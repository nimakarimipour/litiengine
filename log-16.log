====================
Type='FIELD_NO_INIT', message='@NonNull static field gameLoop not initialized'
/home/nima/Developer/nullness-benchmarks/litiengine/src/de/gurkenlabs/litiengine/Game.java:86
  private static GameLoop gameLoop;
Log:
11:53:20.446 TRACE edu.ucr.cs.riple.core.checkers.nullaway.NullAway.lambda$resolveRemainingErrors$19
==============================
11:53:20.446 TRACE edu.ucr.cs.riple.core.checkers.nullaway.NullAway.lambda$resolveRemainingErrors$19
CHATGPT.COUNT = 13
11:53:20.446 TRACE edu.ucr.cs.riple.core.checkers.nullaway.NullAway.lambda$resolveRemainingErrors$19
CHATGPT.PROMPTS SIZE = 13
11:53:20.446 TRACE edu.ucr.cs.riple.core.checkers.nullaway.NullAway.lambda$resolveRemainingErrors$19
Both set to 0 and cleared 0
11:53:20.446 TRACE edu.ucr.cs.riple.core.checkers.nullaway.NullAway.lambda$resolveRemainingErrors$19
16 : TOP LEVEL CALL TO FIX ERROR: Type='FIELD_NO_INIT', message='@NonNull static field gameLoop not initialized'
/home/nima/Developer/nullness-benchmarks/litiengine/src/de/gurkenlabs/litiengine/Game.java:86
  private static GameLoop gameLoop;
11:53:21.983 TRACE edu.ucr.cs.riple.core.checkers.nullaway.codefix.AdvancedNullAwayCodeFix.fix
Fixing error: Type='FIELD_NO_INIT', message='@NonNull static field gameLoop not initialized'
/home/nima/Developer/nullness-benchmarks/litiengine/src/de/gurkenlabs/litiengine/Game.java:86
  private static GameLoop gameLoop;
11:53:21.983 TRACE edu.ucr.cs.riple.core.checkers.nullaway.codefix.AdvancedNullAwayCodeFix.resolveUninitializedField
Resolving uninitialized field errors for fields: [gameLoop]
11:53:21.983 TRACE edu.ucr.cs.riple.core.checkers.nullaway.codefix.AdvancedNullAwayCodeFix.resolveUninitializedField
Working on field: gameLoop
11:53:21.983 TRACE edu.ucr.cs.riple.core.checkers.nullaway.codefix.AdvancedNullAwayCodeFix.investigateFieldNullability
Investigating field nullability.
11:53:21.983 TRACE edu.ucr.cs.riple.core.checkers.nullaway.codefix.AdvancedNullAwayCodeFix.investigateFieldNullability
Checking if there is any method initializing field: gameLoop
11:53:21.986 TRACE edu.ucr.cs.riple.core.checkers.nullaway.codefix.AdvancedNullAwayCodeFix.resolveUninitializedField
Trying to fix errors for making the field nullable
11:53:21.986 TRACE edu.ucr.cs.riple.core.checkers.nullaway.codefix.AdvancedNullAwayCodeFix.lambda$resolveUninitializedField$2
Working on triggered error: Type='DEREFERENCE_NULLABLE', message='dereferenced expression gameLoop is @Nullable'
/home/nima/Developer/nullness-benchmarks/litiengine/src/de/gurkenlabs/litiengine/Game.java:623
    gameLoop.terminate();
11:53:21.986 TRACE edu.ucr.cs.riple.core.checkers.nullaway.codefix.AdvancedNullAwayCodeFix.fix
Fixing error: Type='DEREFERENCE_NULLABLE', message='dereferenced expression gameLoop is @Nullable'
/home/nima/Developer/nullness-benchmarks/litiengine/src/de/gurkenlabs/litiengine/Game.java:623
    gameLoop.terminate();
11:53:21.986 TRACE edu.ucr.cs.riple.core.checkers.nullaway.codefix.AdvancedNullAwayCodeFix.resolveDereferenceError
Resolving dereference error: Type='DEREFERENCE_NULLABLE', message='dereferenced expression gameLoop is @Nullable'
/home/nima/Developer/nullness-benchmarks/litiengine/src/de/gurkenlabs/litiengine/Game.java:623
    gameLoop.terminate();
11:53:21.986 TRACE edu.ucr.cs.riple.core.checkers.nullaway.codefix.AdvancedNullAwayCodeFix.resolveDereferenceError
Checking nullability possibility at error point
11:53:21.988 TRACE edu.ucr.cs.riple.core.checkers.nullaway.codefix.ChatGPT.checkNullabilityPossibilityAtErrorPoint
Asking if the expression can be null at error point point
11:53:21.988 TRACE edu.ucr.cs.riple.core.checkers.nullaway.codefix.ChatGPT.ask
Asking ChatGPT:
In the method below, is there a possibility that the expression "gameLoop" at line "gameLoop.terminate();" is null?
static synchronized void terminate() {
    if (!initialized) {
      return;
    }

    hasStarted = false;
    initialized = false;

    config().save();
    gameLoop.terminate();
    tweenEngine.terminate();
    soundEngine.terminate();

    world().clear();

    for (final GameListener listener : gameListeners) {
      try {
        listener.terminated();
      } catch (Exception e) {
        log().log(Level.WARNING, "game listener threw an exception during shutdown", e);
      }
    }

    gameLoop = null;
    screenManager = null;
    gameWindow = null;
}
Give a single-word answer in XML format. If it is possible for the expression to be null, respond with:
```xml
<response>
    <reason><![CDATA[YOUR REASON]]></reason>
    <value>YES</value>
</response>
```
If it is not possible for the expression to be null, respond with:
```xml
<response>
    <reason><![CDATA[YOUR REASON]]></reason>
    <value>NO</value>
</response>
```
If you are unsure or need more information, respond with where you can ask for more details or what specific information you need.

If additional information is required, list each request inside a `<request>` tag. If no additional information is needed, omit the `<requests>` section.

Respond with:
```xml
<response>
    <reason><![CDATA[YOUR REASON]]></reason>
    <value>UNKNOWN</value>
    <!-- Include <requests> only if additional information is needed -->
    <requests>
        <request><![CDATA[YOUR REQUEST 1]]></request>
        <request><![CDATA[YOUR REQUEST 2]]></request>
    </requests>
</response>
```
11:53:21.988 TRACE edu.ucr.cs.riple.core.checkers.nullaway.codefix.ChatGPT.ask
Retrieving response from cache
11:53:21.988 TRACE edu.ucr.cs.riple.core.checkers.nullaway.codefix.Response.tryCreate
Trying to create Response:
```xml
<response>
    <reason><![CDATA[The code snippet does not show any condition or assignment that ensures gameLoop is non-null before calling gameLoop.terminate(). Without additional context or guarantees from other parts of the code, it's possible that gameLoop could be null.]]></reason>
    <value>YES</value>
</response>
```
11:53:21.989 TRACE edu.ucr.cs.riple.core.checkers.nullaway.codefix.Response.<init>
Creating Response:
```xml
<response>
    <reason><![CDATA[The code snippet does not show any condition or assignment that ensures gameLoop is non-null before calling gameLoop.terminate(). Without additional context or guarantees from other parts of the code, it's possible that gameLoop could be null.]]></reason>
    <value>YES</value>
</response>
```
11:53:21.989 TRACE edu.ucr.cs.riple.core.checkers.nullaway.codefix.Response.<init>
Response created:
Agreement: The code snippet does not show any condition or assignment that ensures gameLoop is non-null before calling gameLoop.terminate(). Without additional context or guarantees from other parts of the code, it's possible that gameLoop could be null.
11:53:21.992 TRACE edu.ucr.cs.riple.core.checkers.nullaway.codefix.AdvancedNullAwayCodeFix.investigateFieldNullability
Investigating field nullability.
11:53:21.992 TRACE edu.ucr.cs.riple.core.checkers.nullaway.codefix.AdvancedNullAwayCodeFix.investigateFieldNullability
Checking if there is any method initializing field: gameLoop
11:53:21.994 TRACE edu.ucr.cs.riple.core.checkers.nullaway.codefix.AdvancedNullAwayCodeFix.resolveFieldNullabilityError
Trying to fix errors for making the field nullable
11:53:21.994 TRACE edu.ucr.cs.riple.core.checkers.nullaway.codefix.AdvancedNullAwayCodeFix.fixErrorByRegions
Fixing error by regions.
11:53:21.994 TRACE edu.ucr.cs.riple.core.checkers.nullaway.codefix.AdvancedNullAwayCodeFix.fixErrorByRegions
Safe regions: 3 - Unsafe regions: 4
11:53:21.994 TRACE edu.ucr.cs.riple.core.checkers.nullaway.codefix.ChatGPT.fixDereferenceErrorBySafeRegions
Attempting to fix dereference error by using safe regions
11:53:21.999 TRACE edu.ucr.cs.riple.core.checkers.nullaway.codefix.ChatGPT.fixDereferenceErrorBySafeRegions
Asking if the error can be fixed by using safe regions
11:53:21.999 TRACE edu.ucr.cs.riple.core.checkers.nullaway.codefix.ChatGPT.ask
Asking ChatGPT:
I want to resolve a warning reported by NullAway.
I am getting the error that in line:     gameLoop.terminate();, the dereferenced expression gameLoop is @Nullable and can produce Null Pointer Exception. In the method below:
static synchronized void terminate() {
    if (!initialized) {
      return;
    }

    hasStarted = false;
    initialized = false;

    config().save();
    gameLoop.terminate();
    tweenEngine.terminate();
    soundEngine.terminate();

    world().clear();

    for (final GameListener listener : gameListeners) {
      try {
        listener.terminated();
      } catch (Exception e) {
        log().log(Level.WARNING, "game listener threw an exception during shutdown", e);
      }
    }

    gameLoop = null;
    screenManager = null;
    gameWindow = null;
}
I am going to show you a couple of other examples in my codebase where the dereferenced expression is used in a way that cannot produce Null Pointer Exception.
Here are the examples(s):
private Game() {
    throw new UnsupportedOperationException();
}
public static synchronized void init(String... args) {
    if (initialized) {
      log().log(Level.INFO, "The game has already been initialized.");
      return;
    }

    log.init();
    handleCommandLineArguments(args);

    config().load();
    Locale.setDefault(new Locale(config().client().getCountry(), config().client().getLanguage()));

    gameLoop = new GameLoop("Main Update Loop", config().client().getMaxFps());
    loop().attach(physics());
    loop().attach(world());

    // setup default exception handling for render and update loop
    setUncaughtExceptionHandler(
        new DefaultUncaughtExceptionHandler(config().client().exitOnError()));

    screenManager = new ScreenManager();
    gameWindow = new GameWindow();

    // initialize  the game window
    window().init();
    world.setCamera(new Camera());

    for (GameListener listener : gameListeners) {
      listener.initialized(args);
    }

    if (!isInNoGUIMode()) {
      window().getRenderComponent().onRendered(g -> metrics().render(g));

      graphics()
          .addEntityRenderedListener(
              e -> DebugRenderer.renderEntityDebugInfo(e.getGraphics(), e.getEntity()));

      window().getRenderComponent().onFpsChanged(fps -> metrics().setFramesPerSecond(fps));
      window()
          .setIcons(
              Arrays.asList(
                  Resources.images().get("liti-logo-x16.png"),
                  Resources.images().get("liti-logo-x20.png"),
                  Resources.images().get("liti-logo-x32.png"),
                  Resources.images().get("liti-logo-x48.png")));

      Input.keyboard()
          .onKeyTyped(
              KeyEvent.VK_PRINTSCREEN,
              key -> {
                // don't take a screenshot if a modifier is active
                if (key.getModifiers() != 0) {
                  return;
                }

                window().getRenderComponent().takeScreenshot();
              });
    }

    Runtime.getRuntime().addShutdownHook(new Thread(Game::terminate, "Shutdown"));

    initialized = true;
}
Given the examples above, I want you to fix the error in the original method by using the same pattern as in the examples.
If you can fix the error, please provide the fixed code snippet in XML format. I just need the XML response, no other information is needed. If you can provide the fixed code snippet, please provide it in the following format and place the code snippet in the <code> tag within ```java block.
For example,
<response>
  <success>true</success>
  <code>
  <![CDATA[
  ```java
  Your fixed code snippet here, JUST THE METHOD.
  ```
    ]]>
  </code>
</response>
Or if you cannot fix the error, please provide the reason in XML format.
<response>
  <success>false</success>
</response>

11:53:22.000 TRACE edu.ucr.cs.riple.core.checkers.nullaway.codefix.ChatGPT.ask
Retrieving response from cache
11:53:22.000 TRACE edu.ucr.cs.riple.core.checkers.nullaway.codefix.Response.tryCreate
Trying to create Response:
```xml
<response>
  <success>true</success>
  <code>
  <![CDATA[
  ```java
  static synchronized void terminate() {
      if (!initialized || gameLoop == null) {
        return;
      }
  
      hasStarted = false;
      initialized = false;
  
      config().save();
      gameLoop.terminate();
      tweenEngine.terminate();
      soundEngine.terminate();
  
      world().clear();
  
      for (final GameListener listener : gameListeners) {
        try {
          listener.terminated();
        } catch (Exception e) {
          log().log(Level.WARNING, "game listener threw an exception during shutdown", e);
        }
      }
  
      gameLoop = null;
      screenManager = null;
      gameWindow = null;
  }
  ```
  ]]>
  </code>
</response>
```
11:53:22.000 TRACE edu.ucr.cs.riple.core.checkers.nullaway.codefix.Response.<init>
Creating Response:
```xml
<response>
  <success>true</success>
  <code>
  <![CDATA[
  ```java
  static synchronized void terminate() {
      if (!initialized || gameLoop == null) {
        return;
      }
  
      hasStarted = false;
      initialized = false;
  
      config().save();
      gameLoop.terminate();
      tweenEngine.terminate();
      soundEngine.terminate();
  
      world().clear();
  
      for (final GameListener listener : gameListeners) {
        try {
          listener.terminated();
        } catch (Exception e) {
          log().log(Level.WARNING, "game listener threw an exception during shutdown", e);
        }
      }
  
      gameLoop = null;
      screenManager = null;
      gameWindow = null;
  }
  ```
  ]]>
  </code>
</response>
```
11:53:22.001 TRACE edu.ucr.cs.riple.core.checkers.nullaway.codefix.Response.<init>
Response created:
static synchronized void terminate() {
      if (!initialized || gameLoop == null) {
        return;
      }
  
      hasStarted = false;
      initialized = false;
  
      config().save();
      gameLoop.terminate();
      tweenEngine.terminate();
      soundEngine.terminate();
  
      world().clear();
  
      for (final GameListener listener : gameListeners) {
        try {
          listener.terminated();
        } catch (Exception e) {
          log().log(Level.WARNING, "game listener threw an exception during shutdown", e);
        }
      }
  
      gameLoop = null;
      screenManager = null;
      gameWindow = null;
  }
11:53:22.001 TRACE edu.ucr.cs.riple.core.checkers.nullaway.codefix.ChatGPT.fixDereferenceErrorBySafeRegions
Fixing the error by using safe regions with code:
static synchronized void terminate() {
      if (!initialized || gameLoop == null) {
        return;
      }
  
      hasStarted = false;
      initialized = false;
  
      config().save();
      gameLoop.terminate();
      tweenEngine.terminate();
      soundEngine.terminate();
  
      world().clear();
  
      for (final GameListener listener : gameListeners) {
        try {
          listener.terminated();
        } catch (Exception e) {
          log().log(Level.WARNING, "game listener threw an exception during shutdown", e);
        }
      }
  
      gameLoop = null;
      screenManager = null;
      gameWindow = null;
  }
11:53:22.001 TRACE edu.ucr.cs.riple.core.checkers.nullaway.codefix.AdvancedNullAwayCodeFix.fixErrorByRegions
Successfully generated a fix for the error.
11:53:22.005 TRACE edu.ucr.cs.riple.core.checkers.nullaway.codefix.AdvancedNullAwayCodeFix.fixErrorByRegions
Fixing error by regions.
11:53:22.005 TRACE edu.ucr.cs.riple.core.checkers.nullaway.codefix.AdvancedNullAwayCodeFix.fixErrorByRegions
Safe regions: 3 - Unsafe regions: 4
11:53:22.005 TRACE edu.ucr.cs.riple.core.checkers.nullaway.codefix.ChatGPT.fixDereferenceErrorBySafeRegions
Attempting to fix dereference error by using safe regions
11:53:22.011 TRACE edu.ucr.cs.riple.core.checkers.nullaway.codefix.ChatGPT.fixDereferenceErrorBySafeRegions
Asking if the error can be fixed by using safe regions
11:53:22.011 TRACE edu.ucr.cs.riple.core.checkers.nullaway.codefix.ChatGPT.ask
Asking ChatGPT:
I want to resolve a warning reported by NullAway.
I am getting the error that in line:     gameLoop.setUncaughtExceptionHandler(uncaughtExceptionHandler);, the dereferenced expression gameLoop is @Nullable and can produce Null Pointer Exception. In the method below:
public static void setUncaughtExceptionHandler(
      UncaughtExceptionHandler uncaughtExceptionHandler) {
    gameLoop.setUncaughtExceptionHandler(uncaughtExceptionHandler);
    Thread.setDefaultUncaughtExceptionHandler(uncaughtExceptionHandler);
}
I am going to show you a couple of other examples in my codebase where the dereferenced expression is used in a way that cannot produce Null Pointer Exception.
Here are the examples(s):
private Game() {
    throw new UnsupportedOperationException();
}
public static synchronized void init(String... args) {
    if (initialized) {
      log().log(Level.INFO, "The game has already been initialized.");
      return;
    }

    log.init();
    handleCommandLineArguments(args);

    config().load();
    Locale.setDefault(new Locale(config().client().getCountry(), config().client().getLanguage()));

    gameLoop = new GameLoop("Main Update Loop", config().client().getMaxFps());
    loop().attach(physics());
    loop().attach(world());

    // setup default exception handling for render and update loop
    setUncaughtExceptionHandler(
        new DefaultUncaughtExceptionHandler(config().client().exitOnError()));

    screenManager = new ScreenManager();
    gameWindow = new GameWindow();

    // initialize  the game window
    window().init();
    world.setCamera(new Camera());

    for (GameListener listener : gameListeners) {
      listener.initialized(args);
    }

    if (!isInNoGUIMode()) {
      window().getRenderComponent().onRendered(g -> metrics().render(g));

      graphics()
          .addEntityRenderedListener(
              e -> DebugRenderer.renderEntityDebugInfo(e.getGraphics(), e.getEntity()));

      window().getRenderComponent().onFpsChanged(fps -> metrics().setFramesPerSecond(fps));
      window()
          .setIcons(
              Arrays.asList(
                  Resources.images().get("liti-logo-x16.png"),
                  Resources.images().get("liti-logo-x20.png"),
                  Resources.images().get("liti-logo-x32.png"),
                  Resources.images().get("liti-logo-x48.png")));

      Input.keyboard()
          .onKeyTyped(
              KeyEvent.VK_PRINTSCREEN,
              key -> {
                // don't take a screenshot if a modifier is active
                if (key.getModifiers() != 0) {
                  return;
                }

                window().getRenderComponent().takeScreenshot();
              });
    }

    Runtime.getRuntime().addShutdownHook(new Thread(Game::terminate, "Shutdown"));

    initialized = true;
}
Given the examples above, I want you to fix the error in the original method by using the same pattern as in the examples.
If you can fix the error, please provide the fixed code snippet in XML format. I just need the XML response, no other information is needed. If you can provide the fixed code snippet, please provide it in the following format and place the code snippet in the <code> tag within ```java block.
For example,
<response>
  <success>true</success>
  <code>
  <![CDATA[
  ```java
  Your fixed code snippet here, JUST THE METHOD.
  ```
    ]]>
  </code>
</response>
Or if you cannot fix the error, please provide the reason in XML format.
<response>
  <success>false</success>
</response>

11:53:22.011 TRACE edu.ucr.cs.riple.core.checkers.nullaway.codefix.ChatGPT.ask
Retrieving response from cache
11:53:22.011 TRACE edu.ucr.cs.riple.core.checkers.nullaway.codefix.Response.tryCreate
Trying to create Response:
```xml
<response>
  <success>true</success>
  <code>
  <![CDATA[
  ```java
  public static synchronized void setUncaughtExceptionHandler(
      UncaughtExceptionHandler uncaughtExceptionHandler) {
    if (gameLoop != null) {
      gameLoop.setUncaughtExceptionHandler(uncaughtExceptionHandler);
    }
    Thread.setDefaultUncaughtExceptionHandler(uncaughtExceptionHandler);
  }
  ```
  ]]>
  </code>
</response>
```
11:53:22.011 TRACE edu.ucr.cs.riple.core.checkers.nullaway.codefix.Response.<init>
Creating Response:
```xml
<response>
  <success>true</success>
  <code>
  <![CDATA[
  ```java
  public static synchronized void setUncaughtExceptionHandler(
      UncaughtExceptionHandler uncaughtExceptionHandler) {
    if (gameLoop != null) {
      gameLoop.setUncaughtExceptionHandler(uncaughtExceptionHandler);
    }
    Thread.setDefaultUncaughtExceptionHandler(uncaughtExceptionHandler);
  }
  ```
  ]]>
  </code>
</response>
```
11:53:22.012 TRACE edu.ucr.cs.riple.core.checkers.nullaway.codefix.Response.<init>
Response created:
public static synchronized void setUncaughtExceptionHandler(
      UncaughtExceptionHandler uncaughtExceptionHandler) {
    if (gameLoop != null) {
      gameLoop.setUncaughtExceptionHandler(uncaughtExceptionHandler);
    }
    Thread.setDefaultUncaughtExceptionHandler(uncaughtExceptionHandler);
  }
11:53:22.012 TRACE edu.ucr.cs.riple.core.checkers.nullaway.codefix.ChatGPT.fixDereferenceErrorBySafeRegions
Fixing the error by using safe regions with code:
public static synchronized void setUncaughtExceptionHandler(
      UncaughtExceptionHandler uncaughtExceptionHandler) {
    if (gameLoop != null) {
      gameLoop.setUncaughtExceptionHandler(uncaughtExceptionHandler);
    }
    Thread.setDefaultUncaughtExceptionHandler(uncaughtExceptionHandler);
  }
11:53:22.012 TRACE edu.ucr.cs.riple.core.checkers.nullaway.codefix.AdvancedNullAwayCodeFix.fixErrorByRegions
Successfully generated a fix for the error.
11:53:22.016 TRACE edu.ucr.cs.riple.core.checkers.nullaway.codefix.AdvancedNullAwayCodeFix.fixErrorByRegions
Fixing error by regions.
11:53:22.016 TRACE edu.ucr.cs.riple.core.checkers.nullaway.codefix.AdvancedNullAwayCodeFix.fixErrorByRegions
Safe regions: 3 - Unsafe regions: 4
11:53:22.016 TRACE edu.ucr.cs.riple.core.checkers.nullaway.codefix.ChatGPT.fixDereferenceErrorBySafeRegions
Attempting to fix dereference error by using safe regions
11:53:22.021 TRACE edu.ucr.cs.riple.core.checkers.nullaway.codefix.ChatGPT.fixDereferenceErrorBySafeRegions
Asking if the error can be fixed by using safe regions
11:53:22.022 TRACE edu.ucr.cs.riple.core.checkers.nullaway.codefix.ChatGPT.ask
Asking ChatGPT:
I want to resolve a warning reported by NullAway.
I am getting the error that in line:     gameLoop.start();, the dereferenced expression gameLoop is @Nullable and can produce Null Pointer Exception. In the method below:
public static synchronized void start() {
    if (!initialized) {
      throw new IllegalStateException(
          "The game cannot be started without being first initialized. Call Game.init(...) before Game.start().");
    }

    gameLoop.start();
    tweenEngine.start();
    soundEngine.start();

    for (final GameListener listener : gameListeners) {
      listener.started();
    }

    hasStarted = true;
}
I am going to show you a couple of other examples in my codebase where the dereferenced expression is used in a way that cannot produce Null Pointer Exception.
Here are the examples(s):
private Game() {
    throw new UnsupportedOperationException();
}
public static synchronized void init(String... args) {
    if (initialized) {
      log().log(Level.INFO, "The game has already been initialized.");
      return;
    }

    log.init();
    handleCommandLineArguments(args);

    config().load();
    Locale.setDefault(new Locale(config().client().getCountry(), config().client().getLanguage()));

    gameLoop = new GameLoop("Main Update Loop", config().client().getMaxFps());
    loop().attach(physics());
    loop().attach(world());

    // setup default exception handling for render and update loop
    setUncaughtExceptionHandler(
        new DefaultUncaughtExceptionHandler(config().client().exitOnError()));

    screenManager = new ScreenManager();
    gameWindow = new GameWindow();

    // initialize  the game window
    window().init();
    world.setCamera(new Camera());

    for (GameListener listener : gameListeners) {
      listener.initialized(args);
    }

    if (!isInNoGUIMode()) {
      window().getRenderComponent().onRendered(g -> metrics().render(g));

      graphics()
          .addEntityRenderedListener(
              e -> DebugRenderer.renderEntityDebugInfo(e.getGraphics(), e.getEntity()));

      window().getRenderComponent().onFpsChanged(fps -> metrics().setFramesPerSecond(fps));
      window()
          .setIcons(
              Arrays.asList(
                  Resources.images().get("liti-logo-x16.png"),
                  Resources.images().get("liti-logo-x20.png"),
                  Resources.images().get("liti-logo-x32.png"),
                  Resources.images().get("liti-logo-x48.png")));

      Input.keyboard()
          .onKeyTyped(
              KeyEvent.VK_PRINTSCREEN,
              key -> {
                // don't take a screenshot if a modifier is active
                if (key.getModifiers() != 0) {
                  return;
                }

                window().getRenderComponent().takeScreenshot();
              });
    }

    Runtime.getRuntime().addShutdownHook(new Thread(Game::terminate, "Shutdown"));

    initialized = true;
}
Given the examples above, I want you to fix the error in the original method by using the same pattern as in the examples.
If you can fix the error, please provide the fixed code snippet in XML format. I just need the XML response, no other information is needed. If you can provide the fixed code snippet, please provide it in the following format and place the code snippet in the <code> tag within ```java block.
For example,
<response>
  <success>true</success>
  <code>
  <![CDATA[
  ```java
  Your fixed code snippet here, JUST THE METHOD.
  ```
    ]]>
  </code>
</response>
Or if you cannot fix the error, please provide the reason in XML format.
<response>
  <success>false</success>
</response>

11:53:22.022 TRACE edu.ucr.cs.riple.core.checkers.nullaway.codefix.ChatGPT.ask
Retrieving response from cache
11:53:22.022 TRACE edu.ucr.cs.riple.core.checkers.nullaway.codefix.Response.tryCreate
Trying to create Response:
```xml
<response>
  <success>true</success>
  <code>
  <![CDATA[
  ```java
  public static synchronized void start() {
      if (!initialized) {
          throw new IllegalStateException(
              "The game cannot be started without being first initialized. Call Game.init(...) before Game.start().");
      }

      if (gameLoop == null) {
          throw new IllegalStateException(
              "Game loop is not initialized. Ensure Game.init(...) has been called successfully.");
      }
      
      gameLoop.start();
      tweenEngine.start();
      soundEngine.start();

      for (final GameListener listener : gameListeners) {
          listener.started();
      }

      hasStarted = true;
  }
  ```
  ]]>
  </code>
</response>
```
11:53:22.022 TRACE edu.ucr.cs.riple.core.checkers.nullaway.codefix.Response.<init>
Creating Response:
```xml
<response>
  <success>true</success>
  <code>
  <![CDATA[
  ```java
  public static synchronized void start() {
      if (!initialized) {
          throw new IllegalStateException(
              "The game cannot be started without being first initialized. Call Game.init(...) before Game.start().");
      }

      if (gameLoop == null) {
          throw new IllegalStateException(
              "Game loop is not initialized. Ensure Game.init(...) has been called successfully.");
      }
      
      gameLoop.start();
      tweenEngine.start();
      soundEngine.start();

      for (final GameListener listener : gameListeners) {
          listener.started();
      }

      hasStarted = true;
  }
  ```
  ]]>
  </code>
</response>
```
11:53:22.023 TRACE edu.ucr.cs.riple.core.checkers.nullaway.codefix.Response.<init>
Response created:
public static synchronized void start() {
      if (!initialized) {
          throw new IllegalStateException(
              "The game cannot be started without being first initialized. Call Game.init(...) before Game.start().");
      }

      if (gameLoop == null) {
          throw new IllegalStateException(
              "Game loop is not initialized. Ensure Game.init(...) has been called successfully.");
      }
      
      gameLoop.start();
      tweenEngine.start();
      soundEngine.start();

      for (final GameListener listener : gameListeners) {
          listener.started();
      }

      hasStarted = true;
  }
11:53:22.023 TRACE edu.ucr.cs.riple.core.checkers.nullaway.codefix.ChatGPT.fixDereferenceErrorBySafeRegions
Fixing the error by using safe regions with code:
public static synchronized void start() {
      if (!initialized) {
          throw new IllegalStateException(
              "The game cannot be started without being first initialized. Call Game.init(...) before Game.start().");
      }

      if (gameLoop == null) {
          throw new IllegalStateException(
              "Game loop is not initialized. Ensure Game.init(...) has been called successfully.");
      }
      
      gameLoop.start();
      tweenEngine.start();
      soundEngine.start();

      for (final GameListener listener : gameListeners) {
          listener.started();
      }

      hasStarted = true;
  }
11:53:22.023 TRACE edu.ucr.cs.riple.core.checkers.nullaway.codefix.AdvancedNullAwayCodeFix.fixErrorByRegions
Successfully generated a fix for the error.
11:53:22.027 TRACE edu.ucr.cs.riple.core.checkers.nullaway.codefix.AdvancedNullAwayCodeFix.lambda$resolveUninitializedField$2
Working on triggered error: Type='DEREFERENCE_NULLABLE', message='dereferenced expression gameLoop is @Nullable'
/home/nima/Developer/nullness-benchmarks/litiengine/src/de/gurkenlabs/litiengine/Game.java:514
    gameLoop.setUncaughtExceptionHandler(uncaughtExceptionHandler);
11:53:22.027 TRACE edu.ucr.cs.riple.core.checkers.nullaway.codefix.AdvancedNullAwayCodeFix.fix
Fixing error: Type='DEREFERENCE_NULLABLE', message='dereferenced expression gameLoop is @Nullable'
/home/nima/Developer/nullness-benchmarks/litiengine/src/de/gurkenlabs/litiengine/Game.java:514
    gameLoop.setUncaughtExceptionHandler(uncaughtExceptionHandler);
11:53:22.027 TRACE edu.ucr.cs.riple.core.checkers.nullaway.codefix.AdvancedNullAwayCodeFix.resolveDereferenceError
Resolving dereference error: Type='DEREFERENCE_NULLABLE', message='dereferenced expression gameLoop is @Nullable'
/home/nima/Developer/nullness-benchmarks/litiengine/src/de/gurkenlabs/litiengine/Game.java:514
    gameLoop.setUncaughtExceptionHandler(uncaughtExceptionHandler);
11:53:22.027 TRACE edu.ucr.cs.riple.core.checkers.nullaway.codefix.AdvancedNullAwayCodeFix.resolveDereferenceError
Checking nullability possibility at error point
11:53:22.029 TRACE edu.ucr.cs.riple.core.checkers.nullaway.codefix.ChatGPT.checkNullabilityPossibilityAtErrorPoint
Asking if the expression can be null at error point point
11:53:22.029 TRACE edu.ucr.cs.riple.core.checkers.nullaway.codefix.ChatGPT.ask
Asking ChatGPT:
In the method below, is there a possibility that the expression "gameLoop" at line "gameLoop.setUncaughtExceptionHandler(uncaughtExceptionHandler);" is null?
public static synchronized void setUncaughtExceptionHandler(
        UncaughtExceptionHandler uncaughtExceptionHandler) {
      if (gameLoop != null) {
        gameLoop.setUncaughtExceptionHandler(uncaughtExceptionHandler);
      }
      Thread.setDefaultUncaughtExceptionHandler(uncaughtExceptionHandler);
}
Give a single-word answer in XML format. If it is possible for the expression to be null, respond with:
```xml
<response>
    <reason><![CDATA[YOUR REASON]]></reason>
    <value>YES</value>
</response>
```
If it is not possible for the expression to be null, respond with:
```xml
<response>
    <reason><![CDATA[YOUR REASON]]></reason>
    <value>NO</value>
</response>
```
If you are unsure or need more information, respond with where you can ask for more details or what specific information you need.

If additional information is required, list each request inside a `<request>` tag. If no additional information is needed, omit the `<requests>` section.

Respond with:
```xml
<response>
    <reason><![CDATA[YOUR REASON]]></reason>
    <value>UNKNOWN</value>
    <!-- Include <requests> only if additional information is needed -->
    <requests>
        <request><![CDATA[YOUR REQUEST 1]]></request>
        <request><![CDATA[YOUR REQUEST 2]]></request>
    </requests>
</response>
```
11:53:22.029 TRACE edu.ucr.cs.riple.core.checkers.nullaway.codefix.ChatGPT.ask
Retrieving response from cache
11:53:22.029 TRACE edu.ucr.cs.riple.core.checkers.nullaway.codefix.Response.tryCreate
Trying to create Response:
```xml
<response>
    <reason><![CDATA[The method includes a null check for gameLoop before calling setUncaughtExceptionHandler, ensuring that the method is only called when gameLoop is not null.]]></reason>
    <value>NO</value>
</response>
```
11:53:22.029 TRACE edu.ucr.cs.riple.core.checkers.nullaway.codefix.Response.<init>
Creating Response:
```xml
<response>
    <reason><![CDATA[The method includes a null check for gameLoop before calling setUncaughtExceptionHandler, ensuring that the method is only called when gameLoop is not null.]]></reason>
    <value>NO</value>
</response>
```
11:53:22.029 TRACE edu.ucr.cs.riple.core.checkers.nullaway.codefix.Response.<init>
Response created:
Disagreement: The method includes a null check for gameLoop before calling setUncaughtExceptionHandler, ensuring that the method is only called when gameLoop is not null.
11:53:22.030 TRACE edu.ucr.cs.riple.core.checkers.nullaway.codefix.AdvancedNullAwayCodeFix.resolveDereferenceError
False positive detected.
11:53:22.030 TRACE edu.ucr.cs.riple.core.checkers.nullaway.codefix.AdvancedNullAwayCodeFix.constructCastToNonnullChange
Constructing cast to nonnull change for reason: The method includes a null check for gameLoop before calling setUncaughtExceptionHandler, ensuring that the method is only called when gameLoop is not null.
11:53:22.032 TRACE edu.ucr.cs.riple.core.checkers.nullaway.codefix.ChatGPT.ask
Asking ChatGPT:
For the reason you mentioned earlier:

"The method includes a null check for gameLoop before calling setUncaughtExceptionHandler, ensuring that the method is only called when gameLoop is not null."

in the method below, the expression gameLoop is not nullable at the point it is used.

```java
public static synchronized void setUncaughtExceptionHandler(
        UncaughtExceptionHandler uncaughtExceptionHandler) {
      if (gameLoop != null) {
        gameLoop.setUncaughtExceptionHandler(uncaughtExceptionHandler);
      }
      Thread.setDefaultUncaughtExceptionHandler(uncaughtExceptionHandler);
}
```
Please Summarize the reason in max 5 words and rewrite the method so that at the line "    gameLoop.setUncaughtExceptionHandler(uncaughtExceptionHandler);", at the occurrence of: "gameLoop" is replaced with `Nullability.castToNonnull(gameLoop, summary of reason)`
Replace "REASON" with the exact reason summary I provide to you (maximum 5 words), not with a generic explanation like "checked to be nonnull".
see the example below, for expression `foo.getBar()`, to wrap it with `Nullability.castToNonnull(foo.getBar(), "reason")`.

```java
public t(){
    String l = foo.getBar();
}
```

will be:
```java
public t(){
    String l = Nullability.castToNonnull(foo.getBar(), "checked to be nonnull");
}
```

### Instructions:

Do not import any additional classes.

Do not add Java comments.

Only modify relevant lines as required.

Return only the modified method wrapped in the XML format shown below.

Place the Java code inside the <code> tag using a CDATA block with ```java formatting.

Just give me the fixed code snippet in XML format in <response> tag like the example below. I will apply the fix to my codebase. Do not import any additional libraries or classes or add java comments. If you can provide the fixed code snippet, please provide it in the following format and place the code snippet in the <code> tag within ```java block.
<response>
  <success>true</success>
  <code><![CDATA[
  ```java
  Your fixed code snippet here
  ```
    ]]>
  </code>
</response>

11:53:22.032 TRACE edu.ucr.cs.riple.core.checkers.nullaway.codefix.ChatGPT.ask
Retrieving response from cache
11:53:22.032 TRACE edu.ucr.cs.riple.core.checkers.nullaway.codefix.Response.tryCreate
Trying to create Response:
<response>
  <success>true</success>
  <code><![CDATA[
  ```java
public static synchronized void setUncaughtExceptionHandler(
        UncaughtExceptionHandler uncaughtExceptionHandler) {
      if (gameLoop != null) {
        Nullability.castToNonnull(gameLoop, "null checked earlier").setUncaughtExceptionHandler(uncaughtExceptionHandler);
      }
      Thread.setDefaultUncaughtExceptionHandler(uncaughtExceptionHandler);
}
  ```
  ]]>
  </code>
</response>
11:53:22.033 TRACE edu.ucr.cs.riple.core.checkers.nullaway.codefix.Response.<init>
Creating Response:
<response>
  <success>true</success>
  <code><![CDATA[
  ```java
public static synchronized void setUncaughtExceptionHandler(
        UncaughtExceptionHandler uncaughtExceptionHandler) {
      if (gameLoop != null) {
        Nullability.castToNonnull(gameLoop, "null checked earlier").setUncaughtExceptionHandler(uncaughtExceptionHandler);
      }
      Thread.setDefaultUncaughtExceptionHandler(uncaughtExceptionHandler);
}
  ```
  ]]>
  </code>
</response>
11:53:22.033 TRACE edu.ucr.cs.riple.core.checkers.nullaway.codefix.Response.<init>
Response created:
public static synchronized void setUncaughtExceptionHandler(
        UncaughtExceptionHandler uncaughtExceptionHandler) {
      if (gameLoop != null) {
        Nullability.castToNonnull(gameLoop, "null checked earlier").setUncaughtExceptionHandler(uncaughtExceptionHandler);
      }
      Thread.setDefaultUncaughtExceptionHandler(uncaughtExceptionHandler);
}
11:53:22.033 TRACE edu.ucr.cs.riple.core.checkers.nullaway.codefix.ChatGPT.fixDereferenceByAddingCastToNonnull
Fixing the error by adding castToNonnull
11:53:22.038 TRACE edu.ucr.cs.riple.core.checkers.nullaway.codefix.AdvancedNullAwayCodeFix.lambda$resolveUninitializedField$2
Working on triggered error: Type='DEREFERENCE_NULLABLE', message='dereferenced expression gameLoop is @Nullable'
/home/nima/Developer/nullness-benchmarks/litiengine/src/de/gurkenlabs/litiengine/Game.java:541
    gameLoop.start();
11:53:22.038 TRACE edu.ucr.cs.riple.core.checkers.nullaway.codefix.AdvancedNullAwayCodeFix.fix
Fixing error: Type='DEREFERENCE_NULLABLE', message='dereferenced expression gameLoop is @Nullable'
/home/nima/Developer/nullness-benchmarks/litiengine/src/de/gurkenlabs/litiengine/Game.java:541
    gameLoop.start();
11:53:22.038 TRACE edu.ucr.cs.riple.core.checkers.nullaway.codefix.AdvancedNullAwayCodeFix.resolveDereferenceError
Resolving dereference error: Type='DEREFERENCE_NULLABLE', message='dereferenced expression gameLoop is @Nullable'
/home/nima/Developer/nullness-benchmarks/litiengine/src/de/gurkenlabs/litiengine/Game.java:541
    gameLoop.start();
11:53:22.038 TRACE edu.ucr.cs.riple.core.checkers.nullaway.codefix.AdvancedNullAwayCodeFix.resolveDereferenceError
Checking nullability possibility at error point
11:53:22.040 TRACE edu.ucr.cs.riple.core.checkers.nullaway.codefix.ChatGPT.checkNullabilityPossibilityAtErrorPoint
Asking if the expression can be null at error point point
11:53:22.040 TRACE edu.ucr.cs.riple.core.checkers.nullaway.codefix.ChatGPT.ask
Asking ChatGPT:
In the method below, is there a possibility that the expression "gameLoop" at line "gameLoop.start();" is null?
public static synchronized void start() {
        if (!initialized) {
            throw new IllegalStateException(
                "The game cannot be started without being first initialized. Call Game.init(...) before Game.start().");
        }
  
        if (gameLoop == null) {
            throw new IllegalStateException(
                "Game loop is not initialized. Ensure Game.init(...) has been called successfully.");
        }
        
        gameLoop.start();
        tweenEngine.start();
        soundEngine.start();
  
        for (final GameListener listener : gameListeners) {
            listener.started();
        }
  
        hasStarted = true;
}
Give a single-word answer in XML format. If it is possible for the expression to be null, respond with:
```xml
<response>
    <reason><![CDATA[YOUR REASON]]></reason>
    <value>YES</value>
</response>
```
If it is not possible for the expression to be null, respond with:
```xml
<response>
    <reason><![CDATA[YOUR REASON]]></reason>
    <value>NO</value>
</response>
```
If you are unsure or need more information, respond with where you can ask for more details or what specific information you need.

If additional information is required, list each request inside a `<request>` tag. If no additional information is needed, omit the `<requests>` section.

Respond with:
```xml
<response>
    <reason><![CDATA[YOUR REASON]]></reason>
    <value>UNKNOWN</value>
    <!-- Include <requests> only if additional information is needed -->
    <requests>
        <request><![CDATA[YOUR REQUEST 1]]></request>
        <request><![CDATA[YOUR REQUEST 2]]></request>
    </requests>
</response>
```
11:53:22.040 TRACE edu.ucr.cs.riple.core.checkers.nullaway.codefix.ChatGPT.ask
Retrieving response from cache
11:53:22.040 TRACE edu.ucr.cs.riple.core.checkers.nullaway.codefix.Response.tryCreate
Trying to create Response:
```xml
<response>
    <reason><![CDATA[The code explicitly checks if gameLoop is null and throws an exception if it is, thereby ensuring gameLoop cannot be null at the point where gameLoop.start() is called.]]></reason>
    <value>NO</value>
</response>
```
11:53:22.040 TRACE edu.ucr.cs.riple.core.checkers.nullaway.codefix.Response.<init>
Creating Response:
```xml
<response>
    <reason><![CDATA[The code explicitly checks if gameLoop is null and throws an exception if it is, thereby ensuring gameLoop cannot be null at the point where gameLoop.start() is called.]]></reason>
    <value>NO</value>
</response>
```
11:53:22.040 TRACE edu.ucr.cs.riple.core.checkers.nullaway.codefix.Response.<init>
Response created:
Disagreement: The code explicitly checks if gameLoop is null and throws an exception if it is, thereby ensuring gameLoop cannot be null at the point where gameLoop.start() is called.
11:53:22.040 TRACE edu.ucr.cs.riple.core.checkers.nullaway.codefix.AdvancedNullAwayCodeFix.resolveDereferenceError
False positive detected.
11:53:22.040 TRACE edu.ucr.cs.riple.core.checkers.nullaway.codefix.AdvancedNullAwayCodeFix.constructCastToNonnullChange
Constructing cast to nonnull change for reason: The code explicitly checks if gameLoop is null and throws an exception if it is, thereby ensuring gameLoop cannot be null at the point where gameLoop.start() is called.
11:53:22.043 TRACE edu.ucr.cs.riple.core.checkers.nullaway.codefix.ChatGPT.ask
Asking ChatGPT:
For the reason you mentioned earlier:

"The code explicitly checks if gameLoop is null and throws an exception if it is, thereby ensuring gameLoop cannot be null at the point where gameLoop.start() is called."

in the method below, the expression gameLoop is not nullable at the point it is used.

```java
public static synchronized void start() {
        if (!initialized) {
            throw new IllegalStateException(
                "The game cannot be started without being first initialized. Call Game.init(...) before Game.start().");
        }
  
        if (gameLoop == null) {
            throw new IllegalStateException(
                "Game loop is not initialized. Ensure Game.init(...) has been called successfully.");
        }
        
        gameLoop.start();
        tweenEngine.start();
        soundEngine.start();
  
        for (final GameListener listener : gameListeners) {
            listener.started();
        }
  
        hasStarted = true;
}
```
Please Summarize the reason in max 5 words and rewrite the method so that at the line "    gameLoop.start();", at the occurrence of: "gameLoop" is replaced with `Nullability.castToNonnull(gameLoop, summary of reason)`
Replace "REASON" with the exact reason summary I provide to you (maximum 5 words), not with a generic explanation like "checked to be nonnull".
see the example below, for expression `foo.getBar()`, to wrap it with `Nullability.castToNonnull(foo.getBar(), "reason")`.

```java
public t(){
    String l = foo.getBar();
}
```

will be:
```java
public t(){
    String l = Nullability.castToNonnull(foo.getBar(), "checked to be nonnull");
}
```

### Instructions:

Do not import any additional classes.

Do not add Java comments.

Only modify relevant lines as required.

Return only the modified method wrapped in the XML format shown below.

Place the Java code inside the <code> tag using a CDATA block with ```java formatting.

Just give me the fixed code snippet in XML format in <response> tag like the example below. I will apply the fix to my codebase. Do not import any additional libraries or classes or add java comments. If you can provide the fixed code snippet, please provide it in the following format and place the code snippet in the <code> tag within ```java block.
<response>
  <success>true</success>
  <code><![CDATA[
  ```java
  Your fixed code snippet here
  ```
    ]]>
  </code>
</response>

11:53:22.043 TRACE edu.ucr.cs.riple.core.checkers.nullaway.codefix.ChatGPT.ask
Retrieving response from cache
11:53:22.043 TRACE edu.ucr.cs.riple.core.checkers.nullaway.codefix.Response.tryCreate
Trying to create Response:
<response>
  <success>true</success>
  <code><![CDATA[
  ```java
  public static synchronized void start() {
        if (!initialized) {
            throw new IllegalStateException(
                "The game cannot be started without being first initialized. Call Game.init(...) before Game.start().");
        }
  
        if (gameLoop == null) {
            throw new IllegalStateException(
                "Game loop is not initialized. Ensure Game.init(...) has been called successfully.");
        }
        
        Nullability.castToNonnull(gameLoop, "gameLoop cannot be null").start();
        tweenEngine.start();
        soundEngine.start();
  
        for (final GameListener listener : gameListeners) {
            listener.started();
        }
  
        hasStarted = true;
  }
  ```
  ]]>
  </code>
</response>
11:53:22.043 TRACE edu.ucr.cs.riple.core.checkers.nullaway.codefix.Response.<init>
Creating Response:
<response>
  <success>true</success>
  <code><![CDATA[
  ```java
  public static synchronized void start() {
        if (!initialized) {
            throw new IllegalStateException(
                "The game cannot be started without being first initialized. Call Game.init(...) before Game.start().");
        }
  
        if (gameLoop == null) {
            throw new IllegalStateException(
                "Game loop is not initialized. Ensure Game.init(...) has been called successfully.");
        }
        
        Nullability.castToNonnull(gameLoop, "gameLoop cannot be null").start();
        tweenEngine.start();
        soundEngine.start();
  
        for (final GameListener listener : gameListeners) {
            listener.started();
        }
  
        hasStarted = true;
  }
  ```
  ]]>
  </code>
</response>
11:53:22.044 TRACE edu.ucr.cs.riple.core.checkers.nullaway.codefix.Response.<init>
Response created:
public static synchronized void start() {
        if (!initialized) {
            throw new IllegalStateException(
                "The game cannot be started without being first initialized. Call Game.init(...) before Game.start().");
        }
  
        if (gameLoop == null) {
            throw new IllegalStateException(
                "Game loop is not initialized. Ensure Game.init(...) has been called successfully.");
        }
        
        Nullability.castToNonnull(gameLoop, "gameLoop cannot be null").start();
        tweenEngine.start();
        soundEngine.start();
  
        for (final GameListener listener : gameListeners) {
            listener.started();
        }
  
        hasStarted = true;
  }
11:53:22.044 TRACE edu.ucr.cs.riple.core.checkers.nullaway.codefix.ChatGPT.fixDereferenceByAddingCastToNonnull
Fixing the error by adding castToNonnull
11:53:22.048 TRACE edu.ucr.cs.riple.core.checkers.nullaway.codefix.AdvancedNullAwayCodeFix.lambda$resolveUninitializedField$2
Working on triggered error: Type='RETURN_NULLABLE', message='returning @Nullable expression from method with @NonNull return type'
/home/nima/Developer/nullness-benchmarks/litiengine/src/de/gurkenlabs/litiengine/Game.java:348
    return gameLoop;
11:53:22.048 TRACE edu.ucr.cs.riple.core.checkers.nullaway.codefix.AdvancedNullAwayCodeFix.fix
Fixing error: Type='RETURN_NULLABLE', message='returning @Nullable expression from method with @NonNull return type'
/home/nima/Developer/nullness-benchmarks/litiengine/src/de/gurkenlabs/litiengine/Game.java:348
    return gameLoop;
11:53:22.048 TRACE edu.ucr.cs.riple.core.checkers.nullaway.codefix.AdvancedNullAwayCodeFix.resolveNullableReturnError
Checking if the method is actually returning nullable.
11:53:22.050 TRACE edu.ucr.cs.riple.core.checkers.nullaway.codefix.ChatGPT.checkNullabilityPossibilityAtErrorPoint
Asking if the expression can be null at error point point
11:53:22.050 TRACE edu.ucr.cs.riple.core.checkers.nullaway.codefix.ChatGPT.ask
Asking ChatGPT:
In the method below, is there a possibility that the expression "return gameLoop;" at line "return gameLoop;" is null?
public static IGameLoop loop() {
    return gameLoop;
}
Give a single-word answer in XML format. If it is possible for the expression to be null, respond with:
```xml
<response>
    <reason><![CDATA[YOUR REASON]]></reason>
    <value>YES</value>
</response>
```
If it is not possible for the expression to be null, respond with:
```xml
<response>
    <reason><![CDATA[YOUR REASON]]></reason>
    <value>NO</value>
</response>
```
If you are unsure or need more information, respond with where you can ask for more details or what specific information you need.

If additional information is required, list each request inside a `<request>` tag. If no additional information is needed, omit the `<requests>` section.

Respond with:
```xml
<response>
    <reason><![CDATA[YOUR REASON]]></reason>
    <value>UNKNOWN</value>
    <!-- Include <requests> only if additional information is needed -->
    <requests>
        <request><![CDATA[YOUR REQUEST 1]]></request>
        <request><![CDATA[YOUR REQUEST 2]]></request>
    </requests>
</response>
```
11:53:22.050 TRACE edu.ucr.cs.riple.core.checkers.nullaway.codefix.ChatGPT.ask
Retrieving response from cache
11:53:22.050 TRACE edu.ucr.cs.riple.core.checkers.nullaway.codefix.Response.tryCreate
Trying to create Response:
```xml
<response>
    <reason><![CDATA[The possibility of the expression "return gameLoop;" being null depends on the initialization of the "gameLoop" variable, which is not provided in the given method.]]></reason>
    <value>UNKNOWN</value>
    <requests>
        <request><![CDATA[Provide the declaration and initialization code for the "gameLoop" variable.]]></request>
    </requests>
</response>
```
11:53:22.050 TRACE edu.ucr.cs.riple.core.checkers.nullaway.codefix.Response.<init>
Creating Response:
```xml
<response>
    <reason><![CDATA[The possibility of the expression "return gameLoop;" being null depends on the initialization of the "gameLoop" variable, which is not provided in the given method.]]></reason>
    <value>UNKNOWN</value>
    <requests>
        <request><![CDATA[Provide the declaration and initialization code for the "gameLoop" variable.]]></request>
    </requests>
</response>
```
11:53:22.051 TRACE edu.ucr.cs.riple.core.checkers.nullaway.codefix.Response.<init>
Response created:
Unknown: The possibility of the expression "return gameLoop;" being null depends on the initialization of the "gameLoop" variable, which is not provided in the given method.
11:53:22.051 TRACE edu.ucr.cs.riple.core.checkers.nullaway.codefix.AdvancedNullAwayCodeFix.resolveNullableReturnError
Checking if the method is a getter for field.
11:53:22.051 TRACE edu.ucr.cs.riple.core.checkers.nullaway.codefix.AdvancedNullAwayCodeFix.resolveNullableReturnError
Not a getter method.
11:53:22.053 TRACE edu.ucr.cs.riple.core.checkers.nullaway.codefix.AdvancedNullAwayCodeFix.resolveNullableReturnError
Made the method nullable and resolving triggered errors.
11:53:22.053 TRACE edu.ucr.cs.riple.core.checkers.nullaway.codefix.AdvancedNullAwayCodeFix.fixTriggeredErrorsForLocation
Fixing triggered errors for location: OnMethod{method='loop()', clazz='de.gurkenlabs.litiengine.Game'}
11:53:22.053 TRACE edu.ucr.cs.riple.core.checkers.nullaway.codefix.AdvancedNullAwayCodeFix.getTriggeredErrorsFromLocation
Impact not found, re-evaluating the location.
11:53:23.612 TRACE edu.ucr.cs.riple.core.checkers.nullaway.codefix.AdvancedNullAwayCodeFix.fixTriggeredErrorsForLocation
Triggered errors size: 50
11:53:23.612 TRACE edu.ucr.cs.riple.core.checkers.nullaway.codefix.AdvancedNullAwayCodeFix.fixTriggeredErrorsForLocation
Adding annotations for resolvable errors, size: 0
11:53:23.618 TRACE edu.ucr.cs.riple.core.checkers.nullaway.codefix.AdvancedNullAwayCodeFix.fixTriggeredErrorsForLocation
Resolving unresolvable error for triggered error: Type='DEREFERENCE_NULLABLE', message='dereferenced expression Game.loop() is @Nullable'
/home/nima/Developer/nullness-benchmarks/litiengine/src/de/gurkenlabs/litiengine/entities/Creature.java:253
      Game.loop().attach(controller);
11:53:23.618 TRACE edu.ucr.cs.riple.core.checkers.nullaway.codefix.AdvancedNullAwayCodeFix.fix
Fixing error: Type='DEREFERENCE_NULLABLE', message='dereferenced expression Game.loop() is @Nullable'
/home/nima/Developer/nullness-benchmarks/litiengine/src/de/gurkenlabs/litiengine/entities/Creature.java:253
      Game.loop().attach(controller);
11:53:23.618 TRACE edu.ucr.cs.riple.core.checkers.nullaway.codefix.AdvancedNullAwayCodeFix.resolveDereferenceError
Resolving dereference error: Type='DEREFERENCE_NULLABLE', message='dereferenced expression Game.loop() is @Nullable'
/home/nima/Developer/nullness-benchmarks/litiengine/src/de/gurkenlabs/litiengine/entities/Creature.java:253
      Game.loop().attach(controller);
11:53:23.618 TRACE edu.ucr.cs.riple.core.checkers.nullaway.codefix.AdvancedNullAwayCodeFix.resolveDereferenceError
Checking nullability possibility at error point
11:53:23.620 TRACE edu.ucr.cs.riple.core.checkers.nullaway.codefix.ChatGPT.checkNullabilityPossibilityAtErrorPoint
Asking if the expression can be null at error point point
11:53:23.620 TRACE edu.ucr.cs.riple.core.checkers.nullaway.codefix.ChatGPT.ask
Asking ChatGPT:
In the method below, is there a possibility that the expression "Game.loop()" at line "Game.loop().attach(controller);" is null?
protected void updateAnimationController() {
    IEntityAnimationController<?> controller = this.createAnimationController();
    this.getControllers().addController(controller);
    if (Game.world().environment() != null && Game.world().environment().isLoaded()) {
      Game.loop().attach(controller);
    }
}
Give a single-word answer in XML format. If it is possible for the expression to be null, respond with:
```xml
<response>
    <reason><![CDATA[YOUR REASON]]></reason>
    <value>YES</value>
</response>
```
If it is not possible for the expression to be null, respond with:
```xml
<response>
    <reason><![CDATA[YOUR REASON]]></reason>
    <value>NO</value>
</response>
```
If you are unsure or need more information, respond with where you can ask for more details or what specific information you need.

If additional information is required, list each request inside a `<request>` tag. If no additional information is needed, omit the `<requests>` section.

Respond with:
```xml
<response>
    <reason><![CDATA[YOUR REASON]]></reason>
    <value>UNKNOWN</value>
    <!-- Include <requests> only if additional information is needed -->
    <requests>
        <request><![CDATA[YOUR REQUEST 1]]></request>
        <request><![CDATA[YOUR REQUEST 2]]></request>
    </requests>
</response>
```
11:53:23.620 TRACE edu.ucr.cs.riple.core.checkers.nullaway.codefix.ChatGPT.ask
Retrieving response from cache
11:53:23.620 TRACE edu.ucr.cs.riple.core.checkers.nullaway.codefix.Response.tryCreate
Trying to create Response:
```xml
<response>
    <reason><![CDATA[The possibility of Game.loop() being null depends on the implementation of the Game class. Without the specific implementation details of how Game and its loop method are defined and initialized, it cannot be definitively determined whether Game.loop() could return null.]]></reason>
    <value>UNKNOWN</value>
    <requests>
        <request><![CDATA[Need the implementation details of the Game class and how the loop method is initialized.]]></request>
    </requests>
</response>
```
11:53:23.620 TRACE edu.ucr.cs.riple.core.checkers.nullaway.codefix.Response.<init>
Creating Response:
```xml
<response>
    <reason><![CDATA[The possibility of Game.loop() being null depends on the implementation of the Game class. Without the specific implementation details of how Game and its loop method are defined and initialized, it cannot be definitively determined whether Game.loop() could return null.]]></reason>
    <value>UNKNOWN</value>
    <requests>
        <request><![CDATA[Need the implementation details of the Game class and how the loop method is initialized.]]></request>
    </requests>
</response>
```
11:53:23.621 TRACE edu.ucr.cs.riple.core.checkers.nullaway.codefix.Response.<init>
Response created:
Unknown: The possibility of Game.loop() being null depends on the implementation of the Game class. Without the specific implementation details of how Game and its loop method are defined and initialized, it cannot be definitively determined whether Game.loop() could return null.
11:53:23.622 TRACE edu.ucr.cs.riple.core.checkers.nullaway.codefix.AdvancedNullAwayCodeFix.resolveMethodDereferenceError
Resolving method dereference error.
11:53:23.622 TRACE edu.ucr.cs.riple.core.checkers.nullaway.codefix.AdvancedNullAwayCodeFix.resolveMethodDereferenceError
Method is in annotated package. Checking if the method is returning nullable.
11:53:23.622 TRACE edu.ucr.cs.riple.core.checkers.nullaway.codefix.AdvancedNullAwayCodeFix.investigateMethodReturnNullability
Checking if the method is returning nullable.
11:53:23.624 TRACE edu.ucr.cs.riple.core.checkers.nullaway.codefix.ChatGPT.checkIfMethodIsReturningNullable
Asking if the method is returning nullable: loop()
11:53:23.626 TRACE edu.ucr.cs.riple.core.checkers.nullaway.codefix.ChatGPT.ask
Asking ChatGPT:
In the method below, is there a possibility that the method returns null based only on its body? Consider the following points:

- The method may have multiple return paths; consider all return statements.
- If the method calls another method, do not assume its return value unless its full declaration is provided. Request its declaration if needed.
- The method may throw an exception instead of returning null. An exception path should not be considered a null return.
- Ensure you request the declarations of any methods whose return values directly or indirectly impact this methods return value before making a conclusion.
- Carefully analyze all conditions and prior operations that may guarantee a non-null return value.

@Nullable public static IGameLoop loop() {
    return gameLoop;
}

Here are the method definitions in addition to the method inquired:

Depth: 0
```java
class de.gurkenlabs.litiengine.Game {
@Nullable public static IGameLoop loop() {
    return gameLoop;
}
}
```


Response Format:
Provide the answer in **XML format** as follows:

#### If the method **cannot** return `null`:
```xml
<response>
  <reason><![CDATA[EXPLAIN WHY THE METHOD CANNOT RETURN NULL]]></reason>
  <value>NO</value>
</response>
```

#### If the method can return null:
```xml
<response>
  <reason><![CDATA[EXPLAIN WHY THE METHOD CAN RETURN NULL]]></reason>
  <value>YES</value>
</response>
```

#### If you are unsure or need more information, respond with where you can ask for more details or what specific information you need.

#### If you are unsure or If there are any methods that directly or indirectly affect the return value and are not fully disclosed, request their declarations first, in the following format:
<response>
  <reason><![CDATA[YOUR REASON]]></reason>
  <value>UNKNOWN</value>
  <methods>
    <method>methodName</method>
  </methods>
</response>

If additional information is required other than method declaration, list each request inside a `<request>` tag. If no additional information is needed, omit the `<requests>` section.

Respond with:
```xml
<response>
    <reason><![CDATA[YOUR REASON]]></reason>
    <value>UNKNOWN</value>
    <!-- Include <requests> only if additional information is needed -->
    <requests>
        <request><![CDATA[YOUR REQUEST 1]]></request>
        <request><![CDATA[YOUR REQUEST 2]]></request>
    </requests>
</response>
```

Additional Notes:
Be precise in your reasoning.
If a methods return value depends on another method not provided, request its declaration before making a conclusion.
If the method can return null in some cases but not others, explain under what conditions it can happen.

11:53:23.626 TRACE edu.ucr.cs.riple.core.checkers.nullaway.codefix.ChatGPT.ask
Retrieving response from cache
11:53:23.626 TRACE edu.ucr.cs.riple.core.checkers.nullaway.codefix.Response.tryCreate
Trying to create Response:
```xml
<response>
  <reason><![CDATA[The method `loop` returns the variable `gameLoop`. Without the initialization or assignment details of `gameLoop`, it's unclear whether it can be null. The possibility of `gameLoop` being uninitialized or set to null elsewhere in the program means `loop` could potentially return null. Further information on `gameLoop` is required.]]></reason>
  <value>UNKNOWN</value>
  <requests>
    <request><![CDATA[Please provide the declaration and initialization of the variable `gameLoop` in the class `de.gurkenlabs.litiengine.Game`.]]></request>
  </requests>
</response>
```
11:53:23.627 TRACE edu.ucr.cs.riple.core.checkers.nullaway.codefix.Response.<init>
Creating Response:
```xml
<response>
  <reason><![CDATA[The method `loop` returns the variable `gameLoop`. Without the initialization or assignment details of `gameLoop`, it's unclear whether it can be null. The possibility of `gameLoop` being uninitialized or set to null elsewhere in the program means `loop` could potentially return null. Further information on `gameLoop` is required.]]></reason>
  <value>UNKNOWN</value>
  <requests>
    <request><![CDATA[Please provide the declaration and initialization of the variable `gameLoop` in the class `de.gurkenlabs.litiengine.Game`.]]></request>
  </requests>
</response>
```
11:53:23.627 TRACE edu.ucr.cs.riple.core.checkers.nullaway.codefix.Response.<init>
Response created:
Unknown: The method `loop` returns the variable `gameLoop`. Without the initialization or assignment details of `gameLoop`, it's unclear whether it can be null. The possibility of `gameLoop` being uninitialized or set to null elsewhere in the program means `loop` could potentially return null. Further information on `gameLoop` is required.
11:53:23.627 TRACE edu.ucr.cs.riple.core.checkers.nullaway.codefix.AdvancedNullAwayCodeFix.investigateMethodReturnNullability
Could not determine the nullability and model did not ask for any method.
11:53:23.627 TRACE edu.ucr.cs.riple.core.checkers.nullaway.codefix.ChatGPT.checkIfMethodIsReturningNullableOnCallSite
Asking if the method is returning nullable on the call site: Game.loop()
11:53:23.873 TRACE edu.ucr.cs.riple.core.checkers.nullaway.codefix.ChatGPT.ask
Asking ChatGPT:
In the method below, is there a possibility that the method returns null at the given call site?

```java
@Nullable public static IGameLoop loop() {
    return gameLoop;
}
```

## Guidelines:
- The method may have multiple return paths; consider all return statements.
- If the method calls another method, do not assume its return value unless its full declaration is provided. Request its declaration if needed.
- The method may throw an exception instead of returning null. An exception path should not be considered a null return.
- Ensure you request the declarations of any methods whose return values directly or indirectly impact this methods return value before making a conclusion.
- If the method returns a value that is determined by a parameter, evaluate based on the actual argument at the given call site.
- Analyze based only on the specific invocation provided. Do not generalize to all possible inputs.- If the return value is guaranteed to be non-null at the call site, the answer should be a definitive NO.
- Do not generalize based on all possible inputsyour answer must be based only on the given invocation.
- Focus only on the given call site, not all possible invocations.

### call site:
Game.loop()

Here are the method definitions and the call chain for this method, showing the sequence of calls from the method to its callers at each depth level:

Depth: 0
```java
class de.gurkenlabs.litiengine.Game {
@Nullable public static IGameLoop loop() {
    return gameLoop;
}
}
```
Depth: 1
```java
class de.gurkenlabs.litiengine.environment.GameWorld {
public void loadEnvironment(@Nullable final Environment env) {
    Lock lock = Game.loop().getLock();
    lock.lock();
    try {
      unloadEnvironment();
      this.environment = env;
      if (env != null) {
        this.addEnvironment(env);

        if (env.getGravity() == 0 && this.gravity() != 0) {
          env.setGravity(this.gravity());
        }

        env.load();
        for (final EnvironmentLoadedListener listener : this.loadedListeners) {
          listener.loaded(env);
        }

        // call map specific listeners
        String mapName = getMapName(env);
        if (mapName != null && this.environmentLoadedListeners.containsKey(mapName)) {

          // for the default camera we center the camera on the environment
          if (this.camera().getClass().equals(Camera.class)) {
            camera().setFocus(env.getCenter());
          }

          for (EnvironmentLoadedListener listener : this.environmentLoadedListeners.get(mapName)) {
            listener.loaded(env);
          }
        }
      }
    } finally {
      lock.unlock();
    }
}public void setCamera(@Nullable final ICamera cam) {
    if (this.camera() != null) {
      Game.loop().detach(camera);
    }

    camera = cam;

    if (cam != null && !Game.isInNoGUIMode()) {
      Game.loop().attach(cam);
      cam.updateFocus();
    }
}
}
```
```java
class de.gurkenlabs.litiengine.entities.behavior.EntityNavigator {
public EntityNavigator(final IMobileEntity entity, final PathFinder pathFinder) {
    this.cancelNavigationConditions = new CopyOnWriteArrayList<>();
    this.listeners = new CopyOnWriteArrayList<>();
    this.entity = entity;
    this.pathFinder = pathFinder;
    this.setAcceptableError(DEFAULT_ACCEPTABLE_ERROR);
    Game.loop().attach(this);
}
}
```
```java
class de.gurkenlabs.litiengine.GameWindow {
private static void initializeWindowEventListeners(Window window) {

    window.addWindowStateListener(
        e -> {
          if (e.getNewState() == Frame.ICONIFIED) {
            Game.loop().setTickRate(ICONIFIED_MAX_FPS);
          } else {
            Game.loop().setTickRate(Game.config().client().getMaxFps());
          }
        });

    window.addWindowFocusListener(
        new WindowFocusListener() {
          @Override
          public void windowLostFocus(WindowEvent e) {
            if (Game.config().graphics().reduceFramesWhenNotFocused()) {
              Game.loop().setTickRate(NONE_FOCUS_MAX_FPS);
            }
          }

          @Override
          public void windowGainedFocus(WindowEvent e) {
            Game.loop().setTickRate(Game.config().client().getMaxFps());
          }
        });

    window.addWindowListener(
        new WindowAdapter() {
          @Override
          public void windowClosing(final WindowEvent event) {
            Game.exit();
          }
        });
}
}
```
```java
class de.gurkenlabs.litiengine.gui.screens.ScreenManager {
public void display(@Nullable final Screen screen) {
    if (Game.hasStarted() && Game.time().since(this.lastScreenChange) < this.getChangeCooldown()) {
      log.log(
          Level.INFO,
          "Skipping displaying of screen {0} because screen changing is currently on cooldown.",
          screen != null ? screen.getName() : "");
      return;
    }

    final Screen previous = this.current();
    if (previous != null) {
      previous.suspend();
    }

    if (screen != null && !this.screens.contains(screen)) {
      this.screens.add(screen);
    }

    this.currentScreen = screen;
    if (!Game.isInNoGUIMode() && this.current() != null) {
      this.current().prepare();
    }

    this.lastScreenChange = Game.loop().getTicks();

    final ScreenChangedEvent event = new ScreenChangedEvent(this.current(), previous);
    for (final ScreenChangedListener listener : this.screenChangedListeners) {
      listener.changed(event);
    }
}
}
```
```java
class de.gurkenlabs.litiengine.abilities.effects.Effect {
@Override
  public void update() {

    for (final Iterator<EffectApplication> iterator = this.getActiveAppliances().iterator();
        iterator.hasNext(); ) {
      final EffectApplication appliance = iterator.next();
      // if the effect duration is reached
      if (this.hasEnded(appliance)) {

        iterator.remove();
        this.cease(appliance);
      }
    }

    // 4. unregister if all appliances are finished
    if (this.getActiveAppliances().isEmpty()) {
      Game.loop().detach(this);
    }
}public void apply(final Shape impactArea) {
    final List<ICombatEntity> affected = this.lookForAffectedEntities(impactArea);
    for (final ICombatEntity affectedEntity : affected) {
      this.apply(affectedEntity);
    }

    this.appliances.add(new EffectApplication(affected, impactArea));

    // if it is the first appliance -> register for update
    if (this.appliances.size() == 1) {
      Game.loop().attach(this);
    }
}
}
```
```java
class de.gurkenlabs.litiengine.GameTime {
public long toTicks(final int milliseconds) {
    return this.toTicks(milliseconds, Game.loop().getTickRate());
}public long since(final long tick) {
    return toMilliseconds(Game.loop().getTicks() - tick);
}public long now() {
    return Game.loop().getTicks();
}public long sinceGameStart() {
    return this.toMilliseconds(Game.loop().getTicks());
}@Override
  public void loaded(Environment environment) {
    environmentLoaded = Game.loop().getTicks();
}public long toMilliseconds(final long ticks) {
    return this.toMilliseconds(ticks, Game.loop().getTickRate());
}
}
```
```java
class de.gurkenlabs.litiengine.GameMetrics {
@Override
  public void render(final Graphics2D g) {
    this.updateMetrics();

    if (!Game.config().client().showGameMetrics()) {
      return;
    }

    this.currentOffsetY = 0;

    g.setColor(this.renderColor);

    // render client metrics
    this.drawTitle(g, "[client]");
    this.drawMetric(g, "fps       : " + this.getFramesPerSecond());
    this.drawMetric(g, "max fps   : " + this.maxFramesPerSecond);
    this.drawMetric(g, "updatables: " + Game.loop().getUpdatableCount());

    // render jvm metrics if debug is enabled
    if (Game.config().debug().isDebugEnabled()) {
      this.drawTitle(g, "[jvm]");
      this.drawMetric(g, "java      : " + this.javaVersion);
      this.drawMetric(g, "memory    : " + String.format("%-5.5s", this.usedMemory) + " MB");
      this.drawMetric(g, "threads   : " + Thread.activeCount());
    }

    // render rendering metrics
    if (!this.renderMetrics.isEmpty()) {
      this.drawTitle(g, "[update]");

      for (RenderMetrics metric : this.renderMetrics) {
        this.drawMetric(g, metric.toString());
      }

      this.renderMetrics.clear();
    }
}
}
```
```java
class de.gurkenlabs.litiengine.graphics.emitters.Emitter {
public void deactivate() {
    if (!this.activated) {
      return;
    }

    this.activated = false;
    this.getParticles().clear();
    this.aliveTime = 0;
    this.activationTick = 0;
    this.lastSpawn = 0;
    Game.loop().detach(this);
}public void activate() {
    if (this.activated) {
      return;
    }

    this.activated = true;
    this.activationTick = Game.time().now();
    Game.loop().attach(this);
}@Override
  public void update() {
    if (this.isPaused()) {
      return;
    }

    // clear particles if the effect time to life is reached
    if (this.isFinished()) {
      for (EmitterFinishedListener listener : this.finishedListeners) {
        listener.finished(this);
      }

      this.delete();
      return;
    }

    final float updateRatio = (float) this.data().getUpdateRate() / Game.loop().getTickRate();
    for (final Particle p : this.getParticles().stream().collect(Collectors.toList())) {
      if (this.particleCanBeRemoved(p)) {
        // remove dead particles
        this.particles.remove(p);
        continue;
      }

      p.update(this.getOrigin(), updateRatio);
    }

    this.aliveTime = Game.time().since(this.activationTick);
    if ((this.data().getSpawnRate() == 0
        || Game.time().since(this.lastSpawn) >= this.data().getSpawnRate())) {
      this.lastSpawn = Game.time().now();
      this.spawnParticle();
    }
}
}
```
```java
class de.gurkenlabs.litiengine.entities.behavior.IBehaviorController {
public default void attach() {
    Game.loop().attach(this);
}public default void detach() {
    Game.loop().detach(this);
}
}
```
```java
class de.gurkenlabs.litiengine.abilities.AbilityExecution {
AbilityExecution(final Ability ability) {
    this.appliedEffects = new CopyOnWriteArrayList<>();
    this.ability = ability;
    this.executionTicks = Game.time().now();
    this.impactArea = ability.calculateImpactArea();
    this.castLocation = ability.getExecutor().getCenter();
    Game.loop().attach(this);
}@Override
  public void update() {
    // if there a no effects to apply -> unregister this instance and we're done
    if (this.getAbility().getEffects().isEmpty()
        || this.getAbility().getEffects().size() == this.getAppliedEffects().size()) {
      Game.loop().detach(this);
      return;
    }

    // handle all effects from the ability that were not applied yet
    for (final Effect effect : this.getAbility().getEffects()) {
      // if the ability was not executed yet or the delay of the effect is not
      // yet reached
      if (this.getAppliedEffects().contains(effect)
          || Game.time().since(this.getExecutionTicks()) < effect.getDelay()) {
        continue;
      }

      effect.apply(this.getExecutionImpactArea());
      this.getAppliedEffects().add(effect);
    }
}
}
```
```java
class de.gurkenlabs.litiengine.GameWindow$3 {
@Override
          public void windowGainedFocus(WindowEvent e) {
            Game.loop().setTickRate(Game.config().client().getMaxFps());
}@Override
          public void windowLostFocus(WindowEvent e) {
            if (Game.config().graphics().reduceFramesWhenNotFocused()) {
              Game.loop().setTickRate(NONE_FOCUS_MAX_FPS);
            }
}
}
```
```java
class de.gurkenlabs.litiengine.environment.EntitySpawner {
protected void spawnNewEntities() {
    if (this.getSpawnMode() != SpawnMode.CUSTOMSPAWNPOINTS && this.getSpawnPoints().isEmpty()) {
      return;
    }

    switch (this.getSpawnMode()) {
      case ALLSPAWNPOINTS:
        for (int i = 0; i < this.getSpawnPoints().size(); i++) {
          final int index = i;
          Game.loop()
              .perform(
                  this.getSpawnDelay() + this.getSpawnDelay() * i,
                  () -> this.spawn(this.getSpawnPoints().get(index), this.getSpawnAmount()));
        }
        break;
      case ONERANDOMSPAWNPOINT:
        this.spawn(Game.random().choose(this.getSpawnPoints()), this.getSpawnAmount());
        break;
      case RANDOMSPAWNPOINTS:
        for (int i = 0; i < this.getSpawnAmount(); i++) {
          Game.loop()
              .perform(
                  this.getSpawnDelay() + this.getSpawnDelay() * i,
                  () -> this.spawn(Game.random().choose(this.getSpawnPoints()), 1));
        }
        break;
      case CUSTOMSPAWNPOINTS:
        List<Spawnpoint> spawnPoints =
            this.customSpawnpoints != null
                ? this.customSpawnpoints.apply(this)
                : this.getCustomSpawnpoints();

        int index = 0;
        for (Spawnpoint spawn : spawnPoints) {
          Game.loop()
              .perform(
                  this.getSpawnDelay() + this.getSpawnDelay() * index, () -> this.spawn(spawn, 1));
          index++;
        }
        break;
      default:
        break;
    }
}
}
```
```java
class de.gurkenlabs.litiengine.tweening.TweenEngine {
@Override
  public void start() {
    Game.loop().attach(this);
}@Override
  public void terminate() {
    Game.loop().detach(this);
}
}
```
```java
class de.gurkenlabs.litiengine.gui.SpeechBubble {
public void hide() {
    Game.world().environment().removeRenderable(this);
    Game.loop().detach(this);
    if (activeSpeechBubbles.get(this.getEntity()) != null
        && activeSpeechBubbles.remove(this.getEntity()).equals(this)) {
      activeSpeechBubbles.remove(this.getEntity());
    }

    for (SpeechBubbleListener listener : this.listeners) {
      listener.hidden();
    }
}private SpeechBubble(
      final IEntity entity,
      final String text,
      @Nullable SpeechBubbleAppearance appearance,
      @Nullable Font font) {
    if (appearance == null) {
      this.appearance = DEFAULT_APPEARANCE;
    } else {
      this.appearance = appearance;
    }

    final SpeechBubble active = activeSpeechBubbles.get(entity);
    if (active != null) {
      active.hide();
    }
    this.setFont(font);

    this.textBoxWidth = (float) (entity.getWidth() * 4);
    this.entity = entity;

    this.currentText = text;
    this.currentTextDisplayTime = DISPLAYTIME_MIN + text.length() * DISPLAYTIME_PER_LETTER;

    this.lastTextDisplay = Game.time().now();
    this.createBubbleImage();
    entity.getEnvironment().add(this, RenderType.UI);
    Game.loop().attach(this);
    activeSpeechBubbles.put(entity, this);
}
}
```
```java
class de.gurkenlabs.litiengine.entities.Prop {
private void updateAnimationController() {
    IEntityAnimationController<?> controller = this.createAnimationController();
    this.getControllers().addController(controller);
    if (Game.world().environment() != null && Game.world().environment().isLoaded()) {
      Game.loop().attach(controller);
    }
}
}
```
```java
class de.gurkenlabs.litiengine.graphics.FreeFlightCamera {
public FreeFlightCamera(final Point2D focus) {
    this.setFocus(focus);
    this.velocity = DEFAULT_SCROLL_PIXELS_PER_SECOND;
    this.scrollPadding = DEFAULT_SCROLL_PADDING;
    this.setClampToMap(true);

    Game.loop().attach(this);
}private void handleFreeFlightCamera() {
    if (Game.world().environment() == null || Game.world().environment().getMap() == null) {
      return;
    }

    final Point2D mouseLocation = Input.mouse().getLocation();

    final double scrollSpeed =
        this.getVelocity()
            / (double) Game.loop().getTickRate()
            * Game.config().input().getMouseSensitivity();

    double x = this.getFocus().getX();
    double y = this.getFocus().getY();

    double deltaX = 0;
    if (mouseLocation.getX() < this.getScrollPadding()) {
      deltaX -= scrollSpeed;
    } else if (Game.window().getResolution().getWidth() - mouseLocation.getX()
        < this.getScrollPadding()) {
      deltaX += scrollSpeed;
    }

    double deltaY = 0;
    if (mouseLocation.getY() < this.getScrollPadding()) {
      deltaY -= scrollSpeed;
    } else if (Game.window().getResolution().getHeight() - mouseLocation.getY()
        < this.getScrollPadding()) {
      deltaY += scrollSpeed;
    }

    x += deltaX;
    y += deltaY;

    this.setFocus(new Point2D.Double(x, y));
}
}
```
```java
class de.gurkenlabs.litiengine.environment.Environment {
private static void dispose(final Collection<? extends IEntity> entities) {
    for (final IEntity entity : entities) {
      if (entity instanceof IUpdateable) {
        Game.loop().detach((IUpdateable) entity);
      }

      entity.detachControllers();
    }
}private static void loadUpdatableOrEmitterEntity(IEntity entity) {
    if (entity instanceof Emitter) {
      final Emitter emitter = (Emitter) entity;
      if (emitter.isActivateOnInit()) {
        emitter.activate();
      }
    } else if (entity instanceof IUpdateable) {
      Game.loop().attach((IUpdateable) entity);
    }
}private void unload(final IEntity entity) {
    // 1. remove from physics engine
    if (entity instanceof ICollisionEntity) {
      Game.physics().remove((ICollisionEntity) entity);
    }

    // 2. unregister from update
    if (entity instanceof IUpdateable) {
      Game.loop().detach((IUpdateable) entity);
    }

    if (entity instanceof IMobileEntity) {
      this.removeGravity((IMobileEntity) entity);
    }

    // 3. detach all controllers
    entity.detachControllers();

    if (entity instanceof Emitter) {
      Emitter em = (Emitter) entity;
      em.deactivate();
    }

    if (this.loaded && (entity instanceof LightSource || entity instanceof StaticShadow)) {
      this.updateLighting(entity);
    }

    entity.removed(this);
}
}
```
```java
class de.gurkenlabs.litiengine.graphics.animation.Animation {
@Override
  public void update() {
    // do nothing if the animation is not playing or the current keyframe is not finished
    if (!this.isPlaying()
        || Game.time().since(this.lastFrameUpdate) < this.getCurrentKeyFrame().getDuration()) {
      return;
    }

    // if we are not looping and the last keyframe is finished, we terminate the animation
    if (!this.isLooping() && this.isLastKeyFrame()) {
      this.terminate();
      return;
    }

    // make sure, we stay inside the keyframe list
    final int newFrameIndex =
        (this.getKeyframes().indexOf(this.currentFrame) + 1) % this.getKeyframes().size();
    final KeyFrame previousFrame = this.currentFrame;
    this.currentFrame = this.getKeyframes().get(newFrameIndex);

    for (KeyFrameListener listener : this.listeners) {
      listener.currentFrameChanged(previousFrame, this.currentFrame);
    }

    this.lastFrameUpdate = Game.loop().getTicks();
}public void restart() {
    this.currentFrame = this.firstFrame;
    this.lastFrameUpdate = Game.loop().getTicks();
}
}
```
```java
class de.gurkenlabs.litiengine.physics.MovementController {
@Override
  public void attach() {
    Game.loop().attach(this);
}private void handleForces() {
    // clean up forces
    this.activeForces.forEach(
        x -> {
          if (x.hasEnded()) {
            this.activeForces.remove(x);
          }
        });

    if (this.activeForces.isEmpty()) {
      return;
    }

    // disable turn-on-move for force handling
    boolean turn = this.getEntity().turnOnMove();
    this.getEntity().setTurnOnMove(false);
    try {
      double deltaX = 0;
      double deltaY = 0;
      for (final Force force : this.activeForces) {
        if (force.cancelOnReached() && force.hasReached(this.getEntity())) {
          force.end();
          continue;
        }

        final Point2D collisionBoxCenter = this.getEntity().getCollisionBoxCenter();
        final double angle =
            GeometricUtilities.calcRotationAngleInDegrees(collisionBoxCenter, force.getLocation());
        final double strength =
            Game.loop().getDeltaTime() * 0.001f * force.getStrength() * Game.loop().getTimeScale();
        deltaX += GeometricUtilities.getDeltaX(angle, strength);
        deltaY += GeometricUtilities.getDeltaY(angle, strength);
      }

      final Point2D target =
          new Point2D.Double(this.getEntity().getX() + deltaX, this.getEntity().getY() + deltaY);
      final boolean success = Game.physics().move(this.getEntity(), target);
      if (!success) {
        for (final Force force : this.activeForces) {
          if (force.cancelOnCollision()) {
            force.end();
          }
        }
      }
    } finally {
      this.getEntity().setTurnOnMove(turn);
    }
}@Override
  public void detach() {
    Game.loop().detach(this);
}public void handleMovement() {
    if (!this.isMovementAllowed()) {
      this.velocity = 0;
      return;
    }

    // max distance an entity can travel within one tick
    final double maxPixelsPerTick = this.getEntity().getTickVelocity();
    final double deltaTime = Game.loop().getDeltaTime() * Game.loop().getTimeScale();

    final double acceleration =
        this.getEntity().getAcceleration() == 0
            ? maxPixelsPerTick
            : deltaTime / this.getEntity().getAcceleration() * maxPixelsPerTick;
    final double deceleration =
        this.getEntity().getDeceleration() == 0
            ? this.getVelocity()
            : deltaTime / this.getEntity().getDeceleration() * maxPixelsPerTick;

    double dx = this.getDx();
    double dy = this.getDy();
    this.setDx(0);
    this.setDy(0);

    final double deltaVelocity =
        Math.min(Math.sqrt(Math.pow(dx, 2) + Math.pow(dy, 2)), acceleration);
    if (deltaVelocity != 0) {
      double newVelocity = this.getVelocity() + deltaVelocity;
      this.setVelocity(newVelocity);
    } else {
      final double newVelocity = Math.max(0, this.getVelocity() - deceleration);
      this.setVelocity(newVelocity);
      dx = GeometricUtilities.getDeltaX(this.moveAngle);
      dy = GeometricUtilities.getDeltaY(this.moveAngle);
    }

    if (this.getVelocity() == 0) {
      this.moveAngle = 0;
      return;
    }

    // actually move entity
    this.moveEntity(dx, dy);
}
}
```
```java
class de.gurkenlabs.litiengine.graphics.animation.AnimationController {
public void detach() {
    Game.loop().detach(this);
}public void attach() {
    Game.loop().attach(this);
}
}
```
```java
class de.gurkenlabs.litiengine.graphics.Camera {
@Override
  public void setZoom(final float targetZoom, final int delay) {
    if (delay == 0) {

      this.zoom = targetZoom;
      this.targetZoom = 0;
      this.zoomDelay = 0;
      this.zoomTick = 0;
      this.zoomStep = 0;

      final ZoomChangedEvent event = new ZoomChangedEvent(this, targetZoom);
      for (final ZoomChangedListener listener : this.zoomListeners) {
        listener.zoomChanged(event);
      }
    } else {
      this.zoomTick = Game.time().now();
      this.targetZoom = targetZoom;
      this.zoomDelay = delay;

      final double tickduration = 1000 / (double) Game.loop().getTickRate();
      final double tickAmount = delay / tickduration;
      final float totalDelta = this.targetZoom - this.zoom;
      this.zoomStep = tickAmount > 0 ? (float) (totalDelta / tickAmount) : totalDelta;
    }
}
}
```
```java
class de.gurkenlabs.litiengine.Game {
public static synchronized void init(String... args) {
    if (initialized) {
      log().log(Level.INFO, "The game has already been initialized.");
      return;
    }

    log.init();
    handleCommandLineArguments(args);

    config().load();
    Locale.setDefault(new Locale(config().client().getCountry(), config().client().getLanguage()));

    gameLoop = new GameLoop("Main Update Loop", config().client().getMaxFps());
    loop().attach(physics());
    loop().attach(world());

    // setup default exception handling for render and update loop
    setUncaughtExceptionHandler(
        new DefaultUncaughtExceptionHandler(config().client().exitOnError()));

    screenManager = new ScreenManager();
    gameWindow = new GameWindow();

    // initialize  the game window
    window().init();
    world.setCamera(new Camera());

    for (GameListener listener : gameListeners) {
      listener.initialized(args);
    }

    if (!isInNoGUIMode()) {
      window().getRenderComponent().onRendered(g -> metrics().render(g));

      graphics()
          .addEntityRenderedListener(
              e -> DebugRenderer.renderEntityDebugInfo(e.getGraphics(), e.getEntity()));

      window().getRenderComponent().onFpsChanged(fps -> metrics().setFramesPerSecond(fps));
      window()
          .setIcons(
              Arrays.asList(
                  Resources.images().get("liti-logo-x16.png"),
                  Resources.images().get("liti-logo-x20.png"),
                  Resources.images().get("liti-logo-x32.png"),
                  Resources.images().get("liti-logo-x48.png")));

      Input.keyboard()
          .onKeyTyped(
              KeyEvent.VK_PRINTSCREEN,
              key -> {
                // don't take a screenshot if a modifier is active
                if (key.getModifiers() != 0) {
                  return;
                }

                window().getRenderComponent().takeScreenshot();
              });
    }

    Runtime.getRuntime().addShutdownHook(new Thread(Game::terminate, "Shutdown"));

    initialized = true;
}
}
```
```java
class de.gurkenlabs.litiengine.entities.Creature {
protected void updateAnimationController() {
    IEntityAnimationController<?> controller = this.createAnimationController();
    this.getControllers().addController(controller);
    if (Game.world().environment() != null && Game.world().environment().isLoaded()) {
      Game.loop().attach(controller);
    }
}@Override
  public float getTickVelocity() {
    // pixels per ms multiplied by the passed ms
    // ensure that entities don't travel too far in case of lag
    return Math.min(Game.loop().getDeltaTime(), GameLoop.TICK_DELTATIME_LAG)
        * 0.001F
        * this.getVelocity().get()
        * Game.loop().getTimeScale();
}
}
```
Depth: 2
```java
class de.gurkenlabs.litiengine.environment.GameWorld {
public void clear() {
    this.unloadEnvironment();
    this.environments.clear();
    this.setCamera(null);
    Game.physics().clear();

    this.environmentListeners.clear();
    this.environmentLoadedListeners.clear();
    this.environmentUnloadedListeners.clear();

    this.listeners.clear();
    this.loadedListeners.clear();
    this.unloadedListeners.clear();
}@Nullable
  public Environment loadEnvironment(IMap map) {
    Environment env = this.getEnvironment(map);
    this.loadEnvironment(env);
    return env;
}@Nullable
  public Environment loadEnvironment(String mapName) {
    Environment env = this.getEnvironment(mapName);
    this.loadEnvironment(env);
    return env;
}
}
```
```java
class de.gurkenlabs.litiengine.GameWindow {
GameWindow() {
    this.hostControl = new JFrame();

    this.resolutionChangedListeners = new CopyOnWriteArrayList<>();

    this.renderCanvas = new RenderComponent(Game.config().graphics().getResolution());
    this.cursor = new MouseCursor();
    if (!Game.isInNoGUIMode()) {
      this.hostControl.setBackground(Color.BLACK);
      this.hostControl.add(this.renderCanvas);

      this.initializeEventListeners();

      this.hostControl.setTitle(Game.info().getTitle());
      this.hostControl.setDefaultCloseOperation(WindowConstants.DO_NOTHING_ON_CLOSE);
      initializeWindowEventListeners(this.hostControl);
    }
}
}
```
```java
class de.gurkenlabs.litiengine.GameTime {
public long sinceEnvironmentLoad() {
    return this.since(this.environmentLoaded);
}public long since(final long tick) {
    return toMilliseconds(Game.loop().getTicks() - tick);
}public long sinceGameStart() {
    return this.toMilliseconds(Game.loop().getTicks());
}
}
```
```java
class de.gurkenlabs.litiengine.abilities.effects.Effect {
protected void cease(final EffectApplication appliance) {
    // 1. cease the effect for all affected entities
    for (final ICombatEntity entity : appliance.getAffectedEntities()) {
      this.cease(entity);
    }

    // 2. apply follow up effects
    this.getFollowUpEffects().forEach(followUp -> followUp.apply(appliance.getImpactArea()));
}protected boolean hasEnded(final EffectApplication appliance) {
    final long effectDuration = Game.time().since(appliance.getAppliedTicks());
    return effectDuration > this.getDuration();
}
}
```
```java
class de.gurkenlabs.litiengine.abilities.effects.EffectApplication {
protected EffectApplication(final List<ICombatEntity> affectedEntities, final Shape impactArea) {
    this.applied = Game.time().now();
    this.affectedEntities = affectedEntities;
    this.impactArea = impactArea;
}
}
```
```java
class de.gurkenlabs.litiengine.entities.CombatEntity {
@Override
  public boolean wasHit(int timeSpan) {
    return Game.time().since(this.lastHit) < timeSpan;
}@Override
  public void hit(final int damage, @Nullable final Ability ability) {
    if (this.isDead()) {
      return;
    }

    if (!this.isIndestructible()) {
      this.getHitPoints().modifyBaseValue(new AttributeModifier<>(Modification.SUBTRACT, damage));
    }

    final EntityHitEvent event = new EntityHitEvent(this, ability, damage, this.isDead());

    for (final CombatEntityListener listener : this.listeners) {
      listener.hit(event);
    }

    for (final CombatEntityHitListener listener : this.hitListeners) {
      listener.hit(event);
    }

    if (this.isDead()) {
      this.fireDeathEvent();
      this.setCollision(false);
    }

    this.lastHit = Game.time().now();
}
}
```
```java
class de.gurkenlabs.litiengine.graphics.ImageEffect {
protected ImageEffect(final int ttl, final String name) {
    this.ttl = ttl;
    this.name = name;
    this.aliveTick = Game.time().now();
}@Override
  public long getAliveTime() {
    return Game.time().since(this.aliveTick);
}
}
```
```java
class de.gurkenlabs.litiengine.abilities.AbilityExecution {
AbilityExecution(final Ability ability) {
    this.appliedEffects = new CopyOnWriteArrayList<>();
    this.ability = ability;
    this.executionTicks = Game.time().now();
    this.impactArea = ability.calculateImpactArea();
    this.castLocation = ability.getExecutor().getCenter();
    Game.loop().attach(this);
}@Override
  public void update() {
    // if there a no effects to apply -> unregister this instance and we're done
    if (this.getAbility().getEffects().isEmpty()
        || this.getAbility().getEffects().size() == this.getAppliedEffects().size()) {
      Game.loop().detach(this);
      return;
    }

    // handle all effects from the ability that were not applied yet
    for (final Effect effect : this.getAbility().getEffects()) {
      // if the ability was not executed yet or the delay of the effect is not
      // yet reached
      if (this.getAppliedEffects().contains(effect)
          || Game.time().since(this.getExecutionTicks()) < effect.getDelay()) {
        continue;
      }

      effect.apply(this.getExecutionImpactArea());
      this.getAppliedEffects().add(effect);
    }
}
}
```
```java
class de.gurkenlabs.litiengine.tweening.TweenEngine {
@Override
  public void update() {
    for (final Tweenable target : this.getTweens().keySet()) {
      for (final Tween tween : this.getTweens().get(target).values()) {
        if (tween.hasStopped()) {
          continue;
        }
        final long elapsed = Game.time().since(tween.getStartTime());
        if (elapsed >= tween.getDuration()) {
          tween.stop();
          continue;
        }
        final float[] currentValues = new float[tween.getTargetValues().length];
        for (int i = 0; i < tween.getTargetValues().length; i++) {
          currentValues[i] =
              tween.getStartValues()[i]
                  + tween.getEquation().compute(elapsed / (float) tween.getDuration())
                      * (tween.getTargetValues()[i] - tween.getStartValues()[i]);
        }
        tween.getTarget().setTweenValues(tween.getType(), currentValues);
      }
    }
}
}
```
```java
class de.gurkenlabs.litiengine.gui.SpeechBubble {
public static SpeechBubble create(
      final IEntity entity, final String text, SpeechBubbleAppearance appearance, Font font) {
    return new SpeechBubble(entity, text, appearance, font);
}public static SpeechBubble create(final IEntity entity, final Font font, final String text) {
    SpeechBubbleAppearance app =
        new SpeechBubbleAppearance(
            DEFAULT_APPEARANCE.getForeColor(),
            DEFAULT_APPEARANCE.getBackgroundColor1(),
            DEFAULT_APPEARANCE.getBorderColor(),
            DEFAULT_APPEARANCE.getPadding());
    return new SpeechBubble(entity, text, app, font);
}public static SpeechBubble create(final IEntity entity, final String text) {
    return new SpeechBubble(entity, text, null, GuiProperties.getDefaultFont());
}@Override
  public void update() {
    if (this.currentText == null) {
      this.hide();
      return;
    }

    this.entityCenter = Game.world().camera().getViewportLocation(this.getEntity().getCenter());

    // old text was displayed long enough
    if (this.lastTextDisplay != 0
        && Game.time().since(this.lastTextDisplay) > this.currentTextDisplayTime) {
      this.currentText = null;
      this.lastTextDisplay = 0;
      return;
    }

    // display new text
    if (this.textIndex < this.currentText.length()
        && Game.time().since(this.lastCharPoll) > LETTER_WRITE_DELAY) {
      this.textIndex++;
      this.lastCharPoll = Game.time().now();
      if (this.typeSound != null) {
        Game.audio().playSound(this.typeSound, this.getEntity());
      }
    }

    // continue displaying currently displayed text
}private SpeechBubble(
      final IEntity entity,
      final String text,
      final Sound typeSound,
      SpeechBubbleAppearance appearance,
      Font font) {
    this(entity, text, appearance, font);
    this.typeSound = typeSound;
}private SpeechBubble(
      final IEntity entity,
      final String text,
      @Nullable SpeechBubbleAppearance appearance,
      @Nullable Font font) {
    if (appearance == null) {
      this.appearance = DEFAULT_APPEARANCE;
    } else {
      this.appearance = appearance;
    }

    final SpeechBubble active = activeSpeechBubbles.get(entity);
    if (active != null) {
      active.hide();
    }
    this.setFont(font);

    this.textBoxWidth = (float) (entity.getWidth() * 4);
    this.entity = entity;

    this.currentText = text;
    this.currentTextDisplayTime = DISPLAYTIME_MIN + text.length() * DISPLAYTIME_PER_LETTER;

    this.lastTextDisplay = Game.time().now();
    this.createBubbleImage();
    entity.getEnvironment().add(this, RenderType.UI);
    Game.loop().attach(this);
    activeSpeechBubbles.put(entity, this);
}
}
```
```java
class de.gurkenlabs.litiengine.gui.TextFieldComponent {
@Override
  public void render(final Graphics2D g) {
    super.render(g);
    g.setFont(this.getFont());
    final FontMetrics fm = g.getFontMetrics();

    if (this.isSelected() && Game.time().since(this.lastToggled) > this.flickerDelay) {
      this.cursorVisible = !this.cursorVisible;
      this.lastToggled = Game.time().now();
    }
    if (this.isSelected() && this.cursorVisible) {
      final Rectangle2D cursor =
          new Rectangle2D.Double(
              this.getX() + this.getTextX() + fm.stringWidth(this.getTextToRender(g)),
              this.getY() + this.getTextY(),
              this.getFont().getSize2D() * 3 / 5,
              this.getFont().getSize2D() * 1 / 5);
      g.setColor(this.getAppearance().getForeColor());
      g.fill(cursor);
    }
}
}
```
```java
class de.gurkenlabs.litiengine.entities.Prop {
public Prop(
      final Point2D location, @Nullable final String spritesheetName, final Material material) {
    super();
    this.rotation = Rotation.NONE;
    this.spritesheetName = spritesheetName;
    this.material = material;
    this.setLocation(location);
    this.updateAnimationController();
}public void setSpritesheetName(@Nullable final String spriteName) {
    this.spritesheetName = spriteName;
    this.updateAnimationController();
}
}
```
```java
class de.gurkenlabs.litiengine.tweening.Tween {
public Tween begin() {
    this.started = Game.time().now();
    this.stopped = false;
    return this;
}
}
```
```java
class de.gurkenlabs.litiengine.graphics.emitters.particles.Particle {
public void update(final Point2D emitterOrigin, final float updateRatio) {
    if (this.aliveTick == 0) {
      this.aliveTick = Game.time().now();
    }

    this.aliveTime = Game.time().since(this.aliveTick);
    if (this.timeToLiveReached()) {
      return;
    }

    if (this.colliding) {
      return;
    }

    if (this.getDeltaWidth() != 0) {
      this.width += this.getDeltaWidth() * updateRatio;
    }

    if (this.getDeltaHeight() != 0) {
      this.height += this.getDeltaHeight() * updateRatio;
    }

    if (this.getDeltaAngle() != 0) {
      this.angle += this.getDeltaAngle() * updateRatio;
    }

    // test for ray cast collision
    final float targetX = this.x + this.getVelocityX() * updateRatio;
    final float targetY = this.y + this.getVelocityY() * updateRatio;

    if (targetX == this.x && targetY == this.y) {
      return;
    }

    if (this.checkForCollision(emitterOrigin, targetX, targetY)) {
      return;
    }

    if (this.getVelocityX() != 0) {
      this.x = targetX;
    }

    if (this.getVelocityY() != 0) {
      this.y = targetY;
    }

    if (this.getAccelerationX() != 0) {
      this.velocityX += this.getAccelerationX() * updateRatio;
    }

    if (this.getAccelerationY() != 0) {
      this.velocityY += this.getAccelerationY() * updateRatio;
    }
}
}
```
```java
class de.gurkenlabs.litiengine.graphics.animation.Animation {
@Override
  public void start() {
    this.playing = true;
    if (this.getKeyframes().isEmpty()) {
      return;
    }

    this.restart();
}@Override
  public void update() {
    // do nothing if the animation is not playing or the current keyframe is not finished
    if (!this.isPlaying()
        || Game.time().since(this.lastFrameUpdate) < this.getCurrentKeyFrame().getDuration()) {
      return;
    }

    // if we are not looping and the last keyframe is finished, we terminate the animation
    if (!this.isLooping() && this.isLastKeyFrame()) {
      this.terminate();
      return;
    }

    // make sure, we stay inside the keyframe list
    final int newFrameIndex =
        (this.getKeyframes().indexOf(this.currentFrame) + 1) % this.getKeyframes().size();
    final KeyFrame previousFrame = this.currentFrame;
    this.currentFrame = this.getKeyframes().get(newFrameIndex);

    for (KeyFrameListener listener : this.listeners) {
      listener.currentFrameChanged(previousFrame, this.currentFrame);
    }

    this.lastFrameUpdate = Game.loop().getTicks();
}
}
```
```java
class de.gurkenlabs.litiengine.graphics.animation.AnimationController {
@Override
  public void update() {
    for (final Animation animation : this.getAll()) {
      animation.update();
    }

    if (this.getCurrent() != null && this.getCurrent().isPaused()) {
      return;
    }

    final boolean playbackFinished = this.getCurrent() != null && !this.getCurrent().isPlaying();
    if (playbackFinished) {
      for (final AnimationListener listener : this.listeners) {
        listener.finished(this.getCurrent());
      }
    }

    if (this.getCurrent() == null || playbackFinished) {
      if (this.getDefault() != null) {
        this.play(this.getDefault().getName());
      } else {
        this.currentAnimation = null;
      }
    }
}
}
```
```java
class de.gurkenlabs.litiengine.graphics.RenderComponent {
private void handleFade() {
    if (this.fadeOutStart != -1) {
      final long timePassed = Game.time().since(this.fadeOutStart);
      this.currentAlpha = MathUtilities.clamp(1 - timePassed / (float) this.fadeOutTime, 0, 1);
      if (this.currentAlpha == 0f) {
        this.fadeOutStart = -1;
        this.fadeOutTime = -1;
      }

      return;
    }

    if (this.fadeInStart != -1) {
      final long timePassed = Game.time().since(this.fadeInStart);
      this.currentAlpha = MathUtilities.clamp(timePassed / (float) this.fadeInTime, 0, 1);
      if (this.currentAlpha == 1f) {
        this.fadeInStart = -1;
        this.fadeInTime = -1;
        this.currentAlpha = Float.NaN;
      }
    }
}public void fadeOut(final int ms) {
    this.fadeInStart = -1;
    this.fadeInTime = -1;
    this.fadeOutStart = Game.time().now();
    this.fadeOutTime = ms;
}public void fadeIn(final int ms) {
    this.fadeOutStart = -1;
    this.fadeOutTime = -1;
    this.fadeInStart = Game.time().now();
    this.fadeInTime = ms;
}
}
```
```java
class de.gurkenlabs.litiengine.entities.Trigger {
private boolean activate(final IEntity activator, final int tar) {
    if (!this.isLoaded()
        || this.isOneTimeTrigger && this.isActivated
        || this.getActivationType() == TriggerActivation.COLLISION
            && activator != null
            && this.collisionActivated.contains(activator)) {
      return false;
    }

    if (this.getCooldown() > 0 && Game.time().since(this.lastActivation) < this.getCooldown()) {
      return false;
    }

    List<Integer> triggerTargets = this.getTargets(tar);

    final TriggerEvent te = new TriggerEvent(this, activator, triggerTargets);

    if (!this.checkActivationPredicates(te)) {
      return false;
    }

    this.isActivated = true;
    if (activator != null) {
      this.collisionActivated.add(activator);
    }

    // if we actually have a trigger target, we send the message to the target
    for (final int target : triggerTargets) {
      final IEntity entity = this.getEnvironment().get(target);
      if (entity == null) {
        log.log(
            Level.WARNING,
            "trigger [{0}] was activated, but the trigger target [{1}] could not be found on the environment",
            new Object[] {this, target});
        continue;
      }

      entity.sendMessage(this, this.message);
    }

    // also send the trigger event to all registered consumers
    for (final TriggerActivatedListener listener : this.activatedListeners) {
      listener.activated(te);
    }

    if (this.isOneTimeTrigger) {
      this.getEnvironment().remove(this);
    }

    this.lastActivation = Game.time().now();
    return true;
}
}
```
```java
class de.gurkenlabs.litiengine.graphics.Camera {
private boolean isShakeEffectActive() {
    return this.getShakeTick() != 0
        && Game.time().since(this.getShakeTick()) < this.getShakeDuration();
}@Override
  public void update() {
    if (Game.world().camera() != null && !Game.world().camera().equals(this)) {
      return;
    }

    if (this.targetZoom > 0) {
      if (Game.time().since(this.zoomTick) >= this.zoomDelay) {
        this.zoom = this.targetZoom;
        this.targetZoom = 0;
        this.zoomDelay = 0;
        this.zoomTick = 0;
        this.zoomStep = 0;
      } else {
        this.zoom += this.zoomStep;
      }

      final ZoomChangedEvent event = new ZoomChangedEvent(this, this.getZoom());
      for (final ZoomChangedListener listener : this.zoomListeners) {
        listener.zoomChanged(event);
      }
    }

    if (this.panTime > 0) {
      if (--this.panTime <= 0) {
        this.setFocus(this.targetFocus);
        this.targetFocus = null;
      } else {
        double diff = this.panTime / (this.panTime + 1.0);
        this.focus =
            new Point2D.Double(
                this.focus.getX() * diff + this.targetFocus.getX() * (1.0 - diff),
                this.focus.getY() * diff + this.targetFocus.getY() * (1.0 - diff));
      }
    }

    if (!this.isShakeEffectActive()) {
      this.shakeOffsetX = 0;
      this.shakeOffsetY = 0;
      return;
    }

    if (Game.time().since(this.lastShake) > this.shakeDelay) {
      this.shakeOffsetX = this.getShakeIntensity() * ThreadLocalRandom.current().nextGaussian();
      this.shakeOffsetY = this.getShakeIntensity() * ThreadLocalRandom.current().nextGaussian();
      this.lastShake = Game.time().now();
    }
}@Override
  public void setZoom(final float targetZoom, final int delay) {
    if (delay == 0) {

      this.zoom = targetZoom;
      this.targetZoom = 0;
      this.zoomDelay = 0;
      this.zoomTick = 0;
      this.zoomStep = 0;

      final ZoomChangedEvent event = new ZoomChangedEvent(this, targetZoom);
      for (final ZoomChangedListener listener : this.zoomListeners) {
        listener.zoomChanged(event);
      }
    } else {
      this.zoomTick = Game.time().now();
      this.targetZoom = targetZoom;
      this.zoomDelay = delay;

      final double tickduration = 1000 / (double) Game.loop().getTickRate();
      final double tickAmount = delay / tickduration;
      final float totalDelta = this.targetZoom - this.zoom;
      this.zoomStep = tickAmount > 0 ? (float) (totalDelta / tickAmount) : totalDelta;
    }
}@Override
  public void shake(final double intensity, final int delay, final int shakeDuration) {
    this.shakeTick = Game.time().now();
    this.shakeDelay = delay;
    this.shakeIntensity = intensity;
    this.shakeDuration = shakeDuration;
}
}
```
```java
class de.gurkenlabs.litiengine.entities.Creature {
public void setSpritesheetName(String spritesheetName) {
    if (this.spritesheetName != null && this.spritesheetName.equals(spritesheetName)) {
      return;
    }

    this.spritesheetName = spritesheetName;
    this.updateAnimationController();
}public boolean isIdle() {
    return Game.time().since(this.lastMoved) > IDLE_DELAY;
}@Override
  public void setLocation(final Point2D position) {
    if (this.isDead() || position == null) {
      return;
    }

    final Point2D oldLocation = this.getLocation();
    super.setLocation(position);

    if (Game.hasStarted() && this.isLoaded()) {
      this.lastMoved = Game.time().now();
      this.fireMovedEvent(
          new EntityMovedEvent(
              this, this.getX() - oldLocation.getX(), this.getY() - oldLocation.getY()));
    }
}
}
```
```java
class de.gurkenlabs.litiengine.gui.screens.ScreenManager {
public void display(final String screenName) {
    if (this.current() != null && this.current().getName().equalsIgnoreCase(screenName)) {
      log.log(
          Level.INFO,
          "Skipping displaying of screen {0} because it is already the current screen.",
          screenName);
      return;
    }

    if (this.screens.stream()
        .noneMatch(element -> element.getName().equalsIgnoreCase(screenName))) {
      log.log(
          Level.WARNING,
          "Could not display the screen {0} because there is no screen with the specified name.",
          screenName);
      return;
    }

    Screen screen = this.get(screenName);
    if (screen == null) {
      return;
    }

    this.display(screen);
}public void add(final Screen screen) {
    screen.setWidth(Game.window().getWidth());
    screen.setHeight(Game.window().getHeight());
    this.screens.add(screen);

    if (this.current() == null) {
      this.display(screen);
    }
}public void remove(Screen screen) {
    this.screens.remove(screen);
    if (this.current() == screen) {
      if (!this.screens.isEmpty()) {
        this.display(this.screens.get(0));
      } else {
        this.display((Screen) null);
      }
    }
}public void display(@Nullable final Screen screen) {
    if (Game.hasStarted() && Game.time().since(this.lastScreenChange) < this.getChangeCooldown()) {
      log.log(
          Level.INFO,
          "Skipping displaying of screen {0} because screen changing is currently on cooldown.",
          screen != null ? screen.getName() : "");
      return;
    }

    final Screen previous = this.current();
    if (previous != null) {
      previous.suspend();
    }

    if (screen != null && !this.screens.contains(screen)) {
      this.screens.add(screen);
    }

    this.currentScreen = screen;
    if (!Game.isInNoGUIMode() && this.current() != null) {
      this.current().prepare();
    }

    this.lastScreenChange = Game.loop().getTicks();

    final ScreenChangedEvent event = new ScreenChangedEvent(this.current(), previous);
    for (final ScreenChangedListener listener : this.screenChangedListeners) {
      listener.changed(event);
    }
}
}
```
```java
class de.gurkenlabs.litiengine.abilities.Ability {
public boolean isOnCooldown() {
    return (this.getCurrentExecution() != null
        && this.getCurrentExecution().getExecutionTicks() > 0
        && Game.time().since(this.getCurrentExecution().getExecutionTicks())
            < this.getAttributes().cooldown().get());
}public boolean isActive() {
    return this.getCurrentExecution() != null
        && Game.time().since(this.getCurrentExecution().getExecutionTicks())
            < this.getAttributes().duration().get();
}@Nullable
  public AbilityExecution cast() {
    if (!this.canCast()) {
      return null;
    }
    this.currentExecution = new AbilityExecution(this);

    for (final AbilityCastListener listener : this.abilityCastListeners) {
      listener.abilityCast(this.currentExecution);
    }

    return this.getCurrentExecution();
}public float getRemainingCooldownInSeconds() {
    if (this.getCurrentExecution() == null
        || this.getExecutor() == null
        || this.getExecutor().isDead()) {
      return 0;
    }

    // calculate cooldown in seconds
    return (float)
        (!this.canCast()
            ? (this.getAttributes().cooldown().get()
                    - Game.time().since(this.getCurrentExecution().getExecutionTicks()))
                * 0.001
            : 0);
}
}
```
```java
class de.gurkenlabs.litiengine.entities.EntityHitEvent {
EntityHitEvent(
      final ICombatEntity hitEntity,
      @Nullable final Ability ability,
      final int damage,
      final boolean kill) {
    super(hitEntity);
    this.executor = ability != null ? ability.getExecutor() : null;
    this.hitEntity = hitEntity;
    this.ability = ability;
    this.damage = damage;
    this.kill = kill;
    this.time = Game.time().now();
}
}
```
```java
class de.gurkenlabs.litiengine.graphics.emitters.Emitter {
public void delete() {
    this.deactivate();
    if (Game.world().environment() != null) {
      Game.world().environment().remove(this);
    }
}public void activate() {
    if (this.activated) {
      return;
    }

    this.activated = true;
    this.activationTick = Game.time().now();
    Game.loop().attach(this);
}@Override
  public void update() {
    if (this.isPaused()) {
      return;
    }

    // clear particles if the effect time to life is reached
    if (this.isFinished()) {
      for (EmitterFinishedListener listener : this.finishedListeners) {
        listener.finished(this);
      }

      this.delete();
      return;
    }

    final float updateRatio = (float) this.data().getUpdateRate() / Game.loop().getTickRate();
    for (final Particle p : this.getParticles().stream().collect(Collectors.toList())) {
      if (this.particleCanBeRemoved(p)) {
        // remove dead particles
        this.particles.remove(p);
        continue;
      }

      p.update(this.getOrigin(), updateRatio);
    }

    this.aliveTime = Game.time().since(this.activationTick);
    if ((this.data().getSpawnRate() == 0
        || Game.time().since(this.lastSpawn) >= this.data().getSpawnRate())) {
      this.lastSpawn = Game.time().now();
      this.spawnParticle();
    }
}
}
```
```java
class de.gurkenlabs.litiengine.GameLoop {
@Override
  public int perform(int delay, Runnable action) {
    final long d = Game.time().toTicks(delay);

    TimedAction a = new TimedAction(this.getTicks() + d, action);
    this.actions.add(a);

    return a.getId();
}
}
```
```java
class de.gurkenlabs.litiengine.environment.EntitySpawner {
protected boolean shouldSpawn() {
    return this.lastSpawnWave == 0
        || Game.time().since(this.lastSpawnWave) >= this.getSpawnInterval();
}@Override
  public void update() {
    if (!this.shouldSpawn()) {
      return;
    }

    this.spawnNewEntities();
    this.lastSpawnWave = Game.time().now();
}
}
```
```java
class de.gurkenlabs.litiengine.graphics.FreeFlightCamera {
@Override
  public void update() {
    this.handleFreeFlightCamera();
}public FreeFlightCamera(double x, double y) {
    this(new Point2D.Double(x, y));
}
}
```
```java
class de.gurkenlabs.litiengine.environment.Environment {
public void unload() {
    if (!this.loaded) {
      return;
    }

    // unregister all updatable entities from the current environment
    for (final IEntity entity : this.allEntities.values()) {
      this.unload(entity);
    }

    this.loaded = false;
    this.fireEvent(l -> l.unloaded(this));
}private static void loadUpdatableOrEmitterEntity(IEntity entity) {
    if (entity instanceof Emitter) {
      final Emitter emitter = (Emitter) entity;
      if (emitter.isActivateOnInit()) {
        emitter.activate();
      }
    } else if (entity instanceof IUpdateable) {
      Game.loop().attach((IUpdateable) entity);
    }
}public void clear() {
    Game.physics().clear();

    this.combatEntities.clear();
    this.mobileEntities.clear();
    this.gravityForces.clear();
    this.layerEntities.clear();
    this.entitiesByTag.clear();
    this.allEntities.clear();

    for (RenderType renderType : RenderType.values()) {
      this.miscEntities.get(renderType).clear();
      this.renderListeners.get(renderType).clear();
      this.renderables.get(renderType).clear();
    }

    dispose(this.allEntities.values());
    dispose(this.triggers);
    this.emitters.clear();
    this.colliders.clear();
    this.props.clear();
    this.creatures.clear();
    this.staticShadows.clear();
    this.combatEntities.clear();
    this.mobileEntities.clear();
    this.lightSources.clear();
    this.spawnPoints.clear();
    this.soundSources.clear();
    this.mapAreas.clear();
    this.triggers.clear();

    this.ambientLight = null;
    this.staticShadowLayer = null;

    for (Map<Integer, IEntity> type : this.miscEntities.values()) {
      type.clear();
    }

    this.initialized = false;

    this.fireEvent(l -> l.cleared(this));
}private void load(final IEntity entity) {
    // an entity can only exist on one environment at a time, so remove it from the current one
    if (entity.getEnvironment() != null) {
      entity.getEnvironment().remove(entity);
    }

    // 1. add to physics engine
    loadPhysicsEntity(entity);

    // 2. register for update or activate
    loadUpdatableOrEmitterEntity(entity);

    // 3. if a gravity is defined, add a gravity force to the entity
    if (entity instanceof IMobileEntity && this.getGravity() != 0) {
      this.addGravityForce((IMobileEntity) entity);
    }

    // 4. attach all controllers
    entity.attachControllers();

    if (this.loaded && (entity instanceof LightSource || entity instanceof StaticShadow)) {
      this.updateLighting(entity);
    }

    entity.loaded(this);
}private void unload(final IEntity entity) {
    // 1. remove from physics engine
    if (entity instanceof ICollisionEntity) {
      Game.physics().remove((ICollisionEntity) entity);
    }

    // 2. unregister from update
    if (entity instanceof IUpdateable) {
      Game.loop().detach((IUpdateable) entity);
    }

    if (entity instanceof IMobileEntity) {
      this.removeGravity((IMobileEntity) entity);
    }

    // 3. detach all controllers
    entity.detachControllers();

    if (entity instanceof Emitter) {
      Emitter em = (Emitter) entity;
      em.deactivate();
    }

    if (this.loaded && (entity instanceof LightSource || entity instanceof StaticShadow)) {
      this.updateLighting(entity);
    }

    entity.removed(this);
}public void remove(final IEntity entity) {
    if (entity == null) {
      return;
    }

    this.allEntities.remove(entity.getMapId());
    Iterator<List<IEntity>> iter = this.layerEntities.values().iterator();
    while (iter.hasNext()) {
      List<IEntity> layer = iter.next();
      if (layer.remove(entity) && layer.isEmpty()) {
        iter.remove();
      }
    }
    if (this.miscEntities.get(entity.getRenderType()) != null) {
      this.miscEntities.get(entity.getRenderType()).values().remove(entity);
    }

    for (String tag : entity.getTags()) {
      if (this.getEntitiesByTag().containsKey(tag)) {
        this.getEntitiesByTag().get(tag).remove(entity);

        if (this.getEntitiesByTag().get(tag).isEmpty()) {
          this.getEntitiesByTag().remove(tag);
        }
      }
    }

    if (entity instanceof Emitter) {
      Emitter emitter = (Emitter) entity;
      this.removeEmitter(emitter);
    }

    if (entity instanceof MapArea) {
      this.mapAreas.remove(entity);
    }

    if (entity instanceof Prop) {
      this.props.remove(entity);
    }

    if (entity instanceof Creature) {
      this.creatures.remove(entity);
    }

    if (entity instanceof CollisionBox) {
      this.colliders.remove(entity);
      this.staticShadows.removeIf(x -> x.getOrigin() != null && x.getOrigin().equals(entity));
    }

    if (entity instanceof LightSource) {
      this.lightSources.remove(entity);
      this.updateLighting(entity);
    }

    if (entity instanceof Trigger) {
      this.triggers.remove(entity);
    }

    if (entity instanceof Spawnpoint) {
      this.spawnPoints.remove(entity);
    }
    if (entity instanceof SoundSource) {
      this.soundSources.remove(entity);
    }

    if (entity instanceof StaticShadow) {
      this.staticShadows.remove(entity);
      this.updateLighting(entity);
    }

    if (entity instanceof IMobileEntity) {
      this.mobileEntities.values().remove(entity);
    }

    if (entity instanceof ICombatEntity) {
      this.combatEntities.values().remove(entity);
    }

    this.unload(entity);

    this.fireEntityEvent(l -> l.entityRemoved(entity));
}
}
```
```java
class de.gurkenlabs.litiengine.physics.MovementController {
@Override
  public void update() {
    this.handleForces();
    this.handleMovement();
}
}
```
```java
class de.gurkenlabs.litiengine.Game {
static synchronized void terminate() {
        if (!initialized || gameLoop == null) {
          return;
        }
    
        hasStarted = false;
        initialized = false;
    
        config().save();
        gameLoop.terminate();
        tweenEngine.terminate();
        soundEngine.terminate();
    
        world().clear();
    
        for (final GameListener listener : gameListeners) {
          try {
            listener.terminated();
          } catch (Exception e) {
            log().log(Level.WARNING, "game listener threw an exception during shutdown", e);
          }
        }
    
        gameLoop = null;
        screenManager = null;
        gameWindow = null;
}public static synchronized void start() {
          if (!initialized) {
              throw new IllegalStateException(
                  "The game cannot be started without being first initialized. Call Game.init(...) before Game.start().");
          }
    
          if (gameLoop == null) {
              throw new IllegalStateException(
                  "Game loop is not initialized. Ensure Game.init(...) has been called successfully.");
          }
          
          Nullability.castToNonnull(gameLoop, "gameLoop cannot be null").start();
          tweenEngine.start();
          soundEngine.start();
    
          for (final GameListener listener : gameListeners) {
              listener.started();
          }
    
          hasStarted = true;
}public static synchronized void init(String... args) {
    if (initialized) {
      log().log(Level.INFO, "The game has already been initialized.");
      return;
    }

    log.init();
    handleCommandLineArguments(args);

    config().load();
    Locale.setDefault(new Locale(config().client().getCountry(), config().client().getLanguage()));

    gameLoop = new GameLoop("Main Update Loop", config().client().getMaxFps());
    loop().attach(physics());
    loop().attach(world());

    // setup default exception handling for render and update loop
    setUncaughtExceptionHandler(
        new DefaultUncaughtExceptionHandler(config().client().exitOnError()));

    screenManager = new ScreenManager();
    gameWindow = new GameWindow();

    // initialize  the game window
    window().init();
    world.setCamera(new Camera());

    for (GameListener listener : gameListeners) {
      listener.initialized(args);
    }

    if (!isInNoGUIMode()) {
      window().getRenderComponent().onRendered(g -> metrics().render(g));

      graphics()
          .addEntityRenderedListener(
              e -> DebugRenderer.renderEntityDebugInfo(e.getGraphics(), e.getEntity()));

      window().getRenderComponent().onFpsChanged(fps -> metrics().setFramesPerSecond(fps));
      window()
          .setIcons(
              Arrays.asList(
                  Resources.images().get("liti-logo-x16.png"),
                  Resources.images().get("liti-logo-x20.png"),
                  Resources.images().get("liti-logo-x32.png"),
                  Resources.images().get("liti-logo-x48.png")));

      Input.keyboard()
          .onKeyTyped(
              KeyEvent.VK_PRINTSCREEN,
              key -> {
                // don't take a screenshot if a modifier is active
                if (key.getModifiers() != 0) {
                  return;
                }

                window().getRenderComponent().takeScreenshot();
              });
    }

    Runtime.getRuntime().addShutdownHook(new Thread(Game::terminate, "Shutdown"));

    initialized = true;
}
}
```


Response Format:
Provide the answer in **XML format** as follows:

#### If the method **cannot** return `null` at the specific call site:
```xml
<response>
  <reason><![CDATA[EXPLAIN WHY THE INVOCATION Game.loop() RESULT CANNOT BE NULL.]]></reason>
  <value>NO</value>
</response>

#### If the method can return null at the specific call site:
<response>
  <reason><![CDATA[EXPLAIN WHY THE INVOCATION Game.loop() RESULT CAN BE NULL.]]></reason>
  <value>YES</value>
</response>

#### If you are unsure or If there are any methods that directly or indirectly affect the return value and are not fully disclosed, request their declarations first, in the following format:
<response>
  <reason><![CDATA[EXPLAIN WHY THIS METHOD DECLARATION IS NECESSARY AND WHY YOU CANNOT MAKE A CONFIDENT DECISION WITHOUT IT]]></reason>
  <success>false</success>
  <methods>
    <method>methodName</method>
  </methods>
</response>

Additional Notes:
Be precise in your reasoning.
If a methods return value depends on another method not provided, request its declaration before making a conclusion.
If the method can return null in this case but not in others, explain why it happens specifically for this call.

11:53:23.875 TRACE edu.ucr.cs.riple.core.checkers.nullaway.codefix.ChatGPT.ask
Retrieving response from cache
11:53:23.875 TRACE edu.ucr.cs.riple.core.checkers.nullaway.codefix.Response.tryCreate
Trying to create Response:
```xml
<response>
  <reason><![CDATA[The method Game.loop() returns the static variable gameLoop. From the information provided, it is evident that gameLoop is assigned a new instance of GameLoop during the initialization process in the Game.init() method. This assignment seems to be necessary for further game operations, as the init method includes an invocation gameLoop = new GameLoop(...). There is no code path in Game.init(), Game.start(), or Game.loop() that sets gameLoop to null once it has been instantiated. Furthermore, Game.start(), which is included in the call chain context, checks if gameLoop is null and throws an IllegalStateException if it is, ensuring that gameLoop is not null if the game has started. Since the specific call site is within operational game code (not a shutdown or uninitialized scenario), it can be reliably inferred that gameLoop is expected to be non-null when Game.loop() is called in an ongoing game session. Therefore, based on this analysis and provided code context, the method cannot return null at the specific call site.]]></reason>
  <value>NO</value>
</response>
```
11:53:23.876 TRACE edu.ucr.cs.riple.core.checkers.nullaway.codefix.Response.<init>
Creating Response:
```xml
<response>
  <reason><![CDATA[The method Game.loop() returns the static variable gameLoop. From the information provided, it is evident that gameLoop is assigned a new instance of GameLoop during the initialization process in the Game.init() method. This assignment seems to be necessary for further game operations, as the init method includes an invocation gameLoop = new GameLoop(...). There is no code path in Game.init(), Game.start(), or Game.loop() that sets gameLoop to null once it has been instantiated. Furthermore, Game.start(), which is included in the call chain context, checks if gameLoop is null and throws an IllegalStateException if it is, ensuring that gameLoop is not null if the game has started. Since the specific call site is within operational game code (not a shutdown or uninitialized scenario), it can be reliably inferred that gameLoop is expected to be non-null when Game.loop() is called in an ongoing game session. Therefore, based on this analysis and provided code context, the method cannot return null at the specific call site.]]></reason>
  <value>NO</value>
</response>
```
11:53:23.876 TRACE edu.ucr.cs.riple.core.checkers.nullaway.codefix.Response.<init>
Response created:
Disagreement: The method Game.loop() returns the static variable gameLoop. From the information provided, it is evident that gameLoop is assigned a new instance of GameLoop during the initialization process in the Game.init() method. This assignment seems to be necessary for further game operations, as the init method includes an invocation gameLoop = new GameLoop(...). There is no code path in Game.init(), Game.start(), or Game.loop() that sets gameLoop to null once it has been instantiated. Furthermore, Game.start(), which is included in the call chain context, checks if gameLoop is null and throws an IllegalStateException if it is, ensuring that gameLoop is not null if the game has started. Since the specific call site is within operational game code (not a shutdown or uninitialized scenario), it can be reliably inferred that gameLoop is expected to be non-null when Game.loop() is called in an ongoing game session. Therefore, based on this analysis and provided code context, the method cannot return null at the specific call site.
11:53:23.876 TRACE edu.ucr.cs.riple.core.checkers.nullaway.codefix.AdvancedNullAwayCodeFix.resolveMethodDereferenceError
Method is not returning nullable on call site. Injecting suppression annotation.
11:53:23.876 TRACE edu.ucr.cs.riple.core.checkers.nullaway.codefix.AdvancedNullAwayCodeFix.constructCastToNonnullChange
Constructing cast to nonnull change for reason: The method Game.loop() returns the static variable gameLoop. From the information provided, it is evident that gameLoop is assigned a new instance of GameLoop during the initialization process in the Game.init() method. This assignment seems to be necessary for further game operations, as the init method includes an invocation gameLoop = new GameLoop(...). There is no code path in Game.init(), Game.start(), or Game.loop() that sets gameLoop to null once it has been instantiated. Furthermore, Game.start(), which is included in the call chain context, checks if gameLoop is null and throws an IllegalStateException if it is, ensuring that gameLoop is not null if the game has started. Since the specific call site is within operational game code (not a shutdown or uninitialized scenario), it can be reliably inferred that gameLoop is expected to be non-null when Game.loop() is called in an ongoing game session. Therefore, based on this analysis and provided code context, the method cannot return null at the specific call site.
11:53:23.877 TRACE edu.ucr.cs.riple.core.checkers.nullaway.codefix.ChatGPT.ask
Asking ChatGPT:
For the reason you mentioned earlier:

"The method Game.loop() returns the static variable gameLoop. From the information provided, it is evident that gameLoop is assigned a new instance of GameLoop during the initialization process in the Game.init() method. This assignment seems to be necessary for further game operations, as the init method includes an invocation gameLoop = new GameLoop(...). There is no code path in Game.init(), Game.start(), or Game.loop() that sets gameLoop to null once it has been instantiated. Furthermore, Game.start(), which is included in the call chain context, checks if gameLoop is null and throws an IllegalStateException if it is, ensuring that gameLoop is not null if the game has started. Since the specific call site is within operational game code (not a shutdown or uninitialized scenario), it can be reliably inferred that gameLoop is expected to be non-null when Game.loop() is called in an ongoing game session. Therefore, based on this analysis and provided code context, the method cannot return null at the specific call site."

in the method below, the expression Game.loop() is not nullable at the point it is used.

```java
protected void updateAnimationController() {
    IEntityAnimationController<?> controller = this.createAnimationController();
    this.getControllers().addController(controller);
    if (Game.world().environment() != null && Game.world().environment().isLoaded()) {
      Game.loop().attach(controller);
    }
}
```
Please Summarize the reason in max 5 words and rewrite the method so that at the line "      Game.loop().attach(controller);", at the occurrence of: "Game.loop()" is replaced with `Nullability.castToNonnull(Game.loop(), summary of reason)`
Replace "REASON" with the exact reason summary I provide to you (maximum 5 words), not with a generic explanation like "checked to be nonnull".
see the example below, for expression `foo.getBar()`, to wrap it with `Nullability.castToNonnull(foo.getBar(), "reason")`.

```java
public t(){
    String l = foo.getBar();
}
```

will be:
```java
public t(){
    String l = Nullability.castToNonnull(foo.getBar(), "checked to be nonnull");
}
```

### Instructions:

Do not import any additional classes.

Do not add Java comments.

Only modify relevant lines as required.

Return only the modified method wrapped in the XML format shown below.

Place the Java code inside the <code> tag using a CDATA block with ```java formatting.

Just give me the fixed code snippet in XML format in <response> tag like the example below. I will apply the fix to my codebase. Do not import any additional libraries or classes or add java comments. If you can provide the fixed code snippet, please provide it in the following format and place the code snippet in the <code> tag within ```java block.
<response>
  <success>true</success>
  <code><![CDATA[
  ```java
  Your fixed code snippet here
  ```
    ]]>
  </code>
</response>

11:53:23.878 TRACE edu.ucr.cs.riple.core.checkers.nullaway.codefix.ChatGPT.ask
Retrieving response from cache
11:53:23.878 TRACE edu.ucr.cs.riple.core.checkers.nullaway.codefix.Response.tryCreate
Trying to create Response:
```xml
<response>
  <success>true</success>
  <code><![CDATA[
  ```java
  protected void updateAnimationController() {
      IEntityAnimationController<?> controller = this.createAnimationController();
      this.getControllers().addController(controller);
      if (Game.world().environment() != null && Game.world().environment().isLoaded()) {
          Nullability.castToNonnull(Game.loop(), "expected to be non-null").attach(controller);
      }
  }
  ```
    ]]>
  </code>
</response>
```
11:53:23.878 TRACE edu.ucr.cs.riple.core.checkers.nullaway.codefix.Response.<init>
Creating Response:
```xml
<response>
  <success>true</success>
  <code><![CDATA[
  ```java
  protected void updateAnimationController() {
      IEntityAnimationController<?> controller = this.createAnimationController();
      this.getControllers().addController(controller);
      if (Game.world().environment() != null && Game.world().environment().isLoaded()) {
          Nullability.castToNonnull(Game.loop(), "expected to be non-null").attach(controller);
      }
  }
  ```
    ]]>
  </code>
</response>
```
11:53:23.878 TRACE edu.ucr.cs.riple.core.checkers.nullaway.codefix.Response.<init>
Response created:
protected void updateAnimationController() {
      IEntityAnimationController<?> controller = this.createAnimationController();
      this.getControllers().addController(controller);
      if (Game.world().environment() != null && Game.world().environment().isLoaded()) {
          Nullability.castToNonnull(Game.loop(), "expected to be non-null").attach(controller);
      }
  }
11:53:23.878 TRACE edu.ucr.cs.riple.core.checkers.nullaway.codefix.ChatGPT.fixDereferenceByAddingCastToNonnull
Fixing the error by adding castToNonnull
11:53:23.881 TRACE edu.ucr.cs.riple.core.checkers.nullaway.codefix.AdvancedNullAwayCodeFix.fixTriggeredErrorsForLocation
Resolving unresolvable error for triggered error: Type='DEREFERENCE_NULLABLE', message='dereferenced expression Game.loop() is @Nullable'
/home/nima/Developer/nullness-benchmarks/litiengine/src/de/gurkenlabs/litiengine/gui/screens/ScreenManager.java:134
    this.lastScreenChange = Game.loop().getTicks();
11:53:23.881 TRACE edu.ucr.cs.riple.core.checkers.nullaway.codefix.AdvancedNullAwayCodeFix.fix
Fixing error: Type='DEREFERENCE_NULLABLE', message='dereferenced expression Game.loop() is @Nullable'
/home/nima/Developer/nullness-benchmarks/litiengine/src/de/gurkenlabs/litiengine/gui/screens/ScreenManager.java:134
    this.lastScreenChange = Game.loop().getTicks();
11:53:23.881 TRACE edu.ucr.cs.riple.core.checkers.nullaway.codefix.AdvancedNullAwayCodeFix.resolveDereferenceError
Resolving dereference error: Type='DEREFERENCE_NULLABLE', message='dereferenced expression Game.loop() is @Nullable'
/home/nima/Developer/nullness-benchmarks/litiengine/src/de/gurkenlabs/litiengine/gui/screens/ScreenManager.java:134
    this.lastScreenChange = Game.loop().getTicks();
11:53:23.881 TRACE edu.ucr.cs.riple.core.checkers.nullaway.codefix.AdvancedNullAwayCodeFix.resolveDereferenceError
Checking nullability possibility at error point
11:53:23.882 TRACE edu.ucr.cs.riple.core.checkers.nullaway.codefix.ChatGPT.checkNullabilityPossibilityAtErrorPoint
Asking if the expression can be null at error point point
11:53:23.882 TRACE edu.ucr.cs.riple.core.checkers.nullaway.codefix.ChatGPT.ask
Asking ChatGPT:
In the method below, is there a possibility that the expression "Game.loop()" at line "this.lastScreenChange = Game.loop().getTicks();" is null?
public void display(@Nullable final Screen screen) {
    if (Game.hasStarted() && Game.time().since(this.lastScreenChange) < this.getChangeCooldown()) {
      log.log(
          Level.INFO,
          "Skipping displaying of screen {0} because screen changing is currently on cooldown.",
          screen != null ? screen.getName() : "");
      return;
    }

    final Screen previous = this.current();
    if (previous != null) {
      previous.suspend();
    }

    if (screen != null && !this.screens.contains(screen)) {
      this.screens.add(screen);
    }

    this.currentScreen = screen;
    if (!Game.isInNoGUIMode() && this.current() != null) {
      this.current().prepare();
    }

    this.lastScreenChange = Game.loop().getTicks();

    final ScreenChangedEvent event = new ScreenChangedEvent(this.current(), previous);
    for (final ScreenChangedListener listener : this.screenChangedListeners) {
      listener.changed(event);
    }
}
Give a single-word answer in XML format. If it is possible for the expression to be null, respond with:
```xml
<response>
    <reason><![CDATA[YOUR REASON]]></reason>
    <value>YES</value>
</response>
```
If it is not possible for the expression to be null, respond with:
```xml
<response>
    <reason><![CDATA[YOUR REASON]]></reason>
    <value>NO</value>
</response>
```
If you are unsure or need more information, respond with where you can ask for more details or what specific information you need.

If additional information is required, list each request inside a `<request>` tag. If no additional information is needed, omit the `<requests>` section.

Respond with:
```xml
<response>
    <reason><![CDATA[YOUR REASON]]></reason>
    <value>UNKNOWN</value>
    <!-- Include <requests> only if additional information is needed -->
    <requests>
        <request><![CDATA[YOUR REQUEST 1]]></request>
        <request><![CDATA[YOUR REQUEST 2]]></request>
    </requests>
</response>
```
11:53:23.882 TRACE edu.ucr.cs.riple.core.checkers.nullaway.codefix.ChatGPT.ask
Retrieving response from cache
11:53:23.882 TRACE edu.ucr.cs.riple.core.checkers.nullaway.codefix.Response.tryCreate
Trying to create Response:
```xml
<response>
    <reason><![CDATA[The possibility of Game.loop() being null depends on the implementation details of the Game class. If the Game class ensures that loop() always returns a valid instance, then it cannot be null. However, without seeing the implementation of the Game class and how it handles the loop method, we cannot conclusively determine if it can return null.]]></reason>
    <value>UNKNOWN</value>
    <requests>
        <request><![CDATA[What does the Game.loop() method return? Is there any situation where it can return null?]]></request>
        <request><![CDATA[Is there any documentation or source code available for the Game class, specifically focusing on the loop method?]]></request>
    </requests>
</response>
```
11:53:23.882 TRACE edu.ucr.cs.riple.core.checkers.nullaway.codefix.Response.<init>
Creating Response:
```xml
<response>
    <reason><![CDATA[The possibility of Game.loop() being null depends on the implementation details of the Game class. If the Game class ensures that loop() always returns a valid instance, then it cannot be null. However, without seeing the implementation of the Game class and how it handles the loop method, we cannot conclusively determine if it can return null.]]></reason>
    <value>UNKNOWN</value>
    <requests>
        <request><![CDATA[What does the Game.loop() method return? Is there any situation where it can return null?]]></request>
        <request><![CDATA[Is there any documentation or source code available for the Game class, specifically focusing on the loop method?]]></request>
    </requests>
</response>
```
11:53:23.883 TRACE edu.ucr.cs.riple.core.checkers.nullaway.codefix.Response.<init>
Response created:
Unknown: The possibility of Game.loop() being null depends on the implementation details of the Game class. If the Game class ensures that loop() always returns a valid instance, then it cannot be null. However, without seeing the implementation of the Game class and how it handles the loop method, we cannot conclusively determine if it can return null.
11:53:23.883 TRACE edu.ucr.cs.riple.core.checkers.nullaway.codefix.AdvancedNullAwayCodeFix.resolveMethodDereferenceError
Resolving method dereference error.
11:53:23.884 TRACE edu.ucr.cs.riple.core.checkers.nullaway.codefix.AdvancedNullAwayCodeFix.resolveMethodDereferenceError
Method is in annotated package. Checking if the method is returning nullable.
11:53:23.884 TRACE edu.ucr.cs.riple.core.checkers.nullaway.codefix.AdvancedNullAwayCodeFix.investigateMethodReturnNullability
Checking if the method is returning nullable.
11:53:23.885 TRACE edu.ucr.cs.riple.core.checkers.nullaway.codefix.ChatGPT.checkIfMethodIsReturningNullable
Asking if the method is returning nullable: loop()
11:53:23.887 TRACE edu.ucr.cs.riple.core.checkers.nullaway.codefix.ChatGPT.ask
Asking ChatGPT:
In the method below, is there a possibility that the method returns null based only on its body? Consider the following points:

- The method may have multiple return paths; consider all return statements.
- If the method calls another method, do not assume its return value unless its full declaration is provided. Request its declaration if needed.
- The method may throw an exception instead of returning null. An exception path should not be considered a null return.
- Ensure you request the declarations of any methods whose return values directly or indirectly impact this methods return value before making a conclusion.
- Carefully analyze all conditions and prior operations that may guarantee a non-null return value.

@Nullable public static IGameLoop loop() {
    return gameLoop;
}

Here are the method definitions in addition to the method inquired:

Depth: 0
```java
class de.gurkenlabs.litiengine.Game {
@Nullable public static IGameLoop loop() {
    return gameLoop;
}
}
```


Response Format:
Provide the answer in **XML format** as follows:

#### If the method **cannot** return `null`:
```xml
<response>
  <reason><![CDATA[EXPLAIN WHY THE METHOD CANNOT RETURN NULL]]></reason>
  <value>NO</value>
</response>
```

#### If the method can return null:
```xml
<response>
  <reason><![CDATA[EXPLAIN WHY THE METHOD CAN RETURN NULL]]></reason>
  <value>YES</value>
</response>
```

#### If you are unsure or need more information, respond with where you can ask for more details or what specific information you need.

#### If you are unsure or If there are any methods that directly or indirectly affect the return value and are not fully disclosed, request their declarations first, in the following format:
<response>
  <reason><![CDATA[YOUR REASON]]></reason>
  <value>UNKNOWN</value>
  <methods>
    <method>methodName</method>
  </methods>
</response>

If additional information is required other than method declaration, list each request inside a `<request>` tag. If no additional information is needed, omit the `<requests>` section.

Respond with:
```xml
<response>
    <reason><![CDATA[YOUR REASON]]></reason>
    <value>UNKNOWN</value>
    <!-- Include <requests> only if additional information is needed -->
    <requests>
        <request><![CDATA[YOUR REQUEST 1]]></request>
        <request><![CDATA[YOUR REQUEST 2]]></request>
    </requests>
</response>
```

Additional Notes:
Be precise in your reasoning.
If a methods return value depends on another method not provided, request its declaration before making a conclusion.
If the method can return null in some cases but not others, explain under what conditions it can happen.

11:53:23.888 TRACE edu.ucr.cs.riple.core.checkers.nullaway.codefix.ChatGPT.ask
Retrieving response from cache
11:53:23.888 TRACE edu.ucr.cs.riple.core.checkers.nullaway.codefix.Response.tryCreate
Trying to create Response:
```xml
<response>
  <reason><![CDATA[The method `loop` returns the variable `gameLoop`. Without the initialization or assignment details of `gameLoop`, it's unclear whether it can be null. The possibility of `gameLoop` being uninitialized or set to null elsewhere in the program means `loop` could potentially return null. Further information on `gameLoop` is required.]]></reason>
  <value>UNKNOWN</value>
  <requests>
    <request><![CDATA[Please provide the declaration and initialization of the variable `gameLoop` in the class `de.gurkenlabs.litiengine.Game`.]]></request>
  </requests>
</response>
```
11:53:23.888 TRACE edu.ucr.cs.riple.core.checkers.nullaway.codefix.Response.<init>
Creating Response:
```xml
<response>
  <reason><![CDATA[The method `loop` returns the variable `gameLoop`. Without the initialization or assignment details of `gameLoop`, it's unclear whether it can be null. The possibility of `gameLoop` being uninitialized or set to null elsewhere in the program means `loop` could potentially return null. Further information on `gameLoop` is required.]]></reason>
  <value>UNKNOWN</value>
  <requests>
    <request><![CDATA[Please provide the declaration and initialization of the variable `gameLoop` in the class `de.gurkenlabs.litiengine.Game`.]]></request>
  </requests>
</response>
```
11:53:23.888 TRACE edu.ucr.cs.riple.core.checkers.nullaway.codefix.Response.<init>
Response created:
Unknown: The method `loop` returns the variable `gameLoop`. Without the initialization or assignment details of `gameLoop`, it's unclear whether it can be null. The possibility of `gameLoop` being uninitialized or set to null elsewhere in the program means `loop` could potentially return null. Further information on `gameLoop` is required.
11:53:23.888 TRACE edu.ucr.cs.riple.core.checkers.nullaway.codefix.AdvancedNullAwayCodeFix.investigateMethodReturnNullability
Could not determine the nullability and model did not ask for any method.
11:53:23.888 TRACE edu.ucr.cs.riple.core.checkers.nullaway.codefix.ChatGPT.checkIfMethodIsReturningNullableOnCallSite
Asking if the method is returning nullable on the call site: Game.loop()
11:53:24.129 TRACE edu.ucr.cs.riple.core.checkers.nullaway.codefix.ChatGPT.ask
Asking ChatGPT:
In the method below, is there a possibility that the method returns null at the given call site?

```java
@Nullable public static IGameLoop loop() {
    return gameLoop;
}
```

## Guidelines:
- The method may have multiple return paths; consider all return statements.
- If the method calls another method, do not assume its return value unless its full declaration is provided. Request its declaration if needed.
- The method may throw an exception instead of returning null. An exception path should not be considered a null return.
- Ensure you request the declarations of any methods whose return values directly or indirectly impact this methods return value before making a conclusion.
- If the method returns a value that is determined by a parameter, evaluate based on the actual argument at the given call site.
- Analyze based only on the specific invocation provided. Do not generalize to all possible inputs.- If the return value is guaranteed to be non-null at the call site, the answer should be a definitive NO.
- Do not generalize based on all possible inputsyour answer must be based only on the given invocation.
- Focus only on the given call site, not all possible invocations.

### call site:
Game.loop()

Here are the method definitions and the call chain for this method, showing the sequence of calls from the method to its callers at each depth level:

Depth: 0
```java
class de.gurkenlabs.litiengine.Game {
@Nullable public static IGameLoop loop() {
    return gameLoop;
}
}
```
Depth: 1
```java
class de.gurkenlabs.litiengine.environment.GameWorld {
public void loadEnvironment(@Nullable final Environment env) {
    Lock lock = Game.loop().getLock();
    lock.lock();
    try {
      unloadEnvironment();
      this.environment = env;
      if (env != null) {
        this.addEnvironment(env);

        if (env.getGravity() == 0 && this.gravity() != 0) {
          env.setGravity(this.gravity());
        }

        env.load();
        for (final EnvironmentLoadedListener listener : this.loadedListeners) {
          listener.loaded(env);
        }

        // call map specific listeners
        String mapName = getMapName(env);
        if (mapName != null && this.environmentLoadedListeners.containsKey(mapName)) {

          // for the default camera we center the camera on the environment
          if (this.camera().getClass().equals(Camera.class)) {
            camera().setFocus(env.getCenter());
          }

          for (EnvironmentLoadedListener listener : this.environmentLoadedListeners.get(mapName)) {
            listener.loaded(env);
          }
        }
      }
    } finally {
      lock.unlock();
    }
}public void setCamera(@Nullable final ICamera cam) {
    if (this.camera() != null) {
      Game.loop().detach(camera);
    }

    camera = cam;

    if (cam != null && !Game.isInNoGUIMode()) {
      Game.loop().attach(cam);
      cam.updateFocus();
    }
}
}
```
```java
class de.gurkenlabs.litiengine.entities.behavior.EntityNavigator {
public EntityNavigator(final IMobileEntity entity, final PathFinder pathFinder) {
    this.cancelNavigationConditions = new CopyOnWriteArrayList<>();
    this.listeners = new CopyOnWriteArrayList<>();
    this.entity = entity;
    this.pathFinder = pathFinder;
    this.setAcceptableError(DEFAULT_ACCEPTABLE_ERROR);
    Game.loop().attach(this);
}
}
```
```java
class de.gurkenlabs.litiengine.GameWindow {
private static void initializeWindowEventListeners(Window window) {

    window.addWindowStateListener(
        e -> {
          if (e.getNewState() == Frame.ICONIFIED) {
            Game.loop().setTickRate(ICONIFIED_MAX_FPS);
          } else {
            Game.loop().setTickRate(Game.config().client().getMaxFps());
          }
        });

    window.addWindowFocusListener(
        new WindowFocusListener() {
          @Override
          public void windowLostFocus(WindowEvent e) {
            if (Game.config().graphics().reduceFramesWhenNotFocused()) {
              Game.loop().setTickRate(NONE_FOCUS_MAX_FPS);
            }
          }

          @Override
          public void windowGainedFocus(WindowEvent e) {
            Game.loop().setTickRate(Game.config().client().getMaxFps());
          }
        });

    window.addWindowListener(
        new WindowAdapter() {
          @Override
          public void windowClosing(final WindowEvent event) {
            Game.exit();
          }
        });
}
}
```
```java
class de.gurkenlabs.litiengine.gui.screens.ScreenManager {
public void display(@Nullable final Screen screen) {
    if (Game.hasStarted() && Game.time().since(this.lastScreenChange) < this.getChangeCooldown()) {
      log.log(
          Level.INFO,
          "Skipping displaying of screen {0} because screen changing is currently on cooldown.",
          screen != null ? screen.getName() : "");
      return;
    }

    final Screen previous = this.current();
    if (previous != null) {
      previous.suspend();
    }

    if (screen != null && !this.screens.contains(screen)) {
      this.screens.add(screen);
    }

    this.currentScreen = screen;
    if (!Game.isInNoGUIMode() && this.current() != null) {
      this.current().prepare();
    }

    this.lastScreenChange = Game.loop().getTicks();

    final ScreenChangedEvent event = new ScreenChangedEvent(this.current(), previous);
    for (final ScreenChangedListener listener : this.screenChangedListeners) {
      listener.changed(event);
    }
}
}
```
```java
class de.gurkenlabs.litiengine.abilities.effects.Effect {
@Override
  public void update() {

    for (final Iterator<EffectApplication> iterator = this.getActiveAppliances().iterator();
        iterator.hasNext(); ) {
      final EffectApplication appliance = iterator.next();
      // if the effect duration is reached
      if (this.hasEnded(appliance)) {

        iterator.remove();
        this.cease(appliance);
      }
    }

    // 4. unregister if all appliances are finished
    if (this.getActiveAppliances().isEmpty()) {
      Game.loop().detach(this);
    }
}public void apply(final Shape impactArea) {
    final List<ICombatEntity> affected = this.lookForAffectedEntities(impactArea);
    for (final ICombatEntity affectedEntity : affected) {
      this.apply(affectedEntity);
    }

    this.appliances.add(new EffectApplication(affected, impactArea));

    // if it is the first appliance -> register for update
    if (this.appliances.size() == 1) {
      Game.loop().attach(this);
    }
}
}
```
```java
class de.gurkenlabs.litiengine.GameTime {
public long toTicks(final int milliseconds) {
    return this.toTicks(milliseconds, Game.loop().getTickRate());
}public long since(final long tick) {
    return toMilliseconds(Game.loop().getTicks() - tick);
}public long now() {
    return Game.loop().getTicks();
}public long sinceGameStart() {
    return this.toMilliseconds(Game.loop().getTicks());
}@Override
  public void loaded(Environment environment) {
    environmentLoaded = Game.loop().getTicks();
}public long toMilliseconds(final long ticks) {
    return this.toMilliseconds(ticks, Game.loop().getTickRate());
}
}
```
```java
class de.gurkenlabs.litiengine.GameMetrics {
@Override
  public void render(final Graphics2D g) {
    this.updateMetrics();

    if (!Game.config().client().showGameMetrics()) {
      return;
    }

    this.currentOffsetY = 0;

    g.setColor(this.renderColor);

    // render client metrics
    this.drawTitle(g, "[client]");
    this.drawMetric(g, "fps       : " + this.getFramesPerSecond());
    this.drawMetric(g, "max fps   : " + this.maxFramesPerSecond);
    this.drawMetric(g, "updatables: " + Game.loop().getUpdatableCount());

    // render jvm metrics if debug is enabled
    if (Game.config().debug().isDebugEnabled()) {
      this.drawTitle(g, "[jvm]");
      this.drawMetric(g, "java      : " + this.javaVersion);
      this.drawMetric(g, "memory    : " + String.format("%-5.5s", this.usedMemory) + " MB");
      this.drawMetric(g, "threads   : " + Thread.activeCount());
    }

    // render rendering metrics
    if (!this.renderMetrics.isEmpty()) {
      this.drawTitle(g, "[update]");

      for (RenderMetrics metric : this.renderMetrics) {
        this.drawMetric(g, metric.toString());
      }

      this.renderMetrics.clear();
    }
}
}
```
```java
class de.gurkenlabs.litiengine.graphics.emitters.Emitter {
public void deactivate() {
    if (!this.activated) {
      return;
    }

    this.activated = false;
    this.getParticles().clear();
    this.aliveTime = 0;
    this.activationTick = 0;
    this.lastSpawn = 0;
    Game.loop().detach(this);
}public void activate() {
    if (this.activated) {
      return;
    }

    this.activated = true;
    this.activationTick = Game.time().now();
    Game.loop().attach(this);
}@Override
  public void update() {
    if (this.isPaused()) {
      return;
    }

    // clear particles if the effect time to life is reached
    if (this.isFinished()) {
      for (EmitterFinishedListener listener : this.finishedListeners) {
        listener.finished(this);
      }

      this.delete();
      return;
    }

    final float updateRatio = (float) this.data().getUpdateRate() / Game.loop().getTickRate();
    for (final Particle p : this.getParticles().stream().collect(Collectors.toList())) {
      if (this.particleCanBeRemoved(p)) {
        // remove dead particles
        this.particles.remove(p);
        continue;
      }

      p.update(this.getOrigin(), updateRatio);
    }

    this.aliveTime = Game.time().since(this.activationTick);
    if ((this.data().getSpawnRate() == 0
        || Game.time().since(this.lastSpawn) >= this.data().getSpawnRate())) {
      this.lastSpawn = Game.time().now();
      this.spawnParticle();
    }
}
}
```
```java
class de.gurkenlabs.litiengine.entities.behavior.IBehaviorController {
public default void attach() {
    Game.loop().attach(this);
}public default void detach() {
    Game.loop().detach(this);
}
}
```
```java
class de.gurkenlabs.litiengine.abilities.AbilityExecution {
AbilityExecution(final Ability ability) {
    this.appliedEffects = new CopyOnWriteArrayList<>();
    this.ability = ability;
    this.executionTicks = Game.time().now();
    this.impactArea = ability.calculateImpactArea();
    this.castLocation = ability.getExecutor().getCenter();
    Game.loop().attach(this);
}@Override
  public void update() {
    // if there a no effects to apply -> unregister this instance and we're done
    if (this.getAbility().getEffects().isEmpty()
        || this.getAbility().getEffects().size() == this.getAppliedEffects().size()) {
      Game.loop().detach(this);
      return;
    }

    // handle all effects from the ability that were not applied yet
    for (final Effect effect : this.getAbility().getEffects()) {
      // if the ability was not executed yet or the delay of the effect is not
      // yet reached
      if (this.getAppliedEffects().contains(effect)
          || Game.time().since(this.getExecutionTicks()) < effect.getDelay()) {
        continue;
      }

      effect.apply(this.getExecutionImpactArea());
      this.getAppliedEffects().add(effect);
    }
}
}
```
```java
class de.gurkenlabs.litiengine.GameWindow$3 {
@Override
          public void windowGainedFocus(WindowEvent e) {
            Game.loop().setTickRate(Game.config().client().getMaxFps());
}@Override
          public void windowLostFocus(WindowEvent e) {
            if (Game.config().graphics().reduceFramesWhenNotFocused()) {
              Game.loop().setTickRate(NONE_FOCUS_MAX_FPS);
            }
}
}
```
```java
class de.gurkenlabs.litiengine.environment.EntitySpawner {
protected void spawnNewEntities() {
    if (this.getSpawnMode() != SpawnMode.CUSTOMSPAWNPOINTS && this.getSpawnPoints().isEmpty()) {
      return;
    }

    switch (this.getSpawnMode()) {
      case ALLSPAWNPOINTS:
        for (int i = 0; i < this.getSpawnPoints().size(); i++) {
          final int index = i;
          Game.loop()
              .perform(
                  this.getSpawnDelay() + this.getSpawnDelay() * i,
                  () -> this.spawn(this.getSpawnPoints().get(index), this.getSpawnAmount()));
        }
        break;
      case ONERANDOMSPAWNPOINT:
        this.spawn(Game.random().choose(this.getSpawnPoints()), this.getSpawnAmount());
        break;
      case RANDOMSPAWNPOINTS:
        for (int i = 0; i < this.getSpawnAmount(); i++) {
          Game.loop()
              .perform(
                  this.getSpawnDelay() + this.getSpawnDelay() * i,
                  () -> this.spawn(Game.random().choose(this.getSpawnPoints()), 1));
        }
        break;
      case CUSTOMSPAWNPOINTS:
        List<Spawnpoint> spawnPoints =
            this.customSpawnpoints != null
                ? this.customSpawnpoints.apply(this)
                : this.getCustomSpawnpoints();

        int index = 0;
        for (Spawnpoint spawn : spawnPoints) {
          Game.loop()
              .perform(
                  this.getSpawnDelay() + this.getSpawnDelay() * index, () -> this.spawn(spawn, 1));
          index++;
        }
        break;
      default:
        break;
    }
}
}
```
```java
class de.gurkenlabs.litiengine.tweening.TweenEngine {
@Override
  public void start() {
    Game.loop().attach(this);
}@Override
  public void terminate() {
    Game.loop().detach(this);
}
}
```
```java
class de.gurkenlabs.litiengine.gui.SpeechBubble {
public void hide() {
    Game.world().environment().removeRenderable(this);
    Game.loop().detach(this);
    if (activeSpeechBubbles.get(this.getEntity()) != null
        && activeSpeechBubbles.remove(this.getEntity()).equals(this)) {
      activeSpeechBubbles.remove(this.getEntity());
    }

    for (SpeechBubbleListener listener : this.listeners) {
      listener.hidden();
    }
}private SpeechBubble(
      final IEntity entity,
      final String text,
      @Nullable SpeechBubbleAppearance appearance,
      @Nullable Font font) {
    if (appearance == null) {
      this.appearance = DEFAULT_APPEARANCE;
    } else {
      this.appearance = appearance;
    }

    final SpeechBubble active = activeSpeechBubbles.get(entity);
    if (active != null) {
      active.hide();
    }
    this.setFont(font);

    this.textBoxWidth = (float) (entity.getWidth() * 4);
    this.entity = entity;

    this.currentText = text;
    this.currentTextDisplayTime = DISPLAYTIME_MIN + text.length() * DISPLAYTIME_PER_LETTER;

    this.lastTextDisplay = Game.time().now();
    this.createBubbleImage();
    entity.getEnvironment().add(this, RenderType.UI);
    Game.loop().attach(this);
    activeSpeechBubbles.put(entity, this);
}
}
```
```java
class de.gurkenlabs.litiengine.entities.Prop {
private void updateAnimationController() {
    IEntityAnimationController<?> controller = this.createAnimationController();
    this.getControllers().addController(controller);
    if (Game.world().environment() != null && Game.world().environment().isLoaded()) {
      Game.loop().attach(controller);
    }
}
}
```
```java
class de.gurkenlabs.litiengine.graphics.FreeFlightCamera {
public FreeFlightCamera(final Point2D focus) {
    this.setFocus(focus);
    this.velocity = DEFAULT_SCROLL_PIXELS_PER_SECOND;
    this.scrollPadding = DEFAULT_SCROLL_PADDING;
    this.setClampToMap(true);

    Game.loop().attach(this);
}private void handleFreeFlightCamera() {
    if (Game.world().environment() == null || Game.world().environment().getMap() == null) {
      return;
    }

    final Point2D mouseLocation = Input.mouse().getLocation();

    final double scrollSpeed =
        this.getVelocity()
            / (double) Game.loop().getTickRate()
            * Game.config().input().getMouseSensitivity();

    double x = this.getFocus().getX();
    double y = this.getFocus().getY();

    double deltaX = 0;
    if (mouseLocation.getX() < this.getScrollPadding()) {
      deltaX -= scrollSpeed;
    } else if (Game.window().getResolution().getWidth() - mouseLocation.getX()
        < this.getScrollPadding()) {
      deltaX += scrollSpeed;
    }

    double deltaY = 0;
    if (mouseLocation.getY() < this.getScrollPadding()) {
      deltaY -= scrollSpeed;
    } else if (Game.window().getResolution().getHeight() - mouseLocation.getY()
        < this.getScrollPadding()) {
      deltaY += scrollSpeed;
    }

    x += deltaX;
    y += deltaY;

    this.setFocus(new Point2D.Double(x, y));
}
}
```
```java
class de.gurkenlabs.litiengine.environment.Environment {
private static void dispose(final Collection<? extends IEntity> entities) {
    for (final IEntity entity : entities) {
      if (entity instanceof IUpdateable) {
        Game.loop().detach((IUpdateable) entity);
      }

      entity.detachControllers();
    }
}private static void loadUpdatableOrEmitterEntity(IEntity entity) {
    if (entity instanceof Emitter) {
      final Emitter emitter = (Emitter) entity;
      if (emitter.isActivateOnInit()) {
        emitter.activate();
      }
    } else if (entity instanceof IUpdateable) {
      Game.loop().attach((IUpdateable) entity);
    }
}private void unload(final IEntity entity) {
    // 1. remove from physics engine
    if (entity instanceof ICollisionEntity) {
      Game.physics().remove((ICollisionEntity) entity);
    }

    // 2. unregister from update
    if (entity instanceof IUpdateable) {
      Game.loop().detach((IUpdateable) entity);
    }

    if (entity instanceof IMobileEntity) {
      this.removeGravity((IMobileEntity) entity);
    }

    // 3. detach all controllers
    entity.detachControllers();

    if (entity instanceof Emitter) {
      Emitter em = (Emitter) entity;
      em.deactivate();
    }

    if (this.loaded && (entity instanceof LightSource || entity instanceof StaticShadow)) {
      this.updateLighting(entity);
    }

    entity.removed(this);
}
}
```
```java
class de.gurkenlabs.litiengine.graphics.animation.Animation {
@Override
  public void update() {
    // do nothing if the animation is not playing or the current keyframe is not finished
    if (!this.isPlaying()
        || Game.time().since(this.lastFrameUpdate) < this.getCurrentKeyFrame().getDuration()) {
      return;
    }

    // if we are not looping and the last keyframe is finished, we terminate the animation
    if (!this.isLooping() && this.isLastKeyFrame()) {
      this.terminate();
      return;
    }

    // make sure, we stay inside the keyframe list
    final int newFrameIndex =
        (this.getKeyframes().indexOf(this.currentFrame) + 1) % this.getKeyframes().size();
    final KeyFrame previousFrame = this.currentFrame;
    this.currentFrame = this.getKeyframes().get(newFrameIndex);

    for (KeyFrameListener listener : this.listeners) {
      listener.currentFrameChanged(previousFrame, this.currentFrame);
    }

    this.lastFrameUpdate = Game.loop().getTicks();
}public void restart() {
    this.currentFrame = this.firstFrame;
    this.lastFrameUpdate = Game.loop().getTicks();
}
}
```
```java
class de.gurkenlabs.litiengine.physics.MovementController {
@Override
  public void attach() {
    Game.loop().attach(this);
}private void handleForces() {
    // clean up forces
    this.activeForces.forEach(
        x -> {
          if (x.hasEnded()) {
            this.activeForces.remove(x);
          }
        });

    if (this.activeForces.isEmpty()) {
      return;
    }

    // disable turn-on-move for force handling
    boolean turn = this.getEntity().turnOnMove();
    this.getEntity().setTurnOnMove(false);
    try {
      double deltaX = 0;
      double deltaY = 0;
      for (final Force force : this.activeForces) {
        if (force.cancelOnReached() && force.hasReached(this.getEntity())) {
          force.end();
          continue;
        }

        final Point2D collisionBoxCenter = this.getEntity().getCollisionBoxCenter();
        final double angle =
            GeometricUtilities.calcRotationAngleInDegrees(collisionBoxCenter, force.getLocation());
        final double strength =
            Game.loop().getDeltaTime() * 0.001f * force.getStrength() * Game.loop().getTimeScale();
        deltaX += GeometricUtilities.getDeltaX(angle, strength);
        deltaY += GeometricUtilities.getDeltaY(angle, strength);
      }

      final Point2D target =
          new Point2D.Double(this.getEntity().getX() + deltaX, this.getEntity().getY() + deltaY);
      final boolean success = Game.physics().move(this.getEntity(), target);
      if (!success) {
        for (final Force force : this.activeForces) {
          if (force.cancelOnCollision()) {
            force.end();
          }
        }
      }
    } finally {
      this.getEntity().setTurnOnMove(turn);
    }
}@Override
  public void detach() {
    Game.loop().detach(this);
}public void handleMovement() {
    if (!this.isMovementAllowed()) {
      this.velocity = 0;
      return;
    }

    // max distance an entity can travel within one tick
    final double maxPixelsPerTick = this.getEntity().getTickVelocity();
    final double deltaTime = Game.loop().getDeltaTime() * Game.loop().getTimeScale();

    final double acceleration =
        this.getEntity().getAcceleration() == 0
            ? maxPixelsPerTick
            : deltaTime / this.getEntity().getAcceleration() * maxPixelsPerTick;
    final double deceleration =
        this.getEntity().getDeceleration() == 0
            ? this.getVelocity()
            : deltaTime / this.getEntity().getDeceleration() * maxPixelsPerTick;

    double dx = this.getDx();
    double dy = this.getDy();
    this.setDx(0);
    this.setDy(0);

    final double deltaVelocity =
        Math.min(Math.sqrt(Math.pow(dx, 2) + Math.pow(dy, 2)), acceleration);
    if (deltaVelocity != 0) {
      double newVelocity = this.getVelocity() + deltaVelocity;
      this.setVelocity(newVelocity);
    } else {
      final double newVelocity = Math.max(0, this.getVelocity() - deceleration);
      this.setVelocity(newVelocity);
      dx = GeometricUtilities.getDeltaX(this.moveAngle);
      dy = GeometricUtilities.getDeltaY(this.moveAngle);
    }

    if (this.getVelocity() == 0) {
      this.moveAngle = 0;
      return;
    }

    // actually move entity
    this.moveEntity(dx, dy);
}
}
```
```java
class de.gurkenlabs.litiengine.graphics.animation.AnimationController {
public void detach() {
    Game.loop().detach(this);
}public void attach() {
    Game.loop().attach(this);
}
}
```
```java
class de.gurkenlabs.litiengine.graphics.Camera {
@Override
  public void setZoom(final float targetZoom, final int delay) {
    if (delay == 0) {

      this.zoom = targetZoom;
      this.targetZoom = 0;
      this.zoomDelay = 0;
      this.zoomTick = 0;
      this.zoomStep = 0;

      final ZoomChangedEvent event = new ZoomChangedEvent(this, targetZoom);
      for (final ZoomChangedListener listener : this.zoomListeners) {
        listener.zoomChanged(event);
      }
    } else {
      this.zoomTick = Game.time().now();
      this.targetZoom = targetZoom;
      this.zoomDelay = delay;

      final double tickduration = 1000 / (double) Game.loop().getTickRate();
      final double tickAmount = delay / tickduration;
      final float totalDelta = this.targetZoom - this.zoom;
      this.zoomStep = tickAmount > 0 ? (float) (totalDelta / tickAmount) : totalDelta;
    }
}
}
```
```java
class de.gurkenlabs.litiengine.Game {
public static synchronized void init(String... args) {
    if (initialized) {
      log().log(Level.INFO, "The game has already been initialized.");
      return;
    }

    log.init();
    handleCommandLineArguments(args);

    config().load();
    Locale.setDefault(new Locale(config().client().getCountry(), config().client().getLanguage()));

    gameLoop = new GameLoop("Main Update Loop", config().client().getMaxFps());
    loop().attach(physics());
    loop().attach(world());

    // setup default exception handling for render and update loop
    setUncaughtExceptionHandler(
        new DefaultUncaughtExceptionHandler(config().client().exitOnError()));

    screenManager = new ScreenManager();
    gameWindow = new GameWindow();

    // initialize  the game window
    window().init();
    world.setCamera(new Camera());

    for (GameListener listener : gameListeners) {
      listener.initialized(args);
    }

    if (!isInNoGUIMode()) {
      window().getRenderComponent().onRendered(g -> metrics().render(g));

      graphics()
          .addEntityRenderedListener(
              e -> DebugRenderer.renderEntityDebugInfo(e.getGraphics(), e.getEntity()));

      window().getRenderComponent().onFpsChanged(fps -> metrics().setFramesPerSecond(fps));
      window()
          .setIcons(
              Arrays.asList(
                  Resources.images().get("liti-logo-x16.png"),
                  Resources.images().get("liti-logo-x20.png"),
                  Resources.images().get("liti-logo-x32.png"),
                  Resources.images().get("liti-logo-x48.png")));

      Input.keyboard()
          .onKeyTyped(
              KeyEvent.VK_PRINTSCREEN,
              key -> {
                // don't take a screenshot if a modifier is active
                if (key.getModifiers() != 0) {
                  return;
                }

                window().getRenderComponent().takeScreenshot();
              });
    }

    Runtime.getRuntime().addShutdownHook(new Thread(Game::terminate, "Shutdown"));

    initialized = true;
}
}
```
```java
class de.gurkenlabs.litiengine.entities.Creature {
protected void updateAnimationController() {
        IEntityAnimationController<?> controller = this.createAnimationController();
        this.getControllers().addController(controller);
        if (Game.world().environment() != null && Game.world().environment().isLoaded()) {
            Nullability.castToNonnull(Game.loop(), "expected to be non-null").attach(controller);
        }
}@Override
  public float getTickVelocity() {
    // pixels per ms multiplied by the passed ms
    // ensure that entities don't travel too far in case of lag
    return Math.min(Game.loop().getDeltaTime(), GameLoop.TICK_DELTATIME_LAG)
        * 0.001F
        * this.getVelocity().get()
        * Game.loop().getTimeScale();
}
}
```
Depth: 2
```java
class de.gurkenlabs.litiengine.environment.GameWorld {
public void clear() {
    this.unloadEnvironment();
    this.environments.clear();
    this.setCamera(null);
    Game.physics().clear();

    this.environmentListeners.clear();
    this.environmentLoadedListeners.clear();
    this.environmentUnloadedListeners.clear();

    this.listeners.clear();
    this.loadedListeners.clear();
    this.unloadedListeners.clear();
}@Nullable
  public Environment loadEnvironment(IMap map) {
    Environment env = this.getEnvironment(map);
    this.loadEnvironment(env);
    return env;
}@Nullable
  public Environment loadEnvironment(String mapName) {
    Environment env = this.getEnvironment(mapName);
    this.loadEnvironment(env);
    return env;
}
}
```
```java
class de.gurkenlabs.litiengine.GameWindow {
GameWindow() {
    this.hostControl = new JFrame();

    this.resolutionChangedListeners = new CopyOnWriteArrayList<>();

    this.renderCanvas = new RenderComponent(Game.config().graphics().getResolution());
    this.cursor = new MouseCursor();
    if (!Game.isInNoGUIMode()) {
      this.hostControl.setBackground(Color.BLACK);
      this.hostControl.add(this.renderCanvas);

      this.initializeEventListeners();

      this.hostControl.setTitle(Game.info().getTitle());
      this.hostControl.setDefaultCloseOperation(WindowConstants.DO_NOTHING_ON_CLOSE);
      initializeWindowEventListeners(this.hostControl);
    }
}
}
```
```java
class de.gurkenlabs.litiengine.GameTime {
public long sinceEnvironmentLoad() {
    return this.since(this.environmentLoaded);
}public long since(final long tick) {
    return toMilliseconds(Game.loop().getTicks() - tick);
}public long sinceGameStart() {
    return this.toMilliseconds(Game.loop().getTicks());
}
}
```
```java
class de.gurkenlabs.litiengine.abilities.effects.Effect {
protected void cease(final EffectApplication appliance) {
    // 1. cease the effect for all affected entities
    for (final ICombatEntity entity : appliance.getAffectedEntities()) {
      this.cease(entity);
    }

    // 2. apply follow up effects
    this.getFollowUpEffects().forEach(followUp -> followUp.apply(appliance.getImpactArea()));
}protected boolean hasEnded(final EffectApplication appliance) {
    final long effectDuration = Game.time().since(appliance.getAppliedTicks());
    return effectDuration > this.getDuration();
}
}
```
```java
class de.gurkenlabs.litiengine.abilities.effects.EffectApplication {
protected EffectApplication(final List<ICombatEntity> affectedEntities, final Shape impactArea) {
    this.applied = Game.time().now();
    this.affectedEntities = affectedEntities;
    this.impactArea = impactArea;
}
}
```
```java
class de.gurkenlabs.litiengine.entities.CombatEntity {
@Override
  public boolean wasHit(int timeSpan) {
    return Game.time().since(this.lastHit) < timeSpan;
}@Override
  public void hit(final int damage, @Nullable final Ability ability) {
    if (this.isDead()) {
      return;
    }

    if (!this.isIndestructible()) {
      this.getHitPoints().modifyBaseValue(new AttributeModifier<>(Modification.SUBTRACT, damage));
    }

    final EntityHitEvent event = new EntityHitEvent(this, ability, damage, this.isDead());

    for (final CombatEntityListener listener : this.listeners) {
      listener.hit(event);
    }

    for (final CombatEntityHitListener listener : this.hitListeners) {
      listener.hit(event);
    }

    if (this.isDead()) {
      this.fireDeathEvent();
      this.setCollision(false);
    }

    this.lastHit = Game.time().now();
}
}
```
```java
class de.gurkenlabs.litiengine.graphics.ImageEffect {
protected ImageEffect(final int ttl, final String name) {
    this.ttl = ttl;
    this.name = name;
    this.aliveTick = Game.time().now();
}@Override
  public long getAliveTime() {
    return Game.time().since(this.aliveTick);
}
}
```
```java
class de.gurkenlabs.litiengine.abilities.AbilityExecution {
AbilityExecution(final Ability ability) {
    this.appliedEffects = new CopyOnWriteArrayList<>();
    this.ability = ability;
    this.executionTicks = Game.time().now();
    this.impactArea = ability.calculateImpactArea();
    this.castLocation = ability.getExecutor().getCenter();
    Game.loop().attach(this);
}@Override
  public void update() {
    // if there a no effects to apply -> unregister this instance and we're done
    if (this.getAbility().getEffects().isEmpty()
        || this.getAbility().getEffects().size() == this.getAppliedEffects().size()) {
      Game.loop().detach(this);
      return;
    }

    // handle all effects from the ability that were not applied yet
    for (final Effect effect : this.getAbility().getEffects()) {
      // if the ability was not executed yet or the delay of the effect is not
      // yet reached
      if (this.getAppliedEffects().contains(effect)
          || Game.time().since(this.getExecutionTicks()) < effect.getDelay()) {
        continue;
      }

      effect.apply(this.getExecutionImpactArea());
      this.getAppliedEffects().add(effect);
    }
}
}
```
```java
class de.gurkenlabs.litiengine.tweening.TweenEngine {
@Override
  public void update() {
    for (final Tweenable target : this.getTweens().keySet()) {
      for (final Tween tween : this.getTweens().get(target).values()) {
        if (tween.hasStopped()) {
          continue;
        }
        final long elapsed = Game.time().since(tween.getStartTime());
        if (elapsed >= tween.getDuration()) {
          tween.stop();
          continue;
        }
        final float[] currentValues = new float[tween.getTargetValues().length];
        for (int i = 0; i < tween.getTargetValues().length; i++) {
          currentValues[i] =
              tween.getStartValues()[i]
                  + tween.getEquation().compute(elapsed / (float) tween.getDuration())
                      * (tween.getTargetValues()[i] - tween.getStartValues()[i]);
        }
        tween.getTarget().setTweenValues(tween.getType(), currentValues);
      }
    }
}
}
```
```java
class de.gurkenlabs.litiengine.gui.SpeechBubble {
public static SpeechBubble create(
      final IEntity entity, final String text, SpeechBubbleAppearance appearance, Font font) {
    return new SpeechBubble(entity, text, appearance, font);
}public static SpeechBubble create(final IEntity entity, final Font font, final String text) {
    SpeechBubbleAppearance app =
        new SpeechBubbleAppearance(
            DEFAULT_APPEARANCE.getForeColor(),
            DEFAULT_APPEARANCE.getBackgroundColor1(),
            DEFAULT_APPEARANCE.getBorderColor(),
            DEFAULT_APPEARANCE.getPadding());
    return new SpeechBubble(entity, text, app, font);
}public static SpeechBubble create(final IEntity entity, final String text) {
    return new SpeechBubble(entity, text, null, GuiProperties.getDefaultFont());
}@Override
  public void update() {
    if (this.currentText == null) {
      this.hide();
      return;
    }

    this.entityCenter = Game.world().camera().getViewportLocation(this.getEntity().getCenter());

    // old text was displayed long enough
    if (this.lastTextDisplay != 0
        && Game.time().since(this.lastTextDisplay) > this.currentTextDisplayTime) {
      this.currentText = null;
      this.lastTextDisplay = 0;
      return;
    }

    // display new text
    if (this.textIndex < this.currentText.length()
        && Game.time().since(this.lastCharPoll) > LETTER_WRITE_DELAY) {
      this.textIndex++;
      this.lastCharPoll = Game.time().now();
      if (this.typeSound != null) {
        Game.audio().playSound(this.typeSound, this.getEntity());
      }
    }

    // continue displaying currently displayed text
}private SpeechBubble(
      final IEntity entity,
      final String text,
      final Sound typeSound,
      SpeechBubbleAppearance appearance,
      Font font) {
    this(entity, text, appearance, font);
    this.typeSound = typeSound;
}private SpeechBubble(
      final IEntity entity,
      final String text,
      @Nullable SpeechBubbleAppearance appearance,
      @Nullable Font font) {
    if (appearance == null) {
      this.appearance = DEFAULT_APPEARANCE;
    } else {
      this.appearance = appearance;
    }

    final SpeechBubble active = activeSpeechBubbles.get(entity);
    if (active != null) {
      active.hide();
    }
    this.setFont(font);

    this.textBoxWidth = (float) (entity.getWidth() * 4);
    this.entity = entity;

    this.currentText = text;
    this.currentTextDisplayTime = DISPLAYTIME_MIN + text.length() * DISPLAYTIME_PER_LETTER;

    this.lastTextDisplay = Game.time().now();
    this.createBubbleImage();
    entity.getEnvironment().add(this, RenderType.UI);
    Game.loop().attach(this);
    activeSpeechBubbles.put(entity, this);
}
}
```
```java
class de.gurkenlabs.litiengine.gui.TextFieldComponent {
@Override
  public void render(final Graphics2D g) {
    super.render(g);
    g.setFont(this.getFont());
    final FontMetrics fm = g.getFontMetrics();

    if (this.isSelected() && Game.time().since(this.lastToggled) > this.flickerDelay) {
      this.cursorVisible = !this.cursorVisible;
      this.lastToggled = Game.time().now();
    }
    if (this.isSelected() && this.cursorVisible) {
      final Rectangle2D cursor =
          new Rectangle2D.Double(
              this.getX() + this.getTextX() + fm.stringWidth(this.getTextToRender(g)),
              this.getY() + this.getTextY(),
              this.getFont().getSize2D() * 3 / 5,
              this.getFont().getSize2D() * 1 / 5);
      g.setColor(this.getAppearance().getForeColor());
      g.fill(cursor);
    }
}
}
```
```java
class de.gurkenlabs.litiengine.entities.Prop {
public Prop(
      final Point2D location, @Nullable final String spritesheetName, final Material material) {
    super();
    this.rotation = Rotation.NONE;
    this.spritesheetName = spritesheetName;
    this.material = material;
    this.setLocation(location);
    this.updateAnimationController();
}public void setSpritesheetName(@Nullable final String spriteName) {
    this.spritesheetName = spriteName;
    this.updateAnimationController();
}
}
```
```java
class de.gurkenlabs.litiengine.tweening.Tween {
public Tween begin() {
    this.started = Game.time().now();
    this.stopped = false;
    return this;
}
}
```
```java
class de.gurkenlabs.litiengine.graphics.emitters.particles.Particle {
public void update(final Point2D emitterOrigin, final float updateRatio) {
    if (this.aliveTick == 0) {
      this.aliveTick = Game.time().now();
    }

    this.aliveTime = Game.time().since(this.aliveTick);
    if (this.timeToLiveReached()) {
      return;
    }

    if (this.colliding) {
      return;
    }

    if (this.getDeltaWidth() != 0) {
      this.width += this.getDeltaWidth() * updateRatio;
    }

    if (this.getDeltaHeight() != 0) {
      this.height += this.getDeltaHeight() * updateRatio;
    }

    if (this.getDeltaAngle() != 0) {
      this.angle += this.getDeltaAngle() * updateRatio;
    }

    // test for ray cast collision
    final float targetX = this.x + this.getVelocityX() * updateRatio;
    final float targetY = this.y + this.getVelocityY() * updateRatio;

    if (targetX == this.x && targetY == this.y) {
      return;
    }

    if (this.checkForCollision(emitterOrigin, targetX, targetY)) {
      return;
    }

    if (this.getVelocityX() != 0) {
      this.x = targetX;
    }

    if (this.getVelocityY() != 0) {
      this.y = targetY;
    }

    if (this.getAccelerationX() != 0) {
      this.velocityX += this.getAccelerationX() * updateRatio;
    }

    if (this.getAccelerationY() != 0) {
      this.velocityY += this.getAccelerationY() * updateRatio;
    }
}
}
```
```java
class de.gurkenlabs.litiengine.graphics.animation.Animation {
@Override
  public void start() {
    this.playing = true;
    if (this.getKeyframes().isEmpty()) {
      return;
    }

    this.restart();
}@Override
  public void update() {
    // do nothing if the animation is not playing or the current keyframe is not finished
    if (!this.isPlaying()
        || Game.time().since(this.lastFrameUpdate) < this.getCurrentKeyFrame().getDuration()) {
      return;
    }

    // if we are not looping and the last keyframe is finished, we terminate the animation
    if (!this.isLooping() && this.isLastKeyFrame()) {
      this.terminate();
      return;
    }

    // make sure, we stay inside the keyframe list
    final int newFrameIndex =
        (this.getKeyframes().indexOf(this.currentFrame) + 1) % this.getKeyframes().size();
    final KeyFrame previousFrame = this.currentFrame;
    this.currentFrame = this.getKeyframes().get(newFrameIndex);

    for (KeyFrameListener listener : this.listeners) {
      listener.currentFrameChanged(previousFrame, this.currentFrame);
    }

    this.lastFrameUpdate = Game.loop().getTicks();
}
}
```
```java
class de.gurkenlabs.litiengine.graphics.animation.AnimationController {
@Override
  public void update() {
    for (final Animation animation : this.getAll()) {
      animation.update();
    }

    if (this.getCurrent() != null && this.getCurrent().isPaused()) {
      return;
    }

    final boolean playbackFinished = this.getCurrent() != null && !this.getCurrent().isPlaying();
    if (playbackFinished) {
      for (final AnimationListener listener : this.listeners) {
        listener.finished(this.getCurrent());
      }
    }

    if (this.getCurrent() == null || playbackFinished) {
      if (this.getDefault() != null) {
        this.play(this.getDefault().getName());
      } else {
        this.currentAnimation = null;
      }
    }
}
}
```
```java
class de.gurkenlabs.litiengine.graphics.RenderComponent {
private void handleFade() {
    if (this.fadeOutStart != -1) {
      final long timePassed = Game.time().since(this.fadeOutStart);
      this.currentAlpha = MathUtilities.clamp(1 - timePassed / (float) this.fadeOutTime, 0, 1);
      if (this.currentAlpha == 0f) {
        this.fadeOutStart = -1;
        this.fadeOutTime = -1;
      }

      return;
    }

    if (this.fadeInStart != -1) {
      final long timePassed = Game.time().since(this.fadeInStart);
      this.currentAlpha = MathUtilities.clamp(timePassed / (float) this.fadeInTime, 0, 1);
      if (this.currentAlpha == 1f) {
        this.fadeInStart = -1;
        this.fadeInTime = -1;
        this.currentAlpha = Float.NaN;
      }
    }
}public void fadeOut(final int ms) {
    this.fadeInStart = -1;
    this.fadeInTime = -1;
    this.fadeOutStart = Game.time().now();
    this.fadeOutTime = ms;
}public void fadeIn(final int ms) {
    this.fadeOutStart = -1;
    this.fadeOutTime = -1;
    this.fadeInStart = Game.time().now();
    this.fadeInTime = ms;
}
}
```
```java
class de.gurkenlabs.litiengine.entities.Trigger {
private boolean activate(final IEntity activator, final int tar) {
    if (!this.isLoaded()
        || this.isOneTimeTrigger && this.isActivated
        || this.getActivationType() == TriggerActivation.COLLISION
            && activator != null
            && this.collisionActivated.contains(activator)) {
      return false;
    }

    if (this.getCooldown() > 0 && Game.time().since(this.lastActivation) < this.getCooldown()) {
      return false;
    }

    List<Integer> triggerTargets = this.getTargets(tar);

    final TriggerEvent te = new TriggerEvent(this, activator, triggerTargets);

    if (!this.checkActivationPredicates(te)) {
      return false;
    }

    this.isActivated = true;
    if (activator != null) {
      this.collisionActivated.add(activator);
    }

    // if we actually have a trigger target, we send the message to the target
    for (final int target : triggerTargets) {
      final IEntity entity = this.getEnvironment().get(target);
      if (entity == null) {
        log.log(
            Level.WARNING,
            "trigger [{0}] was activated, but the trigger target [{1}] could not be found on the environment",
            new Object[] {this, target});
        continue;
      }

      entity.sendMessage(this, this.message);
    }

    // also send the trigger event to all registered consumers
    for (final TriggerActivatedListener listener : this.activatedListeners) {
      listener.activated(te);
    }

    if (this.isOneTimeTrigger) {
      this.getEnvironment().remove(this);
    }

    this.lastActivation = Game.time().now();
    return true;
}
}
```
```java
class de.gurkenlabs.litiengine.graphics.Camera {
private boolean isShakeEffectActive() {
    return this.getShakeTick() != 0
        && Game.time().since(this.getShakeTick()) < this.getShakeDuration();
}@Override
  public void update() {
    if (Game.world().camera() != null && !Game.world().camera().equals(this)) {
      return;
    }

    if (this.targetZoom > 0) {
      if (Game.time().since(this.zoomTick) >= this.zoomDelay) {
        this.zoom = this.targetZoom;
        this.targetZoom = 0;
        this.zoomDelay = 0;
        this.zoomTick = 0;
        this.zoomStep = 0;
      } else {
        this.zoom += this.zoomStep;
      }

      final ZoomChangedEvent event = new ZoomChangedEvent(this, this.getZoom());
      for (final ZoomChangedListener listener : this.zoomListeners) {
        listener.zoomChanged(event);
      }
    }

    if (this.panTime > 0) {
      if (--this.panTime <= 0) {
        this.setFocus(this.targetFocus);
        this.targetFocus = null;
      } else {
        double diff = this.panTime / (this.panTime + 1.0);
        this.focus =
            new Point2D.Double(
                this.focus.getX() * diff + this.targetFocus.getX() * (1.0 - diff),
                this.focus.getY() * diff + this.targetFocus.getY() * (1.0 - diff));
      }
    }

    if (!this.isShakeEffectActive()) {
      this.shakeOffsetX = 0;
      this.shakeOffsetY = 0;
      return;
    }

    if (Game.time().since(this.lastShake) > this.shakeDelay) {
      this.shakeOffsetX = this.getShakeIntensity() * ThreadLocalRandom.current().nextGaussian();
      this.shakeOffsetY = this.getShakeIntensity() * ThreadLocalRandom.current().nextGaussian();
      this.lastShake = Game.time().now();
    }
}@Override
  public void setZoom(final float targetZoom, final int delay) {
    if (delay == 0) {

      this.zoom = targetZoom;
      this.targetZoom = 0;
      this.zoomDelay = 0;
      this.zoomTick = 0;
      this.zoomStep = 0;

      final ZoomChangedEvent event = new ZoomChangedEvent(this, targetZoom);
      for (final ZoomChangedListener listener : this.zoomListeners) {
        listener.zoomChanged(event);
      }
    } else {
      this.zoomTick = Game.time().now();
      this.targetZoom = targetZoom;
      this.zoomDelay = delay;

      final double tickduration = 1000 / (double) Game.loop().getTickRate();
      final double tickAmount = delay / tickduration;
      final float totalDelta = this.targetZoom - this.zoom;
      this.zoomStep = tickAmount > 0 ? (float) (totalDelta / tickAmount) : totalDelta;
    }
}@Override
  public void shake(final double intensity, final int delay, final int shakeDuration) {
    this.shakeTick = Game.time().now();
    this.shakeDelay = delay;
    this.shakeIntensity = intensity;
    this.shakeDuration = shakeDuration;
}
}
```
```java
class de.gurkenlabs.litiengine.entities.Creature {
public void setSpritesheetName(String spritesheetName) {
    if (this.spritesheetName != null && this.spritesheetName.equals(spritesheetName)) {
      return;
    }

    this.spritesheetName = spritesheetName;
    this.updateAnimationController();
}public boolean isIdle() {
    return Game.time().since(this.lastMoved) > IDLE_DELAY;
}@Override
  public void setLocation(final Point2D position) {
    if (this.isDead() || position == null) {
      return;
    }

    final Point2D oldLocation = this.getLocation();
    super.setLocation(position);

    if (Game.hasStarted() && this.isLoaded()) {
      this.lastMoved = Game.time().now();
      this.fireMovedEvent(
          new EntityMovedEvent(
              this, this.getX() - oldLocation.getX(), this.getY() - oldLocation.getY()));
    }
}
}
```
```java
class de.gurkenlabs.litiengine.gui.screens.ScreenManager {
public void display(final String screenName) {
    if (this.current() != null && this.current().getName().equalsIgnoreCase(screenName)) {
      log.log(
          Level.INFO,
          "Skipping displaying of screen {0} because it is already the current screen.",
          screenName);
      return;
    }

    if (this.screens.stream()
        .noneMatch(element -> element.getName().equalsIgnoreCase(screenName))) {
      log.log(
          Level.WARNING,
          "Could not display the screen {0} because there is no screen with the specified name.",
          screenName);
      return;
    }

    Screen screen = this.get(screenName);
    if (screen == null) {
      return;
    }

    this.display(screen);
}public void add(final Screen screen) {
    screen.setWidth(Game.window().getWidth());
    screen.setHeight(Game.window().getHeight());
    this.screens.add(screen);

    if (this.current() == null) {
      this.display(screen);
    }
}public void remove(Screen screen) {
    this.screens.remove(screen);
    if (this.current() == screen) {
      if (!this.screens.isEmpty()) {
        this.display(this.screens.get(0));
      } else {
        this.display((Screen) null);
      }
    }
}public void display(@Nullable final Screen screen) {
    if (Game.hasStarted() && Game.time().since(this.lastScreenChange) < this.getChangeCooldown()) {
      log.log(
          Level.INFO,
          "Skipping displaying of screen {0} because screen changing is currently on cooldown.",
          screen != null ? screen.getName() : "");
      return;
    }

    final Screen previous = this.current();
    if (previous != null) {
      previous.suspend();
    }

    if (screen != null && !this.screens.contains(screen)) {
      this.screens.add(screen);
    }

    this.currentScreen = screen;
    if (!Game.isInNoGUIMode() && this.current() != null) {
      this.current().prepare();
    }

    this.lastScreenChange = Game.loop().getTicks();

    final ScreenChangedEvent event = new ScreenChangedEvent(this.current(), previous);
    for (final ScreenChangedListener listener : this.screenChangedListeners) {
      listener.changed(event);
    }
}
}
```
```java
class de.gurkenlabs.litiengine.abilities.Ability {
public boolean isOnCooldown() {
    return (this.getCurrentExecution() != null
        && this.getCurrentExecution().getExecutionTicks() > 0
        && Game.time().since(this.getCurrentExecution().getExecutionTicks())
            < this.getAttributes().cooldown().get());
}public boolean isActive() {
    return this.getCurrentExecution() != null
        && Game.time().since(this.getCurrentExecution().getExecutionTicks())
            < this.getAttributes().duration().get();
}@Nullable
  public AbilityExecution cast() {
    if (!this.canCast()) {
      return null;
    }
    this.currentExecution = new AbilityExecution(this);

    for (final AbilityCastListener listener : this.abilityCastListeners) {
      listener.abilityCast(this.currentExecution);
    }

    return this.getCurrentExecution();
}public float getRemainingCooldownInSeconds() {
    if (this.getCurrentExecution() == null
        || this.getExecutor() == null
        || this.getExecutor().isDead()) {
      return 0;
    }

    // calculate cooldown in seconds
    return (float)
        (!this.canCast()
            ? (this.getAttributes().cooldown().get()
                    - Game.time().since(this.getCurrentExecution().getExecutionTicks()))
                * 0.001
            : 0);
}
}
```
```java
class de.gurkenlabs.litiengine.entities.EntityHitEvent {
EntityHitEvent(
      final ICombatEntity hitEntity,
      @Nullable final Ability ability,
      final int damage,
      final boolean kill) {
    super(hitEntity);
    this.executor = ability != null ? ability.getExecutor() : null;
    this.hitEntity = hitEntity;
    this.ability = ability;
    this.damage = damage;
    this.kill = kill;
    this.time = Game.time().now();
}
}
```
```java
class de.gurkenlabs.litiengine.graphics.emitters.Emitter {
public void delete() {
    this.deactivate();
    if (Game.world().environment() != null) {
      Game.world().environment().remove(this);
    }
}public void activate() {
    if (this.activated) {
      return;
    }

    this.activated = true;
    this.activationTick = Game.time().now();
    Game.loop().attach(this);
}@Override
  public void update() {
    if (this.isPaused()) {
      return;
    }

    // clear particles if the effect time to life is reached
    if (this.isFinished()) {
      for (EmitterFinishedListener listener : this.finishedListeners) {
        listener.finished(this);
      }

      this.delete();
      return;
    }

    final float updateRatio = (float) this.data().getUpdateRate() / Game.loop().getTickRate();
    for (final Particle p : this.getParticles().stream().collect(Collectors.toList())) {
      if (this.particleCanBeRemoved(p)) {
        // remove dead particles
        this.particles.remove(p);
        continue;
      }

      p.update(this.getOrigin(), updateRatio);
    }

    this.aliveTime = Game.time().since(this.activationTick);
    if ((this.data().getSpawnRate() == 0
        || Game.time().since(this.lastSpawn) >= this.data().getSpawnRate())) {
      this.lastSpawn = Game.time().now();
      this.spawnParticle();
    }
}
}
```
```java
class de.gurkenlabs.litiengine.GameLoop {
@Override
  public int perform(int delay, Runnable action) {
    final long d = Game.time().toTicks(delay);

    TimedAction a = new TimedAction(this.getTicks() + d, action);
    this.actions.add(a);

    return a.getId();
}
}
```
```java
class de.gurkenlabs.litiengine.environment.EntitySpawner {
protected boolean shouldSpawn() {
    return this.lastSpawnWave == 0
        || Game.time().since(this.lastSpawnWave) >= this.getSpawnInterval();
}@Override
  public void update() {
    if (!this.shouldSpawn()) {
      return;
    }

    this.spawnNewEntities();
    this.lastSpawnWave = Game.time().now();
}
}
```
```java
class de.gurkenlabs.litiengine.graphics.FreeFlightCamera {
@Override
  public void update() {
    this.handleFreeFlightCamera();
}public FreeFlightCamera(double x, double y) {
    this(new Point2D.Double(x, y));
}
}
```
```java
class de.gurkenlabs.litiengine.environment.Environment {
public void unload() {
    if (!this.loaded) {
      return;
    }

    // unregister all updatable entities from the current environment
    for (final IEntity entity : this.allEntities.values()) {
      this.unload(entity);
    }

    this.loaded = false;
    this.fireEvent(l -> l.unloaded(this));
}private static void loadUpdatableOrEmitterEntity(IEntity entity) {
    if (entity instanceof Emitter) {
      final Emitter emitter = (Emitter) entity;
      if (emitter.isActivateOnInit()) {
        emitter.activate();
      }
    } else if (entity instanceof IUpdateable) {
      Game.loop().attach((IUpdateable) entity);
    }
}public void clear() {
    Game.physics().clear();

    this.combatEntities.clear();
    this.mobileEntities.clear();
    this.gravityForces.clear();
    this.layerEntities.clear();
    this.entitiesByTag.clear();
    this.allEntities.clear();

    for (RenderType renderType : RenderType.values()) {
      this.miscEntities.get(renderType).clear();
      this.renderListeners.get(renderType).clear();
      this.renderables.get(renderType).clear();
    }

    dispose(this.allEntities.values());
    dispose(this.triggers);
    this.emitters.clear();
    this.colliders.clear();
    this.props.clear();
    this.creatures.clear();
    this.staticShadows.clear();
    this.combatEntities.clear();
    this.mobileEntities.clear();
    this.lightSources.clear();
    this.spawnPoints.clear();
    this.soundSources.clear();
    this.mapAreas.clear();
    this.triggers.clear();

    this.ambientLight = null;
    this.staticShadowLayer = null;

    for (Map<Integer, IEntity> type : this.miscEntities.values()) {
      type.clear();
    }

    this.initialized = false;

    this.fireEvent(l -> l.cleared(this));
}private void load(final IEntity entity) {
    // an entity can only exist on one environment at a time, so remove it from the current one
    if (entity.getEnvironment() != null) {
      entity.getEnvironment().remove(entity);
    }

    // 1. add to physics engine
    loadPhysicsEntity(entity);

    // 2. register for update or activate
    loadUpdatableOrEmitterEntity(entity);

    // 3. if a gravity is defined, add a gravity force to the entity
    if (entity instanceof IMobileEntity && this.getGravity() != 0) {
      this.addGravityForce((IMobileEntity) entity);
    }

    // 4. attach all controllers
    entity.attachControllers();

    if (this.loaded && (entity instanceof LightSource || entity instanceof StaticShadow)) {
      this.updateLighting(entity);
    }

    entity.loaded(this);
}private void unload(final IEntity entity) {
    // 1. remove from physics engine
    if (entity instanceof ICollisionEntity) {
      Game.physics().remove((ICollisionEntity) entity);
    }

    // 2. unregister from update
    if (entity instanceof IUpdateable) {
      Game.loop().detach((IUpdateable) entity);
    }

    if (entity instanceof IMobileEntity) {
      this.removeGravity((IMobileEntity) entity);
    }

    // 3. detach all controllers
    entity.detachControllers();

    if (entity instanceof Emitter) {
      Emitter em = (Emitter) entity;
      em.deactivate();
    }

    if (this.loaded && (entity instanceof LightSource || entity instanceof StaticShadow)) {
      this.updateLighting(entity);
    }

    entity.removed(this);
}public void remove(final IEntity entity) {
    if (entity == null) {
      return;
    }

    this.allEntities.remove(entity.getMapId());
    Iterator<List<IEntity>> iter = this.layerEntities.values().iterator();
    while (iter.hasNext()) {
      List<IEntity> layer = iter.next();
      if (layer.remove(entity) && layer.isEmpty()) {
        iter.remove();
      }
    }
    if (this.miscEntities.get(entity.getRenderType()) != null) {
      this.miscEntities.get(entity.getRenderType()).values().remove(entity);
    }

    for (String tag : entity.getTags()) {
      if (this.getEntitiesByTag().containsKey(tag)) {
        this.getEntitiesByTag().get(tag).remove(entity);

        if (this.getEntitiesByTag().get(tag).isEmpty()) {
          this.getEntitiesByTag().remove(tag);
        }
      }
    }

    if (entity instanceof Emitter) {
      Emitter emitter = (Emitter) entity;
      this.removeEmitter(emitter);
    }

    if (entity instanceof MapArea) {
      this.mapAreas.remove(entity);
    }

    if (entity instanceof Prop) {
      this.props.remove(entity);
    }

    if (entity instanceof Creature) {
      this.creatures.remove(entity);
    }

    if (entity instanceof CollisionBox) {
      this.colliders.remove(entity);
      this.staticShadows.removeIf(x -> x.getOrigin() != null && x.getOrigin().equals(entity));
    }

    if (entity instanceof LightSource) {
      this.lightSources.remove(entity);
      this.updateLighting(entity);
    }

    if (entity instanceof Trigger) {
      this.triggers.remove(entity);
    }

    if (entity instanceof Spawnpoint) {
      this.spawnPoints.remove(entity);
    }
    if (entity instanceof SoundSource) {
      this.soundSources.remove(entity);
    }

    if (entity instanceof StaticShadow) {
      this.staticShadows.remove(entity);
      this.updateLighting(entity);
    }

    if (entity instanceof IMobileEntity) {
      this.mobileEntities.values().remove(entity);
    }

    if (entity instanceof ICombatEntity) {
      this.combatEntities.values().remove(entity);
    }

    this.unload(entity);

    this.fireEntityEvent(l -> l.entityRemoved(entity));
}
}
```
```java
class de.gurkenlabs.litiengine.physics.MovementController {
@Override
  public void update() {
    this.handleForces();
    this.handleMovement();
}
}
```
```java
class de.gurkenlabs.litiengine.Game {
static synchronized void terminate() {
        if (!initialized || gameLoop == null) {
          return;
        }
    
        hasStarted = false;
        initialized = false;
    
        config().save();
        gameLoop.terminate();
        tweenEngine.terminate();
        soundEngine.terminate();
    
        world().clear();
    
        for (final GameListener listener : gameListeners) {
          try {
            listener.terminated();
          } catch (Exception e) {
            log().log(Level.WARNING, "game listener threw an exception during shutdown", e);
          }
        }
    
        gameLoop = null;
        screenManager = null;
        gameWindow = null;
}public static synchronized void start() {
          if (!initialized) {
              throw new IllegalStateException(
                  "The game cannot be started without being first initialized. Call Game.init(...) before Game.start().");
          }
    
          if (gameLoop == null) {
              throw new IllegalStateException(
                  "Game loop is not initialized. Ensure Game.init(...) has been called successfully.");
          }
          
          Nullability.castToNonnull(gameLoop, "gameLoop cannot be null").start();
          tweenEngine.start();
          soundEngine.start();
    
          for (final GameListener listener : gameListeners) {
              listener.started();
          }
    
          hasStarted = true;
}public static synchronized void init(String... args) {
    if (initialized) {
      log().log(Level.INFO, "The game has already been initialized.");
      return;
    }

    log.init();
    handleCommandLineArguments(args);

    config().load();
    Locale.setDefault(new Locale(config().client().getCountry(), config().client().getLanguage()));

    gameLoop = new GameLoop("Main Update Loop", config().client().getMaxFps());
    loop().attach(physics());
    loop().attach(world());

    // setup default exception handling for render and update loop
    setUncaughtExceptionHandler(
        new DefaultUncaughtExceptionHandler(config().client().exitOnError()));

    screenManager = new ScreenManager();
    gameWindow = new GameWindow();

    // initialize  the game window
    window().init();
    world.setCamera(new Camera());

    for (GameListener listener : gameListeners) {
      listener.initialized(args);
    }

    if (!isInNoGUIMode()) {
      window().getRenderComponent().onRendered(g -> metrics().render(g));

      graphics()
          .addEntityRenderedListener(
              e -> DebugRenderer.renderEntityDebugInfo(e.getGraphics(), e.getEntity()));

      window().getRenderComponent().onFpsChanged(fps -> metrics().setFramesPerSecond(fps));
      window()
          .setIcons(
              Arrays.asList(
                  Resources.images().get("liti-logo-x16.png"),
                  Resources.images().get("liti-logo-x20.png"),
                  Resources.images().get("liti-logo-x32.png"),
                  Resources.images().get("liti-logo-x48.png")));

      Input.keyboard()
          .onKeyTyped(
              KeyEvent.VK_PRINTSCREEN,
              key -> {
                // don't take a screenshot if a modifier is active
                if (key.getModifiers() != 0) {
                  return;
                }

                window().getRenderComponent().takeScreenshot();
              });
    }

    Runtime.getRuntime().addShutdownHook(new Thread(Game::terminate, "Shutdown"));

    initialized = true;
}
}
```


Response Format:
Provide the answer in **XML format** as follows:

#### If the method **cannot** return `null` at the specific call site:
```xml
<response>
  <reason><![CDATA[EXPLAIN WHY THE INVOCATION Game.loop() RESULT CANNOT BE NULL.]]></reason>
  <value>NO</value>
</response>

#### If the method can return null at the specific call site:
<response>
  <reason><![CDATA[EXPLAIN WHY THE INVOCATION Game.loop() RESULT CAN BE NULL.]]></reason>
  <value>YES</value>
</response>

#### If you are unsure or If there are any methods that directly or indirectly affect the return value and are not fully disclosed, request their declarations first, in the following format:
<response>
  <reason><![CDATA[EXPLAIN WHY THIS METHOD DECLARATION IS NECESSARY AND WHY YOU CANNOT MAKE A CONFIDENT DECISION WITHOUT IT]]></reason>
  <success>false</success>
  <methods>
    <method>methodName</method>
  </methods>
</response>

Additional Notes:
Be precise in your reasoning.
If a methods return value depends on another method not provided, request its declaration before making a conclusion.
If the method can return null in this case but not in others, explain why it happens specifically for this call.

11:53:24.131 TRACE edu.ucr.cs.riple.core.checkers.nullaway.codefix.ChatGPT.ask
Retrieving response from cache
11:53:24.131 TRACE edu.ucr.cs.riple.core.checkers.nullaway.codefix.Response.tryCreate
Trying to create Response:
```xml
<response>
  <reason><![CDATA[
    In the provided code and call site at `Game.loop()`, the variable `gameLoop` is a static field in the `Game` class. 
    The code indicates that the `gameLoop` is assigned in the `Game.init(...)` method, which is called before any potential usage of `Game.loop()`. 
    The `init` method checks if the game has already been initialized and only proceeds to set up `gameLoop` if it has not been initialized yet. 
    Therefore, assuming that `init` is properly called before `Game.loop()` is accessed, `gameLoop` should be initialized, and `Game.loop()` cannot return `null`.
  ]]></reason>
  <value>NO</value>
</response>
```
11:53:24.131 TRACE edu.ucr.cs.riple.core.checkers.nullaway.codefix.Response.<init>
Creating Response:
```xml
<response>
  <reason><![CDATA[
    In the provided code and call site at `Game.loop()`, the variable `gameLoop` is a static field in the `Game` class. 
    The code indicates that the `gameLoop` is assigned in the `Game.init(...)` method, which is called before any potential usage of `Game.loop()`. 
    The `init` method checks if the game has already been initialized and only proceeds to set up `gameLoop` if it has not been initialized yet. 
    Therefore, assuming that `init` is properly called before `Game.loop()` is accessed, `gameLoop` should be initialized, and `Game.loop()` cannot return `null`.
  ]]></reason>
  <value>NO</value>
</response>
```
11:53:24.131 TRACE edu.ucr.cs.riple.core.checkers.nullaway.codefix.Response.<init>
Response created:
Disagreement: In the provided code and call site at `Game.loop()`, the variable `gameLoop` is a static field in the `Game` class. 
    The code indicates that the `gameLoop` is assigned in the `Game.init(...)` method, which is called before any potential usage of `Game.loop()`. 
    The `init` method checks if the game has already been initialized and only proceeds to set up `gameLoop` if it has not been initialized yet. 
    Therefore, assuming that `init` is properly called before `Game.loop()` is accessed, `gameLoop` should be initialized, and `Game.loop()` cannot return `null`.
11:53:24.131 TRACE edu.ucr.cs.riple.core.checkers.nullaway.codefix.AdvancedNullAwayCodeFix.resolveMethodDereferenceError
Method is not returning nullable on call site. Injecting suppression annotation.
11:53:24.131 TRACE edu.ucr.cs.riple.core.checkers.nullaway.codefix.AdvancedNullAwayCodeFix.constructCastToNonnullChange
Constructing cast to nonnull change for reason: In the provided code and call site at `Game.loop()`, the variable `gameLoop` is a static field in the `Game` class. 
    The code indicates that the `gameLoop` is assigned in the `Game.init(...)` method, which is called before any potential usage of `Game.loop()`. 
    The `init` method checks if the game has already been initialized and only proceeds to set up `gameLoop` if it has not been initialized yet. 
    Therefore, assuming that `init` is properly called before `Game.loop()` is accessed, `gameLoop` should be initialized, and `Game.loop()` cannot return `null`.
11:53:24.132 TRACE edu.ucr.cs.riple.core.checkers.nullaway.codefix.ChatGPT.ask
Asking ChatGPT:
For the reason you mentioned earlier:

"In the provided code and call site at `Game.loop()`, the variable `gameLoop` is a static field in the `Game` class. 
    The code indicates that the `gameLoop` is assigned in the `Game.init(...)` method, which is called before any potential usage of `Game.loop()`. 
    The `init` method checks if the game has already been initialized and only proceeds to set up `gameLoop` if it has not been initialized yet. 
    Therefore, assuming that `init` is properly called before `Game.loop()` is accessed, `gameLoop` should be initialized, and `Game.loop()` cannot return `null`."

in the method below, the expression Game.loop() is not nullable at the point it is used.

```java
public void display(@Nullable final Screen screen) {
    if (Game.hasStarted() && Game.time().since(this.lastScreenChange) < this.getChangeCooldown()) {
      log.log(
          Level.INFO,
          "Skipping displaying of screen {0} because screen changing is currently on cooldown.",
          screen != null ? screen.getName() : "");
      return;
    }

    final Screen previous = this.current();
    if (previous != null) {
      previous.suspend();
    }

    if (screen != null && !this.screens.contains(screen)) {
      this.screens.add(screen);
    }

    this.currentScreen = screen;
    if (!Game.isInNoGUIMode() && this.current() != null) {
      this.current().prepare();
    }

    this.lastScreenChange = Game.loop().getTicks();

    final ScreenChangedEvent event = new ScreenChangedEvent(this.current(), previous);
    for (final ScreenChangedListener listener : this.screenChangedListeners) {
      listener.changed(event);
    }
}
```
Please Summarize the reason in max 5 words and rewrite the method so that at the line "    this.lastScreenChange = Game.loop().getTicks();", at the occurrence of: "Game.loop()" is replaced with `Nullability.castToNonnull(Game.loop(), summary of reason)`
Replace "REASON" with the exact reason summary I provide to you (maximum 5 words), not with a generic explanation like "checked to be nonnull".
see the example below, for expression `foo.getBar()`, to wrap it with `Nullability.castToNonnull(foo.getBar(), "reason")`.

```java
public t(){
    String l = foo.getBar();
}
```

will be:
```java
public t(){
    String l = Nullability.castToNonnull(foo.getBar(), "checked to be nonnull");
}
```

### Instructions:

Do not import any additional classes.

Do not add Java comments.

Only modify relevant lines as required.

Return only the modified method wrapped in the XML format shown below.

Place the Java code inside the <code> tag using a CDATA block with ```java formatting.

Just give me the fixed code snippet in XML format in <response> tag like the example below. I will apply the fix to my codebase. Do not import any additional libraries or classes or add java comments. If you can provide the fixed code snippet, please provide it in the following format and place the code snippet in the <code> tag within ```java block.
<response>
  <success>true</success>
  <code><![CDATA[
  ```java
  Your fixed code snippet here
  ```
    ]]>
  </code>
</response>

11:53:24.133 TRACE edu.ucr.cs.riple.core.checkers.nullaway.codefix.ChatGPT.ask
Retrieving response from cache
11:53:24.133 TRACE edu.ucr.cs.riple.core.checkers.nullaway.codefix.Response.tryCreate
Trying to create Response:
<response>
  <success>true</success>
  <code><![CDATA[
  ```java
  public void display(final Screen screen) {
    if (Game.hasStarted() && Game.time().since(this.lastScreenChange) < this.getChangeCooldown()) {
      log.log(
          Level.INFO,
          "Skipping displaying of screen {0} because screen changing is currently on cooldown.",
          screen != null ? screen.getName() : "");
      return;
    }

    final Screen previous = this.current();
    if (previous != null) {
      previous.suspend();
    }

    if (screen != null && !this.screens.contains(screen)) {
      this.screens.add(screen);
    }

    this.currentScreen = screen;
    if (!Game.isInNoGUIMode() && this.current() != null) {
      this.current().prepare();
    }

    this.lastScreenChange = Nullability.castToNonnull(Game.loop(), "initialized before usage").getTicks();

    final ScreenChangedEvent event = new ScreenChangedEvent(this.current(), previous);
    for (final ScreenChangedListener listener : this.screenChangedListeners) {
      listener.changed(event);
    }
  }
  ```
    ]]>
  </code>
</response>
11:53:24.133 TRACE edu.ucr.cs.riple.core.checkers.nullaway.codefix.Response.<init>
Creating Response:
<response>
  <success>true</success>
  <code><![CDATA[
  ```java
  public void display(final Screen screen) {
    if (Game.hasStarted() && Game.time().since(this.lastScreenChange) < this.getChangeCooldown()) {
      log.log(
          Level.INFO,
          "Skipping displaying of screen {0} because screen changing is currently on cooldown.",
          screen != null ? screen.getName() : "");
      return;
    }

    final Screen previous = this.current();
    if (previous != null) {
      previous.suspend();
    }

    if (screen != null && !this.screens.contains(screen)) {
      this.screens.add(screen);
    }

    this.currentScreen = screen;
    if (!Game.isInNoGUIMode() && this.current() != null) {
      this.current().prepare();
    }

    this.lastScreenChange = Nullability.castToNonnull(Game.loop(), "initialized before usage").getTicks();

    final ScreenChangedEvent event = new ScreenChangedEvent(this.current(), previous);
    for (final ScreenChangedListener listener : this.screenChangedListeners) {
      listener.changed(event);
    }
  }
  ```
    ]]>
  </code>
</response>
11:53:24.134 TRACE edu.ucr.cs.riple.core.checkers.nullaway.codefix.Response.<init>
Response created:
public void display(final Screen screen) {
    if (Game.hasStarted() && Game.time().since(this.lastScreenChange) < this.getChangeCooldown()) {
      log.log(
          Level.INFO,
          "Skipping displaying of screen {0} because screen changing is currently on cooldown.",
          screen != null ? screen.getName() : "");
      return;
    }

    final Screen previous = this.current();
    if (previous != null) {
      previous.suspend();
    }

    if (screen != null && !this.screens.contains(screen)) {
      this.screens.add(screen);
    }

    this.currentScreen = screen;
    if (!Game.isInNoGUIMode() && this.current() != null) {
      this.current().prepare();
    }

    this.lastScreenChange = Nullability.castToNonnull(Game.loop(), "initialized before usage").getTicks();

    final ScreenChangedEvent event = new ScreenChangedEvent(this.current(), previous);
    for (final ScreenChangedListener listener : this.screenChangedListeners) {
      listener.changed(event);
    }
  }
11:53:24.134 TRACE edu.ucr.cs.riple.core.checkers.nullaway.codefix.ChatGPT.fixDereferenceByAddingCastToNonnull
Fixing the error by adding castToNonnull
11:53:24.144 TRACE edu.ucr.cs.riple.core.checkers.nullaway.codefix.AdvancedNullAwayCodeFix.fixTriggeredErrorsForLocation
Resolving unresolvable error for triggered error: Type='DEREFERENCE_NULLABLE', message='dereferenced expression Game.loop() is @Nullable'
/home/nima/Developer/nullness-benchmarks/litiengine/src/de/gurkenlabs/litiengine/environment/Environment.java:2278
      Game.loop().attach((IUpdateable) entity);
11:53:24.144 TRACE edu.ucr.cs.riple.core.checkers.nullaway.codefix.AdvancedNullAwayCodeFix.fix
Fixing error: Type='DEREFERENCE_NULLABLE', message='dereferenced expression Game.loop() is @Nullable'
/home/nima/Developer/nullness-benchmarks/litiengine/src/de/gurkenlabs/litiengine/environment/Environment.java:2278
      Game.loop().attach((IUpdateable) entity);
11:53:24.144 TRACE edu.ucr.cs.riple.core.checkers.nullaway.codefix.AdvancedNullAwayCodeFix.resolveDereferenceError
Resolving dereference error: Type='DEREFERENCE_NULLABLE', message='dereferenced expression Game.loop() is @Nullable'
/home/nima/Developer/nullness-benchmarks/litiengine/src/de/gurkenlabs/litiengine/environment/Environment.java:2278
      Game.loop().attach((IUpdateable) entity);
11:53:24.144 TRACE edu.ucr.cs.riple.core.checkers.nullaway.codefix.AdvancedNullAwayCodeFix.resolveDereferenceError
Checking nullability possibility at error point
11:53:24.156 TRACE edu.ucr.cs.riple.core.checkers.nullaway.codefix.ChatGPT.checkNullabilityPossibilityAtErrorPoint
Asking if the expression can be null at error point point
11:53:24.156 TRACE edu.ucr.cs.riple.core.checkers.nullaway.codefix.ChatGPT.ask
Asking ChatGPT:
In the method below, is there a possibility that the expression "Game.loop()" at line "Game.loop().attach((IUpdateable) entity);" is null?
private static void loadUpdatableOrEmitterEntity(IEntity entity) {
    if (entity instanceof Emitter) {
      final Emitter emitter = (Emitter) entity;
      if (emitter.isActivateOnInit()) {
        emitter.activate();
      }
    } else if (entity instanceof IUpdateable) {
      Game.loop().attach((IUpdateable) entity);
    }
}
Give a single-word answer in XML format. If it is possible for the expression to be null, respond with:
```xml
<response>
    <reason><![CDATA[YOUR REASON]]></reason>
    <value>YES</value>
</response>
```
If it is not possible for the expression to be null, respond with:
```xml
<response>
    <reason><![CDATA[YOUR REASON]]></reason>
    <value>NO</value>
</response>
```
If you are unsure or need more information, respond with where you can ask for more details or what specific information you need.

If additional information is required, list each request inside a `<request>` tag. If no additional information is needed, omit the `<requests>` section.

Respond with:
```xml
<response>
    <reason><![CDATA[YOUR REASON]]></reason>
    <value>UNKNOWN</value>
    <!-- Include <requests> only if additional information is needed -->
    <requests>
        <request><![CDATA[YOUR REQUEST 1]]></request>
        <request><![CDATA[YOUR REQUEST 2]]></request>
    </requests>
</response>
```
11:53:24.156 TRACE edu.ucr.cs.riple.core.checkers.nullaway.codefix.ChatGPT.ask
Retrieving response from cache
11:53:24.156 TRACE edu.ucr.cs.riple.core.checkers.nullaway.codefix.Response.tryCreate
Trying to create Response:
```xml
<response>
    <reason><![CDATA[Insufficient information is provided about the `Game.loop()` method. Without knowing the implementation details of `Game.loop()`, such as whether it has checks to ensure it always returns a non-null object, it is unclear if it can return null.]]></reason>
    <value>UNKNOWN</value>
    <requests>
        <request><![CDATA[Provide implementation or documentation details of the `Game.loop()` method to determine if it can return null.]]></request>
    </requests>
</response>
```
11:53:24.156 TRACE edu.ucr.cs.riple.core.checkers.nullaway.codefix.Response.<init>
Creating Response:
```xml
<response>
    <reason><![CDATA[Insufficient information is provided about the `Game.loop()` method. Without knowing the implementation details of `Game.loop()`, such as whether it has checks to ensure it always returns a non-null object, it is unclear if it can return null.]]></reason>
    <value>UNKNOWN</value>
    <requests>
        <request><![CDATA[Provide implementation or documentation details of the `Game.loop()` method to determine if it can return null.]]></request>
    </requests>
</response>
```
11:53:24.157 TRACE edu.ucr.cs.riple.core.checkers.nullaway.codefix.Response.<init>
Response created:
Unknown: Insufficient information is provided about the `Game.loop()` method. Without knowing the implementation details of `Game.loop()`, such as whether it has checks to ensure it always returns a non-null object, it is unclear if it can return null.
11:53:24.169 TRACE edu.ucr.cs.riple.core.checkers.nullaway.codefix.AdvancedNullAwayCodeFix.resolveMethodDereferenceError
Resolving method dereference error.
11:53:24.169 TRACE edu.ucr.cs.riple.core.checkers.nullaway.codefix.AdvancedNullAwayCodeFix.resolveMethodDereferenceError
Method is in annotated package. Checking if the method is returning nullable.
11:53:24.169 TRACE edu.ucr.cs.riple.core.checkers.nullaway.codefix.AdvancedNullAwayCodeFix.investigateMethodReturnNullability
Checking if the method is returning nullable.
11:53:24.171 TRACE edu.ucr.cs.riple.core.checkers.nullaway.codefix.ChatGPT.checkIfMethodIsReturningNullable
Asking if the method is returning nullable: loop()
11:53:24.173 TRACE edu.ucr.cs.riple.core.checkers.nullaway.codefix.ChatGPT.ask
Asking ChatGPT:
In the method below, is there a possibility that the method returns null based only on its body? Consider the following points:

- The method may have multiple return paths; consider all return statements.
- If the method calls another method, do not assume its return value unless its full declaration is provided. Request its declaration if needed.
- The method may throw an exception instead of returning null. An exception path should not be considered a null return.
- Ensure you request the declarations of any methods whose return values directly or indirectly impact this methods return value before making a conclusion.
- Carefully analyze all conditions and prior operations that may guarantee a non-null return value.

@Nullable public static IGameLoop loop() {
    return gameLoop;
}

Here are the method definitions in addition to the method inquired:

Depth: 0
```java
class de.gurkenlabs.litiengine.Game {
@Nullable public static IGameLoop loop() {
    return gameLoop;
}
}
```


Response Format:
Provide the answer in **XML format** as follows:

#### If the method **cannot** return `null`:
```xml
<response>
  <reason><![CDATA[EXPLAIN WHY THE METHOD CANNOT RETURN NULL]]></reason>
  <value>NO</value>
</response>
```

#### If the method can return null:
```xml
<response>
  <reason><![CDATA[EXPLAIN WHY THE METHOD CAN RETURN NULL]]></reason>
  <value>YES</value>
</response>
```

#### If you are unsure or need more information, respond with where you can ask for more details or what specific information you need.

#### If you are unsure or If there are any methods that directly or indirectly affect the return value and are not fully disclosed, request their declarations first, in the following format:
<response>
  <reason><![CDATA[YOUR REASON]]></reason>
  <value>UNKNOWN</value>
  <methods>
    <method>methodName</method>
  </methods>
</response>

If additional information is required other than method declaration, list each request inside a `<request>` tag. If no additional information is needed, omit the `<requests>` section.

Respond with:
```xml
<response>
    <reason><![CDATA[YOUR REASON]]></reason>
    <value>UNKNOWN</value>
    <!-- Include <requests> only if additional information is needed -->
    <requests>
        <request><![CDATA[YOUR REQUEST 1]]></request>
        <request><![CDATA[YOUR REQUEST 2]]></request>
    </requests>
</response>
```

Additional Notes:
Be precise in your reasoning.
If a methods return value depends on another method not provided, request its declaration before making a conclusion.
If the method can return null in some cases but not others, explain under what conditions it can happen.

11:53:24.173 TRACE edu.ucr.cs.riple.core.checkers.nullaway.codefix.ChatGPT.ask
Retrieving response from cache
11:53:24.173 TRACE edu.ucr.cs.riple.core.checkers.nullaway.codefix.Response.tryCreate
Trying to create Response:
```xml
<response>
  <reason><![CDATA[The method `loop` returns the variable `gameLoop`. Without the initialization or assignment details of `gameLoop`, it's unclear whether it can be null. The possibility of `gameLoop` being uninitialized or set to null elsewhere in the program means `loop` could potentially return null. Further information on `gameLoop` is required.]]></reason>
  <value>UNKNOWN</value>
  <requests>
    <request><![CDATA[Please provide the declaration and initialization of the variable `gameLoop` in the class `de.gurkenlabs.litiengine.Game`.]]></request>
  </requests>
</response>
```
11:53:24.174 TRACE edu.ucr.cs.riple.core.checkers.nullaway.codefix.Response.<init>
Creating Response:
```xml
<response>
  <reason><![CDATA[The method `loop` returns the variable `gameLoop`. Without the initialization or assignment details of `gameLoop`, it's unclear whether it can be null. The possibility of `gameLoop` being uninitialized or set to null elsewhere in the program means `loop` could potentially return null. Further information on `gameLoop` is required.]]></reason>
  <value>UNKNOWN</value>
  <requests>
    <request><![CDATA[Please provide the declaration and initialization of the variable `gameLoop` in the class `de.gurkenlabs.litiengine.Game`.]]></request>
  </requests>
</response>
```
11:53:24.174 TRACE edu.ucr.cs.riple.core.checkers.nullaway.codefix.Response.<init>
Response created:
Unknown: The method `loop` returns the variable `gameLoop`. Without the initialization or assignment details of `gameLoop`, it's unclear whether it can be null. The possibility of `gameLoop` being uninitialized or set to null elsewhere in the program means `loop` could potentially return null. Further information on `gameLoop` is required.
11:53:24.174 TRACE edu.ucr.cs.riple.core.checkers.nullaway.codefix.AdvancedNullAwayCodeFix.investigateMethodReturnNullability
Could not determine the nullability and model did not ask for any method.
11:53:24.174 TRACE edu.ucr.cs.riple.core.checkers.nullaway.codefix.ChatGPT.checkIfMethodIsReturningNullableOnCallSite
Asking if the method is returning nullable on the call site: Game.loop()
11:53:24.415 TRACE edu.ucr.cs.riple.core.checkers.nullaway.codefix.ChatGPT.ask
Asking ChatGPT:
In the method below, is there a possibility that the method returns null at the given call site?

```java
@Nullable public static IGameLoop loop() {
    return gameLoop;
}
```

## Guidelines:
- The method may have multiple return paths; consider all return statements.
- If the method calls another method, do not assume its return value unless its full declaration is provided. Request its declaration if needed.
- The method may throw an exception instead of returning null. An exception path should not be considered a null return.
- Ensure you request the declarations of any methods whose return values directly or indirectly impact this methods return value before making a conclusion.
- If the method returns a value that is determined by a parameter, evaluate based on the actual argument at the given call site.
- Analyze based only on the specific invocation provided. Do not generalize to all possible inputs.- If the return value is guaranteed to be non-null at the call site, the answer should be a definitive NO.
- Do not generalize based on all possible inputsyour answer must be based only on the given invocation.
- Focus only on the given call site, not all possible invocations.

### call site:
Game.loop()

Here are the method definitions and the call chain for this method, showing the sequence of calls from the method to its callers at each depth level:

Depth: 0
```java
class de.gurkenlabs.litiengine.Game {
@Nullable public static IGameLoop loop() {
    return gameLoop;
}
}
```
Depth: 1
```java
class de.gurkenlabs.litiengine.environment.GameWorld {
public void loadEnvironment(@Nullable final Environment env) {
    Lock lock = Game.loop().getLock();
    lock.lock();
    try {
      unloadEnvironment();
      this.environment = env;
      if (env != null) {
        this.addEnvironment(env);

        if (env.getGravity() == 0 && this.gravity() != 0) {
          env.setGravity(this.gravity());
        }

        env.load();
        for (final EnvironmentLoadedListener listener : this.loadedListeners) {
          listener.loaded(env);
        }

        // call map specific listeners
        String mapName = getMapName(env);
        if (mapName != null && this.environmentLoadedListeners.containsKey(mapName)) {

          // for the default camera we center the camera on the environment
          if (this.camera().getClass().equals(Camera.class)) {
            camera().setFocus(env.getCenter());
          }

          for (EnvironmentLoadedListener listener : this.environmentLoadedListeners.get(mapName)) {
            listener.loaded(env);
          }
        }
      }
    } finally {
      lock.unlock();
    }
}public void setCamera(@Nullable final ICamera cam) {
    if (this.camera() != null) {
      Game.loop().detach(camera);
    }

    camera = cam;

    if (cam != null && !Game.isInNoGUIMode()) {
      Game.loop().attach(cam);
      cam.updateFocus();
    }
}
}
```
```java
class de.gurkenlabs.litiengine.entities.behavior.EntityNavigator {
public EntityNavigator(final IMobileEntity entity, final PathFinder pathFinder) {
    this.cancelNavigationConditions = new CopyOnWriteArrayList<>();
    this.listeners = new CopyOnWriteArrayList<>();
    this.entity = entity;
    this.pathFinder = pathFinder;
    this.setAcceptableError(DEFAULT_ACCEPTABLE_ERROR);
    Game.loop().attach(this);
}
}
```
```java
class de.gurkenlabs.litiengine.GameWindow {
private static void initializeWindowEventListeners(Window window) {

    window.addWindowStateListener(
        e -> {
          if (e.getNewState() == Frame.ICONIFIED) {
            Game.loop().setTickRate(ICONIFIED_MAX_FPS);
          } else {
            Game.loop().setTickRate(Game.config().client().getMaxFps());
          }
        });

    window.addWindowFocusListener(
        new WindowFocusListener() {
          @Override
          public void windowLostFocus(WindowEvent e) {
            if (Game.config().graphics().reduceFramesWhenNotFocused()) {
              Game.loop().setTickRate(NONE_FOCUS_MAX_FPS);
            }
          }

          @Override
          public void windowGainedFocus(WindowEvent e) {
            Game.loop().setTickRate(Game.config().client().getMaxFps());
          }
        });

    window.addWindowListener(
        new WindowAdapter() {
          @Override
          public void windowClosing(final WindowEvent event) {
            Game.exit();
          }
        });
}
}
```
```java
class de.gurkenlabs.litiengine.gui.screens.ScreenManager {
public void display(@Nullable final Screen screen) {
      if (Game.hasStarted() && Game.time().since(this.lastScreenChange) < this.getChangeCooldown()) {
        log.log(
            Level.INFO,
            "Skipping displaying of screen {0} because screen changing is currently on cooldown.",
            screen != null ? screen.getName() : "");
        return;
      }
  
      final Screen previous = this.current();
      if (previous != null) {
        previous.suspend();
      }
  
      if (screen != null && !this.screens.contains(screen)) {
        this.screens.add(screen);
      }
  
      this.currentScreen = screen;
      if (!Game.isInNoGUIMode() && this.current() != null) {
        this.current().prepare();
      }
  
      this.lastScreenChange = Nullability.castToNonnull(Game.loop(), "initialized before usage").getTicks();
  
      final ScreenChangedEvent event = new ScreenChangedEvent(this.current(), previous);
      for (final ScreenChangedListener listener : this.screenChangedListeners) {
        listener.changed(event);
      }
}
}
```
```java
class de.gurkenlabs.litiengine.abilities.effects.Effect {
@Override
  public void update() {

    for (final Iterator<EffectApplication> iterator = this.getActiveAppliances().iterator();
        iterator.hasNext(); ) {
      final EffectApplication appliance = iterator.next();
      // if the effect duration is reached
      if (this.hasEnded(appliance)) {

        iterator.remove();
        this.cease(appliance);
      }
    }

    // 4. unregister if all appliances are finished
    if (this.getActiveAppliances().isEmpty()) {
      Game.loop().detach(this);
    }
}public void apply(final Shape impactArea) {
    final List<ICombatEntity> affected = this.lookForAffectedEntities(impactArea);
    for (final ICombatEntity affectedEntity : affected) {
      this.apply(affectedEntity);
    }

    this.appliances.add(new EffectApplication(affected, impactArea));

    // if it is the first appliance -> register for update
    if (this.appliances.size() == 1) {
      Game.loop().attach(this);
    }
}
}
```
```java
class de.gurkenlabs.litiengine.GameTime {
public long toTicks(final int milliseconds) {
    return this.toTicks(milliseconds, Game.loop().getTickRate());
}public long since(final long tick) {
    return toMilliseconds(Game.loop().getTicks() - tick);
}public long now() {
    return Game.loop().getTicks();
}public long sinceGameStart() {
    return this.toMilliseconds(Game.loop().getTicks());
}@Override
  public void loaded(Environment environment) {
    environmentLoaded = Game.loop().getTicks();
}public long toMilliseconds(final long ticks) {
    return this.toMilliseconds(ticks, Game.loop().getTickRate());
}
}
```
```java
class de.gurkenlabs.litiengine.GameMetrics {
@Override
  public void render(final Graphics2D g) {
    this.updateMetrics();

    if (!Game.config().client().showGameMetrics()) {
      return;
    }

    this.currentOffsetY = 0;

    g.setColor(this.renderColor);

    // render client metrics
    this.drawTitle(g, "[client]");
    this.drawMetric(g, "fps       : " + this.getFramesPerSecond());
    this.drawMetric(g, "max fps   : " + this.maxFramesPerSecond);
    this.drawMetric(g, "updatables: " + Game.loop().getUpdatableCount());

    // render jvm metrics if debug is enabled
    if (Game.config().debug().isDebugEnabled()) {
      this.drawTitle(g, "[jvm]");
      this.drawMetric(g, "java      : " + this.javaVersion);
      this.drawMetric(g, "memory    : " + String.format("%-5.5s", this.usedMemory) + " MB");
      this.drawMetric(g, "threads   : " + Thread.activeCount());
    }

    // render rendering metrics
    if (!this.renderMetrics.isEmpty()) {
      this.drawTitle(g, "[update]");

      for (RenderMetrics metric : this.renderMetrics) {
        this.drawMetric(g, metric.toString());
      }

      this.renderMetrics.clear();
    }
}
}
```
```java
class de.gurkenlabs.litiengine.graphics.emitters.Emitter {
public void deactivate() {
    if (!this.activated) {
      return;
    }

    this.activated = false;
    this.getParticles().clear();
    this.aliveTime = 0;
    this.activationTick = 0;
    this.lastSpawn = 0;
    Game.loop().detach(this);
}public void activate() {
    if (this.activated) {
      return;
    }

    this.activated = true;
    this.activationTick = Game.time().now();
    Game.loop().attach(this);
}@Override
  public void update() {
    if (this.isPaused()) {
      return;
    }

    // clear particles if the effect time to life is reached
    if (this.isFinished()) {
      for (EmitterFinishedListener listener : this.finishedListeners) {
        listener.finished(this);
      }

      this.delete();
      return;
    }

    final float updateRatio = (float) this.data().getUpdateRate() / Game.loop().getTickRate();
    for (final Particle p : this.getParticles().stream().collect(Collectors.toList())) {
      if (this.particleCanBeRemoved(p)) {
        // remove dead particles
        this.particles.remove(p);
        continue;
      }

      p.update(this.getOrigin(), updateRatio);
    }

    this.aliveTime = Game.time().since(this.activationTick);
    if ((this.data().getSpawnRate() == 0
        || Game.time().since(this.lastSpawn) >= this.data().getSpawnRate())) {
      this.lastSpawn = Game.time().now();
      this.spawnParticle();
    }
}
}
```
```java
class de.gurkenlabs.litiengine.entities.behavior.IBehaviorController {
public default void attach() {
    Game.loop().attach(this);
}public default void detach() {
    Game.loop().detach(this);
}
}
```
```java
class de.gurkenlabs.litiengine.abilities.AbilityExecution {
AbilityExecution(final Ability ability) {
    this.appliedEffects = new CopyOnWriteArrayList<>();
    this.ability = ability;
    this.executionTicks = Game.time().now();
    this.impactArea = ability.calculateImpactArea();
    this.castLocation = ability.getExecutor().getCenter();
    Game.loop().attach(this);
}@Override
  public void update() {
    // if there a no effects to apply -> unregister this instance and we're done
    if (this.getAbility().getEffects().isEmpty()
        || this.getAbility().getEffects().size() == this.getAppliedEffects().size()) {
      Game.loop().detach(this);
      return;
    }

    // handle all effects from the ability that were not applied yet
    for (final Effect effect : this.getAbility().getEffects()) {
      // if the ability was not executed yet or the delay of the effect is not
      // yet reached
      if (this.getAppliedEffects().contains(effect)
          || Game.time().since(this.getExecutionTicks()) < effect.getDelay()) {
        continue;
      }

      effect.apply(this.getExecutionImpactArea());
      this.getAppliedEffects().add(effect);
    }
}
}
```
```java
class de.gurkenlabs.litiengine.GameWindow$3 {
@Override
          public void windowGainedFocus(WindowEvent e) {
            Game.loop().setTickRate(Game.config().client().getMaxFps());
}@Override
          public void windowLostFocus(WindowEvent e) {
            if (Game.config().graphics().reduceFramesWhenNotFocused()) {
              Game.loop().setTickRate(NONE_FOCUS_MAX_FPS);
            }
}
}
```
```java
class de.gurkenlabs.litiengine.environment.EntitySpawner {
protected void spawnNewEntities() {
    if (this.getSpawnMode() != SpawnMode.CUSTOMSPAWNPOINTS && this.getSpawnPoints().isEmpty()) {
      return;
    }

    switch (this.getSpawnMode()) {
      case ALLSPAWNPOINTS:
        for (int i = 0; i < this.getSpawnPoints().size(); i++) {
          final int index = i;
          Game.loop()
              .perform(
                  this.getSpawnDelay() + this.getSpawnDelay() * i,
                  () -> this.spawn(this.getSpawnPoints().get(index), this.getSpawnAmount()));
        }
        break;
      case ONERANDOMSPAWNPOINT:
        this.spawn(Game.random().choose(this.getSpawnPoints()), this.getSpawnAmount());
        break;
      case RANDOMSPAWNPOINTS:
        for (int i = 0; i < this.getSpawnAmount(); i++) {
          Game.loop()
              .perform(
                  this.getSpawnDelay() + this.getSpawnDelay() * i,
                  () -> this.spawn(Game.random().choose(this.getSpawnPoints()), 1));
        }
        break;
      case CUSTOMSPAWNPOINTS:
        List<Spawnpoint> spawnPoints =
            this.customSpawnpoints != null
                ? this.customSpawnpoints.apply(this)
                : this.getCustomSpawnpoints();

        int index = 0;
        for (Spawnpoint spawn : spawnPoints) {
          Game.loop()
              .perform(
                  this.getSpawnDelay() + this.getSpawnDelay() * index, () -> this.spawn(spawn, 1));
          index++;
        }
        break;
      default:
        break;
    }
}
}
```
```java
class de.gurkenlabs.litiengine.tweening.TweenEngine {
@Override
  public void start() {
    Game.loop().attach(this);
}@Override
  public void terminate() {
    Game.loop().detach(this);
}
}
```
```java
class de.gurkenlabs.litiengine.gui.SpeechBubble {
public void hide() {
    Game.world().environment().removeRenderable(this);
    Game.loop().detach(this);
    if (activeSpeechBubbles.get(this.getEntity()) != null
        && activeSpeechBubbles.remove(this.getEntity()).equals(this)) {
      activeSpeechBubbles.remove(this.getEntity());
    }

    for (SpeechBubbleListener listener : this.listeners) {
      listener.hidden();
    }
}private SpeechBubble(
      final IEntity entity,
      final String text,
      @Nullable SpeechBubbleAppearance appearance,
      @Nullable Font font) {
    if (appearance == null) {
      this.appearance = DEFAULT_APPEARANCE;
    } else {
      this.appearance = appearance;
    }

    final SpeechBubble active = activeSpeechBubbles.get(entity);
    if (active != null) {
      active.hide();
    }
    this.setFont(font);

    this.textBoxWidth = (float) (entity.getWidth() * 4);
    this.entity = entity;

    this.currentText = text;
    this.currentTextDisplayTime = DISPLAYTIME_MIN + text.length() * DISPLAYTIME_PER_LETTER;

    this.lastTextDisplay = Game.time().now();
    this.createBubbleImage();
    entity.getEnvironment().add(this, RenderType.UI);
    Game.loop().attach(this);
    activeSpeechBubbles.put(entity, this);
}
}
```
```java
class de.gurkenlabs.litiengine.entities.Prop {
private void updateAnimationController() {
    IEntityAnimationController<?> controller = this.createAnimationController();
    this.getControllers().addController(controller);
    if (Game.world().environment() != null && Game.world().environment().isLoaded()) {
      Game.loop().attach(controller);
    }
}
}
```
```java
class de.gurkenlabs.litiengine.graphics.FreeFlightCamera {
public FreeFlightCamera(final Point2D focus) {
    this.setFocus(focus);
    this.velocity = DEFAULT_SCROLL_PIXELS_PER_SECOND;
    this.scrollPadding = DEFAULT_SCROLL_PADDING;
    this.setClampToMap(true);

    Game.loop().attach(this);
}private void handleFreeFlightCamera() {
    if (Game.world().environment() == null || Game.world().environment().getMap() == null) {
      return;
    }

    final Point2D mouseLocation = Input.mouse().getLocation();

    final double scrollSpeed =
        this.getVelocity()
            / (double) Game.loop().getTickRate()
            * Game.config().input().getMouseSensitivity();

    double x = this.getFocus().getX();
    double y = this.getFocus().getY();

    double deltaX = 0;
    if (mouseLocation.getX() < this.getScrollPadding()) {
      deltaX -= scrollSpeed;
    } else if (Game.window().getResolution().getWidth() - mouseLocation.getX()
        < this.getScrollPadding()) {
      deltaX += scrollSpeed;
    }

    double deltaY = 0;
    if (mouseLocation.getY() < this.getScrollPadding()) {
      deltaY -= scrollSpeed;
    } else if (Game.window().getResolution().getHeight() - mouseLocation.getY()
        < this.getScrollPadding()) {
      deltaY += scrollSpeed;
    }

    x += deltaX;
    y += deltaY;

    this.setFocus(new Point2D.Double(x, y));
}
}
```
```java
class de.gurkenlabs.litiengine.environment.Environment {
private static void dispose(final Collection<? extends IEntity> entities) {
    for (final IEntity entity : entities) {
      if (entity instanceof IUpdateable) {
        Game.loop().detach((IUpdateable) entity);
      }

      entity.detachControllers();
    }
}private static void loadUpdatableOrEmitterEntity(IEntity entity) {
    if (entity instanceof Emitter) {
      final Emitter emitter = (Emitter) entity;
      if (emitter.isActivateOnInit()) {
        emitter.activate();
      }
    } else if (entity instanceof IUpdateable) {
      Game.loop().attach((IUpdateable) entity);
    }
}private void unload(final IEntity entity) {
    // 1. remove from physics engine
    if (entity instanceof ICollisionEntity) {
      Game.physics().remove((ICollisionEntity) entity);
    }

    // 2. unregister from update
    if (entity instanceof IUpdateable) {
      Game.loop().detach((IUpdateable) entity);
    }

    if (entity instanceof IMobileEntity) {
      this.removeGravity((IMobileEntity) entity);
    }

    // 3. detach all controllers
    entity.detachControllers();

    if (entity instanceof Emitter) {
      Emitter em = (Emitter) entity;
      em.deactivate();
    }

    if (this.loaded && (entity instanceof LightSource || entity instanceof StaticShadow)) {
      this.updateLighting(entity);
    }

    entity.removed(this);
}
}
```
```java
class de.gurkenlabs.litiengine.graphics.animation.Animation {
@Override
  public void update() {
    // do nothing if the animation is not playing or the current keyframe is not finished
    if (!this.isPlaying()
        || Game.time().since(this.lastFrameUpdate) < this.getCurrentKeyFrame().getDuration()) {
      return;
    }

    // if we are not looping and the last keyframe is finished, we terminate the animation
    if (!this.isLooping() && this.isLastKeyFrame()) {
      this.terminate();
      return;
    }

    // make sure, we stay inside the keyframe list
    final int newFrameIndex =
        (this.getKeyframes().indexOf(this.currentFrame) + 1) % this.getKeyframes().size();
    final KeyFrame previousFrame = this.currentFrame;
    this.currentFrame = this.getKeyframes().get(newFrameIndex);

    for (KeyFrameListener listener : this.listeners) {
      listener.currentFrameChanged(previousFrame, this.currentFrame);
    }

    this.lastFrameUpdate = Game.loop().getTicks();
}public void restart() {
    this.currentFrame = this.firstFrame;
    this.lastFrameUpdate = Game.loop().getTicks();
}
}
```
```java
class de.gurkenlabs.litiengine.physics.MovementController {
@Override
  public void attach() {
    Game.loop().attach(this);
}private void handleForces() {
    // clean up forces
    this.activeForces.forEach(
        x -> {
          if (x.hasEnded()) {
            this.activeForces.remove(x);
          }
        });

    if (this.activeForces.isEmpty()) {
      return;
    }

    // disable turn-on-move for force handling
    boolean turn = this.getEntity().turnOnMove();
    this.getEntity().setTurnOnMove(false);
    try {
      double deltaX = 0;
      double deltaY = 0;
      for (final Force force : this.activeForces) {
        if (force.cancelOnReached() && force.hasReached(this.getEntity())) {
          force.end();
          continue;
        }

        final Point2D collisionBoxCenter = this.getEntity().getCollisionBoxCenter();
        final double angle =
            GeometricUtilities.calcRotationAngleInDegrees(collisionBoxCenter, force.getLocation());
        final double strength =
            Game.loop().getDeltaTime() * 0.001f * force.getStrength() * Game.loop().getTimeScale();
        deltaX += GeometricUtilities.getDeltaX(angle, strength);
        deltaY += GeometricUtilities.getDeltaY(angle, strength);
      }

      final Point2D target =
          new Point2D.Double(this.getEntity().getX() + deltaX, this.getEntity().getY() + deltaY);
      final boolean success = Game.physics().move(this.getEntity(), target);
      if (!success) {
        for (final Force force : this.activeForces) {
          if (force.cancelOnCollision()) {
            force.end();
          }
        }
      }
    } finally {
      this.getEntity().setTurnOnMove(turn);
    }
}@Override
  public void detach() {
    Game.loop().detach(this);
}public void handleMovement() {
    if (!this.isMovementAllowed()) {
      this.velocity = 0;
      return;
    }

    // max distance an entity can travel within one tick
    final double maxPixelsPerTick = this.getEntity().getTickVelocity();
    final double deltaTime = Game.loop().getDeltaTime() * Game.loop().getTimeScale();

    final double acceleration =
        this.getEntity().getAcceleration() == 0
            ? maxPixelsPerTick
            : deltaTime / this.getEntity().getAcceleration() * maxPixelsPerTick;
    final double deceleration =
        this.getEntity().getDeceleration() == 0
            ? this.getVelocity()
            : deltaTime / this.getEntity().getDeceleration() * maxPixelsPerTick;

    double dx = this.getDx();
    double dy = this.getDy();
    this.setDx(0);
    this.setDy(0);

    final double deltaVelocity =
        Math.min(Math.sqrt(Math.pow(dx, 2) + Math.pow(dy, 2)), acceleration);
    if (deltaVelocity != 0) {
      double newVelocity = this.getVelocity() + deltaVelocity;
      this.setVelocity(newVelocity);
    } else {
      final double newVelocity = Math.max(0, this.getVelocity() - deceleration);
      this.setVelocity(newVelocity);
      dx = GeometricUtilities.getDeltaX(this.moveAngle);
      dy = GeometricUtilities.getDeltaY(this.moveAngle);
    }

    if (this.getVelocity() == 0) {
      this.moveAngle = 0;
      return;
    }

    // actually move entity
    this.moveEntity(dx, dy);
}
}
```
```java
class de.gurkenlabs.litiengine.graphics.animation.AnimationController {
public void detach() {
    Game.loop().detach(this);
}public void attach() {
    Game.loop().attach(this);
}
}
```
```java
class de.gurkenlabs.litiengine.graphics.Camera {
@Override
  public void setZoom(final float targetZoom, final int delay) {
    if (delay == 0) {

      this.zoom = targetZoom;
      this.targetZoom = 0;
      this.zoomDelay = 0;
      this.zoomTick = 0;
      this.zoomStep = 0;

      final ZoomChangedEvent event = new ZoomChangedEvent(this, targetZoom);
      for (final ZoomChangedListener listener : this.zoomListeners) {
        listener.zoomChanged(event);
      }
    } else {
      this.zoomTick = Game.time().now();
      this.targetZoom = targetZoom;
      this.zoomDelay = delay;

      final double tickduration = 1000 / (double) Game.loop().getTickRate();
      final double tickAmount = delay / tickduration;
      final float totalDelta = this.targetZoom - this.zoom;
      this.zoomStep = tickAmount > 0 ? (float) (totalDelta / tickAmount) : totalDelta;
    }
}
}
```
```java
class de.gurkenlabs.litiengine.Game {
public static synchronized void init(String... args) {
    if (initialized) {
      log().log(Level.INFO, "The game has already been initialized.");
      return;
    }

    log.init();
    handleCommandLineArguments(args);

    config().load();
    Locale.setDefault(new Locale(config().client().getCountry(), config().client().getLanguage()));

    gameLoop = new GameLoop("Main Update Loop", config().client().getMaxFps());
    loop().attach(physics());
    loop().attach(world());

    // setup default exception handling for render and update loop
    setUncaughtExceptionHandler(
        new DefaultUncaughtExceptionHandler(config().client().exitOnError()));

    screenManager = new ScreenManager();
    gameWindow = new GameWindow();

    // initialize  the game window
    window().init();
    world.setCamera(new Camera());

    for (GameListener listener : gameListeners) {
      listener.initialized(args);
    }

    if (!isInNoGUIMode()) {
      window().getRenderComponent().onRendered(g -> metrics().render(g));

      graphics()
          .addEntityRenderedListener(
              e -> DebugRenderer.renderEntityDebugInfo(e.getGraphics(), e.getEntity()));

      window().getRenderComponent().onFpsChanged(fps -> metrics().setFramesPerSecond(fps));
      window()
          .setIcons(
              Arrays.asList(
                  Resources.images().get("liti-logo-x16.png"),
                  Resources.images().get("liti-logo-x20.png"),
                  Resources.images().get("liti-logo-x32.png"),
                  Resources.images().get("liti-logo-x48.png")));

      Input.keyboard()
          .onKeyTyped(
              KeyEvent.VK_PRINTSCREEN,
              key -> {
                // don't take a screenshot if a modifier is active
                if (key.getModifiers() != 0) {
                  return;
                }

                window().getRenderComponent().takeScreenshot();
              });
    }

    Runtime.getRuntime().addShutdownHook(new Thread(Game::terminate, "Shutdown"));

    initialized = true;
}
}
```
```java
class de.gurkenlabs.litiengine.entities.Creature {
protected void updateAnimationController() {
        IEntityAnimationController<?> controller = this.createAnimationController();
        this.getControllers().addController(controller);
        if (Game.world().environment() != null && Game.world().environment().isLoaded()) {
            Nullability.castToNonnull(Game.loop(), "expected to be non-null").attach(controller);
        }
}@Override
  public float getTickVelocity() {
    // pixels per ms multiplied by the passed ms
    // ensure that entities don't travel too far in case of lag
    return Math.min(Game.loop().getDeltaTime(), GameLoop.TICK_DELTATIME_LAG)
        * 0.001F
        * this.getVelocity().get()
        * Game.loop().getTimeScale();
}
}
```
Depth: 2
```java
class de.gurkenlabs.litiengine.environment.GameWorld {
public void clear() {
    this.unloadEnvironment();
    this.environments.clear();
    this.setCamera(null);
    Game.physics().clear();

    this.environmentListeners.clear();
    this.environmentLoadedListeners.clear();
    this.environmentUnloadedListeners.clear();

    this.listeners.clear();
    this.loadedListeners.clear();
    this.unloadedListeners.clear();
}@Nullable
  public Environment loadEnvironment(IMap map) {
    Environment env = this.getEnvironment(map);
    this.loadEnvironment(env);
    return env;
}@Nullable
  public Environment loadEnvironment(String mapName) {
    Environment env = this.getEnvironment(mapName);
    this.loadEnvironment(env);
    return env;
}
}
```
```java
class de.gurkenlabs.litiengine.GameWindow {
GameWindow() {
    this.hostControl = new JFrame();

    this.resolutionChangedListeners = new CopyOnWriteArrayList<>();

    this.renderCanvas = new RenderComponent(Game.config().graphics().getResolution());
    this.cursor = new MouseCursor();
    if (!Game.isInNoGUIMode()) {
      this.hostControl.setBackground(Color.BLACK);
      this.hostControl.add(this.renderCanvas);

      this.initializeEventListeners();

      this.hostControl.setTitle(Game.info().getTitle());
      this.hostControl.setDefaultCloseOperation(WindowConstants.DO_NOTHING_ON_CLOSE);
      initializeWindowEventListeners(this.hostControl);
    }
}
}
```
```java
class de.gurkenlabs.litiengine.GameTime {
public long sinceEnvironmentLoad() {
    return this.since(this.environmentLoaded);
}public long since(final long tick) {
    return toMilliseconds(Game.loop().getTicks() - tick);
}public long sinceGameStart() {
    return this.toMilliseconds(Game.loop().getTicks());
}
}
```
```java
class de.gurkenlabs.litiengine.abilities.effects.Effect {
protected void cease(final EffectApplication appliance) {
    // 1. cease the effect for all affected entities
    for (final ICombatEntity entity : appliance.getAffectedEntities()) {
      this.cease(entity);
    }

    // 2. apply follow up effects
    this.getFollowUpEffects().forEach(followUp -> followUp.apply(appliance.getImpactArea()));
}protected boolean hasEnded(final EffectApplication appliance) {
    final long effectDuration = Game.time().since(appliance.getAppliedTicks());
    return effectDuration > this.getDuration();
}
}
```
```java
class de.gurkenlabs.litiengine.abilities.effects.EffectApplication {
protected EffectApplication(final List<ICombatEntity> affectedEntities, final Shape impactArea) {
    this.applied = Game.time().now();
    this.affectedEntities = affectedEntities;
    this.impactArea = impactArea;
}
}
```
```java
class de.gurkenlabs.litiengine.entities.CombatEntity {
@Override
  public boolean wasHit(int timeSpan) {
    return Game.time().since(this.lastHit) < timeSpan;
}@Override
  public void hit(final int damage, @Nullable final Ability ability) {
    if (this.isDead()) {
      return;
    }

    if (!this.isIndestructible()) {
      this.getHitPoints().modifyBaseValue(new AttributeModifier<>(Modification.SUBTRACT, damage));
    }

    final EntityHitEvent event = new EntityHitEvent(this, ability, damage, this.isDead());

    for (final CombatEntityListener listener : this.listeners) {
      listener.hit(event);
    }

    for (final CombatEntityHitListener listener : this.hitListeners) {
      listener.hit(event);
    }

    if (this.isDead()) {
      this.fireDeathEvent();
      this.setCollision(false);
    }

    this.lastHit = Game.time().now();
}
}
```
```java
class de.gurkenlabs.litiengine.graphics.ImageEffect {
protected ImageEffect(final int ttl, final String name) {
    this.ttl = ttl;
    this.name = name;
    this.aliveTick = Game.time().now();
}@Override
  public long getAliveTime() {
    return Game.time().since(this.aliveTick);
}
}
```
```java
class de.gurkenlabs.litiengine.abilities.AbilityExecution {
AbilityExecution(final Ability ability) {
    this.appliedEffects = new CopyOnWriteArrayList<>();
    this.ability = ability;
    this.executionTicks = Game.time().now();
    this.impactArea = ability.calculateImpactArea();
    this.castLocation = ability.getExecutor().getCenter();
    Game.loop().attach(this);
}@Override
  public void update() {
    // if there a no effects to apply -> unregister this instance and we're done
    if (this.getAbility().getEffects().isEmpty()
        || this.getAbility().getEffects().size() == this.getAppliedEffects().size()) {
      Game.loop().detach(this);
      return;
    }

    // handle all effects from the ability that were not applied yet
    for (final Effect effect : this.getAbility().getEffects()) {
      // if the ability was not executed yet or the delay of the effect is not
      // yet reached
      if (this.getAppliedEffects().contains(effect)
          || Game.time().since(this.getExecutionTicks()) < effect.getDelay()) {
        continue;
      }

      effect.apply(this.getExecutionImpactArea());
      this.getAppliedEffects().add(effect);
    }
}
}
```
```java
class de.gurkenlabs.litiengine.tweening.TweenEngine {
@Override
  public void update() {
    for (final Tweenable target : this.getTweens().keySet()) {
      for (final Tween tween : this.getTweens().get(target).values()) {
        if (tween.hasStopped()) {
          continue;
        }
        final long elapsed = Game.time().since(tween.getStartTime());
        if (elapsed >= tween.getDuration()) {
          tween.stop();
          continue;
        }
        final float[] currentValues = new float[tween.getTargetValues().length];
        for (int i = 0; i < tween.getTargetValues().length; i++) {
          currentValues[i] =
              tween.getStartValues()[i]
                  + tween.getEquation().compute(elapsed / (float) tween.getDuration())
                      * (tween.getTargetValues()[i] - tween.getStartValues()[i]);
        }
        tween.getTarget().setTweenValues(tween.getType(), currentValues);
      }
    }
}
}
```
```java
class de.gurkenlabs.litiengine.gui.SpeechBubble {
public static SpeechBubble create(
      final IEntity entity, final String text, SpeechBubbleAppearance appearance, Font font) {
    return new SpeechBubble(entity, text, appearance, font);
}public static SpeechBubble create(final IEntity entity, final Font font, final String text) {
    SpeechBubbleAppearance app =
        new SpeechBubbleAppearance(
            DEFAULT_APPEARANCE.getForeColor(),
            DEFAULT_APPEARANCE.getBackgroundColor1(),
            DEFAULT_APPEARANCE.getBorderColor(),
            DEFAULT_APPEARANCE.getPadding());
    return new SpeechBubble(entity, text, app, font);
}public static SpeechBubble create(final IEntity entity, final String text) {
    return new SpeechBubble(entity, text, null, GuiProperties.getDefaultFont());
}@Override
  public void update() {
    if (this.currentText == null) {
      this.hide();
      return;
    }

    this.entityCenter = Game.world().camera().getViewportLocation(this.getEntity().getCenter());

    // old text was displayed long enough
    if (this.lastTextDisplay != 0
        && Game.time().since(this.lastTextDisplay) > this.currentTextDisplayTime) {
      this.currentText = null;
      this.lastTextDisplay = 0;
      return;
    }

    // display new text
    if (this.textIndex < this.currentText.length()
        && Game.time().since(this.lastCharPoll) > LETTER_WRITE_DELAY) {
      this.textIndex++;
      this.lastCharPoll = Game.time().now();
      if (this.typeSound != null) {
        Game.audio().playSound(this.typeSound, this.getEntity());
      }
    }

    // continue displaying currently displayed text
}private SpeechBubble(
      final IEntity entity,
      final String text,
      final Sound typeSound,
      SpeechBubbleAppearance appearance,
      Font font) {
    this(entity, text, appearance, font);
    this.typeSound = typeSound;
}private SpeechBubble(
      final IEntity entity,
      final String text,
      @Nullable SpeechBubbleAppearance appearance,
      @Nullable Font font) {
    if (appearance == null) {
      this.appearance = DEFAULT_APPEARANCE;
    } else {
      this.appearance = appearance;
    }

    final SpeechBubble active = activeSpeechBubbles.get(entity);
    if (active != null) {
      active.hide();
    }
    this.setFont(font);

    this.textBoxWidth = (float) (entity.getWidth() * 4);
    this.entity = entity;

    this.currentText = text;
    this.currentTextDisplayTime = DISPLAYTIME_MIN + text.length() * DISPLAYTIME_PER_LETTER;

    this.lastTextDisplay = Game.time().now();
    this.createBubbleImage();
    entity.getEnvironment().add(this, RenderType.UI);
    Game.loop().attach(this);
    activeSpeechBubbles.put(entity, this);
}
}
```
```java
class de.gurkenlabs.litiengine.gui.TextFieldComponent {
@Override
  public void render(final Graphics2D g) {
    super.render(g);
    g.setFont(this.getFont());
    final FontMetrics fm = g.getFontMetrics();

    if (this.isSelected() && Game.time().since(this.lastToggled) > this.flickerDelay) {
      this.cursorVisible = !this.cursorVisible;
      this.lastToggled = Game.time().now();
    }
    if (this.isSelected() && this.cursorVisible) {
      final Rectangle2D cursor =
          new Rectangle2D.Double(
              this.getX() + this.getTextX() + fm.stringWidth(this.getTextToRender(g)),
              this.getY() + this.getTextY(),
              this.getFont().getSize2D() * 3 / 5,
              this.getFont().getSize2D() * 1 / 5);
      g.setColor(this.getAppearance().getForeColor());
      g.fill(cursor);
    }
}
}
```
```java
class de.gurkenlabs.litiengine.entities.Prop {
public Prop(
      final Point2D location, @Nullable final String spritesheetName, final Material material) {
    super();
    this.rotation = Rotation.NONE;
    this.spritesheetName = spritesheetName;
    this.material = material;
    this.setLocation(location);
    this.updateAnimationController();
}public void setSpritesheetName(@Nullable final String spriteName) {
    this.spritesheetName = spriteName;
    this.updateAnimationController();
}
}
```
```java
class de.gurkenlabs.litiengine.tweening.Tween {
public Tween begin() {
    this.started = Game.time().now();
    this.stopped = false;
    return this;
}
}
```
```java
class de.gurkenlabs.litiengine.graphics.emitters.particles.Particle {
public void update(final Point2D emitterOrigin, final float updateRatio) {
    if (this.aliveTick == 0) {
      this.aliveTick = Game.time().now();
    }

    this.aliveTime = Game.time().since(this.aliveTick);
    if (this.timeToLiveReached()) {
      return;
    }

    if (this.colliding) {
      return;
    }

    if (this.getDeltaWidth() != 0) {
      this.width += this.getDeltaWidth() * updateRatio;
    }

    if (this.getDeltaHeight() != 0) {
      this.height += this.getDeltaHeight() * updateRatio;
    }

    if (this.getDeltaAngle() != 0) {
      this.angle += this.getDeltaAngle() * updateRatio;
    }

    // test for ray cast collision
    final float targetX = this.x + this.getVelocityX() * updateRatio;
    final float targetY = this.y + this.getVelocityY() * updateRatio;

    if (targetX == this.x && targetY == this.y) {
      return;
    }

    if (this.checkForCollision(emitterOrigin, targetX, targetY)) {
      return;
    }

    if (this.getVelocityX() != 0) {
      this.x = targetX;
    }

    if (this.getVelocityY() != 0) {
      this.y = targetY;
    }

    if (this.getAccelerationX() != 0) {
      this.velocityX += this.getAccelerationX() * updateRatio;
    }

    if (this.getAccelerationY() != 0) {
      this.velocityY += this.getAccelerationY() * updateRatio;
    }
}
}
```
```java
class de.gurkenlabs.litiengine.graphics.animation.Animation {
@Override
  public void start() {
    this.playing = true;
    if (this.getKeyframes().isEmpty()) {
      return;
    }

    this.restart();
}@Override
  public void update() {
    // do nothing if the animation is not playing or the current keyframe is not finished
    if (!this.isPlaying()
        || Game.time().since(this.lastFrameUpdate) < this.getCurrentKeyFrame().getDuration()) {
      return;
    }

    // if we are not looping and the last keyframe is finished, we terminate the animation
    if (!this.isLooping() && this.isLastKeyFrame()) {
      this.terminate();
      return;
    }

    // make sure, we stay inside the keyframe list
    final int newFrameIndex =
        (this.getKeyframes().indexOf(this.currentFrame) + 1) % this.getKeyframes().size();
    final KeyFrame previousFrame = this.currentFrame;
    this.currentFrame = this.getKeyframes().get(newFrameIndex);

    for (KeyFrameListener listener : this.listeners) {
      listener.currentFrameChanged(previousFrame, this.currentFrame);
    }

    this.lastFrameUpdate = Game.loop().getTicks();
}
}
```
```java
class de.gurkenlabs.litiengine.graphics.animation.AnimationController {
@Override
  public void update() {
    for (final Animation animation : this.getAll()) {
      animation.update();
    }

    if (this.getCurrent() != null && this.getCurrent().isPaused()) {
      return;
    }

    final boolean playbackFinished = this.getCurrent() != null && !this.getCurrent().isPlaying();
    if (playbackFinished) {
      for (final AnimationListener listener : this.listeners) {
        listener.finished(this.getCurrent());
      }
    }

    if (this.getCurrent() == null || playbackFinished) {
      if (this.getDefault() != null) {
        this.play(this.getDefault().getName());
      } else {
        this.currentAnimation = null;
      }
    }
}
}
```
```java
class de.gurkenlabs.litiengine.graphics.RenderComponent {
private void handleFade() {
    if (this.fadeOutStart != -1) {
      final long timePassed = Game.time().since(this.fadeOutStart);
      this.currentAlpha = MathUtilities.clamp(1 - timePassed / (float) this.fadeOutTime, 0, 1);
      if (this.currentAlpha == 0f) {
        this.fadeOutStart = -1;
        this.fadeOutTime = -1;
      }

      return;
    }

    if (this.fadeInStart != -1) {
      final long timePassed = Game.time().since(this.fadeInStart);
      this.currentAlpha = MathUtilities.clamp(timePassed / (float) this.fadeInTime, 0, 1);
      if (this.currentAlpha == 1f) {
        this.fadeInStart = -1;
        this.fadeInTime = -1;
        this.currentAlpha = Float.NaN;
      }
    }
}public void fadeOut(final int ms) {
    this.fadeInStart = -1;
    this.fadeInTime = -1;
    this.fadeOutStart = Game.time().now();
    this.fadeOutTime = ms;
}public void fadeIn(final int ms) {
    this.fadeOutStart = -1;
    this.fadeOutTime = -1;
    this.fadeInStart = Game.time().now();
    this.fadeInTime = ms;
}
}
```
```java
class de.gurkenlabs.litiengine.entities.Trigger {
private boolean activate(final IEntity activator, final int tar) {
    if (!this.isLoaded()
        || this.isOneTimeTrigger && this.isActivated
        || this.getActivationType() == TriggerActivation.COLLISION
            && activator != null
            && this.collisionActivated.contains(activator)) {
      return false;
    }

    if (this.getCooldown() > 0 && Game.time().since(this.lastActivation) < this.getCooldown()) {
      return false;
    }

    List<Integer> triggerTargets = this.getTargets(tar);

    final TriggerEvent te = new TriggerEvent(this, activator, triggerTargets);

    if (!this.checkActivationPredicates(te)) {
      return false;
    }

    this.isActivated = true;
    if (activator != null) {
      this.collisionActivated.add(activator);
    }

    // if we actually have a trigger target, we send the message to the target
    for (final int target : triggerTargets) {
      final IEntity entity = this.getEnvironment().get(target);
      if (entity == null) {
        log.log(
            Level.WARNING,
            "trigger [{0}] was activated, but the trigger target [{1}] could not be found on the environment",
            new Object[] {this, target});
        continue;
      }

      entity.sendMessage(this, this.message);
    }

    // also send the trigger event to all registered consumers
    for (final TriggerActivatedListener listener : this.activatedListeners) {
      listener.activated(te);
    }

    if (this.isOneTimeTrigger) {
      this.getEnvironment().remove(this);
    }

    this.lastActivation = Game.time().now();
    return true;
}
}
```
```java
class de.gurkenlabs.litiengine.graphics.Camera {
private boolean isShakeEffectActive() {
    return this.getShakeTick() != 0
        && Game.time().since(this.getShakeTick()) < this.getShakeDuration();
}@Override
  public void update() {
    if (Game.world().camera() != null && !Game.world().camera().equals(this)) {
      return;
    }

    if (this.targetZoom > 0) {
      if (Game.time().since(this.zoomTick) >= this.zoomDelay) {
        this.zoom = this.targetZoom;
        this.targetZoom = 0;
        this.zoomDelay = 0;
        this.zoomTick = 0;
        this.zoomStep = 0;
      } else {
        this.zoom += this.zoomStep;
      }

      final ZoomChangedEvent event = new ZoomChangedEvent(this, this.getZoom());
      for (final ZoomChangedListener listener : this.zoomListeners) {
        listener.zoomChanged(event);
      }
    }

    if (this.panTime > 0) {
      if (--this.panTime <= 0) {
        this.setFocus(this.targetFocus);
        this.targetFocus = null;
      } else {
        double diff = this.panTime / (this.panTime + 1.0);
        this.focus =
            new Point2D.Double(
                this.focus.getX() * diff + this.targetFocus.getX() * (1.0 - diff),
                this.focus.getY() * diff + this.targetFocus.getY() * (1.0 - diff));
      }
    }

    if (!this.isShakeEffectActive()) {
      this.shakeOffsetX = 0;
      this.shakeOffsetY = 0;
      return;
    }

    if (Game.time().since(this.lastShake) > this.shakeDelay) {
      this.shakeOffsetX = this.getShakeIntensity() * ThreadLocalRandom.current().nextGaussian();
      this.shakeOffsetY = this.getShakeIntensity() * ThreadLocalRandom.current().nextGaussian();
      this.lastShake = Game.time().now();
    }
}@Override
  public void setZoom(final float targetZoom, final int delay) {
    if (delay == 0) {

      this.zoom = targetZoom;
      this.targetZoom = 0;
      this.zoomDelay = 0;
      this.zoomTick = 0;
      this.zoomStep = 0;

      final ZoomChangedEvent event = new ZoomChangedEvent(this, targetZoom);
      for (final ZoomChangedListener listener : this.zoomListeners) {
        listener.zoomChanged(event);
      }
    } else {
      this.zoomTick = Game.time().now();
      this.targetZoom = targetZoom;
      this.zoomDelay = delay;

      final double tickduration = 1000 / (double) Game.loop().getTickRate();
      final double tickAmount = delay / tickduration;
      final float totalDelta = this.targetZoom - this.zoom;
      this.zoomStep = tickAmount > 0 ? (float) (totalDelta / tickAmount) : totalDelta;
    }
}@Override
  public void shake(final double intensity, final int delay, final int shakeDuration) {
    this.shakeTick = Game.time().now();
    this.shakeDelay = delay;
    this.shakeIntensity = intensity;
    this.shakeDuration = shakeDuration;
}
}
```
```java
class de.gurkenlabs.litiengine.entities.Creature {
public void setSpritesheetName(String spritesheetName) {
    if (this.spritesheetName != null && this.spritesheetName.equals(spritesheetName)) {
      return;
    }

    this.spritesheetName = spritesheetName;
    this.updateAnimationController();
}public boolean isIdle() {
    return Game.time().since(this.lastMoved) > IDLE_DELAY;
}@Override
  public void setLocation(final Point2D position) {
    if (this.isDead() || position == null) {
      return;
    }

    final Point2D oldLocation = this.getLocation();
    super.setLocation(position);

    if (Game.hasStarted() && this.isLoaded()) {
      this.lastMoved = Game.time().now();
      this.fireMovedEvent(
          new EntityMovedEvent(
              this, this.getX() - oldLocation.getX(), this.getY() - oldLocation.getY()));
    }
}
}
```
```java
class de.gurkenlabs.litiengine.gui.screens.ScreenManager {
public void display(final String screenName) {
    if (this.current() != null && this.current().getName().equalsIgnoreCase(screenName)) {
      log.log(
          Level.INFO,
          "Skipping displaying of screen {0} because it is already the current screen.",
          screenName);
      return;
    }

    if (this.screens.stream()
        .noneMatch(element -> element.getName().equalsIgnoreCase(screenName))) {
      log.log(
          Level.WARNING,
          "Could not display the screen {0} because there is no screen with the specified name.",
          screenName);
      return;
    }

    Screen screen = this.get(screenName);
    if (screen == null) {
      return;
    }

    this.display(screen);
}public void add(final Screen screen) {
    screen.setWidth(Game.window().getWidth());
    screen.setHeight(Game.window().getHeight());
    this.screens.add(screen);

    if (this.current() == null) {
      this.display(screen);
    }
}public void remove(Screen screen) {
    this.screens.remove(screen);
    if (this.current() == screen) {
      if (!this.screens.isEmpty()) {
        this.display(this.screens.get(0));
      } else {
        this.display((Screen) null);
      }
    }
}public void display(@Nullable final Screen screen) {
      if (Game.hasStarted() && Game.time().since(this.lastScreenChange) < this.getChangeCooldown()) {
        log.log(
            Level.INFO,
            "Skipping displaying of screen {0} because screen changing is currently on cooldown.",
            screen != null ? screen.getName() : "");
        return;
      }
  
      final Screen previous = this.current();
      if (previous != null) {
        previous.suspend();
      }
  
      if (screen != null && !this.screens.contains(screen)) {
        this.screens.add(screen);
      }
  
      this.currentScreen = screen;
      if (!Game.isInNoGUIMode() && this.current() != null) {
        this.current().prepare();
      }
  
      this.lastScreenChange = Nullability.castToNonnull(Game.loop(), "initialized before usage").getTicks();
  
      final ScreenChangedEvent event = new ScreenChangedEvent(this.current(), previous);
      for (final ScreenChangedListener listener : this.screenChangedListeners) {
        listener.changed(event);
      }
}
}
```
```java
class de.gurkenlabs.litiengine.abilities.Ability {
public boolean isOnCooldown() {
    return (this.getCurrentExecution() != null
        && this.getCurrentExecution().getExecutionTicks() > 0
        && Game.time().since(this.getCurrentExecution().getExecutionTicks())
            < this.getAttributes().cooldown().get());
}public boolean isActive() {
    return this.getCurrentExecution() != null
        && Game.time().since(this.getCurrentExecution().getExecutionTicks())
            < this.getAttributes().duration().get();
}@Nullable
  public AbilityExecution cast() {
    if (!this.canCast()) {
      return null;
    }
    this.currentExecution = new AbilityExecution(this);

    for (final AbilityCastListener listener : this.abilityCastListeners) {
      listener.abilityCast(this.currentExecution);
    }

    return this.getCurrentExecution();
}public float getRemainingCooldownInSeconds() {
    if (this.getCurrentExecution() == null
        || this.getExecutor() == null
        || this.getExecutor().isDead()) {
      return 0;
    }

    // calculate cooldown in seconds
    return (float)
        (!this.canCast()
            ? (this.getAttributes().cooldown().get()
                    - Game.time().since(this.getCurrentExecution().getExecutionTicks()))
                * 0.001
            : 0);
}
}
```
```java
class de.gurkenlabs.litiengine.entities.EntityHitEvent {
EntityHitEvent(
      final ICombatEntity hitEntity,
      @Nullable final Ability ability,
      final int damage,
      final boolean kill) {
    super(hitEntity);
    this.executor = ability != null ? ability.getExecutor() : null;
    this.hitEntity = hitEntity;
    this.ability = ability;
    this.damage = damage;
    this.kill = kill;
    this.time = Game.time().now();
}
}
```
```java
class de.gurkenlabs.litiengine.graphics.emitters.Emitter {
public void delete() {
    this.deactivate();
    if (Game.world().environment() != null) {
      Game.world().environment().remove(this);
    }
}public void activate() {
    if (this.activated) {
      return;
    }

    this.activated = true;
    this.activationTick = Game.time().now();
    Game.loop().attach(this);
}@Override
  public void update() {
    if (this.isPaused()) {
      return;
    }

    // clear particles if the effect time to life is reached
    if (this.isFinished()) {
      for (EmitterFinishedListener listener : this.finishedListeners) {
        listener.finished(this);
      }

      this.delete();
      return;
    }

    final float updateRatio = (float) this.data().getUpdateRate() / Game.loop().getTickRate();
    for (final Particle p : this.getParticles().stream().collect(Collectors.toList())) {
      if (this.particleCanBeRemoved(p)) {
        // remove dead particles
        this.particles.remove(p);
        continue;
      }

      p.update(this.getOrigin(), updateRatio);
    }

    this.aliveTime = Game.time().since(this.activationTick);
    if ((this.data().getSpawnRate() == 0
        || Game.time().since(this.lastSpawn) >= this.data().getSpawnRate())) {
      this.lastSpawn = Game.time().now();
      this.spawnParticle();
    }
}
}
```
```java
class de.gurkenlabs.litiengine.GameLoop {
@Override
  public int perform(int delay, Runnable action) {
    final long d = Game.time().toTicks(delay);

    TimedAction a = new TimedAction(this.getTicks() + d, action);
    this.actions.add(a);

    return a.getId();
}
}
```
```java
class de.gurkenlabs.litiengine.environment.EntitySpawner {
protected boolean shouldSpawn() {
    return this.lastSpawnWave == 0
        || Game.time().since(this.lastSpawnWave) >= this.getSpawnInterval();
}@Override
  public void update() {
    if (!this.shouldSpawn()) {
      return;
    }

    this.spawnNewEntities();
    this.lastSpawnWave = Game.time().now();
}
}
```
```java
class de.gurkenlabs.litiengine.graphics.FreeFlightCamera {
@Override
  public void update() {
    this.handleFreeFlightCamera();
}public FreeFlightCamera(double x, double y) {
    this(new Point2D.Double(x, y));
}
}
```
```java
class de.gurkenlabs.litiengine.environment.Environment {
public void unload() {
    if (!this.loaded) {
      return;
    }

    // unregister all updatable entities from the current environment
    for (final IEntity entity : this.allEntities.values()) {
      this.unload(entity);
    }

    this.loaded = false;
    this.fireEvent(l -> l.unloaded(this));
}private static void loadUpdatableOrEmitterEntity(IEntity entity) {
    if (entity instanceof Emitter) {
      final Emitter emitter = (Emitter) entity;
      if (emitter.isActivateOnInit()) {
        emitter.activate();
      }
    } else if (entity instanceof IUpdateable) {
      Game.loop().attach((IUpdateable) entity);
    }
}public void clear() {
    Game.physics().clear();

    this.combatEntities.clear();
    this.mobileEntities.clear();
    this.gravityForces.clear();
    this.layerEntities.clear();
    this.entitiesByTag.clear();
    this.allEntities.clear();

    for (RenderType renderType : RenderType.values()) {
      this.miscEntities.get(renderType).clear();
      this.renderListeners.get(renderType).clear();
      this.renderables.get(renderType).clear();
    }

    dispose(this.allEntities.values());
    dispose(this.triggers);
    this.emitters.clear();
    this.colliders.clear();
    this.props.clear();
    this.creatures.clear();
    this.staticShadows.clear();
    this.combatEntities.clear();
    this.mobileEntities.clear();
    this.lightSources.clear();
    this.spawnPoints.clear();
    this.soundSources.clear();
    this.mapAreas.clear();
    this.triggers.clear();

    this.ambientLight = null;
    this.staticShadowLayer = null;

    for (Map<Integer, IEntity> type : this.miscEntities.values()) {
      type.clear();
    }

    this.initialized = false;

    this.fireEvent(l -> l.cleared(this));
}private void load(final IEntity entity) {
    // an entity can only exist on one environment at a time, so remove it from the current one
    if (entity.getEnvironment() != null) {
      entity.getEnvironment().remove(entity);
    }

    // 1. add to physics engine
    loadPhysicsEntity(entity);

    // 2. register for update or activate
    loadUpdatableOrEmitterEntity(entity);

    // 3. if a gravity is defined, add a gravity force to the entity
    if (entity instanceof IMobileEntity && this.getGravity() != 0) {
      this.addGravityForce((IMobileEntity) entity);
    }

    // 4. attach all controllers
    entity.attachControllers();

    if (this.loaded && (entity instanceof LightSource || entity instanceof StaticShadow)) {
      this.updateLighting(entity);
    }

    entity.loaded(this);
}private void unload(final IEntity entity) {
    // 1. remove from physics engine
    if (entity instanceof ICollisionEntity) {
      Game.physics().remove((ICollisionEntity) entity);
    }

    // 2. unregister from update
    if (entity instanceof IUpdateable) {
      Game.loop().detach((IUpdateable) entity);
    }

    if (entity instanceof IMobileEntity) {
      this.removeGravity((IMobileEntity) entity);
    }

    // 3. detach all controllers
    entity.detachControllers();

    if (entity instanceof Emitter) {
      Emitter em = (Emitter) entity;
      em.deactivate();
    }

    if (this.loaded && (entity instanceof LightSource || entity instanceof StaticShadow)) {
      this.updateLighting(entity);
    }

    entity.removed(this);
}public void remove(final IEntity entity) {
    if (entity == null) {
      return;
    }

    this.allEntities.remove(entity.getMapId());
    Iterator<List<IEntity>> iter = this.layerEntities.values().iterator();
    while (iter.hasNext()) {
      List<IEntity> layer = iter.next();
      if (layer.remove(entity) && layer.isEmpty()) {
        iter.remove();
      }
    }
    if (this.miscEntities.get(entity.getRenderType()) != null) {
      this.miscEntities.get(entity.getRenderType()).values().remove(entity);
    }

    for (String tag : entity.getTags()) {
      if (this.getEntitiesByTag().containsKey(tag)) {
        this.getEntitiesByTag().get(tag).remove(entity);

        if (this.getEntitiesByTag().get(tag).isEmpty()) {
          this.getEntitiesByTag().remove(tag);
        }
      }
    }

    if (entity instanceof Emitter) {
      Emitter emitter = (Emitter) entity;
      this.removeEmitter(emitter);
    }

    if (entity instanceof MapArea) {
      this.mapAreas.remove(entity);
    }

    if (entity instanceof Prop) {
      this.props.remove(entity);
    }

    if (entity instanceof Creature) {
      this.creatures.remove(entity);
    }

    if (entity instanceof CollisionBox) {
      this.colliders.remove(entity);
      this.staticShadows.removeIf(x -> x.getOrigin() != null && x.getOrigin().equals(entity));
    }

    if (entity instanceof LightSource) {
      this.lightSources.remove(entity);
      this.updateLighting(entity);
    }

    if (entity instanceof Trigger) {
      this.triggers.remove(entity);
    }

    if (entity instanceof Spawnpoint) {
      this.spawnPoints.remove(entity);
    }
    if (entity instanceof SoundSource) {
      this.soundSources.remove(entity);
    }

    if (entity instanceof StaticShadow) {
      this.staticShadows.remove(entity);
      this.updateLighting(entity);
    }

    if (entity instanceof IMobileEntity) {
      this.mobileEntities.values().remove(entity);
    }

    if (entity instanceof ICombatEntity) {
      this.combatEntities.values().remove(entity);
    }

    this.unload(entity);

    this.fireEntityEvent(l -> l.entityRemoved(entity));
}
}
```
```java
class de.gurkenlabs.litiengine.physics.MovementController {
@Override
  public void update() {
    this.handleForces();
    this.handleMovement();
}
}
```
```java
class de.gurkenlabs.litiengine.Game {
static synchronized void terminate() {
        if (!initialized || gameLoop == null) {
          return;
        }
    
        hasStarted = false;
        initialized = false;
    
        config().save();
        gameLoop.terminate();
        tweenEngine.terminate();
        soundEngine.terminate();
    
        world().clear();
    
        for (final GameListener listener : gameListeners) {
          try {
            listener.terminated();
          } catch (Exception e) {
            log().log(Level.WARNING, "game listener threw an exception during shutdown", e);
          }
        }
    
        gameLoop = null;
        screenManager = null;
        gameWindow = null;
}public static synchronized void start() {
          if (!initialized) {
              throw new IllegalStateException(
                  "The game cannot be started without being first initialized. Call Game.init(...) before Game.start().");
          }
    
          if (gameLoop == null) {
              throw new IllegalStateException(
                  "Game loop is not initialized. Ensure Game.init(...) has been called successfully.");
          }
          
          Nullability.castToNonnull(gameLoop, "gameLoop cannot be null").start();
          tweenEngine.start();
          soundEngine.start();
    
          for (final GameListener listener : gameListeners) {
              listener.started();
          }
    
          hasStarted = true;
}public static synchronized void init(String... args) {
    if (initialized) {
      log().log(Level.INFO, "The game has already been initialized.");
      return;
    }

    log.init();
    handleCommandLineArguments(args);

    config().load();
    Locale.setDefault(new Locale(config().client().getCountry(), config().client().getLanguage()));

    gameLoop = new GameLoop("Main Update Loop", config().client().getMaxFps());
    loop().attach(physics());
    loop().attach(world());

    // setup default exception handling for render and update loop
    setUncaughtExceptionHandler(
        new DefaultUncaughtExceptionHandler(config().client().exitOnError()));

    screenManager = new ScreenManager();
    gameWindow = new GameWindow();

    // initialize  the game window
    window().init();
    world.setCamera(new Camera());

    for (GameListener listener : gameListeners) {
      listener.initialized(args);
    }

    if (!isInNoGUIMode()) {
      window().getRenderComponent().onRendered(g -> metrics().render(g));

      graphics()
          .addEntityRenderedListener(
              e -> DebugRenderer.renderEntityDebugInfo(e.getGraphics(), e.getEntity()));

      window().getRenderComponent().onFpsChanged(fps -> metrics().setFramesPerSecond(fps));
      window()
          .setIcons(
              Arrays.asList(
                  Resources.images().get("liti-logo-x16.png"),
                  Resources.images().get("liti-logo-x20.png"),
                  Resources.images().get("liti-logo-x32.png"),
                  Resources.images().get("liti-logo-x48.png")));

      Input.keyboard()
          .onKeyTyped(
              KeyEvent.VK_PRINTSCREEN,
              key -> {
                // don't take a screenshot if a modifier is active
                if (key.getModifiers() != 0) {
                  return;
                }

                window().getRenderComponent().takeScreenshot();
              });
    }

    Runtime.getRuntime().addShutdownHook(new Thread(Game::terminate, "Shutdown"));

    initialized = true;
}
}
```


Response Format:
Provide the answer in **XML format** as follows:

#### If the method **cannot** return `null` at the specific call site:
```xml
<response>
  <reason><![CDATA[EXPLAIN WHY THE INVOCATION Game.loop() RESULT CANNOT BE NULL.]]></reason>
  <value>NO</value>
</response>

#### If the method can return null at the specific call site:
<response>
  <reason><![CDATA[EXPLAIN WHY THE INVOCATION Game.loop() RESULT CAN BE NULL.]]></reason>
  <value>YES</value>
</response>

#### If you are unsure or If there are any methods that directly or indirectly affect the return value and are not fully disclosed, request their declarations first, in the following format:
<response>
  <reason><![CDATA[EXPLAIN WHY THIS METHOD DECLARATION IS NECESSARY AND WHY YOU CANNOT MAKE A CONFIDENT DECISION WITHOUT IT]]></reason>
  <success>false</success>
  <methods>
    <method>methodName</method>
  </methods>
</response>

Additional Notes:
Be precise in your reasoning.
If a methods return value depends on another method not provided, request its declaration before making a conclusion.
If the method can return null in this case but not in others, explain why it happens specifically for this call.

11:53:24.417 TRACE edu.ucr.cs.riple.core.checkers.nullaway.codefix.ChatGPT.ask
Retrieving response from cache
11:53:24.417 TRACE edu.ucr.cs.riple.core.checkers.nullaway.codefix.Response.tryCreate
Trying to create Response:
```xml
<response>
  <reason><![CDATA[The method 'Game.loop()' is returning the static field 'gameLoop' from the Game class. In the Game class, we can see the method 'init' where 'gameLoop' is initialized as a new instance of 'GameLoop'. The 'start' method in the Game class checks if 'gameLoop' is null before starting it, ensuring it's initialized through 'init' before use. Furthermore, there are checks within the 'start' and 'terminate' methods that ensure 'gameLoop' is not reset to null while the game is running. Given the initialization pattern and the structural design, the call 'Game.loop()' cannot be null at the call site, assuming 'Game.init()' has been called prior to starting the game and invoking any game loops.]]></reason>
  <value>NO</value>
</response>
```
11:53:24.417 TRACE edu.ucr.cs.riple.core.checkers.nullaway.codefix.Response.<init>
Creating Response:
```xml
<response>
  <reason><![CDATA[The method 'Game.loop()' is returning the static field 'gameLoop' from the Game class. In the Game class, we can see the method 'init' where 'gameLoop' is initialized as a new instance of 'GameLoop'. The 'start' method in the Game class checks if 'gameLoop' is null before starting it, ensuring it's initialized through 'init' before use. Furthermore, there are checks within the 'start' and 'terminate' methods that ensure 'gameLoop' is not reset to null while the game is running. Given the initialization pattern and the structural design, the call 'Game.loop()' cannot be null at the call site, assuming 'Game.init()' has been called prior to starting the game and invoking any game loops.]]></reason>
  <value>NO</value>
</response>
```
11:53:24.418 TRACE edu.ucr.cs.riple.core.checkers.nullaway.codefix.Response.<init>
Response created:
Disagreement: The method 'Game.loop()' is returning the static field 'gameLoop' from the Game class. In the Game class, we can see the method 'init' where 'gameLoop' is initialized as a new instance of 'GameLoop'. The 'start' method in the Game class checks if 'gameLoop' is null before starting it, ensuring it's initialized through 'init' before use. Furthermore, there are checks within the 'start' and 'terminate' methods that ensure 'gameLoop' is not reset to null while the game is running. Given the initialization pattern and the structural design, the call 'Game.loop()' cannot be null at the call site, assuming 'Game.init()' has been called prior to starting the game and invoking any game loops.
11:53:24.418 TRACE edu.ucr.cs.riple.core.checkers.nullaway.codefix.AdvancedNullAwayCodeFix.resolveMethodDereferenceError
Method is not returning nullable on call site. Injecting suppression annotation.
11:53:24.418 TRACE edu.ucr.cs.riple.core.checkers.nullaway.codefix.AdvancedNullAwayCodeFix.constructCastToNonnullChange
Constructing cast to nonnull change for reason: The method 'Game.loop()' is returning the static field 'gameLoop' from the Game class. In the Game class, we can see the method 'init' where 'gameLoop' is initialized as a new instance of 'GameLoop'. The 'start' method in the Game class checks if 'gameLoop' is null before starting it, ensuring it's initialized through 'init' before use. Furthermore, there are checks within the 'start' and 'terminate' methods that ensure 'gameLoop' is not reset to null while the game is running. Given the initialization pattern and the structural design, the call 'Game.loop()' cannot be null at the call site, assuming 'Game.init()' has been called prior to starting the game and invoking any game loops.
11:53:24.430 TRACE edu.ucr.cs.riple.core.checkers.nullaway.codefix.ChatGPT.ask
Asking ChatGPT:
For the reason you mentioned earlier:

"The method 'Game.loop()' is returning the static field 'gameLoop' from the Game class. In the Game class, we can see the method 'init' where 'gameLoop' is initialized as a new instance of 'GameLoop'. The 'start' method in the Game class checks if 'gameLoop' is null before starting it, ensuring it's initialized through 'init' before use. Furthermore, there are checks within the 'start' and 'terminate' methods that ensure 'gameLoop' is not reset to null while the game is running. Given the initialization pattern and the structural design, the call 'Game.loop()' cannot be null at the call site, assuming 'Game.init()' has been called prior to starting the game and invoking any game loops."

in the method below, the expression Game.loop() is not nullable at the point it is used.

```java
private static void loadUpdatableOrEmitterEntity(IEntity entity) {
    if (entity instanceof Emitter) {
      final Emitter emitter = (Emitter) entity;
      if (emitter.isActivateOnInit()) {
        emitter.activate();
      }
    } else if (entity instanceof IUpdateable) {
      Game.loop().attach((IUpdateable) entity);
    }
}
```
Please Summarize the reason in max 5 words and rewrite the method so that at the line "      Game.loop().attach((IUpdateable) entity);", at the occurrence of: "Game.loop()" is replaced with `Nullability.castToNonnull(Game.loop(), summary of reason)`
Replace "REASON" with the exact reason summary I provide to you (maximum 5 words), not with a generic explanation like "checked to be nonnull".
see the example below, for expression `foo.getBar()`, to wrap it with `Nullability.castToNonnull(foo.getBar(), "reason")`.

```java
public t(){
    String l = foo.getBar();
}
```

will be:
```java
public t(){
    String l = Nullability.castToNonnull(foo.getBar(), "checked to be nonnull");
}
```

### Instructions:

Do not import any additional classes.

Do not add Java comments.

Only modify relevant lines as required.

Return only the modified method wrapped in the XML format shown below.

Place the Java code inside the <code> tag using a CDATA block with ```java formatting.

Just give me the fixed code snippet in XML format in <response> tag like the example below. I will apply the fix to my codebase. Do not import any additional libraries or classes or add java comments. If you can provide the fixed code snippet, please provide it in the following format and place the code snippet in the <code> tag within ```java block.
<response>
  <success>true</success>
  <code><![CDATA[
  ```java
  Your fixed code snippet here
  ```
    ]]>
  </code>
</response>

11:53:24.430 TRACE edu.ucr.cs.riple.core.checkers.nullaway.codefix.ChatGPT.ask
Retrieving response from cache
11:53:24.430 TRACE edu.ucr.cs.riple.core.checkers.nullaway.codefix.Response.tryCreate
Trying to create Response:
<response>
  <success>true</success>
  <code><![CDATA[
  ```java
private static void loadUpdatableOrEmitterEntity(IEntity entity) {
    if (entity instanceof Emitter) {
      final Emitter emitter = (Emitter) entity;
      if (emitter.isActivateOnInit()) {
        emitter.activate();
      }
    } else if (entity instanceof IUpdateable) {
      Nullability.castToNonnull(Game.loop(), "initialized through init").attach((IUpdateable) entity);
    }
}
  ```
  ]]>
  </code>
</response>
11:53:24.430 TRACE edu.ucr.cs.riple.core.checkers.nullaway.codefix.Response.<init>
Creating Response:
<response>
  <success>true</success>
  <code><![CDATA[
  ```java
private static void loadUpdatableOrEmitterEntity(IEntity entity) {
    if (entity instanceof Emitter) {
      final Emitter emitter = (Emitter) entity;
      if (emitter.isActivateOnInit()) {
        emitter.activate();
      }
    } else if (entity instanceof IUpdateable) {
      Nullability.castToNonnull(Game.loop(), "initialized through init").attach((IUpdateable) entity);
    }
}
  ```
  ]]>
  </code>
</response>
11:53:24.431 TRACE edu.ucr.cs.riple.core.checkers.nullaway.codefix.Response.<init>
Response created:
private static void loadUpdatableOrEmitterEntity(IEntity entity) {
    if (entity instanceof Emitter) {
      final Emitter emitter = (Emitter) entity;
      if (emitter.isActivateOnInit()) {
        emitter.activate();
      }
    } else if (entity instanceof IUpdateable) {
      Nullability.castToNonnull(Game.loop(), "initialized through init").attach((IUpdateable) entity);
    }
}
11:53:24.431 TRACE edu.ucr.cs.riple.core.checkers.nullaway.codefix.ChatGPT.fixDereferenceByAddingCastToNonnull
Fixing the error by adding castToNonnull
11:53:24.458 TRACE edu.ucr.cs.riple.core.checkers.nullaway.codefix.AdvancedNullAwayCodeFix.fixTriggeredErrorsForLocation
Resolving unresolvable error for triggered error: Type='DEREFERENCE_NULLABLE', message='dereferenced expression Game.loop() is @Nullable'
/home/nima/Developer/nullness-benchmarks/litiengine/src/de/gurkenlabs/litiengine/graphics/FreeFlightCamera.java:74
            / (double) Game.loop().getTickRate()
11:53:24.458 TRACE edu.ucr.cs.riple.core.checkers.nullaway.codefix.AdvancedNullAwayCodeFix.fix
Fixing error: Type='DEREFERENCE_NULLABLE', message='dereferenced expression Game.loop() is @Nullable'
/home/nima/Developer/nullness-benchmarks/litiengine/src/de/gurkenlabs/litiengine/graphics/FreeFlightCamera.java:74
            / (double) Game.loop().getTickRate()
11:53:24.459 TRACE edu.ucr.cs.riple.core.checkers.nullaway.codefix.AdvancedNullAwayCodeFix.resolveDereferenceError
Resolving dereference error: Type='DEREFERENCE_NULLABLE', message='dereferenced expression Game.loop() is @Nullable'
/home/nima/Developer/nullness-benchmarks/litiengine/src/de/gurkenlabs/litiengine/graphics/FreeFlightCamera.java:74
            / (double) Game.loop().getTickRate()
11:53:24.459 TRACE edu.ucr.cs.riple.core.checkers.nullaway.codefix.AdvancedNullAwayCodeFix.resolveDereferenceError
Checking nullability possibility at error point
11:53:24.459 TRACE edu.ucr.cs.riple.core.checkers.nullaway.codefix.ChatGPT.checkNullabilityPossibilityAtErrorPoint
Asking if the expression can be null at error point point
11:53:24.459 TRACE edu.ucr.cs.riple.core.checkers.nullaway.codefix.ChatGPT.ask
Asking ChatGPT:
In the method below, is there a possibility that the expression "Game.loop()" at line "/ (double) Game.loop().getTickRate()" is null?
private void handleFreeFlightCamera() {
    if (Game.world().environment() == null || Game.world().environment().getMap() == null) {
      return;
    }

    final Point2D mouseLocation = Input.mouse().getLocation();

    final double scrollSpeed =
        this.getVelocity()
            / (double) Game.loop().getTickRate()
            * Game.config().input().getMouseSensitivity();

    double x = this.getFocus().getX();
    double y = this.getFocus().getY();

    double deltaX = 0;
    if (mouseLocation.getX() < this.getScrollPadding()) {
      deltaX -= scrollSpeed;
    } else if (Game.window().getResolution().getWidth() - mouseLocation.getX()
        < this.getScrollPadding()) {
      deltaX += scrollSpeed;
    }

    double deltaY = 0;
    if (mouseLocation.getY() < this.getScrollPadding()) {
      deltaY -= scrollSpeed;
    } else if (Game.window().getResolution().getHeight() - mouseLocation.getY()
        < this.getScrollPadding()) {
      deltaY += scrollSpeed;
    }

    x += deltaX;
    y += deltaY;

    this.setFocus(new Point2D.Double(x, y));
}
Give a single-word answer in XML format. If it is possible for the expression to be null, respond with:
```xml
<response>
    <reason><![CDATA[YOUR REASON]]></reason>
    <value>YES</value>
</response>
```
If it is not possible for the expression to be null, respond with:
```xml
<response>
    <reason><![CDATA[YOUR REASON]]></reason>
    <value>NO</value>
</response>
```
If you are unsure or need more information, respond with where you can ask for more details or what specific information you need.

If additional information is required, list each request inside a `<request>` tag. If no additional information is needed, omit the `<requests>` section.

Respond with:
```xml
<response>
    <reason><![CDATA[YOUR REASON]]></reason>
    <value>UNKNOWN</value>
    <!-- Include <requests> only if additional information is needed -->
    <requests>
        <request><![CDATA[YOUR REQUEST 1]]></request>
        <request><![CDATA[YOUR REQUEST 2]]></request>
    </requests>
</response>
```
11:53:24.459 TRACE edu.ucr.cs.riple.core.checkers.nullaway.codefix.ChatGPT.ask
Retrieving response from cache
11:53:24.459 TRACE edu.ucr.cs.riple.core.checkers.nullaway.codefix.Response.tryCreate
Trying to create Response:
```xml
<response>
    <reason><![CDATA[Without additional information on the implementation details of Game.loop(), it is not possible to definitively determine if it can return null.]]></reason>
    <value>UNKNOWN</value>
    <requests>
        <request><![CDATA[Details on the implementation of Game.loop() and whether it can return null.]]></request>
        <request><![CDATA[Information on how Game.loop() is initialized and used throughout the application.]]></request>
    </requests>
</response>
```
11:53:24.460 TRACE edu.ucr.cs.riple.core.checkers.nullaway.codefix.Response.<init>
Creating Response:
```xml
<response>
    <reason><![CDATA[Without additional information on the implementation details of Game.loop(), it is not possible to definitively determine if it can return null.]]></reason>
    <value>UNKNOWN</value>
    <requests>
        <request><![CDATA[Details on the implementation of Game.loop() and whether it can return null.]]></request>
        <request><![CDATA[Information on how Game.loop() is initialized and used throughout the application.]]></request>
    </requests>
</response>
```
11:53:24.460 TRACE edu.ucr.cs.riple.core.checkers.nullaway.codefix.Response.<init>
Response created:
Unknown: Without additional information on the implementation details of Game.loop(), it is not possible to definitively determine if it can return null.
11:53:24.461 TRACE edu.ucr.cs.riple.core.checkers.nullaway.codefix.AdvancedNullAwayCodeFix.resolveMethodDereferenceError
Resolving method dereference error.
11:53:24.461 TRACE edu.ucr.cs.riple.core.checkers.nullaway.codefix.AdvancedNullAwayCodeFix.resolveMethodDereferenceError
Method is in annotated package. Checking if the method is returning nullable.
11:53:24.461 TRACE edu.ucr.cs.riple.core.checkers.nullaway.codefix.AdvancedNullAwayCodeFix.investigateMethodReturnNullability
Checking if the method is returning nullable.
11:53:24.463 TRACE edu.ucr.cs.riple.core.checkers.nullaway.codefix.ChatGPT.checkIfMethodIsReturningNullable
Asking if the method is returning nullable: loop()
11:53:24.465 TRACE edu.ucr.cs.riple.core.checkers.nullaway.codefix.ChatGPT.ask
Asking ChatGPT:
In the method below, is there a possibility that the method returns null based only on its body? Consider the following points:

- The method may have multiple return paths; consider all return statements.
- If the method calls another method, do not assume its return value unless its full declaration is provided. Request its declaration if needed.
- The method may throw an exception instead of returning null. An exception path should not be considered a null return.
- Ensure you request the declarations of any methods whose return values directly or indirectly impact this methods return value before making a conclusion.
- Carefully analyze all conditions and prior operations that may guarantee a non-null return value.

@Nullable public static IGameLoop loop() {
    return gameLoop;
}

Here are the method definitions in addition to the method inquired:

Depth: 0
```java
class de.gurkenlabs.litiengine.Game {
@Nullable public static IGameLoop loop() {
    return gameLoop;
}
}
```


Response Format:
Provide the answer in **XML format** as follows:

#### If the method **cannot** return `null`:
```xml
<response>
  <reason><![CDATA[EXPLAIN WHY THE METHOD CANNOT RETURN NULL]]></reason>
  <value>NO</value>
</response>
```

#### If the method can return null:
```xml
<response>
  <reason><![CDATA[EXPLAIN WHY THE METHOD CAN RETURN NULL]]></reason>
  <value>YES</value>
</response>
```

#### If you are unsure or need more information, respond with where you can ask for more details or what specific information you need.

#### If you are unsure or If there are any methods that directly or indirectly affect the return value and are not fully disclosed, request their declarations first, in the following format:
<response>
  <reason><![CDATA[YOUR REASON]]></reason>
  <value>UNKNOWN</value>
  <methods>
    <method>methodName</method>
  </methods>
</response>

If additional information is required other than method declaration, list each request inside a `<request>` tag. If no additional information is needed, omit the `<requests>` section.

Respond with:
```xml
<response>
    <reason><![CDATA[YOUR REASON]]></reason>
    <value>UNKNOWN</value>
    <!-- Include <requests> only if additional information is needed -->
    <requests>
        <request><![CDATA[YOUR REQUEST 1]]></request>
        <request><![CDATA[YOUR REQUEST 2]]></request>
    </requests>
</response>
```

Additional Notes:
Be precise in your reasoning.
If a methods return value depends on another method not provided, request its declaration before making a conclusion.
If the method can return null in some cases but not others, explain under what conditions it can happen.

11:53:24.465 TRACE edu.ucr.cs.riple.core.checkers.nullaway.codefix.ChatGPT.ask
Retrieving response from cache
11:53:24.465 TRACE edu.ucr.cs.riple.core.checkers.nullaway.codefix.Response.tryCreate
Trying to create Response:
```xml
<response>
  <reason><![CDATA[The method `loop` returns the variable `gameLoop`. Without the initialization or assignment details of `gameLoop`, it's unclear whether it can be null. The possibility of `gameLoop` being uninitialized or set to null elsewhere in the program means `loop` could potentially return null. Further information on `gameLoop` is required.]]></reason>
  <value>UNKNOWN</value>
  <requests>
    <request><![CDATA[Please provide the declaration and initialization of the variable `gameLoop` in the class `de.gurkenlabs.litiengine.Game`.]]></request>
  </requests>
</response>
```
11:53:24.465 TRACE edu.ucr.cs.riple.core.checkers.nullaway.codefix.Response.<init>
Creating Response:
```xml
<response>
  <reason><![CDATA[The method `loop` returns the variable `gameLoop`. Without the initialization or assignment details of `gameLoop`, it's unclear whether it can be null. The possibility of `gameLoop` being uninitialized or set to null elsewhere in the program means `loop` could potentially return null. Further information on `gameLoop` is required.]]></reason>
  <value>UNKNOWN</value>
  <requests>
    <request><![CDATA[Please provide the declaration and initialization of the variable `gameLoop` in the class `de.gurkenlabs.litiengine.Game`.]]></request>
  </requests>
</response>
```
11:53:24.465 TRACE edu.ucr.cs.riple.core.checkers.nullaway.codefix.Response.<init>
Response created:
Unknown: The method `loop` returns the variable `gameLoop`. Without the initialization or assignment details of `gameLoop`, it's unclear whether it can be null. The possibility of `gameLoop` being uninitialized or set to null elsewhere in the program means `loop` could potentially return null. Further information on `gameLoop` is required.
11:53:24.466 TRACE edu.ucr.cs.riple.core.checkers.nullaway.codefix.AdvancedNullAwayCodeFix.investigateMethodReturnNullability
Could not determine the nullability and model did not ask for any method.
11:53:24.466 TRACE edu.ucr.cs.riple.core.checkers.nullaway.codefix.ChatGPT.checkIfMethodIsReturningNullableOnCallSite
Asking if the method is returning nullable on the call site: Game.loop()
11:53:24.709 TRACE edu.ucr.cs.riple.core.checkers.nullaway.codefix.ChatGPT.ask
Asking ChatGPT:
In the method below, is there a possibility that the method returns null at the given call site?

```java
@Nullable public static IGameLoop loop() {
    return gameLoop;
}
```

## Guidelines:
- The method may have multiple return paths; consider all return statements.
- If the method calls another method, do not assume its return value unless its full declaration is provided. Request its declaration if needed.
- The method may throw an exception instead of returning null. An exception path should not be considered a null return.
- Ensure you request the declarations of any methods whose return values directly or indirectly impact this methods return value before making a conclusion.
- If the method returns a value that is determined by a parameter, evaluate based on the actual argument at the given call site.
- Analyze based only on the specific invocation provided. Do not generalize to all possible inputs.- If the return value is guaranteed to be non-null at the call site, the answer should be a definitive NO.
- Do not generalize based on all possible inputsyour answer must be based only on the given invocation.
- Focus only on the given call site, not all possible invocations.

### call site:
Game.loop()

Here are the method definitions and the call chain for this method, showing the sequence of calls from the method to its callers at each depth level:

Depth: 0
```java
class de.gurkenlabs.litiengine.Game {
@Nullable public static IGameLoop loop() {
    return gameLoop;
}
}
```
Depth: 1
```java
class de.gurkenlabs.litiengine.environment.GameWorld {
public void loadEnvironment(@Nullable final Environment env) {
    Lock lock = Game.loop().getLock();
    lock.lock();
    try {
      unloadEnvironment();
      this.environment = env;
      if (env != null) {
        this.addEnvironment(env);

        if (env.getGravity() == 0 && this.gravity() != 0) {
          env.setGravity(this.gravity());
        }

        env.load();
        for (final EnvironmentLoadedListener listener : this.loadedListeners) {
          listener.loaded(env);
        }

        // call map specific listeners
        String mapName = getMapName(env);
        if (mapName != null && this.environmentLoadedListeners.containsKey(mapName)) {

          // for the default camera we center the camera on the environment
          if (this.camera().getClass().equals(Camera.class)) {
            camera().setFocus(env.getCenter());
          }

          for (EnvironmentLoadedListener listener : this.environmentLoadedListeners.get(mapName)) {
            listener.loaded(env);
          }
        }
      }
    } finally {
      lock.unlock();
    }
}public void setCamera(@Nullable final ICamera cam) {
    if (this.camera() != null) {
      Game.loop().detach(camera);
    }

    camera = cam;

    if (cam != null && !Game.isInNoGUIMode()) {
      Game.loop().attach(cam);
      cam.updateFocus();
    }
}
}
```
```java
class de.gurkenlabs.litiengine.entities.behavior.EntityNavigator {
public EntityNavigator(final IMobileEntity entity, final PathFinder pathFinder) {
    this.cancelNavigationConditions = new CopyOnWriteArrayList<>();
    this.listeners = new CopyOnWriteArrayList<>();
    this.entity = entity;
    this.pathFinder = pathFinder;
    this.setAcceptableError(DEFAULT_ACCEPTABLE_ERROR);
    Game.loop().attach(this);
}
}
```
```java
class de.gurkenlabs.litiengine.GameWindow {
private static void initializeWindowEventListeners(Window window) {

    window.addWindowStateListener(
        e -> {
          if (e.getNewState() == Frame.ICONIFIED) {
            Game.loop().setTickRate(ICONIFIED_MAX_FPS);
          } else {
            Game.loop().setTickRate(Game.config().client().getMaxFps());
          }
        });

    window.addWindowFocusListener(
        new WindowFocusListener() {
          @Override
          public void windowLostFocus(WindowEvent e) {
            if (Game.config().graphics().reduceFramesWhenNotFocused()) {
              Game.loop().setTickRate(NONE_FOCUS_MAX_FPS);
            }
          }

          @Override
          public void windowGainedFocus(WindowEvent e) {
            Game.loop().setTickRate(Game.config().client().getMaxFps());
          }
        });

    window.addWindowListener(
        new WindowAdapter() {
          @Override
          public void windowClosing(final WindowEvent event) {
            Game.exit();
          }
        });
}
}
```
```java
class de.gurkenlabs.litiengine.gui.screens.ScreenManager {
public void display(@Nullable final Screen screen) {
      if (Game.hasStarted() && Game.time().since(this.lastScreenChange) < this.getChangeCooldown()) {
        log.log(
            Level.INFO,
            "Skipping displaying of screen {0} because screen changing is currently on cooldown.",
            screen != null ? screen.getName() : "");
        return;
      }
  
      final Screen previous = this.current();
      if (previous != null) {
        previous.suspend();
      }
  
      if (screen != null && !this.screens.contains(screen)) {
        this.screens.add(screen);
      }
  
      this.currentScreen = screen;
      if (!Game.isInNoGUIMode() && this.current() != null) {
        this.current().prepare();
      }
  
      this.lastScreenChange = Nullability.castToNonnull(Game.loop(), "initialized before usage").getTicks();
  
      final ScreenChangedEvent event = new ScreenChangedEvent(this.current(), previous);
      for (final ScreenChangedListener listener : this.screenChangedListeners) {
        listener.changed(event);
      }
}
}
```
```java
class de.gurkenlabs.litiengine.abilities.effects.Effect {
@Override
  public void update() {

    for (final Iterator<EffectApplication> iterator = this.getActiveAppliances().iterator();
        iterator.hasNext(); ) {
      final EffectApplication appliance = iterator.next();
      // if the effect duration is reached
      if (this.hasEnded(appliance)) {

        iterator.remove();
        this.cease(appliance);
      }
    }

    // 4. unregister if all appliances are finished
    if (this.getActiveAppliances().isEmpty()) {
      Game.loop().detach(this);
    }
}public void apply(final Shape impactArea) {
    final List<ICombatEntity> affected = this.lookForAffectedEntities(impactArea);
    for (final ICombatEntity affectedEntity : affected) {
      this.apply(affectedEntity);
    }

    this.appliances.add(new EffectApplication(affected, impactArea));

    // if it is the first appliance -> register for update
    if (this.appliances.size() == 1) {
      Game.loop().attach(this);
    }
}
}
```
```java
class de.gurkenlabs.litiengine.GameTime {
public long toTicks(final int milliseconds) {
    return this.toTicks(milliseconds, Game.loop().getTickRate());
}public long since(final long tick) {
    return toMilliseconds(Game.loop().getTicks() - tick);
}public long now() {
    return Game.loop().getTicks();
}public long sinceGameStart() {
    return this.toMilliseconds(Game.loop().getTicks());
}@Override
  public void loaded(Environment environment) {
    environmentLoaded = Game.loop().getTicks();
}public long toMilliseconds(final long ticks) {
    return this.toMilliseconds(ticks, Game.loop().getTickRate());
}
}
```
```java
class de.gurkenlabs.litiengine.GameMetrics {
@Override
  public void render(final Graphics2D g) {
    this.updateMetrics();

    if (!Game.config().client().showGameMetrics()) {
      return;
    }

    this.currentOffsetY = 0;

    g.setColor(this.renderColor);

    // render client metrics
    this.drawTitle(g, "[client]");
    this.drawMetric(g, "fps       : " + this.getFramesPerSecond());
    this.drawMetric(g, "max fps   : " + this.maxFramesPerSecond);
    this.drawMetric(g, "updatables: " + Game.loop().getUpdatableCount());

    // render jvm metrics if debug is enabled
    if (Game.config().debug().isDebugEnabled()) {
      this.drawTitle(g, "[jvm]");
      this.drawMetric(g, "java      : " + this.javaVersion);
      this.drawMetric(g, "memory    : " + String.format("%-5.5s", this.usedMemory) + " MB");
      this.drawMetric(g, "threads   : " + Thread.activeCount());
    }

    // render rendering metrics
    if (!this.renderMetrics.isEmpty()) {
      this.drawTitle(g, "[update]");

      for (RenderMetrics metric : this.renderMetrics) {
        this.drawMetric(g, metric.toString());
      }

      this.renderMetrics.clear();
    }
}
}
```
```java
class de.gurkenlabs.litiengine.graphics.emitters.Emitter {
public void deactivate() {
    if (!this.activated) {
      return;
    }

    this.activated = false;
    this.getParticles().clear();
    this.aliveTime = 0;
    this.activationTick = 0;
    this.lastSpawn = 0;
    Game.loop().detach(this);
}public void activate() {
    if (this.activated) {
      return;
    }

    this.activated = true;
    this.activationTick = Game.time().now();
    Game.loop().attach(this);
}@Override
  public void update() {
    if (this.isPaused()) {
      return;
    }

    // clear particles if the effect time to life is reached
    if (this.isFinished()) {
      for (EmitterFinishedListener listener : this.finishedListeners) {
        listener.finished(this);
      }

      this.delete();
      return;
    }

    final float updateRatio = (float) this.data().getUpdateRate() / Game.loop().getTickRate();
    for (final Particle p : this.getParticles().stream().collect(Collectors.toList())) {
      if (this.particleCanBeRemoved(p)) {
        // remove dead particles
        this.particles.remove(p);
        continue;
      }

      p.update(this.getOrigin(), updateRatio);
    }

    this.aliveTime = Game.time().since(this.activationTick);
    if ((this.data().getSpawnRate() == 0
        || Game.time().since(this.lastSpawn) >= this.data().getSpawnRate())) {
      this.lastSpawn = Game.time().now();
      this.spawnParticle();
    }
}
}
```
```java
class de.gurkenlabs.litiengine.entities.behavior.IBehaviorController {
public default void attach() {
    Game.loop().attach(this);
}public default void detach() {
    Game.loop().detach(this);
}
}
```
```java
class de.gurkenlabs.litiengine.abilities.AbilityExecution {
AbilityExecution(final Ability ability) {
    this.appliedEffects = new CopyOnWriteArrayList<>();
    this.ability = ability;
    this.executionTicks = Game.time().now();
    this.impactArea = ability.calculateImpactArea();
    this.castLocation = ability.getExecutor().getCenter();
    Game.loop().attach(this);
}@Override
  public void update() {
    // if there a no effects to apply -> unregister this instance and we're done
    if (this.getAbility().getEffects().isEmpty()
        || this.getAbility().getEffects().size() == this.getAppliedEffects().size()) {
      Game.loop().detach(this);
      return;
    }

    // handle all effects from the ability that were not applied yet
    for (final Effect effect : this.getAbility().getEffects()) {
      // if the ability was not executed yet or the delay of the effect is not
      // yet reached
      if (this.getAppliedEffects().contains(effect)
          || Game.time().since(this.getExecutionTicks()) < effect.getDelay()) {
        continue;
      }

      effect.apply(this.getExecutionImpactArea());
      this.getAppliedEffects().add(effect);
    }
}
}
```
```java
class de.gurkenlabs.litiengine.GameWindow$3 {
@Override
          public void windowGainedFocus(WindowEvent e) {
            Game.loop().setTickRate(Game.config().client().getMaxFps());
}@Override
          public void windowLostFocus(WindowEvent e) {
            if (Game.config().graphics().reduceFramesWhenNotFocused()) {
              Game.loop().setTickRate(NONE_FOCUS_MAX_FPS);
            }
}
}
```
```java
class de.gurkenlabs.litiengine.environment.EntitySpawner {
protected void spawnNewEntities() {
    if (this.getSpawnMode() != SpawnMode.CUSTOMSPAWNPOINTS && this.getSpawnPoints().isEmpty()) {
      return;
    }

    switch (this.getSpawnMode()) {
      case ALLSPAWNPOINTS:
        for (int i = 0; i < this.getSpawnPoints().size(); i++) {
          final int index = i;
          Game.loop()
              .perform(
                  this.getSpawnDelay() + this.getSpawnDelay() * i,
                  () -> this.spawn(this.getSpawnPoints().get(index), this.getSpawnAmount()));
        }
        break;
      case ONERANDOMSPAWNPOINT:
        this.spawn(Game.random().choose(this.getSpawnPoints()), this.getSpawnAmount());
        break;
      case RANDOMSPAWNPOINTS:
        for (int i = 0; i < this.getSpawnAmount(); i++) {
          Game.loop()
              .perform(
                  this.getSpawnDelay() + this.getSpawnDelay() * i,
                  () -> this.spawn(Game.random().choose(this.getSpawnPoints()), 1));
        }
        break;
      case CUSTOMSPAWNPOINTS:
        List<Spawnpoint> spawnPoints =
            this.customSpawnpoints != null
                ? this.customSpawnpoints.apply(this)
                : this.getCustomSpawnpoints();

        int index = 0;
        for (Spawnpoint spawn : spawnPoints) {
          Game.loop()
              .perform(
                  this.getSpawnDelay() + this.getSpawnDelay() * index, () -> this.spawn(spawn, 1));
          index++;
        }
        break;
      default:
        break;
    }
}
}
```
```java
class de.gurkenlabs.litiengine.tweening.TweenEngine {
@Override
  public void start() {
    Game.loop().attach(this);
}@Override
  public void terminate() {
    Game.loop().detach(this);
}
}
```
```java
class de.gurkenlabs.litiengine.gui.SpeechBubble {
public void hide() {
    Game.world().environment().removeRenderable(this);
    Game.loop().detach(this);
    if (activeSpeechBubbles.get(this.getEntity()) != null
        && activeSpeechBubbles.remove(this.getEntity()).equals(this)) {
      activeSpeechBubbles.remove(this.getEntity());
    }

    for (SpeechBubbleListener listener : this.listeners) {
      listener.hidden();
    }
}private SpeechBubble(
      final IEntity entity,
      final String text,
      @Nullable SpeechBubbleAppearance appearance,
      @Nullable Font font) {
    if (appearance == null) {
      this.appearance = DEFAULT_APPEARANCE;
    } else {
      this.appearance = appearance;
    }

    final SpeechBubble active = activeSpeechBubbles.get(entity);
    if (active != null) {
      active.hide();
    }
    this.setFont(font);

    this.textBoxWidth = (float) (entity.getWidth() * 4);
    this.entity = entity;

    this.currentText = text;
    this.currentTextDisplayTime = DISPLAYTIME_MIN + text.length() * DISPLAYTIME_PER_LETTER;

    this.lastTextDisplay = Game.time().now();
    this.createBubbleImage();
    entity.getEnvironment().add(this, RenderType.UI);
    Game.loop().attach(this);
    activeSpeechBubbles.put(entity, this);
}
}
```
```java
class de.gurkenlabs.litiengine.entities.Prop {
private void updateAnimationController() {
    IEntityAnimationController<?> controller = this.createAnimationController();
    this.getControllers().addController(controller);
    if (Game.world().environment() != null && Game.world().environment().isLoaded()) {
      Game.loop().attach(controller);
    }
}
}
```
```java
class de.gurkenlabs.litiengine.graphics.FreeFlightCamera {
public FreeFlightCamera(final Point2D focus) {
    this.setFocus(focus);
    this.velocity = DEFAULT_SCROLL_PIXELS_PER_SECOND;
    this.scrollPadding = DEFAULT_SCROLL_PADDING;
    this.setClampToMap(true);

    Game.loop().attach(this);
}private void handleFreeFlightCamera() {
    if (Game.world().environment() == null || Game.world().environment().getMap() == null) {
      return;
    }

    final Point2D mouseLocation = Input.mouse().getLocation();

    final double scrollSpeed =
        this.getVelocity()
            / (double) Game.loop().getTickRate()
            * Game.config().input().getMouseSensitivity();

    double x = this.getFocus().getX();
    double y = this.getFocus().getY();

    double deltaX = 0;
    if (mouseLocation.getX() < this.getScrollPadding()) {
      deltaX -= scrollSpeed;
    } else if (Game.window().getResolution().getWidth() - mouseLocation.getX()
        < this.getScrollPadding()) {
      deltaX += scrollSpeed;
    }

    double deltaY = 0;
    if (mouseLocation.getY() < this.getScrollPadding()) {
      deltaY -= scrollSpeed;
    } else if (Game.window().getResolution().getHeight() - mouseLocation.getY()
        < this.getScrollPadding()) {
      deltaY += scrollSpeed;
    }

    x += deltaX;
    y += deltaY;

    this.setFocus(new Point2D.Double(x, y));
}
}
```
```java
class de.gurkenlabs.litiengine.environment.Environment {
private static void dispose(final Collection<? extends IEntity> entities) {
    for (final IEntity entity : entities) {
      if (entity instanceof IUpdateable) {
        Game.loop().detach((IUpdateable) entity);
      }

      entity.detachControllers();
    }
}private static void loadUpdatableOrEmitterEntity(IEntity entity) {
      if (entity instanceof Emitter) {
        final Emitter emitter = (Emitter) entity;
        if (emitter.isActivateOnInit()) {
          emitter.activate();
        }
      } else if (entity instanceof IUpdateable) {
        Nullability.castToNonnull(Game.loop(), "initialized through init").attach((IUpdateable) entity);
      }
}private void unload(final IEntity entity) {
    // 1. remove from physics engine
    if (entity instanceof ICollisionEntity) {
      Game.physics().remove((ICollisionEntity) entity);
    }

    // 2. unregister from update
    if (entity instanceof IUpdateable) {
      Game.loop().detach((IUpdateable) entity);
    }

    if (entity instanceof IMobileEntity) {
      this.removeGravity((IMobileEntity) entity);
    }

    // 3. detach all controllers
    entity.detachControllers();

    if (entity instanceof Emitter) {
      Emitter em = (Emitter) entity;
      em.deactivate();
    }

    if (this.loaded && (entity instanceof LightSource || entity instanceof StaticShadow)) {
      this.updateLighting(entity);
    }

    entity.removed(this);
}
}
```
```java
class de.gurkenlabs.litiengine.graphics.animation.Animation {
@Override
  public void update() {
    // do nothing if the animation is not playing or the current keyframe is not finished
    if (!this.isPlaying()
        || Game.time().since(this.lastFrameUpdate) < this.getCurrentKeyFrame().getDuration()) {
      return;
    }

    // if we are not looping and the last keyframe is finished, we terminate the animation
    if (!this.isLooping() && this.isLastKeyFrame()) {
      this.terminate();
      return;
    }

    // make sure, we stay inside the keyframe list
    final int newFrameIndex =
        (this.getKeyframes().indexOf(this.currentFrame) + 1) % this.getKeyframes().size();
    final KeyFrame previousFrame = this.currentFrame;
    this.currentFrame = this.getKeyframes().get(newFrameIndex);

    for (KeyFrameListener listener : this.listeners) {
      listener.currentFrameChanged(previousFrame, this.currentFrame);
    }

    this.lastFrameUpdate = Game.loop().getTicks();
}public void restart() {
    this.currentFrame = this.firstFrame;
    this.lastFrameUpdate = Game.loop().getTicks();
}
}
```
```java
class de.gurkenlabs.litiengine.physics.MovementController {
@Override
  public void attach() {
    Game.loop().attach(this);
}private void handleForces() {
    // clean up forces
    this.activeForces.forEach(
        x -> {
          if (x.hasEnded()) {
            this.activeForces.remove(x);
          }
        });

    if (this.activeForces.isEmpty()) {
      return;
    }

    // disable turn-on-move for force handling
    boolean turn = this.getEntity().turnOnMove();
    this.getEntity().setTurnOnMove(false);
    try {
      double deltaX = 0;
      double deltaY = 0;
      for (final Force force : this.activeForces) {
        if (force.cancelOnReached() && force.hasReached(this.getEntity())) {
          force.end();
          continue;
        }

        final Point2D collisionBoxCenter = this.getEntity().getCollisionBoxCenter();
        final double angle =
            GeometricUtilities.calcRotationAngleInDegrees(collisionBoxCenter, force.getLocation());
        final double strength =
            Game.loop().getDeltaTime() * 0.001f * force.getStrength() * Game.loop().getTimeScale();
        deltaX += GeometricUtilities.getDeltaX(angle, strength);
        deltaY += GeometricUtilities.getDeltaY(angle, strength);
      }

      final Point2D target =
          new Point2D.Double(this.getEntity().getX() + deltaX, this.getEntity().getY() + deltaY);
      final boolean success = Game.physics().move(this.getEntity(), target);
      if (!success) {
        for (final Force force : this.activeForces) {
          if (force.cancelOnCollision()) {
            force.end();
          }
        }
      }
    } finally {
      this.getEntity().setTurnOnMove(turn);
    }
}@Override
  public void detach() {
    Game.loop().detach(this);
}public void handleMovement() {
    if (!this.isMovementAllowed()) {
      this.velocity = 0;
      return;
    }

    // max distance an entity can travel within one tick
    final double maxPixelsPerTick = this.getEntity().getTickVelocity();
    final double deltaTime = Game.loop().getDeltaTime() * Game.loop().getTimeScale();

    final double acceleration =
        this.getEntity().getAcceleration() == 0
            ? maxPixelsPerTick
            : deltaTime / this.getEntity().getAcceleration() * maxPixelsPerTick;
    final double deceleration =
        this.getEntity().getDeceleration() == 0
            ? this.getVelocity()
            : deltaTime / this.getEntity().getDeceleration() * maxPixelsPerTick;

    double dx = this.getDx();
    double dy = this.getDy();
    this.setDx(0);
    this.setDy(0);

    final double deltaVelocity =
        Math.min(Math.sqrt(Math.pow(dx, 2) + Math.pow(dy, 2)), acceleration);
    if (deltaVelocity != 0) {
      double newVelocity = this.getVelocity() + deltaVelocity;
      this.setVelocity(newVelocity);
    } else {
      final double newVelocity = Math.max(0, this.getVelocity() - deceleration);
      this.setVelocity(newVelocity);
      dx = GeometricUtilities.getDeltaX(this.moveAngle);
      dy = GeometricUtilities.getDeltaY(this.moveAngle);
    }

    if (this.getVelocity() == 0) {
      this.moveAngle = 0;
      return;
    }

    // actually move entity
    this.moveEntity(dx, dy);
}
}
```
```java
class de.gurkenlabs.litiengine.graphics.animation.AnimationController {
public void detach() {
    Game.loop().detach(this);
}public void attach() {
    Game.loop().attach(this);
}
}
```
```java
class de.gurkenlabs.litiengine.graphics.Camera {
@Override
  public void setZoom(final float targetZoom, final int delay) {
    if (delay == 0) {

      this.zoom = targetZoom;
      this.targetZoom = 0;
      this.zoomDelay = 0;
      this.zoomTick = 0;
      this.zoomStep = 0;

      final ZoomChangedEvent event = new ZoomChangedEvent(this, targetZoom);
      for (final ZoomChangedListener listener : this.zoomListeners) {
        listener.zoomChanged(event);
      }
    } else {
      this.zoomTick = Game.time().now();
      this.targetZoom = targetZoom;
      this.zoomDelay = delay;

      final double tickduration = 1000 / (double) Game.loop().getTickRate();
      final double tickAmount = delay / tickduration;
      final float totalDelta = this.targetZoom - this.zoom;
      this.zoomStep = tickAmount > 0 ? (float) (totalDelta / tickAmount) : totalDelta;
    }
}
}
```
```java
class de.gurkenlabs.litiengine.Game {
public static synchronized void init(String... args) {
    if (initialized) {
      log().log(Level.INFO, "The game has already been initialized.");
      return;
    }

    log.init();
    handleCommandLineArguments(args);

    config().load();
    Locale.setDefault(new Locale(config().client().getCountry(), config().client().getLanguage()));

    gameLoop = new GameLoop("Main Update Loop", config().client().getMaxFps());
    loop().attach(physics());
    loop().attach(world());

    // setup default exception handling for render and update loop
    setUncaughtExceptionHandler(
        new DefaultUncaughtExceptionHandler(config().client().exitOnError()));

    screenManager = new ScreenManager();
    gameWindow = new GameWindow();

    // initialize  the game window
    window().init();
    world.setCamera(new Camera());

    for (GameListener listener : gameListeners) {
      listener.initialized(args);
    }

    if (!isInNoGUIMode()) {
      window().getRenderComponent().onRendered(g -> metrics().render(g));

      graphics()
          .addEntityRenderedListener(
              e -> DebugRenderer.renderEntityDebugInfo(e.getGraphics(), e.getEntity()));

      window().getRenderComponent().onFpsChanged(fps -> metrics().setFramesPerSecond(fps));
      window()
          .setIcons(
              Arrays.asList(
                  Resources.images().get("liti-logo-x16.png"),
                  Resources.images().get("liti-logo-x20.png"),
                  Resources.images().get("liti-logo-x32.png"),
                  Resources.images().get("liti-logo-x48.png")));

      Input.keyboard()
          .onKeyTyped(
              KeyEvent.VK_PRINTSCREEN,
              key -> {
                // don't take a screenshot if a modifier is active
                if (key.getModifiers() != 0) {
                  return;
                }

                window().getRenderComponent().takeScreenshot();
              });
    }

    Runtime.getRuntime().addShutdownHook(new Thread(Game::terminate, "Shutdown"));

    initialized = true;
}
}
```
```java
class de.gurkenlabs.litiengine.entities.Creature {
protected void updateAnimationController() {
        IEntityAnimationController<?> controller = this.createAnimationController();
        this.getControllers().addController(controller);
        if (Game.world().environment() != null && Game.world().environment().isLoaded()) {
            Nullability.castToNonnull(Game.loop(), "expected to be non-null").attach(controller);
        }
}@Override
  public float getTickVelocity() {
    // pixels per ms multiplied by the passed ms
    // ensure that entities don't travel too far in case of lag
    return Math.min(Game.loop().getDeltaTime(), GameLoop.TICK_DELTATIME_LAG)
        * 0.001F
        * this.getVelocity().get()
        * Game.loop().getTimeScale();
}
}
```
Depth: 2
```java
class de.gurkenlabs.litiengine.environment.GameWorld {
public void clear() {
    this.unloadEnvironment();
    this.environments.clear();
    this.setCamera(null);
    Game.physics().clear();

    this.environmentListeners.clear();
    this.environmentLoadedListeners.clear();
    this.environmentUnloadedListeners.clear();

    this.listeners.clear();
    this.loadedListeners.clear();
    this.unloadedListeners.clear();
}@Nullable
  public Environment loadEnvironment(IMap map) {
    Environment env = this.getEnvironment(map);
    this.loadEnvironment(env);
    return env;
}@Nullable
  public Environment loadEnvironment(String mapName) {
    Environment env = this.getEnvironment(mapName);
    this.loadEnvironment(env);
    return env;
}
}
```
```java
class de.gurkenlabs.litiengine.GameWindow {
GameWindow() {
    this.hostControl = new JFrame();

    this.resolutionChangedListeners = new CopyOnWriteArrayList<>();

    this.renderCanvas = new RenderComponent(Game.config().graphics().getResolution());
    this.cursor = new MouseCursor();
    if (!Game.isInNoGUIMode()) {
      this.hostControl.setBackground(Color.BLACK);
      this.hostControl.add(this.renderCanvas);

      this.initializeEventListeners();

      this.hostControl.setTitle(Game.info().getTitle());
      this.hostControl.setDefaultCloseOperation(WindowConstants.DO_NOTHING_ON_CLOSE);
      initializeWindowEventListeners(this.hostControl);
    }
}
}
```
```java
class de.gurkenlabs.litiengine.GameTime {
public long sinceEnvironmentLoad() {
    return this.since(this.environmentLoaded);
}public long since(final long tick) {
    return toMilliseconds(Game.loop().getTicks() - tick);
}public long sinceGameStart() {
    return this.toMilliseconds(Game.loop().getTicks());
}
}
```
```java
class de.gurkenlabs.litiengine.abilities.effects.Effect {
protected void cease(final EffectApplication appliance) {
    // 1. cease the effect for all affected entities
    for (final ICombatEntity entity : appliance.getAffectedEntities()) {
      this.cease(entity);
    }

    // 2. apply follow up effects
    this.getFollowUpEffects().forEach(followUp -> followUp.apply(appliance.getImpactArea()));
}protected boolean hasEnded(final EffectApplication appliance) {
    final long effectDuration = Game.time().since(appliance.getAppliedTicks());
    return effectDuration > this.getDuration();
}
}
```
```java
class de.gurkenlabs.litiengine.abilities.effects.EffectApplication {
protected EffectApplication(final List<ICombatEntity> affectedEntities, final Shape impactArea) {
    this.applied = Game.time().now();
    this.affectedEntities = affectedEntities;
    this.impactArea = impactArea;
}
}
```
```java
class de.gurkenlabs.litiengine.entities.CombatEntity {
@Override
  public boolean wasHit(int timeSpan) {
    return Game.time().since(this.lastHit) < timeSpan;
}@Override
  public void hit(final int damage, @Nullable final Ability ability) {
    if (this.isDead()) {
      return;
    }

    if (!this.isIndestructible()) {
      this.getHitPoints().modifyBaseValue(new AttributeModifier<>(Modification.SUBTRACT, damage));
    }

    final EntityHitEvent event = new EntityHitEvent(this, ability, damage, this.isDead());

    for (final CombatEntityListener listener : this.listeners) {
      listener.hit(event);
    }

    for (final CombatEntityHitListener listener : this.hitListeners) {
      listener.hit(event);
    }

    if (this.isDead()) {
      this.fireDeathEvent();
      this.setCollision(false);
    }

    this.lastHit = Game.time().now();
}
}
```
```java
class de.gurkenlabs.litiengine.graphics.ImageEffect {
protected ImageEffect(final int ttl, final String name) {
    this.ttl = ttl;
    this.name = name;
    this.aliveTick = Game.time().now();
}@Override
  public long getAliveTime() {
    return Game.time().since(this.aliveTick);
}
}
```
```java
class de.gurkenlabs.litiengine.abilities.AbilityExecution {
AbilityExecution(final Ability ability) {
    this.appliedEffects = new CopyOnWriteArrayList<>();
    this.ability = ability;
    this.executionTicks = Game.time().now();
    this.impactArea = ability.calculateImpactArea();
    this.castLocation = ability.getExecutor().getCenter();
    Game.loop().attach(this);
}@Override
  public void update() {
    // if there a no effects to apply -> unregister this instance and we're done
    if (this.getAbility().getEffects().isEmpty()
        || this.getAbility().getEffects().size() == this.getAppliedEffects().size()) {
      Game.loop().detach(this);
      return;
    }

    // handle all effects from the ability that were not applied yet
    for (final Effect effect : this.getAbility().getEffects()) {
      // if the ability was not executed yet or the delay of the effect is not
      // yet reached
      if (this.getAppliedEffects().contains(effect)
          || Game.time().since(this.getExecutionTicks()) < effect.getDelay()) {
        continue;
      }

      effect.apply(this.getExecutionImpactArea());
      this.getAppliedEffects().add(effect);
    }
}
}
```
```java
class de.gurkenlabs.litiengine.tweening.TweenEngine {
@Override
  public void update() {
    for (final Tweenable target : this.getTweens().keySet()) {
      for (final Tween tween : this.getTweens().get(target).values()) {
        if (tween.hasStopped()) {
          continue;
        }
        final long elapsed = Game.time().since(tween.getStartTime());
        if (elapsed >= tween.getDuration()) {
          tween.stop();
          continue;
        }
        final float[] currentValues = new float[tween.getTargetValues().length];
        for (int i = 0; i < tween.getTargetValues().length; i++) {
          currentValues[i] =
              tween.getStartValues()[i]
                  + tween.getEquation().compute(elapsed / (float) tween.getDuration())
                      * (tween.getTargetValues()[i] - tween.getStartValues()[i]);
        }
        tween.getTarget().setTweenValues(tween.getType(), currentValues);
      }
    }
}
}
```
```java
class de.gurkenlabs.litiengine.gui.SpeechBubble {
public static SpeechBubble create(
      final IEntity entity, final String text, SpeechBubbleAppearance appearance, Font font) {
    return new SpeechBubble(entity, text, appearance, font);
}public static SpeechBubble create(final IEntity entity, final Font font, final String text) {
    SpeechBubbleAppearance app =
        new SpeechBubbleAppearance(
            DEFAULT_APPEARANCE.getForeColor(),
            DEFAULT_APPEARANCE.getBackgroundColor1(),
            DEFAULT_APPEARANCE.getBorderColor(),
            DEFAULT_APPEARANCE.getPadding());
    return new SpeechBubble(entity, text, app, font);
}public static SpeechBubble create(final IEntity entity, final String text) {
    return new SpeechBubble(entity, text, null, GuiProperties.getDefaultFont());
}@Override
  public void update() {
    if (this.currentText == null) {
      this.hide();
      return;
    }

    this.entityCenter = Game.world().camera().getViewportLocation(this.getEntity().getCenter());

    // old text was displayed long enough
    if (this.lastTextDisplay != 0
        && Game.time().since(this.lastTextDisplay) > this.currentTextDisplayTime) {
      this.currentText = null;
      this.lastTextDisplay = 0;
      return;
    }

    // display new text
    if (this.textIndex < this.currentText.length()
        && Game.time().since(this.lastCharPoll) > LETTER_WRITE_DELAY) {
      this.textIndex++;
      this.lastCharPoll = Game.time().now();
      if (this.typeSound != null) {
        Game.audio().playSound(this.typeSound, this.getEntity());
      }
    }

    // continue displaying currently displayed text
}private SpeechBubble(
      final IEntity entity,
      final String text,
      final Sound typeSound,
      SpeechBubbleAppearance appearance,
      Font font) {
    this(entity, text, appearance, font);
    this.typeSound = typeSound;
}private SpeechBubble(
      final IEntity entity,
      final String text,
      @Nullable SpeechBubbleAppearance appearance,
      @Nullable Font font) {
    if (appearance == null) {
      this.appearance = DEFAULT_APPEARANCE;
    } else {
      this.appearance = appearance;
    }

    final SpeechBubble active = activeSpeechBubbles.get(entity);
    if (active != null) {
      active.hide();
    }
    this.setFont(font);

    this.textBoxWidth = (float) (entity.getWidth() * 4);
    this.entity = entity;

    this.currentText = text;
    this.currentTextDisplayTime = DISPLAYTIME_MIN + text.length() * DISPLAYTIME_PER_LETTER;

    this.lastTextDisplay = Game.time().now();
    this.createBubbleImage();
    entity.getEnvironment().add(this, RenderType.UI);
    Game.loop().attach(this);
    activeSpeechBubbles.put(entity, this);
}
}
```
```java
class de.gurkenlabs.litiengine.gui.TextFieldComponent {
@Override
  public void render(final Graphics2D g) {
    super.render(g);
    g.setFont(this.getFont());
    final FontMetrics fm = g.getFontMetrics();

    if (this.isSelected() && Game.time().since(this.lastToggled) > this.flickerDelay) {
      this.cursorVisible = !this.cursorVisible;
      this.lastToggled = Game.time().now();
    }
    if (this.isSelected() && this.cursorVisible) {
      final Rectangle2D cursor =
          new Rectangle2D.Double(
              this.getX() + this.getTextX() + fm.stringWidth(this.getTextToRender(g)),
              this.getY() + this.getTextY(),
              this.getFont().getSize2D() * 3 / 5,
              this.getFont().getSize2D() * 1 / 5);
      g.setColor(this.getAppearance().getForeColor());
      g.fill(cursor);
    }
}
}
```
```java
class de.gurkenlabs.litiengine.entities.Prop {
public Prop(
      final Point2D location, @Nullable final String spritesheetName, final Material material) {
    super();
    this.rotation = Rotation.NONE;
    this.spritesheetName = spritesheetName;
    this.material = material;
    this.setLocation(location);
    this.updateAnimationController();
}public void setSpritesheetName(@Nullable final String spriteName) {
    this.spritesheetName = spriteName;
    this.updateAnimationController();
}
}
```
```java
class de.gurkenlabs.litiengine.tweening.Tween {
public Tween begin() {
    this.started = Game.time().now();
    this.stopped = false;
    return this;
}
}
```
```java
class de.gurkenlabs.litiengine.graphics.emitters.particles.Particle {
public void update(final Point2D emitterOrigin, final float updateRatio) {
    if (this.aliveTick == 0) {
      this.aliveTick = Game.time().now();
    }

    this.aliveTime = Game.time().since(this.aliveTick);
    if (this.timeToLiveReached()) {
      return;
    }

    if (this.colliding) {
      return;
    }

    if (this.getDeltaWidth() != 0) {
      this.width += this.getDeltaWidth() * updateRatio;
    }

    if (this.getDeltaHeight() != 0) {
      this.height += this.getDeltaHeight() * updateRatio;
    }

    if (this.getDeltaAngle() != 0) {
      this.angle += this.getDeltaAngle() * updateRatio;
    }

    // test for ray cast collision
    final float targetX = this.x + this.getVelocityX() * updateRatio;
    final float targetY = this.y + this.getVelocityY() * updateRatio;

    if (targetX == this.x && targetY == this.y) {
      return;
    }

    if (this.checkForCollision(emitterOrigin, targetX, targetY)) {
      return;
    }

    if (this.getVelocityX() != 0) {
      this.x = targetX;
    }

    if (this.getVelocityY() != 0) {
      this.y = targetY;
    }

    if (this.getAccelerationX() != 0) {
      this.velocityX += this.getAccelerationX() * updateRatio;
    }

    if (this.getAccelerationY() != 0) {
      this.velocityY += this.getAccelerationY() * updateRatio;
    }
}
}
```
```java
class de.gurkenlabs.litiengine.graphics.animation.Animation {
@Override
  public void start() {
    this.playing = true;
    if (this.getKeyframes().isEmpty()) {
      return;
    }

    this.restart();
}@Override
  public void update() {
    // do nothing if the animation is not playing or the current keyframe is not finished
    if (!this.isPlaying()
        || Game.time().since(this.lastFrameUpdate) < this.getCurrentKeyFrame().getDuration()) {
      return;
    }

    // if we are not looping and the last keyframe is finished, we terminate the animation
    if (!this.isLooping() && this.isLastKeyFrame()) {
      this.terminate();
      return;
    }

    // make sure, we stay inside the keyframe list
    final int newFrameIndex =
        (this.getKeyframes().indexOf(this.currentFrame) + 1) % this.getKeyframes().size();
    final KeyFrame previousFrame = this.currentFrame;
    this.currentFrame = this.getKeyframes().get(newFrameIndex);

    for (KeyFrameListener listener : this.listeners) {
      listener.currentFrameChanged(previousFrame, this.currentFrame);
    }

    this.lastFrameUpdate = Game.loop().getTicks();
}
}
```
```java
class de.gurkenlabs.litiengine.graphics.animation.AnimationController {
@Override
  public void update() {
    for (final Animation animation : this.getAll()) {
      animation.update();
    }

    if (this.getCurrent() != null && this.getCurrent().isPaused()) {
      return;
    }

    final boolean playbackFinished = this.getCurrent() != null && !this.getCurrent().isPlaying();
    if (playbackFinished) {
      for (final AnimationListener listener : this.listeners) {
        listener.finished(this.getCurrent());
      }
    }

    if (this.getCurrent() == null || playbackFinished) {
      if (this.getDefault() != null) {
        this.play(this.getDefault().getName());
      } else {
        this.currentAnimation = null;
      }
    }
}
}
```
```java
class de.gurkenlabs.litiengine.graphics.RenderComponent {
private void handleFade() {
    if (this.fadeOutStart != -1) {
      final long timePassed = Game.time().since(this.fadeOutStart);
      this.currentAlpha = MathUtilities.clamp(1 - timePassed / (float) this.fadeOutTime, 0, 1);
      if (this.currentAlpha == 0f) {
        this.fadeOutStart = -1;
        this.fadeOutTime = -1;
      }

      return;
    }

    if (this.fadeInStart != -1) {
      final long timePassed = Game.time().since(this.fadeInStart);
      this.currentAlpha = MathUtilities.clamp(timePassed / (float) this.fadeInTime, 0, 1);
      if (this.currentAlpha == 1f) {
        this.fadeInStart = -1;
        this.fadeInTime = -1;
        this.currentAlpha = Float.NaN;
      }
    }
}public void fadeOut(final int ms) {
    this.fadeInStart = -1;
    this.fadeInTime = -1;
    this.fadeOutStart = Game.time().now();
    this.fadeOutTime = ms;
}public void fadeIn(final int ms) {
    this.fadeOutStart = -1;
    this.fadeOutTime = -1;
    this.fadeInStart = Game.time().now();
    this.fadeInTime = ms;
}
}
```
```java
class de.gurkenlabs.litiengine.entities.Trigger {
private boolean activate(final IEntity activator, final int tar) {
    if (!this.isLoaded()
        || this.isOneTimeTrigger && this.isActivated
        || this.getActivationType() == TriggerActivation.COLLISION
            && activator != null
            && this.collisionActivated.contains(activator)) {
      return false;
    }

    if (this.getCooldown() > 0 && Game.time().since(this.lastActivation) < this.getCooldown()) {
      return false;
    }

    List<Integer> triggerTargets = this.getTargets(tar);

    final TriggerEvent te = new TriggerEvent(this, activator, triggerTargets);

    if (!this.checkActivationPredicates(te)) {
      return false;
    }

    this.isActivated = true;
    if (activator != null) {
      this.collisionActivated.add(activator);
    }

    // if we actually have a trigger target, we send the message to the target
    for (final int target : triggerTargets) {
      final IEntity entity = this.getEnvironment().get(target);
      if (entity == null) {
        log.log(
            Level.WARNING,
            "trigger [{0}] was activated, but the trigger target [{1}] could not be found on the environment",
            new Object[] {this, target});
        continue;
      }

      entity.sendMessage(this, this.message);
    }

    // also send the trigger event to all registered consumers
    for (final TriggerActivatedListener listener : this.activatedListeners) {
      listener.activated(te);
    }

    if (this.isOneTimeTrigger) {
      this.getEnvironment().remove(this);
    }

    this.lastActivation = Game.time().now();
    return true;
}
}
```
```java
class de.gurkenlabs.litiengine.graphics.Camera {
private boolean isShakeEffectActive() {
    return this.getShakeTick() != 0
        && Game.time().since(this.getShakeTick()) < this.getShakeDuration();
}@Override
  public void update() {
    if (Game.world().camera() != null && !Game.world().camera().equals(this)) {
      return;
    }

    if (this.targetZoom > 0) {
      if (Game.time().since(this.zoomTick) >= this.zoomDelay) {
        this.zoom = this.targetZoom;
        this.targetZoom = 0;
        this.zoomDelay = 0;
        this.zoomTick = 0;
        this.zoomStep = 0;
      } else {
        this.zoom += this.zoomStep;
      }

      final ZoomChangedEvent event = new ZoomChangedEvent(this, this.getZoom());
      for (final ZoomChangedListener listener : this.zoomListeners) {
        listener.zoomChanged(event);
      }
    }

    if (this.panTime > 0) {
      if (--this.panTime <= 0) {
        this.setFocus(this.targetFocus);
        this.targetFocus = null;
      } else {
        double diff = this.panTime / (this.panTime + 1.0);
        this.focus =
            new Point2D.Double(
                this.focus.getX() * diff + this.targetFocus.getX() * (1.0 - diff),
                this.focus.getY() * diff + this.targetFocus.getY() * (1.0 - diff));
      }
    }

    if (!this.isShakeEffectActive()) {
      this.shakeOffsetX = 0;
      this.shakeOffsetY = 0;
      return;
    }

    if (Game.time().since(this.lastShake) > this.shakeDelay) {
      this.shakeOffsetX = this.getShakeIntensity() * ThreadLocalRandom.current().nextGaussian();
      this.shakeOffsetY = this.getShakeIntensity() * ThreadLocalRandom.current().nextGaussian();
      this.lastShake = Game.time().now();
    }
}@Override
  public void setZoom(final float targetZoom, final int delay) {
    if (delay == 0) {

      this.zoom = targetZoom;
      this.targetZoom = 0;
      this.zoomDelay = 0;
      this.zoomTick = 0;
      this.zoomStep = 0;

      final ZoomChangedEvent event = new ZoomChangedEvent(this, targetZoom);
      for (final ZoomChangedListener listener : this.zoomListeners) {
        listener.zoomChanged(event);
      }
    } else {
      this.zoomTick = Game.time().now();
      this.targetZoom = targetZoom;
      this.zoomDelay = delay;

      final double tickduration = 1000 / (double) Game.loop().getTickRate();
      final double tickAmount = delay / tickduration;
      final float totalDelta = this.targetZoom - this.zoom;
      this.zoomStep = tickAmount > 0 ? (float) (totalDelta / tickAmount) : totalDelta;
    }
}@Override
  public void shake(final double intensity, final int delay, final int shakeDuration) {
    this.shakeTick = Game.time().now();
    this.shakeDelay = delay;
    this.shakeIntensity = intensity;
    this.shakeDuration = shakeDuration;
}
}
```
```java
class de.gurkenlabs.litiengine.entities.Creature {
public void setSpritesheetName(String spritesheetName) {
    if (this.spritesheetName != null && this.spritesheetName.equals(spritesheetName)) {
      return;
    }

    this.spritesheetName = spritesheetName;
    this.updateAnimationController();
}public boolean isIdle() {
    return Game.time().since(this.lastMoved) > IDLE_DELAY;
}@Override
  public void setLocation(final Point2D position) {
    if (this.isDead() || position == null) {
      return;
    }

    final Point2D oldLocation = this.getLocation();
    super.setLocation(position);

    if (Game.hasStarted() && this.isLoaded()) {
      this.lastMoved = Game.time().now();
      this.fireMovedEvent(
          new EntityMovedEvent(
              this, this.getX() - oldLocation.getX(), this.getY() - oldLocation.getY()));
    }
}
}
```
```java
class de.gurkenlabs.litiengine.gui.screens.ScreenManager {
public void display(final String screenName) {
    if (this.current() != null && this.current().getName().equalsIgnoreCase(screenName)) {
      log.log(
          Level.INFO,
          "Skipping displaying of screen {0} because it is already the current screen.",
          screenName);
      return;
    }

    if (this.screens.stream()
        .noneMatch(element -> element.getName().equalsIgnoreCase(screenName))) {
      log.log(
          Level.WARNING,
          "Could not display the screen {0} because there is no screen with the specified name.",
          screenName);
      return;
    }

    Screen screen = this.get(screenName);
    if (screen == null) {
      return;
    }

    this.display(screen);
}public void add(final Screen screen) {
    screen.setWidth(Game.window().getWidth());
    screen.setHeight(Game.window().getHeight());
    this.screens.add(screen);

    if (this.current() == null) {
      this.display(screen);
    }
}public void remove(Screen screen) {
    this.screens.remove(screen);
    if (this.current() == screen) {
      if (!this.screens.isEmpty()) {
        this.display(this.screens.get(0));
      } else {
        this.display((Screen) null);
      }
    }
}public void display(@Nullable final Screen screen) {
      if (Game.hasStarted() && Game.time().since(this.lastScreenChange) < this.getChangeCooldown()) {
        log.log(
            Level.INFO,
            "Skipping displaying of screen {0} because screen changing is currently on cooldown.",
            screen != null ? screen.getName() : "");
        return;
      }
  
      final Screen previous = this.current();
      if (previous != null) {
        previous.suspend();
      }
  
      if (screen != null && !this.screens.contains(screen)) {
        this.screens.add(screen);
      }
  
      this.currentScreen = screen;
      if (!Game.isInNoGUIMode() && this.current() != null) {
        this.current().prepare();
      }
  
      this.lastScreenChange = Nullability.castToNonnull(Game.loop(), "initialized before usage").getTicks();
  
      final ScreenChangedEvent event = new ScreenChangedEvent(this.current(), previous);
      for (final ScreenChangedListener listener : this.screenChangedListeners) {
        listener.changed(event);
      }
}
}
```
```java
class de.gurkenlabs.litiengine.abilities.Ability {
public boolean isOnCooldown() {
    return (this.getCurrentExecution() != null
        && this.getCurrentExecution().getExecutionTicks() > 0
        && Game.time().since(this.getCurrentExecution().getExecutionTicks())
            < this.getAttributes().cooldown().get());
}public boolean isActive() {
    return this.getCurrentExecution() != null
        && Game.time().since(this.getCurrentExecution().getExecutionTicks())
            < this.getAttributes().duration().get();
}@Nullable
  public AbilityExecution cast() {
    if (!this.canCast()) {
      return null;
    }
    this.currentExecution = new AbilityExecution(this);

    for (final AbilityCastListener listener : this.abilityCastListeners) {
      listener.abilityCast(this.currentExecution);
    }

    return this.getCurrentExecution();
}public float getRemainingCooldownInSeconds() {
    if (this.getCurrentExecution() == null
        || this.getExecutor() == null
        || this.getExecutor().isDead()) {
      return 0;
    }

    // calculate cooldown in seconds
    return (float)
        (!this.canCast()
            ? (this.getAttributes().cooldown().get()
                    - Game.time().since(this.getCurrentExecution().getExecutionTicks()))
                * 0.001
            : 0);
}
}
```
```java
class de.gurkenlabs.litiengine.entities.EntityHitEvent {
EntityHitEvent(
      final ICombatEntity hitEntity,
      @Nullable final Ability ability,
      final int damage,
      final boolean kill) {
    super(hitEntity);
    this.executor = ability != null ? ability.getExecutor() : null;
    this.hitEntity = hitEntity;
    this.ability = ability;
    this.damage = damage;
    this.kill = kill;
    this.time = Game.time().now();
}
}
```
```java
class de.gurkenlabs.litiengine.graphics.emitters.Emitter {
public void delete() {
    this.deactivate();
    if (Game.world().environment() != null) {
      Game.world().environment().remove(this);
    }
}public void activate() {
    if (this.activated) {
      return;
    }

    this.activated = true;
    this.activationTick = Game.time().now();
    Game.loop().attach(this);
}@Override
  public void update() {
    if (this.isPaused()) {
      return;
    }

    // clear particles if the effect time to life is reached
    if (this.isFinished()) {
      for (EmitterFinishedListener listener : this.finishedListeners) {
        listener.finished(this);
      }

      this.delete();
      return;
    }

    final float updateRatio = (float) this.data().getUpdateRate() / Game.loop().getTickRate();
    for (final Particle p : this.getParticles().stream().collect(Collectors.toList())) {
      if (this.particleCanBeRemoved(p)) {
        // remove dead particles
        this.particles.remove(p);
        continue;
      }

      p.update(this.getOrigin(), updateRatio);
    }

    this.aliveTime = Game.time().since(this.activationTick);
    if ((this.data().getSpawnRate() == 0
        || Game.time().since(this.lastSpawn) >= this.data().getSpawnRate())) {
      this.lastSpawn = Game.time().now();
      this.spawnParticle();
    }
}
}
```
```java
class de.gurkenlabs.litiengine.GameLoop {
@Override
  public int perform(int delay, Runnable action) {
    final long d = Game.time().toTicks(delay);

    TimedAction a = new TimedAction(this.getTicks() + d, action);
    this.actions.add(a);

    return a.getId();
}
}
```
```java
class de.gurkenlabs.litiengine.environment.EntitySpawner {
protected boolean shouldSpawn() {
    return this.lastSpawnWave == 0
        || Game.time().since(this.lastSpawnWave) >= this.getSpawnInterval();
}@Override
  public void update() {
    if (!this.shouldSpawn()) {
      return;
    }

    this.spawnNewEntities();
    this.lastSpawnWave = Game.time().now();
}
}
```
```java
class de.gurkenlabs.litiengine.graphics.FreeFlightCamera {
@Override
  public void update() {
    this.handleFreeFlightCamera();
}public FreeFlightCamera(double x, double y) {
    this(new Point2D.Double(x, y));
}
}
```
```java
class de.gurkenlabs.litiengine.environment.Environment {
public void unload() {
    if (!this.loaded) {
      return;
    }

    // unregister all updatable entities from the current environment
    for (final IEntity entity : this.allEntities.values()) {
      this.unload(entity);
    }

    this.loaded = false;
    this.fireEvent(l -> l.unloaded(this));
}private static void loadUpdatableOrEmitterEntity(IEntity entity) {
      if (entity instanceof Emitter) {
        final Emitter emitter = (Emitter) entity;
        if (emitter.isActivateOnInit()) {
          emitter.activate();
        }
      } else if (entity instanceof IUpdateable) {
        Nullability.castToNonnull(Game.loop(), "initialized through init").attach((IUpdateable) entity);
      }
}public void clear() {
    Game.physics().clear();

    this.combatEntities.clear();
    this.mobileEntities.clear();
    this.gravityForces.clear();
    this.layerEntities.clear();
    this.entitiesByTag.clear();
    this.allEntities.clear();

    for (RenderType renderType : RenderType.values()) {
      this.miscEntities.get(renderType).clear();
      this.renderListeners.get(renderType).clear();
      this.renderables.get(renderType).clear();
    }

    dispose(this.allEntities.values());
    dispose(this.triggers);
    this.emitters.clear();
    this.colliders.clear();
    this.props.clear();
    this.creatures.clear();
    this.staticShadows.clear();
    this.combatEntities.clear();
    this.mobileEntities.clear();
    this.lightSources.clear();
    this.spawnPoints.clear();
    this.soundSources.clear();
    this.mapAreas.clear();
    this.triggers.clear();

    this.ambientLight = null;
    this.staticShadowLayer = null;

    for (Map<Integer, IEntity> type : this.miscEntities.values()) {
      type.clear();
    }

    this.initialized = false;

    this.fireEvent(l -> l.cleared(this));
}private void load(final IEntity entity) {
    // an entity can only exist on one environment at a time, so remove it from the current one
    if (entity.getEnvironment() != null) {
      entity.getEnvironment().remove(entity);
    }

    // 1. add to physics engine
    loadPhysicsEntity(entity);

    // 2. register for update or activate
    loadUpdatableOrEmitterEntity(entity);

    // 3. if a gravity is defined, add a gravity force to the entity
    if (entity instanceof IMobileEntity && this.getGravity() != 0) {
      this.addGravityForce((IMobileEntity) entity);
    }

    // 4. attach all controllers
    entity.attachControllers();

    if (this.loaded && (entity instanceof LightSource || entity instanceof StaticShadow)) {
      this.updateLighting(entity);
    }

    entity.loaded(this);
}private void unload(final IEntity entity) {
    // 1. remove from physics engine
    if (entity instanceof ICollisionEntity) {
      Game.physics().remove((ICollisionEntity) entity);
    }

    // 2. unregister from update
    if (entity instanceof IUpdateable) {
      Game.loop().detach((IUpdateable) entity);
    }

    if (entity instanceof IMobileEntity) {
      this.removeGravity((IMobileEntity) entity);
    }

    // 3. detach all controllers
    entity.detachControllers();

    if (entity instanceof Emitter) {
      Emitter em = (Emitter) entity;
      em.deactivate();
    }

    if (this.loaded && (entity instanceof LightSource || entity instanceof StaticShadow)) {
      this.updateLighting(entity);
    }

    entity.removed(this);
}public void remove(final IEntity entity) {
    if (entity == null) {
      return;
    }

    this.allEntities.remove(entity.getMapId());
    Iterator<List<IEntity>> iter = this.layerEntities.values().iterator();
    while (iter.hasNext()) {
      List<IEntity> layer = iter.next();
      if (layer.remove(entity) && layer.isEmpty()) {
        iter.remove();
      }
    }
    if (this.miscEntities.get(entity.getRenderType()) != null) {
      this.miscEntities.get(entity.getRenderType()).values().remove(entity);
    }

    for (String tag : entity.getTags()) {
      if (this.getEntitiesByTag().containsKey(tag)) {
        this.getEntitiesByTag().get(tag).remove(entity);

        if (this.getEntitiesByTag().get(tag).isEmpty()) {
          this.getEntitiesByTag().remove(tag);
        }
      }
    }

    if (entity instanceof Emitter) {
      Emitter emitter = (Emitter) entity;
      this.removeEmitter(emitter);
    }

    if (entity instanceof MapArea) {
      this.mapAreas.remove(entity);
    }

    if (entity instanceof Prop) {
      this.props.remove(entity);
    }

    if (entity instanceof Creature) {
      this.creatures.remove(entity);
    }

    if (entity instanceof CollisionBox) {
      this.colliders.remove(entity);
      this.staticShadows.removeIf(x -> x.getOrigin() != null && x.getOrigin().equals(entity));
    }

    if (entity instanceof LightSource) {
      this.lightSources.remove(entity);
      this.updateLighting(entity);
    }

    if (entity instanceof Trigger) {
      this.triggers.remove(entity);
    }

    if (entity instanceof Spawnpoint) {
      this.spawnPoints.remove(entity);
    }
    if (entity instanceof SoundSource) {
      this.soundSources.remove(entity);
    }

    if (entity instanceof StaticShadow) {
      this.staticShadows.remove(entity);
      this.updateLighting(entity);
    }

    if (entity instanceof IMobileEntity) {
      this.mobileEntities.values().remove(entity);
    }

    if (entity instanceof ICombatEntity) {
      this.combatEntities.values().remove(entity);
    }

    this.unload(entity);

    this.fireEntityEvent(l -> l.entityRemoved(entity));
}
}
```
```java
class de.gurkenlabs.litiengine.physics.MovementController {
@Override
  public void update() {
    this.handleForces();
    this.handleMovement();
}
}
```
```java
class de.gurkenlabs.litiengine.Game {
static synchronized void terminate() {
        if (!initialized || gameLoop == null) {
          return;
        }
    
        hasStarted = false;
        initialized = false;
    
        config().save();
        gameLoop.terminate();
        tweenEngine.terminate();
        soundEngine.terminate();
    
        world().clear();
    
        for (final GameListener listener : gameListeners) {
          try {
            listener.terminated();
          } catch (Exception e) {
            log().log(Level.WARNING, "game listener threw an exception during shutdown", e);
          }
        }
    
        gameLoop = null;
        screenManager = null;
        gameWindow = null;
}public static synchronized void start() {
          if (!initialized) {
              throw new IllegalStateException(
                  "The game cannot be started without being first initialized. Call Game.init(...) before Game.start().");
          }
    
          if (gameLoop == null) {
              throw new IllegalStateException(
                  "Game loop is not initialized. Ensure Game.init(...) has been called successfully.");
          }
          
          Nullability.castToNonnull(gameLoop, "gameLoop cannot be null").start();
          tweenEngine.start();
          soundEngine.start();
    
          for (final GameListener listener : gameListeners) {
              listener.started();
          }
    
          hasStarted = true;
}public static synchronized void init(String... args) {
    if (initialized) {
      log().log(Level.INFO, "The game has already been initialized.");
      return;
    }

    log.init();
    handleCommandLineArguments(args);

    config().load();
    Locale.setDefault(new Locale(config().client().getCountry(), config().client().getLanguage()));

    gameLoop = new GameLoop("Main Update Loop", config().client().getMaxFps());
    loop().attach(physics());
    loop().attach(world());

    // setup default exception handling for render and update loop
    setUncaughtExceptionHandler(
        new DefaultUncaughtExceptionHandler(config().client().exitOnError()));

    screenManager = new ScreenManager();
    gameWindow = new GameWindow();

    // initialize  the game window
    window().init();
    world.setCamera(new Camera());

    for (GameListener listener : gameListeners) {
      listener.initialized(args);
    }

    if (!isInNoGUIMode()) {
      window().getRenderComponent().onRendered(g -> metrics().render(g));

      graphics()
          .addEntityRenderedListener(
              e -> DebugRenderer.renderEntityDebugInfo(e.getGraphics(), e.getEntity()));

      window().getRenderComponent().onFpsChanged(fps -> metrics().setFramesPerSecond(fps));
      window()
          .setIcons(
              Arrays.asList(
                  Resources.images().get("liti-logo-x16.png"),
                  Resources.images().get("liti-logo-x20.png"),
                  Resources.images().get("liti-logo-x32.png"),
                  Resources.images().get("liti-logo-x48.png")));

      Input.keyboard()
          .onKeyTyped(
              KeyEvent.VK_PRINTSCREEN,
              key -> {
                // don't take a screenshot if a modifier is active
                if (key.getModifiers() != 0) {
                  return;
                }

                window().getRenderComponent().takeScreenshot();
              });
    }

    Runtime.getRuntime().addShutdownHook(new Thread(Game::terminate, "Shutdown"));

    initialized = true;
}
}
```


Response Format:
Provide the answer in **XML format** as follows:

#### If the method **cannot** return `null` at the specific call site:
```xml
<response>
  <reason><![CDATA[EXPLAIN WHY THE INVOCATION Game.loop() RESULT CANNOT BE NULL.]]></reason>
  <value>NO</value>
</response>

#### If the method can return null at the specific call site:
<response>
  <reason><![CDATA[EXPLAIN WHY THE INVOCATION Game.loop() RESULT CAN BE NULL.]]></reason>
  <value>YES</value>
</response>

#### If you are unsure or If there are any methods that directly or indirectly affect the return value and are not fully disclosed, request their declarations first, in the following format:
<response>
  <reason><![CDATA[EXPLAIN WHY THIS METHOD DECLARATION IS NECESSARY AND WHY YOU CANNOT MAKE A CONFIDENT DECISION WITHOUT IT]]></reason>
  <success>false</success>
  <methods>
    <method>methodName</method>
  </methods>
</response>

Additional Notes:
Be precise in your reasoning.
If a methods return value depends on another method not provided, request its declaration before making a conclusion.
If the method can return null in this case but not in others, explain why it happens specifically for this call.

11:53:24.711 TRACE edu.ucr.cs.riple.core.checkers.nullaway.codefix.ChatGPT.ask
Retrieving response from cache
11:53:24.711 TRACE edu.ucr.cs.riple.core.checkers.nullaway.codefix.Response.tryCreate
Trying to create Response:
```xml
<response>
  <reason><![CDATA[The method Game.loop() returns a static field, gameLoop, which is assigned during the initialization phase within the Game.init() method. The Game.init() method contains a check to ensure that the game has not already been initialized. If not initialized, it proceeds to create a new instance of GameLoop and assigns it to gameLoop. Hence, calling Game.loop() in a context where Game.init() has been successfully executed guarantees that gameLoop is initialized and non-null. Moreover, Game.start() which invokes gameLoop.start() to begin the game loop is protected with a check to ensure initialization has been completed. Therefore, at the call site Game.loop(), gameLoop is guaranteed to be non-null provided Game has been initialized.]]></reason>
  <value>NO</value>
</response>
```
11:53:24.712 TRACE edu.ucr.cs.riple.core.checkers.nullaway.codefix.Response.<init>
Creating Response:
```xml
<response>
  <reason><![CDATA[The method Game.loop() returns a static field, gameLoop, which is assigned during the initialization phase within the Game.init() method. The Game.init() method contains a check to ensure that the game has not already been initialized. If not initialized, it proceeds to create a new instance of GameLoop and assigns it to gameLoop. Hence, calling Game.loop() in a context where Game.init() has been successfully executed guarantees that gameLoop is initialized and non-null. Moreover, Game.start() which invokes gameLoop.start() to begin the game loop is protected with a check to ensure initialization has been completed. Therefore, at the call site Game.loop(), gameLoop is guaranteed to be non-null provided Game has been initialized.]]></reason>
  <value>NO</value>
</response>
```
11:53:24.712 TRACE edu.ucr.cs.riple.core.checkers.nullaway.codefix.Response.<init>
Response created:
Disagreement: The method Game.loop() returns a static field, gameLoop, which is assigned during the initialization phase within the Game.init() method. The Game.init() method contains a check to ensure that the game has not already been initialized. If not initialized, it proceeds to create a new instance of GameLoop and assigns it to gameLoop. Hence, calling Game.loop() in a context where Game.init() has been successfully executed guarantees that gameLoop is initialized and non-null. Moreover, Game.start() which invokes gameLoop.start() to begin the game loop is protected with a check to ensure initialization has been completed. Therefore, at the call site Game.loop(), gameLoop is guaranteed to be non-null provided Game has been initialized.
11:53:24.712 TRACE edu.ucr.cs.riple.core.checkers.nullaway.codefix.AdvancedNullAwayCodeFix.resolveMethodDereferenceError
Method is not returning nullable on call site. Injecting suppression annotation.
11:53:24.712 TRACE edu.ucr.cs.riple.core.checkers.nullaway.codefix.AdvancedNullAwayCodeFix.constructCastToNonnullChange
Constructing cast to nonnull change for reason: The method Game.loop() returns a static field, gameLoop, which is assigned during the initialization phase within the Game.init() method. The Game.init() method contains a check to ensure that the game has not already been initialized. If not initialized, it proceeds to create a new instance of GameLoop and assigns it to gameLoop. Hence, calling Game.loop() in a context where Game.init() has been successfully executed guarantees that gameLoop is initialized and non-null. Moreover, Game.start() which invokes gameLoop.start() to begin the game loop is protected with a check to ensure initialization has been completed. Therefore, at the call site Game.loop(), gameLoop is guaranteed to be non-null provided Game has been initialized.
11:53:24.712 TRACE edu.ucr.cs.riple.core.checkers.nullaway.codefix.ChatGPT.ask
Asking ChatGPT:
For the reason you mentioned earlier:

"The method Game.loop() returns a static field, gameLoop, which is assigned during the initialization phase within the Game.init() method. The Game.init() method contains a check to ensure that the game has not already been initialized. If not initialized, it proceeds to create a new instance of GameLoop and assigns it to gameLoop. Hence, calling Game.loop() in a context where Game.init() has been successfully executed guarantees that gameLoop is initialized and non-null. Moreover, Game.start() which invokes gameLoop.start() to begin the game loop is protected with a check to ensure initialization has been completed. Therefore, at the call site Game.loop(), gameLoop is guaranteed to be non-null provided Game has been initialized."

in the method below, the expression Game.loop() is not nullable at the point it is used.

```java
private void handleFreeFlightCamera() {
    if (Game.world().environment() == null || Game.world().environment().getMap() == null) {
      return;
    }

    final Point2D mouseLocation = Input.mouse().getLocation();

    final double scrollSpeed =
        this.getVelocity()
            / (double) Game.loop().getTickRate()
            * Game.config().input().getMouseSensitivity();

    double x = this.getFocus().getX();
    double y = this.getFocus().getY();

    double deltaX = 0;
    if (mouseLocation.getX() < this.getScrollPadding()) {
      deltaX -= scrollSpeed;
    } else if (Game.window().getResolution().getWidth() - mouseLocation.getX()
        < this.getScrollPadding()) {
      deltaX += scrollSpeed;
    }

    double deltaY = 0;
    if (mouseLocation.getY() < this.getScrollPadding()) {
      deltaY -= scrollSpeed;
    } else if (Game.window().getResolution().getHeight() - mouseLocation.getY()
        < this.getScrollPadding()) {
      deltaY += scrollSpeed;
    }

    x += deltaX;
    y += deltaY;

    this.setFocus(new Point2D.Double(x, y));
}
```
Please Summarize the reason in max 5 words and rewrite the method so that at the line "            / (double) Game.loop().getTickRate()", at the occurrence of: "Game.loop()" is replaced with `Nullability.castToNonnull(Game.loop(), summary of reason)`
Replace "REASON" with the exact reason summary I provide to you (maximum 5 words), not with a generic explanation like "checked to be nonnull".
see the example below, for expression `foo.getBar()`, to wrap it with `Nullability.castToNonnull(foo.getBar(), "reason")`.

```java
public t(){
    String l = foo.getBar();
}
```

will be:
```java
public t(){
    String l = Nullability.castToNonnull(foo.getBar(), "checked to be nonnull");
}
```

### Instructions:

Do not import any additional classes.

Do not add Java comments.

Only modify relevant lines as required.

Return only the modified method wrapped in the XML format shown below.

Place the Java code inside the <code> tag using a CDATA block with ```java formatting.

Just give me the fixed code snippet in XML format in <response> tag like the example below. I will apply the fix to my codebase. Do not import any additional libraries or classes or add java comments. If you can provide the fixed code snippet, please provide it in the following format and place the code snippet in the <code> tag within ```java block.
<response>
  <success>true</success>
  <code><![CDATA[
  ```java
  Your fixed code snippet here
  ```
    ]]>
  </code>
</response>

11:53:24.713 TRACE edu.ucr.cs.riple.core.checkers.nullaway.codefix.ChatGPT.ask
Retrieving response from cache
11:53:24.713 TRACE edu.ucr.cs.riple.core.checkers.nullaway.codefix.Response.tryCreate
Trying to create Response:
```xml
<response>
  <success>true</success>
  <code><![CDATA[
  ```java
  private void handleFreeFlightCamera() {
    if (Game.world().environment() == null || Game.world().environment().getMap() == null) {
      return;
    }

    final Point2D mouseLocation = Input.mouse().getLocation();

    final double scrollSpeed =
        this.getVelocity()
            / (double) Nullability.castToNonnull(Game.loop(), "gameLoop always initialized")
                .getTickRate()
            * Game.config().input().getMouseSensitivity();

    double x = this.getFocus().getX();
    double y = this.getFocus().getY();

    double deltaX = 0;
    if (mouseLocation.getX() < this.getScrollPadding()) {
      deltaX -= scrollSpeed;
    } else if (Game.window().getResolution().getWidth() - mouseLocation.getX()
        < this.getScrollPadding()) {
      deltaX += scrollSpeed;
    }

    double deltaY = 0;
    if (mouseLocation.getY() < this.getScrollPadding()) {
      deltaY -= scrollSpeed;
    } else if (Game.window().getResolution().getHeight() - mouseLocation.getY()
        < this.getScrollPadding()) {
      deltaY += scrollSpeed;
    }

    x += deltaX;
    y += deltaY;

    this.setFocus(new Point2D.Double(x, y));
  }
  ```
    ]]>
  </code>
</response>
```
11:53:24.713 TRACE edu.ucr.cs.riple.core.checkers.nullaway.codefix.Response.<init>
Creating Response:
```xml
<response>
  <success>true</success>
  <code><![CDATA[
  ```java
  private void handleFreeFlightCamera() {
    if (Game.world().environment() == null || Game.world().environment().getMap() == null) {
      return;
    }

    final Point2D mouseLocation = Input.mouse().getLocation();

    final double scrollSpeed =
        this.getVelocity()
            / (double) Nullability.castToNonnull(Game.loop(), "gameLoop always initialized")
                .getTickRate()
            * Game.config().input().getMouseSensitivity();

    double x = this.getFocus().getX();
    double y = this.getFocus().getY();

    double deltaX = 0;
    if (mouseLocation.getX() < this.getScrollPadding()) {
      deltaX -= scrollSpeed;
    } else if (Game.window().getResolution().getWidth() - mouseLocation.getX()
        < this.getScrollPadding()) {
      deltaX += scrollSpeed;
    }

    double deltaY = 0;
    if (mouseLocation.getY() < this.getScrollPadding()) {
      deltaY -= scrollSpeed;
    } else if (Game.window().getResolution().getHeight() - mouseLocation.getY()
        < this.getScrollPadding()) {
      deltaY += scrollSpeed;
    }

    x += deltaX;
    y += deltaY;

    this.setFocus(new Point2D.Double(x, y));
  }
  ```
    ]]>
  </code>
</response>
```
11:53:24.714 TRACE edu.ucr.cs.riple.core.checkers.nullaway.codefix.Response.<init>
Response created:
private void handleFreeFlightCamera() {
    if (Game.world().environment() == null || Game.world().environment().getMap() == null) {
      return;
    }

    final Point2D mouseLocation = Input.mouse().getLocation();

    final double scrollSpeed =
        this.getVelocity()
            / (double) Nullability.castToNonnull(Game.loop(), "gameLoop always initialized")
                .getTickRate()
            * Game.config().input().getMouseSensitivity();

    double x = this.getFocus().getX();
    double y = this.getFocus().getY();

    double deltaX = 0;
    if (mouseLocation.getX() < this.getScrollPadding()) {
      deltaX -= scrollSpeed;
    } else if (Game.window().getResolution().getWidth() - mouseLocation.getX()
        < this.getScrollPadding()) {
      deltaX += scrollSpeed;
    }

    double deltaY = 0;
    if (mouseLocation.getY() < this.getScrollPadding()) {
      deltaY -= scrollSpeed;
    } else if (Game.window().getResolution().getHeight() - mouseLocation.getY()
        < this.getScrollPadding()) {
      deltaY += scrollSpeed;
    }

    x += deltaX;
    y += deltaY;

    this.setFocus(new Point2D.Double(x, y));
  }
11:53:24.714 TRACE edu.ucr.cs.riple.core.checkers.nullaway.codefix.ChatGPT.fixDereferenceByAddingCastToNonnull
Fixing the error by adding castToNonnull
11:53:24.715 TRACE edu.ucr.cs.riple.core.checkers.nullaway.codefix.AdvancedNullAwayCodeFix.fixTriggeredErrorsForLocation
Resolving unresolvable error for triggered error: Type='DEREFERENCE_NULLABLE', message='dereferenced expression Game.loop() is @Nullable'
/home/nima/Developer/nullness-benchmarks/litiengine/src/de/gurkenlabs/litiengine/GameMetrics.java:88
    this.drawMetric(g, "updatables: " + Game.loop().getUpdatableCount());
11:53:24.715 TRACE edu.ucr.cs.riple.core.checkers.nullaway.codefix.AdvancedNullAwayCodeFix.fix
Fixing error: Type='DEREFERENCE_NULLABLE', message='dereferenced expression Game.loop() is @Nullable'
/home/nima/Developer/nullness-benchmarks/litiengine/src/de/gurkenlabs/litiengine/GameMetrics.java:88
    this.drawMetric(g, "updatables: " + Game.loop().getUpdatableCount());
11:53:24.715 TRACE edu.ucr.cs.riple.core.checkers.nullaway.codefix.AdvancedNullAwayCodeFix.resolveDereferenceError
Resolving dereference error: Type='DEREFERENCE_NULLABLE', message='dereferenced expression Game.loop() is @Nullable'
/home/nima/Developer/nullness-benchmarks/litiengine/src/de/gurkenlabs/litiengine/GameMetrics.java:88
    this.drawMetric(g, "updatables: " + Game.loop().getUpdatableCount());
11:53:24.715 TRACE edu.ucr.cs.riple.core.checkers.nullaway.codefix.AdvancedNullAwayCodeFix.resolveDereferenceError
Checking nullability possibility at error point
11:53:24.716 TRACE edu.ucr.cs.riple.core.checkers.nullaway.codefix.ChatGPT.checkNullabilityPossibilityAtErrorPoint
Asking if the expression can be null at error point point
11:53:24.716 TRACE edu.ucr.cs.riple.core.checkers.nullaway.codefix.ChatGPT.ask
Asking ChatGPT:
In the method below, is there a possibility that the expression "Game.loop()" at line "this.drawMetric(g, "updatables: " + Game.loop().getUpdatableCount());" is null?
@Override
  public void render(final Graphics2D g) {
    this.updateMetrics();

    if (!Game.config().client().showGameMetrics()) {
      return;
    }

    this.currentOffsetY = 0;

    g.setColor(this.renderColor);

    // render client metrics
    this.drawTitle(g, "[client]");
    this.drawMetric(g, "fps       : " + this.getFramesPerSecond());
    this.drawMetric(g, "max fps   : " + this.maxFramesPerSecond);
    this.drawMetric(g, "updatables: " + Game.loop().getUpdatableCount());

    // render jvm metrics if debug is enabled
    if (Game.config().debug().isDebugEnabled()) {
      this.drawTitle(g, "[jvm]");
      this.drawMetric(g, "java      : " + this.javaVersion);
      this.drawMetric(g, "memory    : " + String.format("%-5.5s", this.usedMemory) + " MB");
      this.drawMetric(g, "threads   : " + Thread.activeCount());
    }

    // render rendering metrics
    if (!this.renderMetrics.isEmpty()) {
      this.drawTitle(g, "[update]");

      for (RenderMetrics metric : this.renderMetrics) {
        this.drawMetric(g, metric.toString());
      }

      this.renderMetrics.clear();
    }
}
Give a single-word answer in XML format. If it is possible for the expression to be null, respond with:
```xml
<response>
    <reason><![CDATA[YOUR REASON]]></reason>
    <value>YES</value>
</response>
```
If it is not possible for the expression to be null, respond with:
```xml
<response>
    <reason><![CDATA[YOUR REASON]]></reason>
    <value>NO</value>
</response>
```
If you are unsure or need more information, respond with where you can ask for more details or what specific information you need.

If additional information is required, list each request inside a `<request>` tag. If no additional information is needed, omit the `<requests>` section.

Respond with:
```xml
<response>
    <reason><![CDATA[YOUR REASON]]></reason>
    <value>UNKNOWN</value>
    <!-- Include <requests> only if additional information is needed -->
    <requests>
        <request><![CDATA[YOUR REQUEST 1]]></request>
        <request><![CDATA[YOUR REQUEST 2]]></request>
    </requests>
</response>
```
11:53:24.716 TRACE edu.ucr.cs.riple.core.checkers.nullaway.codefix.ChatGPT.ask
Retrieving response from cache
11:53:24.716 TRACE edu.ucr.cs.riple.core.checkers.nullaway.codefix.Response.tryCreate
Trying to create Response:
```xml
<response>
    <reason><![CDATA[Without seeing the implementation of Game.loop(), it's impossible to determine if it can return null.]]></reason>
    <value>UNKNOWN</value>
    <requests>
        <request><![CDATA[Provide the implementation details of Game.loop().]]></request>
    </requests>
</response>
```
11:53:24.716 TRACE edu.ucr.cs.riple.core.checkers.nullaway.codefix.Response.<init>
Creating Response:
```xml
<response>
    <reason><![CDATA[Without seeing the implementation of Game.loop(), it's impossible to determine if it can return null.]]></reason>
    <value>UNKNOWN</value>
    <requests>
        <request><![CDATA[Provide the implementation details of Game.loop().]]></request>
    </requests>
</response>
```
11:53:24.717 TRACE edu.ucr.cs.riple.core.checkers.nullaway.codefix.Response.<init>
Response created:
Unknown: Without seeing the implementation of Game.loop(), it's impossible to determine if it can return null.
11:53:24.718 TRACE edu.ucr.cs.riple.core.checkers.nullaway.codefix.AdvancedNullAwayCodeFix.resolveMethodDereferenceError
Resolving method dereference error.
11:53:24.718 TRACE edu.ucr.cs.riple.core.checkers.nullaway.codefix.AdvancedNullAwayCodeFix.resolveMethodDereferenceError
Method is in annotated package. Checking if the method is returning nullable.
11:53:24.718 TRACE edu.ucr.cs.riple.core.checkers.nullaway.codefix.AdvancedNullAwayCodeFix.investigateMethodReturnNullability
Checking if the method is returning nullable.
11:53:24.720 TRACE edu.ucr.cs.riple.core.checkers.nullaway.codefix.ChatGPT.checkIfMethodIsReturningNullable
Asking if the method is returning nullable: loop()
11:53:24.722 TRACE edu.ucr.cs.riple.core.checkers.nullaway.codefix.ChatGPT.ask
Asking ChatGPT:
In the method below, is there a possibility that the method returns null based only on its body? Consider the following points:

- The method may have multiple return paths; consider all return statements.
- If the method calls another method, do not assume its return value unless its full declaration is provided. Request its declaration if needed.
- The method may throw an exception instead of returning null. An exception path should not be considered a null return.
- Ensure you request the declarations of any methods whose return values directly or indirectly impact this methods return value before making a conclusion.
- Carefully analyze all conditions and prior operations that may guarantee a non-null return value.

@Nullable public static IGameLoop loop() {
    return gameLoop;
}

Here are the method definitions in addition to the method inquired:

Depth: 0
```java
class de.gurkenlabs.litiengine.Game {
@Nullable public static IGameLoop loop() {
    return gameLoop;
}
}
```


Response Format:
Provide the answer in **XML format** as follows:

#### If the method **cannot** return `null`:
```xml
<response>
  <reason><![CDATA[EXPLAIN WHY THE METHOD CANNOT RETURN NULL]]></reason>
  <value>NO</value>
</response>
```

#### If the method can return null:
```xml
<response>
  <reason><![CDATA[EXPLAIN WHY THE METHOD CAN RETURN NULL]]></reason>
  <value>YES</value>
</response>
```

#### If you are unsure or need more information, respond with where you can ask for more details or what specific information you need.

#### If you are unsure or If there are any methods that directly or indirectly affect the return value and are not fully disclosed, request their declarations first, in the following format:
<response>
  <reason><![CDATA[YOUR REASON]]></reason>
  <value>UNKNOWN</value>
  <methods>
    <method>methodName</method>
  </methods>
</response>

If additional information is required other than method declaration, list each request inside a `<request>` tag. If no additional information is needed, omit the `<requests>` section.

Respond with:
```xml
<response>
    <reason><![CDATA[YOUR REASON]]></reason>
    <value>UNKNOWN</value>
    <!-- Include <requests> only if additional information is needed -->
    <requests>
        <request><![CDATA[YOUR REQUEST 1]]></request>
        <request><![CDATA[YOUR REQUEST 2]]></request>
    </requests>
</response>
```

Additional Notes:
Be precise in your reasoning.
If a methods return value depends on another method not provided, request its declaration before making a conclusion.
If the method can return null in some cases but not others, explain under what conditions it can happen.

11:53:24.722 TRACE edu.ucr.cs.riple.core.checkers.nullaway.codefix.ChatGPT.ask
Retrieving response from cache
11:53:24.722 TRACE edu.ucr.cs.riple.core.checkers.nullaway.codefix.Response.tryCreate
Trying to create Response:
```xml
<response>
  <reason><![CDATA[The method `loop` returns the variable `gameLoop`. Without the initialization or assignment details of `gameLoop`, it's unclear whether it can be null. The possibility of `gameLoop` being uninitialized or set to null elsewhere in the program means `loop` could potentially return null. Further information on `gameLoop` is required.]]></reason>
  <value>UNKNOWN</value>
  <requests>
    <request><![CDATA[Please provide the declaration and initialization of the variable `gameLoop` in the class `de.gurkenlabs.litiengine.Game`.]]></request>
  </requests>
</response>
```
11:53:24.722 TRACE edu.ucr.cs.riple.core.checkers.nullaway.codefix.Response.<init>
Creating Response:
```xml
<response>
  <reason><![CDATA[The method `loop` returns the variable `gameLoop`. Without the initialization or assignment details of `gameLoop`, it's unclear whether it can be null. The possibility of `gameLoop` being uninitialized or set to null elsewhere in the program means `loop` could potentially return null. Further information on `gameLoop` is required.]]></reason>
  <value>UNKNOWN</value>
  <requests>
    <request><![CDATA[Please provide the declaration and initialization of the variable `gameLoop` in the class `de.gurkenlabs.litiengine.Game`.]]></request>
  </requests>
</response>
```
11:53:24.722 TRACE edu.ucr.cs.riple.core.checkers.nullaway.codefix.Response.<init>
Response created:
Unknown: The method `loop` returns the variable `gameLoop`. Without the initialization or assignment details of `gameLoop`, it's unclear whether it can be null. The possibility of `gameLoop` being uninitialized or set to null elsewhere in the program means `loop` could potentially return null. Further information on `gameLoop` is required.
11:53:24.722 TRACE edu.ucr.cs.riple.core.checkers.nullaway.codefix.AdvancedNullAwayCodeFix.investigateMethodReturnNullability
Could not determine the nullability and model did not ask for any method.
11:53:24.722 TRACE edu.ucr.cs.riple.core.checkers.nullaway.codefix.ChatGPT.checkIfMethodIsReturningNullableOnCallSite
Asking if the method is returning nullable on the call site: Game.loop()
11:53:24.962 TRACE edu.ucr.cs.riple.core.checkers.nullaway.codefix.ChatGPT.ask
Asking ChatGPT:
In the method below, is there a possibility that the method returns null at the given call site?

```java
@Nullable public static IGameLoop loop() {
    return gameLoop;
}
```

## Guidelines:
- The method may have multiple return paths; consider all return statements.
- If the method calls another method, do not assume its return value unless its full declaration is provided. Request its declaration if needed.
- The method may throw an exception instead of returning null. An exception path should not be considered a null return.
- Ensure you request the declarations of any methods whose return values directly or indirectly impact this methods return value before making a conclusion.
- If the method returns a value that is determined by a parameter, evaluate based on the actual argument at the given call site.
- Analyze based only on the specific invocation provided. Do not generalize to all possible inputs.- If the return value is guaranteed to be non-null at the call site, the answer should be a definitive NO.
- Do not generalize based on all possible inputsyour answer must be based only on the given invocation.
- Focus only on the given call site, not all possible invocations.

### call site:
Game.loop()

Here are the method definitions and the call chain for this method, showing the sequence of calls from the method to its callers at each depth level:

Depth: 0
```java
class de.gurkenlabs.litiengine.Game {
@Nullable public static IGameLoop loop() {
    return gameLoop;
}
}
```
Depth: 1
```java
class de.gurkenlabs.litiengine.environment.GameWorld {
public void loadEnvironment(@Nullable final Environment env) {
    Lock lock = Game.loop().getLock();
    lock.lock();
    try {
      unloadEnvironment();
      this.environment = env;
      if (env != null) {
        this.addEnvironment(env);

        if (env.getGravity() == 0 && this.gravity() != 0) {
          env.setGravity(this.gravity());
        }

        env.load();
        for (final EnvironmentLoadedListener listener : this.loadedListeners) {
          listener.loaded(env);
        }

        // call map specific listeners
        String mapName = getMapName(env);
        if (mapName != null && this.environmentLoadedListeners.containsKey(mapName)) {

          // for the default camera we center the camera on the environment
          if (this.camera().getClass().equals(Camera.class)) {
            camera().setFocus(env.getCenter());
          }

          for (EnvironmentLoadedListener listener : this.environmentLoadedListeners.get(mapName)) {
            listener.loaded(env);
          }
        }
      }
    } finally {
      lock.unlock();
    }
}public void setCamera(@Nullable final ICamera cam) {
    if (this.camera() != null) {
      Game.loop().detach(camera);
    }

    camera = cam;

    if (cam != null && !Game.isInNoGUIMode()) {
      Game.loop().attach(cam);
      cam.updateFocus();
    }
}
}
```
```java
class de.gurkenlabs.litiengine.entities.behavior.EntityNavigator {
public EntityNavigator(final IMobileEntity entity, final PathFinder pathFinder) {
    this.cancelNavigationConditions = new CopyOnWriteArrayList<>();
    this.listeners = new CopyOnWriteArrayList<>();
    this.entity = entity;
    this.pathFinder = pathFinder;
    this.setAcceptableError(DEFAULT_ACCEPTABLE_ERROR);
    Game.loop().attach(this);
}
}
```
```java
class de.gurkenlabs.litiengine.GameWindow {
private static void initializeWindowEventListeners(Window window) {

    window.addWindowStateListener(
        e -> {
          if (e.getNewState() == Frame.ICONIFIED) {
            Game.loop().setTickRate(ICONIFIED_MAX_FPS);
          } else {
            Game.loop().setTickRate(Game.config().client().getMaxFps());
          }
        });

    window.addWindowFocusListener(
        new WindowFocusListener() {
          @Override
          public void windowLostFocus(WindowEvent e) {
            if (Game.config().graphics().reduceFramesWhenNotFocused()) {
              Game.loop().setTickRate(NONE_FOCUS_MAX_FPS);
            }
          }

          @Override
          public void windowGainedFocus(WindowEvent e) {
            Game.loop().setTickRate(Game.config().client().getMaxFps());
          }
        });

    window.addWindowListener(
        new WindowAdapter() {
          @Override
          public void windowClosing(final WindowEvent event) {
            Game.exit();
          }
        });
}
}
```
```java
class de.gurkenlabs.litiengine.gui.screens.ScreenManager {
public void display(@Nullable final Screen screen) {
      if (Game.hasStarted() && Game.time().since(this.lastScreenChange) < this.getChangeCooldown()) {
        log.log(
            Level.INFO,
            "Skipping displaying of screen {0} because screen changing is currently on cooldown.",
            screen != null ? screen.getName() : "");
        return;
      }
  
      final Screen previous = this.current();
      if (previous != null) {
        previous.suspend();
      }
  
      if (screen != null && !this.screens.contains(screen)) {
        this.screens.add(screen);
      }
  
      this.currentScreen = screen;
      if (!Game.isInNoGUIMode() && this.current() != null) {
        this.current().prepare();
      }
  
      this.lastScreenChange = Nullability.castToNonnull(Game.loop(), "initialized before usage").getTicks();
  
      final ScreenChangedEvent event = new ScreenChangedEvent(this.current(), previous);
      for (final ScreenChangedListener listener : this.screenChangedListeners) {
        listener.changed(event);
      }
}
}
```
```java
class de.gurkenlabs.litiengine.abilities.effects.Effect {
@Override
  public void update() {

    for (final Iterator<EffectApplication> iterator = this.getActiveAppliances().iterator();
        iterator.hasNext(); ) {
      final EffectApplication appliance = iterator.next();
      // if the effect duration is reached
      if (this.hasEnded(appliance)) {

        iterator.remove();
        this.cease(appliance);
      }
    }

    // 4. unregister if all appliances are finished
    if (this.getActiveAppliances().isEmpty()) {
      Game.loop().detach(this);
    }
}public void apply(final Shape impactArea) {
    final List<ICombatEntity> affected = this.lookForAffectedEntities(impactArea);
    for (final ICombatEntity affectedEntity : affected) {
      this.apply(affectedEntity);
    }

    this.appliances.add(new EffectApplication(affected, impactArea));

    // if it is the first appliance -> register for update
    if (this.appliances.size() == 1) {
      Game.loop().attach(this);
    }
}
}
```
```java
class de.gurkenlabs.litiengine.GameTime {
public long toTicks(final int milliseconds) {
    return this.toTicks(milliseconds, Game.loop().getTickRate());
}public long since(final long tick) {
    return toMilliseconds(Game.loop().getTicks() - tick);
}public long now() {
    return Game.loop().getTicks();
}public long sinceGameStart() {
    return this.toMilliseconds(Game.loop().getTicks());
}@Override
  public void loaded(Environment environment) {
    environmentLoaded = Game.loop().getTicks();
}public long toMilliseconds(final long ticks) {
    return this.toMilliseconds(ticks, Game.loop().getTickRate());
}
}
```
```java
class de.gurkenlabs.litiengine.GameMetrics {
@Override
  public void render(final Graphics2D g) {
    this.updateMetrics();

    if (!Game.config().client().showGameMetrics()) {
      return;
    }

    this.currentOffsetY = 0;

    g.setColor(this.renderColor);

    // render client metrics
    this.drawTitle(g, "[client]");
    this.drawMetric(g, "fps       : " + this.getFramesPerSecond());
    this.drawMetric(g, "max fps   : " + this.maxFramesPerSecond);
    this.drawMetric(g, "updatables: " + Game.loop().getUpdatableCount());

    // render jvm metrics if debug is enabled
    if (Game.config().debug().isDebugEnabled()) {
      this.drawTitle(g, "[jvm]");
      this.drawMetric(g, "java      : " + this.javaVersion);
      this.drawMetric(g, "memory    : " + String.format("%-5.5s", this.usedMemory) + " MB");
      this.drawMetric(g, "threads   : " + Thread.activeCount());
    }

    // render rendering metrics
    if (!this.renderMetrics.isEmpty()) {
      this.drawTitle(g, "[update]");

      for (RenderMetrics metric : this.renderMetrics) {
        this.drawMetric(g, metric.toString());
      }

      this.renderMetrics.clear();
    }
}
}
```
```java
class de.gurkenlabs.litiengine.graphics.emitters.Emitter {
public void deactivate() {
    if (!this.activated) {
      return;
    }

    this.activated = false;
    this.getParticles().clear();
    this.aliveTime = 0;
    this.activationTick = 0;
    this.lastSpawn = 0;
    Game.loop().detach(this);
}public void activate() {
    if (this.activated) {
      return;
    }

    this.activated = true;
    this.activationTick = Game.time().now();
    Game.loop().attach(this);
}@Override
  public void update() {
    if (this.isPaused()) {
      return;
    }

    // clear particles if the effect time to life is reached
    if (this.isFinished()) {
      for (EmitterFinishedListener listener : this.finishedListeners) {
        listener.finished(this);
      }

      this.delete();
      return;
    }

    final float updateRatio = (float) this.data().getUpdateRate() / Game.loop().getTickRate();
    for (final Particle p : this.getParticles().stream().collect(Collectors.toList())) {
      if (this.particleCanBeRemoved(p)) {
        // remove dead particles
        this.particles.remove(p);
        continue;
      }

      p.update(this.getOrigin(), updateRatio);
    }

    this.aliveTime = Game.time().since(this.activationTick);
    if ((this.data().getSpawnRate() == 0
        || Game.time().since(this.lastSpawn) >= this.data().getSpawnRate())) {
      this.lastSpawn = Game.time().now();
      this.spawnParticle();
    }
}
}
```
```java
class de.gurkenlabs.litiengine.entities.behavior.IBehaviorController {
public default void attach() {
    Game.loop().attach(this);
}public default void detach() {
    Game.loop().detach(this);
}
}
```
```java
class de.gurkenlabs.litiengine.abilities.AbilityExecution {
AbilityExecution(final Ability ability) {
    this.appliedEffects = new CopyOnWriteArrayList<>();
    this.ability = ability;
    this.executionTicks = Game.time().now();
    this.impactArea = ability.calculateImpactArea();
    this.castLocation = ability.getExecutor().getCenter();
    Game.loop().attach(this);
}@Override
  public void update() {
    // if there a no effects to apply -> unregister this instance and we're done
    if (this.getAbility().getEffects().isEmpty()
        || this.getAbility().getEffects().size() == this.getAppliedEffects().size()) {
      Game.loop().detach(this);
      return;
    }

    // handle all effects from the ability that were not applied yet
    for (final Effect effect : this.getAbility().getEffects()) {
      // if the ability was not executed yet or the delay of the effect is not
      // yet reached
      if (this.getAppliedEffects().contains(effect)
          || Game.time().since(this.getExecutionTicks()) < effect.getDelay()) {
        continue;
      }

      effect.apply(this.getExecutionImpactArea());
      this.getAppliedEffects().add(effect);
    }
}
}
```
```java
class de.gurkenlabs.litiengine.GameWindow$3 {
@Override
          public void windowGainedFocus(WindowEvent e) {
            Game.loop().setTickRate(Game.config().client().getMaxFps());
}@Override
          public void windowLostFocus(WindowEvent e) {
            if (Game.config().graphics().reduceFramesWhenNotFocused()) {
              Game.loop().setTickRate(NONE_FOCUS_MAX_FPS);
            }
}
}
```
```java
class de.gurkenlabs.litiengine.environment.EntitySpawner {
protected void spawnNewEntities() {
    if (this.getSpawnMode() != SpawnMode.CUSTOMSPAWNPOINTS && this.getSpawnPoints().isEmpty()) {
      return;
    }

    switch (this.getSpawnMode()) {
      case ALLSPAWNPOINTS:
        for (int i = 0; i < this.getSpawnPoints().size(); i++) {
          final int index = i;
          Game.loop()
              .perform(
                  this.getSpawnDelay() + this.getSpawnDelay() * i,
                  () -> this.spawn(this.getSpawnPoints().get(index), this.getSpawnAmount()));
        }
        break;
      case ONERANDOMSPAWNPOINT:
        this.spawn(Game.random().choose(this.getSpawnPoints()), this.getSpawnAmount());
        break;
      case RANDOMSPAWNPOINTS:
        for (int i = 0; i < this.getSpawnAmount(); i++) {
          Game.loop()
              .perform(
                  this.getSpawnDelay() + this.getSpawnDelay() * i,
                  () -> this.spawn(Game.random().choose(this.getSpawnPoints()), 1));
        }
        break;
      case CUSTOMSPAWNPOINTS:
        List<Spawnpoint> spawnPoints =
            this.customSpawnpoints != null
                ? this.customSpawnpoints.apply(this)
                : this.getCustomSpawnpoints();

        int index = 0;
        for (Spawnpoint spawn : spawnPoints) {
          Game.loop()
              .perform(
                  this.getSpawnDelay() + this.getSpawnDelay() * index, () -> this.spawn(spawn, 1));
          index++;
        }
        break;
      default:
        break;
    }
}
}
```
```java
class de.gurkenlabs.litiengine.tweening.TweenEngine {
@Override
  public void start() {
    Game.loop().attach(this);
}@Override
  public void terminate() {
    Game.loop().detach(this);
}
}
```
```java
class de.gurkenlabs.litiengine.gui.SpeechBubble {
public void hide() {
    Game.world().environment().removeRenderable(this);
    Game.loop().detach(this);
    if (activeSpeechBubbles.get(this.getEntity()) != null
        && activeSpeechBubbles.remove(this.getEntity()).equals(this)) {
      activeSpeechBubbles.remove(this.getEntity());
    }

    for (SpeechBubbleListener listener : this.listeners) {
      listener.hidden();
    }
}private SpeechBubble(
      final IEntity entity,
      final String text,
      @Nullable SpeechBubbleAppearance appearance,
      @Nullable Font font) {
    if (appearance == null) {
      this.appearance = DEFAULT_APPEARANCE;
    } else {
      this.appearance = appearance;
    }

    final SpeechBubble active = activeSpeechBubbles.get(entity);
    if (active != null) {
      active.hide();
    }
    this.setFont(font);

    this.textBoxWidth = (float) (entity.getWidth() * 4);
    this.entity = entity;

    this.currentText = text;
    this.currentTextDisplayTime = DISPLAYTIME_MIN + text.length() * DISPLAYTIME_PER_LETTER;

    this.lastTextDisplay = Game.time().now();
    this.createBubbleImage();
    entity.getEnvironment().add(this, RenderType.UI);
    Game.loop().attach(this);
    activeSpeechBubbles.put(entity, this);
}
}
```
```java
class de.gurkenlabs.litiengine.entities.Prop {
private void updateAnimationController() {
    IEntityAnimationController<?> controller = this.createAnimationController();
    this.getControllers().addController(controller);
    if (Game.world().environment() != null && Game.world().environment().isLoaded()) {
      Game.loop().attach(controller);
    }
}
}
```
```java
class de.gurkenlabs.litiengine.graphics.FreeFlightCamera {
public FreeFlightCamera(final Point2D focus) {
    this.setFocus(focus);
    this.velocity = DEFAULT_SCROLL_PIXELS_PER_SECOND;
    this.scrollPadding = DEFAULT_SCROLL_PADDING;
    this.setClampToMap(true);

    Game.loop().attach(this);
}private void handleFreeFlightCamera() {
      if (Game.world().environment() == null || Game.world().environment().getMap() == null) {
        return;
      }
  
      final Point2D mouseLocation = Input.mouse().getLocation();
  
      final double scrollSpeed =
          this.getVelocity()
              / (double) Nullability.castToNonnull(Game.loop(), "gameLoop always initialized")
                  .getTickRate()
              * Game.config().input().getMouseSensitivity();
  
      double x = this.getFocus().getX();
      double y = this.getFocus().getY();
  
      double deltaX = 0;
      if (mouseLocation.getX() < this.getScrollPadding()) {
        deltaX -= scrollSpeed;
      } else if (Game.window().getResolution().getWidth() - mouseLocation.getX()
          < this.getScrollPadding()) {
        deltaX += scrollSpeed;
      }
  
      double deltaY = 0;
      if (mouseLocation.getY() < this.getScrollPadding()) {
        deltaY -= scrollSpeed;
      } else if (Game.window().getResolution().getHeight() - mouseLocation.getY()
          < this.getScrollPadding()) {
        deltaY += scrollSpeed;
      }
  
      x += deltaX;
      y += deltaY;
  
      this.setFocus(new Point2D.Double(x, y));
}
}
```
```java
class de.gurkenlabs.litiengine.environment.Environment {
private static void dispose(final Collection<? extends IEntity> entities) {
    for (final IEntity entity : entities) {
      if (entity instanceof IUpdateable) {
        Game.loop().detach((IUpdateable) entity);
      }

      entity.detachControllers();
    }
}private static void loadUpdatableOrEmitterEntity(IEntity entity) {
      if (entity instanceof Emitter) {
        final Emitter emitter = (Emitter) entity;
        if (emitter.isActivateOnInit()) {
          emitter.activate();
        }
      } else if (entity instanceof IUpdateable) {
        Nullability.castToNonnull(Game.loop(), "initialized through init").attach((IUpdateable) entity);
      }
}private void unload(final IEntity entity) {
    // 1. remove from physics engine
    if (entity instanceof ICollisionEntity) {
      Game.physics().remove((ICollisionEntity) entity);
    }

    // 2. unregister from update
    if (entity instanceof IUpdateable) {
      Game.loop().detach((IUpdateable) entity);
    }

    if (entity instanceof IMobileEntity) {
      this.removeGravity((IMobileEntity) entity);
    }

    // 3. detach all controllers
    entity.detachControllers();

    if (entity instanceof Emitter) {
      Emitter em = (Emitter) entity;
      em.deactivate();
    }

    if (this.loaded && (entity instanceof LightSource || entity instanceof StaticShadow)) {
      this.updateLighting(entity);
    }

    entity.removed(this);
}
}
```
```java
class de.gurkenlabs.litiengine.graphics.animation.Animation {
@Override
  public void update() {
    // do nothing if the animation is not playing or the current keyframe is not finished
    if (!this.isPlaying()
        || Game.time().since(this.lastFrameUpdate) < this.getCurrentKeyFrame().getDuration()) {
      return;
    }

    // if we are not looping and the last keyframe is finished, we terminate the animation
    if (!this.isLooping() && this.isLastKeyFrame()) {
      this.terminate();
      return;
    }

    // make sure, we stay inside the keyframe list
    final int newFrameIndex =
        (this.getKeyframes().indexOf(this.currentFrame) + 1) % this.getKeyframes().size();
    final KeyFrame previousFrame = this.currentFrame;
    this.currentFrame = this.getKeyframes().get(newFrameIndex);

    for (KeyFrameListener listener : this.listeners) {
      listener.currentFrameChanged(previousFrame, this.currentFrame);
    }

    this.lastFrameUpdate = Game.loop().getTicks();
}public void restart() {
    this.currentFrame = this.firstFrame;
    this.lastFrameUpdate = Game.loop().getTicks();
}
}
```
```java
class de.gurkenlabs.litiengine.physics.MovementController {
@Override
  public void attach() {
    Game.loop().attach(this);
}private void handleForces() {
    // clean up forces
    this.activeForces.forEach(
        x -> {
          if (x.hasEnded()) {
            this.activeForces.remove(x);
          }
        });

    if (this.activeForces.isEmpty()) {
      return;
    }

    // disable turn-on-move for force handling
    boolean turn = this.getEntity().turnOnMove();
    this.getEntity().setTurnOnMove(false);
    try {
      double deltaX = 0;
      double deltaY = 0;
      for (final Force force : this.activeForces) {
        if (force.cancelOnReached() && force.hasReached(this.getEntity())) {
          force.end();
          continue;
        }

        final Point2D collisionBoxCenter = this.getEntity().getCollisionBoxCenter();
        final double angle =
            GeometricUtilities.calcRotationAngleInDegrees(collisionBoxCenter, force.getLocation());
        final double strength =
            Game.loop().getDeltaTime() * 0.001f * force.getStrength() * Game.loop().getTimeScale();
        deltaX += GeometricUtilities.getDeltaX(angle, strength);
        deltaY += GeometricUtilities.getDeltaY(angle, strength);
      }

      final Point2D target =
          new Point2D.Double(this.getEntity().getX() + deltaX, this.getEntity().getY() + deltaY);
      final boolean success = Game.physics().move(this.getEntity(), target);
      if (!success) {
        for (final Force force : this.activeForces) {
          if (force.cancelOnCollision()) {
            force.end();
          }
        }
      }
    } finally {
      this.getEntity().setTurnOnMove(turn);
    }
}@Override
  public void detach() {
    Game.loop().detach(this);
}public void handleMovement() {
    if (!this.isMovementAllowed()) {
      this.velocity = 0;
      return;
    }

    // max distance an entity can travel within one tick
    final double maxPixelsPerTick = this.getEntity().getTickVelocity();
    final double deltaTime = Game.loop().getDeltaTime() * Game.loop().getTimeScale();

    final double acceleration =
        this.getEntity().getAcceleration() == 0
            ? maxPixelsPerTick
            : deltaTime / this.getEntity().getAcceleration() * maxPixelsPerTick;
    final double deceleration =
        this.getEntity().getDeceleration() == 0
            ? this.getVelocity()
            : deltaTime / this.getEntity().getDeceleration() * maxPixelsPerTick;

    double dx = this.getDx();
    double dy = this.getDy();
    this.setDx(0);
    this.setDy(0);

    final double deltaVelocity =
        Math.min(Math.sqrt(Math.pow(dx, 2) + Math.pow(dy, 2)), acceleration);
    if (deltaVelocity != 0) {
      double newVelocity = this.getVelocity() + deltaVelocity;
      this.setVelocity(newVelocity);
    } else {
      final double newVelocity = Math.max(0, this.getVelocity() - deceleration);
      this.setVelocity(newVelocity);
      dx = GeometricUtilities.getDeltaX(this.moveAngle);
      dy = GeometricUtilities.getDeltaY(this.moveAngle);
    }

    if (this.getVelocity() == 0) {
      this.moveAngle = 0;
      return;
    }

    // actually move entity
    this.moveEntity(dx, dy);
}
}
```
```java
class de.gurkenlabs.litiengine.graphics.animation.AnimationController {
public void detach() {
    Game.loop().detach(this);
}public void attach() {
    Game.loop().attach(this);
}
}
```
```java
class de.gurkenlabs.litiengine.graphics.Camera {
@Override
  public void setZoom(final float targetZoom, final int delay) {
    if (delay == 0) {

      this.zoom = targetZoom;
      this.targetZoom = 0;
      this.zoomDelay = 0;
      this.zoomTick = 0;
      this.zoomStep = 0;

      final ZoomChangedEvent event = new ZoomChangedEvent(this, targetZoom);
      for (final ZoomChangedListener listener : this.zoomListeners) {
        listener.zoomChanged(event);
      }
    } else {
      this.zoomTick = Game.time().now();
      this.targetZoom = targetZoom;
      this.zoomDelay = delay;

      final double tickduration = 1000 / (double) Game.loop().getTickRate();
      final double tickAmount = delay / tickduration;
      final float totalDelta = this.targetZoom - this.zoom;
      this.zoomStep = tickAmount > 0 ? (float) (totalDelta / tickAmount) : totalDelta;
    }
}
}
```
```java
class de.gurkenlabs.litiengine.Game {
public static synchronized void init(String... args) {
    if (initialized) {
      log().log(Level.INFO, "The game has already been initialized.");
      return;
    }

    log.init();
    handleCommandLineArguments(args);

    config().load();
    Locale.setDefault(new Locale(config().client().getCountry(), config().client().getLanguage()));

    gameLoop = new GameLoop("Main Update Loop", config().client().getMaxFps());
    loop().attach(physics());
    loop().attach(world());

    // setup default exception handling for render and update loop
    setUncaughtExceptionHandler(
        new DefaultUncaughtExceptionHandler(config().client().exitOnError()));

    screenManager = new ScreenManager();
    gameWindow = new GameWindow();

    // initialize  the game window
    window().init();
    world.setCamera(new Camera());

    for (GameListener listener : gameListeners) {
      listener.initialized(args);
    }

    if (!isInNoGUIMode()) {
      window().getRenderComponent().onRendered(g -> metrics().render(g));

      graphics()
          .addEntityRenderedListener(
              e -> DebugRenderer.renderEntityDebugInfo(e.getGraphics(), e.getEntity()));

      window().getRenderComponent().onFpsChanged(fps -> metrics().setFramesPerSecond(fps));
      window()
          .setIcons(
              Arrays.asList(
                  Resources.images().get("liti-logo-x16.png"),
                  Resources.images().get("liti-logo-x20.png"),
                  Resources.images().get("liti-logo-x32.png"),
                  Resources.images().get("liti-logo-x48.png")));

      Input.keyboard()
          .onKeyTyped(
              KeyEvent.VK_PRINTSCREEN,
              key -> {
                // don't take a screenshot if a modifier is active
                if (key.getModifiers() != 0) {
                  return;
                }

                window().getRenderComponent().takeScreenshot();
              });
    }

    Runtime.getRuntime().addShutdownHook(new Thread(Game::terminate, "Shutdown"));

    initialized = true;
}
}
```
```java
class de.gurkenlabs.litiengine.entities.Creature {
protected void updateAnimationController() {
        IEntityAnimationController<?> controller = this.createAnimationController();
        this.getControllers().addController(controller);
        if (Game.world().environment() != null && Game.world().environment().isLoaded()) {
            Nullability.castToNonnull(Game.loop(), "expected to be non-null").attach(controller);
        }
}@Override
  public float getTickVelocity() {
    // pixels per ms multiplied by the passed ms
    // ensure that entities don't travel too far in case of lag
    return Math.min(Game.loop().getDeltaTime(), GameLoop.TICK_DELTATIME_LAG)
        * 0.001F
        * this.getVelocity().get()
        * Game.loop().getTimeScale();
}
}
```
Depth: 2
```java
class de.gurkenlabs.litiengine.environment.GameWorld {
public void clear() {
    this.unloadEnvironment();
    this.environments.clear();
    this.setCamera(null);
    Game.physics().clear();

    this.environmentListeners.clear();
    this.environmentLoadedListeners.clear();
    this.environmentUnloadedListeners.clear();

    this.listeners.clear();
    this.loadedListeners.clear();
    this.unloadedListeners.clear();
}@Nullable
  public Environment loadEnvironment(IMap map) {
    Environment env = this.getEnvironment(map);
    this.loadEnvironment(env);
    return env;
}@Nullable
  public Environment loadEnvironment(String mapName) {
    Environment env = this.getEnvironment(mapName);
    this.loadEnvironment(env);
    return env;
}
}
```
```java
class de.gurkenlabs.litiengine.GameWindow {
GameWindow() {
    this.hostControl = new JFrame();

    this.resolutionChangedListeners = new CopyOnWriteArrayList<>();

    this.renderCanvas = new RenderComponent(Game.config().graphics().getResolution());
    this.cursor = new MouseCursor();
    if (!Game.isInNoGUIMode()) {
      this.hostControl.setBackground(Color.BLACK);
      this.hostControl.add(this.renderCanvas);

      this.initializeEventListeners();

      this.hostControl.setTitle(Game.info().getTitle());
      this.hostControl.setDefaultCloseOperation(WindowConstants.DO_NOTHING_ON_CLOSE);
      initializeWindowEventListeners(this.hostControl);
    }
}
}
```
```java
class de.gurkenlabs.litiengine.GameTime {
public long sinceEnvironmentLoad() {
    return this.since(this.environmentLoaded);
}public long since(final long tick) {
    return toMilliseconds(Game.loop().getTicks() - tick);
}public long sinceGameStart() {
    return this.toMilliseconds(Game.loop().getTicks());
}
}
```
```java
class de.gurkenlabs.litiengine.abilities.effects.Effect {
protected void cease(final EffectApplication appliance) {
    // 1. cease the effect for all affected entities
    for (final ICombatEntity entity : appliance.getAffectedEntities()) {
      this.cease(entity);
    }

    // 2. apply follow up effects
    this.getFollowUpEffects().forEach(followUp -> followUp.apply(appliance.getImpactArea()));
}protected boolean hasEnded(final EffectApplication appliance) {
    final long effectDuration = Game.time().since(appliance.getAppliedTicks());
    return effectDuration > this.getDuration();
}
}
```
```java
class de.gurkenlabs.litiengine.abilities.effects.EffectApplication {
protected EffectApplication(final List<ICombatEntity> affectedEntities, final Shape impactArea) {
    this.applied = Game.time().now();
    this.affectedEntities = affectedEntities;
    this.impactArea = impactArea;
}
}
```
```java
class de.gurkenlabs.litiengine.entities.CombatEntity {
@Override
  public boolean wasHit(int timeSpan) {
    return Game.time().since(this.lastHit) < timeSpan;
}@Override
  public void hit(final int damage, @Nullable final Ability ability) {
    if (this.isDead()) {
      return;
    }

    if (!this.isIndestructible()) {
      this.getHitPoints().modifyBaseValue(new AttributeModifier<>(Modification.SUBTRACT, damage));
    }

    final EntityHitEvent event = new EntityHitEvent(this, ability, damage, this.isDead());

    for (final CombatEntityListener listener : this.listeners) {
      listener.hit(event);
    }

    for (final CombatEntityHitListener listener : this.hitListeners) {
      listener.hit(event);
    }

    if (this.isDead()) {
      this.fireDeathEvent();
      this.setCollision(false);
    }

    this.lastHit = Game.time().now();
}
}
```
```java
class de.gurkenlabs.litiengine.graphics.ImageEffect {
protected ImageEffect(final int ttl, final String name) {
    this.ttl = ttl;
    this.name = name;
    this.aliveTick = Game.time().now();
}@Override
  public long getAliveTime() {
    return Game.time().since(this.aliveTick);
}
}
```
```java
class de.gurkenlabs.litiengine.abilities.AbilityExecution {
AbilityExecution(final Ability ability) {
    this.appliedEffects = new CopyOnWriteArrayList<>();
    this.ability = ability;
    this.executionTicks = Game.time().now();
    this.impactArea = ability.calculateImpactArea();
    this.castLocation = ability.getExecutor().getCenter();
    Game.loop().attach(this);
}@Override
  public void update() {
    // if there a no effects to apply -> unregister this instance and we're done
    if (this.getAbility().getEffects().isEmpty()
        || this.getAbility().getEffects().size() == this.getAppliedEffects().size()) {
      Game.loop().detach(this);
      return;
    }

    // handle all effects from the ability that were not applied yet
    for (final Effect effect : this.getAbility().getEffects()) {
      // if the ability was not executed yet or the delay of the effect is not
      // yet reached
      if (this.getAppliedEffects().contains(effect)
          || Game.time().since(this.getExecutionTicks()) < effect.getDelay()) {
        continue;
      }

      effect.apply(this.getExecutionImpactArea());
      this.getAppliedEffects().add(effect);
    }
}
}
```
```java
class de.gurkenlabs.litiengine.tweening.TweenEngine {
@Override
  public void update() {
    for (final Tweenable target : this.getTweens().keySet()) {
      for (final Tween tween : this.getTweens().get(target).values()) {
        if (tween.hasStopped()) {
          continue;
        }
        final long elapsed = Game.time().since(tween.getStartTime());
        if (elapsed >= tween.getDuration()) {
          tween.stop();
          continue;
        }
        final float[] currentValues = new float[tween.getTargetValues().length];
        for (int i = 0; i < tween.getTargetValues().length; i++) {
          currentValues[i] =
              tween.getStartValues()[i]
                  + tween.getEquation().compute(elapsed / (float) tween.getDuration())
                      * (tween.getTargetValues()[i] - tween.getStartValues()[i]);
        }
        tween.getTarget().setTweenValues(tween.getType(), currentValues);
      }
    }
}
}
```
```java
class de.gurkenlabs.litiengine.gui.SpeechBubble {
public static SpeechBubble create(
      final IEntity entity, final String text, SpeechBubbleAppearance appearance, Font font) {
    return new SpeechBubble(entity, text, appearance, font);
}public static SpeechBubble create(final IEntity entity, final Font font, final String text) {
    SpeechBubbleAppearance app =
        new SpeechBubbleAppearance(
            DEFAULT_APPEARANCE.getForeColor(),
            DEFAULT_APPEARANCE.getBackgroundColor1(),
            DEFAULT_APPEARANCE.getBorderColor(),
            DEFAULT_APPEARANCE.getPadding());
    return new SpeechBubble(entity, text, app, font);
}public static SpeechBubble create(final IEntity entity, final String text) {
    return new SpeechBubble(entity, text, null, GuiProperties.getDefaultFont());
}@Override
  public void update() {
    if (this.currentText == null) {
      this.hide();
      return;
    }

    this.entityCenter = Game.world().camera().getViewportLocation(this.getEntity().getCenter());

    // old text was displayed long enough
    if (this.lastTextDisplay != 0
        && Game.time().since(this.lastTextDisplay) > this.currentTextDisplayTime) {
      this.currentText = null;
      this.lastTextDisplay = 0;
      return;
    }

    // display new text
    if (this.textIndex < this.currentText.length()
        && Game.time().since(this.lastCharPoll) > LETTER_WRITE_DELAY) {
      this.textIndex++;
      this.lastCharPoll = Game.time().now();
      if (this.typeSound != null) {
        Game.audio().playSound(this.typeSound, this.getEntity());
      }
    }

    // continue displaying currently displayed text
}private SpeechBubble(
      final IEntity entity,
      final String text,
      final Sound typeSound,
      SpeechBubbleAppearance appearance,
      Font font) {
    this(entity, text, appearance, font);
    this.typeSound = typeSound;
}private SpeechBubble(
      final IEntity entity,
      final String text,
      @Nullable SpeechBubbleAppearance appearance,
      @Nullable Font font) {
    if (appearance == null) {
      this.appearance = DEFAULT_APPEARANCE;
    } else {
      this.appearance = appearance;
    }

    final SpeechBubble active = activeSpeechBubbles.get(entity);
    if (active != null) {
      active.hide();
    }
    this.setFont(font);

    this.textBoxWidth = (float) (entity.getWidth() * 4);
    this.entity = entity;

    this.currentText = text;
    this.currentTextDisplayTime = DISPLAYTIME_MIN + text.length() * DISPLAYTIME_PER_LETTER;

    this.lastTextDisplay = Game.time().now();
    this.createBubbleImage();
    entity.getEnvironment().add(this, RenderType.UI);
    Game.loop().attach(this);
    activeSpeechBubbles.put(entity, this);
}
}
```
```java
class de.gurkenlabs.litiengine.gui.TextFieldComponent {
@Override
  public void render(final Graphics2D g) {
    super.render(g);
    g.setFont(this.getFont());
    final FontMetrics fm = g.getFontMetrics();

    if (this.isSelected() && Game.time().since(this.lastToggled) > this.flickerDelay) {
      this.cursorVisible = !this.cursorVisible;
      this.lastToggled = Game.time().now();
    }
    if (this.isSelected() && this.cursorVisible) {
      final Rectangle2D cursor =
          new Rectangle2D.Double(
              this.getX() + this.getTextX() + fm.stringWidth(this.getTextToRender(g)),
              this.getY() + this.getTextY(),
              this.getFont().getSize2D() * 3 / 5,
              this.getFont().getSize2D() * 1 / 5);
      g.setColor(this.getAppearance().getForeColor());
      g.fill(cursor);
    }
}
}
```
```java
class de.gurkenlabs.litiengine.entities.Prop {
public Prop(
      final Point2D location, @Nullable final String spritesheetName, final Material material) {
    super();
    this.rotation = Rotation.NONE;
    this.spritesheetName = spritesheetName;
    this.material = material;
    this.setLocation(location);
    this.updateAnimationController();
}public void setSpritesheetName(@Nullable final String spriteName) {
    this.spritesheetName = spriteName;
    this.updateAnimationController();
}
}
```
```java
class de.gurkenlabs.litiengine.tweening.Tween {
public Tween begin() {
    this.started = Game.time().now();
    this.stopped = false;
    return this;
}
}
```
```java
class de.gurkenlabs.litiengine.graphics.emitters.particles.Particle {
public void update(final Point2D emitterOrigin, final float updateRatio) {
    if (this.aliveTick == 0) {
      this.aliveTick = Game.time().now();
    }

    this.aliveTime = Game.time().since(this.aliveTick);
    if (this.timeToLiveReached()) {
      return;
    }

    if (this.colliding) {
      return;
    }

    if (this.getDeltaWidth() != 0) {
      this.width += this.getDeltaWidth() * updateRatio;
    }

    if (this.getDeltaHeight() != 0) {
      this.height += this.getDeltaHeight() * updateRatio;
    }

    if (this.getDeltaAngle() != 0) {
      this.angle += this.getDeltaAngle() * updateRatio;
    }

    // test for ray cast collision
    final float targetX = this.x + this.getVelocityX() * updateRatio;
    final float targetY = this.y + this.getVelocityY() * updateRatio;

    if (targetX == this.x && targetY == this.y) {
      return;
    }

    if (this.checkForCollision(emitterOrigin, targetX, targetY)) {
      return;
    }

    if (this.getVelocityX() != 0) {
      this.x = targetX;
    }

    if (this.getVelocityY() != 0) {
      this.y = targetY;
    }

    if (this.getAccelerationX() != 0) {
      this.velocityX += this.getAccelerationX() * updateRatio;
    }

    if (this.getAccelerationY() != 0) {
      this.velocityY += this.getAccelerationY() * updateRatio;
    }
}
}
```
```java
class de.gurkenlabs.litiengine.graphics.animation.Animation {
@Override
  public void start() {
    this.playing = true;
    if (this.getKeyframes().isEmpty()) {
      return;
    }

    this.restart();
}@Override
  public void update() {
    // do nothing if the animation is not playing or the current keyframe is not finished
    if (!this.isPlaying()
        || Game.time().since(this.lastFrameUpdate) < this.getCurrentKeyFrame().getDuration()) {
      return;
    }

    // if we are not looping and the last keyframe is finished, we terminate the animation
    if (!this.isLooping() && this.isLastKeyFrame()) {
      this.terminate();
      return;
    }

    // make sure, we stay inside the keyframe list
    final int newFrameIndex =
        (this.getKeyframes().indexOf(this.currentFrame) + 1) % this.getKeyframes().size();
    final KeyFrame previousFrame = this.currentFrame;
    this.currentFrame = this.getKeyframes().get(newFrameIndex);

    for (KeyFrameListener listener : this.listeners) {
      listener.currentFrameChanged(previousFrame, this.currentFrame);
    }

    this.lastFrameUpdate = Game.loop().getTicks();
}
}
```
```java
class de.gurkenlabs.litiengine.graphics.animation.AnimationController {
@Override
  public void update() {
    for (final Animation animation : this.getAll()) {
      animation.update();
    }

    if (this.getCurrent() != null && this.getCurrent().isPaused()) {
      return;
    }

    final boolean playbackFinished = this.getCurrent() != null && !this.getCurrent().isPlaying();
    if (playbackFinished) {
      for (final AnimationListener listener : this.listeners) {
        listener.finished(this.getCurrent());
      }
    }

    if (this.getCurrent() == null || playbackFinished) {
      if (this.getDefault() != null) {
        this.play(this.getDefault().getName());
      } else {
        this.currentAnimation = null;
      }
    }
}
}
```
```java
class de.gurkenlabs.litiengine.graphics.RenderComponent {
private void handleFade() {
    if (this.fadeOutStart != -1) {
      final long timePassed = Game.time().since(this.fadeOutStart);
      this.currentAlpha = MathUtilities.clamp(1 - timePassed / (float) this.fadeOutTime, 0, 1);
      if (this.currentAlpha == 0f) {
        this.fadeOutStart = -1;
        this.fadeOutTime = -1;
      }

      return;
    }

    if (this.fadeInStart != -1) {
      final long timePassed = Game.time().since(this.fadeInStart);
      this.currentAlpha = MathUtilities.clamp(timePassed / (float) this.fadeInTime, 0, 1);
      if (this.currentAlpha == 1f) {
        this.fadeInStart = -1;
        this.fadeInTime = -1;
        this.currentAlpha = Float.NaN;
      }
    }
}public void fadeOut(final int ms) {
    this.fadeInStart = -1;
    this.fadeInTime = -1;
    this.fadeOutStart = Game.time().now();
    this.fadeOutTime = ms;
}public void fadeIn(final int ms) {
    this.fadeOutStart = -1;
    this.fadeOutTime = -1;
    this.fadeInStart = Game.time().now();
    this.fadeInTime = ms;
}
}
```
```java
class de.gurkenlabs.litiengine.entities.Trigger {
private boolean activate(final IEntity activator, final int tar) {
    if (!this.isLoaded()
        || this.isOneTimeTrigger && this.isActivated
        || this.getActivationType() == TriggerActivation.COLLISION
            && activator != null
            && this.collisionActivated.contains(activator)) {
      return false;
    }

    if (this.getCooldown() > 0 && Game.time().since(this.lastActivation) < this.getCooldown()) {
      return false;
    }

    List<Integer> triggerTargets = this.getTargets(tar);

    final TriggerEvent te = new TriggerEvent(this, activator, triggerTargets);

    if (!this.checkActivationPredicates(te)) {
      return false;
    }

    this.isActivated = true;
    if (activator != null) {
      this.collisionActivated.add(activator);
    }

    // if we actually have a trigger target, we send the message to the target
    for (final int target : triggerTargets) {
      final IEntity entity = this.getEnvironment().get(target);
      if (entity == null) {
        log.log(
            Level.WARNING,
            "trigger [{0}] was activated, but the trigger target [{1}] could not be found on the environment",
            new Object[] {this, target});
        continue;
      }

      entity.sendMessage(this, this.message);
    }

    // also send the trigger event to all registered consumers
    for (final TriggerActivatedListener listener : this.activatedListeners) {
      listener.activated(te);
    }

    if (this.isOneTimeTrigger) {
      this.getEnvironment().remove(this);
    }

    this.lastActivation = Game.time().now();
    return true;
}
}
```
```java
class de.gurkenlabs.litiengine.graphics.Camera {
private boolean isShakeEffectActive() {
    return this.getShakeTick() != 0
        && Game.time().since(this.getShakeTick()) < this.getShakeDuration();
}@Override
  public void update() {
    if (Game.world().camera() != null && !Game.world().camera().equals(this)) {
      return;
    }

    if (this.targetZoom > 0) {
      if (Game.time().since(this.zoomTick) >= this.zoomDelay) {
        this.zoom = this.targetZoom;
        this.targetZoom = 0;
        this.zoomDelay = 0;
        this.zoomTick = 0;
        this.zoomStep = 0;
      } else {
        this.zoom += this.zoomStep;
      }

      final ZoomChangedEvent event = new ZoomChangedEvent(this, this.getZoom());
      for (final ZoomChangedListener listener : this.zoomListeners) {
        listener.zoomChanged(event);
      }
    }

    if (this.panTime > 0) {
      if (--this.panTime <= 0) {
        this.setFocus(this.targetFocus);
        this.targetFocus = null;
      } else {
        double diff = this.panTime / (this.panTime + 1.0);
        this.focus =
            new Point2D.Double(
                this.focus.getX() * diff + this.targetFocus.getX() * (1.0 - diff),
                this.focus.getY() * diff + this.targetFocus.getY() * (1.0 - diff));
      }
    }

    if (!this.isShakeEffectActive()) {
      this.shakeOffsetX = 0;
      this.shakeOffsetY = 0;
      return;
    }

    if (Game.time().since(this.lastShake) > this.shakeDelay) {
      this.shakeOffsetX = this.getShakeIntensity() * ThreadLocalRandom.current().nextGaussian();
      this.shakeOffsetY = this.getShakeIntensity() * ThreadLocalRandom.current().nextGaussian();
      this.lastShake = Game.time().now();
    }
}@Override
  public void setZoom(final float targetZoom, final int delay) {
    if (delay == 0) {

      this.zoom = targetZoom;
      this.targetZoom = 0;
      this.zoomDelay = 0;
      this.zoomTick = 0;
      this.zoomStep = 0;

      final ZoomChangedEvent event = new ZoomChangedEvent(this, targetZoom);
      for (final ZoomChangedListener listener : this.zoomListeners) {
        listener.zoomChanged(event);
      }
    } else {
      this.zoomTick = Game.time().now();
      this.targetZoom = targetZoom;
      this.zoomDelay = delay;

      final double tickduration = 1000 / (double) Game.loop().getTickRate();
      final double tickAmount = delay / tickduration;
      final float totalDelta = this.targetZoom - this.zoom;
      this.zoomStep = tickAmount > 0 ? (float) (totalDelta / tickAmount) : totalDelta;
    }
}@Override
  public void shake(final double intensity, final int delay, final int shakeDuration) {
    this.shakeTick = Game.time().now();
    this.shakeDelay = delay;
    this.shakeIntensity = intensity;
    this.shakeDuration = shakeDuration;
}
}
```
```java
class de.gurkenlabs.litiengine.entities.Creature {
public void setSpritesheetName(String spritesheetName) {
    if (this.spritesheetName != null && this.spritesheetName.equals(spritesheetName)) {
      return;
    }

    this.spritesheetName = spritesheetName;
    this.updateAnimationController();
}public boolean isIdle() {
    return Game.time().since(this.lastMoved) > IDLE_DELAY;
}@Override
  public void setLocation(final Point2D position) {
    if (this.isDead() || position == null) {
      return;
    }

    final Point2D oldLocation = this.getLocation();
    super.setLocation(position);

    if (Game.hasStarted() && this.isLoaded()) {
      this.lastMoved = Game.time().now();
      this.fireMovedEvent(
          new EntityMovedEvent(
              this, this.getX() - oldLocation.getX(), this.getY() - oldLocation.getY()));
    }
}
}
```
```java
class de.gurkenlabs.litiengine.gui.screens.ScreenManager {
public void display(final String screenName) {
    if (this.current() != null && this.current().getName().equalsIgnoreCase(screenName)) {
      log.log(
          Level.INFO,
          "Skipping displaying of screen {0} because it is already the current screen.",
          screenName);
      return;
    }

    if (this.screens.stream()
        .noneMatch(element -> element.getName().equalsIgnoreCase(screenName))) {
      log.log(
          Level.WARNING,
          "Could not display the screen {0} because there is no screen with the specified name.",
          screenName);
      return;
    }

    Screen screen = this.get(screenName);
    if (screen == null) {
      return;
    }

    this.display(screen);
}public void add(final Screen screen) {
    screen.setWidth(Game.window().getWidth());
    screen.setHeight(Game.window().getHeight());
    this.screens.add(screen);

    if (this.current() == null) {
      this.display(screen);
    }
}public void remove(Screen screen) {
    this.screens.remove(screen);
    if (this.current() == screen) {
      if (!this.screens.isEmpty()) {
        this.display(this.screens.get(0));
      } else {
        this.display((Screen) null);
      }
    }
}public void display(@Nullable final Screen screen) {
      if (Game.hasStarted() && Game.time().since(this.lastScreenChange) < this.getChangeCooldown()) {
        log.log(
            Level.INFO,
            "Skipping displaying of screen {0} because screen changing is currently on cooldown.",
            screen != null ? screen.getName() : "");
        return;
      }
  
      final Screen previous = this.current();
      if (previous != null) {
        previous.suspend();
      }
  
      if (screen != null && !this.screens.contains(screen)) {
        this.screens.add(screen);
      }
  
      this.currentScreen = screen;
      if (!Game.isInNoGUIMode() && this.current() != null) {
        this.current().prepare();
      }
  
      this.lastScreenChange = Nullability.castToNonnull(Game.loop(), "initialized before usage").getTicks();
  
      final ScreenChangedEvent event = new ScreenChangedEvent(this.current(), previous);
      for (final ScreenChangedListener listener : this.screenChangedListeners) {
        listener.changed(event);
      }
}
}
```
```java
class de.gurkenlabs.litiengine.abilities.Ability {
public boolean isOnCooldown() {
    return (this.getCurrentExecution() != null
        && this.getCurrentExecution().getExecutionTicks() > 0
        && Game.time().since(this.getCurrentExecution().getExecutionTicks())
            < this.getAttributes().cooldown().get());
}public boolean isActive() {
    return this.getCurrentExecution() != null
        && Game.time().since(this.getCurrentExecution().getExecutionTicks())
            < this.getAttributes().duration().get();
}@Nullable
  public AbilityExecution cast() {
    if (!this.canCast()) {
      return null;
    }
    this.currentExecution = new AbilityExecution(this);

    for (final AbilityCastListener listener : this.abilityCastListeners) {
      listener.abilityCast(this.currentExecution);
    }

    return this.getCurrentExecution();
}public float getRemainingCooldownInSeconds() {
    if (this.getCurrentExecution() == null
        || this.getExecutor() == null
        || this.getExecutor().isDead()) {
      return 0;
    }

    // calculate cooldown in seconds
    return (float)
        (!this.canCast()
            ? (this.getAttributes().cooldown().get()
                    - Game.time().since(this.getCurrentExecution().getExecutionTicks()))
                * 0.001
            : 0);
}
}
```
```java
class de.gurkenlabs.litiengine.entities.EntityHitEvent {
EntityHitEvent(
      final ICombatEntity hitEntity,
      @Nullable final Ability ability,
      final int damage,
      final boolean kill) {
    super(hitEntity);
    this.executor = ability != null ? ability.getExecutor() : null;
    this.hitEntity = hitEntity;
    this.ability = ability;
    this.damage = damage;
    this.kill = kill;
    this.time = Game.time().now();
}
}
```
```java
class de.gurkenlabs.litiengine.graphics.emitters.Emitter {
public void delete() {
    this.deactivate();
    if (Game.world().environment() != null) {
      Game.world().environment().remove(this);
    }
}public void activate() {
    if (this.activated) {
      return;
    }

    this.activated = true;
    this.activationTick = Game.time().now();
    Game.loop().attach(this);
}@Override
  public void update() {
    if (this.isPaused()) {
      return;
    }

    // clear particles if the effect time to life is reached
    if (this.isFinished()) {
      for (EmitterFinishedListener listener : this.finishedListeners) {
        listener.finished(this);
      }

      this.delete();
      return;
    }

    final float updateRatio = (float) this.data().getUpdateRate() / Game.loop().getTickRate();
    for (final Particle p : this.getParticles().stream().collect(Collectors.toList())) {
      if (this.particleCanBeRemoved(p)) {
        // remove dead particles
        this.particles.remove(p);
        continue;
      }

      p.update(this.getOrigin(), updateRatio);
    }

    this.aliveTime = Game.time().since(this.activationTick);
    if ((this.data().getSpawnRate() == 0
        || Game.time().since(this.lastSpawn) >= this.data().getSpawnRate())) {
      this.lastSpawn = Game.time().now();
      this.spawnParticle();
    }
}
}
```
```java
class de.gurkenlabs.litiengine.GameLoop {
@Override
  public int perform(int delay, Runnable action) {
    final long d = Game.time().toTicks(delay);

    TimedAction a = new TimedAction(this.getTicks() + d, action);
    this.actions.add(a);

    return a.getId();
}
}
```
```java
class de.gurkenlabs.litiengine.environment.EntitySpawner {
protected boolean shouldSpawn() {
    return this.lastSpawnWave == 0
        || Game.time().since(this.lastSpawnWave) >= this.getSpawnInterval();
}@Override
  public void update() {
    if (!this.shouldSpawn()) {
      return;
    }

    this.spawnNewEntities();
    this.lastSpawnWave = Game.time().now();
}
}
```
```java
class de.gurkenlabs.litiengine.graphics.FreeFlightCamera {
@Override
  public void update() {
    this.handleFreeFlightCamera();
}public FreeFlightCamera(double x, double y) {
    this(new Point2D.Double(x, y));
}
}
```
```java
class de.gurkenlabs.litiengine.environment.Environment {
public void unload() {
    if (!this.loaded) {
      return;
    }

    // unregister all updatable entities from the current environment
    for (final IEntity entity : this.allEntities.values()) {
      this.unload(entity);
    }

    this.loaded = false;
    this.fireEvent(l -> l.unloaded(this));
}private static void loadUpdatableOrEmitterEntity(IEntity entity) {
      if (entity instanceof Emitter) {
        final Emitter emitter = (Emitter) entity;
        if (emitter.isActivateOnInit()) {
          emitter.activate();
        }
      } else if (entity instanceof IUpdateable) {
        Nullability.castToNonnull(Game.loop(), "initialized through init").attach((IUpdateable) entity);
      }
}public void clear() {
    Game.physics().clear();

    this.combatEntities.clear();
    this.mobileEntities.clear();
    this.gravityForces.clear();
    this.layerEntities.clear();
    this.entitiesByTag.clear();
    this.allEntities.clear();

    for (RenderType renderType : RenderType.values()) {
      this.miscEntities.get(renderType).clear();
      this.renderListeners.get(renderType).clear();
      this.renderables.get(renderType).clear();
    }

    dispose(this.allEntities.values());
    dispose(this.triggers);
    this.emitters.clear();
    this.colliders.clear();
    this.props.clear();
    this.creatures.clear();
    this.staticShadows.clear();
    this.combatEntities.clear();
    this.mobileEntities.clear();
    this.lightSources.clear();
    this.spawnPoints.clear();
    this.soundSources.clear();
    this.mapAreas.clear();
    this.triggers.clear();

    this.ambientLight = null;
    this.staticShadowLayer = null;

    for (Map<Integer, IEntity> type : this.miscEntities.values()) {
      type.clear();
    }

    this.initialized = false;

    this.fireEvent(l -> l.cleared(this));
}private void load(final IEntity entity) {
    // an entity can only exist on one environment at a time, so remove it from the current one
    if (entity.getEnvironment() != null) {
      entity.getEnvironment().remove(entity);
    }

    // 1. add to physics engine
    loadPhysicsEntity(entity);

    // 2. register for update or activate
    loadUpdatableOrEmitterEntity(entity);

    // 3. if a gravity is defined, add a gravity force to the entity
    if (entity instanceof IMobileEntity && this.getGravity() != 0) {
      this.addGravityForce((IMobileEntity) entity);
    }

    // 4. attach all controllers
    entity.attachControllers();

    if (this.loaded && (entity instanceof LightSource || entity instanceof StaticShadow)) {
      this.updateLighting(entity);
    }

    entity.loaded(this);
}private void unload(final IEntity entity) {
    // 1. remove from physics engine
    if (entity instanceof ICollisionEntity) {
      Game.physics().remove((ICollisionEntity) entity);
    }

    // 2. unregister from update
    if (entity instanceof IUpdateable) {
      Game.loop().detach((IUpdateable) entity);
    }

    if (entity instanceof IMobileEntity) {
      this.removeGravity((IMobileEntity) entity);
    }

    // 3. detach all controllers
    entity.detachControllers();

    if (entity instanceof Emitter) {
      Emitter em = (Emitter) entity;
      em.deactivate();
    }

    if (this.loaded && (entity instanceof LightSource || entity instanceof StaticShadow)) {
      this.updateLighting(entity);
    }

    entity.removed(this);
}public void remove(final IEntity entity) {
    if (entity == null) {
      return;
    }

    this.allEntities.remove(entity.getMapId());
    Iterator<List<IEntity>> iter = this.layerEntities.values().iterator();
    while (iter.hasNext()) {
      List<IEntity> layer = iter.next();
      if (layer.remove(entity) && layer.isEmpty()) {
        iter.remove();
      }
    }
    if (this.miscEntities.get(entity.getRenderType()) != null) {
      this.miscEntities.get(entity.getRenderType()).values().remove(entity);
    }

    for (String tag : entity.getTags()) {
      if (this.getEntitiesByTag().containsKey(tag)) {
        this.getEntitiesByTag().get(tag).remove(entity);

        if (this.getEntitiesByTag().get(tag).isEmpty()) {
          this.getEntitiesByTag().remove(tag);
        }
      }
    }

    if (entity instanceof Emitter) {
      Emitter emitter = (Emitter) entity;
      this.removeEmitter(emitter);
    }

    if (entity instanceof MapArea) {
      this.mapAreas.remove(entity);
    }

    if (entity instanceof Prop) {
      this.props.remove(entity);
    }

    if (entity instanceof Creature) {
      this.creatures.remove(entity);
    }

    if (entity instanceof CollisionBox) {
      this.colliders.remove(entity);
      this.staticShadows.removeIf(x -> x.getOrigin() != null && x.getOrigin().equals(entity));
    }

    if (entity instanceof LightSource) {
      this.lightSources.remove(entity);
      this.updateLighting(entity);
    }

    if (entity instanceof Trigger) {
      this.triggers.remove(entity);
    }

    if (entity instanceof Spawnpoint) {
      this.spawnPoints.remove(entity);
    }
    if (entity instanceof SoundSource) {
      this.soundSources.remove(entity);
    }

    if (entity instanceof StaticShadow) {
      this.staticShadows.remove(entity);
      this.updateLighting(entity);
    }

    if (entity instanceof IMobileEntity) {
      this.mobileEntities.values().remove(entity);
    }

    if (entity instanceof ICombatEntity) {
      this.combatEntities.values().remove(entity);
    }

    this.unload(entity);

    this.fireEntityEvent(l -> l.entityRemoved(entity));
}
}
```
```java
class de.gurkenlabs.litiengine.physics.MovementController {
@Override
  public void update() {
    this.handleForces();
    this.handleMovement();
}
}
```
```java
class de.gurkenlabs.litiengine.Game {
static synchronized void terminate() {
        if (!initialized || gameLoop == null) {
          return;
        }
    
        hasStarted = false;
        initialized = false;
    
        config().save();
        gameLoop.terminate();
        tweenEngine.terminate();
        soundEngine.terminate();
    
        world().clear();
    
        for (final GameListener listener : gameListeners) {
          try {
            listener.terminated();
          } catch (Exception e) {
            log().log(Level.WARNING, "game listener threw an exception during shutdown", e);
          }
        }
    
        gameLoop = null;
        screenManager = null;
        gameWindow = null;
}public static synchronized void start() {
          if (!initialized) {
              throw new IllegalStateException(
                  "The game cannot be started without being first initialized. Call Game.init(...) before Game.start().");
          }
    
          if (gameLoop == null) {
              throw new IllegalStateException(
                  "Game loop is not initialized. Ensure Game.init(...) has been called successfully.");
          }
          
          Nullability.castToNonnull(gameLoop, "gameLoop cannot be null").start();
          tweenEngine.start();
          soundEngine.start();
    
          for (final GameListener listener : gameListeners) {
              listener.started();
          }
    
          hasStarted = true;
}public static synchronized void init(String... args) {
    if (initialized) {
      log().log(Level.INFO, "The game has already been initialized.");
      return;
    }

    log.init();
    handleCommandLineArguments(args);

    config().load();
    Locale.setDefault(new Locale(config().client().getCountry(), config().client().getLanguage()));

    gameLoop = new GameLoop("Main Update Loop", config().client().getMaxFps());
    loop().attach(physics());
    loop().attach(world());

    // setup default exception handling for render and update loop
    setUncaughtExceptionHandler(
        new DefaultUncaughtExceptionHandler(config().client().exitOnError()));

    screenManager = new ScreenManager();
    gameWindow = new GameWindow();

    // initialize  the game window
    window().init();
    world.setCamera(new Camera());

    for (GameListener listener : gameListeners) {
      listener.initialized(args);
    }

    if (!isInNoGUIMode()) {
      window().getRenderComponent().onRendered(g -> metrics().render(g));

      graphics()
          .addEntityRenderedListener(
              e -> DebugRenderer.renderEntityDebugInfo(e.getGraphics(), e.getEntity()));

      window().getRenderComponent().onFpsChanged(fps -> metrics().setFramesPerSecond(fps));
      window()
          .setIcons(
              Arrays.asList(
                  Resources.images().get("liti-logo-x16.png"),
                  Resources.images().get("liti-logo-x20.png"),
                  Resources.images().get("liti-logo-x32.png"),
                  Resources.images().get("liti-logo-x48.png")));

      Input.keyboard()
          .onKeyTyped(
              KeyEvent.VK_PRINTSCREEN,
              key -> {
                // don't take a screenshot if a modifier is active
                if (key.getModifiers() != 0) {
                  return;
                }

                window().getRenderComponent().takeScreenshot();
              });
    }

    Runtime.getRuntime().addShutdownHook(new Thread(Game::terminate, "Shutdown"));

    initialized = true;
}
}
```


Response Format:
Provide the answer in **XML format** as follows:

#### If the method **cannot** return `null` at the specific call site:
```xml
<response>
  <reason><![CDATA[EXPLAIN WHY THE INVOCATION Game.loop() RESULT CANNOT BE NULL.]]></reason>
  <value>NO</value>
</response>

#### If the method can return null at the specific call site:
<response>
  <reason><![CDATA[EXPLAIN WHY THE INVOCATION Game.loop() RESULT CAN BE NULL.]]></reason>
  <value>YES</value>
</response>

#### If you are unsure or If there are any methods that directly or indirectly affect the return value and are not fully disclosed, request their declarations first, in the following format:
<response>
  <reason><![CDATA[EXPLAIN WHY THIS METHOD DECLARATION IS NECESSARY AND WHY YOU CANNOT MAKE A CONFIDENT DECISION WITHOUT IT]]></reason>
  <success>false</success>
  <methods>
    <method>methodName</method>
  </methods>
</response>

Additional Notes:
Be precise in your reasoning.
If a methods return value depends on another method not provided, request its declaration before making a conclusion.
If the method can return null in this case but not in others, explain why it happens specifically for this call.

11:53:24.964 TRACE edu.ucr.cs.riple.core.checkers.nullaway.codefix.ChatGPT.ask
Retrieving response from cache
11:53:24.964 TRACE edu.ucr.cs.riple.core.checkers.nullaway.codefix.Response.tryCreate
Trying to create Response:
```xml
<response>
  <reason><![CDATA[The Game.loop() method accesses the static gameLoop variable, which is initially assigned during the initialization process in Game.init(). The initialization checks if the game has already been initialized to prevent re-initialization. However, if Game.terminate() is called, it sets gameLoop to null. Therefore, Game.loop() can return null if Game.terminate() is called before accessing Game.loop(). This makes it possible for Game.loop() to return null at the specific call site depending on when the method is called in the lifecycle.]]></reason>
  <value>YES</value>
</response>
```
11:53:24.965 TRACE edu.ucr.cs.riple.core.checkers.nullaway.codefix.Response.<init>
Creating Response:
```xml
<response>
  <reason><![CDATA[The Game.loop() method accesses the static gameLoop variable, which is initially assigned during the initialization process in Game.init(). The initialization checks if the game has already been initialized to prevent re-initialization. However, if Game.terminate() is called, it sets gameLoop to null. Therefore, Game.loop() can return null if Game.terminate() is called before accessing Game.loop(). This makes it possible for Game.loop() to return null at the specific call site depending on when the method is called in the lifecycle.]]></reason>
  <value>YES</value>
</response>
```
11:53:24.965 TRACE edu.ucr.cs.riple.core.checkers.nullaway.codefix.Response.<init>
Response created:
Agreement: The Game.loop() method accesses the static gameLoop variable, which is initially assigned during the initialization process in Game.init(). The initialization checks if the game has already been initialized to prevent re-initialization. However, if Game.terminate() is called, it sets gameLoop to null. Therefore, Game.loop() can return null if Game.terminate() is called before accessing Game.loop(). This makes it possible for Game.loop() to return null at the specific call site depending on when the method is called in the lifecycle.
11:53:24.965 TRACE edu.ucr.cs.riple.core.checkers.nullaway.codefix.AdvancedNullAwayCodeFix.resolveMethodDereferenceError
Trying to fix by regions using the method as an example.
11:53:24.965 TRACE edu.ucr.cs.riple.core.checkers.nullaway.codefix.AdvancedNullAwayCodeFix.fixErrorByRegions
Fixing error by regions.
11:53:24.965 TRACE edu.ucr.cs.riple.core.checkers.nullaway.codefix.AdvancedNullAwayCodeFix.getTriggeredErrorsFromLocation
Impact not found, re-evaluating the location.
11:53:26.470 TRACE edu.ucr.cs.riple.core.checkers.nullaway.codefix.AdvancedNullAwayCodeFix.fixErrorByRegions
Safe regions: 42 - Unsafe regions: 5
11:53:26.470 TRACE edu.ucr.cs.riple.core.checkers.nullaway.codefix.ChatGPT.fixDereferenceErrorBySafeRegions
Attempting to fix dereference error by using safe regions
11:53:26.529 TRACE edu.ucr.cs.riple.core.checkers.nullaway.codefix.ChatGPT.fixDereferenceErrorBySafeRegions
Asking if the error can be fixed by using safe regions
11:53:26.529 TRACE edu.ucr.cs.riple.core.checkers.nullaway.codefix.ChatGPT.ask
Asking ChatGPT:
I want to resolve a warning reported by NullAway.
I am getting the error that in line:     this.drawMetric(g, "updatables: " + Game.loop().getUpdatableCount());, the dereferenced expression Game.loop() is @Nullable and can produce Null Pointer Exception. In the method below:
@Override
  public void render(final Graphics2D g) {
    this.updateMetrics();

    if (!Game.config().client().showGameMetrics()) {
      return;
    }

    this.currentOffsetY = 0;

    g.setColor(this.renderColor);

    // render client metrics
    this.drawTitle(g, "[client]");
    this.drawMetric(g, "fps       : " + this.getFramesPerSecond());
    this.drawMetric(g, "max fps   : " + this.maxFramesPerSecond);
    this.drawMetric(g, "updatables: " + Game.loop().getUpdatableCount());

    // render jvm metrics if debug is enabled
    if (Game.config().debug().isDebugEnabled()) {
      this.drawTitle(g, "[jvm]");
      this.drawMetric(g, "java      : " + this.javaVersion);
      this.drawMetric(g, "memory    : " + String.format("%-5.5s", this.usedMemory) + " MB");
      this.drawMetric(g, "threads   : " + Thread.activeCount());
    }

    // render rendering metrics
    if (!this.renderMetrics.isEmpty()) {
      this.drawTitle(g, "[update]");

      for (RenderMetrics metric : this.renderMetrics) {
        this.drawMetric(g, metric.toString());
      }

      this.renderMetrics.clear();
    }
}
I am going to show you a couple of other examples in my codebase where the dereferenced expression is used in a way that cannot produce Null Pointer Exception.
Here are the examples(s):
@Override
          public void windowGainedFocus(WindowEvent e) {
            Game.loop().setTickRate(Game.config().client().getMaxFps());
}
public void detach() {
    Game.loop().detach(this);
}
public void hide() {
    Game.world().environment().removeRenderable(this);
    Game.loop().detach(this);
    if (activeSpeechBubbles.get(this.getEntity()) != null
        && activeSpeechBubbles.remove(this.getEntity()).equals(this)) {
      activeSpeechBubbles.remove(this.getEntity());
    }

    for (SpeechBubbleListener listener : this.listeners) {
      listener.hidden();
    }
}
public void activate() {
    if (this.activated) {
      return;
    }

    this.activated = true;
    this.activationTick = Game.time().now();
    Game.loop().attach(this);
}
private SpeechBubble(
      final IEntity entity,
      final String text,
      @Nullable SpeechBubbleAppearance appearance,
      @Nullable Font font) {
    if (appearance == null) {
      this.appearance = DEFAULT_APPEARANCE;
    } else {
      this.appearance = appearance;
    }

    final SpeechBubble active = activeSpeechBubbles.get(entity);
    if (active != null) {
      active.hide();
    }
    this.setFont(font);

    this.textBoxWidth = (float) (entity.getWidth() * 4);
    this.entity = entity;

    this.currentText = text;
    this.currentTextDisplayTime = DISPLAYTIME_MIN + text.length() * DISPLAYTIME_PER_LETTER;

    this.lastTextDisplay = Game.time().now();
    this.createBubbleImage();
    entity.getEnvironment().add(this, RenderType.UI);
    Game.loop().attach(this);
    activeSpeechBubbles.put(entity, this);
}
public long now() {
    return Game.loop().getTicks();
}
AbilityExecution(final Ability ability) {
    this.appliedEffects = new CopyOnWriteArrayList<>();
    this.ability = ability;
    this.executionTicks = Game.time().now();
    this.impactArea = ability.calculateImpactArea();
    this.castLocation = ability.getExecutor().getCenter();
    Game.loop().attach(this);
}
public long sinceGameStart() {
    return this.toMilliseconds(Game.loop().getTicks());
}
@Override
  public void loaded(Environment environment) {
    environmentLoaded = Game.loop().getTicks();
}
private static void initializeWindowEventListeners(Window window) {

    window.addWindowStateListener(
        e -> {
          if (e.getNewState() == Frame.ICONIFIED) {
            Game.loop().setTickRate(ICONIFIED_MAX_FPS);
          } else {
            Game.loop().setTickRate(Game.config().client().getMaxFps());
          }
        });

    window.addWindowFocusListener(
        new WindowFocusListener() {
          @Override
          public void windowLostFocus(WindowEvent e) {
            if (Game.config().graphics().reduceFramesWhenNotFocused()) {
              Game.loop().setTickRate(NONE_FOCUS_MAX_FPS);
            }
          }

          @Override
          public void windowGainedFocus(WindowEvent e) {
            Game.loop().setTickRate(Game.config().client().getMaxFps());
          }
        });

    window.addWindowListener(
        new WindowAdapter() {
          @Override
          public void windowClosing(final WindowEvent event) {
            Game.exit();
          }
        });
}
@Override
  public void start() {
    Game.loop().attach(this);
}
public default void attach() {
    Game.loop().attach(this);
}
public void loadEnvironment(@Nullable final Environment env) {
    Lock lock = Game.loop().getLock();
    lock.lock();
    try {
      unloadEnvironment();
      this.environment = env;
      if (env != null) {
        this.addEnvironment(env);

        if (env.getGravity() == 0 && this.gravity() != 0) {
          env.setGravity(this.gravity());
        }

        env.load();
        for (final EnvironmentLoadedListener listener : this.loadedListeners) {
          listener.loaded(env);
        }

        // call map specific listeners
        String mapName = getMapName(env);
        if (mapName != null && this.environmentLoadedListeners.containsKey(mapName)) {

          // for the default camera we center the camera on the environment
          if (this.camera().getClass().equals(Camera.class)) {
            camera().setFocus(env.getCenter());
          }

          for (EnvironmentLoadedListener listener : this.environmentLoadedListeners.get(mapName)) {
            listener.loaded(env);
          }
        }
      }
    } finally {
      lock.unlock();
    }
}
protected void spawnNewEntities() {
    if (this.getSpawnMode() != SpawnMode.CUSTOMSPAWNPOINTS && this.getSpawnPoints().isEmpty()) {
      return;
    }

    switch (this.getSpawnMode()) {
      case ALLSPAWNPOINTS:
        for (int i = 0; i < this.getSpawnPoints().size(); i++) {
          final int index = i;
          Game.loop()
              .perform(
                  this.getSpawnDelay() + this.getSpawnDelay() * i,
                  () -> this.spawn(this.getSpawnPoints().get(index), this.getSpawnAmount()));
        }
        break;
      case ONERANDOMSPAWNPOINT:
        this.spawn(Game.random().choose(this.getSpawnPoints()), this.getSpawnAmount());
        break;
      case RANDOMSPAWNPOINTS:
        for (int i = 0; i < this.getSpawnAmount(); i++) {
          Game.loop()
              .perform(
                  this.getSpawnDelay() + this.getSpawnDelay() * i,
                  () -> this.spawn(Game.random().choose(this.getSpawnPoints()), 1));
        }
        break;
      case CUSTOMSPAWNPOINTS:
        List<Spawnpoint> spawnPoints =
            this.customSpawnpoints != null
                ? this.customSpawnpoints.apply(this)
                : this.getCustomSpawnpoints();

        int index = 0;
        for (Spawnpoint spawn : spawnPoints) {
          Game.loop()
              .perform(
                  this.getSpawnDelay() + this.getSpawnDelay() * index, () -> this.spawn(spawn, 1));
          index++;
        }
        break;
      default:
        break;
    }
}
@Override
  public void attach() {
    Game.loop().attach(this);
}
public long toTicks(final int milliseconds) {
    return this.toTicks(milliseconds, Game.loop().getTickRate());
}
private void handleForces() {
    // clean up forces
    this.activeForces.forEach(
        x -> {
          if (x.hasEnded()) {
            this.activeForces.remove(x);
          }
        });

    if (this.activeForces.isEmpty()) {
      return;
    }

    // disable turn-on-move for force handling
    boolean turn = this.getEntity().turnOnMove();
    this.getEntity().setTurnOnMove(false);
    try {
      double deltaX = 0;
      double deltaY = 0;
      for (final Force force : this.activeForces) {
        if (force.cancelOnReached() && force.hasReached(this.getEntity())) {
          force.end();
          continue;
        }

        final Point2D collisionBoxCenter = this.getEntity().getCollisionBoxCenter();
        final double angle =
            GeometricUtilities.calcRotationAngleInDegrees(collisionBoxCenter, force.getLocation());
        final double strength =
            Game.loop().getDeltaTime() * 0.001f * force.getStrength() * Game.loop().getTimeScale();
        deltaX += GeometricUtilities.getDeltaX(angle, strength);
        deltaY += GeometricUtilities.getDeltaY(angle, strength);
      }

      final Point2D target =
          new Point2D.Double(this.getEntity().getX() + deltaX, this.getEntity().getY() + deltaY);
      final boolean success = Game.physics().move(this.getEntity(), target);
      if (!success) {
        for (final Force force : this.activeForces) {
          if (force.cancelOnCollision()) {
            force.end();
          }
        }
      }
    } finally {
      this.getEntity().setTurnOnMove(turn);
    }
}
@Override
  public void update() {
    // do nothing if the animation is not playing or the current keyframe is not finished
    if (!this.isPlaying()
        || Game.time().since(this.lastFrameUpdate) < this.getCurrentKeyFrame().getDuration()) {
      return;
    }

    // if we are not looping and the last keyframe is finished, we terminate the animation
    if (!this.isLooping() && this.isLastKeyFrame()) {
      this.terminate();
      return;
    }

    // make sure, we stay inside the keyframe list
    final int newFrameIndex =
        (this.getKeyframes().indexOf(this.currentFrame) + 1) % this.getKeyframes().size();
    final KeyFrame previousFrame = this.currentFrame;
    this.currentFrame = this.getKeyframes().get(newFrameIndex);

    for (KeyFrameListener listener : this.listeners) {
      listener.currentFrameChanged(previousFrame, this.currentFrame);
    }

    this.lastFrameUpdate = Game.loop().getTicks();
}
@Override
  public void update() {
    // if there a no effects to apply -> unregister this instance and we're done
    if (this.getAbility().getEffects().isEmpty()
        || this.getAbility().getEffects().size() == this.getAppliedEffects().size()) {
      Game.loop().detach(this);
      return;
    }

    // handle all effects from the ability that were not applied yet
    for (final Effect effect : this.getAbility().getEffects()) {
      // if the ability was not executed yet or the delay of the effect is not
      // yet reached
      if (this.getAppliedEffects().contains(effect)
          || Game.time().since(this.getExecutionTicks()) < effect.getDelay()) {
        continue;
      }

      effect.apply(this.getExecutionImpactArea());
      this.getAppliedEffects().add(effect);
    }
}
public long toMilliseconds(final long ticks) {
    return this.toMilliseconds(ticks, Game.loop().getTickRate());
}
@Override
  public void update() {
    if (this.isPaused()) {
      return;
    }

    // clear particles if the effect time to life is reached
    if (this.isFinished()) {
      for (EmitterFinishedListener listener : this.finishedListeners) {
        listener.finished(this);
      }

      this.delete();
      return;
    }

    final float updateRatio = (float) this.data().getUpdateRate() / Game.loop().getTickRate();
    for (final Particle p : this.getParticles().stream().collect(Collectors.toList())) {
      if (this.particleCanBeRemoved(p)) {
        // remove dead particles
        this.particles.remove(p);
        continue;
      }

      p.update(this.getOrigin(), updateRatio);
    }

    this.aliveTime = Game.time().since(this.activationTick);
    if ((this.data().getSpawnRate() == 0
        || Game.time().since(this.lastSpawn) >= this.data().getSpawnRate())) {
      this.lastSpawn = Game.time().now();
      this.spawnParticle();
    }
}
private void updateAnimationController() {
    IEntityAnimationController<?> controller = this.createAnimationController();
    this.getControllers().addController(controller);
    if (Game.world().environment() != null && Game.world().environment().isLoaded()) {
      Game.loop().attach(controller);
    }
}
public void apply(final Shape impactArea) {
    final List<ICombatEntity> affected = this.lookForAffectedEntities(impactArea);
    for (final ICombatEntity affectedEntity : affected) {
      this.apply(affectedEntity);
    }

    this.appliances.add(new EffectApplication(affected, impactArea));

    // if it is the first appliance -> register for update
    if (this.appliances.size() == 1) {
      Game.loop().attach(this);
    }
}
public void deactivate() {
    if (!this.activated) {
      return;
    }

    this.activated = false;
    this.getParticles().clear();
    this.aliveTime = 0;
    this.activationTick = 0;
    this.lastSpawn = 0;
    Game.loop().detach(this);
}
private static void loadUpdatableOrEmitterEntity(IEntity entity) {
      if (entity instanceof Emitter) {
        final Emitter emitter = (Emitter) entity;
        if (emitter.isActivateOnInit()) {
          emitter.activate();
        }
      } else if (entity instanceof IUpdateable) {
        Nullability.castToNonnull(Game.loop(), "initialized through init").attach((IUpdateable) entity);
      }
}
@Override
  public void terminate() {
    Game.loop().detach(this);
}
public default void detach() {
    Game.loop().detach(this);
}
protected void updateAnimationController() {
        IEntityAnimationController<?> controller = this.createAnimationController();
        this.getControllers().addController(controller);
        if (Game.world().environment() != null && Game.world().environment().isLoaded()) {
            Nullability.castToNonnull(Game.loop(), "expected to be non-null").attach(controller);
        }
}
@Override
  public void detach() {
    Game.loop().detach(this);
}
public long since(final long tick) {
    return toMilliseconds(Game.loop().getTicks() - tick);
}
@Nullable public static IGameLoop loop() {
    return gameLoop;
}
@Override
  public void update() {

    for (final Iterator<EffectApplication> iterator = this.getActiveAppliances().iterator();
        iterator.hasNext(); ) {
      final EffectApplication appliance = iterator.next();
      // if the effect duration is reached
      if (this.hasEnded(appliance)) {

        iterator.remove();
        this.cease(appliance);
      }
    }

    // 4. unregister if all appliances are finished
    if (this.getActiveAppliances().isEmpty()) {
      Game.loop().detach(this);
    }
}
@Override
  public void setZoom(final float targetZoom, final int delay) {
    if (delay == 0) {

      this.zoom = targetZoom;
      this.targetZoom = 0;
      this.zoomDelay = 0;
      this.zoomTick = 0;
      this.zoomStep = 0;

      final ZoomChangedEvent event = new ZoomChangedEvent(this, targetZoom);
      for (final ZoomChangedListener listener : this.zoomListeners) {
        listener.zoomChanged(event);
      }
    } else {
      this.zoomTick = Game.time().now();
      this.targetZoom = targetZoom;
      this.zoomDelay = delay;

      final double tickduration = 1000 / (double) Game.loop().getTickRate();
      final double tickAmount = delay / tickduration;
      final float totalDelta = this.targetZoom - this.zoom;
      this.zoomStep = tickAmount > 0 ? (float) (totalDelta / tickAmount) : totalDelta;
    }
}
public void attach() {
    Game.loop().attach(this);
}
public EntityNavigator(final IMobileEntity entity, final PathFinder pathFinder) {
    this.cancelNavigationConditions = new CopyOnWriteArrayList<>();
    this.listeners = new CopyOnWriteArrayList<>();
    this.entity = entity;
    this.pathFinder = pathFinder;
    this.setAcceptableError(DEFAULT_ACCEPTABLE_ERROR);
    Game.loop().attach(this);
}
public void setCamera(@Nullable final ICamera cam) {
    if (this.camera() != null) {
      Game.loop().detach(camera);
    }

    camera = cam;

    if (cam != null && !Game.isInNoGUIMode()) {
      Game.loop().attach(cam);
      cam.updateFocus();
    }
}
public void display(@Nullable final Screen screen) {
      if (Game.hasStarted() && Game.time().since(this.lastScreenChange) < this.getChangeCooldown()) {
        log.log(
            Level.INFO,
            "Skipping displaying of screen {0} because screen changing is currently on cooldown.",
            screen != null ? screen.getName() : "");
        return;
      }
  
      final Screen previous = this.current();
      if (previous != null) {
        previous.suspend();
      }
  
      if (screen != null && !this.screens.contains(screen)) {
        this.screens.add(screen);
      }
  
      this.currentScreen = screen;
      if (!Game.isInNoGUIMode() && this.current() != null) {
        this.current().prepare();
      }
  
      this.lastScreenChange = Nullability.castToNonnull(Game.loop(), "initialized before usage").getTicks();
  
      final ScreenChangedEvent event = new ScreenChangedEvent(this.current(), previous);
      for (final ScreenChangedListener listener : this.screenChangedListeners) {
        listener.changed(event);
      }
}
public void handleMovement() {
    if (!this.isMovementAllowed()) {
      this.velocity = 0;
      return;
    }

    // max distance an entity can travel within one tick
    final double maxPixelsPerTick = this.getEntity().getTickVelocity();
    final double deltaTime = Game.loop().getDeltaTime() * Game.loop().getTimeScale();

    final double acceleration =
        this.getEntity().getAcceleration() == 0
            ? maxPixelsPerTick
            : deltaTime / this.getEntity().getAcceleration() * maxPixelsPerTick;
    final double deceleration =
        this.getEntity().getDeceleration() == 0
            ? this.getVelocity()
            : deltaTime / this.getEntity().getDeceleration() * maxPixelsPerTick;

    double dx = this.getDx();
    double dy = this.getDy();
    this.setDx(0);
    this.setDy(0);

    final double deltaVelocity =
        Math.min(Math.sqrt(Math.pow(dx, 2) + Math.pow(dy, 2)), acceleration);
    if (deltaVelocity != 0) {
      double newVelocity = this.getVelocity() + deltaVelocity;
      this.setVelocity(newVelocity);
    } else {
      final double newVelocity = Math.max(0, this.getVelocity() - deceleration);
      this.setVelocity(newVelocity);
      dx = GeometricUtilities.getDeltaX(this.moveAngle);
      dy = GeometricUtilities.getDeltaY(this.moveAngle);
    }

    if (this.getVelocity() == 0) {
      this.moveAngle = 0;
      return;
    }

    // actually move entity
    this.moveEntity(dx, dy);
}
@Override
          public void windowLostFocus(WindowEvent e) {
            if (Game.config().graphics().reduceFramesWhenNotFocused()) {
              Game.loop().setTickRate(NONE_FOCUS_MAX_FPS);
            }
}
private void handleFreeFlightCamera() {
      if (Game.world().environment() == null || Game.world().environment().getMap() == null) {
        return;
      }
  
      final Point2D mouseLocation = Input.mouse().getLocation();
  
      final double scrollSpeed =
          this.getVelocity()
              / (double) Nullability.castToNonnull(Game.loop(), "gameLoop always initialized")
                  .getTickRate()
              * Game.config().input().getMouseSensitivity();
  
      double x = this.getFocus().getX();
      double y = this.getFocus().getY();
  
      double deltaX = 0;
      if (mouseLocation.getX() < this.getScrollPadding()) {
        deltaX -= scrollSpeed;
      } else if (Game.window().getResolution().getWidth() - mouseLocation.getX()
          < this.getScrollPadding()) {
        deltaX += scrollSpeed;
      }
  
      double deltaY = 0;
      if (mouseLocation.getY() < this.getScrollPadding()) {
        deltaY -= scrollSpeed;
      } else if (Game.window().getResolution().getHeight() - mouseLocation.getY()
          < this.getScrollPadding()) {
        deltaY += scrollSpeed;
      }
  
      x += deltaX;
      y += deltaY;
  
      this.setFocus(new Point2D.Double(x, y));
}
public void restart() {
    this.currentFrame = this.firstFrame;
    this.lastFrameUpdate = Game.loop().getTicks();
}
@Override
  public void render(final Graphics2D g) {
    this.updateMetrics();

    if (!Game.config().client().showGameMetrics()) {
      return;
    }

    this.currentOffsetY = 0;

    g.setColor(this.renderColor);

    // render client metrics
    this.drawTitle(g, "[client]");
    this.drawMetric(g, "fps       : " + this.getFramesPerSecond());
    this.drawMetric(g, "max fps   : " + this.maxFramesPerSecond);
    this.drawMetric(g, "updatables: " + Game.loop().getUpdatableCount());

    // render jvm metrics if debug is enabled
    if (Game.config().debug().isDebugEnabled()) {
      this.drawTitle(g, "[jvm]");
      this.drawMetric(g, "java      : " + this.javaVersion);
      this.drawMetric(g, "memory    : " + String.format("%-5.5s", this.usedMemory) + " MB");
      this.drawMetric(g, "threads   : " + Thread.activeCount());
    }

    // render rendering metrics
    if (!this.renderMetrics.isEmpty()) {
      this.drawTitle(g, "[update]");

      for (RenderMetrics metric : this.renderMetrics) {
        this.drawMetric(g, metric.toString());
      }

      this.renderMetrics.clear();
    }
}
Given the examples above, I want you to fix the error in the original method by using the same pattern as in the examples.
If you can fix the error, please provide the fixed code snippet in XML format. I just need the XML response, no other information is needed. If you can provide the fixed code snippet, please provide it in the following format and place the code snippet in the <code> tag within ```java block.
For example,
<response>
  <success>true</success>
  <code>
  <![CDATA[
  ```java
  Your fixed code snippet here, JUST THE METHOD.
  ```
    ]]>
  </code>
</response>
Or if you cannot fix the error, please provide the reason in XML format.
<response>
  <success>false</success>
</response>

11:53:26.530 TRACE edu.ucr.cs.riple.core.checkers.nullaway.codefix.ChatGPT.ask
Retrieving response from cache
11:53:26.530 TRACE edu.ucr.cs.riple.core.checkers.nullaway.codefix.Response.tryCreate
Trying to create Response:
```xml
<response>
  <success>true</success>
  <code>
  <![CDATA[
  ```java
  @Override
  public void render(final Graphics2D g) {
    this.updateMetrics();

    if (!Game.config().client().showGameMetrics()) {
      return;
    }

    this.currentOffsetY = 0;

    g.setColor(this.renderColor);

    // render client metrics
    this.drawTitle(g, "[client]");
    this.drawMetric(g, "fps       : " + this.getFramesPerSecond());
    this.drawMetric(g, "max fps   : " + this.maxFramesPerSecond);

    // Use Nullability.castToNonnull to prevent NullAway warning
    this.drawMetric(g, "updatables: " + Nullability.castToNonnull(Game.loop(), "gameLoop always initialized").getUpdatableCount());

    // render jvm metrics if debug is enabled
    if (Game.config().debug().isDebugEnabled()) {
      this.drawTitle(g, "[jvm]");
      this.drawMetric(g, "java      : " + this.javaVersion);
      this.drawMetric(g, "memory    : " + String.format("%-5.5s", this.usedMemory) + " MB");
      this.drawMetric(g, "threads   : " + Thread.activeCount());
    }

    // render rendering metrics
    if (!this.renderMetrics.isEmpty()) {
      this.drawTitle(g, "[update]");

      for (RenderMetrics metric : this.renderMetrics) {
        this.drawMetric(g, metric.toString());
      }

      this.renderMetrics.clear();
    }
  }
  ```
    ]]>
  </code>
</response>
```
11:53:26.531 TRACE edu.ucr.cs.riple.core.checkers.nullaway.codefix.Response.<init>
Creating Response:
```xml
<response>
  <success>true</success>
  <code>
  <![CDATA[
  ```java
  @Override
  public void render(final Graphics2D g) {
    this.updateMetrics();

    if (!Game.config().client().showGameMetrics()) {
      return;
    }

    this.currentOffsetY = 0;

    g.setColor(this.renderColor);

    // render client metrics
    this.drawTitle(g, "[client]");
    this.drawMetric(g, "fps       : " + this.getFramesPerSecond());
    this.drawMetric(g, "max fps   : " + this.maxFramesPerSecond);

    // Use Nullability.castToNonnull to prevent NullAway warning
    this.drawMetric(g, "updatables: " + Nullability.castToNonnull(Game.loop(), "gameLoop always initialized").getUpdatableCount());

    // render jvm metrics if debug is enabled
    if (Game.config().debug().isDebugEnabled()) {
      this.drawTitle(g, "[jvm]");
      this.drawMetric(g, "java      : " + this.javaVersion);
      this.drawMetric(g, "memory    : " + String.format("%-5.5s", this.usedMemory) + " MB");
      this.drawMetric(g, "threads   : " + Thread.activeCount());
    }

    // render rendering metrics
    if (!this.renderMetrics.isEmpty()) {
      this.drawTitle(g, "[update]");

      for (RenderMetrics metric : this.renderMetrics) {
        this.drawMetric(g, metric.toString());
      }

      this.renderMetrics.clear();
    }
  }
  ```
    ]]>
  </code>
</response>
```
11:53:26.531 TRACE edu.ucr.cs.riple.core.checkers.nullaway.codefix.Response.<init>
Response created:
@Override
  public void render(final Graphics2D g) {
    this.updateMetrics();

    if (!Game.config().client().showGameMetrics()) {
      return;
    }

    this.currentOffsetY = 0;

    g.setColor(this.renderColor);

    // render client metrics
    this.drawTitle(g, "[client]");
    this.drawMetric(g, "fps       : " + this.getFramesPerSecond());
    this.drawMetric(g, "max fps   : " + this.maxFramesPerSecond);

    // Use Nullability.castToNonnull to prevent NullAway warning
    this.drawMetric(g, "updatables: " + Nullability.castToNonnull(Game.loop(), "gameLoop always initialized").getUpdatableCount());

    // render jvm metrics if debug is enabled
    if (Game.config().debug().isDebugEnabled()) {
      this.drawTitle(g, "[jvm]");
      this.drawMetric(g, "java      : " + this.javaVersion);
      this.drawMetric(g, "memory    : " + String.format("%-5.5s", this.usedMemory) + " MB");
      this.drawMetric(g, "threads   : " + Thread.activeCount());
    }

    // render rendering metrics
    if (!this.renderMetrics.isEmpty()) {
      this.drawTitle(g, "[update]");

      for (RenderMetrics metric : this.renderMetrics) {
        this.drawMetric(g, metric.toString());
      }

      this.renderMetrics.clear();
    }
  }
11:53:26.531 TRACE edu.ucr.cs.riple.core.checkers.nullaway.codefix.ChatGPT.fixDereferenceErrorBySafeRegions
Fixing the error by using safe regions with code:
@Override
  public void render(final Graphics2D g) {
    this.updateMetrics();

    if (!Game.config().client().showGameMetrics()) {
      return;
    }

    this.currentOffsetY = 0;

    g.setColor(this.renderColor);

    // render client metrics
    this.drawTitle(g, "[client]");
    this.drawMetric(g, "fps       : " + this.getFramesPerSecond());
    this.drawMetric(g, "max fps   : " + this.maxFramesPerSecond);

    // Use Nullability.castToNonnull to prevent NullAway warning
    this.drawMetric(g, "updatables: " + Nullability.castToNonnull(Game.loop(), "gameLoop always initialized").getUpdatableCount());

    // render jvm metrics if debug is enabled
    if (Game.config().debug().isDebugEnabled()) {
      this.drawTitle(g, "[jvm]");
      this.drawMetric(g, "java      : " + this.javaVersion);
      this.drawMetric(g, "memory    : " + String.format("%-5.5s", this.usedMemory) + " MB");
      this.drawMetric(g, "threads   : " + Thread.activeCount());
    }

    // render rendering metrics
    if (!this.renderMetrics.isEmpty()) {
      this.drawTitle(g, "[update]");

      for (RenderMetrics metric : this.renderMetrics) {
        this.drawMetric(g, metric.toString());
      }

      this.renderMetrics.clear();
    }
  }
11:53:26.531 TRACE edu.ucr.cs.riple.core.checkers.nullaway.codefix.AdvancedNullAwayCodeFix.fixErrorByRegions
Successfully generated a fix for the error.
11:53:26.533 TRACE edu.ucr.cs.riple.core.checkers.nullaway.codefix.AdvancedNullAwayCodeFix.fixTriggeredErrorsForLocation
Resolving unresolvable error for triggered error: Type='DEREFERENCE_NULLABLE', message='dereferenced expression Game.loop() is @Nullable'
/home/nima/Developer/nullness-benchmarks/litiengine/src/de/gurkenlabs/litiengine/abilities/AbilityExecution.java:24
    Game.loop().attach(this);
11:53:26.533 TRACE edu.ucr.cs.riple.core.checkers.nullaway.codefix.AdvancedNullAwayCodeFix.fix
Fixing error: Type='DEREFERENCE_NULLABLE', message='dereferenced expression Game.loop() is @Nullable'
/home/nima/Developer/nullness-benchmarks/litiengine/src/de/gurkenlabs/litiengine/abilities/AbilityExecution.java:24
    Game.loop().attach(this);
11:53:26.533 TRACE edu.ucr.cs.riple.core.checkers.nullaway.codefix.AdvancedNullAwayCodeFix.resolveDereferenceError
Resolving dereference error: Type='DEREFERENCE_NULLABLE', message='dereferenced expression Game.loop() is @Nullable'
/home/nima/Developer/nullness-benchmarks/litiengine/src/de/gurkenlabs/litiengine/abilities/AbilityExecution.java:24
    Game.loop().attach(this);
11:53:26.533 TRACE edu.ucr.cs.riple.core.checkers.nullaway.codefix.AdvancedNullAwayCodeFix.resolveDereferenceError
Checking nullability possibility at error point
11:53:26.534 TRACE edu.ucr.cs.riple.core.checkers.nullaway.codefix.ChatGPT.checkNullabilityPossibilityAtErrorPoint
Asking if the expression can be null at error point point
11:53:26.534 TRACE edu.ucr.cs.riple.core.checkers.nullaway.codefix.ChatGPT.ask
Asking ChatGPT:
In the method below, is there a possibility that the expression "Game.loop()" at line "Game.loop().attach(this);" is null?
AbilityExecution(final Ability ability) {
    this.appliedEffects = new CopyOnWriteArrayList<>();
    this.ability = ability;
    this.executionTicks = Game.time().now();
    this.impactArea = ability.calculateImpactArea();
    this.castLocation = ability.getExecutor().getCenter();
    Game.loop().attach(this);
}
Give a single-word answer in XML format. If it is possible for the expression to be null, respond with:
```xml
<response>
    <reason><![CDATA[YOUR REASON]]></reason>
    <value>YES</value>
</response>
```
If it is not possible for the expression to be null, respond with:
```xml
<response>
    <reason><![CDATA[YOUR REASON]]></reason>
    <value>NO</value>
</response>
```
If you are unsure or need more information, respond with where you can ask for more details or what specific information you need.

If additional information is required, list each request inside a `<request>` tag. If no additional information is needed, omit the `<requests>` section.

Respond with:
```xml
<response>
    <reason><![CDATA[YOUR REASON]]></reason>
    <value>UNKNOWN</value>
    <!-- Include <requests> only if additional information is needed -->
    <requests>
        <request><![CDATA[YOUR REQUEST 1]]></request>
        <request><![CDATA[YOUR REQUEST 2]]></request>
    </requests>
</response>
```
11:53:26.534 TRACE edu.ucr.cs.riple.core.checkers.nullaway.codefix.ChatGPT.ask
Retrieving response from cache
11:53:26.534 TRACE edu.ucr.cs.riple.core.checkers.nullaway.codefix.Response.tryCreate
Trying to create Response:
```xml
<response>
    <reason><![CDATA[The nullability of Game.loop() depends on the context and implementation of the Game class which is not provided. If Game.loop() is guaranteed to be initialized before AbilityExecution is called, then it's not null; otherwise, it could be null.]]></reason>
    <value>UNKNOWN</value>
    <requests>
        <request><![CDATA[Provide the implementation of the Game class or details about how Game.loop() is initialized.]]></request>
    </requests>
</response>
```
11:53:26.534 TRACE edu.ucr.cs.riple.core.checkers.nullaway.codefix.Response.<init>
Creating Response:
```xml
<response>
    <reason><![CDATA[The nullability of Game.loop() depends on the context and implementation of the Game class which is not provided. If Game.loop() is guaranteed to be initialized before AbilityExecution is called, then it's not null; otherwise, it could be null.]]></reason>
    <value>UNKNOWN</value>
    <requests>
        <request><![CDATA[Provide the implementation of the Game class or details about how Game.loop() is initialized.]]></request>
    </requests>
</response>
```
11:53:26.534 TRACE edu.ucr.cs.riple.core.checkers.nullaway.codefix.Response.<init>
Response created:
Unknown: The nullability of Game.loop() depends on the context and implementation of the Game class which is not provided. If Game.loop() is guaranteed to be initialized before AbilityExecution is called, then it's not null; otherwise, it could be null.
11:53:26.535 TRACE edu.ucr.cs.riple.core.checkers.nullaway.codefix.AdvancedNullAwayCodeFix.resolveMethodDereferenceError
Resolving method dereference error.
11:53:26.535 TRACE edu.ucr.cs.riple.core.checkers.nullaway.codefix.AdvancedNullAwayCodeFix.resolveMethodDereferenceError
Method is in annotated package. Checking if the method is returning nullable.
11:53:26.535 TRACE edu.ucr.cs.riple.core.checkers.nullaway.codefix.AdvancedNullAwayCodeFix.investigateMethodReturnNullability
Checking if the method is returning nullable.
11:53:26.537 TRACE edu.ucr.cs.riple.core.checkers.nullaway.codefix.ChatGPT.checkIfMethodIsReturningNullable
Asking if the method is returning nullable: loop()
11:53:26.539 TRACE edu.ucr.cs.riple.core.checkers.nullaway.codefix.ChatGPT.ask
Asking ChatGPT:
In the method below, is there a possibility that the method returns null based only on its body? Consider the following points:

- The method may have multiple return paths; consider all return statements.
- If the method calls another method, do not assume its return value unless its full declaration is provided. Request its declaration if needed.
- The method may throw an exception instead of returning null. An exception path should not be considered a null return.
- Ensure you request the declarations of any methods whose return values directly or indirectly impact this methods return value before making a conclusion.
- Carefully analyze all conditions and prior operations that may guarantee a non-null return value.

@Nullable public static IGameLoop loop() {
    return gameLoop;
}

Here are the method definitions in addition to the method inquired:

Depth: 0
```java
class de.gurkenlabs.litiengine.Game {
@Nullable public static IGameLoop loop() {
    return gameLoop;
}
}
```


Response Format:
Provide the answer in **XML format** as follows:

#### If the method **cannot** return `null`:
```xml
<response>
  <reason><![CDATA[EXPLAIN WHY THE METHOD CANNOT RETURN NULL]]></reason>
  <value>NO</value>
</response>
```

#### If the method can return null:
```xml
<response>
  <reason><![CDATA[EXPLAIN WHY THE METHOD CAN RETURN NULL]]></reason>
  <value>YES</value>
</response>
```

#### If you are unsure or need more information, respond with where you can ask for more details or what specific information you need.

#### If you are unsure or If there are any methods that directly or indirectly affect the return value and are not fully disclosed, request their declarations first, in the following format:
<response>
  <reason><![CDATA[YOUR REASON]]></reason>
  <value>UNKNOWN</value>
  <methods>
    <method>methodName</method>
  </methods>
</response>

If additional information is required other than method declaration, list each request inside a `<request>` tag. If no additional information is needed, omit the `<requests>` section.

Respond with:
```xml
<response>
    <reason><![CDATA[YOUR REASON]]></reason>
    <value>UNKNOWN</value>
    <!-- Include <requests> only if additional information is needed -->
    <requests>
        <request><![CDATA[YOUR REQUEST 1]]></request>
        <request><![CDATA[YOUR REQUEST 2]]></request>
    </requests>
</response>
```

Additional Notes:
Be precise in your reasoning.
If a methods return value depends on another method not provided, request its declaration before making a conclusion.
If the method can return null in some cases but not others, explain under what conditions it can happen.

11:53:26.539 TRACE edu.ucr.cs.riple.core.checkers.nullaway.codefix.ChatGPT.ask
Retrieving response from cache
11:53:26.539 TRACE edu.ucr.cs.riple.core.checkers.nullaway.codefix.Response.tryCreate
Trying to create Response:
```xml
<response>
  <reason><![CDATA[The method `loop` returns the variable `gameLoop`. Without the initialization or assignment details of `gameLoop`, it's unclear whether it can be null. The possibility of `gameLoop` being uninitialized or set to null elsewhere in the program means `loop` could potentially return null. Further information on `gameLoop` is required.]]></reason>
  <value>UNKNOWN</value>
  <requests>
    <request><![CDATA[Please provide the declaration and initialization of the variable `gameLoop` in the class `de.gurkenlabs.litiengine.Game`.]]></request>
  </requests>
</response>
```
11:53:26.539 TRACE edu.ucr.cs.riple.core.checkers.nullaway.codefix.Response.<init>
Creating Response:
```xml
<response>
  <reason><![CDATA[The method `loop` returns the variable `gameLoop`. Without the initialization or assignment details of `gameLoop`, it's unclear whether it can be null. The possibility of `gameLoop` being uninitialized or set to null elsewhere in the program means `loop` could potentially return null. Further information on `gameLoop` is required.]]></reason>
  <value>UNKNOWN</value>
  <requests>
    <request><![CDATA[Please provide the declaration and initialization of the variable `gameLoop` in the class `de.gurkenlabs.litiengine.Game`.]]></request>
  </requests>
</response>
```
11:53:26.540 TRACE edu.ucr.cs.riple.core.checkers.nullaway.codefix.Response.<init>
Response created:
Unknown: The method `loop` returns the variable `gameLoop`. Without the initialization or assignment details of `gameLoop`, it's unclear whether it can be null. The possibility of `gameLoop` being uninitialized or set to null elsewhere in the program means `loop` could potentially return null. Further information on `gameLoop` is required.
11:53:26.540 TRACE edu.ucr.cs.riple.core.checkers.nullaway.codefix.AdvancedNullAwayCodeFix.investigateMethodReturnNullability
Could not determine the nullability and model did not ask for any method.
11:53:26.540 TRACE edu.ucr.cs.riple.core.checkers.nullaway.codefix.ChatGPT.checkIfMethodIsReturningNullableOnCallSite
Asking if the method is returning nullable on the call site: Game.loop()
11:53:26.781 TRACE edu.ucr.cs.riple.core.checkers.nullaway.codefix.ChatGPT.ask
Asking ChatGPT:
In the method below, is there a possibility that the method returns null at the given call site?

```java
@Nullable public static IGameLoop loop() {
    return gameLoop;
}
```

## Guidelines:
- The method may have multiple return paths; consider all return statements.
- If the method calls another method, do not assume its return value unless its full declaration is provided. Request its declaration if needed.
- The method may throw an exception instead of returning null. An exception path should not be considered a null return.
- Ensure you request the declarations of any methods whose return values directly or indirectly impact this methods return value before making a conclusion.
- If the method returns a value that is determined by a parameter, evaluate based on the actual argument at the given call site.
- Analyze based only on the specific invocation provided. Do not generalize to all possible inputs.- If the return value is guaranteed to be non-null at the call site, the answer should be a definitive NO.
- Do not generalize based on all possible inputsyour answer must be based only on the given invocation.
- Focus only on the given call site, not all possible invocations.

### call site:
Game.loop()

Here are the method definitions and the call chain for this method, showing the sequence of calls from the method to its callers at each depth level:

Depth: 0
```java
class de.gurkenlabs.litiengine.Game {
@Nullable public static IGameLoop loop() {
    return gameLoop;
}
}
```
Depth: 1
```java
class de.gurkenlabs.litiengine.environment.GameWorld {
public void loadEnvironment(@Nullable final Environment env) {
    Lock lock = Game.loop().getLock();
    lock.lock();
    try {
      unloadEnvironment();
      this.environment = env;
      if (env != null) {
        this.addEnvironment(env);

        if (env.getGravity() == 0 && this.gravity() != 0) {
          env.setGravity(this.gravity());
        }

        env.load();
        for (final EnvironmentLoadedListener listener : this.loadedListeners) {
          listener.loaded(env);
        }

        // call map specific listeners
        String mapName = getMapName(env);
        if (mapName != null && this.environmentLoadedListeners.containsKey(mapName)) {

          // for the default camera we center the camera on the environment
          if (this.camera().getClass().equals(Camera.class)) {
            camera().setFocus(env.getCenter());
          }

          for (EnvironmentLoadedListener listener : this.environmentLoadedListeners.get(mapName)) {
            listener.loaded(env);
          }
        }
      }
    } finally {
      lock.unlock();
    }
}public void setCamera(@Nullable final ICamera cam) {
    if (this.camera() != null) {
      Game.loop().detach(camera);
    }

    camera = cam;

    if (cam != null && !Game.isInNoGUIMode()) {
      Game.loop().attach(cam);
      cam.updateFocus();
    }
}
}
```
```java
class de.gurkenlabs.litiengine.entities.behavior.EntityNavigator {
public EntityNavigator(final IMobileEntity entity, final PathFinder pathFinder) {
    this.cancelNavigationConditions = new CopyOnWriteArrayList<>();
    this.listeners = new CopyOnWriteArrayList<>();
    this.entity = entity;
    this.pathFinder = pathFinder;
    this.setAcceptableError(DEFAULT_ACCEPTABLE_ERROR);
    Game.loop().attach(this);
}
}
```
```java
class de.gurkenlabs.litiengine.GameWindow {
private static void initializeWindowEventListeners(Window window) {

    window.addWindowStateListener(
        e -> {
          if (e.getNewState() == Frame.ICONIFIED) {
            Game.loop().setTickRate(ICONIFIED_MAX_FPS);
          } else {
            Game.loop().setTickRate(Game.config().client().getMaxFps());
          }
        });

    window.addWindowFocusListener(
        new WindowFocusListener() {
          @Override
          public void windowLostFocus(WindowEvent e) {
            if (Game.config().graphics().reduceFramesWhenNotFocused()) {
              Game.loop().setTickRate(NONE_FOCUS_MAX_FPS);
            }
          }

          @Override
          public void windowGainedFocus(WindowEvent e) {
            Game.loop().setTickRate(Game.config().client().getMaxFps());
          }
        });

    window.addWindowListener(
        new WindowAdapter() {
          @Override
          public void windowClosing(final WindowEvent event) {
            Game.exit();
          }
        });
}
}
```
```java
class de.gurkenlabs.litiengine.gui.screens.ScreenManager {
public void display(@Nullable final Screen screen) {
      if (Game.hasStarted() && Game.time().since(this.lastScreenChange) < this.getChangeCooldown()) {
        log.log(
            Level.INFO,
            "Skipping displaying of screen {0} because screen changing is currently on cooldown.",
            screen != null ? screen.getName() : "");
        return;
      }
  
      final Screen previous = this.current();
      if (previous != null) {
        previous.suspend();
      }
  
      if (screen != null && !this.screens.contains(screen)) {
        this.screens.add(screen);
      }
  
      this.currentScreen = screen;
      if (!Game.isInNoGUIMode() && this.current() != null) {
        this.current().prepare();
      }
  
      this.lastScreenChange = Nullability.castToNonnull(Game.loop(), "initialized before usage").getTicks();
  
      final ScreenChangedEvent event = new ScreenChangedEvent(this.current(), previous);
      for (final ScreenChangedListener listener : this.screenChangedListeners) {
        listener.changed(event);
      }
}
}
```
```java
class de.gurkenlabs.litiengine.abilities.effects.Effect {
@Override
  public void update() {

    for (final Iterator<EffectApplication> iterator = this.getActiveAppliances().iterator();
        iterator.hasNext(); ) {
      final EffectApplication appliance = iterator.next();
      // if the effect duration is reached
      if (this.hasEnded(appliance)) {

        iterator.remove();
        this.cease(appliance);
      }
    }

    // 4. unregister if all appliances are finished
    if (this.getActiveAppliances().isEmpty()) {
      Game.loop().detach(this);
    }
}public void apply(final Shape impactArea) {
    final List<ICombatEntity> affected = this.lookForAffectedEntities(impactArea);
    for (final ICombatEntity affectedEntity : affected) {
      this.apply(affectedEntity);
    }

    this.appliances.add(new EffectApplication(affected, impactArea));

    // if it is the first appliance -> register for update
    if (this.appliances.size() == 1) {
      Game.loop().attach(this);
    }
}
}
```
```java
class de.gurkenlabs.litiengine.GameTime {
public long toTicks(final int milliseconds) {
    return this.toTicks(milliseconds, Game.loop().getTickRate());
}public long since(final long tick) {
    return toMilliseconds(Game.loop().getTicks() - tick);
}public long now() {
    return Game.loop().getTicks();
}public long sinceGameStart() {
    return this.toMilliseconds(Game.loop().getTicks());
}@Override
  public void loaded(Environment environment) {
    environmentLoaded = Game.loop().getTicks();
}public long toMilliseconds(final long ticks) {
    return this.toMilliseconds(ticks, Game.loop().getTickRate());
}
}
```
```java
class de.gurkenlabs.litiengine.GameMetrics {
@Override
    public void render(final Graphics2D g) {
      this.updateMetrics();
  
      if (!Game.config().client().showGameMetrics()) {
        return;
      }
  
      this.currentOffsetY = 0;
  
      g.setColor(this.renderColor);
  
      // render client metrics
      this.drawTitle(g, "[client]");
      this.drawMetric(g, "fps       : " + this.getFramesPerSecond());
      this.drawMetric(g, "max fps   : " + this.maxFramesPerSecond);
  
      // Use Nullability.castToNonnull to prevent NullAway warning
      this.drawMetric(g, "updatables: " + Nullability.castToNonnull(Game.loop(), "gameLoop always initialized").getUpdatableCount());
  
      // render jvm metrics if debug is enabled
      if (Game.config().debug().isDebugEnabled()) {
        this.drawTitle(g, "[jvm]");
        this.drawMetric(g, "java      : " + this.javaVersion);
        this.drawMetric(g, "memory    : " + String.format("%-5.5s", this.usedMemory) + " MB");
        this.drawMetric(g, "threads   : " + Thread.activeCount());
      }
  
      // render rendering metrics
      if (!this.renderMetrics.isEmpty()) {
        this.drawTitle(g, "[update]");
  
        for (RenderMetrics metric : this.renderMetrics) {
          this.drawMetric(g, metric.toString());
        }
  
        this.renderMetrics.clear();
      }
}
}
```
```java
class de.gurkenlabs.litiengine.graphics.emitters.Emitter {
public void deactivate() {
    if (!this.activated) {
      return;
    }

    this.activated = false;
    this.getParticles().clear();
    this.aliveTime = 0;
    this.activationTick = 0;
    this.lastSpawn = 0;
    Game.loop().detach(this);
}public void activate() {
    if (this.activated) {
      return;
    }

    this.activated = true;
    this.activationTick = Game.time().now();
    Game.loop().attach(this);
}@Override
  public void update() {
    if (this.isPaused()) {
      return;
    }

    // clear particles if the effect time to life is reached
    if (this.isFinished()) {
      for (EmitterFinishedListener listener : this.finishedListeners) {
        listener.finished(this);
      }

      this.delete();
      return;
    }

    final float updateRatio = (float) this.data().getUpdateRate() / Game.loop().getTickRate();
    for (final Particle p : this.getParticles().stream().collect(Collectors.toList())) {
      if (this.particleCanBeRemoved(p)) {
        // remove dead particles
        this.particles.remove(p);
        continue;
      }

      p.update(this.getOrigin(), updateRatio);
    }

    this.aliveTime = Game.time().since(this.activationTick);
    if ((this.data().getSpawnRate() == 0
        || Game.time().since(this.lastSpawn) >= this.data().getSpawnRate())) {
      this.lastSpawn = Game.time().now();
      this.spawnParticle();
    }
}
}
```
```java
class de.gurkenlabs.litiengine.entities.behavior.IBehaviorController {
public default void attach() {
    Game.loop().attach(this);
}public default void detach() {
    Game.loop().detach(this);
}
}
```
```java
class de.gurkenlabs.litiengine.abilities.AbilityExecution {
AbilityExecution(final Ability ability) {
    this.appliedEffects = new CopyOnWriteArrayList<>();
    this.ability = ability;
    this.executionTicks = Game.time().now();
    this.impactArea = ability.calculateImpactArea();
    this.castLocation = ability.getExecutor().getCenter();
    Game.loop().attach(this);
}@Override
  public void update() {
    // if there a no effects to apply -> unregister this instance and we're done
    if (this.getAbility().getEffects().isEmpty()
        || this.getAbility().getEffects().size() == this.getAppliedEffects().size()) {
      Game.loop().detach(this);
      return;
    }

    // handle all effects from the ability that were not applied yet
    for (final Effect effect : this.getAbility().getEffects()) {
      // if the ability was not executed yet or the delay of the effect is not
      // yet reached
      if (this.getAppliedEffects().contains(effect)
          || Game.time().since(this.getExecutionTicks()) < effect.getDelay()) {
        continue;
      }

      effect.apply(this.getExecutionImpactArea());
      this.getAppliedEffects().add(effect);
    }
}
}
```
```java
class de.gurkenlabs.litiengine.GameWindow$3 {
@Override
          public void windowGainedFocus(WindowEvent e) {
            Game.loop().setTickRate(Game.config().client().getMaxFps());
}@Override
          public void windowLostFocus(WindowEvent e) {
            if (Game.config().graphics().reduceFramesWhenNotFocused()) {
              Game.loop().setTickRate(NONE_FOCUS_MAX_FPS);
            }
}
}
```
```java
class de.gurkenlabs.litiengine.environment.EntitySpawner {
protected void spawnNewEntities() {
    if (this.getSpawnMode() != SpawnMode.CUSTOMSPAWNPOINTS && this.getSpawnPoints().isEmpty()) {
      return;
    }

    switch (this.getSpawnMode()) {
      case ALLSPAWNPOINTS:
        for (int i = 0; i < this.getSpawnPoints().size(); i++) {
          final int index = i;
          Game.loop()
              .perform(
                  this.getSpawnDelay() + this.getSpawnDelay() * i,
                  () -> this.spawn(this.getSpawnPoints().get(index), this.getSpawnAmount()));
        }
        break;
      case ONERANDOMSPAWNPOINT:
        this.spawn(Game.random().choose(this.getSpawnPoints()), this.getSpawnAmount());
        break;
      case RANDOMSPAWNPOINTS:
        for (int i = 0; i < this.getSpawnAmount(); i++) {
          Game.loop()
              .perform(
                  this.getSpawnDelay() + this.getSpawnDelay() * i,
                  () -> this.spawn(Game.random().choose(this.getSpawnPoints()), 1));
        }
        break;
      case CUSTOMSPAWNPOINTS:
        List<Spawnpoint> spawnPoints =
            this.customSpawnpoints != null
                ? this.customSpawnpoints.apply(this)
                : this.getCustomSpawnpoints();

        int index = 0;
        for (Spawnpoint spawn : spawnPoints) {
          Game.loop()
              .perform(
                  this.getSpawnDelay() + this.getSpawnDelay() * index, () -> this.spawn(spawn, 1));
          index++;
        }
        break;
      default:
        break;
    }
}
}
```
```java
class de.gurkenlabs.litiengine.tweening.TweenEngine {
@Override
  public void start() {
    Game.loop().attach(this);
}@Override
  public void terminate() {
    Game.loop().detach(this);
}
}
```
```java
class de.gurkenlabs.litiengine.gui.SpeechBubble {
public void hide() {
    Game.world().environment().removeRenderable(this);
    Game.loop().detach(this);
    if (activeSpeechBubbles.get(this.getEntity()) != null
        && activeSpeechBubbles.remove(this.getEntity()).equals(this)) {
      activeSpeechBubbles.remove(this.getEntity());
    }

    for (SpeechBubbleListener listener : this.listeners) {
      listener.hidden();
    }
}private SpeechBubble(
      final IEntity entity,
      final String text,
      @Nullable SpeechBubbleAppearance appearance,
      @Nullable Font font) {
    if (appearance == null) {
      this.appearance = DEFAULT_APPEARANCE;
    } else {
      this.appearance = appearance;
    }

    final SpeechBubble active = activeSpeechBubbles.get(entity);
    if (active != null) {
      active.hide();
    }
    this.setFont(font);

    this.textBoxWidth = (float) (entity.getWidth() * 4);
    this.entity = entity;

    this.currentText = text;
    this.currentTextDisplayTime = DISPLAYTIME_MIN + text.length() * DISPLAYTIME_PER_LETTER;

    this.lastTextDisplay = Game.time().now();
    this.createBubbleImage();
    entity.getEnvironment().add(this, RenderType.UI);
    Game.loop().attach(this);
    activeSpeechBubbles.put(entity, this);
}
}
```
```java
class de.gurkenlabs.litiengine.entities.Prop {
private void updateAnimationController() {
    IEntityAnimationController<?> controller = this.createAnimationController();
    this.getControllers().addController(controller);
    if (Game.world().environment() != null && Game.world().environment().isLoaded()) {
      Game.loop().attach(controller);
    }
}
}
```
```java
class de.gurkenlabs.litiengine.graphics.FreeFlightCamera {
public FreeFlightCamera(final Point2D focus) {
    this.setFocus(focus);
    this.velocity = DEFAULT_SCROLL_PIXELS_PER_SECOND;
    this.scrollPadding = DEFAULT_SCROLL_PADDING;
    this.setClampToMap(true);

    Game.loop().attach(this);
}private void handleFreeFlightCamera() {
      if (Game.world().environment() == null || Game.world().environment().getMap() == null) {
        return;
      }
  
      final Point2D mouseLocation = Input.mouse().getLocation();
  
      final double scrollSpeed =
          this.getVelocity()
              / (double) Nullability.castToNonnull(Game.loop(), "gameLoop always initialized")
                  .getTickRate()
              * Game.config().input().getMouseSensitivity();
  
      double x = this.getFocus().getX();
      double y = this.getFocus().getY();
  
      double deltaX = 0;
      if (mouseLocation.getX() < this.getScrollPadding()) {
        deltaX -= scrollSpeed;
      } else if (Game.window().getResolution().getWidth() - mouseLocation.getX()
          < this.getScrollPadding()) {
        deltaX += scrollSpeed;
      }
  
      double deltaY = 0;
      if (mouseLocation.getY() < this.getScrollPadding()) {
        deltaY -= scrollSpeed;
      } else if (Game.window().getResolution().getHeight() - mouseLocation.getY()
          < this.getScrollPadding()) {
        deltaY += scrollSpeed;
      }
  
      x += deltaX;
      y += deltaY;
  
      this.setFocus(new Point2D.Double(x, y));
}
}
```
```java
class de.gurkenlabs.litiengine.environment.Environment {
private static void dispose(final Collection<? extends IEntity> entities) {
    for (final IEntity entity : entities) {
      if (entity instanceof IUpdateable) {
        Game.loop().detach((IUpdateable) entity);
      }

      entity.detachControllers();
    }
}private static void loadUpdatableOrEmitterEntity(IEntity entity) {
      if (entity instanceof Emitter) {
        final Emitter emitter = (Emitter) entity;
        if (emitter.isActivateOnInit()) {
          emitter.activate();
        }
      } else if (entity instanceof IUpdateable) {
        Nullability.castToNonnull(Game.loop(), "initialized through init").attach((IUpdateable) entity);
      }
}private void unload(final IEntity entity) {
    // 1. remove from physics engine
    if (entity instanceof ICollisionEntity) {
      Game.physics().remove((ICollisionEntity) entity);
    }

    // 2. unregister from update
    if (entity instanceof IUpdateable) {
      Game.loop().detach((IUpdateable) entity);
    }

    if (entity instanceof IMobileEntity) {
      this.removeGravity((IMobileEntity) entity);
    }

    // 3. detach all controllers
    entity.detachControllers();

    if (entity instanceof Emitter) {
      Emitter em = (Emitter) entity;
      em.deactivate();
    }

    if (this.loaded && (entity instanceof LightSource || entity instanceof StaticShadow)) {
      this.updateLighting(entity);
    }

    entity.removed(this);
}
}
```
```java
class de.gurkenlabs.litiengine.graphics.animation.Animation {
@Override
  public void update() {
    // do nothing if the animation is not playing or the current keyframe is not finished
    if (!this.isPlaying()
        || Game.time().since(this.lastFrameUpdate) < this.getCurrentKeyFrame().getDuration()) {
      return;
    }

    // if we are not looping and the last keyframe is finished, we terminate the animation
    if (!this.isLooping() && this.isLastKeyFrame()) {
      this.terminate();
      return;
    }

    // make sure, we stay inside the keyframe list
    final int newFrameIndex =
        (this.getKeyframes().indexOf(this.currentFrame) + 1) % this.getKeyframes().size();
    final KeyFrame previousFrame = this.currentFrame;
    this.currentFrame = this.getKeyframes().get(newFrameIndex);

    for (KeyFrameListener listener : this.listeners) {
      listener.currentFrameChanged(previousFrame, this.currentFrame);
    }

    this.lastFrameUpdate = Game.loop().getTicks();
}public void restart() {
    this.currentFrame = this.firstFrame;
    this.lastFrameUpdate = Game.loop().getTicks();
}
}
```
```java
class de.gurkenlabs.litiengine.physics.MovementController {
@Override
  public void attach() {
    Game.loop().attach(this);
}private void handleForces() {
    // clean up forces
    this.activeForces.forEach(
        x -> {
          if (x.hasEnded()) {
            this.activeForces.remove(x);
          }
        });

    if (this.activeForces.isEmpty()) {
      return;
    }

    // disable turn-on-move for force handling
    boolean turn = this.getEntity().turnOnMove();
    this.getEntity().setTurnOnMove(false);
    try {
      double deltaX = 0;
      double deltaY = 0;
      for (final Force force : this.activeForces) {
        if (force.cancelOnReached() && force.hasReached(this.getEntity())) {
          force.end();
          continue;
        }

        final Point2D collisionBoxCenter = this.getEntity().getCollisionBoxCenter();
        final double angle =
            GeometricUtilities.calcRotationAngleInDegrees(collisionBoxCenter, force.getLocation());
        final double strength =
            Game.loop().getDeltaTime() * 0.001f * force.getStrength() * Game.loop().getTimeScale();
        deltaX += GeometricUtilities.getDeltaX(angle, strength);
        deltaY += GeometricUtilities.getDeltaY(angle, strength);
      }

      final Point2D target =
          new Point2D.Double(this.getEntity().getX() + deltaX, this.getEntity().getY() + deltaY);
      final boolean success = Game.physics().move(this.getEntity(), target);
      if (!success) {
        for (final Force force : this.activeForces) {
          if (force.cancelOnCollision()) {
            force.end();
          }
        }
      }
    } finally {
      this.getEntity().setTurnOnMove(turn);
    }
}@Override
  public void detach() {
    Game.loop().detach(this);
}public void handleMovement() {
    if (!this.isMovementAllowed()) {
      this.velocity = 0;
      return;
    }

    // max distance an entity can travel within one tick
    final double maxPixelsPerTick = this.getEntity().getTickVelocity();
    final double deltaTime = Game.loop().getDeltaTime() * Game.loop().getTimeScale();

    final double acceleration =
        this.getEntity().getAcceleration() == 0
            ? maxPixelsPerTick
            : deltaTime / this.getEntity().getAcceleration() * maxPixelsPerTick;
    final double deceleration =
        this.getEntity().getDeceleration() == 0
            ? this.getVelocity()
            : deltaTime / this.getEntity().getDeceleration() * maxPixelsPerTick;

    double dx = this.getDx();
    double dy = this.getDy();
    this.setDx(0);
    this.setDy(0);

    final double deltaVelocity =
        Math.min(Math.sqrt(Math.pow(dx, 2) + Math.pow(dy, 2)), acceleration);
    if (deltaVelocity != 0) {
      double newVelocity = this.getVelocity() + deltaVelocity;
      this.setVelocity(newVelocity);
    } else {
      final double newVelocity = Math.max(0, this.getVelocity() - deceleration);
      this.setVelocity(newVelocity);
      dx = GeometricUtilities.getDeltaX(this.moveAngle);
      dy = GeometricUtilities.getDeltaY(this.moveAngle);
    }

    if (this.getVelocity() == 0) {
      this.moveAngle = 0;
      return;
    }

    // actually move entity
    this.moveEntity(dx, dy);
}
}
```
```java
class de.gurkenlabs.litiengine.graphics.animation.AnimationController {
public void detach() {
    Game.loop().detach(this);
}public void attach() {
    Game.loop().attach(this);
}
}
```
```java
class de.gurkenlabs.litiengine.graphics.Camera {
@Override
  public void setZoom(final float targetZoom, final int delay) {
    if (delay == 0) {

      this.zoom = targetZoom;
      this.targetZoom = 0;
      this.zoomDelay = 0;
      this.zoomTick = 0;
      this.zoomStep = 0;

      final ZoomChangedEvent event = new ZoomChangedEvent(this, targetZoom);
      for (final ZoomChangedListener listener : this.zoomListeners) {
        listener.zoomChanged(event);
      }
    } else {
      this.zoomTick = Game.time().now();
      this.targetZoom = targetZoom;
      this.zoomDelay = delay;

      final double tickduration = 1000 / (double) Game.loop().getTickRate();
      final double tickAmount = delay / tickduration;
      final float totalDelta = this.targetZoom - this.zoom;
      this.zoomStep = tickAmount > 0 ? (float) (totalDelta / tickAmount) : totalDelta;
    }
}
}
```
```java
class de.gurkenlabs.litiengine.Game {
public static synchronized void init(String... args) {
    if (initialized) {
      log().log(Level.INFO, "The game has already been initialized.");
      return;
    }

    log.init();
    handleCommandLineArguments(args);

    config().load();
    Locale.setDefault(new Locale(config().client().getCountry(), config().client().getLanguage()));

    gameLoop = new GameLoop("Main Update Loop", config().client().getMaxFps());
    loop().attach(physics());
    loop().attach(world());

    // setup default exception handling for render and update loop
    setUncaughtExceptionHandler(
        new DefaultUncaughtExceptionHandler(config().client().exitOnError()));

    screenManager = new ScreenManager();
    gameWindow = new GameWindow();

    // initialize  the game window
    window().init();
    world.setCamera(new Camera());

    for (GameListener listener : gameListeners) {
      listener.initialized(args);
    }

    if (!isInNoGUIMode()) {
      window().getRenderComponent().onRendered(g -> metrics().render(g));

      graphics()
          .addEntityRenderedListener(
              e -> DebugRenderer.renderEntityDebugInfo(e.getGraphics(), e.getEntity()));

      window().getRenderComponent().onFpsChanged(fps -> metrics().setFramesPerSecond(fps));
      window()
          .setIcons(
              Arrays.asList(
                  Resources.images().get("liti-logo-x16.png"),
                  Resources.images().get("liti-logo-x20.png"),
                  Resources.images().get("liti-logo-x32.png"),
                  Resources.images().get("liti-logo-x48.png")));

      Input.keyboard()
          .onKeyTyped(
              KeyEvent.VK_PRINTSCREEN,
              key -> {
                // don't take a screenshot if a modifier is active
                if (key.getModifiers() != 0) {
                  return;
                }

                window().getRenderComponent().takeScreenshot();
              });
    }

    Runtime.getRuntime().addShutdownHook(new Thread(Game::terminate, "Shutdown"));

    initialized = true;
}
}
```
```java
class de.gurkenlabs.litiengine.entities.Creature {
protected void updateAnimationController() {
        IEntityAnimationController<?> controller = this.createAnimationController();
        this.getControllers().addController(controller);
        if (Game.world().environment() != null && Game.world().environment().isLoaded()) {
            Nullability.castToNonnull(Game.loop(), "expected to be non-null").attach(controller);
        }
}@Override
  public float getTickVelocity() {
    // pixels per ms multiplied by the passed ms
    // ensure that entities don't travel too far in case of lag
    return Math.min(Game.loop().getDeltaTime(), GameLoop.TICK_DELTATIME_LAG)
        * 0.001F
        * this.getVelocity().get()
        * Game.loop().getTimeScale();
}
}
```
Depth: 2
```java
class de.gurkenlabs.litiengine.environment.GameWorld {
public void clear() {
    this.unloadEnvironment();
    this.environments.clear();
    this.setCamera(null);
    Game.physics().clear();

    this.environmentListeners.clear();
    this.environmentLoadedListeners.clear();
    this.environmentUnloadedListeners.clear();

    this.listeners.clear();
    this.loadedListeners.clear();
    this.unloadedListeners.clear();
}@Nullable
  public Environment loadEnvironment(IMap map) {
    Environment env = this.getEnvironment(map);
    this.loadEnvironment(env);
    return env;
}@Nullable
  public Environment loadEnvironment(String mapName) {
    Environment env = this.getEnvironment(mapName);
    this.loadEnvironment(env);
    return env;
}
}
```
```java
class de.gurkenlabs.litiengine.GameWindow {
GameWindow() {
    this.hostControl = new JFrame();

    this.resolutionChangedListeners = new CopyOnWriteArrayList<>();

    this.renderCanvas = new RenderComponent(Game.config().graphics().getResolution());
    this.cursor = new MouseCursor();
    if (!Game.isInNoGUIMode()) {
      this.hostControl.setBackground(Color.BLACK);
      this.hostControl.add(this.renderCanvas);

      this.initializeEventListeners();

      this.hostControl.setTitle(Game.info().getTitle());
      this.hostControl.setDefaultCloseOperation(WindowConstants.DO_NOTHING_ON_CLOSE);
      initializeWindowEventListeners(this.hostControl);
    }
}
}
```
```java
class de.gurkenlabs.litiengine.GameTime {
public long sinceEnvironmentLoad() {
    return this.since(this.environmentLoaded);
}public long since(final long tick) {
    return toMilliseconds(Game.loop().getTicks() - tick);
}public long sinceGameStart() {
    return this.toMilliseconds(Game.loop().getTicks());
}
}
```
```java
class de.gurkenlabs.litiengine.abilities.effects.Effect {
protected void cease(final EffectApplication appliance) {
    // 1. cease the effect for all affected entities
    for (final ICombatEntity entity : appliance.getAffectedEntities()) {
      this.cease(entity);
    }

    // 2. apply follow up effects
    this.getFollowUpEffects().forEach(followUp -> followUp.apply(appliance.getImpactArea()));
}protected boolean hasEnded(final EffectApplication appliance) {
    final long effectDuration = Game.time().since(appliance.getAppliedTicks());
    return effectDuration > this.getDuration();
}
}
```
```java
class de.gurkenlabs.litiengine.abilities.effects.EffectApplication {
protected EffectApplication(final List<ICombatEntity> affectedEntities, final Shape impactArea) {
    this.applied = Game.time().now();
    this.affectedEntities = affectedEntities;
    this.impactArea = impactArea;
}
}
```
```java
class de.gurkenlabs.litiengine.entities.CombatEntity {
@Override
  public boolean wasHit(int timeSpan) {
    return Game.time().since(this.lastHit) < timeSpan;
}@Override
  public void hit(final int damage, @Nullable final Ability ability) {
    if (this.isDead()) {
      return;
    }

    if (!this.isIndestructible()) {
      this.getHitPoints().modifyBaseValue(new AttributeModifier<>(Modification.SUBTRACT, damage));
    }

    final EntityHitEvent event = new EntityHitEvent(this, ability, damage, this.isDead());

    for (final CombatEntityListener listener : this.listeners) {
      listener.hit(event);
    }

    for (final CombatEntityHitListener listener : this.hitListeners) {
      listener.hit(event);
    }

    if (this.isDead()) {
      this.fireDeathEvent();
      this.setCollision(false);
    }

    this.lastHit = Game.time().now();
}
}
```
```java
class de.gurkenlabs.litiengine.graphics.ImageEffect {
protected ImageEffect(final int ttl, final String name) {
    this.ttl = ttl;
    this.name = name;
    this.aliveTick = Game.time().now();
}@Override
  public long getAliveTime() {
    return Game.time().since(this.aliveTick);
}
}
```
```java
class de.gurkenlabs.litiengine.abilities.AbilityExecution {
AbilityExecution(final Ability ability) {
    this.appliedEffects = new CopyOnWriteArrayList<>();
    this.ability = ability;
    this.executionTicks = Game.time().now();
    this.impactArea = ability.calculateImpactArea();
    this.castLocation = ability.getExecutor().getCenter();
    Game.loop().attach(this);
}@Override
  public void update() {
    // if there a no effects to apply -> unregister this instance and we're done
    if (this.getAbility().getEffects().isEmpty()
        || this.getAbility().getEffects().size() == this.getAppliedEffects().size()) {
      Game.loop().detach(this);
      return;
    }

    // handle all effects from the ability that were not applied yet
    for (final Effect effect : this.getAbility().getEffects()) {
      // if the ability was not executed yet or the delay of the effect is not
      // yet reached
      if (this.getAppliedEffects().contains(effect)
          || Game.time().since(this.getExecutionTicks()) < effect.getDelay()) {
        continue;
      }

      effect.apply(this.getExecutionImpactArea());
      this.getAppliedEffects().add(effect);
    }
}
}
```
```java
class de.gurkenlabs.litiengine.tweening.TweenEngine {
@Override
  public void update() {
    for (final Tweenable target : this.getTweens().keySet()) {
      for (final Tween tween : this.getTweens().get(target).values()) {
        if (tween.hasStopped()) {
          continue;
        }
        final long elapsed = Game.time().since(tween.getStartTime());
        if (elapsed >= tween.getDuration()) {
          tween.stop();
          continue;
        }
        final float[] currentValues = new float[tween.getTargetValues().length];
        for (int i = 0; i < tween.getTargetValues().length; i++) {
          currentValues[i] =
              tween.getStartValues()[i]
                  + tween.getEquation().compute(elapsed / (float) tween.getDuration())
                      * (tween.getTargetValues()[i] - tween.getStartValues()[i]);
        }
        tween.getTarget().setTweenValues(tween.getType(), currentValues);
      }
    }
}
}
```
```java
class de.gurkenlabs.litiengine.gui.SpeechBubble {
public static SpeechBubble create(
      final IEntity entity, final String text, SpeechBubbleAppearance appearance, Font font) {
    return new SpeechBubble(entity, text, appearance, font);
}public static SpeechBubble create(final IEntity entity, final Font font, final String text) {
    SpeechBubbleAppearance app =
        new SpeechBubbleAppearance(
            DEFAULT_APPEARANCE.getForeColor(),
            DEFAULT_APPEARANCE.getBackgroundColor1(),
            DEFAULT_APPEARANCE.getBorderColor(),
            DEFAULT_APPEARANCE.getPadding());
    return new SpeechBubble(entity, text, app, font);
}public static SpeechBubble create(final IEntity entity, final String text) {
    return new SpeechBubble(entity, text, null, GuiProperties.getDefaultFont());
}@Override
  public void update() {
    if (this.currentText == null) {
      this.hide();
      return;
    }

    this.entityCenter = Game.world().camera().getViewportLocation(this.getEntity().getCenter());

    // old text was displayed long enough
    if (this.lastTextDisplay != 0
        && Game.time().since(this.lastTextDisplay) > this.currentTextDisplayTime) {
      this.currentText = null;
      this.lastTextDisplay = 0;
      return;
    }

    // display new text
    if (this.textIndex < this.currentText.length()
        && Game.time().since(this.lastCharPoll) > LETTER_WRITE_DELAY) {
      this.textIndex++;
      this.lastCharPoll = Game.time().now();
      if (this.typeSound != null) {
        Game.audio().playSound(this.typeSound, this.getEntity());
      }
    }

    // continue displaying currently displayed text
}private SpeechBubble(
      final IEntity entity,
      final String text,
      final Sound typeSound,
      SpeechBubbleAppearance appearance,
      Font font) {
    this(entity, text, appearance, font);
    this.typeSound = typeSound;
}private SpeechBubble(
      final IEntity entity,
      final String text,
      @Nullable SpeechBubbleAppearance appearance,
      @Nullable Font font) {
    if (appearance == null) {
      this.appearance = DEFAULT_APPEARANCE;
    } else {
      this.appearance = appearance;
    }

    final SpeechBubble active = activeSpeechBubbles.get(entity);
    if (active != null) {
      active.hide();
    }
    this.setFont(font);

    this.textBoxWidth = (float) (entity.getWidth() * 4);
    this.entity = entity;

    this.currentText = text;
    this.currentTextDisplayTime = DISPLAYTIME_MIN + text.length() * DISPLAYTIME_PER_LETTER;

    this.lastTextDisplay = Game.time().now();
    this.createBubbleImage();
    entity.getEnvironment().add(this, RenderType.UI);
    Game.loop().attach(this);
    activeSpeechBubbles.put(entity, this);
}
}
```
```java
class de.gurkenlabs.litiengine.gui.TextFieldComponent {
@Override
  public void render(final Graphics2D g) {
    super.render(g);
    g.setFont(this.getFont());
    final FontMetrics fm = g.getFontMetrics();

    if (this.isSelected() && Game.time().since(this.lastToggled) > this.flickerDelay) {
      this.cursorVisible = !this.cursorVisible;
      this.lastToggled = Game.time().now();
    }
    if (this.isSelected() && this.cursorVisible) {
      final Rectangle2D cursor =
          new Rectangle2D.Double(
              this.getX() + this.getTextX() + fm.stringWidth(this.getTextToRender(g)),
              this.getY() + this.getTextY(),
              this.getFont().getSize2D() * 3 / 5,
              this.getFont().getSize2D() * 1 / 5);
      g.setColor(this.getAppearance().getForeColor());
      g.fill(cursor);
    }
}
}
```
```java
class de.gurkenlabs.litiengine.entities.Prop {
public Prop(
      final Point2D location, @Nullable final String spritesheetName, final Material material) {
    super();
    this.rotation = Rotation.NONE;
    this.spritesheetName = spritesheetName;
    this.material = material;
    this.setLocation(location);
    this.updateAnimationController();
}public void setSpritesheetName(@Nullable final String spriteName) {
    this.spritesheetName = spriteName;
    this.updateAnimationController();
}
}
```
```java
class de.gurkenlabs.litiengine.tweening.Tween {
public Tween begin() {
    this.started = Game.time().now();
    this.stopped = false;
    return this;
}
}
```
```java
class de.gurkenlabs.litiengine.graphics.emitters.particles.Particle {
public void update(final Point2D emitterOrigin, final float updateRatio) {
    if (this.aliveTick == 0) {
      this.aliveTick = Game.time().now();
    }

    this.aliveTime = Game.time().since(this.aliveTick);
    if (this.timeToLiveReached()) {
      return;
    }

    if (this.colliding) {
      return;
    }

    if (this.getDeltaWidth() != 0) {
      this.width += this.getDeltaWidth() * updateRatio;
    }

    if (this.getDeltaHeight() != 0) {
      this.height += this.getDeltaHeight() * updateRatio;
    }

    if (this.getDeltaAngle() != 0) {
      this.angle += this.getDeltaAngle() * updateRatio;
    }

    // test for ray cast collision
    final float targetX = this.x + this.getVelocityX() * updateRatio;
    final float targetY = this.y + this.getVelocityY() * updateRatio;

    if (targetX == this.x && targetY == this.y) {
      return;
    }

    if (this.checkForCollision(emitterOrigin, targetX, targetY)) {
      return;
    }

    if (this.getVelocityX() != 0) {
      this.x = targetX;
    }

    if (this.getVelocityY() != 0) {
      this.y = targetY;
    }

    if (this.getAccelerationX() != 0) {
      this.velocityX += this.getAccelerationX() * updateRatio;
    }

    if (this.getAccelerationY() != 0) {
      this.velocityY += this.getAccelerationY() * updateRatio;
    }
}
}
```
```java
class de.gurkenlabs.litiengine.graphics.animation.Animation {
@Override
  public void start() {
    this.playing = true;
    if (this.getKeyframes().isEmpty()) {
      return;
    }

    this.restart();
}@Override
  public void update() {
    // do nothing if the animation is not playing or the current keyframe is not finished
    if (!this.isPlaying()
        || Game.time().since(this.lastFrameUpdate) < this.getCurrentKeyFrame().getDuration()) {
      return;
    }

    // if we are not looping and the last keyframe is finished, we terminate the animation
    if (!this.isLooping() && this.isLastKeyFrame()) {
      this.terminate();
      return;
    }

    // make sure, we stay inside the keyframe list
    final int newFrameIndex =
        (this.getKeyframes().indexOf(this.currentFrame) + 1) % this.getKeyframes().size();
    final KeyFrame previousFrame = this.currentFrame;
    this.currentFrame = this.getKeyframes().get(newFrameIndex);

    for (KeyFrameListener listener : this.listeners) {
      listener.currentFrameChanged(previousFrame, this.currentFrame);
    }

    this.lastFrameUpdate = Game.loop().getTicks();
}
}
```
```java
class de.gurkenlabs.litiengine.graphics.animation.AnimationController {
@Override
  public void update() {
    for (final Animation animation : this.getAll()) {
      animation.update();
    }

    if (this.getCurrent() != null && this.getCurrent().isPaused()) {
      return;
    }

    final boolean playbackFinished = this.getCurrent() != null && !this.getCurrent().isPlaying();
    if (playbackFinished) {
      for (final AnimationListener listener : this.listeners) {
        listener.finished(this.getCurrent());
      }
    }

    if (this.getCurrent() == null || playbackFinished) {
      if (this.getDefault() != null) {
        this.play(this.getDefault().getName());
      } else {
        this.currentAnimation = null;
      }
    }
}
}
```
```java
class de.gurkenlabs.litiengine.graphics.RenderComponent {
private void handleFade() {
    if (this.fadeOutStart != -1) {
      final long timePassed = Game.time().since(this.fadeOutStart);
      this.currentAlpha = MathUtilities.clamp(1 - timePassed / (float) this.fadeOutTime, 0, 1);
      if (this.currentAlpha == 0f) {
        this.fadeOutStart = -1;
        this.fadeOutTime = -1;
      }

      return;
    }

    if (this.fadeInStart != -1) {
      final long timePassed = Game.time().since(this.fadeInStart);
      this.currentAlpha = MathUtilities.clamp(timePassed / (float) this.fadeInTime, 0, 1);
      if (this.currentAlpha == 1f) {
        this.fadeInStart = -1;
        this.fadeInTime = -1;
        this.currentAlpha = Float.NaN;
      }
    }
}public void fadeOut(final int ms) {
    this.fadeInStart = -1;
    this.fadeInTime = -1;
    this.fadeOutStart = Game.time().now();
    this.fadeOutTime = ms;
}public void fadeIn(final int ms) {
    this.fadeOutStart = -1;
    this.fadeOutTime = -1;
    this.fadeInStart = Game.time().now();
    this.fadeInTime = ms;
}
}
```
```java
class de.gurkenlabs.litiengine.entities.Trigger {
private boolean activate(final IEntity activator, final int tar) {
    if (!this.isLoaded()
        || this.isOneTimeTrigger && this.isActivated
        || this.getActivationType() == TriggerActivation.COLLISION
            && activator != null
            && this.collisionActivated.contains(activator)) {
      return false;
    }

    if (this.getCooldown() > 0 && Game.time().since(this.lastActivation) < this.getCooldown()) {
      return false;
    }

    List<Integer> triggerTargets = this.getTargets(tar);

    final TriggerEvent te = new TriggerEvent(this, activator, triggerTargets);

    if (!this.checkActivationPredicates(te)) {
      return false;
    }

    this.isActivated = true;
    if (activator != null) {
      this.collisionActivated.add(activator);
    }

    // if we actually have a trigger target, we send the message to the target
    for (final int target : triggerTargets) {
      final IEntity entity = this.getEnvironment().get(target);
      if (entity == null) {
        log.log(
            Level.WARNING,
            "trigger [{0}] was activated, but the trigger target [{1}] could not be found on the environment",
            new Object[] {this, target});
        continue;
      }

      entity.sendMessage(this, this.message);
    }

    // also send the trigger event to all registered consumers
    for (final TriggerActivatedListener listener : this.activatedListeners) {
      listener.activated(te);
    }

    if (this.isOneTimeTrigger) {
      this.getEnvironment().remove(this);
    }

    this.lastActivation = Game.time().now();
    return true;
}
}
```
```java
class de.gurkenlabs.litiengine.graphics.Camera {
private boolean isShakeEffectActive() {
    return this.getShakeTick() != 0
        && Game.time().since(this.getShakeTick()) < this.getShakeDuration();
}@Override
  public void update() {
    if (Game.world().camera() != null && !Game.world().camera().equals(this)) {
      return;
    }

    if (this.targetZoom > 0) {
      if (Game.time().since(this.zoomTick) >= this.zoomDelay) {
        this.zoom = this.targetZoom;
        this.targetZoom = 0;
        this.zoomDelay = 0;
        this.zoomTick = 0;
        this.zoomStep = 0;
      } else {
        this.zoom += this.zoomStep;
      }

      final ZoomChangedEvent event = new ZoomChangedEvent(this, this.getZoom());
      for (final ZoomChangedListener listener : this.zoomListeners) {
        listener.zoomChanged(event);
      }
    }

    if (this.panTime > 0) {
      if (--this.panTime <= 0) {
        this.setFocus(this.targetFocus);
        this.targetFocus = null;
      } else {
        double diff = this.panTime / (this.panTime + 1.0);
        this.focus =
            new Point2D.Double(
                this.focus.getX() * diff + this.targetFocus.getX() * (1.0 - diff),
                this.focus.getY() * diff + this.targetFocus.getY() * (1.0 - diff));
      }
    }

    if (!this.isShakeEffectActive()) {
      this.shakeOffsetX = 0;
      this.shakeOffsetY = 0;
      return;
    }

    if (Game.time().since(this.lastShake) > this.shakeDelay) {
      this.shakeOffsetX = this.getShakeIntensity() * ThreadLocalRandom.current().nextGaussian();
      this.shakeOffsetY = this.getShakeIntensity() * ThreadLocalRandom.current().nextGaussian();
      this.lastShake = Game.time().now();
    }
}@Override
  public void setZoom(final float targetZoom, final int delay) {
    if (delay == 0) {

      this.zoom = targetZoom;
      this.targetZoom = 0;
      this.zoomDelay = 0;
      this.zoomTick = 0;
      this.zoomStep = 0;

      final ZoomChangedEvent event = new ZoomChangedEvent(this, targetZoom);
      for (final ZoomChangedListener listener : this.zoomListeners) {
        listener.zoomChanged(event);
      }
    } else {
      this.zoomTick = Game.time().now();
      this.targetZoom = targetZoom;
      this.zoomDelay = delay;

      final double tickduration = 1000 / (double) Game.loop().getTickRate();
      final double tickAmount = delay / tickduration;
      final float totalDelta = this.targetZoom - this.zoom;
      this.zoomStep = tickAmount > 0 ? (float) (totalDelta / tickAmount) : totalDelta;
    }
}@Override
  public void shake(final double intensity, final int delay, final int shakeDuration) {
    this.shakeTick = Game.time().now();
    this.shakeDelay = delay;
    this.shakeIntensity = intensity;
    this.shakeDuration = shakeDuration;
}
}
```
```java
class de.gurkenlabs.litiengine.entities.Creature {
public void setSpritesheetName(String spritesheetName) {
    if (this.spritesheetName != null && this.spritesheetName.equals(spritesheetName)) {
      return;
    }

    this.spritesheetName = spritesheetName;
    this.updateAnimationController();
}public boolean isIdle() {
    return Game.time().since(this.lastMoved) > IDLE_DELAY;
}@Override
  public void setLocation(final Point2D position) {
    if (this.isDead() || position == null) {
      return;
    }

    final Point2D oldLocation = this.getLocation();
    super.setLocation(position);

    if (Game.hasStarted() && this.isLoaded()) {
      this.lastMoved = Game.time().now();
      this.fireMovedEvent(
          new EntityMovedEvent(
              this, this.getX() - oldLocation.getX(), this.getY() - oldLocation.getY()));
    }
}
}
```
```java
class de.gurkenlabs.litiengine.gui.screens.ScreenManager {
public void display(final String screenName) {
    if (this.current() != null && this.current().getName().equalsIgnoreCase(screenName)) {
      log.log(
          Level.INFO,
          "Skipping displaying of screen {0} because it is already the current screen.",
          screenName);
      return;
    }

    if (this.screens.stream()
        .noneMatch(element -> element.getName().equalsIgnoreCase(screenName))) {
      log.log(
          Level.WARNING,
          "Could not display the screen {0} because there is no screen with the specified name.",
          screenName);
      return;
    }

    Screen screen = this.get(screenName);
    if (screen == null) {
      return;
    }

    this.display(screen);
}public void add(final Screen screen) {
    screen.setWidth(Game.window().getWidth());
    screen.setHeight(Game.window().getHeight());
    this.screens.add(screen);

    if (this.current() == null) {
      this.display(screen);
    }
}public void remove(Screen screen) {
    this.screens.remove(screen);
    if (this.current() == screen) {
      if (!this.screens.isEmpty()) {
        this.display(this.screens.get(0));
      } else {
        this.display((Screen) null);
      }
    }
}public void display(@Nullable final Screen screen) {
      if (Game.hasStarted() && Game.time().since(this.lastScreenChange) < this.getChangeCooldown()) {
        log.log(
            Level.INFO,
            "Skipping displaying of screen {0} because screen changing is currently on cooldown.",
            screen != null ? screen.getName() : "");
        return;
      }
  
      final Screen previous = this.current();
      if (previous != null) {
        previous.suspend();
      }
  
      if (screen != null && !this.screens.contains(screen)) {
        this.screens.add(screen);
      }
  
      this.currentScreen = screen;
      if (!Game.isInNoGUIMode() && this.current() != null) {
        this.current().prepare();
      }
  
      this.lastScreenChange = Nullability.castToNonnull(Game.loop(), "initialized before usage").getTicks();
  
      final ScreenChangedEvent event = new ScreenChangedEvent(this.current(), previous);
      for (final ScreenChangedListener listener : this.screenChangedListeners) {
        listener.changed(event);
      }
}
}
```
```java
class de.gurkenlabs.litiengine.abilities.Ability {
public boolean isOnCooldown() {
    return (this.getCurrentExecution() != null
        && this.getCurrentExecution().getExecutionTicks() > 0
        && Game.time().since(this.getCurrentExecution().getExecutionTicks())
            < this.getAttributes().cooldown().get());
}public boolean isActive() {
    return this.getCurrentExecution() != null
        && Game.time().since(this.getCurrentExecution().getExecutionTicks())
            < this.getAttributes().duration().get();
}@Nullable
  public AbilityExecution cast() {
    if (!this.canCast()) {
      return null;
    }
    this.currentExecution = new AbilityExecution(this);

    for (final AbilityCastListener listener : this.abilityCastListeners) {
      listener.abilityCast(this.currentExecution);
    }

    return this.getCurrentExecution();
}public float getRemainingCooldownInSeconds() {
    if (this.getCurrentExecution() == null
        || this.getExecutor() == null
        || this.getExecutor().isDead()) {
      return 0;
    }

    // calculate cooldown in seconds
    return (float)
        (!this.canCast()
            ? (this.getAttributes().cooldown().get()
                    - Game.time().since(this.getCurrentExecution().getExecutionTicks()))
                * 0.001
            : 0);
}
}
```
```java
class de.gurkenlabs.litiengine.entities.EntityHitEvent {
EntityHitEvent(
      final ICombatEntity hitEntity,
      @Nullable final Ability ability,
      final int damage,
      final boolean kill) {
    super(hitEntity);
    this.executor = ability != null ? ability.getExecutor() : null;
    this.hitEntity = hitEntity;
    this.ability = ability;
    this.damage = damage;
    this.kill = kill;
    this.time = Game.time().now();
}
}
```
```java
class de.gurkenlabs.litiengine.graphics.emitters.Emitter {
public void delete() {
    this.deactivate();
    if (Game.world().environment() != null) {
      Game.world().environment().remove(this);
    }
}public void activate() {
    if (this.activated) {
      return;
    }

    this.activated = true;
    this.activationTick = Game.time().now();
    Game.loop().attach(this);
}@Override
  public void update() {
    if (this.isPaused()) {
      return;
    }

    // clear particles if the effect time to life is reached
    if (this.isFinished()) {
      for (EmitterFinishedListener listener : this.finishedListeners) {
        listener.finished(this);
      }

      this.delete();
      return;
    }

    final float updateRatio = (float) this.data().getUpdateRate() / Game.loop().getTickRate();
    for (final Particle p : this.getParticles().stream().collect(Collectors.toList())) {
      if (this.particleCanBeRemoved(p)) {
        // remove dead particles
        this.particles.remove(p);
        continue;
      }

      p.update(this.getOrigin(), updateRatio);
    }

    this.aliveTime = Game.time().since(this.activationTick);
    if ((this.data().getSpawnRate() == 0
        || Game.time().since(this.lastSpawn) >= this.data().getSpawnRate())) {
      this.lastSpawn = Game.time().now();
      this.spawnParticle();
    }
}
}
```
```java
class de.gurkenlabs.litiengine.GameLoop {
@Override
  public int perform(int delay, Runnable action) {
    final long d = Game.time().toTicks(delay);

    TimedAction a = new TimedAction(this.getTicks() + d, action);
    this.actions.add(a);

    return a.getId();
}
}
```
```java
class de.gurkenlabs.litiengine.environment.EntitySpawner {
protected boolean shouldSpawn() {
    return this.lastSpawnWave == 0
        || Game.time().since(this.lastSpawnWave) >= this.getSpawnInterval();
}@Override
  public void update() {
    if (!this.shouldSpawn()) {
      return;
    }

    this.spawnNewEntities();
    this.lastSpawnWave = Game.time().now();
}
}
```
```java
class de.gurkenlabs.litiengine.graphics.FreeFlightCamera {
@Override
  public void update() {
    this.handleFreeFlightCamera();
}public FreeFlightCamera(double x, double y) {
    this(new Point2D.Double(x, y));
}
}
```
```java
class de.gurkenlabs.litiengine.environment.Environment {
public void unload() {
    if (!this.loaded) {
      return;
    }

    // unregister all updatable entities from the current environment
    for (final IEntity entity : this.allEntities.values()) {
      this.unload(entity);
    }

    this.loaded = false;
    this.fireEvent(l -> l.unloaded(this));
}private static void loadUpdatableOrEmitterEntity(IEntity entity) {
      if (entity instanceof Emitter) {
        final Emitter emitter = (Emitter) entity;
        if (emitter.isActivateOnInit()) {
          emitter.activate();
        }
      } else if (entity instanceof IUpdateable) {
        Nullability.castToNonnull(Game.loop(), "initialized through init").attach((IUpdateable) entity);
      }
}public void clear() {
    Game.physics().clear();

    this.combatEntities.clear();
    this.mobileEntities.clear();
    this.gravityForces.clear();
    this.layerEntities.clear();
    this.entitiesByTag.clear();
    this.allEntities.clear();

    for (RenderType renderType : RenderType.values()) {
      this.miscEntities.get(renderType).clear();
      this.renderListeners.get(renderType).clear();
      this.renderables.get(renderType).clear();
    }

    dispose(this.allEntities.values());
    dispose(this.triggers);
    this.emitters.clear();
    this.colliders.clear();
    this.props.clear();
    this.creatures.clear();
    this.staticShadows.clear();
    this.combatEntities.clear();
    this.mobileEntities.clear();
    this.lightSources.clear();
    this.spawnPoints.clear();
    this.soundSources.clear();
    this.mapAreas.clear();
    this.triggers.clear();

    this.ambientLight = null;
    this.staticShadowLayer = null;

    for (Map<Integer, IEntity> type : this.miscEntities.values()) {
      type.clear();
    }

    this.initialized = false;

    this.fireEvent(l -> l.cleared(this));
}private void load(final IEntity entity) {
    // an entity can only exist on one environment at a time, so remove it from the current one
    if (entity.getEnvironment() != null) {
      entity.getEnvironment().remove(entity);
    }

    // 1. add to physics engine
    loadPhysicsEntity(entity);

    // 2. register for update or activate
    loadUpdatableOrEmitterEntity(entity);

    // 3. if a gravity is defined, add a gravity force to the entity
    if (entity instanceof IMobileEntity && this.getGravity() != 0) {
      this.addGravityForce((IMobileEntity) entity);
    }

    // 4. attach all controllers
    entity.attachControllers();

    if (this.loaded && (entity instanceof LightSource || entity instanceof StaticShadow)) {
      this.updateLighting(entity);
    }

    entity.loaded(this);
}private void unload(final IEntity entity) {
    // 1. remove from physics engine
    if (entity instanceof ICollisionEntity) {
      Game.physics().remove((ICollisionEntity) entity);
    }

    // 2. unregister from update
    if (entity instanceof IUpdateable) {
      Game.loop().detach((IUpdateable) entity);
    }

    if (entity instanceof IMobileEntity) {
      this.removeGravity((IMobileEntity) entity);
    }

    // 3. detach all controllers
    entity.detachControllers();

    if (entity instanceof Emitter) {
      Emitter em = (Emitter) entity;
      em.deactivate();
    }

    if (this.loaded && (entity instanceof LightSource || entity instanceof StaticShadow)) {
      this.updateLighting(entity);
    }

    entity.removed(this);
}public void remove(final IEntity entity) {
    if (entity == null) {
      return;
    }

    this.allEntities.remove(entity.getMapId());
    Iterator<List<IEntity>> iter = this.layerEntities.values().iterator();
    while (iter.hasNext()) {
      List<IEntity> layer = iter.next();
      if (layer.remove(entity) && layer.isEmpty()) {
        iter.remove();
      }
    }
    if (this.miscEntities.get(entity.getRenderType()) != null) {
      this.miscEntities.get(entity.getRenderType()).values().remove(entity);
    }

    for (String tag : entity.getTags()) {
      if (this.getEntitiesByTag().containsKey(tag)) {
        this.getEntitiesByTag().get(tag).remove(entity);

        if (this.getEntitiesByTag().get(tag).isEmpty()) {
          this.getEntitiesByTag().remove(tag);
        }
      }
    }

    if (entity instanceof Emitter) {
      Emitter emitter = (Emitter) entity;
      this.removeEmitter(emitter);
    }

    if (entity instanceof MapArea) {
      this.mapAreas.remove(entity);
    }

    if (entity instanceof Prop) {
      this.props.remove(entity);
    }

    if (entity instanceof Creature) {
      this.creatures.remove(entity);
    }

    if (entity instanceof CollisionBox) {
      this.colliders.remove(entity);
      this.staticShadows.removeIf(x -> x.getOrigin() != null && x.getOrigin().equals(entity));
    }

    if (entity instanceof LightSource) {
      this.lightSources.remove(entity);
      this.updateLighting(entity);
    }

    if (entity instanceof Trigger) {
      this.triggers.remove(entity);
    }

    if (entity instanceof Spawnpoint) {
      this.spawnPoints.remove(entity);
    }
    if (entity instanceof SoundSource) {
      this.soundSources.remove(entity);
    }

    if (entity instanceof StaticShadow) {
      this.staticShadows.remove(entity);
      this.updateLighting(entity);
    }

    if (entity instanceof IMobileEntity) {
      this.mobileEntities.values().remove(entity);
    }

    if (entity instanceof ICombatEntity) {
      this.combatEntities.values().remove(entity);
    }

    this.unload(entity);

    this.fireEntityEvent(l -> l.entityRemoved(entity));
}
}
```
```java
class de.gurkenlabs.litiengine.physics.MovementController {
@Override
  public void update() {
    this.handleForces();
    this.handleMovement();
}
}
```
```java
class de.gurkenlabs.litiengine.Game {
static synchronized void terminate() {
        if (!initialized || gameLoop == null) {
          return;
        }
    
        hasStarted = false;
        initialized = false;
    
        config().save();
        gameLoop.terminate();
        tweenEngine.terminate();
        soundEngine.terminate();
    
        world().clear();
    
        for (final GameListener listener : gameListeners) {
          try {
            listener.terminated();
          } catch (Exception e) {
            log().log(Level.WARNING, "game listener threw an exception during shutdown", e);
          }
        }
    
        gameLoop = null;
        screenManager = null;
        gameWindow = null;
}public static synchronized void start() {
          if (!initialized) {
              throw new IllegalStateException(
                  "The game cannot be started without being first initialized. Call Game.init(...) before Game.start().");
          }
    
          if (gameLoop == null) {
              throw new IllegalStateException(
                  "Game loop is not initialized. Ensure Game.init(...) has been called successfully.");
          }
          
          Nullability.castToNonnull(gameLoop, "gameLoop cannot be null").start();
          tweenEngine.start();
          soundEngine.start();
    
          for (final GameListener listener : gameListeners) {
              listener.started();
          }
    
          hasStarted = true;
}public static synchronized void init(String... args) {
    if (initialized) {
      log().log(Level.INFO, "The game has already been initialized.");
      return;
    }

    log.init();
    handleCommandLineArguments(args);

    config().load();
    Locale.setDefault(new Locale(config().client().getCountry(), config().client().getLanguage()));

    gameLoop = new GameLoop("Main Update Loop", config().client().getMaxFps());
    loop().attach(physics());
    loop().attach(world());

    // setup default exception handling for render and update loop
    setUncaughtExceptionHandler(
        new DefaultUncaughtExceptionHandler(config().client().exitOnError()));

    screenManager = new ScreenManager();
    gameWindow = new GameWindow();

    // initialize  the game window
    window().init();
    world.setCamera(new Camera());

    for (GameListener listener : gameListeners) {
      listener.initialized(args);
    }

    if (!isInNoGUIMode()) {
      window().getRenderComponent().onRendered(g -> metrics().render(g));

      graphics()
          .addEntityRenderedListener(
              e -> DebugRenderer.renderEntityDebugInfo(e.getGraphics(), e.getEntity()));

      window().getRenderComponent().onFpsChanged(fps -> metrics().setFramesPerSecond(fps));
      window()
          .setIcons(
              Arrays.asList(
                  Resources.images().get("liti-logo-x16.png"),
                  Resources.images().get("liti-logo-x20.png"),
                  Resources.images().get("liti-logo-x32.png"),
                  Resources.images().get("liti-logo-x48.png")));

      Input.keyboard()
          .onKeyTyped(
              KeyEvent.VK_PRINTSCREEN,
              key -> {
                // don't take a screenshot if a modifier is active
                if (key.getModifiers() != 0) {
                  return;
                }

                window().getRenderComponent().takeScreenshot();
              });
    }

    Runtime.getRuntime().addShutdownHook(new Thread(Game::terminate, "Shutdown"));

    initialized = true;
}
}
```


Response Format:
Provide the answer in **XML format** as follows:

#### If the method **cannot** return `null` at the specific call site:
```xml
<response>
  <reason><![CDATA[EXPLAIN WHY THE INVOCATION Game.loop() RESULT CANNOT BE NULL.]]></reason>
  <value>NO</value>
</response>

#### If the method can return null at the specific call site:
<response>
  <reason><![CDATA[EXPLAIN WHY THE INVOCATION Game.loop() RESULT CAN BE NULL.]]></reason>
  <value>YES</value>
</response>

#### If you are unsure or If there are any methods that directly or indirectly affect the return value and are not fully disclosed, request their declarations first, in the following format:
<response>
  <reason><![CDATA[EXPLAIN WHY THIS METHOD DECLARATION IS NECESSARY AND WHY YOU CANNOT MAKE A CONFIDENT DECISION WITHOUT IT]]></reason>
  <success>false</success>
  <methods>
    <method>methodName</method>
  </methods>
</response>

Additional Notes:
Be precise in your reasoning.
If a methods return value depends on another method not provided, request its declaration before making a conclusion.
If the method can return null in this case but not in others, explain why it happens specifically for this call.

11:53:26.783 TRACE edu.ucr.cs.riple.core.checkers.nullaway.codefix.ChatGPT.ask
Retrieving response from cache
11:53:26.783 TRACE edu.ucr.cs.riple.core.checkers.nullaway.codefix.Response.tryCreate
Trying to create Response:
```xml
<response>
  <reason><![CDATA[The `Game.loop()` method returns the static field `gameLoop`. In the code provided, `gameLoop` is initialized in the `init()` method of the `de.gurkenlabs.litiengine.Game` class. This method assigns a new `GameLoop` object to `gameLoop`. The game initialization process must be completed with a call to `Game.init(...)` prior to starting the game with `Game.start()`. If the `Game` has been correctly initialized by calling `Game.init(..., args)` before any invocation of `Game.loop()`, the `gameLoop` field will be non-null. The method relies on this initialization process, ensuring `gameLoop` is not null when the game is properly set up. Therefore, under normal circumstances where `Game.init(...)` is properly invoked before other methods that use `Game.loop()`, `gameLoop` cannot be null at the call site in `GameWorld.loadEnvironment()`.]]></reason>
  <value>NO</value>
</response>
```
11:53:26.783 TRACE edu.ucr.cs.riple.core.checkers.nullaway.codefix.Response.<init>
Creating Response:
```xml
<response>
  <reason><![CDATA[The `Game.loop()` method returns the static field `gameLoop`. In the code provided, `gameLoop` is initialized in the `init()` method of the `de.gurkenlabs.litiengine.Game` class. This method assigns a new `GameLoop` object to `gameLoop`. The game initialization process must be completed with a call to `Game.init(...)` prior to starting the game with `Game.start()`. If the `Game` has been correctly initialized by calling `Game.init(..., args)` before any invocation of `Game.loop()`, the `gameLoop` field will be non-null. The method relies on this initialization process, ensuring `gameLoop` is not null when the game is properly set up. Therefore, under normal circumstances where `Game.init(...)` is properly invoked before other methods that use `Game.loop()`, `gameLoop` cannot be null at the call site in `GameWorld.loadEnvironment()`.]]></reason>
  <value>NO</value>
</response>
```
11:53:26.783 TRACE edu.ucr.cs.riple.core.checkers.nullaway.codefix.Response.<init>
Response created:
Disagreement: The `Game.loop()` method returns the static field `gameLoop`. In the code provided, `gameLoop` is initialized in the `init()` method of the `de.gurkenlabs.litiengine.Game` class. This method assigns a new `GameLoop` object to `gameLoop`. The game initialization process must be completed with a call to `Game.init(...)` prior to starting the game with `Game.start()`. If the `Game` has been correctly initialized by calling `Game.init(..., args)` before any invocation of `Game.loop()`, the `gameLoop` field will be non-null. The method relies on this initialization process, ensuring `gameLoop` is not null when the game is properly set up. Therefore, under normal circumstances where `Game.init(...)` is properly invoked before other methods that use `Game.loop()`, `gameLoop` cannot be null at the call site in `GameWorld.loadEnvironment()`.
11:53:26.783 TRACE edu.ucr.cs.riple.core.checkers.nullaway.codefix.AdvancedNullAwayCodeFix.resolveMethodDereferenceError
Method is not returning nullable on call site. Injecting suppression annotation.
11:53:26.783 TRACE edu.ucr.cs.riple.core.checkers.nullaway.codefix.AdvancedNullAwayCodeFix.constructCastToNonnullChange
Constructing cast to nonnull change for reason: The `Game.loop()` method returns the static field `gameLoop`. In the code provided, `gameLoop` is initialized in the `init()` method of the `de.gurkenlabs.litiengine.Game` class. This method assigns a new `GameLoop` object to `gameLoop`. The game initialization process must be completed with a call to `Game.init(...)` prior to starting the game with `Game.start()`. If the `Game` has been correctly initialized by calling `Game.init(..., args)` before any invocation of `Game.loop()`, the `gameLoop` field will be non-null. The method relies on this initialization process, ensuring `gameLoop` is not null when the game is properly set up. Therefore, under normal circumstances where `Game.init(...)` is properly invoked before other methods that use `Game.loop()`, `gameLoop` cannot be null at the call site in `GameWorld.loadEnvironment()`.
11:53:26.784 TRACE edu.ucr.cs.riple.core.checkers.nullaway.codefix.ChatGPT.ask
Asking ChatGPT:
For the reason you mentioned earlier:

"The `Game.loop()` method returns the static field `gameLoop`. In the code provided, `gameLoop` is initialized in the `init()` method of the `de.gurkenlabs.litiengine.Game` class. This method assigns a new `GameLoop` object to `gameLoop`. The game initialization process must be completed with a call to `Game.init(...)` prior to starting the game with `Game.start()`. If the `Game` has been correctly initialized by calling `Game.init(..., args)` before any invocation of `Game.loop()`, the `gameLoop` field will be non-null. The method relies on this initialization process, ensuring `gameLoop` is not null when the game is properly set up. Therefore, under normal circumstances where `Game.init(...)` is properly invoked before other methods that use `Game.loop()`, `gameLoop` cannot be null at the call site in `GameWorld.loadEnvironment()`."

in the method below, the expression Game.loop() is not nullable at the point it is used.

```java
AbilityExecution(final Ability ability) {
    this.appliedEffects = new CopyOnWriteArrayList<>();
    this.ability = ability;
    this.executionTicks = Game.time().now();
    this.impactArea = ability.calculateImpactArea();
    this.castLocation = ability.getExecutor().getCenter();
    Game.loop().attach(this);
}
```
Please Summarize the reason in max 5 words and rewrite the method so that at the line "    Game.loop().attach(this);", at the occurrence of: "Game.loop()" is replaced with `Nullability.castToNonnull(Game.loop(), summary of reason)`
Replace "REASON" with the exact reason summary I provide to you (maximum 5 words), not with a generic explanation like "checked to be nonnull".
see the example below, for expression `foo.getBar()`, to wrap it with `Nullability.castToNonnull(foo.getBar(), "reason")`.

```java
public t(){
    String l = foo.getBar();
}
```

will be:
```java
public t(){
    String l = Nullability.castToNonnull(foo.getBar(), "checked to be nonnull");
}
```

### Instructions:

Do not import any additional classes.

Do not add Java comments.

Only modify relevant lines as required.

Return only the modified method wrapped in the XML format shown below.

Place the Java code inside the <code> tag using a CDATA block with ```java formatting.

Just give me the fixed code snippet in XML format in <response> tag like the example below. I will apply the fix to my codebase. Do not import any additional libraries or classes or add java comments. If you can provide the fixed code snippet, please provide it in the following format and place the code snippet in the <code> tag within ```java block.
<response>
  <success>true</success>
  <code><![CDATA[
  ```java
  Your fixed code snippet here
  ```
    ]]>
  </code>
</response>

11:53:26.784 TRACE edu.ucr.cs.riple.core.checkers.nullaway.codefix.ChatGPT.ask
Retrieving response from cache
11:53:26.784 TRACE edu.ucr.cs.riple.core.checkers.nullaway.codefix.Response.tryCreate
Trying to create Response:
<response>
  <success>true</success>
  <code><![CDATA[
  ```java
  AbilityExecution(final Ability ability) {
      this.appliedEffects = new CopyOnWriteArrayList<>();
      this.ability = ability;
      this.executionTicks = Game.time().now();
      this.impactArea = ability.calculateImpactArea();
      this.castLocation = ability.getExecutor().getCenter();
      Nullability.castToNonnull(Game.loop(), "proper initialization done").attach(this);
  }
  ```
    ]]>
  </code>
</response>
11:53:26.784 TRACE edu.ucr.cs.riple.core.checkers.nullaway.codefix.Response.<init>
Creating Response:
<response>
  <success>true</success>
  <code><![CDATA[
  ```java
  AbilityExecution(final Ability ability) {
      this.appliedEffects = new CopyOnWriteArrayList<>();
      this.ability = ability;
      this.executionTicks = Game.time().now();
      this.impactArea = ability.calculateImpactArea();
      this.castLocation = ability.getExecutor().getCenter();
      Nullability.castToNonnull(Game.loop(), "proper initialization done").attach(this);
  }
  ```
    ]]>
  </code>
</response>
11:53:26.785 TRACE edu.ucr.cs.riple.core.checkers.nullaway.codefix.Response.<init>
Response created:
AbilityExecution(final Ability ability) {
      this.appliedEffects = new CopyOnWriteArrayList<>();
      this.ability = ability;
      this.executionTicks = Game.time().now();
      this.impactArea = ability.calculateImpactArea();
      this.castLocation = ability.getExecutor().getCenter();
      Nullability.castToNonnull(Game.loop(), "proper initialization done").attach(this);
  }
11:53:26.785 TRACE edu.ucr.cs.riple.core.checkers.nullaway.codefix.ChatGPT.fixDereferenceByAddingCastToNonnull
Fixing the error by adding castToNonnull
11:53:26.786 TRACE edu.ucr.cs.riple.core.checkers.nullaway.codefix.AdvancedNullAwayCodeFix.fixTriggeredErrorsForLocation
Resolving unresolvable error for triggered error: Type='DEREFERENCE_NULLABLE', message='dereferenced expression Game.loop() is @Nullable'
/home/nima/Developer/nullness-benchmarks/litiengine/src/de/gurkenlabs/litiengine/physics/MovementController.java:31
    Game.loop().attach(this);
11:53:26.786 TRACE edu.ucr.cs.riple.core.checkers.nullaway.codefix.AdvancedNullAwayCodeFix.fix
Fixing error: Type='DEREFERENCE_NULLABLE', message='dereferenced expression Game.loop() is @Nullable'
/home/nima/Developer/nullness-benchmarks/litiengine/src/de/gurkenlabs/litiengine/physics/MovementController.java:31
    Game.loop().attach(this);
11:53:26.786 TRACE edu.ucr.cs.riple.core.checkers.nullaway.codefix.AdvancedNullAwayCodeFix.resolveDereferenceError
Resolving dereference error: Type='DEREFERENCE_NULLABLE', message='dereferenced expression Game.loop() is @Nullable'
/home/nima/Developer/nullness-benchmarks/litiengine/src/de/gurkenlabs/litiengine/physics/MovementController.java:31
    Game.loop().attach(this);
11:53:26.786 TRACE edu.ucr.cs.riple.core.checkers.nullaway.codefix.AdvancedNullAwayCodeFix.resolveDereferenceError
Checking nullability possibility at error point
11:53:26.787 TRACE edu.ucr.cs.riple.core.checkers.nullaway.codefix.ChatGPT.checkNullabilityPossibilityAtErrorPoint
Asking if the expression can be null at error point point
11:53:26.787 TRACE edu.ucr.cs.riple.core.checkers.nullaway.codefix.ChatGPT.ask
Asking ChatGPT:
In the method below, is there a possibility that the expression "Game.loop()" at line "Game.loop().attach(this);" is null?
@Override
  public void attach() {
    Game.loop().attach(this);
}
Give a single-word answer in XML format. If it is possible for the expression to be null, respond with:
```xml
<response>
    <reason><![CDATA[YOUR REASON]]></reason>
    <value>YES</value>
</response>
```
If it is not possible for the expression to be null, respond with:
```xml
<response>
    <reason><![CDATA[YOUR REASON]]></reason>
    <value>NO</value>
</response>
```
If you are unsure or need more information, respond with where you can ask for more details or what specific information you need.

If additional information is required, list each request inside a `<request>` tag. If no additional information is needed, omit the `<requests>` section.

Respond with:
```xml
<response>
    <reason><![CDATA[YOUR REASON]]></reason>
    <value>UNKNOWN</value>
    <!-- Include <requests> only if additional information is needed -->
    <requests>
        <request><![CDATA[YOUR REQUEST 1]]></request>
        <request><![CDATA[YOUR REQUEST 2]]></request>
    </requests>
</response>
```
11:53:26.787 TRACE edu.ucr.cs.riple.core.checkers.nullaway.codefix.ChatGPT.ask
Retrieving response from cache
11:53:26.787 TRACE edu.ucr.cs.riple.core.checkers.nullaway.codefix.Response.tryCreate
Trying to create Response:
```xml
<response>
    <reason><![CDATA[Without additional information on the implementation details of the Game class and its loop method, it is unclear if Game.loop() can return null.]]></reason>
    <value>UNKNOWN</value>
    <requests>
        <request><![CDATA[Provide the implementation or documentation of the Game.loop() method.]]></request>
        <request><![CDATA[Clarify if there are conditions under which Game.loop() is expected to return null.]]></request>
    </requests>
</response>
```
11:53:26.787 TRACE edu.ucr.cs.riple.core.checkers.nullaway.codefix.Response.<init>
Creating Response:
```xml
<response>
    <reason><![CDATA[Without additional information on the implementation details of the Game class and its loop method, it is unclear if Game.loop() can return null.]]></reason>
    <value>UNKNOWN</value>
    <requests>
        <request><![CDATA[Provide the implementation or documentation of the Game.loop() method.]]></request>
        <request><![CDATA[Clarify if there are conditions under which Game.loop() is expected to return null.]]></request>
    </requests>
</response>
```
11:53:26.788 TRACE edu.ucr.cs.riple.core.checkers.nullaway.codefix.Response.<init>
Response created:
Unknown: Without additional information on the implementation details of the Game class and its loop method, it is unclear if Game.loop() can return null.
11:53:26.789 TRACE edu.ucr.cs.riple.core.checkers.nullaway.codefix.AdvancedNullAwayCodeFix.resolveMethodDereferenceError
Resolving method dereference error.
11:53:26.789 TRACE edu.ucr.cs.riple.core.checkers.nullaway.codefix.AdvancedNullAwayCodeFix.resolveMethodDereferenceError
Method is in annotated package. Checking if the method is returning nullable.
11:53:26.789 TRACE edu.ucr.cs.riple.core.checkers.nullaway.codefix.AdvancedNullAwayCodeFix.investigateMethodReturnNullability
Checking if the method is returning nullable.
11:53:26.791 TRACE edu.ucr.cs.riple.core.checkers.nullaway.codefix.ChatGPT.checkIfMethodIsReturningNullable
Asking if the method is returning nullable: loop()
11:53:26.793 TRACE edu.ucr.cs.riple.core.checkers.nullaway.codefix.ChatGPT.ask
Asking ChatGPT:
In the method below, is there a possibility that the method returns null based only on its body? Consider the following points:

- The method may have multiple return paths; consider all return statements.
- If the method calls another method, do not assume its return value unless its full declaration is provided. Request its declaration if needed.
- The method may throw an exception instead of returning null. An exception path should not be considered a null return.
- Ensure you request the declarations of any methods whose return values directly or indirectly impact this methods return value before making a conclusion.
- Carefully analyze all conditions and prior operations that may guarantee a non-null return value.

@Nullable public static IGameLoop loop() {
    return gameLoop;
}

Here are the method definitions in addition to the method inquired:

Depth: 0
```java
class de.gurkenlabs.litiengine.Game {
@Nullable public static IGameLoop loop() {
    return gameLoop;
}
}
```


Response Format:
Provide the answer in **XML format** as follows:

#### If the method **cannot** return `null`:
```xml
<response>
  <reason><![CDATA[EXPLAIN WHY THE METHOD CANNOT RETURN NULL]]></reason>
  <value>NO</value>
</response>
```

#### If the method can return null:
```xml
<response>
  <reason><![CDATA[EXPLAIN WHY THE METHOD CAN RETURN NULL]]></reason>
  <value>YES</value>
</response>
```

#### If you are unsure or need more information, respond with where you can ask for more details or what specific information you need.

#### If you are unsure or If there are any methods that directly or indirectly affect the return value and are not fully disclosed, request their declarations first, in the following format:
<response>
  <reason><![CDATA[YOUR REASON]]></reason>
  <value>UNKNOWN</value>
  <methods>
    <method>methodName</method>
  </methods>
</response>

If additional information is required other than method declaration, list each request inside a `<request>` tag. If no additional information is needed, omit the `<requests>` section.

Respond with:
```xml
<response>
    <reason><![CDATA[YOUR REASON]]></reason>
    <value>UNKNOWN</value>
    <!-- Include <requests> only if additional information is needed -->
    <requests>
        <request><![CDATA[YOUR REQUEST 1]]></request>
        <request><![CDATA[YOUR REQUEST 2]]></request>
    </requests>
</response>
```

Additional Notes:
Be precise in your reasoning.
If a methods return value depends on another method not provided, request its declaration before making a conclusion.
If the method can return null in some cases but not others, explain under what conditions it can happen.

11:53:26.793 TRACE edu.ucr.cs.riple.core.checkers.nullaway.codefix.ChatGPT.ask
Retrieving response from cache
11:53:26.793 TRACE edu.ucr.cs.riple.core.checkers.nullaway.codefix.Response.tryCreate
Trying to create Response:
```xml
<response>
  <reason><![CDATA[The method `loop` returns the variable `gameLoop`. Without the initialization or assignment details of `gameLoop`, it's unclear whether it can be null. The possibility of `gameLoop` being uninitialized or set to null elsewhere in the program means `loop` could potentially return null. Further information on `gameLoop` is required.]]></reason>
  <value>UNKNOWN</value>
  <requests>
    <request><![CDATA[Please provide the declaration and initialization of the variable `gameLoop` in the class `de.gurkenlabs.litiengine.Game`.]]></request>
  </requests>
</response>
```
11:53:26.793 TRACE edu.ucr.cs.riple.core.checkers.nullaway.codefix.Response.<init>
Creating Response:
```xml
<response>
  <reason><![CDATA[The method `loop` returns the variable `gameLoop`. Without the initialization or assignment details of `gameLoop`, it's unclear whether it can be null. The possibility of `gameLoop` being uninitialized or set to null elsewhere in the program means `loop` could potentially return null. Further information on `gameLoop` is required.]]></reason>
  <value>UNKNOWN</value>
  <requests>
    <request><![CDATA[Please provide the declaration and initialization of the variable `gameLoop` in the class `de.gurkenlabs.litiengine.Game`.]]></request>
  </requests>
</response>
```
11:53:26.794 TRACE edu.ucr.cs.riple.core.checkers.nullaway.codefix.Response.<init>
Response created:
Unknown: The method `loop` returns the variable `gameLoop`. Without the initialization or assignment details of `gameLoop`, it's unclear whether it can be null. The possibility of `gameLoop` being uninitialized or set to null elsewhere in the program means `loop` could potentially return null. Further information on `gameLoop` is required.
11:53:26.794 TRACE edu.ucr.cs.riple.core.checkers.nullaway.codefix.AdvancedNullAwayCodeFix.investigateMethodReturnNullability
Could not determine the nullability and model did not ask for any method.
11:53:26.794 TRACE edu.ucr.cs.riple.core.checkers.nullaway.codefix.ChatGPT.checkIfMethodIsReturningNullableOnCallSite
Asking if the method is returning nullable on the call site: Game.loop()
11:53:27.034 TRACE edu.ucr.cs.riple.core.checkers.nullaway.codefix.ChatGPT.ask
Asking ChatGPT:
In the method below, is there a possibility that the method returns null at the given call site?

```java
@Nullable public static IGameLoop loop() {
    return gameLoop;
}
```

## Guidelines:
- The method may have multiple return paths; consider all return statements.
- If the method calls another method, do not assume its return value unless its full declaration is provided. Request its declaration if needed.
- The method may throw an exception instead of returning null. An exception path should not be considered a null return.
- Ensure you request the declarations of any methods whose return values directly or indirectly impact this methods return value before making a conclusion.
- If the method returns a value that is determined by a parameter, evaluate based on the actual argument at the given call site.
- Analyze based only on the specific invocation provided. Do not generalize to all possible inputs.- If the return value is guaranteed to be non-null at the call site, the answer should be a definitive NO.
- Do not generalize based on all possible inputsyour answer must be based only on the given invocation.
- Focus only on the given call site, not all possible invocations.

### call site:
Game.loop()

Here are the method definitions and the call chain for this method, showing the sequence of calls from the method to its callers at each depth level:

Depth: 0
```java
class de.gurkenlabs.litiengine.Game {
@Nullable public static IGameLoop loop() {
    return gameLoop;
}
}
```
Depth: 1
```java
class de.gurkenlabs.litiengine.environment.GameWorld {
public void loadEnvironment(@Nullable final Environment env) {
    Lock lock = Game.loop().getLock();
    lock.lock();
    try {
      unloadEnvironment();
      this.environment = env;
      if (env != null) {
        this.addEnvironment(env);

        if (env.getGravity() == 0 && this.gravity() != 0) {
          env.setGravity(this.gravity());
        }

        env.load();
        for (final EnvironmentLoadedListener listener : this.loadedListeners) {
          listener.loaded(env);
        }

        // call map specific listeners
        String mapName = getMapName(env);
        if (mapName != null && this.environmentLoadedListeners.containsKey(mapName)) {

          // for the default camera we center the camera on the environment
          if (this.camera().getClass().equals(Camera.class)) {
            camera().setFocus(env.getCenter());
          }

          for (EnvironmentLoadedListener listener : this.environmentLoadedListeners.get(mapName)) {
            listener.loaded(env);
          }
        }
      }
    } finally {
      lock.unlock();
    }
}public void setCamera(@Nullable final ICamera cam) {
    if (this.camera() != null) {
      Game.loop().detach(camera);
    }

    camera = cam;

    if (cam != null && !Game.isInNoGUIMode()) {
      Game.loop().attach(cam);
      cam.updateFocus();
    }
}
}
```
```java
class de.gurkenlabs.litiengine.entities.behavior.EntityNavigator {
public EntityNavigator(final IMobileEntity entity, final PathFinder pathFinder) {
    this.cancelNavigationConditions = new CopyOnWriteArrayList<>();
    this.listeners = new CopyOnWriteArrayList<>();
    this.entity = entity;
    this.pathFinder = pathFinder;
    this.setAcceptableError(DEFAULT_ACCEPTABLE_ERROR);
    Game.loop().attach(this);
}
}
```
```java
class de.gurkenlabs.litiengine.GameWindow {
private static void initializeWindowEventListeners(Window window) {

    window.addWindowStateListener(
        e -> {
          if (e.getNewState() == Frame.ICONIFIED) {
            Game.loop().setTickRate(ICONIFIED_MAX_FPS);
          } else {
            Game.loop().setTickRate(Game.config().client().getMaxFps());
          }
        });

    window.addWindowFocusListener(
        new WindowFocusListener() {
          @Override
          public void windowLostFocus(WindowEvent e) {
            if (Game.config().graphics().reduceFramesWhenNotFocused()) {
              Game.loop().setTickRate(NONE_FOCUS_MAX_FPS);
            }
          }

          @Override
          public void windowGainedFocus(WindowEvent e) {
            Game.loop().setTickRate(Game.config().client().getMaxFps());
          }
        });

    window.addWindowListener(
        new WindowAdapter() {
          @Override
          public void windowClosing(final WindowEvent event) {
            Game.exit();
          }
        });
}
}
```
```java
class de.gurkenlabs.litiengine.gui.screens.ScreenManager {
public void display(@Nullable final Screen screen) {
      if (Game.hasStarted() && Game.time().since(this.lastScreenChange) < this.getChangeCooldown()) {
        log.log(
            Level.INFO,
            "Skipping displaying of screen {0} because screen changing is currently on cooldown.",
            screen != null ? screen.getName() : "");
        return;
      }
  
      final Screen previous = this.current();
      if (previous != null) {
        previous.suspend();
      }
  
      if (screen != null && !this.screens.contains(screen)) {
        this.screens.add(screen);
      }
  
      this.currentScreen = screen;
      if (!Game.isInNoGUIMode() && this.current() != null) {
        this.current().prepare();
      }
  
      this.lastScreenChange = Nullability.castToNonnull(Game.loop(), "initialized before usage").getTicks();
  
      final ScreenChangedEvent event = new ScreenChangedEvent(this.current(), previous);
      for (final ScreenChangedListener listener : this.screenChangedListeners) {
        listener.changed(event);
      }
}
}
```
```java
class de.gurkenlabs.litiengine.abilities.effects.Effect {
@Override
  public void update() {

    for (final Iterator<EffectApplication> iterator = this.getActiveAppliances().iterator();
        iterator.hasNext(); ) {
      final EffectApplication appliance = iterator.next();
      // if the effect duration is reached
      if (this.hasEnded(appliance)) {

        iterator.remove();
        this.cease(appliance);
      }
    }

    // 4. unregister if all appliances are finished
    if (this.getActiveAppliances().isEmpty()) {
      Game.loop().detach(this);
    }
}public void apply(final Shape impactArea) {
    final List<ICombatEntity> affected = this.lookForAffectedEntities(impactArea);
    for (final ICombatEntity affectedEntity : affected) {
      this.apply(affectedEntity);
    }

    this.appliances.add(new EffectApplication(affected, impactArea));

    // if it is the first appliance -> register for update
    if (this.appliances.size() == 1) {
      Game.loop().attach(this);
    }
}
}
```
```java
class de.gurkenlabs.litiengine.GameTime {
public long toTicks(final int milliseconds) {
    return this.toTicks(milliseconds, Game.loop().getTickRate());
}public long since(final long tick) {
    return toMilliseconds(Game.loop().getTicks() - tick);
}public long now() {
    return Game.loop().getTicks();
}public long sinceGameStart() {
    return this.toMilliseconds(Game.loop().getTicks());
}@Override
  public void loaded(Environment environment) {
    environmentLoaded = Game.loop().getTicks();
}public long toMilliseconds(final long ticks) {
    return this.toMilliseconds(ticks, Game.loop().getTickRate());
}
}
```
```java
class de.gurkenlabs.litiengine.GameMetrics {
@Override
    public void render(final Graphics2D g) {
      this.updateMetrics();
  
      if (!Game.config().client().showGameMetrics()) {
        return;
      }
  
      this.currentOffsetY = 0;
  
      g.setColor(this.renderColor);
  
      // render client metrics
      this.drawTitle(g, "[client]");
      this.drawMetric(g, "fps       : " + this.getFramesPerSecond());
      this.drawMetric(g, "max fps   : " + this.maxFramesPerSecond);
  
      // Use Nullability.castToNonnull to prevent NullAway warning
      this.drawMetric(g, "updatables: " + Nullability.castToNonnull(Game.loop(), "gameLoop always initialized").getUpdatableCount());
  
      // render jvm metrics if debug is enabled
      if (Game.config().debug().isDebugEnabled()) {
        this.drawTitle(g, "[jvm]");
        this.drawMetric(g, "java      : " + this.javaVersion);
        this.drawMetric(g, "memory    : " + String.format("%-5.5s", this.usedMemory) + " MB");
        this.drawMetric(g, "threads   : " + Thread.activeCount());
      }
  
      // render rendering metrics
      if (!this.renderMetrics.isEmpty()) {
        this.drawTitle(g, "[update]");
  
        for (RenderMetrics metric : this.renderMetrics) {
          this.drawMetric(g, metric.toString());
        }
  
        this.renderMetrics.clear();
      }
}
}
```
```java
class de.gurkenlabs.litiengine.graphics.emitters.Emitter {
public void deactivate() {
    if (!this.activated) {
      return;
    }

    this.activated = false;
    this.getParticles().clear();
    this.aliveTime = 0;
    this.activationTick = 0;
    this.lastSpawn = 0;
    Game.loop().detach(this);
}public void activate() {
    if (this.activated) {
      return;
    }

    this.activated = true;
    this.activationTick = Game.time().now();
    Game.loop().attach(this);
}@Override
  public void update() {
    if (this.isPaused()) {
      return;
    }

    // clear particles if the effect time to life is reached
    if (this.isFinished()) {
      for (EmitterFinishedListener listener : this.finishedListeners) {
        listener.finished(this);
      }

      this.delete();
      return;
    }

    final float updateRatio = (float) this.data().getUpdateRate() / Game.loop().getTickRate();
    for (final Particle p : this.getParticles().stream().collect(Collectors.toList())) {
      if (this.particleCanBeRemoved(p)) {
        // remove dead particles
        this.particles.remove(p);
        continue;
      }

      p.update(this.getOrigin(), updateRatio);
    }

    this.aliveTime = Game.time().since(this.activationTick);
    if ((this.data().getSpawnRate() == 0
        || Game.time().since(this.lastSpawn) >= this.data().getSpawnRate())) {
      this.lastSpawn = Game.time().now();
      this.spawnParticle();
    }
}
}
```
```java
class de.gurkenlabs.litiengine.entities.behavior.IBehaviorController {
public default void attach() {
    Game.loop().attach(this);
}public default void detach() {
    Game.loop().detach(this);
}
}
```
```java
class de.gurkenlabs.litiengine.abilities.AbilityExecution {
AbilityExecution(final Ability ability) {
        this.appliedEffects = new CopyOnWriteArrayList<>();
        this.ability = ability;
        this.executionTicks = Game.time().now();
        this.impactArea = ability.calculateImpactArea();
        this.castLocation = ability.getExecutor().getCenter();
        Nullability.castToNonnull(Game.loop(), "proper initialization done").attach(this);
}@Override
  public void update() {
    // if there a no effects to apply -> unregister this instance and we're done
    if (this.getAbility().getEffects().isEmpty()
        || this.getAbility().getEffects().size() == this.getAppliedEffects().size()) {
      Game.loop().detach(this);
      return;
    }

    // handle all effects from the ability that were not applied yet
    for (final Effect effect : this.getAbility().getEffects()) {
      // if the ability was not executed yet or the delay of the effect is not
      // yet reached
      if (this.getAppliedEffects().contains(effect)
          || Game.time().since(this.getExecutionTicks()) < effect.getDelay()) {
        continue;
      }

      effect.apply(this.getExecutionImpactArea());
      this.getAppliedEffects().add(effect);
    }
}
}
```
```java
class de.gurkenlabs.litiengine.GameWindow$3 {
@Override
          public void windowGainedFocus(WindowEvent e) {
            Game.loop().setTickRate(Game.config().client().getMaxFps());
}@Override
          public void windowLostFocus(WindowEvent e) {
            if (Game.config().graphics().reduceFramesWhenNotFocused()) {
              Game.loop().setTickRate(NONE_FOCUS_MAX_FPS);
            }
}
}
```
```java
class de.gurkenlabs.litiengine.environment.EntitySpawner {
protected void spawnNewEntities() {
    if (this.getSpawnMode() != SpawnMode.CUSTOMSPAWNPOINTS && this.getSpawnPoints().isEmpty()) {
      return;
    }

    switch (this.getSpawnMode()) {
      case ALLSPAWNPOINTS:
        for (int i = 0; i < this.getSpawnPoints().size(); i++) {
          final int index = i;
          Game.loop()
              .perform(
                  this.getSpawnDelay() + this.getSpawnDelay() * i,
                  () -> this.spawn(this.getSpawnPoints().get(index), this.getSpawnAmount()));
        }
        break;
      case ONERANDOMSPAWNPOINT:
        this.spawn(Game.random().choose(this.getSpawnPoints()), this.getSpawnAmount());
        break;
      case RANDOMSPAWNPOINTS:
        for (int i = 0; i < this.getSpawnAmount(); i++) {
          Game.loop()
              .perform(
                  this.getSpawnDelay() + this.getSpawnDelay() * i,
                  () -> this.spawn(Game.random().choose(this.getSpawnPoints()), 1));
        }
        break;
      case CUSTOMSPAWNPOINTS:
        List<Spawnpoint> spawnPoints =
            this.customSpawnpoints != null
                ? this.customSpawnpoints.apply(this)
                : this.getCustomSpawnpoints();

        int index = 0;
        for (Spawnpoint spawn : spawnPoints) {
          Game.loop()
              .perform(
                  this.getSpawnDelay() + this.getSpawnDelay() * index, () -> this.spawn(spawn, 1));
          index++;
        }
        break;
      default:
        break;
    }
}
}
```
```java
class de.gurkenlabs.litiengine.tweening.TweenEngine {
@Override
  public void start() {
    Game.loop().attach(this);
}@Override
  public void terminate() {
    Game.loop().detach(this);
}
}
```
```java
class de.gurkenlabs.litiengine.gui.SpeechBubble {
public void hide() {
    Game.world().environment().removeRenderable(this);
    Game.loop().detach(this);
    if (activeSpeechBubbles.get(this.getEntity()) != null
        && activeSpeechBubbles.remove(this.getEntity()).equals(this)) {
      activeSpeechBubbles.remove(this.getEntity());
    }

    for (SpeechBubbleListener listener : this.listeners) {
      listener.hidden();
    }
}private SpeechBubble(
      final IEntity entity,
      final String text,
      @Nullable SpeechBubbleAppearance appearance,
      @Nullable Font font) {
    if (appearance == null) {
      this.appearance = DEFAULT_APPEARANCE;
    } else {
      this.appearance = appearance;
    }

    final SpeechBubble active = activeSpeechBubbles.get(entity);
    if (active != null) {
      active.hide();
    }
    this.setFont(font);

    this.textBoxWidth = (float) (entity.getWidth() * 4);
    this.entity = entity;

    this.currentText = text;
    this.currentTextDisplayTime = DISPLAYTIME_MIN + text.length() * DISPLAYTIME_PER_LETTER;

    this.lastTextDisplay = Game.time().now();
    this.createBubbleImage();
    entity.getEnvironment().add(this, RenderType.UI);
    Game.loop().attach(this);
    activeSpeechBubbles.put(entity, this);
}
}
```
```java
class de.gurkenlabs.litiengine.entities.Prop {
private void updateAnimationController() {
    IEntityAnimationController<?> controller = this.createAnimationController();
    this.getControllers().addController(controller);
    if (Game.world().environment() != null && Game.world().environment().isLoaded()) {
      Game.loop().attach(controller);
    }
}
}
```
```java
class de.gurkenlabs.litiengine.graphics.FreeFlightCamera {
public FreeFlightCamera(final Point2D focus) {
    this.setFocus(focus);
    this.velocity = DEFAULT_SCROLL_PIXELS_PER_SECOND;
    this.scrollPadding = DEFAULT_SCROLL_PADDING;
    this.setClampToMap(true);

    Game.loop().attach(this);
}private void handleFreeFlightCamera() {
      if (Game.world().environment() == null || Game.world().environment().getMap() == null) {
        return;
      }
  
      final Point2D mouseLocation = Input.mouse().getLocation();
  
      final double scrollSpeed =
          this.getVelocity()
              / (double) Nullability.castToNonnull(Game.loop(), "gameLoop always initialized")
                  .getTickRate()
              * Game.config().input().getMouseSensitivity();
  
      double x = this.getFocus().getX();
      double y = this.getFocus().getY();
  
      double deltaX = 0;
      if (mouseLocation.getX() < this.getScrollPadding()) {
        deltaX -= scrollSpeed;
      } else if (Game.window().getResolution().getWidth() - mouseLocation.getX()
          < this.getScrollPadding()) {
        deltaX += scrollSpeed;
      }
  
      double deltaY = 0;
      if (mouseLocation.getY() < this.getScrollPadding()) {
        deltaY -= scrollSpeed;
      } else if (Game.window().getResolution().getHeight() - mouseLocation.getY()
          < this.getScrollPadding()) {
        deltaY += scrollSpeed;
      }
  
      x += deltaX;
      y += deltaY;
  
      this.setFocus(new Point2D.Double(x, y));
}
}
```
```java
class de.gurkenlabs.litiengine.environment.Environment {
private static void dispose(final Collection<? extends IEntity> entities) {
    for (final IEntity entity : entities) {
      if (entity instanceof IUpdateable) {
        Game.loop().detach((IUpdateable) entity);
      }

      entity.detachControllers();
    }
}private static void loadUpdatableOrEmitterEntity(IEntity entity) {
      if (entity instanceof Emitter) {
        final Emitter emitter = (Emitter) entity;
        if (emitter.isActivateOnInit()) {
          emitter.activate();
        }
      } else if (entity instanceof IUpdateable) {
        Nullability.castToNonnull(Game.loop(), "initialized through init").attach((IUpdateable) entity);
      }
}private void unload(final IEntity entity) {
    // 1. remove from physics engine
    if (entity instanceof ICollisionEntity) {
      Game.physics().remove((ICollisionEntity) entity);
    }

    // 2. unregister from update
    if (entity instanceof IUpdateable) {
      Game.loop().detach((IUpdateable) entity);
    }

    if (entity instanceof IMobileEntity) {
      this.removeGravity((IMobileEntity) entity);
    }

    // 3. detach all controllers
    entity.detachControllers();

    if (entity instanceof Emitter) {
      Emitter em = (Emitter) entity;
      em.deactivate();
    }

    if (this.loaded && (entity instanceof LightSource || entity instanceof StaticShadow)) {
      this.updateLighting(entity);
    }

    entity.removed(this);
}
}
```
```java
class de.gurkenlabs.litiengine.graphics.animation.Animation {
@Override
  public void update() {
    // do nothing if the animation is not playing or the current keyframe is not finished
    if (!this.isPlaying()
        || Game.time().since(this.lastFrameUpdate) < this.getCurrentKeyFrame().getDuration()) {
      return;
    }

    // if we are not looping and the last keyframe is finished, we terminate the animation
    if (!this.isLooping() && this.isLastKeyFrame()) {
      this.terminate();
      return;
    }

    // make sure, we stay inside the keyframe list
    final int newFrameIndex =
        (this.getKeyframes().indexOf(this.currentFrame) + 1) % this.getKeyframes().size();
    final KeyFrame previousFrame = this.currentFrame;
    this.currentFrame = this.getKeyframes().get(newFrameIndex);

    for (KeyFrameListener listener : this.listeners) {
      listener.currentFrameChanged(previousFrame, this.currentFrame);
    }

    this.lastFrameUpdate = Game.loop().getTicks();
}public void restart() {
    this.currentFrame = this.firstFrame;
    this.lastFrameUpdate = Game.loop().getTicks();
}
}
```
```java
class de.gurkenlabs.litiengine.physics.MovementController {
@Override
  public void attach() {
    Game.loop().attach(this);
}private void handleForces() {
    // clean up forces
    this.activeForces.forEach(
        x -> {
          if (x.hasEnded()) {
            this.activeForces.remove(x);
          }
        });

    if (this.activeForces.isEmpty()) {
      return;
    }

    // disable turn-on-move for force handling
    boolean turn = this.getEntity().turnOnMove();
    this.getEntity().setTurnOnMove(false);
    try {
      double deltaX = 0;
      double deltaY = 0;
      for (final Force force : this.activeForces) {
        if (force.cancelOnReached() && force.hasReached(this.getEntity())) {
          force.end();
          continue;
        }

        final Point2D collisionBoxCenter = this.getEntity().getCollisionBoxCenter();
        final double angle =
            GeometricUtilities.calcRotationAngleInDegrees(collisionBoxCenter, force.getLocation());
        final double strength =
            Game.loop().getDeltaTime() * 0.001f * force.getStrength() * Game.loop().getTimeScale();
        deltaX += GeometricUtilities.getDeltaX(angle, strength);
        deltaY += GeometricUtilities.getDeltaY(angle, strength);
      }

      final Point2D target =
          new Point2D.Double(this.getEntity().getX() + deltaX, this.getEntity().getY() + deltaY);
      final boolean success = Game.physics().move(this.getEntity(), target);
      if (!success) {
        for (final Force force : this.activeForces) {
          if (force.cancelOnCollision()) {
            force.end();
          }
        }
      }
    } finally {
      this.getEntity().setTurnOnMove(turn);
    }
}@Override
  public void detach() {
    Game.loop().detach(this);
}public void handleMovement() {
    if (!this.isMovementAllowed()) {
      this.velocity = 0;
      return;
    }

    // max distance an entity can travel within one tick
    final double maxPixelsPerTick = this.getEntity().getTickVelocity();
    final double deltaTime = Game.loop().getDeltaTime() * Game.loop().getTimeScale();

    final double acceleration =
        this.getEntity().getAcceleration() == 0
            ? maxPixelsPerTick
            : deltaTime / this.getEntity().getAcceleration() * maxPixelsPerTick;
    final double deceleration =
        this.getEntity().getDeceleration() == 0
            ? this.getVelocity()
            : deltaTime / this.getEntity().getDeceleration() * maxPixelsPerTick;

    double dx = this.getDx();
    double dy = this.getDy();
    this.setDx(0);
    this.setDy(0);

    final double deltaVelocity =
        Math.min(Math.sqrt(Math.pow(dx, 2) + Math.pow(dy, 2)), acceleration);
    if (deltaVelocity != 0) {
      double newVelocity = this.getVelocity() + deltaVelocity;
      this.setVelocity(newVelocity);
    } else {
      final double newVelocity = Math.max(0, this.getVelocity() - deceleration);
      this.setVelocity(newVelocity);
      dx = GeometricUtilities.getDeltaX(this.moveAngle);
      dy = GeometricUtilities.getDeltaY(this.moveAngle);
    }

    if (this.getVelocity() == 0) {
      this.moveAngle = 0;
      return;
    }

    // actually move entity
    this.moveEntity(dx, dy);
}
}
```
```java
class de.gurkenlabs.litiengine.graphics.animation.AnimationController {
public void detach() {
    Game.loop().detach(this);
}public void attach() {
    Game.loop().attach(this);
}
}
```
```java
class de.gurkenlabs.litiengine.graphics.Camera {
@Override
  public void setZoom(final float targetZoom, final int delay) {
    if (delay == 0) {

      this.zoom = targetZoom;
      this.targetZoom = 0;
      this.zoomDelay = 0;
      this.zoomTick = 0;
      this.zoomStep = 0;

      final ZoomChangedEvent event = new ZoomChangedEvent(this, targetZoom);
      for (final ZoomChangedListener listener : this.zoomListeners) {
        listener.zoomChanged(event);
      }
    } else {
      this.zoomTick = Game.time().now();
      this.targetZoom = targetZoom;
      this.zoomDelay = delay;

      final double tickduration = 1000 / (double) Game.loop().getTickRate();
      final double tickAmount = delay / tickduration;
      final float totalDelta = this.targetZoom - this.zoom;
      this.zoomStep = tickAmount > 0 ? (float) (totalDelta / tickAmount) : totalDelta;
    }
}
}
```
```java
class de.gurkenlabs.litiengine.Game {
public static synchronized void init(String... args) {
    if (initialized) {
      log().log(Level.INFO, "The game has already been initialized.");
      return;
    }

    log.init();
    handleCommandLineArguments(args);

    config().load();
    Locale.setDefault(new Locale(config().client().getCountry(), config().client().getLanguage()));

    gameLoop = new GameLoop("Main Update Loop", config().client().getMaxFps());
    loop().attach(physics());
    loop().attach(world());

    // setup default exception handling for render and update loop
    setUncaughtExceptionHandler(
        new DefaultUncaughtExceptionHandler(config().client().exitOnError()));

    screenManager = new ScreenManager();
    gameWindow = new GameWindow();

    // initialize  the game window
    window().init();
    world.setCamera(new Camera());

    for (GameListener listener : gameListeners) {
      listener.initialized(args);
    }

    if (!isInNoGUIMode()) {
      window().getRenderComponent().onRendered(g -> metrics().render(g));

      graphics()
          .addEntityRenderedListener(
              e -> DebugRenderer.renderEntityDebugInfo(e.getGraphics(), e.getEntity()));

      window().getRenderComponent().onFpsChanged(fps -> metrics().setFramesPerSecond(fps));
      window()
          .setIcons(
              Arrays.asList(
                  Resources.images().get("liti-logo-x16.png"),
                  Resources.images().get("liti-logo-x20.png"),
                  Resources.images().get("liti-logo-x32.png"),
                  Resources.images().get("liti-logo-x48.png")));

      Input.keyboard()
          .onKeyTyped(
              KeyEvent.VK_PRINTSCREEN,
              key -> {
                // don't take a screenshot if a modifier is active
                if (key.getModifiers() != 0) {
                  return;
                }

                window().getRenderComponent().takeScreenshot();
              });
    }

    Runtime.getRuntime().addShutdownHook(new Thread(Game::terminate, "Shutdown"));

    initialized = true;
}
}
```
```java
class de.gurkenlabs.litiengine.entities.Creature {
protected void updateAnimationController() {
        IEntityAnimationController<?> controller = this.createAnimationController();
        this.getControllers().addController(controller);
        if (Game.world().environment() != null && Game.world().environment().isLoaded()) {
            Nullability.castToNonnull(Game.loop(), "expected to be non-null").attach(controller);
        }
}@Override
  public float getTickVelocity() {
    // pixels per ms multiplied by the passed ms
    // ensure that entities don't travel too far in case of lag
    return Math.min(Game.loop().getDeltaTime(), GameLoop.TICK_DELTATIME_LAG)
        * 0.001F
        * this.getVelocity().get()
        * Game.loop().getTimeScale();
}
}
```
Depth: 2
```java
class de.gurkenlabs.litiengine.environment.GameWorld {
public void clear() {
    this.unloadEnvironment();
    this.environments.clear();
    this.setCamera(null);
    Game.physics().clear();

    this.environmentListeners.clear();
    this.environmentLoadedListeners.clear();
    this.environmentUnloadedListeners.clear();

    this.listeners.clear();
    this.loadedListeners.clear();
    this.unloadedListeners.clear();
}@Nullable
  public Environment loadEnvironment(IMap map) {
    Environment env = this.getEnvironment(map);
    this.loadEnvironment(env);
    return env;
}@Nullable
  public Environment loadEnvironment(String mapName) {
    Environment env = this.getEnvironment(mapName);
    this.loadEnvironment(env);
    return env;
}
}
```
```java
class de.gurkenlabs.litiengine.GameWindow {
GameWindow() {
    this.hostControl = new JFrame();

    this.resolutionChangedListeners = new CopyOnWriteArrayList<>();

    this.renderCanvas = new RenderComponent(Game.config().graphics().getResolution());
    this.cursor = new MouseCursor();
    if (!Game.isInNoGUIMode()) {
      this.hostControl.setBackground(Color.BLACK);
      this.hostControl.add(this.renderCanvas);

      this.initializeEventListeners();

      this.hostControl.setTitle(Game.info().getTitle());
      this.hostControl.setDefaultCloseOperation(WindowConstants.DO_NOTHING_ON_CLOSE);
      initializeWindowEventListeners(this.hostControl);
    }
}
}
```
```java
class de.gurkenlabs.litiengine.GameTime {
public long sinceEnvironmentLoad() {
    return this.since(this.environmentLoaded);
}public long since(final long tick) {
    return toMilliseconds(Game.loop().getTicks() - tick);
}public long sinceGameStart() {
    return this.toMilliseconds(Game.loop().getTicks());
}
}
```
```java
class de.gurkenlabs.litiengine.abilities.effects.Effect {
protected void cease(final EffectApplication appliance) {
    // 1. cease the effect for all affected entities
    for (final ICombatEntity entity : appliance.getAffectedEntities()) {
      this.cease(entity);
    }

    // 2. apply follow up effects
    this.getFollowUpEffects().forEach(followUp -> followUp.apply(appliance.getImpactArea()));
}protected boolean hasEnded(final EffectApplication appliance) {
    final long effectDuration = Game.time().since(appliance.getAppliedTicks());
    return effectDuration > this.getDuration();
}
}
```
```java
class de.gurkenlabs.litiengine.abilities.effects.EffectApplication {
protected EffectApplication(final List<ICombatEntity> affectedEntities, final Shape impactArea) {
    this.applied = Game.time().now();
    this.affectedEntities = affectedEntities;
    this.impactArea = impactArea;
}
}
```
```java
class de.gurkenlabs.litiengine.entities.CombatEntity {
@Override
  public boolean wasHit(int timeSpan) {
    return Game.time().since(this.lastHit) < timeSpan;
}@Override
  public void hit(final int damage, @Nullable final Ability ability) {
    if (this.isDead()) {
      return;
    }

    if (!this.isIndestructible()) {
      this.getHitPoints().modifyBaseValue(new AttributeModifier<>(Modification.SUBTRACT, damage));
    }

    final EntityHitEvent event = new EntityHitEvent(this, ability, damage, this.isDead());

    for (final CombatEntityListener listener : this.listeners) {
      listener.hit(event);
    }

    for (final CombatEntityHitListener listener : this.hitListeners) {
      listener.hit(event);
    }

    if (this.isDead()) {
      this.fireDeathEvent();
      this.setCollision(false);
    }

    this.lastHit = Game.time().now();
}
}
```
```java
class de.gurkenlabs.litiengine.graphics.ImageEffect {
protected ImageEffect(final int ttl, final String name) {
    this.ttl = ttl;
    this.name = name;
    this.aliveTick = Game.time().now();
}@Override
  public long getAliveTime() {
    return Game.time().since(this.aliveTick);
}
}
```
```java
class de.gurkenlabs.litiengine.abilities.AbilityExecution {
AbilityExecution(final Ability ability) {
        this.appliedEffects = new CopyOnWriteArrayList<>();
        this.ability = ability;
        this.executionTicks = Game.time().now();
        this.impactArea = ability.calculateImpactArea();
        this.castLocation = ability.getExecutor().getCenter();
        Nullability.castToNonnull(Game.loop(), "proper initialization done").attach(this);
}@Override
  public void update() {
    // if there a no effects to apply -> unregister this instance and we're done
    if (this.getAbility().getEffects().isEmpty()
        || this.getAbility().getEffects().size() == this.getAppliedEffects().size()) {
      Game.loop().detach(this);
      return;
    }

    // handle all effects from the ability that were not applied yet
    for (final Effect effect : this.getAbility().getEffects()) {
      // if the ability was not executed yet or the delay of the effect is not
      // yet reached
      if (this.getAppliedEffects().contains(effect)
          || Game.time().since(this.getExecutionTicks()) < effect.getDelay()) {
        continue;
      }

      effect.apply(this.getExecutionImpactArea());
      this.getAppliedEffects().add(effect);
    }
}
}
```
```java
class de.gurkenlabs.litiengine.tweening.TweenEngine {
@Override
  public void update() {
    for (final Tweenable target : this.getTweens().keySet()) {
      for (final Tween tween : this.getTweens().get(target).values()) {
        if (tween.hasStopped()) {
          continue;
        }
        final long elapsed = Game.time().since(tween.getStartTime());
        if (elapsed >= tween.getDuration()) {
          tween.stop();
          continue;
        }
        final float[] currentValues = new float[tween.getTargetValues().length];
        for (int i = 0; i < tween.getTargetValues().length; i++) {
          currentValues[i] =
              tween.getStartValues()[i]
                  + tween.getEquation().compute(elapsed / (float) tween.getDuration())
                      * (tween.getTargetValues()[i] - tween.getStartValues()[i]);
        }
        tween.getTarget().setTweenValues(tween.getType(), currentValues);
      }
    }
}
}
```
```java
class de.gurkenlabs.litiengine.gui.SpeechBubble {
public static SpeechBubble create(
      final IEntity entity, final String text, SpeechBubbleAppearance appearance, Font font) {
    return new SpeechBubble(entity, text, appearance, font);
}public static SpeechBubble create(final IEntity entity, final Font font, final String text) {
    SpeechBubbleAppearance app =
        new SpeechBubbleAppearance(
            DEFAULT_APPEARANCE.getForeColor(),
            DEFAULT_APPEARANCE.getBackgroundColor1(),
            DEFAULT_APPEARANCE.getBorderColor(),
            DEFAULT_APPEARANCE.getPadding());
    return new SpeechBubble(entity, text, app, font);
}public static SpeechBubble create(final IEntity entity, final String text) {
    return new SpeechBubble(entity, text, null, GuiProperties.getDefaultFont());
}@Override
  public void update() {
    if (this.currentText == null) {
      this.hide();
      return;
    }

    this.entityCenter = Game.world().camera().getViewportLocation(this.getEntity().getCenter());

    // old text was displayed long enough
    if (this.lastTextDisplay != 0
        && Game.time().since(this.lastTextDisplay) > this.currentTextDisplayTime) {
      this.currentText = null;
      this.lastTextDisplay = 0;
      return;
    }

    // display new text
    if (this.textIndex < this.currentText.length()
        && Game.time().since(this.lastCharPoll) > LETTER_WRITE_DELAY) {
      this.textIndex++;
      this.lastCharPoll = Game.time().now();
      if (this.typeSound != null) {
        Game.audio().playSound(this.typeSound, this.getEntity());
      }
    }

    // continue displaying currently displayed text
}private SpeechBubble(
      final IEntity entity,
      final String text,
      final Sound typeSound,
      SpeechBubbleAppearance appearance,
      Font font) {
    this(entity, text, appearance, font);
    this.typeSound = typeSound;
}private SpeechBubble(
      final IEntity entity,
      final String text,
      @Nullable SpeechBubbleAppearance appearance,
      @Nullable Font font) {
    if (appearance == null) {
      this.appearance = DEFAULT_APPEARANCE;
    } else {
      this.appearance = appearance;
    }

    final SpeechBubble active = activeSpeechBubbles.get(entity);
    if (active != null) {
      active.hide();
    }
    this.setFont(font);

    this.textBoxWidth = (float) (entity.getWidth() * 4);
    this.entity = entity;

    this.currentText = text;
    this.currentTextDisplayTime = DISPLAYTIME_MIN + text.length() * DISPLAYTIME_PER_LETTER;

    this.lastTextDisplay = Game.time().now();
    this.createBubbleImage();
    entity.getEnvironment().add(this, RenderType.UI);
    Game.loop().attach(this);
    activeSpeechBubbles.put(entity, this);
}
}
```
```java
class de.gurkenlabs.litiengine.gui.TextFieldComponent {
@Override
  public void render(final Graphics2D g) {
    super.render(g);
    g.setFont(this.getFont());
    final FontMetrics fm = g.getFontMetrics();

    if (this.isSelected() && Game.time().since(this.lastToggled) > this.flickerDelay) {
      this.cursorVisible = !this.cursorVisible;
      this.lastToggled = Game.time().now();
    }
    if (this.isSelected() && this.cursorVisible) {
      final Rectangle2D cursor =
          new Rectangle2D.Double(
              this.getX() + this.getTextX() + fm.stringWidth(this.getTextToRender(g)),
              this.getY() + this.getTextY(),
              this.getFont().getSize2D() * 3 / 5,
              this.getFont().getSize2D() * 1 / 5);
      g.setColor(this.getAppearance().getForeColor());
      g.fill(cursor);
    }
}
}
```
```java
class de.gurkenlabs.litiengine.entities.Prop {
public Prop(
      final Point2D location, @Nullable final String spritesheetName, final Material material) {
    super();
    this.rotation = Rotation.NONE;
    this.spritesheetName = spritesheetName;
    this.material = material;
    this.setLocation(location);
    this.updateAnimationController();
}public void setSpritesheetName(@Nullable final String spriteName) {
    this.spritesheetName = spriteName;
    this.updateAnimationController();
}
}
```
```java
class de.gurkenlabs.litiengine.tweening.Tween {
public Tween begin() {
    this.started = Game.time().now();
    this.stopped = false;
    return this;
}
}
```
```java
class de.gurkenlabs.litiengine.graphics.emitters.particles.Particle {
public void update(final Point2D emitterOrigin, final float updateRatio) {
    if (this.aliveTick == 0) {
      this.aliveTick = Game.time().now();
    }

    this.aliveTime = Game.time().since(this.aliveTick);
    if (this.timeToLiveReached()) {
      return;
    }

    if (this.colliding) {
      return;
    }

    if (this.getDeltaWidth() != 0) {
      this.width += this.getDeltaWidth() * updateRatio;
    }

    if (this.getDeltaHeight() != 0) {
      this.height += this.getDeltaHeight() * updateRatio;
    }

    if (this.getDeltaAngle() != 0) {
      this.angle += this.getDeltaAngle() * updateRatio;
    }

    // test for ray cast collision
    final float targetX = this.x + this.getVelocityX() * updateRatio;
    final float targetY = this.y + this.getVelocityY() * updateRatio;

    if (targetX == this.x && targetY == this.y) {
      return;
    }

    if (this.checkForCollision(emitterOrigin, targetX, targetY)) {
      return;
    }

    if (this.getVelocityX() != 0) {
      this.x = targetX;
    }

    if (this.getVelocityY() != 0) {
      this.y = targetY;
    }

    if (this.getAccelerationX() != 0) {
      this.velocityX += this.getAccelerationX() * updateRatio;
    }

    if (this.getAccelerationY() != 0) {
      this.velocityY += this.getAccelerationY() * updateRatio;
    }
}
}
```
```java
class de.gurkenlabs.litiengine.graphics.animation.Animation {
@Override
  public void start() {
    this.playing = true;
    if (this.getKeyframes().isEmpty()) {
      return;
    }

    this.restart();
}@Override
  public void update() {
    // do nothing if the animation is not playing or the current keyframe is not finished
    if (!this.isPlaying()
        || Game.time().since(this.lastFrameUpdate) < this.getCurrentKeyFrame().getDuration()) {
      return;
    }

    // if we are not looping and the last keyframe is finished, we terminate the animation
    if (!this.isLooping() && this.isLastKeyFrame()) {
      this.terminate();
      return;
    }

    // make sure, we stay inside the keyframe list
    final int newFrameIndex =
        (this.getKeyframes().indexOf(this.currentFrame) + 1) % this.getKeyframes().size();
    final KeyFrame previousFrame = this.currentFrame;
    this.currentFrame = this.getKeyframes().get(newFrameIndex);

    for (KeyFrameListener listener : this.listeners) {
      listener.currentFrameChanged(previousFrame, this.currentFrame);
    }

    this.lastFrameUpdate = Game.loop().getTicks();
}
}
```
```java
class de.gurkenlabs.litiengine.graphics.animation.AnimationController {
@Override
  public void update() {
    for (final Animation animation : this.getAll()) {
      animation.update();
    }

    if (this.getCurrent() != null && this.getCurrent().isPaused()) {
      return;
    }

    final boolean playbackFinished = this.getCurrent() != null && !this.getCurrent().isPlaying();
    if (playbackFinished) {
      for (final AnimationListener listener : this.listeners) {
        listener.finished(this.getCurrent());
      }
    }

    if (this.getCurrent() == null || playbackFinished) {
      if (this.getDefault() != null) {
        this.play(this.getDefault().getName());
      } else {
        this.currentAnimation = null;
      }
    }
}
}
```
```java
class de.gurkenlabs.litiengine.graphics.RenderComponent {
private void handleFade() {
    if (this.fadeOutStart != -1) {
      final long timePassed = Game.time().since(this.fadeOutStart);
      this.currentAlpha = MathUtilities.clamp(1 - timePassed / (float) this.fadeOutTime, 0, 1);
      if (this.currentAlpha == 0f) {
        this.fadeOutStart = -1;
        this.fadeOutTime = -1;
      }

      return;
    }

    if (this.fadeInStart != -1) {
      final long timePassed = Game.time().since(this.fadeInStart);
      this.currentAlpha = MathUtilities.clamp(timePassed / (float) this.fadeInTime, 0, 1);
      if (this.currentAlpha == 1f) {
        this.fadeInStart = -1;
        this.fadeInTime = -1;
        this.currentAlpha = Float.NaN;
      }
    }
}public void fadeOut(final int ms) {
    this.fadeInStart = -1;
    this.fadeInTime = -1;
    this.fadeOutStart = Game.time().now();
    this.fadeOutTime = ms;
}public void fadeIn(final int ms) {
    this.fadeOutStart = -1;
    this.fadeOutTime = -1;
    this.fadeInStart = Game.time().now();
    this.fadeInTime = ms;
}
}
```
```java
class de.gurkenlabs.litiengine.entities.Trigger {
private boolean activate(final IEntity activator, final int tar) {
    if (!this.isLoaded()
        || this.isOneTimeTrigger && this.isActivated
        || this.getActivationType() == TriggerActivation.COLLISION
            && activator != null
            && this.collisionActivated.contains(activator)) {
      return false;
    }

    if (this.getCooldown() > 0 && Game.time().since(this.lastActivation) < this.getCooldown()) {
      return false;
    }

    List<Integer> triggerTargets = this.getTargets(tar);

    final TriggerEvent te = new TriggerEvent(this, activator, triggerTargets);

    if (!this.checkActivationPredicates(te)) {
      return false;
    }

    this.isActivated = true;
    if (activator != null) {
      this.collisionActivated.add(activator);
    }

    // if we actually have a trigger target, we send the message to the target
    for (final int target : triggerTargets) {
      final IEntity entity = this.getEnvironment().get(target);
      if (entity == null) {
        log.log(
            Level.WARNING,
            "trigger [{0}] was activated, but the trigger target [{1}] could not be found on the environment",
            new Object[] {this, target});
        continue;
      }

      entity.sendMessage(this, this.message);
    }

    // also send the trigger event to all registered consumers
    for (final TriggerActivatedListener listener : this.activatedListeners) {
      listener.activated(te);
    }

    if (this.isOneTimeTrigger) {
      this.getEnvironment().remove(this);
    }

    this.lastActivation = Game.time().now();
    return true;
}
}
```
```java
class de.gurkenlabs.litiengine.graphics.Camera {
private boolean isShakeEffectActive() {
    return this.getShakeTick() != 0
        && Game.time().since(this.getShakeTick()) < this.getShakeDuration();
}@Override
  public void update() {
    if (Game.world().camera() != null && !Game.world().camera().equals(this)) {
      return;
    }

    if (this.targetZoom > 0) {
      if (Game.time().since(this.zoomTick) >= this.zoomDelay) {
        this.zoom = this.targetZoom;
        this.targetZoom = 0;
        this.zoomDelay = 0;
        this.zoomTick = 0;
        this.zoomStep = 0;
      } else {
        this.zoom += this.zoomStep;
      }

      final ZoomChangedEvent event = new ZoomChangedEvent(this, this.getZoom());
      for (final ZoomChangedListener listener : this.zoomListeners) {
        listener.zoomChanged(event);
      }
    }

    if (this.panTime > 0) {
      if (--this.panTime <= 0) {
        this.setFocus(this.targetFocus);
        this.targetFocus = null;
      } else {
        double diff = this.panTime / (this.panTime + 1.0);
        this.focus =
            new Point2D.Double(
                this.focus.getX() * diff + this.targetFocus.getX() * (1.0 - diff),
                this.focus.getY() * diff + this.targetFocus.getY() * (1.0 - diff));
      }
    }

    if (!this.isShakeEffectActive()) {
      this.shakeOffsetX = 0;
      this.shakeOffsetY = 0;
      return;
    }

    if (Game.time().since(this.lastShake) > this.shakeDelay) {
      this.shakeOffsetX = this.getShakeIntensity() * ThreadLocalRandom.current().nextGaussian();
      this.shakeOffsetY = this.getShakeIntensity() * ThreadLocalRandom.current().nextGaussian();
      this.lastShake = Game.time().now();
    }
}@Override
  public void setZoom(final float targetZoom, final int delay) {
    if (delay == 0) {

      this.zoom = targetZoom;
      this.targetZoom = 0;
      this.zoomDelay = 0;
      this.zoomTick = 0;
      this.zoomStep = 0;

      final ZoomChangedEvent event = new ZoomChangedEvent(this, targetZoom);
      for (final ZoomChangedListener listener : this.zoomListeners) {
        listener.zoomChanged(event);
      }
    } else {
      this.zoomTick = Game.time().now();
      this.targetZoom = targetZoom;
      this.zoomDelay = delay;

      final double tickduration = 1000 / (double) Game.loop().getTickRate();
      final double tickAmount = delay / tickduration;
      final float totalDelta = this.targetZoom - this.zoom;
      this.zoomStep = tickAmount > 0 ? (float) (totalDelta / tickAmount) : totalDelta;
    }
}@Override
  public void shake(final double intensity, final int delay, final int shakeDuration) {
    this.shakeTick = Game.time().now();
    this.shakeDelay = delay;
    this.shakeIntensity = intensity;
    this.shakeDuration = shakeDuration;
}
}
```
```java
class de.gurkenlabs.litiengine.entities.Creature {
public void setSpritesheetName(String spritesheetName) {
    if (this.spritesheetName != null && this.spritesheetName.equals(spritesheetName)) {
      return;
    }

    this.spritesheetName = spritesheetName;
    this.updateAnimationController();
}public boolean isIdle() {
    return Game.time().since(this.lastMoved) > IDLE_DELAY;
}@Override
  public void setLocation(final Point2D position) {
    if (this.isDead() || position == null) {
      return;
    }

    final Point2D oldLocation = this.getLocation();
    super.setLocation(position);

    if (Game.hasStarted() && this.isLoaded()) {
      this.lastMoved = Game.time().now();
      this.fireMovedEvent(
          new EntityMovedEvent(
              this, this.getX() - oldLocation.getX(), this.getY() - oldLocation.getY()));
    }
}
}
```
```java
class de.gurkenlabs.litiengine.gui.screens.ScreenManager {
public void display(final String screenName) {
    if (this.current() != null && this.current().getName().equalsIgnoreCase(screenName)) {
      log.log(
          Level.INFO,
          "Skipping displaying of screen {0} because it is already the current screen.",
          screenName);
      return;
    }

    if (this.screens.stream()
        .noneMatch(element -> element.getName().equalsIgnoreCase(screenName))) {
      log.log(
          Level.WARNING,
          "Could not display the screen {0} because there is no screen with the specified name.",
          screenName);
      return;
    }

    Screen screen = this.get(screenName);
    if (screen == null) {
      return;
    }

    this.display(screen);
}public void add(final Screen screen) {
    screen.setWidth(Game.window().getWidth());
    screen.setHeight(Game.window().getHeight());
    this.screens.add(screen);

    if (this.current() == null) {
      this.display(screen);
    }
}public void remove(Screen screen) {
    this.screens.remove(screen);
    if (this.current() == screen) {
      if (!this.screens.isEmpty()) {
        this.display(this.screens.get(0));
      } else {
        this.display((Screen) null);
      }
    }
}public void display(@Nullable final Screen screen) {
      if (Game.hasStarted() && Game.time().since(this.lastScreenChange) < this.getChangeCooldown()) {
        log.log(
            Level.INFO,
            "Skipping displaying of screen {0} because screen changing is currently on cooldown.",
            screen != null ? screen.getName() : "");
        return;
      }
  
      final Screen previous = this.current();
      if (previous != null) {
        previous.suspend();
      }
  
      if (screen != null && !this.screens.contains(screen)) {
        this.screens.add(screen);
      }
  
      this.currentScreen = screen;
      if (!Game.isInNoGUIMode() && this.current() != null) {
        this.current().prepare();
      }
  
      this.lastScreenChange = Nullability.castToNonnull(Game.loop(), "initialized before usage").getTicks();
  
      final ScreenChangedEvent event = new ScreenChangedEvent(this.current(), previous);
      for (final ScreenChangedListener listener : this.screenChangedListeners) {
        listener.changed(event);
      }
}
}
```
```java
class de.gurkenlabs.litiengine.abilities.Ability {
public boolean isOnCooldown() {
    return (this.getCurrentExecution() != null
        && this.getCurrentExecution().getExecutionTicks() > 0
        && Game.time().since(this.getCurrentExecution().getExecutionTicks())
            < this.getAttributes().cooldown().get());
}public boolean isActive() {
    return this.getCurrentExecution() != null
        && Game.time().since(this.getCurrentExecution().getExecutionTicks())
            < this.getAttributes().duration().get();
}@Nullable
  public AbilityExecution cast() {
    if (!this.canCast()) {
      return null;
    }
    this.currentExecution = new AbilityExecution(this);

    for (final AbilityCastListener listener : this.abilityCastListeners) {
      listener.abilityCast(this.currentExecution);
    }

    return this.getCurrentExecution();
}public float getRemainingCooldownInSeconds() {
    if (this.getCurrentExecution() == null
        || this.getExecutor() == null
        || this.getExecutor().isDead()) {
      return 0;
    }

    // calculate cooldown in seconds
    return (float)
        (!this.canCast()
            ? (this.getAttributes().cooldown().get()
                    - Game.time().since(this.getCurrentExecution().getExecutionTicks()))
                * 0.001
            : 0);
}
}
```
```java
class de.gurkenlabs.litiengine.entities.EntityHitEvent {
EntityHitEvent(
      final ICombatEntity hitEntity,
      @Nullable final Ability ability,
      final int damage,
      final boolean kill) {
    super(hitEntity);
    this.executor = ability != null ? ability.getExecutor() : null;
    this.hitEntity = hitEntity;
    this.ability = ability;
    this.damage = damage;
    this.kill = kill;
    this.time = Game.time().now();
}
}
```
```java
class de.gurkenlabs.litiengine.graphics.emitters.Emitter {
public void delete() {
    this.deactivate();
    if (Game.world().environment() != null) {
      Game.world().environment().remove(this);
    }
}public void activate() {
    if (this.activated) {
      return;
    }

    this.activated = true;
    this.activationTick = Game.time().now();
    Game.loop().attach(this);
}@Override
  public void update() {
    if (this.isPaused()) {
      return;
    }

    // clear particles if the effect time to life is reached
    if (this.isFinished()) {
      for (EmitterFinishedListener listener : this.finishedListeners) {
        listener.finished(this);
      }

      this.delete();
      return;
    }

    final float updateRatio = (float) this.data().getUpdateRate() / Game.loop().getTickRate();
    for (final Particle p : this.getParticles().stream().collect(Collectors.toList())) {
      if (this.particleCanBeRemoved(p)) {
        // remove dead particles
        this.particles.remove(p);
        continue;
      }

      p.update(this.getOrigin(), updateRatio);
    }

    this.aliveTime = Game.time().since(this.activationTick);
    if ((this.data().getSpawnRate() == 0
        || Game.time().since(this.lastSpawn) >= this.data().getSpawnRate())) {
      this.lastSpawn = Game.time().now();
      this.spawnParticle();
    }
}
}
```
```java
class de.gurkenlabs.litiengine.GameLoop {
@Override
  public int perform(int delay, Runnable action) {
    final long d = Game.time().toTicks(delay);

    TimedAction a = new TimedAction(this.getTicks() + d, action);
    this.actions.add(a);

    return a.getId();
}
}
```
```java
class de.gurkenlabs.litiengine.environment.EntitySpawner {
protected boolean shouldSpawn() {
    return this.lastSpawnWave == 0
        || Game.time().since(this.lastSpawnWave) >= this.getSpawnInterval();
}@Override
  public void update() {
    if (!this.shouldSpawn()) {
      return;
    }

    this.spawnNewEntities();
    this.lastSpawnWave = Game.time().now();
}
}
```
```java
class de.gurkenlabs.litiengine.graphics.FreeFlightCamera {
@Override
  public void update() {
    this.handleFreeFlightCamera();
}public FreeFlightCamera(double x, double y) {
    this(new Point2D.Double(x, y));
}
}
```
```java
class de.gurkenlabs.litiengine.environment.Environment {
public void unload() {
    if (!this.loaded) {
      return;
    }

    // unregister all updatable entities from the current environment
    for (final IEntity entity : this.allEntities.values()) {
      this.unload(entity);
    }

    this.loaded = false;
    this.fireEvent(l -> l.unloaded(this));
}private static void loadUpdatableOrEmitterEntity(IEntity entity) {
      if (entity instanceof Emitter) {
        final Emitter emitter = (Emitter) entity;
        if (emitter.isActivateOnInit()) {
          emitter.activate();
        }
      } else if (entity instanceof IUpdateable) {
        Nullability.castToNonnull(Game.loop(), "initialized through init").attach((IUpdateable) entity);
      }
}public void clear() {
    Game.physics().clear();

    this.combatEntities.clear();
    this.mobileEntities.clear();
    this.gravityForces.clear();
    this.layerEntities.clear();
    this.entitiesByTag.clear();
    this.allEntities.clear();

    for (RenderType renderType : RenderType.values()) {
      this.miscEntities.get(renderType).clear();
      this.renderListeners.get(renderType).clear();
      this.renderables.get(renderType).clear();
    }

    dispose(this.allEntities.values());
    dispose(this.triggers);
    this.emitters.clear();
    this.colliders.clear();
    this.props.clear();
    this.creatures.clear();
    this.staticShadows.clear();
    this.combatEntities.clear();
    this.mobileEntities.clear();
    this.lightSources.clear();
    this.spawnPoints.clear();
    this.soundSources.clear();
    this.mapAreas.clear();
    this.triggers.clear();

    this.ambientLight = null;
    this.staticShadowLayer = null;

    for (Map<Integer, IEntity> type : this.miscEntities.values()) {
      type.clear();
    }

    this.initialized = false;

    this.fireEvent(l -> l.cleared(this));
}private void load(final IEntity entity) {
    // an entity can only exist on one environment at a time, so remove it from the current one
    if (entity.getEnvironment() != null) {
      entity.getEnvironment().remove(entity);
    }

    // 1. add to physics engine
    loadPhysicsEntity(entity);

    // 2. register for update or activate
    loadUpdatableOrEmitterEntity(entity);

    // 3. if a gravity is defined, add a gravity force to the entity
    if (entity instanceof IMobileEntity && this.getGravity() != 0) {
      this.addGravityForce((IMobileEntity) entity);
    }

    // 4. attach all controllers
    entity.attachControllers();

    if (this.loaded && (entity instanceof LightSource || entity instanceof StaticShadow)) {
      this.updateLighting(entity);
    }

    entity.loaded(this);
}private void unload(final IEntity entity) {
    // 1. remove from physics engine
    if (entity instanceof ICollisionEntity) {
      Game.physics().remove((ICollisionEntity) entity);
    }

    // 2. unregister from update
    if (entity instanceof IUpdateable) {
      Game.loop().detach((IUpdateable) entity);
    }

    if (entity instanceof IMobileEntity) {
      this.removeGravity((IMobileEntity) entity);
    }

    // 3. detach all controllers
    entity.detachControllers();

    if (entity instanceof Emitter) {
      Emitter em = (Emitter) entity;
      em.deactivate();
    }

    if (this.loaded && (entity instanceof LightSource || entity instanceof StaticShadow)) {
      this.updateLighting(entity);
    }

    entity.removed(this);
}public void remove(final IEntity entity) {
    if (entity == null) {
      return;
    }

    this.allEntities.remove(entity.getMapId());
    Iterator<List<IEntity>> iter = this.layerEntities.values().iterator();
    while (iter.hasNext()) {
      List<IEntity> layer = iter.next();
      if (layer.remove(entity) && layer.isEmpty()) {
        iter.remove();
      }
    }
    if (this.miscEntities.get(entity.getRenderType()) != null) {
      this.miscEntities.get(entity.getRenderType()).values().remove(entity);
    }

    for (String tag : entity.getTags()) {
      if (this.getEntitiesByTag().containsKey(tag)) {
        this.getEntitiesByTag().get(tag).remove(entity);

        if (this.getEntitiesByTag().get(tag).isEmpty()) {
          this.getEntitiesByTag().remove(tag);
        }
      }
    }

    if (entity instanceof Emitter) {
      Emitter emitter = (Emitter) entity;
      this.removeEmitter(emitter);
    }

    if (entity instanceof MapArea) {
      this.mapAreas.remove(entity);
    }

    if (entity instanceof Prop) {
      this.props.remove(entity);
    }

    if (entity instanceof Creature) {
      this.creatures.remove(entity);
    }

    if (entity instanceof CollisionBox) {
      this.colliders.remove(entity);
      this.staticShadows.removeIf(x -> x.getOrigin() != null && x.getOrigin().equals(entity));
    }

    if (entity instanceof LightSource) {
      this.lightSources.remove(entity);
      this.updateLighting(entity);
    }

    if (entity instanceof Trigger) {
      this.triggers.remove(entity);
    }

    if (entity instanceof Spawnpoint) {
      this.spawnPoints.remove(entity);
    }
    if (entity instanceof SoundSource) {
      this.soundSources.remove(entity);
    }

    if (entity instanceof StaticShadow) {
      this.staticShadows.remove(entity);
      this.updateLighting(entity);
    }

    if (entity instanceof IMobileEntity) {
      this.mobileEntities.values().remove(entity);
    }

    if (entity instanceof ICombatEntity) {
      this.combatEntities.values().remove(entity);
    }

    this.unload(entity);

    this.fireEntityEvent(l -> l.entityRemoved(entity));
}
}
```
```java
class de.gurkenlabs.litiengine.physics.MovementController {
@Override
  public void update() {
    this.handleForces();
    this.handleMovement();
}
}
```
```java
class de.gurkenlabs.litiengine.Game {
static synchronized void terminate() {
        if (!initialized || gameLoop == null) {
          return;
        }
    
        hasStarted = false;
        initialized = false;
    
        config().save();
        gameLoop.terminate();
        tweenEngine.terminate();
        soundEngine.terminate();
    
        world().clear();
    
        for (final GameListener listener : gameListeners) {
          try {
            listener.terminated();
          } catch (Exception e) {
            log().log(Level.WARNING, "game listener threw an exception during shutdown", e);
          }
        }
    
        gameLoop = null;
        screenManager = null;
        gameWindow = null;
}public static synchronized void start() {
          if (!initialized) {
              throw new IllegalStateException(
                  "The game cannot be started without being first initialized. Call Game.init(...) before Game.start().");
          }
    
          if (gameLoop == null) {
              throw new IllegalStateException(
                  "Game loop is not initialized. Ensure Game.init(...) has been called successfully.");
          }
          
          Nullability.castToNonnull(gameLoop, "gameLoop cannot be null").start();
          tweenEngine.start();
          soundEngine.start();
    
          for (final GameListener listener : gameListeners) {
              listener.started();
          }
    
          hasStarted = true;
}public static synchronized void init(String... args) {
    if (initialized) {
      log().log(Level.INFO, "The game has already been initialized.");
      return;
    }

    log.init();
    handleCommandLineArguments(args);

    config().load();
    Locale.setDefault(new Locale(config().client().getCountry(), config().client().getLanguage()));

    gameLoop = new GameLoop("Main Update Loop", config().client().getMaxFps());
    loop().attach(physics());
    loop().attach(world());

    // setup default exception handling for render and update loop
    setUncaughtExceptionHandler(
        new DefaultUncaughtExceptionHandler(config().client().exitOnError()));

    screenManager = new ScreenManager();
    gameWindow = new GameWindow();

    // initialize  the game window
    window().init();
    world.setCamera(new Camera());

    for (GameListener listener : gameListeners) {
      listener.initialized(args);
    }

    if (!isInNoGUIMode()) {
      window().getRenderComponent().onRendered(g -> metrics().render(g));

      graphics()
          .addEntityRenderedListener(
              e -> DebugRenderer.renderEntityDebugInfo(e.getGraphics(), e.getEntity()));

      window().getRenderComponent().onFpsChanged(fps -> metrics().setFramesPerSecond(fps));
      window()
          .setIcons(
              Arrays.asList(
                  Resources.images().get("liti-logo-x16.png"),
                  Resources.images().get("liti-logo-x20.png"),
                  Resources.images().get("liti-logo-x32.png"),
                  Resources.images().get("liti-logo-x48.png")));

      Input.keyboard()
          .onKeyTyped(
              KeyEvent.VK_PRINTSCREEN,
              key -> {
                // don't take a screenshot if a modifier is active
                if (key.getModifiers() != 0) {
                  return;
                }

                window().getRenderComponent().takeScreenshot();
              });
    }

    Runtime.getRuntime().addShutdownHook(new Thread(Game::terminate, "Shutdown"));

    initialized = true;
}
}
```


Response Format:
Provide the answer in **XML format** as follows:

#### If the method **cannot** return `null` at the specific call site:
```xml
<response>
  <reason><![CDATA[EXPLAIN WHY THE INVOCATION Game.loop() RESULT CANNOT BE NULL.]]></reason>
  <value>NO</value>
</response>

#### If the method can return null at the specific call site:
<response>
  <reason><![CDATA[EXPLAIN WHY THE INVOCATION Game.loop() RESULT CAN BE NULL.]]></reason>
  <value>YES</value>
</response>

#### If you are unsure or If there are any methods that directly or indirectly affect the return value and are not fully disclosed, request their declarations first, in the following format:
<response>
  <reason><![CDATA[EXPLAIN WHY THIS METHOD DECLARATION IS NECESSARY AND WHY YOU CANNOT MAKE A CONFIDENT DECISION WITHOUT IT]]></reason>
  <success>false</success>
  <methods>
    <method>methodName</method>
  </methods>
</response>

Additional Notes:
Be precise in your reasoning.
If a methods return value depends on another method not provided, request its declaration before making a conclusion.
If the method can return null in this case but not in others, explain why it happens specifically for this call.

11:53:27.036 TRACE edu.ucr.cs.riple.core.checkers.nullaway.codefix.ChatGPT.ask
Retrieving response from cache
11:53:27.036 TRACE edu.ucr.cs.riple.core.checkers.nullaway.codefix.Response.tryCreate
Trying to create Response:
```xml
<response>
  <reason><![CDATA[The method Game.loop() directly returns the static variable gameLoop from the Game class. This variable is initialized in the init() method of the Game class to a new GameLoop instance and is properly checked during the initialization process. As the call site Game.loop() is utilized in various methods and classes, including critical operations throughout the code, it is ensured that gameLoop is initialized before being used. Furthermore, the Game.start() method throws an IllegalStateException if gameLoop is not initialized. This ensures that Game.loop() cannot return null at the call site unless theres a critical programming error like bypassing init() and start() methods, which under normal circumstances is prevented by design.]]></reason>
  <value>NO</value>
</response>
```
11:53:27.036 TRACE edu.ucr.cs.riple.core.checkers.nullaway.codefix.Response.<init>
Creating Response:
```xml
<response>
  <reason><![CDATA[The method Game.loop() directly returns the static variable gameLoop from the Game class. This variable is initialized in the init() method of the Game class to a new GameLoop instance and is properly checked during the initialization process. As the call site Game.loop() is utilized in various methods and classes, including critical operations throughout the code, it is ensured that gameLoop is initialized before being used. Furthermore, the Game.start() method throws an IllegalStateException if gameLoop is not initialized. This ensures that Game.loop() cannot return null at the call site unless theres a critical programming error like bypassing init() and start() methods, which under normal circumstances is prevented by design.]]></reason>
  <value>NO</value>
</response>
```
11:53:27.037 TRACE edu.ucr.cs.riple.core.checkers.nullaway.codefix.Response.<init>
Response created:
Disagreement: The method Game.loop() directly returns the static variable gameLoop from the Game class. This variable is initialized in the init() method of the Game class to a new GameLoop instance and is properly checked during the initialization process. As the call site Game.loop() is utilized in various methods and classes, including critical operations throughout the code, it is ensured that gameLoop is initialized before being used. Furthermore, the Game.start() method throws an IllegalStateException if gameLoop is not initialized. This ensures that Game.loop() cannot return null at the call site unless theres a critical programming error like bypassing init() and start() methods, which under normal circumstances is prevented by design.
11:53:27.037 TRACE edu.ucr.cs.riple.core.checkers.nullaway.codefix.AdvancedNullAwayCodeFix.resolveMethodDereferenceError
Method is not returning nullable on call site. Injecting suppression annotation.
11:53:27.037 TRACE edu.ucr.cs.riple.core.checkers.nullaway.codefix.AdvancedNullAwayCodeFix.constructCastToNonnullChange
Constructing cast to nonnull change for reason: The method Game.loop() directly returns the static variable gameLoop from the Game class. This variable is initialized in the init() method of the Game class to a new GameLoop instance and is properly checked during the initialization process. As the call site Game.loop() is utilized in various methods and classes, including critical operations throughout the code, it is ensured that gameLoop is initialized before being used. Furthermore, the Game.start() method throws an IllegalStateException if gameLoop is not initialized. This ensures that Game.loop() cannot return null at the call site unless theres a critical programming error like bypassing init() and start() methods, which under normal circumstances is prevented by design.
11:53:27.038 TRACE edu.ucr.cs.riple.core.checkers.nullaway.codefix.ChatGPT.ask
Asking ChatGPT:
For the reason you mentioned earlier:

"The method Game.loop() directly returns the static variable gameLoop from the Game class. This variable is initialized in the init() method of the Game class to a new GameLoop instance and is properly checked during the initialization process. As the call site Game.loop() is utilized in various methods and classes, including critical operations throughout the code, it is ensured that gameLoop is initialized before being used. Furthermore, the Game.start() method throws an IllegalStateException if gameLoop is not initialized. This ensures that Game.loop() cannot return null at the call site unless theres a critical programming error like bypassing init() and start() methods, which under normal circumstances is prevented by design."

in the method below, the expression Game.loop() is not nullable at the point it is used.

```java
@Override
  public void attach() {
    Game.loop().attach(this);
}
```
Please Summarize the reason in max 5 words and rewrite the method so that at the line "    Game.loop().attach(this);", at the occurrence of: "Game.loop()" is replaced with `Nullability.castToNonnull(Game.loop(), summary of reason)`
Replace "REASON" with the exact reason summary I provide to you (maximum 5 words), not with a generic explanation like "checked to be nonnull".
see the example below, for expression `foo.getBar()`, to wrap it with `Nullability.castToNonnull(foo.getBar(), "reason")`.

```java
public t(){
    String l = foo.getBar();
}
```

will be:
```java
public t(){
    String l = Nullability.castToNonnull(foo.getBar(), "checked to be nonnull");
}
```

### Instructions:

Do not import any additional classes.

Do not add Java comments.

Only modify relevant lines as required.

Return only the modified method wrapped in the XML format shown below.

Place the Java code inside the <code> tag using a CDATA block with ```java formatting.

Just give me the fixed code snippet in XML format in <response> tag like the example below. I will apply the fix to my codebase. Do not import any additional libraries or classes or add java comments. If you can provide the fixed code snippet, please provide it in the following format and place the code snippet in the <code> tag within ```java block.
<response>
  <success>true</success>
  <code><![CDATA[
  ```java
  Your fixed code snippet here
  ```
    ]]>
  </code>
</response>

11:53:27.038 TRACE edu.ucr.cs.riple.core.checkers.nullaway.codefix.ChatGPT.ask
Retrieving response from cache
11:53:27.038 TRACE edu.ucr.cs.riple.core.checkers.nullaway.codefix.Response.tryCreate
Trying to create Response:
<response>
  <success>true</success>
  <code><![CDATA[
  ```java
  @Override
  public void attach() {
    Nullability.castToNonnull(Game.loop(), "properly initialized before use").attach(this);
  }
  ```
  ]]>
  </code>
</response>
11:53:27.038 TRACE edu.ucr.cs.riple.core.checkers.nullaway.codefix.Response.<init>
Creating Response:
<response>
  <success>true</success>
  <code><![CDATA[
  ```java
  @Override
  public void attach() {
    Nullability.castToNonnull(Game.loop(), "properly initialized before use").attach(this);
  }
  ```
  ]]>
  </code>
</response>
11:53:27.039 TRACE edu.ucr.cs.riple.core.checkers.nullaway.codefix.Response.<init>
Response created:
@Override
  public void attach() {
    Nullability.castToNonnull(Game.loop(), "properly initialized before use").attach(this);
  }
11:53:27.039 TRACE edu.ucr.cs.riple.core.checkers.nullaway.codefix.ChatGPT.fixDereferenceByAddingCastToNonnull
Fixing the error by adding castToNonnull
11:53:27.041 TRACE edu.ucr.cs.riple.core.checkers.nullaway.codefix.AdvancedNullAwayCodeFix.fixTriggeredErrorsForLocation
Resolving unresolvable error for triggered error: Type='DEREFERENCE_NULLABLE', message='dereferenced expression Game.loop() is @Nullable'
/home/nima/Developer/nullness-benchmarks/litiengine/src/de/gurkenlabs/litiengine/GameTime.java:111
    environmentLoaded = Game.loop().getTicks();
11:53:27.041 TRACE edu.ucr.cs.riple.core.checkers.nullaway.codefix.AdvancedNullAwayCodeFix.fix
Fixing error: Type='DEREFERENCE_NULLABLE', message='dereferenced expression Game.loop() is @Nullable'
/home/nima/Developer/nullness-benchmarks/litiengine/src/de/gurkenlabs/litiengine/GameTime.java:111
    environmentLoaded = Game.loop().getTicks();
11:53:27.041 TRACE edu.ucr.cs.riple.core.checkers.nullaway.codefix.AdvancedNullAwayCodeFix.resolveDereferenceError
Resolving dereference error: Type='DEREFERENCE_NULLABLE', message='dereferenced expression Game.loop() is @Nullable'
/home/nima/Developer/nullness-benchmarks/litiengine/src/de/gurkenlabs/litiengine/GameTime.java:111
    environmentLoaded = Game.loop().getTicks();
11:53:27.041 TRACE edu.ucr.cs.riple.core.checkers.nullaway.codefix.AdvancedNullAwayCodeFix.resolveDereferenceError
Checking nullability possibility at error point
11:53:27.042 TRACE edu.ucr.cs.riple.core.checkers.nullaway.codefix.ChatGPT.checkNullabilityPossibilityAtErrorPoint
Asking if the expression can be null at error point point
11:53:27.042 TRACE edu.ucr.cs.riple.core.checkers.nullaway.codefix.ChatGPT.ask
Asking ChatGPT:
In the method below, is there a possibility that the expression "Game.loop()" at line "environmentLoaded = Game.loop().getTicks();" is null?
@Override
  public void loaded(Environment environment) {
    environmentLoaded = Game.loop().getTicks();
}
Give a single-word answer in XML format. If it is possible for the expression to be null, respond with:
```xml
<response>
    <reason><![CDATA[YOUR REASON]]></reason>
    <value>YES</value>
</response>
```
If it is not possible for the expression to be null, respond with:
```xml
<response>
    <reason><![CDATA[YOUR REASON]]></reason>
    <value>NO</value>
</response>
```
If you are unsure or need more information, respond with where you can ask for more details or what specific information you need.

If additional information is required, list each request inside a `<request>` tag. If no additional information is needed, omit the `<requests>` section.

Respond with:
```xml
<response>
    <reason><![CDATA[YOUR REASON]]></reason>
    <value>UNKNOWN</value>
    <!-- Include <requests> only if additional information is needed -->
    <requests>
        <request><![CDATA[YOUR REQUEST 1]]></request>
        <request><![CDATA[YOUR REQUEST 2]]></request>
    </requests>
</response>
```
11:53:27.042 TRACE edu.ucr.cs.riple.core.checkers.nullaway.codefix.ChatGPT.ask
Retrieving response from cache
11:53:27.042 TRACE edu.ucr.cs.riple.core.checkers.nullaway.codefix.Response.tryCreate
Trying to create Response:
```xml
<response>
    <reason><![CDATA[Without additional context about what "Game.loop()" returns and its implementation, it is unclear whether the expression can be null.]]></reason>
    <value>UNKNOWN</value>
    <requests>
        <request><![CDATA[Information about the return value of "Game.loop()".]]></request>
        <request><![CDATA[Details on the "Game" class implementation.]]></request>
    </requests>
</response>
```
11:53:27.042 TRACE edu.ucr.cs.riple.core.checkers.nullaway.codefix.Response.<init>
Creating Response:
```xml
<response>
    <reason><![CDATA[Without additional context about what "Game.loop()" returns and its implementation, it is unclear whether the expression can be null.]]></reason>
    <value>UNKNOWN</value>
    <requests>
        <request><![CDATA[Information about the return value of "Game.loop()".]]></request>
        <request><![CDATA[Details on the "Game" class implementation.]]></request>
    </requests>
</response>
```
11:53:27.042 TRACE edu.ucr.cs.riple.core.checkers.nullaway.codefix.Response.<init>
Response created:
Unknown: Without additional context about what "Game.loop()" returns and its implementation, it is unclear whether the expression can be null.
11:53:27.043 TRACE edu.ucr.cs.riple.core.checkers.nullaway.codefix.AdvancedNullAwayCodeFix.resolveMethodDereferenceError
Resolving method dereference error.
11:53:27.043 TRACE edu.ucr.cs.riple.core.checkers.nullaway.codefix.AdvancedNullAwayCodeFix.resolveMethodDereferenceError
Method is in annotated package. Checking if the method is returning nullable.
11:53:27.043 TRACE edu.ucr.cs.riple.core.checkers.nullaway.codefix.AdvancedNullAwayCodeFix.investigateMethodReturnNullability
Checking if the method is returning nullable.
11:53:27.045 TRACE edu.ucr.cs.riple.core.checkers.nullaway.codefix.ChatGPT.checkIfMethodIsReturningNullable
Asking if the method is returning nullable: loop()
11:53:27.047 TRACE edu.ucr.cs.riple.core.checkers.nullaway.codefix.ChatGPT.ask
Asking ChatGPT:
In the method below, is there a possibility that the method returns null based only on its body? Consider the following points:

- The method may have multiple return paths; consider all return statements.
- If the method calls another method, do not assume its return value unless its full declaration is provided. Request its declaration if needed.
- The method may throw an exception instead of returning null. An exception path should not be considered a null return.
- Ensure you request the declarations of any methods whose return values directly or indirectly impact this methods return value before making a conclusion.
- Carefully analyze all conditions and prior operations that may guarantee a non-null return value.

@Nullable public static IGameLoop loop() {
    return gameLoop;
}

Here are the method definitions in addition to the method inquired:

Depth: 0
```java
class de.gurkenlabs.litiengine.Game {
@Nullable public static IGameLoop loop() {
    return gameLoop;
}
}
```


Response Format:
Provide the answer in **XML format** as follows:

#### If the method **cannot** return `null`:
```xml
<response>
  <reason><![CDATA[EXPLAIN WHY THE METHOD CANNOT RETURN NULL]]></reason>
  <value>NO</value>
</response>
```

#### If the method can return null:
```xml
<response>
  <reason><![CDATA[EXPLAIN WHY THE METHOD CAN RETURN NULL]]></reason>
  <value>YES</value>
</response>
```

#### If you are unsure or need more information, respond with where you can ask for more details or what specific information you need.

#### If you are unsure or If there are any methods that directly or indirectly affect the return value and are not fully disclosed, request their declarations first, in the following format:
<response>
  <reason><![CDATA[YOUR REASON]]></reason>
  <value>UNKNOWN</value>
  <methods>
    <method>methodName</method>
  </methods>
</response>

If additional information is required other than method declaration, list each request inside a `<request>` tag. If no additional information is needed, omit the `<requests>` section.

Respond with:
```xml
<response>
    <reason><![CDATA[YOUR REASON]]></reason>
    <value>UNKNOWN</value>
    <!-- Include <requests> only if additional information is needed -->
    <requests>
        <request><![CDATA[YOUR REQUEST 1]]></request>
        <request><![CDATA[YOUR REQUEST 2]]></request>
    </requests>
</response>
```

Additional Notes:
Be precise in your reasoning.
If a methods return value depends on another method not provided, request its declaration before making a conclusion.
If the method can return null in some cases but not others, explain under what conditions it can happen.

11:53:27.047 TRACE edu.ucr.cs.riple.core.checkers.nullaway.codefix.ChatGPT.ask
Retrieving response from cache
11:53:27.047 TRACE edu.ucr.cs.riple.core.checkers.nullaway.codefix.Response.tryCreate
Trying to create Response:
```xml
<response>
  <reason><![CDATA[The method `loop` returns the variable `gameLoop`. Without the initialization or assignment details of `gameLoop`, it's unclear whether it can be null. The possibility of `gameLoop` being uninitialized or set to null elsewhere in the program means `loop` could potentially return null. Further information on `gameLoop` is required.]]></reason>
  <value>UNKNOWN</value>
  <requests>
    <request><![CDATA[Please provide the declaration and initialization of the variable `gameLoop` in the class `de.gurkenlabs.litiengine.Game`.]]></request>
  </requests>
</response>
```
11:53:27.047 TRACE edu.ucr.cs.riple.core.checkers.nullaway.codefix.Response.<init>
Creating Response:
```xml
<response>
  <reason><![CDATA[The method `loop` returns the variable `gameLoop`. Without the initialization or assignment details of `gameLoop`, it's unclear whether it can be null. The possibility of `gameLoop` being uninitialized or set to null elsewhere in the program means `loop` could potentially return null. Further information on `gameLoop` is required.]]></reason>
  <value>UNKNOWN</value>
  <requests>
    <request><![CDATA[Please provide the declaration and initialization of the variable `gameLoop` in the class `de.gurkenlabs.litiengine.Game`.]]></request>
  </requests>
</response>
```
11:53:27.047 TRACE edu.ucr.cs.riple.core.checkers.nullaway.codefix.Response.<init>
Response created:
Unknown: The method `loop` returns the variable `gameLoop`. Without the initialization or assignment details of `gameLoop`, it's unclear whether it can be null. The possibility of `gameLoop` being uninitialized or set to null elsewhere in the program means `loop` could potentially return null. Further information on `gameLoop` is required.
11:53:27.048 TRACE edu.ucr.cs.riple.core.checkers.nullaway.codefix.AdvancedNullAwayCodeFix.investigateMethodReturnNullability
Could not determine the nullability and model did not ask for any method.
11:53:27.048 TRACE edu.ucr.cs.riple.core.checkers.nullaway.codefix.ChatGPT.checkIfMethodIsReturningNullableOnCallSite
Asking if the method is returning nullable on the call site: Game.loop()
11:53:27.287 TRACE edu.ucr.cs.riple.core.checkers.nullaway.codefix.ChatGPT.ask
Asking ChatGPT:
In the method below, is there a possibility that the method returns null at the given call site?

```java
@Nullable public static IGameLoop loop() {
    return gameLoop;
}
```

## Guidelines:
- The method may have multiple return paths; consider all return statements.
- If the method calls another method, do not assume its return value unless its full declaration is provided. Request its declaration if needed.
- The method may throw an exception instead of returning null. An exception path should not be considered a null return.
- Ensure you request the declarations of any methods whose return values directly or indirectly impact this methods return value before making a conclusion.
- If the method returns a value that is determined by a parameter, evaluate based on the actual argument at the given call site.
- Analyze based only on the specific invocation provided. Do not generalize to all possible inputs.- If the return value is guaranteed to be non-null at the call site, the answer should be a definitive NO.
- Do not generalize based on all possible inputsyour answer must be based only on the given invocation.
- Focus only on the given call site, not all possible invocations.

### call site:
Game.loop()

Here are the method definitions and the call chain for this method, showing the sequence of calls from the method to its callers at each depth level:

Depth: 0
```java
class de.gurkenlabs.litiengine.Game {
@Nullable public static IGameLoop loop() {
    return gameLoop;
}
}
```
Depth: 1
```java
class de.gurkenlabs.litiengine.environment.GameWorld {
public void loadEnvironment(@Nullable final Environment env) {
    Lock lock = Game.loop().getLock();
    lock.lock();
    try {
      unloadEnvironment();
      this.environment = env;
      if (env != null) {
        this.addEnvironment(env);

        if (env.getGravity() == 0 && this.gravity() != 0) {
          env.setGravity(this.gravity());
        }

        env.load();
        for (final EnvironmentLoadedListener listener : this.loadedListeners) {
          listener.loaded(env);
        }

        // call map specific listeners
        String mapName = getMapName(env);
        if (mapName != null && this.environmentLoadedListeners.containsKey(mapName)) {

          // for the default camera we center the camera on the environment
          if (this.camera().getClass().equals(Camera.class)) {
            camera().setFocus(env.getCenter());
          }

          for (EnvironmentLoadedListener listener : this.environmentLoadedListeners.get(mapName)) {
            listener.loaded(env);
          }
        }
      }
    } finally {
      lock.unlock();
    }
}public void setCamera(@Nullable final ICamera cam) {
    if (this.camera() != null) {
      Game.loop().detach(camera);
    }

    camera = cam;

    if (cam != null && !Game.isInNoGUIMode()) {
      Game.loop().attach(cam);
      cam.updateFocus();
    }
}
}
```
```java
class de.gurkenlabs.litiengine.entities.behavior.EntityNavigator {
public EntityNavigator(final IMobileEntity entity, final PathFinder pathFinder) {
    this.cancelNavigationConditions = new CopyOnWriteArrayList<>();
    this.listeners = new CopyOnWriteArrayList<>();
    this.entity = entity;
    this.pathFinder = pathFinder;
    this.setAcceptableError(DEFAULT_ACCEPTABLE_ERROR);
    Game.loop().attach(this);
}
}
```
```java
class de.gurkenlabs.litiengine.GameWindow {
private static void initializeWindowEventListeners(Window window) {

    window.addWindowStateListener(
        e -> {
          if (e.getNewState() == Frame.ICONIFIED) {
            Game.loop().setTickRate(ICONIFIED_MAX_FPS);
          } else {
            Game.loop().setTickRate(Game.config().client().getMaxFps());
          }
        });

    window.addWindowFocusListener(
        new WindowFocusListener() {
          @Override
          public void windowLostFocus(WindowEvent e) {
            if (Game.config().graphics().reduceFramesWhenNotFocused()) {
              Game.loop().setTickRate(NONE_FOCUS_MAX_FPS);
            }
          }

          @Override
          public void windowGainedFocus(WindowEvent e) {
            Game.loop().setTickRate(Game.config().client().getMaxFps());
          }
        });

    window.addWindowListener(
        new WindowAdapter() {
          @Override
          public void windowClosing(final WindowEvent event) {
            Game.exit();
          }
        });
}
}
```
```java
class de.gurkenlabs.litiengine.gui.screens.ScreenManager {
public void display(@Nullable final Screen screen) {
      if (Game.hasStarted() && Game.time().since(this.lastScreenChange) < this.getChangeCooldown()) {
        log.log(
            Level.INFO,
            "Skipping displaying of screen {0} because screen changing is currently on cooldown.",
            screen != null ? screen.getName() : "");
        return;
      }
  
      final Screen previous = this.current();
      if (previous != null) {
        previous.suspend();
      }
  
      if (screen != null && !this.screens.contains(screen)) {
        this.screens.add(screen);
      }
  
      this.currentScreen = screen;
      if (!Game.isInNoGUIMode() && this.current() != null) {
        this.current().prepare();
      }
  
      this.lastScreenChange = Nullability.castToNonnull(Game.loop(), "initialized before usage").getTicks();
  
      final ScreenChangedEvent event = new ScreenChangedEvent(this.current(), previous);
      for (final ScreenChangedListener listener : this.screenChangedListeners) {
        listener.changed(event);
      }
}
}
```
```java
class de.gurkenlabs.litiengine.abilities.effects.Effect {
@Override
  public void update() {

    for (final Iterator<EffectApplication> iterator = this.getActiveAppliances().iterator();
        iterator.hasNext(); ) {
      final EffectApplication appliance = iterator.next();
      // if the effect duration is reached
      if (this.hasEnded(appliance)) {

        iterator.remove();
        this.cease(appliance);
      }
    }

    // 4. unregister if all appliances are finished
    if (this.getActiveAppliances().isEmpty()) {
      Game.loop().detach(this);
    }
}public void apply(final Shape impactArea) {
    final List<ICombatEntity> affected = this.lookForAffectedEntities(impactArea);
    for (final ICombatEntity affectedEntity : affected) {
      this.apply(affectedEntity);
    }

    this.appliances.add(new EffectApplication(affected, impactArea));

    // if it is the first appliance -> register for update
    if (this.appliances.size() == 1) {
      Game.loop().attach(this);
    }
}
}
```
```java
class de.gurkenlabs.litiengine.GameTime {
public long toTicks(final int milliseconds) {
    return this.toTicks(milliseconds, Game.loop().getTickRate());
}public long since(final long tick) {
    return toMilliseconds(Game.loop().getTicks() - tick);
}public long now() {
    return Game.loop().getTicks();
}public long sinceGameStart() {
    return this.toMilliseconds(Game.loop().getTicks());
}@Override
  public void loaded(Environment environment) {
    environmentLoaded = Game.loop().getTicks();
}public long toMilliseconds(final long ticks) {
    return this.toMilliseconds(ticks, Game.loop().getTickRate());
}
}
```
```java
class de.gurkenlabs.litiengine.GameMetrics {
@Override
    public void render(final Graphics2D g) {
      this.updateMetrics();
  
      if (!Game.config().client().showGameMetrics()) {
        return;
      }
  
      this.currentOffsetY = 0;
  
      g.setColor(this.renderColor);
  
      // render client metrics
      this.drawTitle(g, "[client]");
      this.drawMetric(g, "fps       : " + this.getFramesPerSecond());
      this.drawMetric(g, "max fps   : " + this.maxFramesPerSecond);
  
      // Use Nullability.castToNonnull to prevent NullAway warning
      this.drawMetric(g, "updatables: " + Nullability.castToNonnull(Game.loop(), "gameLoop always initialized").getUpdatableCount());
  
      // render jvm metrics if debug is enabled
      if (Game.config().debug().isDebugEnabled()) {
        this.drawTitle(g, "[jvm]");
        this.drawMetric(g, "java      : " + this.javaVersion);
        this.drawMetric(g, "memory    : " + String.format("%-5.5s", this.usedMemory) + " MB");
        this.drawMetric(g, "threads   : " + Thread.activeCount());
      }
  
      // render rendering metrics
      if (!this.renderMetrics.isEmpty()) {
        this.drawTitle(g, "[update]");
  
        for (RenderMetrics metric : this.renderMetrics) {
          this.drawMetric(g, metric.toString());
        }
  
        this.renderMetrics.clear();
      }
}
}
```
```java
class de.gurkenlabs.litiengine.graphics.emitters.Emitter {
public void deactivate() {
    if (!this.activated) {
      return;
    }

    this.activated = false;
    this.getParticles().clear();
    this.aliveTime = 0;
    this.activationTick = 0;
    this.lastSpawn = 0;
    Game.loop().detach(this);
}public void activate() {
    if (this.activated) {
      return;
    }

    this.activated = true;
    this.activationTick = Game.time().now();
    Game.loop().attach(this);
}@Override
  public void update() {
    if (this.isPaused()) {
      return;
    }

    // clear particles if the effect time to life is reached
    if (this.isFinished()) {
      for (EmitterFinishedListener listener : this.finishedListeners) {
        listener.finished(this);
      }

      this.delete();
      return;
    }

    final float updateRatio = (float) this.data().getUpdateRate() / Game.loop().getTickRate();
    for (final Particle p : this.getParticles().stream().collect(Collectors.toList())) {
      if (this.particleCanBeRemoved(p)) {
        // remove dead particles
        this.particles.remove(p);
        continue;
      }

      p.update(this.getOrigin(), updateRatio);
    }

    this.aliveTime = Game.time().since(this.activationTick);
    if ((this.data().getSpawnRate() == 0
        || Game.time().since(this.lastSpawn) >= this.data().getSpawnRate())) {
      this.lastSpawn = Game.time().now();
      this.spawnParticle();
    }
}
}
```
```java
class de.gurkenlabs.litiengine.entities.behavior.IBehaviorController {
public default void attach() {
    Game.loop().attach(this);
}public default void detach() {
    Game.loop().detach(this);
}
}
```
```java
class de.gurkenlabs.litiengine.abilities.AbilityExecution {
AbilityExecution(final Ability ability) {
        this.appliedEffects = new CopyOnWriteArrayList<>();
        this.ability = ability;
        this.executionTicks = Game.time().now();
        this.impactArea = ability.calculateImpactArea();
        this.castLocation = ability.getExecutor().getCenter();
        Nullability.castToNonnull(Game.loop(), "proper initialization done").attach(this);
}@Override
  public void update() {
    // if there a no effects to apply -> unregister this instance and we're done
    if (this.getAbility().getEffects().isEmpty()
        || this.getAbility().getEffects().size() == this.getAppliedEffects().size()) {
      Game.loop().detach(this);
      return;
    }

    // handle all effects from the ability that were not applied yet
    for (final Effect effect : this.getAbility().getEffects()) {
      // if the ability was not executed yet or the delay of the effect is not
      // yet reached
      if (this.getAppliedEffects().contains(effect)
          || Game.time().since(this.getExecutionTicks()) < effect.getDelay()) {
        continue;
      }

      effect.apply(this.getExecutionImpactArea());
      this.getAppliedEffects().add(effect);
    }
}
}
```
```java
class de.gurkenlabs.litiengine.GameWindow$3 {
@Override
          public void windowGainedFocus(WindowEvent e) {
            Game.loop().setTickRate(Game.config().client().getMaxFps());
}@Override
          public void windowLostFocus(WindowEvent e) {
            if (Game.config().graphics().reduceFramesWhenNotFocused()) {
              Game.loop().setTickRate(NONE_FOCUS_MAX_FPS);
            }
}
}
```
```java
class de.gurkenlabs.litiengine.environment.EntitySpawner {
protected void spawnNewEntities() {
    if (this.getSpawnMode() != SpawnMode.CUSTOMSPAWNPOINTS && this.getSpawnPoints().isEmpty()) {
      return;
    }

    switch (this.getSpawnMode()) {
      case ALLSPAWNPOINTS:
        for (int i = 0; i < this.getSpawnPoints().size(); i++) {
          final int index = i;
          Game.loop()
              .perform(
                  this.getSpawnDelay() + this.getSpawnDelay() * i,
                  () -> this.spawn(this.getSpawnPoints().get(index), this.getSpawnAmount()));
        }
        break;
      case ONERANDOMSPAWNPOINT:
        this.spawn(Game.random().choose(this.getSpawnPoints()), this.getSpawnAmount());
        break;
      case RANDOMSPAWNPOINTS:
        for (int i = 0; i < this.getSpawnAmount(); i++) {
          Game.loop()
              .perform(
                  this.getSpawnDelay() + this.getSpawnDelay() * i,
                  () -> this.spawn(Game.random().choose(this.getSpawnPoints()), 1));
        }
        break;
      case CUSTOMSPAWNPOINTS:
        List<Spawnpoint> spawnPoints =
            this.customSpawnpoints != null
                ? this.customSpawnpoints.apply(this)
                : this.getCustomSpawnpoints();

        int index = 0;
        for (Spawnpoint spawn : spawnPoints) {
          Game.loop()
              .perform(
                  this.getSpawnDelay() + this.getSpawnDelay() * index, () -> this.spawn(spawn, 1));
          index++;
        }
        break;
      default:
        break;
    }
}
}
```
```java
class de.gurkenlabs.litiengine.tweening.TweenEngine {
@Override
  public void start() {
    Game.loop().attach(this);
}@Override
  public void terminate() {
    Game.loop().detach(this);
}
}
```
```java
class de.gurkenlabs.litiengine.gui.SpeechBubble {
public void hide() {
    Game.world().environment().removeRenderable(this);
    Game.loop().detach(this);
    if (activeSpeechBubbles.get(this.getEntity()) != null
        && activeSpeechBubbles.remove(this.getEntity()).equals(this)) {
      activeSpeechBubbles.remove(this.getEntity());
    }

    for (SpeechBubbleListener listener : this.listeners) {
      listener.hidden();
    }
}private SpeechBubble(
      final IEntity entity,
      final String text,
      @Nullable SpeechBubbleAppearance appearance,
      @Nullable Font font) {
    if (appearance == null) {
      this.appearance = DEFAULT_APPEARANCE;
    } else {
      this.appearance = appearance;
    }

    final SpeechBubble active = activeSpeechBubbles.get(entity);
    if (active != null) {
      active.hide();
    }
    this.setFont(font);

    this.textBoxWidth = (float) (entity.getWidth() * 4);
    this.entity = entity;

    this.currentText = text;
    this.currentTextDisplayTime = DISPLAYTIME_MIN + text.length() * DISPLAYTIME_PER_LETTER;

    this.lastTextDisplay = Game.time().now();
    this.createBubbleImage();
    entity.getEnvironment().add(this, RenderType.UI);
    Game.loop().attach(this);
    activeSpeechBubbles.put(entity, this);
}
}
```
```java
class de.gurkenlabs.litiengine.entities.Prop {
private void updateAnimationController() {
    IEntityAnimationController<?> controller = this.createAnimationController();
    this.getControllers().addController(controller);
    if (Game.world().environment() != null && Game.world().environment().isLoaded()) {
      Game.loop().attach(controller);
    }
}
}
```
```java
class de.gurkenlabs.litiengine.graphics.FreeFlightCamera {
public FreeFlightCamera(final Point2D focus) {
    this.setFocus(focus);
    this.velocity = DEFAULT_SCROLL_PIXELS_PER_SECOND;
    this.scrollPadding = DEFAULT_SCROLL_PADDING;
    this.setClampToMap(true);

    Game.loop().attach(this);
}private void handleFreeFlightCamera() {
      if (Game.world().environment() == null || Game.world().environment().getMap() == null) {
        return;
      }
  
      final Point2D mouseLocation = Input.mouse().getLocation();
  
      final double scrollSpeed =
          this.getVelocity()
              / (double) Nullability.castToNonnull(Game.loop(), "gameLoop always initialized")
                  .getTickRate()
              * Game.config().input().getMouseSensitivity();
  
      double x = this.getFocus().getX();
      double y = this.getFocus().getY();
  
      double deltaX = 0;
      if (mouseLocation.getX() < this.getScrollPadding()) {
        deltaX -= scrollSpeed;
      } else if (Game.window().getResolution().getWidth() - mouseLocation.getX()
          < this.getScrollPadding()) {
        deltaX += scrollSpeed;
      }
  
      double deltaY = 0;
      if (mouseLocation.getY() < this.getScrollPadding()) {
        deltaY -= scrollSpeed;
      } else if (Game.window().getResolution().getHeight() - mouseLocation.getY()
          < this.getScrollPadding()) {
        deltaY += scrollSpeed;
      }
  
      x += deltaX;
      y += deltaY;
  
      this.setFocus(new Point2D.Double(x, y));
}
}
```
```java
class de.gurkenlabs.litiengine.environment.Environment {
private static void dispose(final Collection<? extends IEntity> entities) {
    for (final IEntity entity : entities) {
      if (entity instanceof IUpdateable) {
        Game.loop().detach((IUpdateable) entity);
      }

      entity.detachControllers();
    }
}private static void loadUpdatableOrEmitterEntity(IEntity entity) {
      if (entity instanceof Emitter) {
        final Emitter emitter = (Emitter) entity;
        if (emitter.isActivateOnInit()) {
          emitter.activate();
        }
      } else if (entity instanceof IUpdateable) {
        Nullability.castToNonnull(Game.loop(), "initialized through init").attach((IUpdateable) entity);
      }
}private void unload(final IEntity entity) {
    // 1. remove from physics engine
    if (entity instanceof ICollisionEntity) {
      Game.physics().remove((ICollisionEntity) entity);
    }

    // 2. unregister from update
    if (entity instanceof IUpdateable) {
      Game.loop().detach((IUpdateable) entity);
    }

    if (entity instanceof IMobileEntity) {
      this.removeGravity((IMobileEntity) entity);
    }

    // 3. detach all controllers
    entity.detachControllers();

    if (entity instanceof Emitter) {
      Emitter em = (Emitter) entity;
      em.deactivate();
    }

    if (this.loaded && (entity instanceof LightSource || entity instanceof StaticShadow)) {
      this.updateLighting(entity);
    }

    entity.removed(this);
}
}
```
```java
class de.gurkenlabs.litiengine.graphics.animation.Animation {
@Override
  public void update() {
    // do nothing if the animation is not playing or the current keyframe is not finished
    if (!this.isPlaying()
        || Game.time().since(this.lastFrameUpdate) < this.getCurrentKeyFrame().getDuration()) {
      return;
    }

    // if we are not looping and the last keyframe is finished, we terminate the animation
    if (!this.isLooping() && this.isLastKeyFrame()) {
      this.terminate();
      return;
    }

    // make sure, we stay inside the keyframe list
    final int newFrameIndex =
        (this.getKeyframes().indexOf(this.currentFrame) + 1) % this.getKeyframes().size();
    final KeyFrame previousFrame = this.currentFrame;
    this.currentFrame = this.getKeyframes().get(newFrameIndex);

    for (KeyFrameListener listener : this.listeners) {
      listener.currentFrameChanged(previousFrame, this.currentFrame);
    }

    this.lastFrameUpdate = Game.loop().getTicks();
}public void restart() {
    this.currentFrame = this.firstFrame;
    this.lastFrameUpdate = Game.loop().getTicks();
}
}
```
```java
class de.gurkenlabs.litiengine.physics.MovementController {
@Override
    public void attach() {
      Nullability.castToNonnull(Game.loop(), "properly initialized before use").attach(this);
}private void handleForces() {
    // clean up forces
    this.activeForces.forEach(
        x -> {
          if (x.hasEnded()) {
            this.activeForces.remove(x);
          }
        });

    if (this.activeForces.isEmpty()) {
      return;
    }

    // disable turn-on-move for force handling
    boolean turn = this.getEntity().turnOnMove();
    this.getEntity().setTurnOnMove(false);
    try {
      double deltaX = 0;
      double deltaY = 0;
      for (final Force force : this.activeForces) {
        if (force.cancelOnReached() && force.hasReached(this.getEntity())) {
          force.end();
          continue;
        }

        final Point2D collisionBoxCenter = this.getEntity().getCollisionBoxCenter();
        final double angle =
            GeometricUtilities.calcRotationAngleInDegrees(collisionBoxCenter, force.getLocation());
        final double strength =
            Game.loop().getDeltaTime() * 0.001f * force.getStrength() * Game.loop().getTimeScale();
        deltaX += GeometricUtilities.getDeltaX(angle, strength);
        deltaY += GeometricUtilities.getDeltaY(angle, strength);
      }

      final Point2D target =
          new Point2D.Double(this.getEntity().getX() + deltaX, this.getEntity().getY() + deltaY);
      final boolean success = Game.physics().move(this.getEntity(), target);
      if (!success) {
        for (final Force force : this.activeForces) {
          if (force.cancelOnCollision()) {
            force.end();
          }
        }
      }
    } finally {
      this.getEntity().setTurnOnMove(turn);
    }
}@Override
  public void detach() {
    Game.loop().detach(this);
}public void handleMovement() {
    if (!this.isMovementAllowed()) {
      this.velocity = 0;
      return;
    }

    // max distance an entity can travel within one tick
    final double maxPixelsPerTick = this.getEntity().getTickVelocity();
    final double deltaTime = Game.loop().getDeltaTime() * Game.loop().getTimeScale();

    final double acceleration =
        this.getEntity().getAcceleration() == 0
            ? maxPixelsPerTick
            : deltaTime / this.getEntity().getAcceleration() * maxPixelsPerTick;
    final double deceleration =
        this.getEntity().getDeceleration() == 0
            ? this.getVelocity()
            : deltaTime / this.getEntity().getDeceleration() * maxPixelsPerTick;

    double dx = this.getDx();
    double dy = this.getDy();
    this.setDx(0);
    this.setDy(0);

    final double deltaVelocity =
        Math.min(Math.sqrt(Math.pow(dx, 2) + Math.pow(dy, 2)), acceleration);
    if (deltaVelocity != 0) {
      double newVelocity = this.getVelocity() + deltaVelocity;
      this.setVelocity(newVelocity);
    } else {
      final double newVelocity = Math.max(0, this.getVelocity() - deceleration);
      this.setVelocity(newVelocity);
      dx = GeometricUtilities.getDeltaX(this.moveAngle);
      dy = GeometricUtilities.getDeltaY(this.moveAngle);
    }

    if (this.getVelocity() == 0) {
      this.moveAngle = 0;
      return;
    }

    // actually move entity
    this.moveEntity(dx, dy);
}
}
```
```java
class de.gurkenlabs.litiengine.graphics.animation.AnimationController {
public void detach() {
    Game.loop().detach(this);
}public void attach() {
    Game.loop().attach(this);
}
}
```
```java
class de.gurkenlabs.litiengine.graphics.Camera {
@Override
  public void setZoom(final float targetZoom, final int delay) {
    if (delay == 0) {

      this.zoom = targetZoom;
      this.targetZoom = 0;
      this.zoomDelay = 0;
      this.zoomTick = 0;
      this.zoomStep = 0;

      final ZoomChangedEvent event = new ZoomChangedEvent(this, targetZoom);
      for (final ZoomChangedListener listener : this.zoomListeners) {
        listener.zoomChanged(event);
      }
    } else {
      this.zoomTick = Game.time().now();
      this.targetZoom = targetZoom;
      this.zoomDelay = delay;

      final double tickduration = 1000 / (double) Game.loop().getTickRate();
      final double tickAmount = delay / tickduration;
      final float totalDelta = this.targetZoom - this.zoom;
      this.zoomStep = tickAmount > 0 ? (float) (totalDelta / tickAmount) : totalDelta;
    }
}
}
```
```java
class de.gurkenlabs.litiengine.Game {
public static synchronized void init(String... args) {
    if (initialized) {
      log().log(Level.INFO, "The game has already been initialized.");
      return;
    }

    log.init();
    handleCommandLineArguments(args);

    config().load();
    Locale.setDefault(new Locale(config().client().getCountry(), config().client().getLanguage()));

    gameLoop = new GameLoop("Main Update Loop", config().client().getMaxFps());
    loop().attach(physics());
    loop().attach(world());

    // setup default exception handling for render and update loop
    setUncaughtExceptionHandler(
        new DefaultUncaughtExceptionHandler(config().client().exitOnError()));

    screenManager = new ScreenManager();
    gameWindow = new GameWindow();

    // initialize  the game window
    window().init();
    world.setCamera(new Camera());

    for (GameListener listener : gameListeners) {
      listener.initialized(args);
    }

    if (!isInNoGUIMode()) {
      window().getRenderComponent().onRendered(g -> metrics().render(g));

      graphics()
          .addEntityRenderedListener(
              e -> DebugRenderer.renderEntityDebugInfo(e.getGraphics(), e.getEntity()));

      window().getRenderComponent().onFpsChanged(fps -> metrics().setFramesPerSecond(fps));
      window()
          .setIcons(
              Arrays.asList(
                  Resources.images().get("liti-logo-x16.png"),
                  Resources.images().get("liti-logo-x20.png"),
                  Resources.images().get("liti-logo-x32.png"),
                  Resources.images().get("liti-logo-x48.png")));

      Input.keyboard()
          .onKeyTyped(
              KeyEvent.VK_PRINTSCREEN,
              key -> {
                // don't take a screenshot if a modifier is active
                if (key.getModifiers() != 0) {
                  return;
                }

                window().getRenderComponent().takeScreenshot();
              });
    }

    Runtime.getRuntime().addShutdownHook(new Thread(Game::terminate, "Shutdown"));

    initialized = true;
}
}
```
```java
class de.gurkenlabs.litiengine.entities.Creature {
protected void updateAnimationController() {
        IEntityAnimationController<?> controller = this.createAnimationController();
        this.getControllers().addController(controller);
        if (Game.world().environment() != null && Game.world().environment().isLoaded()) {
            Nullability.castToNonnull(Game.loop(), "expected to be non-null").attach(controller);
        }
}@Override
  public float getTickVelocity() {
    // pixels per ms multiplied by the passed ms
    // ensure that entities don't travel too far in case of lag
    return Math.min(Game.loop().getDeltaTime(), GameLoop.TICK_DELTATIME_LAG)
        * 0.001F
        * this.getVelocity().get()
        * Game.loop().getTimeScale();
}
}
```
Depth: 2
```java
class de.gurkenlabs.litiengine.environment.GameWorld {
public void clear() {
    this.unloadEnvironment();
    this.environments.clear();
    this.setCamera(null);
    Game.physics().clear();

    this.environmentListeners.clear();
    this.environmentLoadedListeners.clear();
    this.environmentUnloadedListeners.clear();

    this.listeners.clear();
    this.loadedListeners.clear();
    this.unloadedListeners.clear();
}@Nullable
  public Environment loadEnvironment(IMap map) {
    Environment env = this.getEnvironment(map);
    this.loadEnvironment(env);
    return env;
}@Nullable
  public Environment loadEnvironment(String mapName) {
    Environment env = this.getEnvironment(mapName);
    this.loadEnvironment(env);
    return env;
}
}
```
```java
class de.gurkenlabs.litiengine.GameWindow {
GameWindow() {
    this.hostControl = new JFrame();

    this.resolutionChangedListeners = new CopyOnWriteArrayList<>();

    this.renderCanvas = new RenderComponent(Game.config().graphics().getResolution());
    this.cursor = new MouseCursor();
    if (!Game.isInNoGUIMode()) {
      this.hostControl.setBackground(Color.BLACK);
      this.hostControl.add(this.renderCanvas);

      this.initializeEventListeners();

      this.hostControl.setTitle(Game.info().getTitle());
      this.hostControl.setDefaultCloseOperation(WindowConstants.DO_NOTHING_ON_CLOSE);
      initializeWindowEventListeners(this.hostControl);
    }
}
}
```
```java
class de.gurkenlabs.litiengine.GameTime {
public long sinceEnvironmentLoad() {
    return this.since(this.environmentLoaded);
}public long since(final long tick) {
    return toMilliseconds(Game.loop().getTicks() - tick);
}public long sinceGameStart() {
    return this.toMilliseconds(Game.loop().getTicks());
}
}
```
```java
class de.gurkenlabs.litiengine.abilities.effects.Effect {
protected void cease(final EffectApplication appliance) {
    // 1. cease the effect for all affected entities
    for (final ICombatEntity entity : appliance.getAffectedEntities()) {
      this.cease(entity);
    }

    // 2. apply follow up effects
    this.getFollowUpEffects().forEach(followUp -> followUp.apply(appliance.getImpactArea()));
}protected boolean hasEnded(final EffectApplication appliance) {
    final long effectDuration = Game.time().since(appliance.getAppliedTicks());
    return effectDuration > this.getDuration();
}
}
```
```java
class de.gurkenlabs.litiengine.abilities.effects.EffectApplication {
protected EffectApplication(final List<ICombatEntity> affectedEntities, final Shape impactArea) {
    this.applied = Game.time().now();
    this.affectedEntities = affectedEntities;
    this.impactArea = impactArea;
}
}
```
```java
class de.gurkenlabs.litiengine.entities.CombatEntity {
@Override
  public boolean wasHit(int timeSpan) {
    return Game.time().since(this.lastHit) < timeSpan;
}@Override
  public void hit(final int damage, @Nullable final Ability ability) {
    if (this.isDead()) {
      return;
    }

    if (!this.isIndestructible()) {
      this.getHitPoints().modifyBaseValue(new AttributeModifier<>(Modification.SUBTRACT, damage));
    }

    final EntityHitEvent event = new EntityHitEvent(this, ability, damage, this.isDead());

    for (final CombatEntityListener listener : this.listeners) {
      listener.hit(event);
    }

    for (final CombatEntityHitListener listener : this.hitListeners) {
      listener.hit(event);
    }

    if (this.isDead()) {
      this.fireDeathEvent();
      this.setCollision(false);
    }

    this.lastHit = Game.time().now();
}
}
```
```java
class de.gurkenlabs.litiengine.graphics.ImageEffect {
protected ImageEffect(final int ttl, final String name) {
    this.ttl = ttl;
    this.name = name;
    this.aliveTick = Game.time().now();
}@Override
  public long getAliveTime() {
    return Game.time().since(this.aliveTick);
}
}
```
```java
class de.gurkenlabs.litiengine.abilities.AbilityExecution {
AbilityExecution(final Ability ability) {
        this.appliedEffects = new CopyOnWriteArrayList<>();
        this.ability = ability;
        this.executionTicks = Game.time().now();
        this.impactArea = ability.calculateImpactArea();
        this.castLocation = ability.getExecutor().getCenter();
        Nullability.castToNonnull(Game.loop(), "proper initialization done").attach(this);
}@Override
  public void update() {
    // if there a no effects to apply -> unregister this instance and we're done
    if (this.getAbility().getEffects().isEmpty()
        || this.getAbility().getEffects().size() == this.getAppliedEffects().size()) {
      Game.loop().detach(this);
      return;
    }

    // handle all effects from the ability that were not applied yet
    for (final Effect effect : this.getAbility().getEffects()) {
      // if the ability was not executed yet or the delay of the effect is not
      // yet reached
      if (this.getAppliedEffects().contains(effect)
          || Game.time().since(this.getExecutionTicks()) < effect.getDelay()) {
        continue;
      }

      effect.apply(this.getExecutionImpactArea());
      this.getAppliedEffects().add(effect);
    }
}
}
```
```java
class de.gurkenlabs.litiengine.tweening.TweenEngine {
@Override
  public void update() {
    for (final Tweenable target : this.getTweens().keySet()) {
      for (final Tween tween : this.getTweens().get(target).values()) {
        if (tween.hasStopped()) {
          continue;
        }
        final long elapsed = Game.time().since(tween.getStartTime());
        if (elapsed >= tween.getDuration()) {
          tween.stop();
          continue;
        }
        final float[] currentValues = new float[tween.getTargetValues().length];
        for (int i = 0; i < tween.getTargetValues().length; i++) {
          currentValues[i] =
              tween.getStartValues()[i]
                  + tween.getEquation().compute(elapsed / (float) tween.getDuration())
                      * (tween.getTargetValues()[i] - tween.getStartValues()[i]);
        }
        tween.getTarget().setTweenValues(tween.getType(), currentValues);
      }
    }
}
}
```
```java
class de.gurkenlabs.litiengine.gui.SpeechBubble {
public static SpeechBubble create(
      final IEntity entity, final String text, SpeechBubbleAppearance appearance, Font font) {
    return new SpeechBubble(entity, text, appearance, font);
}public static SpeechBubble create(final IEntity entity, final Font font, final String text) {
    SpeechBubbleAppearance app =
        new SpeechBubbleAppearance(
            DEFAULT_APPEARANCE.getForeColor(),
            DEFAULT_APPEARANCE.getBackgroundColor1(),
            DEFAULT_APPEARANCE.getBorderColor(),
            DEFAULT_APPEARANCE.getPadding());
    return new SpeechBubble(entity, text, app, font);
}public static SpeechBubble create(final IEntity entity, final String text) {
    return new SpeechBubble(entity, text, null, GuiProperties.getDefaultFont());
}@Override
  public void update() {
    if (this.currentText == null) {
      this.hide();
      return;
    }

    this.entityCenter = Game.world().camera().getViewportLocation(this.getEntity().getCenter());

    // old text was displayed long enough
    if (this.lastTextDisplay != 0
        && Game.time().since(this.lastTextDisplay) > this.currentTextDisplayTime) {
      this.currentText = null;
      this.lastTextDisplay = 0;
      return;
    }

    // display new text
    if (this.textIndex < this.currentText.length()
        && Game.time().since(this.lastCharPoll) > LETTER_WRITE_DELAY) {
      this.textIndex++;
      this.lastCharPoll = Game.time().now();
      if (this.typeSound != null) {
        Game.audio().playSound(this.typeSound, this.getEntity());
      }
    }

    // continue displaying currently displayed text
}private SpeechBubble(
      final IEntity entity,
      final String text,
      final Sound typeSound,
      SpeechBubbleAppearance appearance,
      Font font) {
    this(entity, text, appearance, font);
    this.typeSound = typeSound;
}private SpeechBubble(
      final IEntity entity,
      final String text,
      @Nullable SpeechBubbleAppearance appearance,
      @Nullable Font font) {
    if (appearance == null) {
      this.appearance = DEFAULT_APPEARANCE;
    } else {
      this.appearance = appearance;
    }

    final SpeechBubble active = activeSpeechBubbles.get(entity);
    if (active != null) {
      active.hide();
    }
    this.setFont(font);

    this.textBoxWidth = (float) (entity.getWidth() * 4);
    this.entity = entity;

    this.currentText = text;
    this.currentTextDisplayTime = DISPLAYTIME_MIN + text.length() * DISPLAYTIME_PER_LETTER;

    this.lastTextDisplay = Game.time().now();
    this.createBubbleImage();
    entity.getEnvironment().add(this, RenderType.UI);
    Game.loop().attach(this);
    activeSpeechBubbles.put(entity, this);
}
}
```
```java
class de.gurkenlabs.litiengine.gui.TextFieldComponent {
@Override
  public void render(final Graphics2D g) {
    super.render(g);
    g.setFont(this.getFont());
    final FontMetrics fm = g.getFontMetrics();

    if (this.isSelected() && Game.time().since(this.lastToggled) > this.flickerDelay) {
      this.cursorVisible = !this.cursorVisible;
      this.lastToggled = Game.time().now();
    }
    if (this.isSelected() && this.cursorVisible) {
      final Rectangle2D cursor =
          new Rectangle2D.Double(
              this.getX() + this.getTextX() + fm.stringWidth(this.getTextToRender(g)),
              this.getY() + this.getTextY(),
              this.getFont().getSize2D() * 3 / 5,
              this.getFont().getSize2D() * 1 / 5);
      g.setColor(this.getAppearance().getForeColor());
      g.fill(cursor);
    }
}
}
```
```java
class de.gurkenlabs.litiengine.entities.Prop {
public Prop(
      final Point2D location, @Nullable final String spritesheetName, final Material material) {
    super();
    this.rotation = Rotation.NONE;
    this.spritesheetName = spritesheetName;
    this.material = material;
    this.setLocation(location);
    this.updateAnimationController();
}public void setSpritesheetName(@Nullable final String spriteName) {
    this.spritesheetName = spriteName;
    this.updateAnimationController();
}
}
```
```java
class de.gurkenlabs.litiengine.tweening.Tween {
public Tween begin() {
    this.started = Game.time().now();
    this.stopped = false;
    return this;
}
}
```
```java
class de.gurkenlabs.litiengine.graphics.emitters.particles.Particle {
public void update(final Point2D emitterOrigin, final float updateRatio) {
    if (this.aliveTick == 0) {
      this.aliveTick = Game.time().now();
    }

    this.aliveTime = Game.time().since(this.aliveTick);
    if (this.timeToLiveReached()) {
      return;
    }

    if (this.colliding) {
      return;
    }

    if (this.getDeltaWidth() != 0) {
      this.width += this.getDeltaWidth() * updateRatio;
    }

    if (this.getDeltaHeight() != 0) {
      this.height += this.getDeltaHeight() * updateRatio;
    }

    if (this.getDeltaAngle() != 0) {
      this.angle += this.getDeltaAngle() * updateRatio;
    }

    // test for ray cast collision
    final float targetX = this.x + this.getVelocityX() * updateRatio;
    final float targetY = this.y + this.getVelocityY() * updateRatio;

    if (targetX == this.x && targetY == this.y) {
      return;
    }

    if (this.checkForCollision(emitterOrigin, targetX, targetY)) {
      return;
    }

    if (this.getVelocityX() != 0) {
      this.x = targetX;
    }

    if (this.getVelocityY() != 0) {
      this.y = targetY;
    }

    if (this.getAccelerationX() != 0) {
      this.velocityX += this.getAccelerationX() * updateRatio;
    }

    if (this.getAccelerationY() != 0) {
      this.velocityY += this.getAccelerationY() * updateRatio;
    }
}
}
```
```java
class de.gurkenlabs.litiengine.graphics.animation.Animation {
@Override
  public void start() {
    this.playing = true;
    if (this.getKeyframes().isEmpty()) {
      return;
    }

    this.restart();
}@Override
  public void update() {
    // do nothing if the animation is not playing or the current keyframe is not finished
    if (!this.isPlaying()
        || Game.time().since(this.lastFrameUpdate) < this.getCurrentKeyFrame().getDuration()) {
      return;
    }

    // if we are not looping and the last keyframe is finished, we terminate the animation
    if (!this.isLooping() && this.isLastKeyFrame()) {
      this.terminate();
      return;
    }

    // make sure, we stay inside the keyframe list
    final int newFrameIndex =
        (this.getKeyframes().indexOf(this.currentFrame) + 1) % this.getKeyframes().size();
    final KeyFrame previousFrame = this.currentFrame;
    this.currentFrame = this.getKeyframes().get(newFrameIndex);

    for (KeyFrameListener listener : this.listeners) {
      listener.currentFrameChanged(previousFrame, this.currentFrame);
    }

    this.lastFrameUpdate = Game.loop().getTicks();
}
}
```
```java
class de.gurkenlabs.litiengine.graphics.animation.AnimationController {
@Override
  public void update() {
    for (final Animation animation : this.getAll()) {
      animation.update();
    }

    if (this.getCurrent() != null && this.getCurrent().isPaused()) {
      return;
    }

    final boolean playbackFinished = this.getCurrent() != null && !this.getCurrent().isPlaying();
    if (playbackFinished) {
      for (final AnimationListener listener : this.listeners) {
        listener.finished(this.getCurrent());
      }
    }

    if (this.getCurrent() == null || playbackFinished) {
      if (this.getDefault() != null) {
        this.play(this.getDefault().getName());
      } else {
        this.currentAnimation = null;
      }
    }
}
}
```
```java
class de.gurkenlabs.litiengine.graphics.RenderComponent {
private void handleFade() {
    if (this.fadeOutStart != -1) {
      final long timePassed = Game.time().since(this.fadeOutStart);
      this.currentAlpha = MathUtilities.clamp(1 - timePassed / (float) this.fadeOutTime, 0, 1);
      if (this.currentAlpha == 0f) {
        this.fadeOutStart = -1;
        this.fadeOutTime = -1;
      }

      return;
    }

    if (this.fadeInStart != -1) {
      final long timePassed = Game.time().since(this.fadeInStart);
      this.currentAlpha = MathUtilities.clamp(timePassed / (float) this.fadeInTime, 0, 1);
      if (this.currentAlpha == 1f) {
        this.fadeInStart = -1;
        this.fadeInTime = -1;
        this.currentAlpha = Float.NaN;
      }
    }
}public void fadeOut(final int ms) {
    this.fadeInStart = -1;
    this.fadeInTime = -1;
    this.fadeOutStart = Game.time().now();
    this.fadeOutTime = ms;
}public void fadeIn(final int ms) {
    this.fadeOutStart = -1;
    this.fadeOutTime = -1;
    this.fadeInStart = Game.time().now();
    this.fadeInTime = ms;
}
}
```
```java
class de.gurkenlabs.litiengine.entities.Trigger {
private boolean activate(final IEntity activator, final int tar) {
    if (!this.isLoaded()
        || this.isOneTimeTrigger && this.isActivated
        || this.getActivationType() == TriggerActivation.COLLISION
            && activator != null
            && this.collisionActivated.contains(activator)) {
      return false;
    }

    if (this.getCooldown() > 0 && Game.time().since(this.lastActivation) < this.getCooldown()) {
      return false;
    }

    List<Integer> triggerTargets = this.getTargets(tar);

    final TriggerEvent te = new TriggerEvent(this, activator, triggerTargets);

    if (!this.checkActivationPredicates(te)) {
      return false;
    }

    this.isActivated = true;
    if (activator != null) {
      this.collisionActivated.add(activator);
    }

    // if we actually have a trigger target, we send the message to the target
    for (final int target : triggerTargets) {
      final IEntity entity = this.getEnvironment().get(target);
      if (entity == null) {
        log.log(
            Level.WARNING,
            "trigger [{0}] was activated, but the trigger target [{1}] could not be found on the environment",
            new Object[] {this, target});
        continue;
      }

      entity.sendMessage(this, this.message);
    }

    // also send the trigger event to all registered consumers
    for (final TriggerActivatedListener listener : this.activatedListeners) {
      listener.activated(te);
    }

    if (this.isOneTimeTrigger) {
      this.getEnvironment().remove(this);
    }

    this.lastActivation = Game.time().now();
    return true;
}
}
```
```java
class de.gurkenlabs.litiengine.graphics.Camera {
private boolean isShakeEffectActive() {
    return this.getShakeTick() != 0
        && Game.time().since(this.getShakeTick()) < this.getShakeDuration();
}@Override
  public void update() {
    if (Game.world().camera() != null && !Game.world().camera().equals(this)) {
      return;
    }

    if (this.targetZoom > 0) {
      if (Game.time().since(this.zoomTick) >= this.zoomDelay) {
        this.zoom = this.targetZoom;
        this.targetZoom = 0;
        this.zoomDelay = 0;
        this.zoomTick = 0;
        this.zoomStep = 0;
      } else {
        this.zoom += this.zoomStep;
      }

      final ZoomChangedEvent event = new ZoomChangedEvent(this, this.getZoom());
      for (final ZoomChangedListener listener : this.zoomListeners) {
        listener.zoomChanged(event);
      }
    }

    if (this.panTime > 0) {
      if (--this.panTime <= 0) {
        this.setFocus(this.targetFocus);
        this.targetFocus = null;
      } else {
        double diff = this.panTime / (this.panTime + 1.0);
        this.focus =
            new Point2D.Double(
                this.focus.getX() * diff + this.targetFocus.getX() * (1.0 - diff),
                this.focus.getY() * diff + this.targetFocus.getY() * (1.0 - diff));
      }
    }

    if (!this.isShakeEffectActive()) {
      this.shakeOffsetX = 0;
      this.shakeOffsetY = 0;
      return;
    }

    if (Game.time().since(this.lastShake) > this.shakeDelay) {
      this.shakeOffsetX = this.getShakeIntensity() * ThreadLocalRandom.current().nextGaussian();
      this.shakeOffsetY = this.getShakeIntensity() * ThreadLocalRandom.current().nextGaussian();
      this.lastShake = Game.time().now();
    }
}@Override
  public void setZoom(final float targetZoom, final int delay) {
    if (delay == 0) {

      this.zoom = targetZoom;
      this.targetZoom = 0;
      this.zoomDelay = 0;
      this.zoomTick = 0;
      this.zoomStep = 0;

      final ZoomChangedEvent event = new ZoomChangedEvent(this, targetZoom);
      for (final ZoomChangedListener listener : this.zoomListeners) {
        listener.zoomChanged(event);
      }
    } else {
      this.zoomTick = Game.time().now();
      this.targetZoom = targetZoom;
      this.zoomDelay = delay;

      final double tickduration = 1000 / (double) Game.loop().getTickRate();
      final double tickAmount = delay / tickduration;
      final float totalDelta = this.targetZoom - this.zoom;
      this.zoomStep = tickAmount > 0 ? (float) (totalDelta / tickAmount) : totalDelta;
    }
}@Override
  public void shake(final double intensity, final int delay, final int shakeDuration) {
    this.shakeTick = Game.time().now();
    this.shakeDelay = delay;
    this.shakeIntensity = intensity;
    this.shakeDuration = shakeDuration;
}
}
```
```java
class de.gurkenlabs.litiengine.entities.Creature {
public void setSpritesheetName(String spritesheetName) {
    if (this.spritesheetName != null && this.spritesheetName.equals(spritesheetName)) {
      return;
    }

    this.spritesheetName = spritesheetName;
    this.updateAnimationController();
}public boolean isIdle() {
    return Game.time().since(this.lastMoved) > IDLE_DELAY;
}@Override
  public void setLocation(final Point2D position) {
    if (this.isDead() || position == null) {
      return;
    }

    final Point2D oldLocation = this.getLocation();
    super.setLocation(position);

    if (Game.hasStarted() && this.isLoaded()) {
      this.lastMoved = Game.time().now();
      this.fireMovedEvent(
          new EntityMovedEvent(
              this, this.getX() - oldLocation.getX(), this.getY() - oldLocation.getY()));
    }
}
}
```
```java
class de.gurkenlabs.litiengine.gui.screens.ScreenManager {
public void display(final String screenName) {
    if (this.current() != null && this.current().getName().equalsIgnoreCase(screenName)) {
      log.log(
          Level.INFO,
          "Skipping displaying of screen {0} because it is already the current screen.",
          screenName);
      return;
    }

    if (this.screens.stream()
        .noneMatch(element -> element.getName().equalsIgnoreCase(screenName))) {
      log.log(
          Level.WARNING,
          "Could not display the screen {0} because there is no screen with the specified name.",
          screenName);
      return;
    }

    Screen screen = this.get(screenName);
    if (screen == null) {
      return;
    }

    this.display(screen);
}public void add(final Screen screen) {
    screen.setWidth(Game.window().getWidth());
    screen.setHeight(Game.window().getHeight());
    this.screens.add(screen);

    if (this.current() == null) {
      this.display(screen);
    }
}public void remove(Screen screen) {
    this.screens.remove(screen);
    if (this.current() == screen) {
      if (!this.screens.isEmpty()) {
        this.display(this.screens.get(0));
      } else {
        this.display((Screen) null);
      }
    }
}public void display(@Nullable final Screen screen) {
      if (Game.hasStarted() && Game.time().since(this.lastScreenChange) < this.getChangeCooldown()) {
        log.log(
            Level.INFO,
            "Skipping displaying of screen {0} because screen changing is currently on cooldown.",
            screen != null ? screen.getName() : "");
        return;
      }
  
      final Screen previous = this.current();
      if (previous != null) {
        previous.suspend();
      }
  
      if (screen != null && !this.screens.contains(screen)) {
        this.screens.add(screen);
      }
  
      this.currentScreen = screen;
      if (!Game.isInNoGUIMode() && this.current() != null) {
        this.current().prepare();
      }
  
      this.lastScreenChange = Nullability.castToNonnull(Game.loop(), "initialized before usage").getTicks();
  
      final ScreenChangedEvent event = new ScreenChangedEvent(this.current(), previous);
      for (final ScreenChangedListener listener : this.screenChangedListeners) {
        listener.changed(event);
      }
}
}
```
```java
class de.gurkenlabs.litiengine.abilities.Ability {
public boolean isOnCooldown() {
    return (this.getCurrentExecution() != null
        && this.getCurrentExecution().getExecutionTicks() > 0
        && Game.time().since(this.getCurrentExecution().getExecutionTicks())
            < this.getAttributes().cooldown().get());
}public boolean isActive() {
    return this.getCurrentExecution() != null
        && Game.time().since(this.getCurrentExecution().getExecutionTicks())
            < this.getAttributes().duration().get();
}@Nullable
  public AbilityExecution cast() {
    if (!this.canCast()) {
      return null;
    }
    this.currentExecution = new AbilityExecution(this);

    for (final AbilityCastListener listener : this.abilityCastListeners) {
      listener.abilityCast(this.currentExecution);
    }

    return this.getCurrentExecution();
}public float getRemainingCooldownInSeconds() {
    if (this.getCurrentExecution() == null
        || this.getExecutor() == null
        || this.getExecutor().isDead()) {
      return 0;
    }

    // calculate cooldown in seconds
    return (float)
        (!this.canCast()
            ? (this.getAttributes().cooldown().get()
                    - Game.time().since(this.getCurrentExecution().getExecutionTicks()))
                * 0.001
            : 0);
}
}
```
```java
class de.gurkenlabs.litiengine.entities.EntityHitEvent {
EntityHitEvent(
      final ICombatEntity hitEntity,
      @Nullable final Ability ability,
      final int damage,
      final boolean kill) {
    super(hitEntity);
    this.executor = ability != null ? ability.getExecutor() : null;
    this.hitEntity = hitEntity;
    this.ability = ability;
    this.damage = damage;
    this.kill = kill;
    this.time = Game.time().now();
}
}
```
```java
class de.gurkenlabs.litiengine.graphics.emitters.Emitter {
public void delete() {
    this.deactivate();
    if (Game.world().environment() != null) {
      Game.world().environment().remove(this);
    }
}public void activate() {
    if (this.activated) {
      return;
    }

    this.activated = true;
    this.activationTick = Game.time().now();
    Game.loop().attach(this);
}@Override
  public void update() {
    if (this.isPaused()) {
      return;
    }

    // clear particles if the effect time to life is reached
    if (this.isFinished()) {
      for (EmitterFinishedListener listener : this.finishedListeners) {
        listener.finished(this);
      }

      this.delete();
      return;
    }

    final float updateRatio = (float) this.data().getUpdateRate() / Game.loop().getTickRate();
    for (final Particle p : this.getParticles().stream().collect(Collectors.toList())) {
      if (this.particleCanBeRemoved(p)) {
        // remove dead particles
        this.particles.remove(p);
        continue;
      }

      p.update(this.getOrigin(), updateRatio);
    }

    this.aliveTime = Game.time().since(this.activationTick);
    if ((this.data().getSpawnRate() == 0
        || Game.time().since(this.lastSpawn) >= this.data().getSpawnRate())) {
      this.lastSpawn = Game.time().now();
      this.spawnParticle();
    }
}
}
```
```java
class de.gurkenlabs.litiengine.GameLoop {
@Override
  public int perform(int delay, Runnable action) {
    final long d = Game.time().toTicks(delay);

    TimedAction a = new TimedAction(this.getTicks() + d, action);
    this.actions.add(a);

    return a.getId();
}
}
```
```java
class de.gurkenlabs.litiengine.environment.EntitySpawner {
protected boolean shouldSpawn() {
    return this.lastSpawnWave == 0
        || Game.time().since(this.lastSpawnWave) >= this.getSpawnInterval();
}@Override
  public void update() {
    if (!this.shouldSpawn()) {
      return;
    }

    this.spawnNewEntities();
    this.lastSpawnWave = Game.time().now();
}
}
```
```java
class de.gurkenlabs.litiengine.graphics.FreeFlightCamera {
@Override
  public void update() {
    this.handleFreeFlightCamera();
}public FreeFlightCamera(double x, double y) {
    this(new Point2D.Double(x, y));
}
}
```
```java
class de.gurkenlabs.litiengine.environment.Environment {
public void unload() {
    if (!this.loaded) {
      return;
    }

    // unregister all updatable entities from the current environment
    for (final IEntity entity : this.allEntities.values()) {
      this.unload(entity);
    }

    this.loaded = false;
    this.fireEvent(l -> l.unloaded(this));
}private static void loadUpdatableOrEmitterEntity(IEntity entity) {
      if (entity instanceof Emitter) {
        final Emitter emitter = (Emitter) entity;
        if (emitter.isActivateOnInit()) {
          emitter.activate();
        }
      } else if (entity instanceof IUpdateable) {
        Nullability.castToNonnull(Game.loop(), "initialized through init").attach((IUpdateable) entity);
      }
}public void clear() {
    Game.physics().clear();

    this.combatEntities.clear();
    this.mobileEntities.clear();
    this.gravityForces.clear();
    this.layerEntities.clear();
    this.entitiesByTag.clear();
    this.allEntities.clear();

    for (RenderType renderType : RenderType.values()) {
      this.miscEntities.get(renderType).clear();
      this.renderListeners.get(renderType).clear();
      this.renderables.get(renderType).clear();
    }

    dispose(this.allEntities.values());
    dispose(this.triggers);
    this.emitters.clear();
    this.colliders.clear();
    this.props.clear();
    this.creatures.clear();
    this.staticShadows.clear();
    this.combatEntities.clear();
    this.mobileEntities.clear();
    this.lightSources.clear();
    this.spawnPoints.clear();
    this.soundSources.clear();
    this.mapAreas.clear();
    this.triggers.clear();

    this.ambientLight = null;
    this.staticShadowLayer = null;

    for (Map<Integer, IEntity> type : this.miscEntities.values()) {
      type.clear();
    }

    this.initialized = false;

    this.fireEvent(l -> l.cleared(this));
}private void load(final IEntity entity) {
    // an entity can only exist on one environment at a time, so remove it from the current one
    if (entity.getEnvironment() != null) {
      entity.getEnvironment().remove(entity);
    }

    // 1. add to physics engine
    loadPhysicsEntity(entity);

    // 2. register for update or activate
    loadUpdatableOrEmitterEntity(entity);

    // 3. if a gravity is defined, add a gravity force to the entity
    if (entity instanceof IMobileEntity && this.getGravity() != 0) {
      this.addGravityForce((IMobileEntity) entity);
    }

    // 4. attach all controllers
    entity.attachControllers();

    if (this.loaded && (entity instanceof LightSource || entity instanceof StaticShadow)) {
      this.updateLighting(entity);
    }

    entity.loaded(this);
}private void unload(final IEntity entity) {
    // 1. remove from physics engine
    if (entity instanceof ICollisionEntity) {
      Game.physics().remove((ICollisionEntity) entity);
    }

    // 2. unregister from update
    if (entity instanceof IUpdateable) {
      Game.loop().detach((IUpdateable) entity);
    }

    if (entity instanceof IMobileEntity) {
      this.removeGravity((IMobileEntity) entity);
    }

    // 3. detach all controllers
    entity.detachControllers();

    if (entity instanceof Emitter) {
      Emitter em = (Emitter) entity;
      em.deactivate();
    }

    if (this.loaded && (entity instanceof LightSource || entity instanceof StaticShadow)) {
      this.updateLighting(entity);
    }

    entity.removed(this);
}public void remove(final IEntity entity) {
    if (entity == null) {
      return;
    }

    this.allEntities.remove(entity.getMapId());
    Iterator<List<IEntity>> iter = this.layerEntities.values().iterator();
    while (iter.hasNext()) {
      List<IEntity> layer = iter.next();
      if (layer.remove(entity) && layer.isEmpty()) {
        iter.remove();
      }
    }
    if (this.miscEntities.get(entity.getRenderType()) != null) {
      this.miscEntities.get(entity.getRenderType()).values().remove(entity);
    }

    for (String tag : entity.getTags()) {
      if (this.getEntitiesByTag().containsKey(tag)) {
        this.getEntitiesByTag().get(tag).remove(entity);

        if (this.getEntitiesByTag().get(tag).isEmpty()) {
          this.getEntitiesByTag().remove(tag);
        }
      }
    }

    if (entity instanceof Emitter) {
      Emitter emitter = (Emitter) entity;
      this.removeEmitter(emitter);
    }

    if (entity instanceof MapArea) {
      this.mapAreas.remove(entity);
    }

    if (entity instanceof Prop) {
      this.props.remove(entity);
    }

    if (entity instanceof Creature) {
      this.creatures.remove(entity);
    }

    if (entity instanceof CollisionBox) {
      this.colliders.remove(entity);
      this.staticShadows.removeIf(x -> x.getOrigin() != null && x.getOrigin().equals(entity));
    }

    if (entity instanceof LightSource) {
      this.lightSources.remove(entity);
      this.updateLighting(entity);
    }

    if (entity instanceof Trigger) {
      this.triggers.remove(entity);
    }

    if (entity instanceof Spawnpoint) {
      this.spawnPoints.remove(entity);
    }
    if (entity instanceof SoundSource) {
      this.soundSources.remove(entity);
    }

    if (entity instanceof StaticShadow) {
      this.staticShadows.remove(entity);
      this.updateLighting(entity);
    }

    if (entity instanceof IMobileEntity) {
      this.mobileEntities.values().remove(entity);
    }

    if (entity instanceof ICombatEntity) {
      this.combatEntities.values().remove(entity);
    }

    this.unload(entity);

    this.fireEntityEvent(l -> l.entityRemoved(entity));
}
}
```
```java
class de.gurkenlabs.litiengine.physics.MovementController {
@Override
  public void update() {
    this.handleForces();
    this.handleMovement();
}
}
```
```java
class de.gurkenlabs.litiengine.Game {
static synchronized void terminate() {
        if (!initialized || gameLoop == null) {
          return;
        }
    
        hasStarted = false;
        initialized = false;
    
        config().save();
        gameLoop.terminate();
        tweenEngine.terminate();
        soundEngine.terminate();
    
        world().clear();
    
        for (final GameListener listener : gameListeners) {
          try {
            listener.terminated();
          } catch (Exception e) {
            log().log(Level.WARNING, "game listener threw an exception during shutdown", e);
          }
        }
    
        gameLoop = null;
        screenManager = null;
        gameWindow = null;
}public static synchronized void start() {
          if (!initialized) {
              throw new IllegalStateException(
                  "The game cannot be started without being first initialized. Call Game.init(...) before Game.start().");
          }
    
          if (gameLoop == null) {
              throw new IllegalStateException(
                  "Game loop is not initialized. Ensure Game.init(...) has been called successfully.");
          }
          
          Nullability.castToNonnull(gameLoop, "gameLoop cannot be null").start();
          tweenEngine.start();
          soundEngine.start();
    
          for (final GameListener listener : gameListeners) {
              listener.started();
          }
    
          hasStarted = true;
}public static synchronized void init(String... args) {
    if (initialized) {
      log().log(Level.INFO, "The game has already been initialized.");
      return;
    }

    log.init();
    handleCommandLineArguments(args);

    config().load();
    Locale.setDefault(new Locale(config().client().getCountry(), config().client().getLanguage()));

    gameLoop = new GameLoop("Main Update Loop", config().client().getMaxFps());
    loop().attach(physics());
    loop().attach(world());

    // setup default exception handling for render and update loop
    setUncaughtExceptionHandler(
        new DefaultUncaughtExceptionHandler(config().client().exitOnError()));

    screenManager = new ScreenManager();
    gameWindow = new GameWindow();

    // initialize  the game window
    window().init();
    world.setCamera(new Camera());

    for (GameListener listener : gameListeners) {
      listener.initialized(args);
    }

    if (!isInNoGUIMode()) {
      window().getRenderComponent().onRendered(g -> metrics().render(g));

      graphics()
          .addEntityRenderedListener(
              e -> DebugRenderer.renderEntityDebugInfo(e.getGraphics(), e.getEntity()));

      window().getRenderComponent().onFpsChanged(fps -> metrics().setFramesPerSecond(fps));
      window()
          .setIcons(
              Arrays.asList(
                  Resources.images().get("liti-logo-x16.png"),
                  Resources.images().get("liti-logo-x20.png"),
                  Resources.images().get("liti-logo-x32.png"),
                  Resources.images().get("liti-logo-x48.png")));

      Input.keyboard()
          .onKeyTyped(
              KeyEvent.VK_PRINTSCREEN,
              key -> {
                // don't take a screenshot if a modifier is active
                if (key.getModifiers() != 0) {
                  return;
                }

                window().getRenderComponent().takeScreenshot();
              });
    }

    Runtime.getRuntime().addShutdownHook(new Thread(Game::terminate, "Shutdown"));

    initialized = true;
}
}
```


Response Format:
Provide the answer in **XML format** as follows:

#### If the method **cannot** return `null` at the specific call site:
```xml
<response>
  <reason><![CDATA[EXPLAIN WHY THE INVOCATION Game.loop() RESULT CANNOT BE NULL.]]></reason>
  <value>NO</value>
</response>

#### If the method can return null at the specific call site:
<response>
  <reason><![CDATA[EXPLAIN WHY THE INVOCATION Game.loop() RESULT CAN BE NULL.]]></reason>
  <value>YES</value>
</response>

#### If you are unsure or If there are any methods that directly or indirectly affect the return value and are not fully disclosed, request their declarations first, in the following format:
<response>
  <reason><![CDATA[EXPLAIN WHY THIS METHOD DECLARATION IS NECESSARY AND WHY YOU CANNOT MAKE A CONFIDENT DECISION WITHOUT IT]]></reason>
  <success>false</success>
  <methods>
    <method>methodName</method>
  </methods>
</response>

Additional Notes:
Be precise in your reasoning.
If a methods return value depends on another method not provided, request its declaration before making a conclusion.
If the method can return null in this case but not in others, explain why it happens specifically for this call.

11:53:27.289 TRACE edu.ucr.cs.riple.core.checkers.nullaway.codefix.ChatGPT.ask
Retrieving response from cache
11:53:27.289 TRACE edu.ucr.cs.riple.core.checkers.nullaway.codefix.Response.tryCreate
Trying to create Response:
```xml
<response>
  <reason><![CDATA[The `Game.loop()` method returns a static field `gameLoop` from the `de.gurkenlabs.litiengine.Game` class. The initialization of this field occurs in the `Game.init(String... args)` method, where `gameLoop` is assigned a new `GameLoop` object. This method is called before `Game.start()`, and it is verified that `Game.init(...)` has been called successfully in `Game.start()`, ensuring `gameLoop` is not null when `Game.hasStarted()` is true. Therefore, as long as the game has been properly initialized and started using `Game.init(...)` and `Game.start()`, the method `Game.loop()` cannot return null at the specific call site `Game.loop()`.]]></reason>
  <value>NO</value>
</response>
```
11:53:27.289 TRACE edu.ucr.cs.riple.core.checkers.nullaway.codefix.Response.<init>
Creating Response:
```xml
<response>
  <reason><![CDATA[The `Game.loop()` method returns a static field `gameLoop` from the `de.gurkenlabs.litiengine.Game` class. The initialization of this field occurs in the `Game.init(String... args)` method, where `gameLoop` is assigned a new `GameLoop` object. This method is called before `Game.start()`, and it is verified that `Game.init(...)` has been called successfully in `Game.start()`, ensuring `gameLoop` is not null when `Game.hasStarted()` is true. Therefore, as long as the game has been properly initialized and started using `Game.init(...)` and `Game.start()`, the method `Game.loop()` cannot return null at the specific call site `Game.loop()`.]]></reason>
  <value>NO</value>
</response>
```
11:53:27.289 TRACE edu.ucr.cs.riple.core.checkers.nullaway.codefix.Response.<init>
Response created:
Disagreement: The `Game.loop()` method returns a static field `gameLoop` from the `de.gurkenlabs.litiengine.Game` class. The initialization of this field occurs in the `Game.init(String... args)` method, where `gameLoop` is assigned a new `GameLoop` object. This method is called before `Game.start()`, and it is verified that `Game.init(...)` has been called successfully in `Game.start()`, ensuring `gameLoop` is not null when `Game.hasStarted()` is true. Therefore, as long as the game has been properly initialized and started using `Game.init(...)` and `Game.start()`, the method `Game.loop()` cannot return null at the specific call site `Game.loop()`.
11:53:27.290 TRACE edu.ucr.cs.riple.core.checkers.nullaway.codefix.AdvancedNullAwayCodeFix.resolveMethodDereferenceError
Method is not returning nullable on call site. Injecting suppression annotation.
11:53:27.290 TRACE edu.ucr.cs.riple.core.checkers.nullaway.codefix.AdvancedNullAwayCodeFix.constructCastToNonnullChange
Constructing cast to nonnull change for reason: The `Game.loop()` method returns a static field `gameLoop` from the `de.gurkenlabs.litiengine.Game` class. The initialization of this field occurs in the `Game.init(String... args)` method, where `gameLoop` is assigned a new `GameLoop` object. This method is called before `Game.start()`, and it is verified that `Game.init(...)` has been called successfully in `Game.start()`, ensuring `gameLoop` is not null when `Game.hasStarted()` is true. Therefore, as long as the game has been properly initialized and started using `Game.init(...)` and `Game.start()`, the method `Game.loop()` cannot return null at the specific call site `Game.loop()`.
11:53:27.290 TRACE edu.ucr.cs.riple.core.checkers.nullaway.codefix.ChatGPT.ask
Asking ChatGPT:
For the reason you mentioned earlier:

"The `Game.loop()` method returns a static field `gameLoop` from the `de.gurkenlabs.litiengine.Game` class. The initialization of this field occurs in the `Game.init(String... args)` method, where `gameLoop` is assigned a new `GameLoop` object. This method is called before `Game.start()`, and it is verified that `Game.init(...)` has been called successfully in `Game.start()`, ensuring `gameLoop` is not null when `Game.hasStarted()` is true. Therefore, as long as the game has been properly initialized and started using `Game.init(...)` and `Game.start()`, the method `Game.loop()` cannot return null at the specific call site `Game.loop()`."

in the method below, the expression Game.loop() is not nullable at the point it is used.

```java
@Override
  public void loaded(Environment environment) {
    environmentLoaded = Game.loop().getTicks();
}
```
Please Summarize the reason in max 5 words and rewrite the method so that at the line "    environmentLoaded = Game.loop().getTicks();", at the occurrence of: "Game.loop()" is replaced with `Nullability.castToNonnull(Game.loop(), summary of reason)`
Replace "REASON" with the exact reason summary I provide to you (maximum 5 words), not with a generic explanation like "checked to be nonnull".
see the example below, for expression `foo.getBar()`, to wrap it with `Nullability.castToNonnull(foo.getBar(), "reason")`.

```java
public t(){
    String l = foo.getBar();
}
```

will be:
```java
public t(){
    String l = Nullability.castToNonnull(foo.getBar(), "checked to be nonnull");
}
```

### Instructions:

Do not import any additional classes.

Do not add Java comments.

Only modify relevant lines as required.

Return only the modified method wrapped in the XML format shown below.

Place the Java code inside the <code> tag using a CDATA block with ```java formatting.

Just give me the fixed code snippet in XML format in <response> tag like the example below. I will apply the fix to my codebase. Do not import any additional libraries or classes or add java comments. If you can provide the fixed code snippet, please provide it in the following format and place the code snippet in the <code> tag within ```java block.
<response>
  <success>true</success>
  <code><![CDATA[
  ```java
  Your fixed code snippet here
  ```
    ]]>
  </code>
</response>

11:53:27.290 TRACE edu.ucr.cs.riple.core.checkers.nullaway.codefix.ChatGPT.ask
Retrieving response from cache
11:53:27.290 TRACE edu.ucr.cs.riple.core.checkers.nullaway.codefix.Response.tryCreate
Trying to create Response:
<response>
  <success>true</success>
  <code><![CDATA[
  ```java
@Override
  public void loaded(Environment environment) {
    environmentLoaded = Nullability.castToNonnull(Game.loop(), "properly initialized and started").getTicks();
}
  ```
    ]]>
  </code>
</response>
11:53:27.290 TRACE edu.ucr.cs.riple.core.checkers.nullaway.codefix.Response.<init>
Creating Response:
<response>
  <success>true</success>
  <code><![CDATA[
  ```java
@Override
  public void loaded(Environment environment) {
    environmentLoaded = Nullability.castToNonnull(Game.loop(), "properly initialized and started").getTicks();
}
  ```
    ]]>
  </code>
</response>
11:53:27.291 TRACE edu.ucr.cs.riple.core.checkers.nullaway.codefix.Response.<init>
Response created:
@Override
  public void loaded(Environment environment) {
    environmentLoaded = Nullability.castToNonnull(Game.loop(), "properly initialized and started").getTicks();
}
11:53:27.291 TRACE edu.ucr.cs.riple.core.checkers.nullaway.codefix.ChatGPT.fixDereferenceByAddingCastToNonnull
Fixing the error by adding castToNonnull
11:53:27.292 TRACE edu.ucr.cs.riple.core.checkers.nullaway.codefix.AdvancedNullAwayCodeFix.fixTriggeredErrorsForLocation
Resolving unresolvable error for triggered error: Type='DEREFERENCE_NULLABLE', message='dereferenced expression Game.loop() is @Nullable'
/home/nima/Developer/nullness-benchmarks/litiengine/src/de/gurkenlabs/litiengine/GameWindow.java:379
            Game.loop().setTickRate(ICONIFIED_MAX_FPS);
11:53:27.292 TRACE edu.ucr.cs.riple.core.checkers.nullaway.codefix.AdvancedNullAwayCodeFix.fix
Fixing error: Type='DEREFERENCE_NULLABLE', message='dereferenced expression Game.loop() is @Nullable'
/home/nima/Developer/nullness-benchmarks/litiengine/src/de/gurkenlabs/litiengine/GameWindow.java:379
            Game.loop().setTickRate(ICONIFIED_MAX_FPS);
11:53:27.292 TRACE edu.ucr.cs.riple.core.checkers.nullaway.codefix.AdvancedNullAwayCodeFix.resolveDereferenceError
Resolving dereference error: Type='DEREFERENCE_NULLABLE', message='dereferenced expression Game.loop() is @Nullable'
/home/nima/Developer/nullness-benchmarks/litiengine/src/de/gurkenlabs/litiengine/GameWindow.java:379
            Game.loop().setTickRate(ICONIFIED_MAX_FPS);
11:53:27.292 TRACE edu.ucr.cs.riple.core.checkers.nullaway.codefix.AdvancedNullAwayCodeFix.resolveDereferenceError
Checking nullability possibility at error point
11:53:27.293 TRACE edu.ucr.cs.riple.core.checkers.nullaway.codefix.ChatGPT.checkNullabilityPossibilityAtErrorPoint
Asking if the expression can be null at error point point
11:53:27.293 TRACE edu.ucr.cs.riple.core.checkers.nullaway.codefix.ChatGPT.ask
Asking ChatGPT:
In the method below, is there a possibility that the expression "Game.loop()" at line "Game.loop().setTickRate(ICONIFIED_MAX_FPS);" is null?
private static void initializeWindowEventListeners(Window window) {

    window.addWindowStateListener(
        e -> {
          if (e.getNewState() == Frame.ICONIFIED) {
            Game.loop().setTickRate(ICONIFIED_MAX_FPS);
          } else {
            Game.loop().setTickRate(Game.config().client().getMaxFps());
          }
        });

    window.addWindowFocusListener(
        new WindowFocusListener() {
          @Override
          public void windowLostFocus(WindowEvent e) {
            if (Game.config().graphics().reduceFramesWhenNotFocused()) {
              Game.loop().setTickRate(NONE_FOCUS_MAX_FPS);
            }
          }

          @Override
          public void windowGainedFocus(WindowEvent e) {
            Game.loop().setTickRate(Game.config().client().getMaxFps());
          }
        });

    window.addWindowListener(
        new WindowAdapter() {
          @Override
          public void windowClosing(final WindowEvent event) {
            Game.exit();
          }
        });
}
Give a single-word answer in XML format. If it is possible for the expression to be null, respond with:
```xml
<response>
    <reason><![CDATA[YOUR REASON]]></reason>
    <value>YES</value>
</response>
```
If it is not possible for the expression to be null, respond with:
```xml
<response>
    <reason><![CDATA[YOUR REASON]]></reason>
    <value>NO</value>
</response>
```
If you are unsure or need more information, respond with where you can ask for more details or what specific information you need.

If additional information is required, list each request inside a `<request>` tag. If no additional information is needed, omit the `<requests>` section.

Respond with:
```xml
<response>
    <reason><![CDATA[YOUR REASON]]></reason>
    <value>UNKNOWN</value>
    <!-- Include <requests> only if additional information is needed -->
    <requests>
        <request><![CDATA[YOUR REQUEST 1]]></request>
        <request><![CDATA[YOUR REQUEST 2]]></request>
    </requests>
</response>
```
11:53:27.294 TRACE edu.ucr.cs.riple.core.checkers.nullaway.codefix.ChatGPT.ask
Retrieving response from cache
11:53:27.294 TRACE edu.ucr.cs.riple.core.checkers.nullaway.codefix.Response.tryCreate
Trying to create Response:
```xml
<response>
    <reason><![CDATA[The possibility of Game.loop() being null depends on the implementation of the Game class and how the loop() method is defined. Without information on the initialization and behavior of Game.loop(), it's unclear whether a null value might be returned.]]></reason>
    <value>UNKNOWN</value>
    <requests>
        <request><![CDATA[Provide the implementation of the Game class, especially the loop() method.]]></request>
        <request><![CDATA[Explain the initialization sequence and lifecycle management for the Game.loop() method.]]></request>
    </requests>
</response>
```
11:53:27.294 TRACE edu.ucr.cs.riple.core.checkers.nullaway.codefix.Response.<init>
Creating Response:
```xml
<response>
    <reason><![CDATA[The possibility of Game.loop() being null depends on the implementation of the Game class and how the loop() method is defined. Without information on the initialization and behavior of Game.loop(), it's unclear whether a null value might be returned.]]></reason>
    <value>UNKNOWN</value>
    <requests>
        <request><![CDATA[Provide the implementation of the Game class, especially the loop() method.]]></request>
        <request><![CDATA[Explain the initialization sequence and lifecycle management for the Game.loop() method.]]></request>
    </requests>
</response>
```
11:53:27.294 TRACE edu.ucr.cs.riple.core.checkers.nullaway.codefix.Response.<init>
Response created:
Unknown: The possibility of Game.loop() being null depends on the implementation of the Game class and how the loop() method is defined. Without information on the initialization and behavior of Game.loop(), it's unclear whether a null value might be returned.
11:53:27.296 TRACE edu.ucr.cs.riple.core.checkers.nullaway.codefix.AdvancedNullAwayCodeFix.resolveMethodDereferenceError
Resolving method dereference error.
11:53:27.296 TRACE edu.ucr.cs.riple.core.checkers.nullaway.codefix.AdvancedNullAwayCodeFix.resolveMethodDereferenceError
Method is in annotated package. Checking if the method is returning nullable.
11:53:27.296 TRACE edu.ucr.cs.riple.core.checkers.nullaway.codefix.AdvancedNullAwayCodeFix.investigateMethodReturnNullability
Checking if the method is returning nullable.
11:53:27.298 TRACE edu.ucr.cs.riple.core.checkers.nullaway.codefix.ChatGPT.checkIfMethodIsReturningNullable
Asking if the method is returning nullable: loop()
11:53:27.300 TRACE edu.ucr.cs.riple.core.checkers.nullaway.codefix.ChatGPT.ask
Asking ChatGPT:
In the method below, is there a possibility that the method returns null based only on its body? Consider the following points:

- The method may have multiple return paths; consider all return statements.
- If the method calls another method, do not assume its return value unless its full declaration is provided. Request its declaration if needed.
- The method may throw an exception instead of returning null. An exception path should not be considered a null return.
- Ensure you request the declarations of any methods whose return values directly or indirectly impact this methods return value before making a conclusion.
- Carefully analyze all conditions and prior operations that may guarantee a non-null return value.

@Nullable public static IGameLoop loop() {
    return gameLoop;
}

Here are the method definitions in addition to the method inquired:

Depth: 0
```java
class de.gurkenlabs.litiengine.Game {
@Nullable public static IGameLoop loop() {
    return gameLoop;
}
}
```


Response Format:
Provide the answer in **XML format** as follows:

#### If the method **cannot** return `null`:
```xml
<response>
  <reason><![CDATA[EXPLAIN WHY THE METHOD CANNOT RETURN NULL]]></reason>
  <value>NO</value>
</response>
```

#### If the method can return null:
```xml
<response>
  <reason><![CDATA[EXPLAIN WHY THE METHOD CAN RETURN NULL]]></reason>
  <value>YES</value>
</response>
```

#### If you are unsure or need more information, respond with where you can ask for more details or what specific information you need.

#### If you are unsure or If there are any methods that directly or indirectly affect the return value and are not fully disclosed, request their declarations first, in the following format:
<response>
  <reason><![CDATA[YOUR REASON]]></reason>
  <value>UNKNOWN</value>
  <methods>
    <method>methodName</method>
  </methods>
</response>

If additional information is required other than method declaration, list each request inside a `<request>` tag. If no additional information is needed, omit the `<requests>` section.

Respond with:
```xml
<response>
    <reason><![CDATA[YOUR REASON]]></reason>
    <value>UNKNOWN</value>
    <!-- Include <requests> only if additional information is needed -->
    <requests>
        <request><![CDATA[YOUR REQUEST 1]]></request>
        <request><![CDATA[YOUR REQUEST 2]]></request>
    </requests>
</response>
```

Additional Notes:
Be precise in your reasoning.
If a methods return value depends on another method not provided, request its declaration before making a conclusion.
If the method can return null in some cases but not others, explain under what conditions it can happen.

11:53:27.300 TRACE edu.ucr.cs.riple.core.checkers.nullaway.codefix.ChatGPT.ask
Retrieving response from cache
11:53:27.300 TRACE edu.ucr.cs.riple.core.checkers.nullaway.codefix.Response.tryCreate
Trying to create Response:
```xml
<response>
  <reason><![CDATA[The method `loop` returns the variable `gameLoop`. Without the initialization or assignment details of `gameLoop`, it's unclear whether it can be null. The possibility of `gameLoop` being uninitialized or set to null elsewhere in the program means `loop` could potentially return null. Further information on `gameLoop` is required.]]></reason>
  <value>UNKNOWN</value>
  <requests>
    <request><![CDATA[Please provide the declaration and initialization of the variable `gameLoop` in the class `de.gurkenlabs.litiengine.Game`.]]></request>
  </requests>
</response>
```
11:53:27.300 TRACE edu.ucr.cs.riple.core.checkers.nullaway.codefix.Response.<init>
Creating Response:
```xml
<response>
  <reason><![CDATA[The method `loop` returns the variable `gameLoop`. Without the initialization or assignment details of `gameLoop`, it's unclear whether it can be null. The possibility of `gameLoop` being uninitialized or set to null elsewhere in the program means `loop` could potentially return null. Further information on `gameLoop` is required.]]></reason>
  <value>UNKNOWN</value>
  <requests>
    <request><![CDATA[Please provide the declaration and initialization of the variable `gameLoop` in the class `de.gurkenlabs.litiengine.Game`.]]></request>
  </requests>
</response>
```
11:53:27.300 TRACE edu.ucr.cs.riple.core.checkers.nullaway.codefix.Response.<init>
Response created:
Unknown: The method `loop` returns the variable `gameLoop`. Without the initialization or assignment details of `gameLoop`, it's unclear whether it can be null. The possibility of `gameLoop` being uninitialized or set to null elsewhere in the program means `loop` could potentially return null. Further information on `gameLoop` is required.
11:53:27.300 TRACE edu.ucr.cs.riple.core.checkers.nullaway.codefix.AdvancedNullAwayCodeFix.investigateMethodReturnNullability
Could not determine the nullability and model did not ask for any method.
11:53:27.301 TRACE edu.ucr.cs.riple.core.checkers.nullaway.codefix.ChatGPT.checkIfMethodIsReturningNullableOnCallSite
Asking if the method is returning nullable on the call site: Game.loop()
11:53:27.538 TRACE edu.ucr.cs.riple.core.checkers.nullaway.codefix.ChatGPT.ask
Asking ChatGPT:
In the method below, is there a possibility that the method returns null at the given call site?

```java
@Nullable public static IGameLoop loop() {
    return gameLoop;
}
```

## Guidelines:
- The method may have multiple return paths; consider all return statements.
- If the method calls another method, do not assume its return value unless its full declaration is provided. Request its declaration if needed.
- The method may throw an exception instead of returning null. An exception path should not be considered a null return.
- Ensure you request the declarations of any methods whose return values directly or indirectly impact this methods return value before making a conclusion.
- If the method returns a value that is determined by a parameter, evaluate based on the actual argument at the given call site.
- Analyze based only on the specific invocation provided. Do not generalize to all possible inputs.- If the return value is guaranteed to be non-null at the call site, the answer should be a definitive NO.
- Do not generalize based on all possible inputsyour answer must be based only on the given invocation.
- Focus only on the given call site, not all possible invocations.

### call site:
Game.loop()

Here are the method definitions and the call chain for this method, showing the sequence of calls from the method to its callers at each depth level:

Depth: 0
```java
class de.gurkenlabs.litiengine.Game {
@Nullable public static IGameLoop loop() {
    return gameLoop;
}
}
```
Depth: 1
```java
class de.gurkenlabs.litiengine.environment.GameWorld {
public void loadEnvironment(@Nullable final Environment env) {
    Lock lock = Game.loop().getLock();
    lock.lock();
    try {
      unloadEnvironment();
      this.environment = env;
      if (env != null) {
        this.addEnvironment(env);

        if (env.getGravity() == 0 && this.gravity() != 0) {
          env.setGravity(this.gravity());
        }

        env.load();
        for (final EnvironmentLoadedListener listener : this.loadedListeners) {
          listener.loaded(env);
        }

        // call map specific listeners
        String mapName = getMapName(env);
        if (mapName != null && this.environmentLoadedListeners.containsKey(mapName)) {

          // for the default camera we center the camera on the environment
          if (this.camera().getClass().equals(Camera.class)) {
            camera().setFocus(env.getCenter());
          }

          for (EnvironmentLoadedListener listener : this.environmentLoadedListeners.get(mapName)) {
            listener.loaded(env);
          }
        }
      }
    } finally {
      lock.unlock();
    }
}public void setCamera(@Nullable final ICamera cam) {
    if (this.camera() != null) {
      Game.loop().detach(camera);
    }

    camera = cam;

    if (cam != null && !Game.isInNoGUIMode()) {
      Game.loop().attach(cam);
      cam.updateFocus();
    }
}
}
```
```java
class de.gurkenlabs.litiengine.entities.behavior.EntityNavigator {
public EntityNavigator(final IMobileEntity entity, final PathFinder pathFinder) {
    this.cancelNavigationConditions = new CopyOnWriteArrayList<>();
    this.listeners = new CopyOnWriteArrayList<>();
    this.entity = entity;
    this.pathFinder = pathFinder;
    this.setAcceptableError(DEFAULT_ACCEPTABLE_ERROR);
    Game.loop().attach(this);
}
}
```
```java
class de.gurkenlabs.litiengine.GameWindow {
private static void initializeWindowEventListeners(Window window) {

    window.addWindowStateListener(
        e -> {
          if (e.getNewState() == Frame.ICONIFIED) {
            Game.loop().setTickRate(ICONIFIED_MAX_FPS);
          } else {
            Game.loop().setTickRate(Game.config().client().getMaxFps());
          }
        });

    window.addWindowFocusListener(
        new WindowFocusListener() {
          @Override
          public void windowLostFocus(WindowEvent e) {
            if (Game.config().graphics().reduceFramesWhenNotFocused()) {
              Game.loop().setTickRate(NONE_FOCUS_MAX_FPS);
            }
          }

          @Override
          public void windowGainedFocus(WindowEvent e) {
            Game.loop().setTickRate(Game.config().client().getMaxFps());
          }
        });

    window.addWindowListener(
        new WindowAdapter() {
          @Override
          public void windowClosing(final WindowEvent event) {
            Game.exit();
          }
        });
}
}
```
```java
class de.gurkenlabs.litiengine.gui.screens.ScreenManager {
public void display(@Nullable final Screen screen) {
      if (Game.hasStarted() && Game.time().since(this.lastScreenChange) < this.getChangeCooldown()) {
        log.log(
            Level.INFO,
            "Skipping displaying of screen {0} because screen changing is currently on cooldown.",
            screen != null ? screen.getName() : "");
        return;
      }
  
      final Screen previous = this.current();
      if (previous != null) {
        previous.suspend();
      }
  
      if (screen != null && !this.screens.contains(screen)) {
        this.screens.add(screen);
      }
  
      this.currentScreen = screen;
      if (!Game.isInNoGUIMode() && this.current() != null) {
        this.current().prepare();
      }
  
      this.lastScreenChange = Nullability.castToNonnull(Game.loop(), "initialized before usage").getTicks();
  
      final ScreenChangedEvent event = new ScreenChangedEvent(this.current(), previous);
      for (final ScreenChangedListener listener : this.screenChangedListeners) {
        listener.changed(event);
      }
}
}
```
```java
class de.gurkenlabs.litiengine.abilities.effects.Effect {
@Override
  public void update() {

    for (final Iterator<EffectApplication> iterator = this.getActiveAppliances().iterator();
        iterator.hasNext(); ) {
      final EffectApplication appliance = iterator.next();
      // if the effect duration is reached
      if (this.hasEnded(appliance)) {

        iterator.remove();
        this.cease(appliance);
      }
    }

    // 4. unregister if all appliances are finished
    if (this.getActiveAppliances().isEmpty()) {
      Game.loop().detach(this);
    }
}public void apply(final Shape impactArea) {
    final List<ICombatEntity> affected = this.lookForAffectedEntities(impactArea);
    for (final ICombatEntity affectedEntity : affected) {
      this.apply(affectedEntity);
    }

    this.appliances.add(new EffectApplication(affected, impactArea));

    // if it is the first appliance -> register for update
    if (this.appliances.size() == 1) {
      Game.loop().attach(this);
    }
}
}
```
```java
class de.gurkenlabs.litiengine.GameTime {
public long toTicks(final int milliseconds) {
    return this.toTicks(milliseconds, Game.loop().getTickRate());
}public long since(final long tick) {
    return toMilliseconds(Game.loop().getTicks() - tick);
}public long now() {
    return Game.loop().getTicks();
}public long sinceGameStart() {
    return this.toMilliseconds(Game.loop().getTicks());
}@Override
    public void loaded(Environment environment) {
      environmentLoaded = Nullability.castToNonnull(Game.loop(), "properly initialized and started").getTicks();
}public long toMilliseconds(final long ticks) {
    return this.toMilliseconds(ticks, Game.loop().getTickRate());
}
}
```
```java
class de.gurkenlabs.litiengine.GameMetrics {
@Override
    public void render(final Graphics2D g) {
      this.updateMetrics();
  
      if (!Game.config().client().showGameMetrics()) {
        return;
      }
  
      this.currentOffsetY = 0;
  
      g.setColor(this.renderColor);
  
      // render client metrics
      this.drawTitle(g, "[client]");
      this.drawMetric(g, "fps       : " + this.getFramesPerSecond());
      this.drawMetric(g, "max fps   : " + this.maxFramesPerSecond);
  
      // Use Nullability.castToNonnull to prevent NullAway warning
      this.drawMetric(g, "updatables: " + Nullability.castToNonnull(Game.loop(), "gameLoop always initialized").getUpdatableCount());
  
      // render jvm metrics if debug is enabled
      if (Game.config().debug().isDebugEnabled()) {
        this.drawTitle(g, "[jvm]");
        this.drawMetric(g, "java      : " + this.javaVersion);
        this.drawMetric(g, "memory    : " + String.format("%-5.5s", this.usedMemory) + " MB");
        this.drawMetric(g, "threads   : " + Thread.activeCount());
      }
  
      // render rendering metrics
      if (!this.renderMetrics.isEmpty()) {
        this.drawTitle(g, "[update]");
  
        for (RenderMetrics metric : this.renderMetrics) {
          this.drawMetric(g, metric.toString());
        }
  
        this.renderMetrics.clear();
      }
}
}
```
```java
class de.gurkenlabs.litiengine.graphics.emitters.Emitter {
public void deactivate() {
    if (!this.activated) {
      return;
    }

    this.activated = false;
    this.getParticles().clear();
    this.aliveTime = 0;
    this.activationTick = 0;
    this.lastSpawn = 0;
    Game.loop().detach(this);
}public void activate() {
    if (this.activated) {
      return;
    }

    this.activated = true;
    this.activationTick = Game.time().now();
    Game.loop().attach(this);
}@Override
  public void update() {
    if (this.isPaused()) {
      return;
    }

    // clear particles if the effect time to life is reached
    if (this.isFinished()) {
      for (EmitterFinishedListener listener : this.finishedListeners) {
        listener.finished(this);
      }

      this.delete();
      return;
    }

    final float updateRatio = (float) this.data().getUpdateRate() / Game.loop().getTickRate();
    for (final Particle p : this.getParticles().stream().collect(Collectors.toList())) {
      if (this.particleCanBeRemoved(p)) {
        // remove dead particles
        this.particles.remove(p);
        continue;
      }

      p.update(this.getOrigin(), updateRatio);
    }

    this.aliveTime = Game.time().since(this.activationTick);
    if ((this.data().getSpawnRate() == 0
        || Game.time().since(this.lastSpawn) >= this.data().getSpawnRate())) {
      this.lastSpawn = Game.time().now();
      this.spawnParticle();
    }
}
}
```
```java
class de.gurkenlabs.litiengine.entities.behavior.IBehaviorController {
public default void attach() {
    Game.loop().attach(this);
}public default void detach() {
    Game.loop().detach(this);
}
}
```
```java
class de.gurkenlabs.litiengine.abilities.AbilityExecution {
AbilityExecution(final Ability ability) {
        this.appliedEffects = new CopyOnWriteArrayList<>();
        this.ability = ability;
        this.executionTicks = Game.time().now();
        this.impactArea = ability.calculateImpactArea();
        this.castLocation = ability.getExecutor().getCenter();
        Nullability.castToNonnull(Game.loop(), "proper initialization done").attach(this);
}@Override
  public void update() {
    // if there a no effects to apply -> unregister this instance and we're done
    if (this.getAbility().getEffects().isEmpty()
        || this.getAbility().getEffects().size() == this.getAppliedEffects().size()) {
      Game.loop().detach(this);
      return;
    }

    // handle all effects from the ability that were not applied yet
    for (final Effect effect : this.getAbility().getEffects()) {
      // if the ability was not executed yet or the delay of the effect is not
      // yet reached
      if (this.getAppliedEffects().contains(effect)
          || Game.time().since(this.getExecutionTicks()) < effect.getDelay()) {
        continue;
      }

      effect.apply(this.getExecutionImpactArea());
      this.getAppliedEffects().add(effect);
    }
}
}
```
```java
class de.gurkenlabs.litiengine.GameWindow$3 {
@Override
          public void windowGainedFocus(WindowEvent e) {
            Game.loop().setTickRate(Game.config().client().getMaxFps());
}@Override
          public void windowLostFocus(WindowEvent e) {
            if (Game.config().graphics().reduceFramesWhenNotFocused()) {
              Game.loop().setTickRate(NONE_FOCUS_MAX_FPS);
            }
}
}
```
```java
class de.gurkenlabs.litiengine.environment.EntitySpawner {
protected void spawnNewEntities() {
    if (this.getSpawnMode() != SpawnMode.CUSTOMSPAWNPOINTS && this.getSpawnPoints().isEmpty()) {
      return;
    }

    switch (this.getSpawnMode()) {
      case ALLSPAWNPOINTS:
        for (int i = 0; i < this.getSpawnPoints().size(); i++) {
          final int index = i;
          Game.loop()
              .perform(
                  this.getSpawnDelay() + this.getSpawnDelay() * i,
                  () -> this.spawn(this.getSpawnPoints().get(index), this.getSpawnAmount()));
        }
        break;
      case ONERANDOMSPAWNPOINT:
        this.spawn(Game.random().choose(this.getSpawnPoints()), this.getSpawnAmount());
        break;
      case RANDOMSPAWNPOINTS:
        for (int i = 0; i < this.getSpawnAmount(); i++) {
          Game.loop()
              .perform(
                  this.getSpawnDelay() + this.getSpawnDelay() * i,
                  () -> this.spawn(Game.random().choose(this.getSpawnPoints()), 1));
        }
        break;
      case CUSTOMSPAWNPOINTS:
        List<Spawnpoint> spawnPoints =
            this.customSpawnpoints != null
                ? this.customSpawnpoints.apply(this)
                : this.getCustomSpawnpoints();

        int index = 0;
        for (Spawnpoint spawn : spawnPoints) {
          Game.loop()
              .perform(
                  this.getSpawnDelay() + this.getSpawnDelay() * index, () -> this.spawn(spawn, 1));
          index++;
        }
        break;
      default:
        break;
    }
}
}
```
```java
class de.gurkenlabs.litiengine.tweening.TweenEngine {
@Override
  public void start() {
    Game.loop().attach(this);
}@Override
  public void terminate() {
    Game.loop().detach(this);
}
}
```
```java
class de.gurkenlabs.litiengine.gui.SpeechBubble {
public void hide() {
    Game.world().environment().removeRenderable(this);
    Game.loop().detach(this);
    if (activeSpeechBubbles.get(this.getEntity()) != null
        && activeSpeechBubbles.remove(this.getEntity()).equals(this)) {
      activeSpeechBubbles.remove(this.getEntity());
    }

    for (SpeechBubbleListener listener : this.listeners) {
      listener.hidden();
    }
}private SpeechBubble(
      final IEntity entity,
      final String text,
      @Nullable SpeechBubbleAppearance appearance,
      @Nullable Font font) {
    if (appearance == null) {
      this.appearance = DEFAULT_APPEARANCE;
    } else {
      this.appearance = appearance;
    }

    final SpeechBubble active = activeSpeechBubbles.get(entity);
    if (active != null) {
      active.hide();
    }
    this.setFont(font);

    this.textBoxWidth = (float) (entity.getWidth() * 4);
    this.entity = entity;

    this.currentText = text;
    this.currentTextDisplayTime = DISPLAYTIME_MIN + text.length() * DISPLAYTIME_PER_LETTER;

    this.lastTextDisplay = Game.time().now();
    this.createBubbleImage();
    entity.getEnvironment().add(this, RenderType.UI);
    Game.loop().attach(this);
    activeSpeechBubbles.put(entity, this);
}
}
```
```java
class de.gurkenlabs.litiengine.entities.Prop {
private void updateAnimationController() {
    IEntityAnimationController<?> controller = this.createAnimationController();
    this.getControllers().addController(controller);
    if (Game.world().environment() != null && Game.world().environment().isLoaded()) {
      Game.loop().attach(controller);
    }
}
}
```
```java
class de.gurkenlabs.litiengine.graphics.FreeFlightCamera {
public FreeFlightCamera(final Point2D focus) {
    this.setFocus(focus);
    this.velocity = DEFAULT_SCROLL_PIXELS_PER_SECOND;
    this.scrollPadding = DEFAULT_SCROLL_PADDING;
    this.setClampToMap(true);

    Game.loop().attach(this);
}private void handleFreeFlightCamera() {
      if (Game.world().environment() == null || Game.world().environment().getMap() == null) {
        return;
      }
  
      final Point2D mouseLocation = Input.mouse().getLocation();
  
      final double scrollSpeed =
          this.getVelocity()
              / (double) Nullability.castToNonnull(Game.loop(), "gameLoop always initialized")
                  .getTickRate()
              * Game.config().input().getMouseSensitivity();
  
      double x = this.getFocus().getX();
      double y = this.getFocus().getY();
  
      double deltaX = 0;
      if (mouseLocation.getX() < this.getScrollPadding()) {
        deltaX -= scrollSpeed;
      } else if (Game.window().getResolution().getWidth() - mouseLocation.getX()
          < this.getScrollPadding()) {
        deltaX += scrollSpeed;
      }
  
      double deltaY = 0;
      if (mouseLocation.getY() < this.getScrollPadding()) {
        deltaY -= scrollSpeed;
      } else if (Game.window().getResolution().getHeight() - mouseLocation.getY()
          < this.getScrollPadding()) {
        deltaY += scrollSpeed;
      }
  
      x += deltaX;
      y += deltaY;
  
      this.setFocus(new Point2D.Double(x, y));
}
}
```
```java
class de.gurkenlabs.litiengine.environment.Environment {
private static void dispose(final Collection<? extends IEntity> entities) {
    for (final IEntity entity : entities) {
      if (entity instanceof IUpdateable) {
        Game.loop().detach((IUpdateable) entity);
      }

      entity.detachControllers();
    }
}private static void loadUpdatableOrEmitterEntity(IEntity entity) {
      if (entity instanceof Emitter) {
        final Emitter emitter = (Emitter) entity;
        if (emitter.isActivateOnInit()) {
          emitter.activate();
        }
      } else if (entity instanceof IUpdateable) {
        Nullability.castToNonnull(Game.loop(), "initialized through init").attach((IUpdateable) entity);
      }
}private void unload(final IEntity entity) {
    // 1. remove from physics engine
    if (entity instanceof ICollisionEntity) {
      Game.physics().remove((ICollisionEntity) entity);
    }

    // 2. unregister from update
    if (entity instanceof IUpdateable) {
      Game.loop().detach((IUpdateable) entity);
    }

    if (entity instanceof IMobileEntity) {
      this.removeGravity((IMobileEntity) entity);
    }

    // 3. detach all controllers
    entity.detachControllers();

    if (entity instanceof Emitter) {
      Emitter em = (Emitter) entity;
      em.deactivate();
    }

    if (this.loaded && (entity instanceof LightSource || entity instanceof StaticShadow)) {
      this.updateLighting(entity);
    }

    entity.removed(this);
}
}
```
```java
class de.gurkenlabs.litiengine.graphics.animation.Animation {
@Override
  public void update() {
    // do nothing if the animation is not playing or the current keyframe is not finished
    if (!this.isPlaying()
        || Game.time().since(this.lastFrameUpdate) < this.getCurrentKeyFrame().getDuration()) {
      return;
    }

    // if we are not looping and the last keyframe is finished, we terminate the animation
    if (!this.isLooping() && this.isLastKeyFrame()) {
      this.terminate();
      return;
    }

    // make sure, we stay inside the keyframe list
    final int newFrameIndex =
        (this.getKeyframes().indexOf(this.currentFrame) + 1) % this.getKeyframes().size();
    final KeyFrame previousFrame = this.currentFrame;
    this.currentFrame = this.getKeyframes().get(newFrameIndex);

    for (KeyFrameListener listener : this.listeners) {
      listener.currentFrameChanged(previousFrame, this.currentFrame);
    }

    this.lastFrameUpdate = Game.loop().getTicks();
}public void restart() {
    this.currentFrame = this.firstFrame;
    this.lastFrameUpdate = Game.loop().getTicks();
}
}
```
```java
class de.gurkenlabs.litiengine.physics.MovementController {
@Override
    public void attach() {
      Nullability.castToNonnull(Game.loop(), "properly initialized before use").attach(this);
}private void handleForces() {
    // clean up forces
    this.activeForces.forEach(
        x -> {
          if (x.hasEnded()) {
            this.activeForces.remove(x);
          }
        });

    if (this.activeForces.isEmpty()) {
      return;
    }

    // disable turn-on-move for force handling
    boolean turn = this.getEntity().turnOnMove();
    this.getEntity().setTurnOnMove(false);
    try {
      double deltaX = 0;
      double deltaY = 0;
      for (final Force force : this.activeForces) {
        if (force.cancelOnReached() && force.hasReached(this.getEntity())) {
          force.end();
          continue;
        }

        final Point2D collisionBoxCenter = this.getEntity().getCollisionBoxCenter();
        final double angle =
            GeometricUtilities.calcRotationAngleInDegrees(collisionBoxCenter, force.getLocation());
        final double strength =
            Game.loop().getDeltaTime() * 0.001f * force.getStrength() * Game.loop().getTimeScale();
        deltaX += GeometricUtilities.getDeltaX(angle, strength);
        deltaY += GeometricUtilities.getDeltaY(angle, strength);
      }

      final Point2D target =
          new Point2D.Double(this.getEntity().getX() + deltaX, this.getEntity().getY() + deltaY);
      final boolean success = Game.physics().move(this.getEntity(), target);
      if (!success) {
        for (final Force force : this.activeForces) {
          if (force.cancelOnCollision()) {
            force.end();
          }
        }
      }
    } finally {
      this.getEntity().setTurnOnMove(turn);
    }
}@Override
  public void detach() {
    Game.loop().detach(this);
}public void handleMovement() {
    if (!this.isMovementAllowed()) {
      this.velocity = 0;
      return;
    }

    // max distance an entity can travel within one tick
    final double maxPixelsPerTick = this.getEntity().getTickVelocity();
    final double deltaTime = Game.loop().getDeltaTime() * Game.loop().getTimeScale();

    final double acceleration =
        this.getEntity().getAcceleration() == 0
            ? maxPixelsPerTick
            : deltaTime / this.getEntity().getAcceleration() * maxPixelsPerTick;
    final double deceleration =
        this.getEntity().getDeceleration() == 0
            ? this.getVelocity()
            : deltaTime / this.getEntity().getDeceleration() * maxPixelsPerTick;

    double dx = this.getDx();
    double dy = this.getDy();
    this.setDx(0);
    this.setDy(0);

    final double deltaVelocity =
        Math.min(Math.sqrt(Math.pow(dx, 2) + Math.pow(dy, 2)), acceleration);
    if (deltaVelocity != 0) {
      double newVelocity = this.getVelocity() + deltaVelocity;
      this.setVelocity(newVelocity);
    } else {
      final double newVelocity = Math.max(0, this.getVelocity() - deceleration);
      this.setVelocity(newVelocity);
      dx = GeometricUtilities.getDeltaX(this.moveAngle);
      dy = GeometricUtilities.getDeltaY(this.moveAngle);
    }

    if (this.getVelocity() == 0) {
      this.moveAngle = 0;
      return;
    }

    // actually move entity
    this.moveEntity(dx, dy);
}
}
```
```java
class de.gurkenlabs.litiengine.graphics.animation.AnimationController {
public void detach() {
    Game.loop().detach(this);
}public void attach() {
    Game.loop().attach(this);
}
}
```
```java
class de.gurkenlabs.litiengine.graphics.Camera {
@Override
  public void setZoom(final float targetZoom, final int delay) {
    if (delay == 0) {

      this.zoom = targetZoom;
      this.targetZoom = 0;
      this.zoomDelay = 0;
      this.zoomTick = 0;
      this.zoomStep = 0;

      final ZoomChangedEvent event = new ZoomChangedEvent(this, targetZoom);
      for (final ZoomChangedListener listener : this.zoomListeners) {
        listener.zoomChanged(event);
      }
    } else {
      this.zoomTick = Game.time().now();
      this.targetZoom = targetZoom;
      this.zoomDelay = delay;

      final double tickduration = 1000 / (double) Game.loop().getTickRate();
      final double tickAmount = delay / tickduration;
      final float totalDelta = this.targetZoom - this.zoom;
      this.zoomStep = tickAmount > 0 ? (float) (totalDelta / tickAmount) : totalDelta;
    }
}
}
```
```java
class de.gurkenlabs.litiengine.Game {
public static synchronized void init(String... args) {
    if (initialized) {
      log().log(Level.INFO, "The game has already been initialized.");
      return;
    }

    log.init();
    handleCommandLineArguments(args);

    config().load();
    Locale.setDefault(new Locale(config().client().getCountry(), config().client().getLanguage()));

    gameLoop = new GameLoop("Main Update Loop", config().client().getMaxFps());
    loop().attach(physics());
    loop().attach(world());

    // setup default exception handling for render and update loop
    setUncaughtExceptionHandler(
        new DefaultUncaughtExceptionHandler(config().client().exitOnError()));

    screenManager = new ScreenManager();
    gameWindow = new GameWindow();

    // initialize  the game window
    window().init();
    world.setCamera(new Camera());

    for (GameListener listener : gameListeners) {
      listener.initialized(args);
    }

    if (!isInNoGUIMode()) {
      window().getRenderComponent().onRendered(g -> metrics().render(g));

      graphics()
          .addEntityRenderedListener(
              e -> DebugRenderer.renderEntityDebugInfo(e.getGraphics(), e.getEntity()));

      window().getRenderComponent().onFpsChanged(fps -> metrics().setFramesPerSecond(fps));
      window()
          .setIcons(
              Arrays.asList(
                  Resources.images().get("liti-logo-x16.png"),
                  Resources.images().get("liti-logo-x20.png"),
                  Resources.images().get("liti-logo-x32.png"),
                  Resources.images().get("liti-logo-x48.png")));

      Input.keyboard()
          .onKeyTyped(
              KeyEvent.VK_PRINTSCREEN,
              key -> {
                // don't take a screenshot if a modifier is active
                if (key.getModifiers() != 0) {
                  return;
                }

                window().getRenderComponent().takeScreenshot();
              });
    }

    Runtime.getRuntime().addShutdownHook(new Thread(Game::terminate, "Shutdown"));

    initialized = true;
}
}
```
```java
class de.gurkenlabs.litiengine.entities.Creature {
protected void updateAnimationController() {
        IEntityAnimationController<?> controller = this.createAnimationController();
        this.getControllers().addController(controller);
        if (Game.world().environment() != null && Game.world().environment().isLoaded()) {
            Nullability.castToNonnull(Game.loop(), "expected to be non-null").attach(controller);
        }
}@Override
  public float getTickVelocity() {
    // pixels per ms multiplied by the passed ms
    // ensure that entities don't travel too far in case of lag
    return Math.min(Game.loop().getDeltaTime(), GameLoop.TICK_DELTATIME_LAG)
        * 0.001F
        * this.getVelocity().get()
        * Game.loop().getTimeScale();
}
}
```
Depth: 2
```java
class de.gurkenlabs.litiengine.environment.GameWorld {
public void clear() {
    this.unloadEnvironment();
    this.environments.clear();
    this.setCamera(null);
    Game.physics().clear();

    this.environmentListeners.clear();
    this.environmentLoadedListeners.clear();
    this.environmentUnloadedListeners.clear();

    this.listeners.clear();
    this.loadedListeners.clear();
    this.unloadedListeners.clear();
}@Nullable
  public Environment loadEnvironment(IMap map) {
    Environment env = this.getEnvironment(map);
    this.loadEnvironment(env);
    return env;
}@Nullable
  public Environment loadEnvironment(String mapName) {
    Environment env = this.getEnvironment(mapName);
    this.loadEnvironment(env);
    return env;
}
}
```
```java
class de.gurkenlabs.litiengine.GameWindow {
GameWindow() {
    this.hostControl = new JFrame();

    this.resolutionChangedListeners = new CopyOnWriteArrayList<>();

    this.renderCanvas = new RenderComponent(Game.config().graphics().getResolution());
    this.cursor = new MouseCursor();
    if (!Game.isInNoGUIMode()) {
      this.hostControl.setBackground(Color.BLACK);
      this.hostControl.add(this.renderCanvas);

      this.initializeEventListeners();

      this.hostControl.setTitle(Game.info().getTitle());
      this.hostControl.setDefaultCloseOperation(WindowConstants.DO_NOTHING_ON_CLOSE);
      initializeWindowEventListeners(this.hostControl);
    }
}
}
```
```java
class de.gurkenlabs.litiengine.GameTime {
public long sinceEnvironmentLoad() {
    return this.since(this.environmentLoaded);
}public long since(final long tick) {
    return toMilliseconds(Game.loop().getTicks() - tick);
}public long sinceGameStart() {
    return this.toMilliseconds(Game.loop().getTicks());
}
}
```
```java
class de.gurkenlabs.litiengine.abilities.effects.Effect {
protected void cease(final EffectApplication appliance) {
    // 1. cease the effect for all affected entities
    for (final ICombatEntity entity : appliance.getAffectedEntities()) {
      this.cease(entity);
    }

    // 2. apply follow up effects
    this.getFollowUpEffects().forEach(followUp -> followUp.apply(appliance.getImpactArea()));
}protected boolean hasEnded(final EffectApplication appliance) {
    final long effectDuration = Game.time().since(appliance.getAppliedTicks());
    return effectDuration > this.getDuration();
}
}
```
```java
class de.gurkenlabs.litiengine.abilities.effects.EffectApplication {
protected EffectApplication(final List<ICombatEntity> affectedEntities, final Shape impactArea) {
    this.applied = Game.time().now();
    this.affectedEntities = affectedEntities;
    this.impactArea = impactArea;
}
}
```
```java
class de.gurkenlabs.litiengine.entities.CombatEntity {
@Override
  public boolean wasHit(int timeSpan) {
    return Game.time().since(this.lastHit) < timeSpan;
}@Override
  public void hit(final int damage, @Nullable final Ability ability) {
    if (this.isDead()) {
      return;
    }

    if (!this.isIndestructible()) {
      this.getHitPoints().modifyBaseValue(new AttributeModifier<>(Modification.SUBTRACT, damage));
    }

    final EntityHitEvent event = new EntityHitEvent(this, ability, damage, this.isDead());

    for (final CombatEntityListener listener : this.listeners) {
      listener.hit(event);
    }

    for (final CombatEntityHitListener listener : this.hitListeners) {
      listener.hit(event);
    }

    if (this.isDead()) {
      this.fireDeathEvent();
      this.setCollision(false);
    }

    this.lastHit = Game.time().now();
}
}
```
```java
class de.gurkenlabs.litiengine.graphics.ImageEffect {
protected ImageEffect(final int ttl, final String name) {
    this.ttl = ttl;
    this.name = name;
    this.aliveTick = Game.time().now();
}@Override
  public long getAliveTime() {
    return Game.time().since(this.aliveTick);
}
}
```
```java
class de.gurkenlabs.litiengine.abilities.AbilityExecution {
AbilityExecution(final Ability ability) {
        this.appliedEffects = new CopyOnWriteArrayList<>();
        this.ability = ability;
        this.executionTicks = Game.time().now();
        this.impactArea = ability.calculateImpactArea();
        this.castLocation = ability.getExecutor().getCenter();
        Nullability.castToNonnull(Game.loop(), "proper initialization done").attach(this);
}@Override
  public void update() {
    // if there a no effects to apply -> unregister this instance and we're done
    if (this.getAbility().getEffects().isEmpty()
        || this.getAbility().getEffects().size() == this.getAppliedEffects().size()) {
      Game.loop().detach(this);
      return;
    }

    // handle all effects from the ability that were not applied yet
    for (final Effect effect : this.getAbility().getEffects()) {
      // if the ability was not executed yet or the delay of the effect is not
      // yet reached
      if (this.getAppliedEffects().contains(effect)
          || Game.time().since(this.getExecutionTicks()) < effect.getDelay()) {
        continue;
      }

      effect.apply(this.getExecutionImpactArea());
      this.getAppliedEffects().add(effect);
    }
}
}
```
```java
class de.gurkenlabs.litiengine.tweening.TweenEngine {
@Override
  public void update() {
    for (final Tweenable target : this.getTweens().keySet()) {
      for (final Tween tween : this.getTweens().get(target).values()) {
        if (tween.hasStopped()) {
          continue;
        }
        final long elapsed = Game.time().since(tween.getStartTime());
        if (elapsed >= tween.getDuration()) {
          tween.stop();
          continue;
        }
        final float[] currentValues = new float[tween.getTargetValues().length];
        for (int i = 0; i < tween.getTargetValues().length; i++) {
          currentValues[i] =
              tween.getStartValues()[i]
                  + tween.getEquation().compute(elapsed / (float) tween.getDuration())
                      * (tween.getTargetValues()[i] - tween.getStartValues()[i]);
        }
        tween.getTarget().setTweenValues(tween.getType(), currentValues);
      }
    }
}
}
```
```java
class de.gurkenlabs.litiengine.gui.SpeechBubble {
public static SpeechBubble create(
      final IEntity entity, final String text, SpeechBubbleAppearance appearance, Font font) {
    return new SpeechBubble(entity, text, appearance, font);
}public static SpeechBubble create(final IEntity entity, final Font font, final String text) {
    SpeechBubbleAppearance app =
        new SpeechBubbleAppearance(
            DEFAULT_APPEARANCE.getForeColor(),
            DEFAULT_APPEARANCE.getBackgroundColor1(),
            DEFAULT_APPEARANCE.getBorderColor(),
            DEFAULT_APPEARANCE.getPadding());
    return new SpeechBubble(entity, text, app, font);
}public static SpeechBubble create(final IEntity entity, final String text) {
    return new SpeechBubble(entity, text, null, GuiProperties.getDefaultFont());
}@Override
  public void update() {
    if (this.currentText == null) {
      this.hide();
      return;
    }

    this.entityCenter = Game.world().camera().getViewportLocation(this.getEntity().getCenter());

    // old text was displayed long enough
    if (this.lastTextDisplay != 0
        && Game.time().since(this.lastTextDisplay) > this.currentTextDisplayTime) {
      this.currentText = null;
      this.lastTextDisplay = 0;
      return;
    }

    // display new text
    if (this.textIndex < this.currentText.length()
        && Game.time().since(this.lastCharPoll) > LETTER_WRITE_DELAY) {
      this.textIndex++;
      this.lastCharPoll = Game.time().now();
      if (this.typeSound != null) {
        Game.audio().playSound(this.typeSound, this.getEntity());
      }
    }

    // continue displaying currently displayed text
}private SpeechBubble(
      final IEntity entity,
      final String text,
      final Sound typeSound,
      SpeechBubbleAppearance appearance,
      Font font) {
    this(entity, text, appearance, font);
    this.typeSound = typeSound;
}private SpeechBubble(
      final IEntity entity,
      final String text,
      @Nullable SpeechBubbleAppearance appearance,
      @Nullable Font font) {
    if (appearance == null) {
      this.appearance = DEFAULT_APPEARANCE;
    } else {
      this.appearance = appearance;
    }

    final SpeechBubble active = activeSpeechBubbles.get(entity);
    if (active != null) {
      active.hide();
    }
    this.setFont(font);

    this.textBoxWidth = (float) (entity.getWidth() * 4);
    this.entity = entity;

    this.currentText = text;
    this.currentTextDisplayTime = DISPLAYTIME_MIN + text.length() * DISPLAYTIME_PER_LETTER;

    this.lastTextDisplay = Game.time().now();
    this.createBubbleImage();
    entity.getEnvironment().add(this, RenderType.UI);
    Game.loop().attach(this);
    activeSpeechBubbles.put(entity, this);
}
}
```
```java
class de.gurkenlabs.litiengine.gui.TextFieldComponent {
@Override
  public void render(final Graphics2D g) {
    super.render(g);
    g.setFont(this.getFont());
    final FontMetrics fm = g.getFontMetrics();

    if (this.isSelected() && Game.time().since(this.lastToggled) > this.flickerDelay) {
      this.cursorVisible = !this.cursorVisible;
      this.lastToggled = Game.time().now();
    }
    if (this.isSelected() && this.cursorVisible) {
      final Rectangle2D cursor =
          new Rectangle2D.Double(
              this.getX() + this.getTextX() + fm.stringWidth(this.getTextToRender(g)),
              this.getY() + this.getTextY(),
              this.getFont().getSize2D() * 3 / 5,
              this.getFont().getSize2D() * 1 / 5);
      g.setColor(this.getAppearance().getForeColor());
      g.fill(cursor);
    }
}
}
```
```java
class de.gurkenlabs.litiengine.entities.Prop {
public Prop(
      final Point2D location, @Nullable final String spritesheetName, final Material material) {
    super();
    this.rotation = Rotation.NONE;
    this.spritesheetName = spritesheetName;
    this.material = material;
    this.setLocation(location);
    this.updateAnimationController();
}public void setSpritesheetName(@Nullable final String spriteName) {
    this.spritesheetName = spriteName;
    this.updateAnimationController();
}
}
```
```java
class de.gurkenlabs.litiengine.tweening.Tween {
public Tween begin() {
    this.started = Game.time().now();
    this.stopped = false;
    return this;
}
}
```
```java
class de.gurkenlabs.litiengine.graphics.emitters.particles.Particle {
public void update(final Point2D emitterOrigin, final float updateRatio) {
    if (this.aliveTick == 0) {
      this.aliveTick = Game.time().now();
    }

    this.aliveTime = Game.time().since(this.aliveTick);
    if (this.timeToLiveReached()) {
      return;
    }

    if (this.colliding) {
      return;
    }

    if (this.getDeltaWidth() != 0) {
      this.width += this.getDeltaWidth() * updateRatio;
    }

    if (this.getDeltaHeight() != 0) {
      this.height += this.getDeltaHeight() * updateRatio;
    }

    if (this.getDeltaAngle() != 0) {
      this.angle += this.getDeltaAngle() * updateRatio;
    }

    // test for ray cast collision
    final float targetX = this.x + this.getVelocityX() * updateRatio;
    final float targetY = this.y + this.getVelocityY() * updateRatio;

    if (targetX == this.x && targetY == this.y) {
      return;
    }

    if (this.checkForCollision(emitterOrigin, targetX, targetY)) {
      return;
    }

    if (this.getVelocityX() != 0) {
      this.x = targetX;
    }

    if (this.getVelocityY() != 0) {
      this.y = targetY;
    }

    if (this.getAccelerationX() != 0) {
      this.velocityX += this.getAccelerationX() * updateRatio;
    }

    if (this.getAccelerationY() != 0) {
      this.velocityY += this.getAccelerationY() * updateRatio;
    }
}
}
```
```java
class de.gurkenlabs.litiengine.graphics.animation.Animation {
@Override
  public void start() {
    this.playing = true;
    if (this.getKeyframes().isEmpty()) {
      return;
    }

    this.restart();
}@Override
  public void update() {
    // do nothing if the animation is not playing or the current keyframe is not finished
    if (!this.isPlaying()
        || Game.time().since(this.lastFrameUpdate) < this.getCurrentKeyFrame().getDuration()) {
      return;
    }

    // if we are not looping and the last keyframe is finished, we terminate the animation
    if (!this.isLooping() && this.isLastKeyFrame()) {
      this.terminate();
      return;
    }

    // make sure, we stay inside the keyframe list
    final int newFrameIndex =
        (this.getKeyframes().indexOf(this.currentFrame) + 1) % this.getKeyframes().size();
    final KeyFrame previousFrame = this.currentFrame;
    this.currentFrame = this.getKeyframes().get(newFrameIndex);

    for (KeyFrameListener listener : this.listeners) {
      listener.currentFrameChanged(previousFrame, this.currentFrame);
    }

    this.lastFrameUpdate = Game.loop().getTicks();
}
}
```
```java
class de.gurkenlabs.litiengine.graphics.animation.AnimationController {
@Override
  public void update() {
    for (final Animation animation : this.getAll()) {
      animation.update();
    }

    if (this.getCurrent() != null && this.getCurrent().isPaused()) {
      return;
    }

    final boolean playbackFinished = this.getCurrent() != null && !this.getCurrent().isPlaying();
    if (playbackFinished) {
      for (final AnimationListener listener : this.listeners) {
        listener.finished(this.getCurrent());
      }
    }

    if (this.getCurrent() == null || playbackFinished) {
      if (this.getDefault() != null) {
        this.play(this.getDefault().getName());
      } else {
        this.currentAnimation = null;
      }
    }
}
}
```
```java
class de.gurkenlabs.litiengine.graphics.RenderComponent {
private void handleFade() {
    if (this.fadeOutStart != -1) {
      final long timePassed = Game.time().since(this.fadeOutStart);
      this.currentAlpha = MathUtilities.clamp(1 - timePassed / (float) this.fadeOutTime, 0, 1);
      if (this.currentAlpha == 0f) {
        this.fadeOutStart = -1;
        this.fadeOutTime = -1;
      }

      return;
    }

    if (this.fadeInStart != -1) {
      final long timePassed = Game.time().since(this.fadeInStart);
      this.currentAlpha = MathUtilities.clamp(timePassed / (float) this.fadeInTime, 0, 1);
      if (this.currentAlpha == 1f) {
        this.fadeInStart = -1;
        this.fadeInTime = -1;
        this.currentAlpha = Float.NaN;
      }
    }
}public void fadeOut(final int ms) {
    this.fadeInStart = -1;
    this.fadeInTime = -1;
    this.fadeOutStart = Game.time().now();
    this.fadeOutTime = ms;
}public void fadeIn(final int ms) {
    this.fadeOutStart = -1;
    this.fadeOutTime = -1;
    this.fadeInStart = Game.time().now();
    this.fadeInTime = ms;
}
}
```
```java
class de.gurkenlabs.litiengine.entities.Trigger {
private boolean activate(final IEntity activator, final int tar) {
    if (!this.isLoaded()
        || this.isOneTimeTrigger && this.isActivated
        || this.getActivationType() == TriggerActivation.COLLISION
            && activator != null
            && this.collisionActivated.contains(activator)) {
      return false;
    }

    if (this.getCooldown() > 0 && Game.time().since(this.lastActivation) < this.getCooldown()) {
      return false;
    }

    List<Integer> triggerTargets = this.getTargets(tar);

    final TriggerEvent te = new TriggerEvent(this, activator, triggerTargets);

    if (!this.checkActivationPredicates(te)) {
      return false;
    }

    this.isActivated = true;
    if (activator != null) {
      this.collisionActivated.add(activator);
    }

    // if we actually have a trigger target, we send the message to the target
    for (final int target : triggerTargets) {
      final IEntity entity = this.getEnvironment().get(target);
      if (entity == null) {
        log.log(
            Level.WARNING,
            "trigger [{0}] was activated, but the trigger target [{1}] could not be found on the environment",
            new Object[] {this, target});
        continue;
      }

      entity.sendMessage(this, this.message);
    }

    // also send the trigger event to all registered consumers
    for (final TriggerActivatedListener listener : this.activatedListeners) {
      listener.activated(te);
    }

    if (this.isOneTimeTrigger) {
      this.getEnvironment().remove(this);
    }

    this.lastActivation = Game.time().now();
    return true;
}
}
```
```java
class de.gurkenlabs.litiengine.graphics.Camera {
private boolean isShakeEffectActive() {
    return this.getShakeTick() != 0
        && Game.time().since(this.getShakeTick()) < this.getShakeDuration();
}@Override
  public void update() {
    if (Game.world().camera() != null && !Game.world().camera().equals(this)) {
      return;
    }

    if (this.targetZoom > 0) {
      if (Game.time().since(this.zoomTick) >= this.zoomDelay) {
        this.zoom = this.targetZoom;
        this.targetZoom = 0;
        this.zoomDelay = 0;
        this.zoomTick = 0;
        this.zoomStep = 0;
      } else {
        this.zoom += this.zoomStep;
      }

      final ZoomChangedEvent event = new ZoomChangedEvent(this, this.getZoom());
      for (final ZoomChangedListener listener : this.zoomListeners) {
        listener.zoomChanged(event);
      }
    }

    if (this.panTime > 0) {
      if (--this.panTime <= 0) {
        this.setFocus(this.targetFocus);
        this.targetFocus = null;
      } else {
        double diff = this.panTime / (this.panTime + 1.0);
        this.focus =
            new Point2D.Double(
                this.focus.getX() * diff + this.targetFocus.getX() * (1.0 - diff),
                this.focus.getY() * diff + this.targetFocus.getY() * (1.0 - diff));
      }
    }

    if (!this.isShakeEffectActive()) {
      this.shakeOffsetX = 0;
      this.shakeOffsetY = 0;
      return;
    }

    if (Game.time().since(this.lastShake) > this.shakeDelay) {
      this.shakeOffsetX = this.getShakeIntensity() * ThreadLocalRandom.current().nextGaussian();
      this.shakeOffsetY = this.getShakeIntensity() * ThreadLocalRandom.current().nextGaussian();
      this.lastShake = Game.time().now();
    }
}@Override
  public void setZoom(final float targetZoom, final int delay) {
    if (delay == 0) {

      this.zoom = targetZoom;
      this.targetZoom = 0;
      this.zoomDelay = 0;
      this.zoomTick = 0;
      this.zoomStep = 0;

      final ZoomChangedEvent event = new ZoomChangedEvent(this, targetZoom);
      for (final ZoomChangedListener listener : this.zoomListeners) {
        listener.zoomChanged(event);
      }
    } else {
      this.zoomTick = Game.time().now();
      this.targetZoom = targetZoom;
      this.zoomDelay = delay;

      final double tickduration = 1000 / (double) Game.loop().getTickRate();
      final double tickAmount = delay / tickduration;
      final float totalDelta = this.targetZoom - this.zoom;
      this.zoomStep = tickAmount > 0 ? (float) (totalDelta / tickAmount) : totalDelta;
    }
}@Override
  public void shake(final double intensity, final int delay, final int shakeDuration) {
    this.shakeTick = Game.time().now();
    this.shakeDelay = delay;
    this.shakeIntensity = intensity;
    this.shakeDuration = shakeDuration;
}
}
```
```java
class de.gurkenlabs.litiengine.entities.Creature {
public void setSpritesheetName(String spritesheetName) {
    if (this.spritesheetName != null && this.spritesheetName.equals(spritesheetName)) {
      return;
    }

    this.spritesheetName = spritesheetName;
    this.updateAnimationController();
}public boolean isIdle() {
    return Game.time().since(this.lastMoved) > IDLE_DELAY;
}@Override
  public void setLocation(final Point2D position) {
    if (this.isDead() || position == null) {
      return;
    }

    final Point2D oldLocation = this.getLocation();
    super.setLocation(position);

    if (Game.hasStarted() && this.isLoaded()) {
      this.lastMoved = Game.time().now();
      this.fireMovedEvent(
          new EntityMovedEvent(
              this, this.getX() - oldLocation.getX(), this.getY() - oldLocation.getY()));
    }
}
}
```
```java
class de.gurkenlabs.litiengine.gui.screens.ScreenManager {
public void display(final String screenName) {
    if (this.current() != null && this.current().getName().equalsIgnoreCase(screenName)) {
      log.log(
          Level.INFO,
          "Skipping displaying of screen {0} because it is already the current screen.",
          screenName);
      return;
    }

    if (this.screens.stream()
        .noneMatch(element -> element.getName().equalsIgnoreCase(screenName))) {
      log.log(
          Level.WARNING,
          "Could not display the screen {0} because there is no screen with the specified name.",
          screenName);
      return;
    }

    Screen screen = this.get(screenName);
    if (screen == null) {
      return;
    }

    this.display(screen);
}public void add(final Screen screen) {
    screen.setWidth(Game.window().getWidth());
    screen.setHeight(Game.window().getHeight());
    this.screens.add(screen);

    if (this.current() == null) {
      this.display(screen);
    }
}public void remove(Screen screen) {
    this.screens.remove(screen);
    if (this.current() == screen) {
      if (!this.screens.isEmpty()) {
        this.display(this.screens.get(0));
      } else {
        this.display((Screen) null);
      }
    }
}public void display(@Nullable final Screen screen) {
      if (Game.hasStarted() && Game.time().since(this.lastScreenChange) < this.getChangeCooldown()) {
        log.log(
            Level.INFO,
            "Skipping displaying of screen {0} because screen changing is currently on cooldown.",
            screen != null ? screen.getName() : "");
        return;
      }
  
      final Screen previous = this.current();
      if (previous != null) {
        previous.suspend();
      }
  
      if (screen != null && !this.screens.contains(screen)) {
        this.screens.add(screen);
      }
  
      this.currentScreen = screen;
      if (!Game.isInNoGUIMode() && this.current() != null) {
        this.current().prepare();
      }
  
      this.lastScreenChange = Nullability.castToNonnull(Game.loop(), "initialized before usage").getTicks();
  
      final ScreenChangedEvent event = new ScreenChangedEvent(this.current(), previous);
      for (final ScreenChangedListener listener : this.screenChangedListeners) {
        listener.changed(event);
      }
}
}
```
```java
class de.gurkenlabs.litiengine.abilities.Ability {
public boolean isOnCooldown() {
    return (this.getCurrentExecution() != null
        && this.getCurrentExecution().getExecutionTicks() > 0
        && Game.time().since(this.getCurrentExecution().getExecutionTicks())
            < this.getAttributes().cooldown().get());
}public boolean isActive() {
    return this.getCurrentExecution() != null
        && Game.time().since(this.getCurrentExecution().getExecutionTicks())
            < this.getAttributes().duration().get();
}@Nullable
  public AbilityExecution cast() {
    if (!this.canCast()) {
      return null;
    }
    this.currentExecution = new AbilityExecution(this);

    for (final AbilityCastListener listener : this.abilityCastListeners) {
      listener.abilityCast(this.currentExecution);
    }

    return this.getCurrentExecution();
}public float getRemainingCooldownInSeconds() {
    if (this.getCurrentExecution() == null
        || this.getExecutor() == null
        || this.getExecutor().isDead()) {
      return 0;
    }

    // calculate cooldown in seconds
    return (float)
        (!this.canCast()
            ? (this.getAttributes().cooldown().get()
                    - Game.time().since(this.getCurrentExecution().getExecutionTicks()))
                * 0.001
            : 0);
}
}
```
```java
class de.gurkenlabs.litiengine.entities.EntityHitEvent {
EntityHitEvent(
      final ICombatEntity hitEntity,
      @Nullable final Ability ability,
      final int damage,
      final boolean kill) {
    super(hitEntity);
    this.executor = ability != null ? ability.getExecutor() : null;
    this.hitEntity = hitEntity;
    this.ability = ability;
    this.damage = damage;
    this.kill = kill;
    this.time = Game.time().now();
}
}
```
```java
class de.gurkenlabs.litiengine.graphics.emitters.Emitter {
public void delete() {
    this.deactivate();
    if (Game.world().environment() != null) {
      Game.world().environment().remove(this);
    }
}public void activate() {
    if (this.activated) {
      return;
    }

    this.activated = true;
    this.activationTick = Game.time().now();
    Game.loop().attach(this);
}@Override
  public void update() {
    if (this.isPaused()) {
      return;
    }

    // clear particles if the effect time to life is reached
    if (this.isFinished()) {
      for (EmitterFinishedListener listener : this.finishedListeners) {
        listener.finished(this);
      }

      this.delete();
      return;
    }

    final float updateRatio = (float) this.data().getUpdateRate() / Game.loop().getTickRate();
    for (final Particle p : this.getParticles().stream().collect(Collectors.toList())) {
      if (this.particleCanBeRemoved(p)) {
        // remove dead particles
        this.particles.remove(p);
        continue;
      }

      p.update(this.getOrigin(), updateRatio);
    }

    this.aliveTime = Game.time().since(this.activationTick);
    if ((this.data().getSpawnRate() == 0
        || Game.time().since(this.lastSpawn) >= this.data().getSpawnRate())) {
      this.lastSpawn = Game.time().now();
      this.spawnParticle();
    }
}
}
```
```java
class de.gurkenlabs.litiengine.GameLoop {
@Override
  public int perform(int delay, Runnable action) {
    final long d = Game.time().toTicks(delay);

    TimedAction a = new TimedAction(this.getTicks() + d, action);
    this.actions.add(a);

    return a.getId();
}
}
```
```java
class de.gurkenlabs.litiengine.environment.EntitySpawner {
protected boolean shouldSpawn() {
    return this.lastSpawnWave == 0
        || Game.time().since(this.lastSpawnWave) >= this.getSpawnInterval();
}@Override
  public void update() {
    if (!this.shouldSpawn()) {
      return;
    }

    this.spawnNewEntities();
    this.lastSpawnWave = Game.time().now();
}
}
```
```java
class de.gurkenlabs.litiengine.graphics.FreeFlightCamera {
@Override
  public void update() {
    this.handleFreeFlightCamera();
}public FreeFlightCamera(double x, double y) {
    this(new Point2D.Double(x, y));
}
}
```
```java
class de.gurkenlabs.litiengine.environment.Environment {
public void unload() {
    if (!this.loaded) {
      return;
    }

    // unregister all updatable entities from the current environment
    for (final IEntity entity : this.allEntities.values()) {
      this.unload(entity);
    }

    this.loaded = false;
    this.fireEvent(l -> l.unloaded(this));
}private static void loadUpdatableOrEmitterEntity(IEntity entity) {
      if (entity instanceof Emitter) {
        final Emitter emitter = (Emitter) entity;
        if (emitter.isActivateOnInit()) {
          emitter.activate();
        }
      } else if (entity instanceof IUpdateable) {
        Nullability.castToNonnull(Game.loop(), "initialized through init").attach((IUpdateable) entity);
      }
}public void clear() {
    Game.physics().clear();

    this.combatEntities.clear();
    this.mobileEntities.clear();
    this.gravityForces.clear();
    this.layerEntities.clear();
    this.entitiesByTag.clear();
    this.allEntities.clear();

    for (RenderType renderType : RenderType.values()) {
      this.miscEntities.get(renderType).clear();
      this.renderListeners.get(renderType).clear();
      this.renderables.get(renderType).clear();
    }

    dispose(this.allEntities.values());
    dispose(this.triggers);
    this.emitters.clear();
    this.colliders.clear();
    this.props.clear();
    this.creatures.clear();
    this.staticShadows.clear();
    this.combatEntities.clear();
    this.mobileEntities.clear();
    this.lightSources.clear();
    this.spawnPoints.clear();
    this.soundSources.clear();
    this.mapAreas.clear();
    this.triggers.clear();

    this.ambientLight = null;
    this.staticShadowLayer = null;

    for (Map<Integer, IEntity> type : this.miscEntities.values()) {
      type.clear();
    }

    this.initialized = false;

    this.fireEvent(l -> l.cleared(this));
}private void load(final IEntity entity) {
    // an entity can only exist on one environment at a time, so remove it from the current one
    if (entity.getEnvironment() != null) {
      entity.getEnvironment().remove(entity);
    }

    // 1. add to physics engine
    loadPhysicsEntity(entity);

    // 2. register for update or activate
    loadUpdatableOrEmitterEntity(entity);

    // 3. if a gravity is defined, add a gravity force to the entity
    if (entity instanceof IMobileEntity && this.getGravity() != 0) {
      this.addGravityForce((IMobileEntity) entity);
    }

    // 4. attach all controllers
    entity.attachControllers();

    if (this.loaded && (entity instanceof LightSource || entity instanceof StaticShadow)) {
      this.updateLighting(entity);
    }

    entity.loaded(this);
}private void unload(final IEntity entity) {
    // 1. remove from physics engine
    if (entity instanceof ICollisionEntity) {
      Game.physics().remove((ICollisionEntity) entity);
    }

    // 2. unregister from update
    if (entity instanceof IUpdateable) {
      Game.loop().detach((IUpdateable) entity);
    }

    if (entity instanceof IMobileEntity) {
      this.removeGravity((IMobileEntity) entity);
    }

    // 3. detach all controllers
    entity.detachControllers();

    if (entity instanceof Emitter) {
      Emitter em = (Emitter) entity;
      em.deactivate();
    }

    if (this.loaded && (entity instanceof LightSource || entity instanceof StaticShadow)) {
      this.updateLighting(entity);
    }

    entity.removed(this);
}public void remove(final IEntity entity) {
    if (entity == null) {
      return;
    }

    this.allEntities.remove(entity.getMapId());
    Iterator<List<IEntity>> iter = this.layerEntities.values().iterator();
    while (iter.hasNext()) {
      List<IEntity> layer = iter.next();
      if (layer.remove(entity) && layer.isEmpty()) {
        iter.remove();
      }
    }
    if (this.miscEntities.get(entity.getRenderType()) != null) {
      this.miscEntities.get(entity.getRenderType()).values().remove(entity);
    }

    for (String tag : entity.getTags()) {
      if (this.getEntitiesByTag().containsKey(tag)) {
        this.getEntitiesByTag().get(tag).remove(entity);

        if (this.getEntitiesByTag().get(tag).isEmpty()) {
          this.getEntitiesByTag().remove(tag);
        }
      }
    }

    if (entity instanceof Emitter) {
      Emitter emitter = (Emitter) entity;
      this.removeEmitter(emitter);
    }

    if (entity instanceof MapArea) {
      this.mapAreas.remove(entity);
    }

    if (entity instanceof Prop) {
      this.props.remove(entity);
    }

    if (entity instanceof Creature) {
      this.creatures.remove(entity);
    }

    if (entity instanceof CollisionBox) {
      this.colliders.remove(entity);
      this.staticShadows.removeIf(x -> x.getOrigin() != null && x.getOrigin().equals(entity));
    }

    if (entity instanceof LightSource) {
      this.lightSources.remove(entity);
      this.updateLighting(entity);
    }

    if (entity instanceof Trigger) {
      this.triggers.remove(entity);
    }

    if (entity instanceof Spawnpoint) {
      this.spawnPoints.remove(entity);
    }
    if (entity instanceof SoundSource) {
      this.soundSources.remove(entity);
    }

    if (entity instanceof StaticShadow) {
      this.staticShadows.remove(entity);
      this.updateLighting(entity);
    }

    if (entity instanceof IMobileEntity) {
      this.mobileEntities.values().remove(entity);
    }

    if (entity instanceof ICombatEntity) {
      this.combatEntities.values().remove(entity);
    }

    this.unload(entity);

    this.fireEntityEvent(l -> l.entityRemoved(entity));
}
}
```
```java
class de.gurkenlabs.litiengine.physics.MovementController {
@Override
  public void update() {
    this.handleForces();
    this.handleMovement();
}
}
```
```java
class de.gurkenlabs.litiengine.Game {
static synchronized void terminate() {
        if (!initialized || gameLoop == null) {
          return;
        }
    
        hasStarted = false;
        initialized = false;
    
        config().save();
        gameLoop.terminate();
        tweenEngine.terminate();
        soundEngine.terminate();
    
        world().clear();
    
        for (final GameListener listener : gameListeners) {
          try {
            listener.terminated();
          } catch (Exception e) {
            log().log(Level.WARNING, "game listener threw an exception during shutdown", e);
          }
        }
    
        gameLoop = null;
        screenManager = null;
        gameWindow = null;
}public static synchronized void start() {
          if (!initialized) {
              throw new IllegalStateException(
                  "The game cannot be started without being first initialized. Call Game.init(...) before Game.start().");
          }
    
          if (gameLoop == null) {
              throw new IllegalStateException(
                  "Game loop is not initialized. Ensure Game.init(...) has been called successfully.");
          }
          
          Nullability.castToNonnull(gameLoop, "gameLoop cannot be null").start();
          tweenEngine.start();
          soundEngine.start();
    
          for (final GameListener listener : gameListeners) {
              listener.started();
          }
    
          hasStarted = true;
}public static synchronized void init(String... args) {
    if (initialized) {
      log().log(Level.INFO, "The game has already been initialized.");
      return;
    }

    log.init();
    handleCommandLineArguments(args);

    config().load();
    Locale.setDefault(new Locale(config().client().getCountry(), config().client().getLanguage()));

    gameLoop = new GameLoop("Main Update Loop", config().client().getMaxFps());
    loop().attach(physics());
    loop().attach(world());

    // setup default exception handling for render and update loop
    setUncaughtExceptionHandler(
        new DefaultUncaughtExceptionHandler(config().client().exitOnError()));

    screenManager = new ScreenManager();
    gameWindow = new GameWindow();

    // initialize  the game window
    window().init();
    world.setCamera(new Camera());

    for (GameListener listener : gameListeners) {
      listener.initialized(args);
    }

    if (!isInNoGUIMode()) {
      window().getRenderComponent().onRendered(g -> metrics().render(g));

      graphics()
          .addEntityRenderedListener(
              e -> DebugRenderer.renderEntityDebugInfo(e.getGraphics(), e.getEntity()));

      window().getRenderComponent().onFpsChanged(fps -> metrics().setFramesPerSecond(fps));
      window()
          .setIcons(
              Arrays.asList(
                  Resources.images().get("liti-logo-x16.png"),
                  Resources.images().get("liti-logo-x20.png"),
                  Resources.images().get("liti-logo-x32.png"),
                  Resources.images().get("liti-logo-x48.png")));

      Input.keyboard()
          .onKeyTyped(
              KeyEvent.VK_PRINTSCREEN,
              key -> {
                // don't take a screenshot if a modifier is active
                if (key.getModifiers() != 0) {
                  return;
                }

                window().getRenderComponent().takeScreenshot();
              });
    }

    Runtime.getRuntime().addShutdownHook(new Thread(Game::terminate, "Shutdown"));

    initialized = true;
}
}
```


Response Format:
Provide the answer in **XML format** as follows:

#### If the method **cannot** return `null` at the specific call site:
```xml
<response>
  <reason><![CDATA[EXPLAIN WHY THE INVOCATION Game.loop() RESULT CANNOT BE NULL.]]></reason>
  <value>NO</value>
</response>

#### If the method can return null at the specific call site:
<response>
  <reason><![CDATA[EXPLAIN WHY THE INVOCATION Game.loop() RESULT CAN BE NULL.]]></reason>
  <value>YES</value>
</response>

#### If you are unsure or If there are any methods that directly or indirectly affect the return value and are not fully disclosed, request their declarations first, in the following format:
<response>
  <reason><![CDATA[EXPLAIN WHY THIS METHOD DECLARATION IS NECESSARY AND WHY YOU CANNOT MAKE A CONFIDENT DECISION WITHOUT IT]]></reason>
  <success>false</success>
  <methods>
    <method>methodName</method>
  </methods>
</response>

Additional Notes:
Be precise in your reasoning.
If a methods return value depends on another method not provided, request its declaration before making a conclusion.
If the method can return null in this case but not in others, explain why it happens specifically for this call.

11:53:27.540 TRACE edu.ucr.cs.riple.core.checkers.nullaway.codefix.ChatGPT.ask
Retrieving response from cache
11:53:27.540 TRACE edu.ucr.cs.riple.core.checkers.nullaway.codefix.Response.tryCreate
Trying to create Response:
```xml
<response>
  <reason><![CDATA[
    The specific invocation of `Game.loop()` cannot return `null` given the initialization sequence described in the code. 
    The `GameLoop` instance (`gameLoop`) is set during the `Game.init()` method, which initializes the game loop with `new GameLoop(...)`. 
    The method `Game.loop()` then returns this `gameLoop`. 
    Since the initialization method (`Game.init()`) ensures that `gameLoop` is not `null`, any call to `Game.loop()` after `Game.init()` would not return `null`. 
    Additionally, the `Game.terminate()` method that sets `gameLoop` to `null` is only called during game termination, ensuring that during normal game execution, `gameLoop` is valid.
  ]]></reason>
  <value>NO</value>
</response>
```
11:53:27.541 TRACE edu.ucr.cs.riple.core.checkers.nullaway.codefix.Response.<init>
Creating Response:
```xml
<response>
  <reason><![CDATA[
    The specific invocation of `Game.loop()` cannot return `null` given the initialization sequence described in the code. 
    The `GameLoop` instance (`gameLoop`) is set during the `Game.init()` method, which initializes the game loop with `new GameLoop(...)`. 
    The method `Game.loop()` then returns this `gameLoop`. 
    Since the initialization method (`Game.init()`) ensures that `gameLoop` is not `null`, any call to `Game.loop()` after `Game.init()` would not return `null`. 
    Additionally, the `Game.terminate()` method that sets `gameLoop` to `null` is only called during game termination, ensuring that during normal game execution, `gameLoop` is valid.
  ]]></reason>
  <value>NO</value>
</response>
```
11:53:27.541 TRACE edu.ucr.cs.riple.core.checkers.nullaway.codefix.Response.<init>
Response created:
Disagreement: The specific invocation of `Game.loop()` cannot return `null` given the initialization sequence described in the code. 
    The `GameLoop` instance (`gameLoop`) is set during the `Game.init()` method, which initializes the game loop with `new GameLoop(...)`. 
    The method `Game.loop()` then returns this `gameLoop`. 
    Since the initialization method (`Game.init()`) ensures that `gameLoop` is not `null`, any call to `Game.loop()` after `Game.init()` would not return `null`. 
    Additionally, the `Game.terminate()` method that sets `gameLoop` to `null` is only called during game termination, ensuring that during normal game execution, `gameLoop` is valid.
11:53:27.541 TRACE edu.ucr.cs.riple.core.checkers.nullaway.codefix.AdvancedNullAwayCodeFix.resolveMethodDereferenceError
Method is not returning nullable on call site. Injecting suppression annotation.
11:53:27.541 TRACE edu.ucr.cs.riple.core.checkers.nullaway.codefix.AdvancedNullAwayCodeFix.constructCastToNonnullChange
Constructing cast to nonnull change for reason: The specific invocation of `Game.loop()` cannot return `null` given the initialization sequence described in the code. 
    The `GameLoop` instance (`gameLoop`) is set during the `Game.init()` method, which initializes the game loop with `new GameLoop(...)`. 
    The method `Game.loop()` then returns this `gameLoop`. 
    Since the initialization method (`Game.init()`) ensures that `gameLoop` is not `null`, any call to `Game.loop()` after `Game.init()` would not return `null`. 
    Additionally, the `Game.terminate()` method that sets `gameLoop` to `null` is only called during game termination, ensuring that during normal game execution, `gameLoop` is valid.
11:53:27.542 TRACE edu.ucr.cs.riple.core.checkers.nullaway.codefix.ChatGPT.ask
Asking ChatGPT:
For the reason you mentioned earlier:

"The specific invocation of `Game.loop()` cannot return `null` given the initialization sequence described in the code. 
    The `GameLoop` instance (`gameLoop`) is set during the `Game.init()` method, which initializes the game loop with `new GameLoop(...)`. 
    The method `Game.loop()` then returns this `gameLoop`. 
    Since the initialization method (`Game.init()`) ensures that `gameLoop` is not `null`, any call to `Game.loop()` after `Game.init()` would not return `null`. 
    Additionally, the `Game.terminate()` method that sets `gameLoop` to `null` is only called during game termination, ensuring that during normal game execution, `gameLoop` is valid."

in the method below, the expression Game.loop() is not nullable at the point it is used.

```java
private static void initializeWindowEventListeners(Window window) {

    window.addWindowStateListener(
        e -> {
          if (e.getNewState() == Frame.ICONIFIED) {
            Game.loop().setTickRate(ICONIFIED_MAX_FPS);
          } else {
            Game.loop().setTickRate(Game.config().client().getMaxFps());
          }
        });

    window.addWindowFocusListener(
        new WindowFocusListener() {
          @Override
          public void windowLostFocus(WindowEvent e) {
            if (Game.config().graphics().reduceFramesWhenNotFocused()) {
              Game.loop().setTickRate(NONE_FOCUS_MAX_FPS);
            }
          }

          @Override
          public void windowGainedFocus(WindowEvent e) {
            Game.loop().setTickRate(Game.config().client().getMaxFps());
          }
        });

    window.addWindowListener(
        new WindowAdapter() {
          @Override
          public void windowClosing(final WindowEvent event) {
            Game.exit();
          }
        });
}
```
Please Summarize the reason in max 5 words and rewrite the method so that at the line "            Game.loop().setTickRate(ICONIFIED_MAX_FPS);", at the occurrence of: "Game.loop()" is replaced with `Nullability.castToNonnull(Game.loop(), summary of reason)`
Replace "REASON" with the exact reason summary I provide to you (maximum 5 words), not with a generic explanation like "checked to be nonnull".
see the example below, for expression `foo.getBar()`, to wrap it with `Nullability.castToNonnull(foo.getBar(), "reason")`.

```java
public t(){
    String l = foo.getBar();
}
```

will be:
```java
public t(){
    String l = Nullability.castToNonnull(foo.getBar(), "checked to be nonnull");
}
```

### Instructions:

Do not import any additional classes.

Do not add Java comments.

Only modify relevant lines as required.

Return only the modified method wrapped in the XML format shown below.

Place the Java code inside the <code> tag using a CDATA block with ```java formatting.

Just give me the fixed code snippet in XML format in <response> tag like the example below. I will apply the fix to my codebase. Do not import any additional libraries or classes or add java comments. If you can provide the fixed code snippet, please provide it in the following format and place the code snippet in the <code> tag within ```java block.
<response>
  <success>true</success>
  <code><![CDATA[
  ```java
  Your fixed code snippet here
  ```
    ]]>
  </code>
</response>

11:53:27.543 TRACE edu.ucr.cs.riple.core.checkers.nullaway.codefix.ChatGPT.ask
Retrieving response from cache
11:53:27.543 TRACE edu.ucr.cs.riple.core.checkers.nullaway.codefix.Response.tryCreate
Trying to create Response:
<response>
  <success>true</success>
  <code><![CDATA[
  ```java
private static void initializeWindowEventListeners(Window window) {

    window.addWindowStateListener(
        e -> {
          if (e.getNewState() == Frame.ICONIFIED) {
            Nullability.castToNonnull(Game.loop(), "initialized by Game.init").setTickRate(ICONIFIED_MAX_FPS);
          } else {
            Game.loop().setTickRate(Game.config().client().getMaxFps());
          }
        });

    window.addWindowFocusListener(
        new WindowFocusListener() {
          @Override
          public void windowLostFocus(WindowEvent e) {
            if (Game.config().graphics().reduceFramesWhenNotFocused()) {
              Game.loop().setTickRate(NONE_FOCUS_MAX_FPS);
            }
          }

          @Override
          public void windowGainedFocus(WindowEvent e) {
            Game.loop().setTickRate(Game.config().client().getMaxFps());
          }
        });

    window.addWindowListener(
        new WindowAdapter() {
          @Override
          public void windowClosing(final WindowEvent event) {
            Game.exit();
          }
        });
}
  ```
    ]]>
  </code>
</response>
11:53:27.543 TRACE edu.ucr.cs.riple.core.checkers.nullaway.codefix.Response.<init>
Creating Response:
<response>
  <success>true</success>
  <code><![CDATA[
  ```java
private static void initializeWindowEventListeners(Window window) {

    window.addWindowStateListener(
        e -> {
          if (e.getNewState() == Frame.ICONIFIED) {
            Nullability.castToNonnull(Game.loop(), "initialized by Game.init").setTickRate(ICONIFIED_MAX_FPS);
          } else {
            Game.loop().setTickRate(Game.config().client().getMaxFps());
          }
        });

    window.addWindowFocusListener(
        new WindowFocusListener() {
          @Override
          public void windowLostFocus(WindowEvent e) {
            if (Game.config().graphics().reduceFramesWhenNotFocused()) {
              Game.loop().setTickRate(NONE_FOCUS_MAX_FPS);
            }
          }

          @Override
          public void windowGainedFocus(WindowEvent e) {
            Game.loop().setTickRate(Game.config().client().getMaxFps());
          }
        });

    window.addWindowListener(
        new WindowAdapter() {
          @Override
          public void windowClosing(final WindowEvent event) {
            Game.exit();
          }
        });
}
  ```
    ]]>
  </code>
</response>
11:53:27.544 TRACE edu.ucr.cs.riple.core.checkers.nullaway.codefix.Response.<init>
Response created:
private static void initializeWindowEventListeners(Window window) {

    window.addWindowStateListener(
        e -> {
          if (e.getNewState() == Frame.ICONIFIED) {
            Nullability.castToNonnull(Game.loop(), "initialized by Game.init").setTickRate(ICONIFIED_MAX_FPS);
          } else {
            Game.loop().setTickRate(Game.config().client().getMaxFps());
          }
        });

    window.addWindowFocusListener(
        new WindowFocusListener() {
          @Override
          public void windowLostFocus(WindowEvent e) {
            if (Game.config().graphics().reduceFramesWhenNotFocused()) {
              Game.loop().setTickRate(NONE_FOCUS_MAX_FPS);
            }
          }

          @Override
          public void windowGainedFocus(WindowEvent e) {
            Game.loop().setTickRate(Game.config().client().getMaxFps());
          }
        });

    window.addWindowListener(
        new WindowAdapter() {
          @Override
          public void windowClosing(final WindowEvent event) {
            Game.exit();
          }
        });
}
11:53:27.544 TRACE edu.ucr.cs.riple.core.checkers.nullaway.codefix.ChatGPT.fixDereferenceByAddingCastToNonnull
Fixing the error by adding castToNonnull
11:53:27.547 TRACE edu.ucr.cs.riple.core.checkers.nullaway.codefix.AdvancedNullAwayCodeFix.fixTriggeredErrorsForLocation
Resolving unresolvable error for triggered error: Type='DEREFERENCE_NULLABLE', message='dereferenced expression Game.loop() is @Nullable'
/home/nima/Developer/nullness-benchmarks/litiengine/src/de/gurkenlabs/litiengine/environment/GameWorld.java:521
      Game.loop().attach(cam);
11:53:27.547 TRACE edu.ucr.cs.riple.core.checkers.nullaway.codefix.AdvancedNullAwayCodeFix.fix
Fixing error: Type='DEREFERENCE_NULLABLE', message='dereferenced expression Game.loop() is @Nullable'
/home/nima/Developer/nullness-benchmarks/litiengine/src/de/gurkenlabs/litiengine/environment/GameWorld.java:521
      Game.loop().attach(cam);
11:53:27.547 TRACE edu.ucr.cs.riple.core.checkers.nullaway.codefix.AdvancedNullAwayCodeFix.resolveDereferenceError
Resolving dereference error: Type='DEREFERENCE_NULLABLE', message='dereferenced expression Game.loop() is @Nullable'
/home/nima/Developer/nullness-benchmarks/litiengine/src/de/gurkenlabs/litiengine/environment/GameWorld.java:521
      Game.loop().attach(cam);
11:53:27.547 TRACE edu.ucr.cs.riple.core.checkers.nullaway.codefix.AdvancedNullAwayCodeFix.resolveDereferenceError
Checking nullability possibility at error point
11:53:27.549 TRACE edu.ucr.cs.riple.core.checkers.nullaway.codefix.ChatGPT.checkNullabilityPossibilityAtErrorPoint
Asking if the expression can be null at error point point
11:53:27.549 TRACE edu.ucr.cs.riple.core.checkers.nullaway.codefix.ChatGPT.ask
Asking ChatGPT:
In the method below, is there a possibility that the expression "Game.loop()" at line "Game.loop().attach(cam);" is null?
public void setCamera(@Nullable final ICamera cam) {
    if (this.camera() != null) {
      Game.loop().detach(camera);
    }

    camera = cam;

    if (cam != null && !Game.isInNoGUIMode()) {
      Game.loop().attach(cam);
      cam.updateFocus();
    }
}
Give a single-word answer in XML format. If it is possible for the expression to be null, respond with:
```xml
<response>
    <reason><![CDATA[YOUR REASON]]></reason>
    <value>YES</value>
</response>
```
If it is not possible for the expression to be null, respond with:
```xml
<response>
    <reason><![CDATA[YOUR REASON]]></reason>
    <value>NO</value>
</response>
```
If you are unsure or need more information, respond with where you can ask for more details or what specific information you need.

If additional information is required, list each request inside a `<request>` tag. If no additional information is needed, omit the `<requests>` section.

Respond with:
```xml
<response>
    <reason><![CDATA[YOUR REASON]]></reason>
    <value>UNKNOWN</value>
    <!-- Include <requests> only if additional information is needed -->
    <requests>
        <request><![CDATA[YOUR REQUEST 1]]></request>
        <request><![CDATA[YOUR REQUEST 2]]></request>
    </requests>
</response>
```
11:53:27.549 TRACE edu.ucr.cs.riple.core.checkers.nullaway.codefix.ChatGPT.ask
Retrieving response from cache
11:53:27.549 TRACE edu.ucr.cs.riple.core.checkers.nullaway.codefix.Response.tryCreate
Trying to create Response:
```xml
<response>
    <reason><![CDATA[The possibility of Game.loop() returning null depends on how the Game class is implemented, which is not provided. Without more information on the Game class and the loop() method implementation, it cannot be determined if Game.loop() might return null.]]></reason>
    <value>UNKNOWN</value>
    <requests>
        <request><![CDATA[Provide the implementation details of the Game class, specifically the loop() method.]]></request>
        <request><![CDATA[Clarify if there are any conditions under which Game.loop() might return null.]]></request>
    </requests>
</response>
```
11:53:27.549 TRACE edu.ucr.cs.riple.core.checkers.nullaway.codefix.Response.<init>
Creating Response:
```xml
<response>
    <reason><![CDATA[The possibility of Game.loop() returning null depends on how the Game class is implemented, which is not provided. Without more information on the Game class and the loop() method implementation, it cannot be determined if Game.loop() might return null.]]></reason>
    <value>UNKNOWN</value>
    <requests>
        <request><![CDATA[Provide the implementation details of the Game class, specifically the loop() method.]]></request>
        <request><![CDATA[Clarify if there are any conditions under which Game.loop() might return null.]]></request>
    </requests>
</response>
```
11:53:27.550 TRACE edu.ucr.cs.riple.core.checkers.nullaway.codefix.Response.<init>
Response created:
Unknown: The possibility of Game.loop() returning null depends on how the Game class is implemented, which is not provided. Without more information on the Game class and the loop() method implementation, it cannot be determined if Game.loop() might return null.
11:53:27.552 TRACE edu.ucr.cs.riple.core.checkers.nullaway.codefix.AdvancedNullAwayCodeFix.resolveMethodDereferenceError
Resolving method dereference error.
11:53:27.552 TRACE edu.ucr.cs.riple.core.checkers.nullaway.codefix.AdvancedNullAwayCodeFix.resolveMethodDereferenceError
Method is in annotated package. Checking if the method is returning nullable.
11:53:27.552 TRACE edu.ucr.cs.riple.core.checkers.nullaway.codefix.AdvancedNullAwayCodeFix.investigateMethodReturnNullability
Checking if the method is returning nullable.
11:53:27.554 TRACE edu.ucr.cs.riple.core.checkers.nullaway.codefix.ChatGPT.checkIfMethodIsReturningNullable
Asking if the method is returning nullable: loop()
11:53:27.556 TRACE edu.ucr.cs.riple.core.checkers.nullaway.codefix.ChatGPT.ask
Asking ChatGPT:
In the method below, is there a possibility that the method returns null based only on its body? Consider the following points:

- The method may have multiple return paths; consider all return statements.
- If the method calls another method, do not assume its return value unless its full declaration is provided. Request its declaration if needed.
- The method may throw an exception instead of returning null. An exception path should not be considered a null return.
- Ensure you request the declarations of any methods whose return values directly or indirectly impact this methods return value before making a conclusion.
- Carefully analyze all conditions and prior operations that may guarantee a non-null return value.

@Nullable public static IGameLoop loop() {
    return gameLoop;
}

Here are the method definitions in addition to the method inquired:

Depth: 0
```java
class de.gurkenlabs.litiengine.Game {
@Nullable public static IGameLoop loop() {
    return gameLoop;
}
}
```


Response Format:
Provide the answer in **XML format** as follows:

#### If the method **cannot** return `null`:
```xml
<response>
  <reason><![CDATA[EXPLAIN WHY THE METHOD CANNOT RETURN NULL]]></reason>
  <value>NO</value>
</response>
```

#### If the method can return null:
```xml
<response>
  <reason><![CDATA[EXPLAIN WHY THE METHOD CAN RETURN NULL]]></reason>
  <value>YES</value>
</response>
```

#### If you are unsure or need more information, respond with where you can ask for more details or what specific information you need.

#### If you are unsure or If there are any methods that directly or indirectly affect the return value and are not fully disclosed, request their declarations first, in the following format:
<response>
  <reason><![CDATA[YOUR REASON]]></reason>
  <value>UNKNOWN</value>
  <methods>
    <method>methodName</method>
  </methods>
</response>

If additional information is required other than method declaration, list each request inside a `<request>` tag. If no additional information is needed, omit the `<requests>` section.

Respond with:
```xml
<response>
    <reason><![CDATA[YOUR REASON]]></reason>
    <value>UNKNOWN</value>
    <!-- Include <requests> only if additional information is needed -->
    <requests>
        <request><![CDATA[YOUR REQUEST 1]]></request>
        <request><![CDATA[YOUR REQUEST 2]]></request>
    </requests>
</response>
```

Additional Notes:
Be precise in your reasoning.
If a methods return value depends on another method not provided, request its declaration before making a conclusion.
If the method can return null in some cases but not others, explain under what conditions it can happen.

11:53:27.556 TRACE edu.ucr.cs.riple.core.checkers.nullaway.codefix.ChatGPT.ask
Retrieving response from cache
11:53:27.556 TRACE edu.ucr.cs.riple.core.checkers.nullaway.codefix.Response.tryCreate
Trying to create Response:
```xml
<response>
  <reason><![CDATA[The method `loop` returns the variable `gameLoop`. Without the initialization or assignment details of `gameLoop`, it's unclear whether it can be null. The possibility of `gameLoop` being uninitialized or set to null elsewhere in the program means `loop` could potentially return null. Further information on `gameLoop` is required.]]></reason>
  <value>UNKNOWN</value>
  <requests>
    <request><![CDATA[Please provide the declaration and initialization of the variable `gameLoop` in the class `de.gurkenlabs.litiengine.Game`.]]></request>
  </requests>
</response>
```
11:53:27.556 TRACE edu.ucr.cs.riple.core.checkers.nullaway.codefix.Response.<init>
Creating Response:
```xml
<response>
  <reason><![CDATA[The method `loop` returns the variable `gameLoop`. Without the initialization or assignment details of `gameLoop`, it's unclear whether it can be null. The possibility of `gameLoop` being uninitialized or set to null elsewhere in the program means `loop` could potentially return null. Further information on `gameLoop` is required.]]></reason>
  <value>UNKNOWN</value>
  <requests>
    <request><![CDATA[Please provide the declaration and initialization of the variable `gameLoop` in the class `de.gurkenlabs.litiengine.Game`.]]></request>
  </requests>
</response>
```
11:53:27.557 TRACE edu.ucr.cs.riple.core.checkers.nullaway.codefix.Response.<init>
Response created:
Unknown: The method `loop` returns the variable `gameLoop`. Without the initialization or assignment details of `gameLoop`, it's unclear whether it can be null. The possibility of `gameLoop` being uninitialized or set to null elsewhere in the program means `loop` could potentially return null. Further information on `gameLoop` is required.
11:53:27.557 TRACE edu.ucr.cs.riple.core.checkers.nullaway.codefix.AdvancedNullAwayCodeFix.investigateMethodReturnNullability
Could not determine the nullability and model did not ask for any method.
11:53:27.557 TRACE edu.ucr.cs.riple.core.checkers.nullaway.codefix.ChatGPT.checkIfMethodIsReturningNullableOnCallSite
Asking if the method is returning nullable on the call site: Game.loop()
11:53:27.795 TRACE edu.ucr.cs.riple.core.checkers.nullaway.codefix.ChatGPT.ask
Asking ChatGPT:
In the method below, is there a possibility that the method returns null at the given call site?

```java
@Nullable public static IGameLoop loop() {
    return gameLoop;
}
```

## Guidelines:
- The method may have multiple return paths; consider all return statements.
- If the method calls another method, do not assume its return value unless its full declaration is provided. Request its declaration if needed.
- The method may throw an exception instead of returning null. An exception path should not be considered a null return.
- Ensure you request the declarations of any methods whose return values directly or indirectly impact this methods return value before making a conclusion.
- If the method returns a value that is determined by a parameter, evaluate based on the actual argument at the given call site.
- Analyze based only on the specific invocation provided. Do not generalize to all possible inputs.- If the return value is guaranteed to be non-null at the call site, the answer should be a definitive NO.
- Do not generalize based on all possible inputsyour answer must be based only on the given invocation.
- Focus only on the given call site, not all possible invocations.

### call site:
Game.loop()

Here are the method definitions and the call chain for this method, showing the sequence of calls from the method to its callers at each depth level:

Depth: 0
```java
class de.gurkenlabs.litiengine.Game {
@Nullable public static IGameLoop loop() {
    return gameLoop;
}
}
```
Depth: 1
```java
class de.gurkenlabs.litiengine.environment.GameWorld {
public void loadEnvironment(@Nullable final Environment env) {
    Lock lock = Game.loop().getLock();
    lock.lock();
    try {
      unloadEnvironment();
      this.environment = env;
      if (env != null) {
        this.addEnvironment(env);

        if (env.getGravity() == 0 && this.gravity() != 0) {
          env.setGravity(this.gravity());
        }

        env.load();
        for (final EnvironmentLoadedListener listener : this.loadedListeners) {
          listener.loaded(env);
        }

        // call map specific listeners
        String mapName = getMapName(env);
        if (mapName != null && this.environmentLoadedListeners.containsKey(mapName)) {

          // for the default camera we center the camera on the environment
          if (this.camera().getClass().equals(Camera.class)) {
            camera().setFocus(env.getCenter());
          }

          for (EnvironmentLoadedListener listener : this.environmentLoadedListeners.get(mapName)) {
            listener.loaded(env);
          }
        }
      }
    } finally {
      lock.unlock();
    }
}public void setCamera(@Nullable final ICamera cam) {
    if (this.camera() != null) {
      Game.loop().detach(camera);
    }

    camera = cam;

    if (cam != null && !Game.isInNoGUIMode()) {
      Game.loop().attach(cam);
      cam.updateFocus();
    }
}
}
```
```java
class de.gurkenlabs.litiengine.entities.behavior.EntityNavigator {
public EntityNavigator(final IMobileEntity entity, final PathFinder pathFinder) {
    this.cancelNavigationConditions = new CopyOnWriteArrayList<>();
    this.listeners = new CopyOnWriteArrayList<>();
    this.entity = entity;
    this.pathFinder = pathFinder;
    this.setAcceptableError(DEFAULT_ACCEPTABLE_ERROR);
    Game.loop().attach(this);
}
}
```
```java
class de.gurkenlabs.litiengine.GameWindow {
private static void initializeWindowEventListeners(Window window) {
  
      window.addWindowStateListener(
          e -> {
            if (e.getNewState() == Frame.ICONIFIED) {
              Nullability.castToNonnull(Game.loop(), "initialized by Game.init").setTickRate(ICONIFIED_MAX_FPS);
            } else {
              Game.loop().setTickRate(Game.config().client().getMaxFps());
            }
          });
  
      window.addWindowFocusListener(
          new WindowFocusListener() {
            @Override
            public void windowLostFocus(WindowEvent e) {
              if (Game.config().graphics().reduceFramesWhenNotFocused()) {
                Game.loop().setTickRate(NONE_FOCUS_MAX_FPS);
              }
            }
  
            @Override
            public void windowGainedFocus(WindowEvent e) {
              Game.loop().setTickRate(Game.config().client().getMaxFps());
            }
          });
  
      window.addWindowListener(
          new WindowAdapter() {
            @Override
            public void windowClosing(final WindowEvent event) {
              Game.exit();
            }
          });
}
}
```
```java
class de.gurkenlabs.litiengine.gui.screens.ScreenManager {
public void display(@Nullable final Screen screen) {
      if (Game.hasStarted() && Game.time().since(this.lastScreenChange) < this.getChangeCooldown()) {
        log.log(
            Level.INFO,
            "Skipping displaying of screen {0} because screen changing is currently on cooldown.",
            screen != null ? screen.getName() : "");
        return;
      }
  
      final Screen previous = this.current();
      if (previous != null) {
        previous.suspend();
      }
  
      if (screen != null && !this.screens.contains(screen)) {
        this.screens.add(screen);
      }
  
      this.currentScreen = screen;
      if (!Game.isInNoGUIMode() && this.current() != null) {
        this.current().prepare();
      }
  
      this.lastScreenChange = Nullability.castToNonnull(Game.loop(), "initialized before usage").getTicks();
  
      final ScreenChangedEvent event = new ScreenChangedEvent(this.current(), previous);
      for (final ScreenChangedListener listener : this.screenChangedListeners) {
        listener.changed(event);
      }
}
}
```
```java
class de.gurkenlabs.litiengine.abilities.effects.Effect {
@Override
  public void update() {

    for (final Iterator<EffectApplication> iterator = this.getActiveAppliances().iterator();
        iterator.hasNext(); ) {
      final EffectApplication appliance = iterator.next();
      // if the effect duration is reached
      if (this.hasEnded(appliance)) {

        iterator.remove();
        this.cease(appliance);
      }
    }

    // 4. unregister if all appliances are finished
    if (this.getActiveAppliances().isEmpty()) {
      Game.loop().detach(this);
    }
}public void apply(final Shape impactArea) {
    final List<ICombatEntity> affected = this.lookForAffectedEntities(impactArea);
    for (final ICombatEntity affectedEntity : affected) {
      this.apply(affectedEntity);
    }

    this.appliances.add(new EffectApplication(affected, impactArea));

    // if it is the first appliance -> register for update
    if (this.appliances.size() == 1) {
      Game.loop().attach(this);
    }
}
}
```
```java
class de.gurkenlabs.litiengine.GameTime {
public long toTicks(final int milliseconds) {
    return this.toTicks(milliseconds, Game.loop().getTickRate());
}public long since(final long tick) {
    return toMilliseconds(Game.loop().getTicks() - tick);
}public long now() {
    return Game.loop().getTicks();
}public long sinceGameStart() {
    return this.toMilliseconds(Game.loop().getTicks());
}@Override
    public void loaded(Environment environment) {
      environmentLoaded = Nullability.castToNonnull(Game.loop(), "properly initialized and started").getTicks();
}public long toMilliseconds(final long ticks) {
    return this.toMilliseconds(ticks, Game.loop().getTickRate());
}
}
```
```java
class de.gurkenlabs.litiengine.GameMetrics {
@Override
    public void render(final Graphics2D g) {
      this.updateMetrics();
  
      if (!Game.config().client().showGameMetrics()) {
        return;
      }
  
      this.currentOffsetY = 0;
  
      g.setColor(this.renderColor);
  
      // render client metrics
      this.drawTitle(g, "[client]");
      this.drawMetric(g, "fps       : " + this.getFramesPerSecond());
      this.drawMetric(g, "max fps   : " + this.maxFramesPerSecond);
  
      // Use Nullability.castToNonnull to prevent NullAway warning
      this.drawMetric(g, "updatables: " + Nullability.castToNonnull(Game.loop(), "gameLoop always initialized").getUpdatableCount());
  
      // render jvm metrics if debug is enabled
      if (Game.config().debug().isDebugEnabled()) {
        this.drawTitle(g, "[jvm]");
        this.drawMetric(g, "java      : " + this.javaVersion);
        this.drawMetric(g, "memory    : " + String.format("%-5.5s", this.usedMemory) + " MB");
        this.drawMetric(g, "threads   : " + Thread.activeCount());
      }
  
      // render rendering metrics
      if (!this.renderMetrics.isEmpty()) {
        this.drawTitle(g, "[update]");
  
        for (RenderMetrics metric : this.renderMetrics) {
          this.drawMetric(g, metric.toString());
        }
  
        this.renderMetrics.clear();
      }
}
}
```
```java
class de.gurkenlabs.litiengine.graphics.emitters.Emitter {
public void deactivate() {
    if (!this.activated) {
      return;
    }

    this.activated = false;
    this.getParticles().clear();
    this.aliveTime = 0;
    this.activationTick = 0;
    this.lastSpawn = 0;
    Game.loop().detach(this);
}public void activate() {
    if (this.activated) {
      return;
    }

    this.activated = true;
    this.activationTick = Game.time().now();
    Game.loop().attach(this);
}@Override
  public void update() {
    if (this.isPaused()) {
      return;
    }

    // clear particles if the effect time to life is reached
    if (this.isFinished()) {
      for (EmitterFinishedListener listener : this.finishedListeners) {
        listener.finished(this);
      }

      this.delete();
      return;
    }

    final float updateRatio = (float) this.data().getUpdateRate() / Game.loop().getTickRate();
    for (final Particle p : this.getParticles().stream().collect(Collectors.toList())) {
      if (this.particleCanBeRemoved(p)) {
        // remove dead particles
        this.particles.remove(p);
        continue;
      }

      p.update(this.getOrigin(), updateRatio);
    }

    this.aliveTime = Game.time().since(this.activationTick);
    if ((this.data().getSpawnRate() == 0
        || Game.time().since(this.lastSpawn) >= this.data().getSpawnRate())) {
      this.lastSpawn = Game.time().now();
      this.spawnParticle();
    }
}
}
```
```java
class de.gurkenlabs.litiengine.entities.behavior.IBehaviorController {
public default void attach() {
    Game.loop().attach(this);
}public default void detach() {
    Game.loop().detach(this);
}
}
```
```java
class de.gurkenlabs.litiengine.abilities.AbilityExecution {
AbilityExecution(final Ability ability) {
        this.appliedEffects = new CopyOnWriteArrayList<>();
        this.ability = ability;
        this.executionTicks = Game.time().now();
        this.impactArea = ability.calculateImpactArea();
        this.castLocation = ability.getExecutor().getCenter();
        Nullability.castToNonnull(Game.loop(), "proper initialization done").attach(this);
}@Override
  public void update() {
    // if there a no effects to apply -> unregister this instance and we're done
    if (this.getAbility().getEffects().isEmpty()
        || this.getAbility().getEffects().size() == this.getAppliedEffects().size()) {
      Game.loop().detach(this);
      return;
    }

    // handle all effects from the ability that were not applied yet
    for (final Effect effect : this.getAbility().getEffects()) {
      // if the ability was not executed yet or the delay of the effect is not
      // yet reached
      if (this.getAppliedEffects().contains(effect)
          || Game.time().since(this.getExecutionTicks()) < effect.getDelay()) {
        continue;
      }

      effect.apply(this.getExecutionImpactArea());
      this.getAppliedEffects().add(effect);
    }
}
}
```
```java
class de.gurkenlabs.litiengine.GameWindow$3 {
@Override
            public void windowGainedFocus(WindowEvent e) {
              Game.loop().setTickRate(Game.config().client().getMaxFps());
}@Override
            public void windowLostFocus(WindowEvent e) {
              if (Game.config().graphics().reduceFramesWhenNotFocused()) {
                Game.loop().setTickRate(NONE_FOCUS_MAX_FPS);
              }
}
}
```
```java
class de.gurkenlabs.litiengine.environment.EntitySpawner {
protected void spawnNewEntities() {
    if (this.getSpawnMode() != SpawnMode.CUSTOMSPAWNPOINTS && this.getSpawnPoints().isEmpty()) {
      return;
    }

    switch (this.getSpawnMode()) {
      case ALLSPAWNPOINTS:
        for (int i = 0; i < this.getSpawnPoints().size(); i++) {
          final int index = i;
          Game.loop()
              .perform(
                  this.getSpawnDelay() + this.getSpawnDelay() * i,
                  () -> this.spawn(this.getSpawnPoints().get(index), this.getSpawnAmount()));
        }
        break;
      case ONERANDOMSPAWNPOINT:
        this.spawn(Game.random().choose(this.getSpawnPoints()), this.getSpawnAmount());
        break;
      case RANDOMSPAWNPOINTS:
        for (int i = 0; i < this.getSpawnAmount(); i++) {
          Game.loop()
              .perform(
                  this.getSpawnDelay() + this.getSpawnDelay() * i,
                  () -> this.spawn(Game.random().choose(this.getSpawnPoints()), 1));
        }
        break;
      case CUSTOMSPAWNPOINTS:
        List<Spawnpoint> spawnPoints =
            this.customSpawnpoints != null
                ? this.customSpawnpoints.apply(this)
                : this.getCustomSpawnpoints();

        int index = 0;
        for (Spawnpoint spawn : spawnPoints) {
          Game.loop()
              .perform(
                  this.getSpawnDelay() + this.getSpawnDelay() * index, () -> this.spawn(spawn, 1));
          index++;
        }
        break;
      default:
        break;
    }
}
}
```
```java
class de.gurkenlabs.litiengine.tweening.TweenEngine {
@Override
  public void start() {
    Game.loop().attach(this);
}@Override
  public void terminate() {
    Game.loop().detach(this);
}
}
```
```java
class de.gurkenlabs.litiengine.gui.SpeechBubble {
public void hide() {
    Game.world().environment().removeRenderable(this);
    Game.loop().detach(this);
    if (activeSpeechBubbles.get(this.getEntity()) != null
        && activeSpeechBubbles.remove(this.getEntity()).equals(this)) {
      activeSpeechBubbles.remove(this.getEntity());
    }

    for (SpeechBubbleListener listener : this.listeners) {
      listener.hidden();
    }
}private SpeechBubble(
      final IEntity entity,
      final String text,
      @Nullable SpeechBubbleAppearance appearance,
      @Nullable Font font) {
    if (appearance == null) {
      this.appearance = DEFAULT_APPEARANCE;
    } else {
      this.appearance = appearance;
    }

    final SpeechBubble active = activeSpeechBubbles.get(entity);
    if (active != null) {
      active.hide();
    }
    this.setFont(font);

    this.textBoxWidth = (float) (entity.getWidth() * 4);
    this.entity = entity;

    this.currentText = text;
    this.currentTextDisplayTime = DISPLAYTIME_MIN + text.length() * DISPLAYTIME_PER_LETTER;

    this.lastTextDisplay = Game.time().now();
    this.createBubbleImage();
    entity.getEnvironment().add(this, RenderType.UI);
    Game.loop().attach(this);
    activeSpeechBubbles.put(entity, this);
}
}
```
```java
class de.gurkenlabs.litiengine.entities.Prop {
private void updateAnimationController() {
    IEntityAnimationController<?> controller = this.createAnimationController();
    this.getControllers().addController(controller);
    if (Game.world().environment() != null && Game.world().environment().isLoaded()) {
      Game.loop().attach(controller);
    }
}
}
```
```java
class de.gurkenlabs.litiengine.graphics.FreeFlightCamera {
public FreeFlightCamera(final Point2D focus) {
    this.setFocus(focus);
    this.velocity = DEFAULT_SCROLL_PIXELS_PER_SECOND;
    this.scrollPadding = DEFAULT_SCROLL_PADDING;
    this.setClampToMap(true);

    Game.loop().attach(this);
}private void handleFreeFlightCamera() {
      if (Game.world().environment() == null || Game.world().environment().getMap() == null) {
        return;
      }
  
      final Point2D mouseLocation = Input.mouse().getLocation();
  
      final double scrollSpeed =
          this.getVelocity()
              / (double) Nullability.castToNonnull(Game.loop(), "gameLoop always initialized")
                  .getTickRate()
              * Game.config().input().getMouseSensitivity();
  
      double x = this.getFocus().getX();
      double y = this.getFocus().getY();
  
      double deltaX = 0;
      if (mouseLocation.getX() < this.getScrollPadding()) {
        deltaX -= scrollSpeed;
      } else if (Game.window().getResolution().getWidth() - mouseLocation.getX()
          < this.getScrollPadding()) {
        deltaX += scrollSpeed;
      }
  
      double deltaY = 0;
      if (mouseLocation.getY() < this.getScrollPadding()) {
        deltaY -= scrollSpeed;
      } else if (Game.window().getResolution().getHeight() - mouseLocation.getY()
          < this.getScrollPadding()) {
        deltaY += scrollSpeed;
      }
  
      x += deltaX;
      y += deltaY;
  
      this.setFocus(new Point2D.Double(x, y));
}
}
```
```java
class de.gurkenlabs.litiengine.environment.Environment {
private static void dispose(final Collection<? extends IEntity> entities) {
    for (final IEntity entity : entities) {
      if (entity instanceof IUpdateable) {
        Game.loop().detach((IUpdateable) entity);
      }

      entity.detachControllers();
    }
}private static void loadUpdatableOrEmitterEntity(IEntity entity) {
      if (entity instanceof Emitter) {
        final Emitter emitter = (Emitter) entity;
        if (emitter.isActivateOnInit()) {
          emitter.activate();
        }
      } else if (entity instanceof IUpdateable) {
        Nullability.castToNonnull(Game.loop(), "initialized through init").attach((IUpdateable) entity);
      }
}private void unload(final IEntity entity) {
    // 1. remove from physics engine
    if (entity instanceof ICollisionEntity) {
      Game.physics().remove((ICollisionEntity) entity);
    }

    // 2. unregister from update
    if (entity instanceof IUpdateable) {
      Game.loop().detach((IUpdateable) entity);
    }

    if (entity instanceof IMobileEntity) {
      this.removeGravity((IMobileEntity) entity);
    }

    // 3. detach all controllers
    entity.detachControllers();

    if (entity instanceof Emitter) {
      Emitter em = (Emitter) entity;
      em.deactivate();
    }

    if (this.loaded && (entity instanceof LightSource || entity instanceof StaticShadow)) {
      this.updateLighting(entity);
    }

    entity.removed(this);
}
}
```
```java
class de.gurkenlabs.litiengine.graphics.animation.Animation {
@Override
  public void update() {
    // do nothing if the animation is not playing or the current keyframe is not finished
    if (!this.isPlaying()
        || Game.time().since(this.lastFrameUpdate) < this.getCurrentKeyFrame().getDuration()) {
      return;
    }

    // if we are not looping and the last keyframe is finished, we terminate the animation
    if (!this.isLooping() && this.isLastKeyFrame()) {
      this.terminate();
      return;
    }

    // make sure, we stay inside the keyframe list
    final int newFrameIndex =
        (this.getKeyframes().indexOf(this.currentFrame) + 1) % this.getKeyframes().size();
    final KeyFrame previousFrame = this.currentFrame;
    this.currentFrame = this.getKeyframes().get(newFrameIndex);

    for (KeyFrameListener listener : this.listeners) {
      listener.currentFrameChanged(previousFrame, this.currentFrame);
    }

    this.lastFrameUpdate = Game.loop().getTicks();
}public void restart() {
    this.currentFrame = this.firstFrame;
    this.lastFrameUpdate = Game.loop().getTicks();
}
}
```
```java
class de.gurkenlabs.litiengine.physics.MovementController {
@Override
    public void attach() {
      Nullability.castToNonnull(Game.loop(), "properly initialized before use").attach(this);
}private void handleForces() {
    // clean up forces
    this.activeForces.forEach(
        x -> {
          if (x.hasEnded()) {
            this.activeForces.remove(x);
          }
        });

    if (this.activeForces.isEmpty()) {
      return;
    }

    // disable turn-on-move for force handling
    boolean turn = this.getEntity().turnOnMove();
    this.getEntity().setTurnOnMove(false);
    try {
      double deltaX = 0;
      double deltaY = 0;
      for (final Force force : this.activeForces) {
        if (force.cancelOnReached() && force.hasReached(this.getEntity())) {
          force.end();
          continue;
        }

        final Point2D collisionBoxCenter = this.getEntity().getCollisionBoxCenter();
        final double angle =
            GeometricUtilities.calcRotationAngleInDegrees(collisionBoxCenter, force.getLocation());
        final double strength =
            Game.loop().getDeltaTime() * 0.001f * force.getStrength() * Game.loop().getTimeScale();
        deltaX += GeometricUtilities.getDeltaX(angle, strength);
        deltaY += GeometricUtilities.getDeltaY(angle, strength);
      }

      final Point2D target =
          new Point2D.Double(this.getEntity().getX() + deltaX, this.getEntity().getY() + deltaY);
      final boolean success = Game.physics().move(this.getEntity(), target);
      if (!success) {
        for (final Force force : this.activeForces) {
          if (force.cancelOnCollision()) {
            force.end();
          }
        }
      }
    } finally {
      this.getEntity().setTurnOnMove(turn);
    }
}@Override
  public void detach() {
    Game.loop().detach(this);
}public void handleMovement() {
    if (!this.isMovementAllowed()) {
      this.velocity = 0;
      return;
    }

    // max distance an entity can travel within one tick
    final double maxPixelsPerTick = this.getEntity().getTickVelocity();
    final double deltaTime = Game.loop().getDeltaTime() * Game.loop().getTimeScale();

    final double acceleration =
        this.getEntity().getAcceleration() == 0
            ? maxPixelsPerTick
            : deltaTime / this.getEntity().getAcceleration() * maxPixelsPerTick;
    final double deceleration =
        this.getEntity().getDeceleration() == 0
            ? this.getVelocity()
            : deltaTime / this.getEntity().getDeceleration() * maxPixelsPerTick;

    double dx = this.getDx();
    double dy = this.getDy();
    this.setDx(0);
    this.setDy(0);

    final double deltaVelocity =
        Math.min(Math.sqrt(Math.pow(dx, 2) + Math.pow(dy, 2)), acceleration);
    if (deltaVelocity != 0) {
      double newVelocity = this.getVelocity() + deltaVelocity;
      this.setVelocity(newVelocity);
    } else {
      final double newVelocity = Math.max(0, this.getVelocity() - deceleration);
      this.setVelocity(newVelocity);
      dx = GeometricUtilities.getDeltaX(this.moveAngle);
      dy = GeometricUtilities.getDeltaY(this.moveAngle);
    }

    if (this.getVelocity() == 0) {
      this.moveAngle = 0;
      return;
    }

    // actually move entity
    this.moveEntity(dx, dy);
}
}
```
```java
class de.gurkenlabs.litiengine.graphics.animation.AnimationController {
public void detach() {
    Game.loop().detach(this);
}public void attach() {
    Game.loop().attach(this);
}
}
```
```java
class de.gurkenlabs.litiengine.graphics.Camera {
@Override
  public void setZoom(final float targetZoom, final int delay) {
    if (delay == 0) {

      this.zoom = targetZoom;
      this.targetZoom = 0;
      this.zoomDelay = 0;
      this.zoomTick = 0;
      this.zoomStep = 0;

      final ZoomChangedEvent event = new ZoomChangedEvent(this, targetZoom);
      for (final ZoomChangedListener listener : this.zoomListeners) {
        listener.zoomChanged(event);
      }
    } else {
      this.zoomTick = Game.time().now();
      this.targetZoom = targetZoom;
      this.zoomDelay = delay;

      final double tickduration = 1000 / (double) Game.loop().getTickRate();
      final double tickAmount = delay / tickduration;
      final float totalDelta = this.targetZoom - this.zoom;
      this.zoomStep = tickAmount > 0 ? (float) (totalDelta / tickAmount) : totalDelta;
    }
}
}
```
```java
class de.gurkenlabs.litiengine.Game {
public static synchronized void init(String... args) {
    if (initialized) {
      log().log(Level.INFO, "The game has already been initialized.");
      return;
    }

    log.init();
    handleCommandLineArguments(args);

    config().load();
    Locale.setDefault(new Locale(config().client().getCountry(), config().client().getLanguage()));

    gameLoop = new GameLoop("Main Update Loop", config().client().getMaxFps());
    loop().attach(physics());
    loop().attach(world());

    // setup default exception handling for render and update loop
    setUncaughtExceptionHandler(
        new DefaultUncaughtExceptionHandler(config().client().exitOnError()));

    screenManager = new ScreenManager();
    gameWindow = new GameWindow();

    // initialize  the game window
    window().init();
    world.setCamera(new Camera());

    for (GameListener listener : gameListeners) {
      listener.initialized(args);
    }

    if (!isInNoGUIMode()) {
      window().getRenderComponent().onRendered(g -> metrics().render(g));

      graphics()
          .addEntityRenderedListener(
              e -> DebugRenderer.renderEntityDebugInfo(e.getGraphics(), e.getEntity()));

      window().getRenderComponent().onFpsChanged(fps -> metrics().setFramesPerSecond(fps));
      window()
          .setIcons(
              Arrays.asList(
                  Resources.images().get("liti-logo-x16.png"),
                  Resources.images().get("liti-logo-x20.png"),
                  Resources.images().get("liti-logo-x32.png"),
                  Resources.images().get("liti-logo-x48.png")));

      Input.keyboard()
          .onKeyTyped(
              KeyEvent.VK_PRINTSCREEN,
              key -> {
                // don't take a screenshot if a modifier is active
                if (key.getModifiers() != 0) {
                  return;
                }

                window().getRenderComponent().takeScreenshot();
              });
    }

    Runtime.getRuntime().addShutdownHook(new Thread(Game::terminate, "Shutdown"));

    initialized = true;
}
}
```
```java
class de.gurkenlabs.litiengine.entities.Creature {
protected void updateAnimationController() {
        IEntityAnimationController<?> controller = this.createAnimationController();
        this.getControllers().addController(controller);
        if (Game.world().environment() != null && Game.world().environment().isLoaded()) {
            Nullability.castToNonnull(Game.loop(), "expected to be non-null").attach(controller);
        }
}@Override
  public float getTickVelocity() {
    // pixels per ms multiplied by the passed ms
    // ensure that entities don't travel too far in case of lag
    return Math.min(Game.loop().getDeltaTime(), GameLoop.TICK_DELTATIME_LAG)
        * 0.001F
        * this.getVelocity().get()
        * Game.loop().getTimeScale();
}
}
```
Depth: 2
```java
class de.gurkenlabs.litiengine.environment.GameWorld {
public void clear() {
    this.unloadEnvironment();
    this.environments.clear();
    this.setCamera(null);
    Game.physics().clear();

    this.environmentListeners.clear();
    this.environmentLoadedListeners.clear();
    this.environmentUnloadedListeners.clear();

    this.listeners.clear();
    this.loadedListeners.clear();
    this.unloadedListeners.clear();
}@Nullable
  public Environment loadEnvironment(IMap map) {
    Environment env = this.getEnvironment(map);
    this.loadEnvironment(env);
    return env;
}@Nullable
  public Environment loadEnvironment(String mapName) {
    Environment env = this.getEnvironment(mapName);
    this.loadEnvironment(env);
    return env;
}
}
```
```java
class de.gurkenlabs.litiengine.GameWindow {
GameWindow() {
    this.hostControl = new JFrame();

    this.resolutionChangedListeners = new CopyOnWriteArrayList<>();

    this.renderCanvas = new RenderComponent(Game.config().graphics().getResolution());
    this.cursor = new MouseCursor();
    if (!Game.isInNoGUIMode()) {
      this.hostControl.setBackground(Color.BLACK);
      this.hostControl.add(this.renderCanvas);

      this.initializeEventListeners();

      this.hostControl.setTitle(Game.info().getTitle());
      this.hostControl.setDefaultCloseOperation(WindowConstants.DO_NOTHING_ON_CLOSE);
      initializeWindowEventListeners(this.hostControl);
    }
}
}
```
```java
class de.gurkenlabs.litiengine.GameTime {
public long sinceEnvironmentLoad() {
    return this.since(this.environmentLoaded);
}public long since(final long tick) {
    return toMilliseconds(Game.loop().getTicks() - tick);
}public long sinceGameStart() {
    return this.toMilliseconds(Game.loop().getTicks());
}
}
```
```java
class de.gurkenlabs.litiengine.abilities.effects.Effect {
protected void cease(final EffectApplication appliance) {
    // 1. cease the effect for all affected entities
    for (final ICombatEntity entity : appliance.getAffectedEntities()) {
      this.cease(entity);
    }

    // 2. apply follow up effects
    this.getFollowUpEffects().forEach(followUp -> followUp.apply(appliance.getImpactArea()));
}protected boolean hasEnded(final EffectApplication appliance) {
    final long effectDuration = Game.time().since(appliance.getAppliedTicks());
    return effectDuration > this.getDuration();
}
}
```
```java
class de.gurkenlabs.litiengine.abilities.effects.EffectApplication {
protected EffectApplication(final List<ICombatEntity> affectedEntities, final Shape impactArea) {
    this.applied = Game.time().now();
    this.affectedEntities = affectedEntities;
    this.impactArea = impactArea;
}
}
```
```java
class de.gurkenlabs.litiengine.entities.CombatEntity {
@Override
  public boolean wasHit(int timeSpan) {
    return Game.time().since(this.lastHit) < timeSpan;
}@Override
  public void hit(final int damage, @Nullable final Ability ability) {
    if (this.isDead()) {
      return;
    }

    if (!this.isIndestructible()) {
      this.getHitPoints().modifyBaseValue(new AttributeModifier<>(Modification.SUBTRACT, damage));
    }

    final EntityHitEvent event = new EntityHitEvent(this, ability, damage, this.isDead());

    for (final CombatEntityListener listener : this.listeners) {
      listener.hit(event);
    }

    for (final CombatEntityHitListener listener : this.hitListeners) {
      listener.hit(event);
    }

    if (this.isDead()) {
      this.fireDeathEvent();
      this.setCollision(false);
    }

    this.lastHit = Game.time().now();
}
}
```
```java
class de.gurkenlabs.litiengine.graphics.ImageEffect {
protected ImageEffect(final int ttl, final String name) {
    this.ttl = ttl;
    this.name = name;
    this.aliveTick = Game.time().now();
}@Override
  public long getAliveTime() {
    return Game.time().since(this.aliveTick);
}
}
```
```java
class de.gurkenlabs.litiengine.abilities.AbilityExecution {
AbilityExecution(final Ability ability) {
        this.appliedEffects = new CopyOnWriteArrayList<>();
        this.ability = ability;
        this.executionTicks = Game.time().now();
        this.impactArea = ability.calculateImpactArea();
        this.castLocation = ability.getExecutor().getCenter();
        Nullability.castToNonnull(Game.loop(), "proper initialization done").attach(this);
}@Override
  public void update() {
    // if there a no effects to apply -> unregister this instance and we're done
    if (this.getAbility().getEffects().isEmpty()
        || this.getAbility().getEffects().size() == this.getAppliedEffects().size()) {
      Game.loop().detach(this);
      return;
    }

    // handle all effects from the ability that were not applied yet
    for (final Effect effect : this.getAbility().getEffects()) {
      // if the ability was not executed yet or the delay of the effect is not
      // yet reached
      if (this.getAppliedEffects().contains(effect)
          || Game.time().since(this.getExecutionTicks()) < effect.getDelay()) {
        continue;
      }

      effect.apply(this.getExecutionImpactArea());
      this.getAppliedEffects().add(effect);
    }
}
}
```
```java
class de.gurkenlabs.litiengine.tweening.TweenEngine {
@Override
  public void update() {
    for (final Tweenable target : this.getTweens().keySet()) {
      for (final Tween tween : this.getTweens().get(target).values()) {
        if (tween.hasStopped()) {
          continue;
        }
        final long elapsed = Game.time().since(tween.getStartTime());
        if (elapsed >= tween.getDuration()) {
          tween.stop();
          continue;
        }
        final float[] currentValues = new float[tween.getTargetValues().length];
        for (int i = 0; i < tween.getTargetValues().length; i++) {
          currentValues[i] =
              tween.getStartValues()[i]
                  + tween.getEquation().compute(elapsed / (float) tween.getDuration())
                      * (tween.getTargetValues()[i] - tween.getStartValues()[i]);
        }
        tween.getTarget().setTweenValues(tween.getType(), currentValues);
      }
    }
}
}
```
```java
class de.gurkenlabs.litiengine.gui.SpeechBubble {
public static SpeechBubble create(
      final IEntity entity, final String text, SpeechBubbleAppearance appearance, Font font) {
    return new SpeechBubble(entity, text, appearance, font);
}public static SpeechBubble create(final IEntity entity, final Font font, final String text) {
    SpeechBubbleAppearance app =
        new SpeechBubbleAppearance(
            DEFAULT_APPEARANCE.getForeColor(),
            DEFAULT_APPEARANCE.getBackgroundColor1(),
            DEFAULT_APPEARANCE.getBorderColor(),
            DEFAULT_APPEARANCE.getPadding());
    return new SpeechBubble(entity, text, app, font);
}public static SpeechBubble create(final IEntity entity, final String text) {
    return new SpeechBubble(entity, text, null, GuiProperties.getDefaultFont());
}@Override
  public void update() {
    if (this.currentText == null) {
      this.hide();
      return;
    }

    this.entityCenter = Game.world().camera().getViewportLocation(this.getEntity().getCenter());

    // old text was displayed long enough
    if (this.lastTextDisplay != 0
        && Game.time().since(this.lastTextDisplay) > this.currentTextDisplayTime) {
      this.currentText = null;
      this.lastTextDisplay = 0;
      return;
    }

    // display new text
    if (this.textIndex < this.currentText.length()
        && Game.time().since(this.lastCharPoll) > LETTER_WRITE_DELAY) {
      this.textIndex++;
      this.lastCharPoll = Game.time().now();
      if (this.typeSound != null) {
        Game.audio().playSound(this.typeSound, this.getEntity());
      }
    }

    // continue displaying currently displayed text
}private SpeechBubble(
      final IEntity entity,
      final String text,
      final Sound typeSound,
      SpeechBubbleAppearance appearance,
      Font font) {
    this(entity, text, appearance, font);
    this.typeSound = typeSound;
}private SpeechBubble(
      final IEntity entity,
      final String text,
      @Nullable SpeechBubbleAppearance appearance,
      @Nullable Font font) {
    if (appearance == null) {
      this.appearance = DEFAULT_APPEARANCE;
    } else {
      this.appearance = appearance;
    }

    final SpeechBubble active = activeSpeechBubbles.get(entity);
    if (active != null) {
      active.hide();
    }
    this.setFont(font);

    this.textBoxWidth = (float) (entity.getWidth() * 4);
    this.entity = entity;

    this.currentText = text;
    this.currentTextDisplayTime = DISPLAYTIME_MIN + text.length() * DISPLAYTIME_PER_LETTER;

    this.lastTextDisplay = Game.time().now();
    this.createBubbleImage();
    entity.getEnvironment().add(this, RenderType.UI);
    Game.loop().attach(this);
    activeSpeechBubbles.put(entity, this);
}
}
```
```java
class de.gurkenlabs.litiengine.gui.TextFieldComponent {
@Override
  public void render(final Graphics2D g) {
    super.render(g);
    g.setFont(this.getFont());
    final FontMetrics fm = g.getFontMetrics();

    if (this.isSelected() && Game.time().since(this.lastToggled) > this.flickerDelay) {
      this.cursorVisible = !this.cursorVisible;
      this.lastToggled = Game.time().now();
    }
    if (this.isSelected() && this.cursorVisible) {
      final Rectangle2D cursor =
          new Rectangle2D.Double(
              this.getX() + this.getTextX() + fm.stringWidth(this.getTextToRender(g)),
              this.getY() + this.getTextY(),
              this.getFont().getSize2D() * 3 / 5,
              this.getFont().getSize2D() * 1 / 5);
      g.setColor(this.getAppearance().getForeColor());
      g.fill(cursor);
    }
}
}
```
```java
class de.gurkenlabs.litiengine.entities.Prop {
public Prop(
      final Point2D location, @Nullable final String spritesheetName, final Material material) {
    super();
    this.rotation = Rotation.NONE;
    this.spritesheetName = spritesheetName;
    this.material = material;
    this.setLocation(location);
    this.updateAnimationController();
}public void setSpritesheetName(@Nullable final String spriteName) {
    this.spritesheetName = spriteName;
    this.updateAnimationController();
}
}
```
```java
class de.gurkenlabs.litiengine.tweening.Tween {
public Tween begin() {
    this.started = Game.time().now();
    this.stopped = false;
    return this;
}
}
```
```java
class de.gurkenlabs.litiengine.graphics.emitters.particles.Particle {
public void update(final Point2D emitterOrigin, final float updateRatio) {
    if (this.aliveTick == 0) {
      this.aliveTick = Game.time().now();
    }

    this.aliveTime = Game.time().since(this.aliveTick);
    if (this.timeToLiveReached()) {
      return;
    }

    if (this.colliding) {
      return;
    }

    if (this.getDeltaWidth() != 0) {
      this.width += this.getDeltaWidth() * updateRatio;
    }

    if (this.getDeltaHeight() != 0) {
      this.height += this.getDeltaHeight() * updateRatio;
    }

    if (this.getDeltaAngle() != 0) {
      this.angle += this.getDeltaAngle() * updateRatio;
    }

    // test for ray cast collision
    final float targetX = this.x + this.getVelocityX() * updateRatio;
    final float targetY = this.y + this.getVelocityY() * updateRatio;

    if (targetX == this.x && targetY == this.y) {
      return;
    }

    if (this.checkForCollision(emitterOrigin, targetX, targetY)) {
      return;
    }

    if (this.getVelocityX() != 0) {
      this.x = targetX;
    }

    if (this.getVelocityY() != 0) {
      this.y = targetY;
    }

    if (this.getAccelerationX() != 0) {
      this.velocityX += this.getAccelerationX() * updateRatio;
    }

    if (this.getAccelerationY() != 0) {
      this.velocityY += this.getAccelerationY() * updateRatio;
    }
}
}
```
```java
class de.gurkenlabs.litiengine.graphics.animation.Animation {
@Override
  public void start() {
    this.playing = true;
    if (this.getKeyframes().isEmpty()) {
      return;
    }

    this.restart();
}@Override
  public void update() {
    // do nothing if the animation is not playing or the current keyframe is not finished
    if (!this.isPlaying()
        || Game.time().since(this.lastFrameUpdate) < this.getCurrentKeyFrame().getDuration()) {
      return;
    }

    // if we are not looping and the last keyframe is finished, we terminate the animation
    if (!this.isLooping() && this.isLastKeyFrame()) {
      this.terminate();
      return;
    }

    // make sure, we stay inside the keyframe list
    final int newFrameIndex =
        (this.getKeyframes().indexOf(this.currentFrame) + 1) % this.getKeyframes().size();
    final KeyFrame previousFrame = this.currentFrame;
    this.currentFrame = this.getKeyframes().get(newFrameIndex);

    for (KeyFrameListener listener : this.listeners) {
      listener.currentFrameChanged(previousFrame, this.currentFrame);
    }

    this.lastFrameUpdate = Game.loop().getTicks();
}
}
```
```java
class de.gurkenlabs.litiengine.graphics.animation.AnimationController {
@Override
  public void update() {
    for (final Animation animation : this.getAll()) {
      animation.update();
    }

    if (this.getCurrent() != null && this.getCurrent().isPaused()) {
      return;
    }

    final boolean playbackFinished = this.getCurrent() != null && !this.getCurrent().isPlaying();
    if (playbackFinished) {
      for (final AnimationListener listener : this.listeners) {
        listener.finished(this.getCurrent());
      }
    }

    if (this.getCurrent() == null || playbackFinished) {
      if (this.getDefault() != null) {
        this.play(this.getDefault().getName());
      } else {
        this.currentAnimation = null;
      }
    }
}
}
```
```java
class de.gurkenlabs.litiengine.graphics.RenderComponent {
private void handleFade() {
    if (this.fadeOutStart != -1) {
      final long timePassed = Game.time().since(this.fadeOutStart);
      this.currentAlpha = MathUtilities.clamp(1 - timePassed / (float) this.fadeOutTime, 0, 1);
      if (this.currentAlpha == 0f) {
        this.fadeOutStart = -1;
        this.fadeOutTime = -1;
      }

      return;
    }

    if (this.fadeInStart != -1) {
      final long timePassed = Game.time().since(this.fadeInStart);
      this.currentAlpha = MathUtilities.clamp(timePassed / (float) this.fadeInTime, 0, 1);
      if (this.currentAlpha == 1f) {
        this.fadeInStart = -1;
        this.fadeInTime = -1;
        this.currentAlpha = Float.NaN;
      }
    }
}public void fadeOut(final int ms) {
    this.fadeInStart = -1;
    this.fadeInTime = -1;
    this.fadeOutStart = Game.time().now();
    this.fadeOutTime = ms;
}public void fadeIn(final int ms) {
    this.fadeOutStart = -1;
    this.fadeOutTime = -1;
    this.fadeInStart = Game.time().now();
    this.fadeInTime = ms;
}
}
```
```java
class de.gurkenlabs.litiengine.entities.Trigger {
private boolean activate(final IEntity activator, final int tar) {
    if (!this.isLoaded()
        || this.isOneTimeTrigger && this.isActivated
        || this.getActivationType() == TriggerActivation.COLLISION
            && activator != null
            && this.collisionActivated.contains(activator)) {
      return false;
    }

    if (this.getCooldown() > 0 && Game.time().since(this.lastActivation) < this.getCooldown()) {
      return false;
    }

    List<Integer> triggerTargets = this.getTargets(tar);

    final TriggerEvent te = new TriggerEvent(this, activator, triggerTargets);

    if (!this.checkActivationPredicates(te)) {
      return false;
    }

    this.isActivated = true;
    if (activator != null) {
      this.collisionActivated.add(activator);
    }

    // if we actually have a trigger target, we send the message to the target
    for (final int target : triggerTargets) {
      final IEntity entity = this.getEnvironment().get(target);
      if (entity == null) {
        log.log(
            Level.WARNING,
            "trigger [{0}] was activated, but the trigger target [{1}] could not be found on the environment",
            new Object[] {this, target});
        continue;
      }

      entity.sendMessage(this, this.message);
    }

    // also send the trigger event to all registered consumers
    for (final TriggerActivatedListener listener : this.activatedListeners) {
      listener.activated(te);
    }

    if (this.isOneTimeTrigger) {
      this.getEnvironment().remove(this);
    }

    this.lastActivation = Game.time().now();
    return true;
}
}
```
```java
class de.gurkenlabs.litiengine.graphics.Camera {
private boolean isShakeEffectActive() {
    return this.getShakeTick() != 0
        && Game.time().since(this.getShakeTick()) < this.getShakeDuration();
}@Override
  public void update() {
    if (Game.world().camera() != null && !Game.world().camera().equals(this)) {
      return;
    }

    if (this.targetZoom > 0) {
      if (Game.time().since(this.zoomTick) >= this.zoomDelay) {
        this.zoom = this.targetZoom;
        this.targetZoom = 0;
        this.zoomDelay = 0;
        this.zoomTick = 0;
        this.zoomStep = 0;
      } else {
        this.zoom += this.zoomStep;
      }

      final ZoomChangedEvent event = new ZoomChangedEvent(this, this.getZoom());
      for (final ZoomChangedListener listener : this.zoomListeners) {
        listener.zoomChanged(event);
      }
    }

    if (this.panTime > 0) {
      if (--this.panTime <= 0) {
        this.setFocus(this.targetFocus);
        this.targetFocus = null;
      } else {
        double diff = this.panTime / (this.panTime + 1.0);
        this.focus =
            new Point2D.Double(
                this.focus.getX() * diff + this.targetFocus.getX() * (1.0 - diff),
                this.focus.getY() * diff + this.targetFocus.getY() * (1.0 - diff));
      }
    }

    if (!this.isShakeEffectActive()) {
      this.shakeOffsetX = 0;
      this.shakeOffsetY = 0;
      return;
    }

    if (Game.time().since(this.lastShake) > this.shakeDelay) {
      this.shakeOffsetX = this.getShakeIntensity() * ThreadLocalRandom.current().nextGaussian();
      this.shakeOffsetY = this.getShakeIntensity() * ThreadLocalRandom.current().nextGaussian();
      this.lastShake = Game.time().now();
    }
}@Override
  public void setZoom(final float targetZoom, final int delay) {
    if (delay == 0) {

      this.zoom = targetZoom;
      this.targetZoom = 0;
      this.zoomDelay = 0;
      this.zoomTick = 0;
      this.zoomStep = 0;

      final ZoomChangedEvent event = new ZoomChangedEvent(this, targetZoom);
      for (final ZoomChangedListener listener : this.zoomListeners) {
        listener.zoomChanged(event);
      }
    } else {
      this.zoomTick = Game.time().now();
      this.targetZoom = targetZoom;
      this.zoomDelay = delay;

      final double tickduration = 1000 / (double) Game.loop().getTickRate();
      final double tickAmount = delay / tickduration;
      final float totalDelta = this.targetZoom - this.zoom;
      this.zoomStep = tickAmount > 0 ? (float) (totalDelta / tickAmount) : totalDelta;
    }
}@Override
  public void shake(final double intensity, final int delay, final int shakeDuration) {
    this.shakeTick = Game.time().now();
    this.shakeDelay = delay;
    this.shakeIntensity = intensity;
    this.shakeDuration = shakeDuration;
}
}
```
```java
class de.gurkenlabs.litiengine.entities.Creature {
public void setSpritesheetName(String spritesheetName) {
    if (this.spritesheetName != null && this.spritesheetName.equals(spritesheetName)) {
      return;
    }

    this.spritesheetName = spritesheetName;
    this.updateAnimationController();
}public boolean isIdle() {
    return Game.time().since(this.lastMoved) > IDLE_DELAY;
}@Override
  public void setLocation(final Point2D position) {
    if (this.isDead() || position == null) {
      return;
    }

    final Point2D oldLocation = this.getLocation();
    super.setLocation(position);

    if (Game.hasStarted() && this.isLoaded()) {
      this.lastMoved = Game.time().now();
      this.fireMovedEvent(
          new EntityMovedEvent(
              this, this.getX() - oldLocation.getX(), this.getY() - oldLocation.getY()));
    }
}
}
```
```java
class de.gurkenlabs.litiengine.gui.screens.ScreenManager {
public void display(final String screenName) {
    if (this.current() != null && this.current().getName().equalsIgnoreCase(screenName)) {
      log.log(
          Level.INFO,
          "Skipping displaying of screen {0} because it is already the current screen.",
          screenName);
      return;
    }

    if (this.screens.stream()
        .noneMatch(element -> element.getName().equalsIgnoreCase(screenName))) {
      log.log(
          Level.WARNING,
          "Could not display the screen {0} because there is no screen with the specified name.",
          screenName);
      return;
    }

    Screen screen = this.get(screenName);
    if (screen == null) {
      return;
    }

    this.display(screen);
}public void add(final Screen screen) {
    screen.setWidth(Game.window().getWidth());
    screen.setHeight(Game.window().getHeight());
    this.screens.add(screen);

    if (this.current() == null) {
      this.display(screen);
    }
}public void remove(Screen screen) {
    this.screens.remove(screen);
    if (this.current() == screen) {
      if (!this.screens.isEmpty()) {
        this.display(this.screens.get(0));
      } else {
        this.display((Screen) null);
      }
    }
}public void display(@Nullable final Screen screen) {
      if (Game.hasStarted() && Game.time().since(this.lastScreenChange) < this.getChangeCooldown()) {
        log.log(
            Level.INFO,
            "Skipping displaying of screen {0} because screen changing is currently on cooldown.",
            screen != null ? screen.getName() : "");
        return;
      }
  
      final Screen previous = this.current();
      if (previous != null) {
        previous.suspend();
      }
  
      if (screen != null && !this.screens.contains(screen)) {
        this.screens.add(screen);
      }
  
      this.currentScreen = screen;
      if (!Game.isInNoGUIMode() && this.current() != null) {
        this.current().prepare();
      }
  
      this.lastScreenChange = Nullability.castToNonnull(Game.loop(), "initialized before usage").getTicks();
  
      final ScreenChangedEvent event = new ScreenChangedEvent(this.current(), previous);
      for (final ScreenChangedListener listener : this.screenChangedListeners) {
        listener.changed(event);
      }
}
}
```
```java
class de.gurkenlabs.litiengine.abilities.Ability {
public boolean isOnCooldown() {
    return (this.getCurrentExecution() != null
        && this.getCurrentExecution().getExecutionTicks() > 0
        && Game.time().since(this.getCurrentExecution().getExecutionTicks())
            < this.getAttributes().cooldown().get());
}public boolean isActive() {
    return this.getCurrentExecution() != null
        && Game.time().since(this.getCurrentExecution().getExecutionTicks())
            < this.getAttributes().duration().get();
}@Nullable
  public AbilityExecution cast() {
    if (!this.canCast()) {
      return null;
    }
    this.currentExecution = new AbilityExecution(this);

    for (final AbilityCastListener listener : this.abilityCastListeners) {
      listener.abilityCast(this.currentExecution);
    }

    return this.getCurrentExecution();
}public float getRemainingCooldownInSeconds() {
    if (this.getCurrentExecution() == null
        || this.getExecutor() == null
        || this.getExecutor().isDead()) {
      return 0;
    }

    // calculate cooldown in seconds
    return (float)
        (!this.canCast()
            ? (this.getAttributes().cooldown().get()
                    - Game.time().since(this.getCurrentExecution().getExecutionTicks()))
                * 0.001
            : 0);
}
}
```
```java
class de.gurkenlabs.litiengine.entities.EntityHitEvent {
EntityHitEvent(
      final ICombatEntity hitEntity,
      @Nullable final Ability ability,
      final int damage,
      final boolean kill) {
    super(hitEntity);
    this.executor = ability != null ? ability.getExecutor() : null;
    this.hitEntity = hitEntity;
    this.ability = ability;
    this.damage = damage;
    this.kill = kill;
    this.time = Game.time().now();
}
}
```
```java
class de.gurkenlabs.litiengine.graphics.emitters.Emitter {
public void delete() {
    this.deactivate();
    if (Game.world().environment() != null) {
      Game.world().environment().remove(this);
    }
}public void activate() {
    if (this.activated) {
      return;
    }

    this.activated = true;
    this.activationTick = Game.time().now();
    Game.loop().attach(this);
}@Override
  public void update() {
    if (this.isPaused()) {
      return;
    }

    // clear particles if the effect time to life is reached
    if (this.isFinished()) {
      for (EmitterFinishedListener listener : this.finishedListeners) {
        listener.finished(this);
      }

      this.delete();
      return;
    }

    final float updateRatio = (float) this.data().getUpdateRate() / Game.loop().getTickRate();
    for (final Particle p : this.getParticles().stream().collect(Collectors.toList())) {
      if (this.particleCanBeRemoved(p)) {
        // remove dead particles
        this.particles.remove(p);
        continue;
      }

      p.update(this.getOrigin(), updateRatio);
    }

    this.aliveTime = Game.time().since(this.activationTick);
    if ((this.data().getSpawnRate() == 0
        || Game.time().since(this.lastSpawn) >= this.data().getSpawnRate())) {
      this.lastSpawn = Game.time().now();
      this.spawnParticle();
    }
}
}
```
```java
class de.gurkenlabs.litiengine.GameLoop {
@Override
  public int perform(int delay, Runnable action) {
    final long d = Game.time().toTicks(delay);

    TimedAction a = new TimedAction(this.getTicks() + d, action);
    this.actions.add(a);

    return a.getId();
}
}
```
```java
class de.gurkenlabs.litiengine.environment.EntitySpawner {
protected boolean shouldSpawn() {
    return this.lastSpawnWave == 0
        || Game.time().since(this.lastSpawnWave) >= this.getSpawnInterval();
}@Override
  public void update() {
    if (!this.shouldSpawn()) {
      return;
    }

    this.spawnNewEntities();
    this.lastSpawnWave = Game.time().now();
}
}
```
```java
class de.gurkenlabs.litiengine.graphics.FreeFlightCamera {
@Override
  public void update() {
    this.handleFreeFlightCamera();
}public FreeFlightCamera(double x, double y) {
    this(new Point2D.Double(x, y));
}
}
```
```java
class de.gurkenlabs.litiengine.environment.Environment {
public void unload() {
    if (!this.loaded) {
      return;
    }

    // unregister all updatable entities from the current environment
    for (final IEntity entity : this.allEntities.values()) {
      this.unload(entity);
    }

    this.loaded = false;
    this.fireEvent(l -> l.unloaded(this));
}private static void loadUpdatableOrEmitterEntity(IEntity entity) {
      if (entity instanceof Emitter) {
        final Emitter emitter = (Emitter) entity;
        if (emitter.isActivateOnInit()) {
          emitter.activate();
        }
      } else if (entity instanceof IUpdateable) {
        Nullability.castToNonnull(Game.loop(), "initialized through init").attach((IUpdateable) entity);
      }
}public void clear() {
    Game.physics().clear();

    this.combatEntities.clear();
    this.mobileEntities.clear();
    this.gravityForces.clear();
    this.layerEntities.clear();
    this.entitiesByTag.clear();
    this.allEntities.clear();

    for (RenderType renderType : RenderType.values()) {
      this.miscEntities.get(renderType).clear();
      this.renderListeners.get(renderType).clear();
      this.renderables.get(renderType).clear();
    }

    dispose(this.allEntities.values());
    dispose(this.triggers);
    this.emitters.clear();
    this.colliders.clear();
    this.props.clear();
    this.creatures.clear();
    this.staticShadows.clear();
    this.combatEntities.clear();
    this.mobileEntities.clear();
    this.lightSources.clear();
    this.spawnPoints.clear();
    this.soundSources.clear();
    this.mapAreas.clear();
    this.triggers.clear();

    this.ambientLight = null;
    this.staticShadowLayer = null;

    for (Map<Integer, IEntity> type : this.miscEntities.values()) {
      type.clear();
    }

    this.initialized = false;

    this.fireEvent(l -> l.cleared(this));
}private void load(final IEntity entity) {
    // an entity can only exist on one environment at a time, so remove it from the current one
    if (entity.getEnvironment() != null) {
      entity.getEnvironment().remove(entity);
    }

    // 1. add to physics engine
    loadPhysicsEntity(entity);

    // 2. register for update or activate
    loadUpdatableOrEmitterEntity(entity);

    // 3. if a gravity is defined, add a gravity force to the entity
    if (entity instanceof IMobileEntity && this.getGravity() != 0) {
      this.addGravityForce((IMobileEntity) entity);
    }

    // 4. attach all controllers
    entity.attachControllers();

    if (this.loaded && (entity instanceof LightSource || entity instanceof StaticShadow)) {
      this.updateLighting(entity);
    }

    entity.loaded(this);
}private void unload(final IEntity entity) {
    // 1. remove from physics engine
    if (entity instanceof ICollisionEntity) {
      Game.physics().remove((ICollisionEntity) entity);
    }

    // 2. unregister from update
    if (entity instanceof IUpdateable) {
      Game.loop().detach((IUpdateable) entity);
    }

    if (entity instanceof IMobileEntity) {
      this.removeGravity((IMobileEntity) entity);
    }

    // 3. detach all controllers
    entity.detachControllers();

    if (entity instanceof Emitter) {
      Emitter em = (Emitter) entity;
      em.deactivate();
    }

    if (this.loaded && (entity instanceof LightSource || entity instanceof StaticShadow)) {
      this.updateLighting(entity);
    }

    entity.removed(this);
}public void remove(final IEntity entity) {
    if (entity == null) {
      return;
    }

    this.allEntities.remove(entity.getMapId());
    Iterator<List<IEntity>> iter = this.layerEntities.values().iterator();
    while (iter.hasNext()) {
      List<IEntity> layer = iter.next();
      if (layer.remove(entity) && layer.isEmpty()) {
        iter.remove();
      }
    }
    if (this.miscEntities.get(entity.getRenderType()) != null) {
      this.miscEntities.get(entity.getRenderType()).values().remove(entity);
    }

    for (String tag : entity.getTags()) {
      if (this.getEntitiesByTag().containsKey(tag)) {
        this.getEntitiesByTag().get(tag).remove(entity);

        if (this.getEntitiesByTag().get(tag).isEmpty()) {
          this.getEntitiesByTag().remove(tag);
        }
      }
    }

    if (entity instanceof Emitter) {
      Emitter emitter = (Emitter) entity;
      this.removeEmitter(emitter);
    }

    if (entity instanceof MapArea) {
      this.mapAreas.remove(entity);
    }

    if (entity instanceof Prop) {
      this.props.remove(entity);
    }

    if (entity instanceof Creature) {
      this.creatures.remove(entity);
    }

    if (entity instanceof CollisionBox) {
      this.colliders.remove(entity);
      this.staticShadows.removeIf(x -> x.getOrigin() != null && x.getOrigin().equals(entity));
    }

    if (entity instanceof LightSource) {
      this.lightSources.remove(entity);
      this.updateLighting(entity);
    }

    if (entity instanceof Trigger) {
      this.triggers.remove(entity);
    }

    if (entity instanceof Spawnpoint) {
      this.spawnPoints.remove(entity);
    }
    if (entity instanceof SoundSource) {
      this.soundSources.remove(entity);
    }

    if (entity instanceof StaticShadow) {
      this.staticShadows.remove(entity);
      this.updateLighting(entity);
    }

    if (entity instanceof IMobileEntity) {
      this.mobileEntities.values().remove(entity);
    }

    if (entity instanceof ICombatEntity) {
      this.combatEntities.values().remove(entity);
    }

    this.unload(entity);

    this.fireEntityEvent(l -> l.entityRemoved(entity));
}
}
```
```java
class de.gurkenlabs.litiengine.physics.MovementController {
@Override
  public void update() {
    this.handleForces();
    this.handleMovement();
}
}
```
```java
class de.gurkenlabs.litiengine.Game {
static synchronized void terminate() {
        if (!initialized || gameLoop == null) {
          return;
        }
    
        hasStarted = false;
        initialized = false;
    
        config().save();
        gameLoop.terminate();
        tweenEngine.terminate();
        soundEngine.terminate();
    
        world().clear();
    
        for (final GameListener listener : gameListeners) {
          try {
            listener.terminated();
          } catch (Exception e) {
            log().log(Level.WARNING, "game listener threw an exception during shutdown", e);
          }
        }
    
        gameLoop = null;
        screenManager = null;
        gameWindow = null;
}public static synchronized void start() {
          if (!initialized) {
              throw new IllegalStateException(
                  "The game cannot be started without being first initialized. Call Game.init(...) before Game.start().");
          }
    
          if (gameLoop == null) {
              throw new IllegalStateException(
                  "Game loop is not initialized. Ensure Game.init(...) has been called successfully.");
          }
          
          Nullability.castToNonnull(gameLoop, "gameLoop cannot be null").start();
          tweenEngine.start();
          soundEngine.start();
    
          for (final GameListener listener : gameListeners) {
              listener.started();
          }
    
          hasStarted = true;
}public static synchronized void init(String... args) {
    if (initialized) {
      log().log(Level.INFO, "The game has already been initialized.");
      return;
    }

    log.init();
    handleCommandLineArguments(args);

    config().load();
    Locale.setDefault(new Locale(config().client().getCountry(), config().client().getLanguage()));

    gameLoop = new GameLoop("Main Update Loop", config().client().getMaxFps());
    loop().attach(physics());
    loop().attach(world());

    // setup default exception handling for render and update loop
    setUncaughtExceptionHandler(
        new DefaultUncaughtExceptionHandler(config().client().exitOnError()));

    screenManager = new ScreenManager();
    gameWindow = new GameWindow();

    // initialize  the game window
    window().init();
    world.setCamera(new Camera());

    for (GameListener listener : gameListeners) {
      listener.initialized(args);
    }

    if (!isInNoGUIMode()) {
      window().getRenderComponent().onRendered(g -> metrics().render(g));

      graphics()
          .addEntityRenderedListener(
              e -> DebugRenderer.renderEntityDebugInfo(e.getGraphics(), e.getEntity()));

      window().getRenderComponent().onFpsChanged(fps -> metrics().setFramesPerSecond(fps));
      window()
          .setIcons(
              Arrays.asList(
                  Resources.images().get("liti-logo-x16.png"),
                  Resources.images().get("liti-logo-x20.png"),
                  Resources.images().get("liti-logo-x32.png"),
                  Resources.images().get("liti-logo-x48.png")));

      Input.keyboard()
          .onKeyTyped(
              KeyEvent.VK_PRINTSCREEN,
              key -> {
                // don't take a screenshot if a modifier is active
                if (key.getModifiers() != 0) {
                  return;
                }

                window().getRenderComponent().takeScreenshot();
              });
    }

    Runtime.getRuntime().addShutdownHook(new Thread(Game::terminate, "Shutdown"));

    initialized = true;
}
}
```


Response Format:
Provide the answer in **XML format** as follows:

#### If the method **cannot** return `null` at the specific call site:
```xml
<response>
  <reason><![CDATA[EXPLAIN WHY THE INVOCATION Game.loop() RESULT CANNOT BE NULL.]]></reason>
  <value>NO</value>
</response>

#### If the method can return null at the specific call site:
<response>
  <reason><![CDATA[EXPLAIN WHY THE INVOCATION Game.loop() RESULT CAN BE NULL.]]></reason>
  <value>YES</value>
</response>

#### If you are unsure or If there are any methods that directly or indirectly affect the return value and are not fully disclosed, request their declarations first, in the following format:
<response>
  <reason><![CDATA[EXPLAIN WHY THIS METHOD DECLARATION IS NECESSARY AND WHY YOU CANNOT MAKE A CONFIDENT DECISION WITHOUT IT]]></reason>
  <success>false</success>
  <methods>
    <method>methodName</method>
  </methods>
</response>

Additional Notes:
Be precise in your reasoning.
If a methods return value depends on another method not provided, request its declaration before making a conclusion.
If the method can return null in this case but not in others, explain why it happens specifically for this call.

11:53:27.797 TRACE edu.ucr.cs.riple.core.checkers.nullaway.codefix.ChatGPT.ask
Retrieving response from cache
11:53:27.797 TRACE edu.ucr.cs.riple.core.checkers.nullaway.codefix.Response.tryCreate
Trying to create Response:
```xml
<response>
  <reason><![CDATA[The invocation Game.loop() cannot return null because the Game.init method, which initializes the gameLoop variable, is synchronized and must be called before any game operations that rely on the loop. In particular, the Game.start method checks if the game has been initialized and throws an exception if it has not. Therefore, if any of the methods within the call chain are executable without throwing an initialization exception, it implies that Game.init has been successfully called, ensuring that gameLoop is not null.]]></reason>
  <value>NO</value>
</response>
```
11:53:27.798 TRACE edu.ucr.cs.riple.core.checkers.nullaway.codefix.Response.<init>
Creating Response:
```xml
<response>
  <reason><![CDATA[The invocation Game.loop() cannot return null because the Game.init method, which initializes the gameLoop variable, is synchronized and must be called before any game operations that rely on the loop. In particular, the Game.start method checks if the game has been initialized and throws an exception if it has not. Therefore, if any of the methods within the call chain are executable without throwing an initialization exception, it implies that Game.init has been successfully called, ensuring that gameLoop is not null.]]></reason>
  <value>NO</value>
</response>
```
11:53:27.798 TRACE edu.ucr.cs.riple.core.checkers.nullaway.codefix.Response.<init>
Response created:
Disagreement: The invocation Game.loop() cannot return null because the Game.init method, which initializes the gameLoop variable, is synchronized and must be called before any game operations that rely on the loop. In particular, the Game.start method checks if the game has been initialized and throws an exception if it has not. Therefore, if any of the methods within the call chain are executable without throwing an initialization exception, it implies that Game.init has been successfully called, ensuring that gameLoop is not null.
11:53:27.798 TRACE edu.ucr.cs.riple.core.checkers.nullaway.codefix.AdvancedNullAwayCodeFix.resolveMethodDereferenceError
Method is not returning nullable on call site. Injecting suppression annotation.
11:53:27.798 TRACE edu.ucr.cs.riple.core.checkers.nullaway.codefix.AdvancedNullAwayCodeFix.constructCastToNonnullChange
Constructing cast to nonnull change for reason: The invocation Game.loop() cannot return null because the Game.init method, which initializes the gameLoop variable, is synchronized and must be called before any game operations that rely on the loop. In particular, the Game.start method checks if the game has been initialized and throws an exception if it has not. Therefore, if any of the methods within the call chain are executable without throwing an initialization exception, it implies that Game.init has been successfully called, ensuring that gameLoop is not null.
11:53:27.800 TRACE edu.ucr.cs.riple.core.checkers.nullaway.codefix.ChatGPT.ask
Asking ChatGPT:
For the reason you mentioned earlier:

"The invocation Game.loop() cannot return null because the Game.init method, which initializes the gameLoop variable, is synchronized and must be called before any game operations that rely on the loop. In particular, the Game.start method checks if the game has been initialized and throws an exception if it has not. Therefore, if any of the methods within the call chain are executable without throwing an initialization exception, it implies that Game.init has been successfully called, ensuring that gameLoop is not null."

in the method below, the expression Game.loop() is not nullable at the point it is used.

```java
public void setCamera(@Nullable final ICamera cam) {
    if (this.camera() != null) {
      Game.loop().detach(camera);
    }

    camera = cam;

    if (cam != null && !Game.isInNoGUIMode()) {
      Game.loop().attach(cam);
      cam.updateFocus();
    }
}
```
Please Summarize the reason in max 5 words and rewrite the method so that at the line "      Game.loop().attach(cam);", at the occurrence of: "Game.loop()" is replaced with `Nullability.castToNonnull(Game.loop(), summary of reason)`
Replace "REASON" with the exact reason summary I provide to you (maximum 5 words), not with a generic explanation like "checked to be nonnull".
see the example below, for expression `foo.getBar()`, to wrap it with `Nullability.castToNonnull(foo.getBar(), "reason")`.

```java
public t(){
    String l = foo.getBar();
}
```

will be:
```java
public t(){
    String l = Nullability.castToNonnull(foo.getBar(), "checked to be nonnull");
}
```

### Instructions:

Do not import any additional classes.

Do not add Java comments.

Only modify relevant lines as required.

Return only the modified method wrapped in the XML format shown below.

Place the Java code inside the <code> tag using a CDATA block with ```java formatting.

Just give me the fixed code snippet in XML format in <response> tag like the example below. I will apply the fix to my codebase. Do not import any additional libraries or classes or add java comments. If you can provide the fixed code snippet, please provide it in the following format and place the code snippet in the <code> tag within ```java block.
<response>
  <success>true</success>
  <code><![CDATA[
  ```java
  Your fixed code snippet here
  ```
    ]]>
  </code>
</response>

11:53:27.800 TRACE edu.ucr.cs.riple.core.checkers.nullaway.codefix.ChatGPT.ask
Retrieving response from cache
11:53:27.800 TRACE edu.ucr.cs.riple.core.checkers.nullaway.codefix.Response.tryCreate
Trying to create Response:
<response>
  <success>true</success>
  <code><![CDATA[
  ```java
public void setCamera(final ICamera cam) {
    if (this.camera() != null) {
      Game.loop().detach(camera);
    }

    camera = cam;

    if (cam != null && !Game.isInNoGUIMode()) {
      Nullability.castToNonnull(Game.loop(), "synchronized initialization").attach(cam);
      cam.updateFocus();
    }
}
  ```
  ]]>
  </code>
</response>
11:53:27.801 TRACE edu.ucr.cs.riple.core.checkers.nullaway.codefix.Response.<init>
Creating Response:
<response>
  <success>true</success>
  <code><![CDATA[
  ```java
public void setCamera(final ICamera cam) {
    if (this.camera() != null) {
      Game.loop().detach(camera);
    }

    camera = cam;

    if (cam != null && !Game.isInNoGUIMode()) {
      Nullability.castToNonnull(Game.loop(), "synchronized initialization").attach(cam);
      cam.updateFocus();
    }
}
  ```
  ]]>
  </code>
</response>
11:53:27.801 TRACE edu.ucr.cs.riple.core.checkers.nullaway.codefix.Response.<init>
Response created:
public void setCamera(final ICamera cam) {
    if (this.camera() != null) {
      Game.loop().detach(camera);
    }

    camera = cam;

    if (cam != null && !Game.isInNoGUIMode()) {
      Nullability.castToNonnull(Game.loop(), "synchronized initialization").attach(cam);
      cam.updateFocus();
    }
}
11:53:27.801 TRACE edu.ucr.cs.riple.core.checkers.nullaway.codefix.ChatGPT.fixDereferenceByAddingCastToNonnull
Fixing the error by adding castToNonnull
11:53:27.814 TRACE edu.ucr.cs.riple.core.checkers.nullaway.codefix.AdvancedNullAwayCodeFix.fixTriggeredErrorsForLocation
Resolving unresolvable error for triggered error: Type='DEREFERENCE_NULLABLE', message='dereferenced expression Game.loop() is @Nullable'
/home/nima/Developer/nullness-benchmarks/litiengine/src/de/gurkenlabs/litiengine/GameTime.java:32
    return Game.loop().getTicks();
11:53:27.814 TRACE edu.ucr.cs.riple.core.checkers.nullaway.codefix.AdvancedNullAwayCodeFix.fix
Fixing error: Type='DEREFERENCE_NULLABLE', message='dereferenced expression Game.loop() is @Nullable'
/home/nima/Developer/nullness-benchmarks/litiengine/src/de/gurkenlabs/litiengine/GameTime.java:32
    return Game.loop().getTicks();
11:53:27.814 TRACE edu.ucr.cs.riple.core.checkers.nullaway.codefix.AdvancedNullAwayCodeFix.resolveDereferenceError
Resolving dereference error: Type='DEREFERENCE_NULLABLE', message='dereferenced expression Game.loop() is @Nullable'
/home/nima/Developer/nullness-benchmarks/litiengine/src/de/gurkenlabs/litiengine/GameTime.java:32
    return Game.loop().getTicks();
11:53:27.814 TRACE edu.ucr.cs.riple.core.checkers.nullaway.codefix.AdvancedNullAwayCodeFix.resolveDereferenceError
Checking nullability possibility at error point
11:53:27.814 TRACE edu.ucr.cs.riple.core.checkers.nullaway.codefix.ChatGPT.checkNullabilityPossibilityAtErrorPoint
Asking if the expression can be null at error point point
11:53:27.814 TRACE edu.ucr.cs.riple.core.checkers.nullaway.codefix.ChatGPT.ask
Asking ChatGPT:
In the method below, is there a possibility that the expression "Game.loop()" at line "return Game.loop().getTicks();" is null?
public long now() {
    return Game.loop().getTicks();
}
Give a single-word answer in XML format. If it is possible for the expression to be null, respond with:
```xml
<response>
    <reason><![CDATA[YOUR REASON]]></reason>
    <value>YES</value>
</response>
```
If it is not possible for the expression to be null, respond with:
```xml
<response>
    <reason><![CDATA[YOUR REASON]]></reason>
    <value>NO</value>
</response>
```
If you are unsure or need more information, respond with where you can ask for more details or what specific information you need.

If additional information is required, list each request inside a `<request>` tag. If no additional information is needed, omit the `<requests>` section.

Respond with:
```xml
<response>
    <reason><![CDATA[YOUR REASON]]></reason>
    <value>UNKNOWN</value>
    <!-- Include <requests> only if additional information is needed -->
    <requests>
        <request><![CDATA[YOUR REQUEST 1]]></request>
        <request><![CDATA[YOUR REQUEST 2]]></request>
    </requests>
</response>
```
11:53:27.814 TRACE edu.ucr.cs.riple.core.checkers.nullaway.codefix.ChatGPT.ask
Retrieving response from cache
11:53:27.814 TRACE edu.ucr.cs.riple.core.checkers.nullaway.codefix.Response.tryCreate
Trying to create Response:
```xml
<response>
    <reason><![CDATA[The method "Game.loop()" could return null if there is no explicit guarantee or contract in the code that it always returns a non-null value. Without information about its implementation or documentation, it cannot be concluded definitively.]]></reason>
    <value>UNKNOWN</value>
    <requests>
        <request><![CDATA[Provide the implementation of or documentation for the "Game.loop()" method.]]></request>
    </requests>
</response>
```
11:53:27.815 TRACE edu.ucr.cs.riple.core.checkers.nullaway.codefix.Response.<init>
Creating Response:
```xml
<response>
    <reason><![CDATA[The method "Game.loop()" could return null if there is no explicit guarantee or contract in the code that it always returns a non-null value. Without information about its implementation or documentation, it cannot be concluded definitively.]]></reason>
    <value>UNKNOWN</value>
    <requests>
        <request><![CDATA[Provide the implementation of or documentation for the "Game.loop()" method.]]></request>
    </requests>
</response>
```
11:53:27.815 TRACE edu.ucr.cs.riple.core.checkers.nullaway.codefix.Response.<init>
Response created:
Unknown: The method "Game.loop()" could return null if there is no explicit guarantee or contract in the code that it always returns a non-null value. Without information about its implementation or documentation, it cannot be concluded definitively.
11:53:27.816 TRACE edu.ucr.cs.riple.core.checkers.nullaway.codefix.AdvancedNullAwayCodeFix.resolveMethodDereferenceError
Resolving method dereference error.
11:53:27.816 TRACE edu.ucr.cs.riple.core.checkers.nullaway.codefix.AdvancedNullAwayCodeFix.resolveMethodDereferenceError
Method is in annotated package. Checking if the method is returning nullable.
11:53:27.816 TRACE edu.ucr.cs.riple.core.checkers.nullaway.codefix.AdvancedNullAwayCodeFix.investigateMethodReturnNullability
Checking if the method is returning nullable.
11:53:27.818 TRACE edu.ucr.cs.riple.core.checkers.nullaway.codefix.ChatGPT.checkIfMethodIsReturningNullable
Asking if the method is returning nullable: loop()
11:53:27.819 TRACE edu.ucr.cs.riple.core.checkers.nullaway.codefix.ChatGPT.ask
Asking ChatGPT:
In the method below, is there a possibility that the method returns null based only on its body? Consider the following points:

- The method may have multiple return paths; consider all return statements.
- If the method calls another method, do not assume its return value unless its full declaration is provided. Request its declaration if needed.
- The method may throw an exception instead of returning null. An exception path should not be considered a null return.
- Ensure you request the declarations of any methods whose return values directly or indirectly impact this methods return value before making a conclusion.
- Carefully analyze all conditions and prior operations that may guarantee a non-null return value.

@Nullable public static IGameLoop loop() {
    return gameLoop;
}

Here are the method definitions in addition to the method inquired:

Depth: 0
```java
class de.gurkenlabs.litiengine.Game {
@Nullable public static IGameLoop loop() {
    return gameLoop;
}
}
```


Response Format:
Provide the answer in **XML format** as follows:

#### If the method **cannot** return `null`:
```xml
<response>
  <reason><![CDATA[EXPLAIN WHY THE METHOD CANNOT RETURN NULL]]></reason>
  <value>NO</value>
</response>
```

#### If the method can return null:
```xml
<response>
  <reason><![CDATA[EXPLAIN WHY THE METHOD CAN RETURN NULL]]></reason>
  <value>YES</value>
</response>
```

#### If you are unsure or need more information, respond with where you can ask for more details or what specific information you need.

#### If you are unsure or If there are any methods that directly or indirectly affect the return value and are not fully disclosed, request their declarations first, in the following format:
<response>
  <reason><![CDATA[YOUR REASON]]></reason>
  <value>UNKNOWN</value>
  <methods>
    <method>methodName</method>
  </methods>
</response>

If additional information is required other than method declaration, list each request inside a `<request>` tag. If no additional information is needed, omit the `<requests>` section.

Respond with:
```xml
<response>
    <reason><![CDATA[YOUR REASON]]></reason>
    <value>UNKNOWN</value>
    <!-- Include <requests> only if additional information is needed -->
    <requests>
        <request><![CDATA[YOUR REQUEST 1]]></request>
        <request><![CDATA[YOUR REQUEST 2]]></request>
    </requests>
</response>
```

Additional Notes:
Be precise in your reasoning.
If a methods return value depends on another method not provided, request its declaration before making a conclusion.
If the method can return null in some cases but not others, explain under what conditions it can happen.

11:53:27.820 TRACE edu.ucr.cs.riple.core.checkers.nullaway.codefix.ChatGPT.ask
Retrieving response from cache
11:53:27.820 TRACE edu.ucr.cs.riple.core.checkers.nullaway.codefix.Response.tryCreate
Trying to create Response:
```xml
<response>
  <reason><![CDATA[The method `loop` returns the variable `gameLoop`. Without the initialization or assignment details of `gameLoop`, it's unclear whether it can be null. The possibility of `gameLoop` being uninitialized or set to null elsewhere in the program means `loop` could potentially return null. Further information on `gameLoop` is required.]]></reason>
  <value>UNKNOWN</value>
  <requests>
    <request><![CDATA[Please provide the declaration and initialization of the variable `gameLoop` in the class `de.gurkenlabs.litiengine.Game`.]]></request>
  </requests>
</response>
```
11:53:27.820 TRACE edu.ucr.cs.riple.core.checkers.nullaway.codefix.Response.<init>
Creating Response:
```xml
<response>
  <reason><![CDATA[The method `loop` returns the variable `gameLoop`. Without the initialization or assignment details of `gameLoop`, it's unclear whether it can be null. The possibility of `gameLoop` being uninitialized or set to null elsewhere in the program means `loop` could potentially return null. Further information on `gameLoop` is required.]]></reason>
  <value>UNKNOWN</value>
  <requests>
    <request><![CDATA[Please provide the declaration and initialization of the variable `gameLoop` in the class `de.gurkenlabs.litiengine.Game`.]]></request>
  </requests>
</response>
```
11:53:27.820 TRACE edu.ucr.cs.riple.core.checkers.nullaway.codefix.Response.<init>
Response created:
Unknown: The method `loop` returns the variable `gameLoop`. Without the initialization or assignment details of `gameLoop`, it's unclear whether it can be null. The possibility of `gameLoop` being uninitialized or set to null elsewhere in the program means `loop` could potentially return null. Further information on `gameLoop` is required.
11:53:27.820 TRACE edu.ucr.cs.riple.core.checkers.nullaway.codefix.AdvancedNullAwayCodeFix.investigateMethodReturnNullability
Could not determine the nullability and model did not ask for any method.
11:53:27.820 TRACE edu.ucr.cs.riple.core.checkers.nullaway.codefix.ChatGPT.checkIfMethodIsReturningNullableOnCallSite
Asking if the method is returning nullable on the call site: Game.loop()
11:53:28.062 TRACE edu.ucr.cs.riple.core.checkers.nullaway.codefix.ChatGPT.ask
Asking ChatGPT:
In the method below, is there a possibility that the method returns null at the given call site?

```java
@Nullable public static IGameLoop loop() {
    return gameLoop;
}
```

## Guidelines:
- The method may have multiple return paths; consider all return statements.
- If the method calls another method, do not assume its return value unless its full declaration is provided. Request its declaration if needed.
- The method may throw an exception instead of returning null. An exception path should not be considered a null return.
- Ensure you request the declarations of any methods whose return values directly or indirectly impact this methods return value before making a conclusion.
- If the method returns a value that is determined by a parameter, evaluate based on the actual argument at the given call site.
- Analyze based only on the specific invocation provided. Do not generalize to all possible inputs.- If the return value is guaranteed to be non-null at the call site, the answer should be a definitive NO.
- Do not generalize based on all possible inputsyour answer must be based only on the given invocation.
- Focus only on the given call site, not all possible invocations.

### call site:
Game.loop()

Here are the method definitions and the call chain for this method, showing the sequence of calls from the method to its callers at each depth level:

Depth: 0
```java
class de.gurkenlabs.litiengine.Game {
@Nullable public static IGameLoop loop() {
    return gameLoop;
}
}
```
Depth: 1
```java
class de.gurkenlabs.litiengine.environment.GameWorld {
public void loadEnvironment(@Nullable final Environment env) {
    Lock lock = Game.loop().getLock();
    lock.lock();
    try {
      unloadEnvironment();
      this.environment = env;
      if (env != null) {
        this.addEnvironment(env);

        if (env.getGravity() == 0 && this.gravity() != 0) {
          env.setGravity(this.gravity());
        }

        env.load();
        for (final EnvironmentLoadedListener listener : this.loadedListeners) {
          listener.loaded(env);
        }

        // call map specific listeners
        String mapName = getMapName(env);
        if (mapName != null && this.environmentLoadedListeners.containsKey(mapName)) {

          // for the default camera we center the camera on the environment
          if (this.camera().getClass().equals(Camera.class)) {
            camera().setFocus(env.getCenter());
          }

          for (EnvironmentLoadedListener listener : this.environmentLoadedListeners.get(mapName)) {
            listener.loaded(env);
          }
        }
      }
    } finally {
      lock.unlock();
    }
}public void setCamera(@Nullable final ICamera cam) {
      if (this.camera() != null) {
        Game.loop().detach(camera);
      }
  
      camera = cam;
  
      if (cam != null && !Game.isInNoGUIMode()) {
        Nullability.castToNonnull(Game.loop(), "synchronized initialization").attach(cam);
        cam.updateFocus();
      }
}
}
```
```java
class de.gurkenlabs.litiengine.entities.behavior.EntityNavigator {
public EntityNavigator(final IMobileEntity entity, final PathFinder pathFinder) {
    this.cancelNavigationConditions = new CopyOnWriteArrayList<>();
    this.listeners = new CopyOnWriteArrayList<>();
    this.entity = entity;
    this.pathFinder = pathFinder;
    this.setAcceptableError(DEFAULT_ACCEPTABLE_ERROR);
    Game.loop().attach(this);
}
}
```
```java
class de.gurkenlabs.litiengine.GameWindow {
private static void initializeWindowEventListeners(Window window) {
  
      window.addWindowStateListener(
          e -> {
            if (e.getNewState() == Frame.ICONIFIED) {
              Nullability.castToNonnull(Game.loop(), "initialized by Game.init").setTickRate(ICONIFIED_MAX_FPS);
            } else {
              Game.loop().setTickRate(Game.config().client().getMaxFps());
            }
          });
  
      window.addWindowFocusListener(
          new WindowFocusListener() {
            @Override
            public void windowLostFocus(WindowEvent e) {
              if (Game.config().graphics().reduceFramesWhenNotFocused()) {
                Game.loop().setTickRate(NONE_FOCUS_MAX_FPS);
              }
            }
  
            @Override
            public void windowGainedFocus(WindowEvent e) {
              Game.loop().setTickRate(Game.config().client().getMaxFps());
            }
          });
  
      window.addWindowListener(
          new WindowAdapter() {
            @Override
            public void windowClosing(final WindowEvent event) {
              Game.exit();
            }
          });
}
}
```
```java
class de.gurkenlabs.litiengine.gui.screens.ScreenManager {
public void display(@Nullable final Screen screen) {
      if (Game.hasStarted() && Game.time().since(this.lastScreenChange) < this.getChangeCooldown()) {
        log.log(
            Level.INFO,
            "Skipping displaying of screen {0} because screen changing is currently on cooldown.",
            screen != null ? screen.getName() : "");
        return;
      }
  
      final Screen previous = this.current();
      if (previous != null) {
        previous.suspend();
      }
  
      if (screen != null && !this.screens.contains(screen)) {
        this.screens.add(screen);
      }
  
      this.currentScreen = screen;
      if (!Game.isInNoGUIMode() && this.current() != null) {
        this.current().prepare();
      }
  
      this.lastScreenChange = Nullability.castToNonnull(Game.loop(), "initialized before usage").getTicks();
  
      final ScreenChangedEvent event = new ScreenChangedEvent(this.current(), previous);
      for (final ScreenChangedListener listener : this.screenChangedListeners) {
        listener.changed(event);
      }
}
}
```
```java
class de.gurkenlabs.litiengine.abilities.effects.Effect {
@Override
  public void update() {

    for (final Iterator<EffectApplication> iterator = this.getActiveAppliances().iterator();
        iterator.hasNext(); ) {
      final EffectApplication appliance = iterator.next();
      // if the effect duration is reached
      if (this.hasEnded(appliance)) {

        iterator.remove();
        this.cease(appliance);
      }
    }

    // 4. unregister if all appliances are finished
    if (this.getActiveAppliances().isEmpty()) {
      Game.loop().detach(this);
    }
}public void apply(final Shape impactArea) {
    final List<ICombatEntity> affected = this.lookForAffectedEntities(impactArea);
    for (final ICombatEntity affectedEntity : affected) {
      this.apply(affectedEntity);
    }

    this.appliances.add(new EffectApplication(affected, impactArea));

    // if it is the first appliance -> register for update
    if (this.appliances.size() == 1) {
      Game.loop().attach(this);
    }
}
}
```
```java
class de.gurkenlabs.litiengine.GameTime {
public long toTicks(final int milliseconds) {
    return this.toTicks(milliseconds, Game.loop().getTickRate());
}public long since(final long tick) {
    return toMilliseconds(Game.loop().getTicks() - tick);
}public long now() {
    return Game.loop().getTicks();
}public long sinceGameStart() {
    return this.toMilliseconds(Game.loop().getTicks());
}@Override
    public void loaded(Environment environment) {
      environmentLoaded = Nullability.castToNonnull(Game.loop(), "properly initialized and started").getTicks();
}public long toMilliseconds(final long ticks) {
    return this.toMilliseconds(ticks, Game.loop().getTickRate());
}
}
```
```java
class de.gurkenlabs.litiengine.GameMetrics {
@Override
    public void render(final Graphics2D g) {
      this.updateMetrics();
  
      if (!Game.config().client().showGameMetrics()) {
        return;
      }
  
      this.currentOffsetY = 0;
  
      g.setColor(this.renderColor);
  
      // render client metrics
      this.drawTitle(g, "[client]");
      this.drawMetric(g, "fps       : " + this.getFramesPerSecond());
      this.drawMetric(g, "max fps   : " + this.maxFramesPerSecond);
  
      // Use Nullability.castToNonnull to prevent NullAway warning
      this.drawMetric(g, "updatables: " + Nullability.castToNonnull(Game.loop(), "gameLoop always initialized").getUpdatableCount());
  
      // render jvm metrics if debug is enabled
      if (Game.config().debug().isDebugEnabled()) {
        this.drawTitle(g, "[jvm]");
        this.drawMetric(g, "java      : " + this.javaVersion);
        this.drawMetric(g, "memory    : " + String.format("%-5.5s", this.usedMemory) + " MB");
        this.drawMetric(g, "threads   : " + Thread.activeCount());
      }
  
      // render rendering metrics
      if (!this.renderMetrics.isEmpty()) {
        this.drawTitle(g, "[update]");
  
        for (RenderMetrics metric : this.renderMetrics) {
          this.drawMetric(g, metric.toString());
        }
  
        this.renderMetrics.clear();
      }
}
}
```
```java
class de.gurkenlabs.litiengine.graphics.emitters.Emitter {
public void deactivate() {
    if (!this.activated) {
      return;
    }

    this.activated = false;
    this.getParticles().clear();
    this.aliveTime = 0;
    this.activationTick = 0;
    this.lastSpawn = 0;
    Game.loop().detach(this);
}public void activate() {
    if (this.activated) {
      return;
    }

    this.activated = true;
    this.activationTick = Game.time().now();
    Game.loop().attach(this);
}@Override
  public void update() {
    if (this.isPaused()) {
      return;
    }

    // clear particles if the effect time to life is reached
    if (this.isFinished()) {
      for (EmitterFinishedListener listener : this.finishedListeners) {
        listener.finished(this);
      }

      this.delete();
      return;
    }

    final float updateRatio = (float) this.data().getUpdateRate() / Game.loop().getTickRate();
    for (final Particle p : this.getParticles().stream().collect(Collectors.toList())) {
      if (this.particleCanBeRemoved(p)) {
        // remove dead particles
        this.particles.remove(p);
        continue;
      }

      p.update(this.getOrigin(), updateRatio);
    }

    this.aliveTime = Game.time().since(this.activationTick);
    if ((this.data().getSpawnRate() == 0
        || Game.time().since(this.lastSpawn) >= this.data().getSpawnRate())) {
      this.lastSpawn = Game.time().now();
      this.spawnParticle();
    }
}
}
```
```java
class de.gurkenlabs.litiengine.entities.behavior.IBehaviorController {
public default void attach() {
    Game.loop().attach(this);
}public default void detach() {
    Game.loop().detach(this);
}
}
```
```java
class de.gurkenlabs.litiengine.abilities.AbilityExecution {
AbilityExecution(final Ability ability) {
        this.appliedEffects = new CopyOnWriteArrayList<>();
        this.ability = ability;
        this.executionTicks = Game.time().now();
        this.impactArea = ability.calculateImpactArea();
        this.castLocation = ability.getExecutor().getCenter();
        Nullability.castToNonnull(Game.loop(), "proper initialization done").attach(this);
}@Override
  public void update() {
    // if there a no effects to apply -> unregister this instance and we're done
    if (this.getAbility().getEffects().isEmpty()
        || this.getAbility().getEffects().size() == this.getAppliedEffects().size()) {
      Game.loop().detach(this);
      return;
    }

    // handle all effects from the ability that were not applied yet
    for (final Effect effect : this.getAbility().getEffects()) {
      // if the ability was not executed yet or the delay of the effect is not
      // yet reached
      if (this.getAppliedEffects().contains(effect)
          || Game.time().since(this.getExecutionTicks()) < effect.getDelay()) {
        continue;
      }

      effect.apply(this.getExecutionImpactArea());
      this.getAppliedEffects().add(effect);
    }
}
}
```
```java
class de.gurkenlabs.litiengine.GameWindow$3 {
@Override
            public void windowGainedFocus(WindowEvent e) {
              Game.loop().setTickRate(Game.config().client().getMaxFps());
}@Override
            public void windowLostFocus(WindowEvent e) {
              if (Game.config().graphics().reduceFramesWhenNotFocused()) {
                Game.loop().setTickRate(NONE_FOCUS_MAX_FPS);
              }
}
}
```
```java
class de.gurkenlabs.litiengine.environment.EntitySpawner {
protected void spawnNewEntities() {
    if (this.getSpawnMode() != SpawnMode.CUSTOMSPAWNPOINTS && this.getSpawnPoints().isEmpty()) {
      return;
    }

    switch (this.getSpawnMode()) {
      case ALLSPAWNPOINTS:
        for (int i = 0; i < this.getSpawnPoints().size(); i++) {
          final int index = i;
          Game.loop()
              .perform(
                  this.getSpawnDelay() + this.getSpawnDelay() * i,
                  () -> this.spawn(this.getSpawnPoints().get(index), this.getSpawnAmount()));
        }
        break;
      case ONERANDOMSPAWNPOINT:
        this.spawn(Game.random().choose(this.getSpawnPoints()), this.getSpawnAmount());
        break;
      case RANDOMSPAWNPOINTS:
        for (int i = 0; i < this.getSpawnAmount(); i++) {
          Game.loop()
              .perform(
                  this.getSpawnDelay() + this.getSpawnDelay() * i,
                  () -> this.spawn(Game.random().choose(this.getSpawnPoints()), 1));
        }
        break;
      case CUSTOMSPAWNPOINTS:
        List<Spawnpoint> spawnPoints =
            this.customSpawnpoints != null
                ? this.customSpawnpoints.apply(this)
                : this.getCustomSpawnpoints();

        int index = 0;
        for (Spawnpoint spawn : spawnPoints) {
          Game.loop()
              .perform(
                  this.getSpawnDelay() + this.getSpawnDelay() * index, () -> this.spawn(spawn, 1));
          index++;
        }
        break;
      default:
        break;
    }
}
}
```
```java
class de.gurkenlabs.litiengine.tweening.TweenEngine {
@Override
  public void start() {
    Game.loop().attach(this);
}@Override
  public void terminate() {
    Game.loop().detach(this);
}
}
```
```java
class de.gurkenlabs.litiengine.gui.SpeechBubble {
public void hide() {
    Game.world().environment().removeRenderable(this);
    Game.loop().detach(this);
    if (activeSpeechBubbles.get(this.getEntity()) != null
        && activeSpeechBubbles.remove(this.getEntity()).equals(this)) {
      activeSpeechBubbles.remove(this.getEntity());
    }

    for (SpeechBubbleListener listener : this.listeners) {
      listener.hidden();
    }
}private SpeechBubble(
      final IEntity entity,
      final String text,
      @Nullable SpeechBubbleAppearance appearance,
      @Nullable Font font) {
    if (appearance == null) {
      this.appearance = DEFAULT_APPEARANCE;
    } else {
      this.appearance = appearance;
    }

    final SpeechBubble active = activeSpeechBubbles.get(entity);
    if (active != null) {
      active.hide();
    }
    this.setFont(font);

    this.textBoxWidth = (float) (entity.getWidth() * 4);
    this.entity = entity;

    this.currentText = text;
    this.currentTextDisplayTime = DISPLAYTIME_MIN + text.length() * DISPLAYTIME_PER_LETTER;

    this.lastTextDisplay = Game.time().now();
    this.createBubbleImage();
    entity.getEnvironment().add(this, RenderType.UI);
    Game.loop().attach(this);
    activeSpeechBubbles.put(entity, this);
}
}
```
```java
class de.gurkenlabs.litiengine.entities.Prop {
private void updateAnimationController() {
    IEntityAnimationController<?> controller = this.createAnimationController();
    this.getControllers().addController(controller);
    if (Game.world().environment() != null && Game.world().environment().isLoaded()) {
      Game.loop().attach(controller);
    }
}
}
```
```java
class de.gurkenlabs.litiengine.graphics.FreeFlightCamera {
public FreeFlightCamera(final Point2D focus) {
    this.setFocus(focus);
    this.velocity = DEFAULT_SCROLL_PIXELS_PER_SECOND;
    this.scrollPadding = DEFAULT_SCROLL_PADDING;
    this.setClampToMap(true);

    Game.loop().attach(this);
}private void handleFreeFlightCamera() {
      if (Game.world().environment() == null || Game.world().environment().getMap() == null) {
        return;
      }
  
      final Point2D mouseLocation = Input.mouse().getLocation();
  
      final double scrollSpeed =
          this.getVelocity()
              / (double) Nullability.castToNonnull(Game.loop(), "gameLoop always initialized")
                  .getTickRate()
              * Game.config().input().getMouseSensitivity();
  
      double x = this.getFocus().getX();
      double y = this.getFocus().getY();
  
      double deltaX = 0;
      if (mouseLocation.getX() < this.getScrollPadding()) {
        deltaX -= scrollSpeed;
      } else if (Game.window().getResolution().getWidth() - mouseLocation.getX()
          < this.getScrollPadding()) {
        deltaX += scrollSpeed;
      }
  
      double deltaY = 0;
      if (mouseLocation.getY() < this.getScrollPadding()) {
        deltaY -= scrollSpeed;
      } else if (Game.window().getResolution().getHeight() - mouseLocation.getY()
          < this.getScrollPadding()) {
        deltaY += scrollSpeed;
      }
  
      x += deltaX;
      y += deltaY;
  
      this.setFocus(new Point2D.Double(x, y));
}
}
```
```java
class de.gurkenlabs.litiengine.environment.Environment {
private static void dispose(final Collection<? extends IEntity> entities) {
    for (final IEntity entity : entities) {
      if (entity instanceof IUpdateable) {
        Game.loop().detach((IUpdateable) entity);
      }

      entity.detachControllers();
    }
}private static void loadUpdatableOrEmitterEntity(IEntity entity) {
      if (entity instanceof Emitter) {
        final Emitter emitter = (Emitter) entity;
        if (emitter.isActivateOnInit()) {
          emitter.activate();
        }
      } else if (entity instanceof IUpdateable) {
        Nullability.castToNonnull(Game.loop(), "initialized through init").attach((IUpdateable) entity);
      }
}private void unload(final IEntity entity) {
    // 1. remove from physics engine
    if (entity instanceof ICollisionEntity) {
      Game.physics().remove((ICollisionEntity) entity);
    }

    // 2. unregister from update
    if (entity instanceof IUpdateable) {
      Game.loop().detach((IUpdateable) entity);
    }

    if (entity instanceof IMobileEntity) {
      this.removeGravity((IMobileEntity) entity);
    }

    // 3. detach all controllers
    entity.detachControllers();

    if (entity instanceof Emitter) {
      Emitter em = (Emitter) entity;
      em.deactivate();
    }

    if (this.loaded && (entity instanceof LightSource || entity instanceof StaticShadow)) {
      this.updateLighting(entity);
    }

    entity.removed(this);
}
}
```
```java
class de.gurkenlabs.litiengine.graphics.animation.Animation {
@Override
  public void update() {
    // do nothing if the animation is not playing or the current keyframe is not finished
    if (!this.isPlaying()
        || Game.time().since(this.lastFrameUpdate) < this.getCurrentKeyFrame().getDuration()) {
      return;
    }

    // if we are not looping and the last keyframe is finished, we terminate the animation
    if (!this.isLooping() && this.isLastKeyFrame()) {
      this.terminate();
      return;
    }

    // make sure, we stay inside the keyframe list
    final int newFrameIndex =
        (this.getKeyframes().indexOf(this.currentFrame) + 1) % this.getKeyframes().size();
    final KeyFrame previousFrame = this.currentFrame;
    this.currentFrame = this.getKeyframes().get(newFrameIndex);

    for (KeyFrameListener listener : this.listeners) {
      listener.currentFrameChanged(previousFrame, this.currentFrame);
    }

    this.lastFrameUpdate = Game.loop().getTicks();
}public void restart() {
    this.currentFrame = this.firstFrame;
    this.lastFrameUpdate = Game.loop().getTicks();
}
}
```
```java
class de.gurkenlabs.litiengine.physics.MovementController {
@Override
    public void attach() {
      Nullability.castToNonnull(Game.loop(), "properly initialized before use").attach(this);
}private void handleForces() {
    // clean up forces
    this.activeForces.forEach(
        x -> {
          if (x.hasEnded()) {
            this.activeForces.remove(x);
          }
        });

    if (this.activeForces.isEmpty()) {
      return;
    }

    // disable turn-on-move for force handling
    boolean turn = this.getEntity().turnOnMove();
    this.getEntity().setTurnOnMove(false);
    try {
      double deltaX = 0;
      double deltaY = 0;
      for (final Force force : this.activeForces) {
        if (force.cancelOnReached() && force.hasReached(this.getEntity())) {
          force.end();
          continue;
        }

        final Point2D collisionBoxCenter = this.getEntity().getCollisionBoxCenter();
        final double angle =
            GeometricUtilities.calcRotationAngleInDegrees(collisionBoxCenter, force.getLocation());
        final double strength =
            Game.loop().getDeltaTime() * 0.001f * force.getStrength() * Game.loop().getTimeScale();
        deltaX += GeometricUtilities.getDeltaX(angle, strength);
        deltaY += GeometricUtilities.getDeltaY(angle, strength);
      }

      final Point2D target =
          new Point2D.Double(this.getEntity().getX() + deltaX, this.getEntity().getY() + deltaY);
      final boolean success = Game.physics().move(this.getEntity(), target);
      if (!success) {
        for (final Force force : this.activeForces) {
          if (force.cancelOnCollision()) {
            force.end();
          }
        }
      }
    } finally {
      this.getEntity().setTurnOnMove(turn);
    }
}@Override
  public void detach() {
    Game.loop().detach(this);
}public void handleMovement() {
    if (!this.isMovementAllowed()) {
      this.velocity = 0;
      return;
    }

    // max distance an entity can travel within one tick
    final double maxPixelsPerTick = this.getEntity().getTickVelocity();
    final double deltaTime = Game.loop().getDeltaTime() * Game.loop().getTimeScale();

    final double acceleration =
        this.getEntity().getAcceleration() == 0
            ? maxPixelsPerTick
            : deltaTime / this.getEntity().getAcceleration() * maxPixelsPerTick;
    final double deceleration =
        this.getEntity().getDeceleration() == 0
            ? this.getVelocity()
            : deltaTime / this.getEntity().getDeceleration() * maxPixelsPerTick;

    double dx = this.getDx();
    double dy = this.getDy();
    this.setDx(0);
    this.setDy(0);

    final double deltaVelocity =
        Math.min(Math.sqrt(Math.pow(dx, 2) + Math.pow(dy, 2)), acceleration);
    if (deltaVelocity != 0) {
      double newVelocity = this.getVelocity() + deltaVelocity;
      this.setVelocity(newVelocity);
    } else {
      final double newVelocity = Math.max(0, this.getVelocity() - deceleration);
      this.setVelocity(newVelocity);
      dx = GeometricUtilities.getDeltaX(this.moveAngle);
      dy = GeometricUtilities.getDeltaY(this.moveAngle);
    }

    if (this.getVelocity() == 0) {
      this.moveAngle = 0;
      return;
    }

    // actually move entity
    this.moveEntity(dx, dy);
}
}
```
```java
class de.gurkenlabs.litiengine.graphics.animation.AnimationController {
public void detach() {
    Game.loop().detach(this);
}public void attach() {
    Game.loop().attach(this);
}
}
```
```java
class de.gurkenlabs.litiengine.graphics.Camera {
@Override
  public void setZoom(final float targetZoom, final int delay) {
    if (delay == 0) {

      this.zoom = targetZoom;
      this.targetZoom = 0;
      this.zoomDelay = 0;
      this.zoomTick = 0;
      this.zoomStep = 0;

      final ZoomChangedEvent event = new ZoomChangedEvent(this, targetZoom);
      for (final ZoomChangedListener listener : this.zoomListeners) {
        listener.zoomChanged(event);
      }
    } else {
      this.zoomTick = Game.time().now();
      this.targetZoom = targetZoom;
      this.zoomDelay = delay;

      final double tickduration = 1000 / (double) Game.loop().getTickRate();
      final double tickAmount = delay / tickduration;
      final float totalDelta = this.targetZoom - this.zoom;
      this.zoomStep = tickAmount > 0 ? (float) (totalDelta / tickAmount) : totalDelta;
    }
}
}
```
```java
class de.gurkenlabs.litiengine.Game {
public static synchronized void init(String... args) {
    if (initialized) {
      log().log(Level.INFO, "The game has already been initialized.");
      return;
    }

    log.init();
    handleCommandLineArguments(args);

    config().load();
    Locale.setDefault(new Locale(config().client().getCountry(), config().client().getLanguage()));

    gameLoop = new GameLoop("Main Update Loop", config().client().getMaxFps());
    loop().attach(physics());
    loop().attach(world());

    // setup default exception handling for render and update loop
    setUncaughtExceptionHandler(
        new DefaultUncaughtExceptionHandler(config().client().exitOnError()));

    screenManager = new ScreenManager();
    gameWindow = new GameWindow();

    // initialize  the game window
    window().init();
    world.setCamera(new Camera());

    for (GameListener listener : gameListeners) {
      listener.initialized(args);
    }

    if (!isInNoGUIMode()) {
      window().getRenderComponent().onRendered(g -> metrics().render(g));

      graphics()
          .addEntityRenderedListener(
              e -> DebugRenderer.renderEntityDebugInfo(e.getGraphics(), e.getEntity()));

      window().getRenderComponent().onFpsChanged(fps -> metrics().setFramesPerSecond(fps));
      window()
          .setIcons(
              Arrays.asList(
                  Resources.images().get("liti-logo-x16.png"),
                  Resources.images().get("liti-logo-x20.png"),
                  Resources.images().get("liti-logo-x32.png"),
                  Resources.images().get("liti-logo-x48.png")));

      Input.keyboard()
          .onKeyTyped(
              KeyEvent.VK_PRINTSCREEN,
              key -> {
                // don't take a screenshot if a modifier is active
                if (key.getModifiers() != 0) {
                  return;
                }

                window().getRenderComponent().takeScreenshot();
              });
    }

    Runtime.getRuntime().addShutdownHook(new Thread(Game::terminate, "Shutdown"));

    initialized = true;
}
}
```
```java
class de.gurkenlabs.litiengine.entities.Creature {
protected void updateAnimationController() {
        IEntityAnimationController<?> controller = this.createAnimationController();
        this.getControllers().addController(controller);
        if (Game.world().environment() != null && Game.world().environment().isLoaded()) {
            Nullability.castToNonnull(Game.loop(), "expected to be non-null").attach(controller);
        }
}@Override
  public float getTickVelocity() {
    // pixels per ms multiplied by the passed ms
    // ensure that entities don't travel too far in case of lag
    return Math.min(Game.loop().getDeltaTime(), GameLoop.TICK_DELTATIME_LAG)
        * 0.001F
        * this.getVelocity().get()
        * Game.loop().getTimeScale();
}
}
```
Depth: 2
```java
class de.gurkenlabs.litiengine.environment.GameWorld {
public void clear() {
    this.unloadEnvironment();
    this.environments.clear();
    this.setCamera(null);
    Game.physics().clear();

    this.environmentListeners.clear();
    this.environmentLoadedListeners.clear();
    this.environmentUnloadedListeners.clear();

    this.listeners.clear();
    this.loadedListeners.clear();
    this.unloadedListeners.clear();
}@Nullable
  public Environment loadEnvironment(IMap map) {
    Environment env = this.getEnvironment(map);
    this.loadEnvironment(env);
    return env;
}@Nullable
  public Environment loadEnvironment(String mapName) {
    Environment env = this.getEnvironment(mapName);
    this.loadEnvironment(env);
    return env;
}
}
```
```java
class de.gurkenlabs.litiengine.GameWindow {
GameWindow() {
    this.hostControl = new JFrame();

    this.resolutionChangedListeners = new CopyOnWriteArrayList<>();

    this.renderCanvas = new RenderComponent(Game.config().graphics().getResolution());
    this.cursor = new MouseCursor();
    if (!Game.isInNoGUIMode()) {
      this.hostControl.setBackground(Color.BLACK);
      this.hostControl.add(this.renderCanvas);

      this.initializeEventListeners();

      this.hostControl.setTitle(Game.info().getTitle());
      this.hostControl.setDefaultCloseOperation(WindowConstants.DO_NOTHING_ON_CLOSE);
      initializeWindowEventListeners(this.hostControl);
    }
}
}
```
```java
class de.gurkenlabs.litiengine.GameTime {
public long sinceEnvironmentLoad() {
    return this.since(this.environmentLoaded);
}public long since(final long tick) {
    return toMilliseconds(Game.loop().getTicks() - tick);
}public long sinceGameStart() {
    return this.toMilliseconds(Game.loop().getTicks());
}
}
```
```java
class de.gurkenlabs.litiengine.abilities.effects.Effect {
protected void cease(final EffectApplication appliance) {
    // 1. cease the effect for all affected entities
    for (final ICombatEntity entity : appliance.getAffectedEntities()) {
      this.cease(entity);
    }

    // 2. apply follow up effects
    this.getFollowUpEffects().forEach(followUp -> followUp.apply(appliance.getImpactArea()));
}protected boolean hasEnded(final EffectApplication appliance) {
    final long effectDuration = Game.time().since(appliance.getAppliedTicks());
    return effectDuration > this.getDuration();
}
}
```
```java
class de.gurkenlabs.litiengine.abilities.effects.EffectApplication {
protected EffectApplication(final List<ICombatEntity> affectedEntities, final Shape impactArea) {
    this.applied = Game.time().now();
    this.affectedEntities = affectedEntities;
    this.impactArea = impactArea;
}
}
```
```java
class de.gurkenlabs.litiengine.entities.CombatEntity {
@Override
  public boolean wasHit(int timeSpan) {
    return Game.time().since(this.lastHit) < timeSpan;
}@Override
  public void hit(final int damage, @Nullable final Ability ability) {
    if (this.isDead()) {
      return;
    }

    if (!this.isIndestructible()) {
      this.getHitPoints().modifyBaseValue(new AttributeModifier<>(Modification.SUBTRACT, damage));
    }

    final EntityHitEvent event = new EntityHitEvent(this, ability, damage, this.isDead());

    for (final CombatEntityListener listener : this.listeners) {
      listener.hit(event);
    }

    for (final CombatEntityHitListener listener : this.hitListeners) {
      listener.hit(event);
    }

    if (this.isDead()) {
      this.fireDeathEvent();
      this.setCollision(false);
    }

    this.lastHit = Game.time().now();
}
}
```
```java
class de.gurkenlabs.litiengine.graphics.ImageEffect {
protected ImageEffect(final int ttl, final String name) {
    this.ttl = ttl;
    this.name = name;
    this.aliveTick = Game.time().now();
}@Override
  public long getAliveTime() {
    return Game.time().since(this.aliveTick);
}
}
```
```java
class de.gurkenlabs.litiengine.abilities.AbilityExecution {
AbilityExecution(final Ability ability) {
        this.appliedEffects = new CopyOnWriteArrayList<>();
        this.ability = ability;
        this.executionTicks = Game.time().now();
        this.impactArea = ability.calculateImpactArea();
        this.castLocation = ability.getExecutor().getCenter();
        Nullability.castToNonnull(Game.loop(), "proper initialization done").attach(this);
}@Override
  public void update() {
    // if there a no effects to apply -> unregister this instance and we're done
    if (this.getAbility().getEffects().isEmpty()
        || this.getAbility().getEffects().size() == this.getAppliedEffects().size()) {
      Game.loop().detach(this);
      return;
    }

    // handle all effects from the ability that were not applied yet
    for (final Effect effect : this.getAbility().getEffects()) {
      // if the ability was not executed yet or the delay of the effect is not
      // yet reached
      if (this.getAppliedEffects().contains(effect)
          || Game.time().since(this.getExecutionTicks()) < effect.getDelay()) {
        continue;
      }

      effect.apply(this.getExecutionImpactArea());
      this.getAppliedEffects().add(effect);
    }
}
}
```
```java
class de.gurkenlabs.litiengine.tweening.TweenEngine {
@Override
  public void update() {
    for (final Tweenable target : this.getTweens().keySet()) {
      for (final Tween tween : this.getTweens().get(target).values()) {
        if (tween.hasStopped()) {
          continue;
        }
        final long elapsed = Game.time().since(tween.getStartTime());
        if (elapsed >= tween.getDuration()) {
          tween.stop();
          continue;
        }
        final float[] currentValues = new float[tween.getTargetValues().length];
        for (int i = 0; i < tween.getTargetValues().length; i++) {
          currentValues[i] =
              tween.getStartValues()[i]
                  + tween.getEquation().compute(elapsed / (float) tween.getDuration())
                      * (tween.getTargetValues()[i] - tween.getStartValues()[i]);
        }
        tween.getTarget().setTweenValues(tween.getType(), currentValues);
      }
    }
}
}
```
```java
class de.gurkenlabs.litiengine.gui.SpeechBubble {
public static SpeechBubble create(
      final IEntity entity, final String text, SpeechBubbleAppearance appearance, Font font) {
    return new SpeechBubble(entity, text, appearance, font);
}public static SpeechBubble create(final IEntity entity, final Font font, final String text) {
    SpeechBubbleAppearance app =
        new SpeechBubbleAppearance(
            DEFAULT_APPEARANCE.getForeColor(),
            DEFAULT_APPEARANCE.getBackgroundColor1(),
            DEFAULT_APPEARANCE.getBorderColor(),
            DEFAULT_APPEARANCE.getPadding());
    return new SpeechBubble(entity, text, app, font);
}public static SpeechBubble create(final IEntity entity, final String text) {
    return new SpeechBubble(entity, text, null, GuiProperties.getDefaultFont());
}@Override
  public void update() {
    if (this.currentText == null) {
      this.hide();
      return;
    }

    this.entityCenter = Game.world().camera().getViewportLocation(this.getEntity().getCenter());

    // old text was displayed long enough
    if (this.lastTextDisplay != 0
        && Game.time().since(this.lastTextDisplay) > this.currentTextDisplayTime) {
      this.currentText = null;
      this.lastTextDisplay = 0;
      return;
    }

    // display new text
    if (this.textIndex < this.currentText.length()
        && Game.time().since(this.lastCharPoll) > LETTER_WRITE_DELAY) {
      this.textIndex++;
      this.lastCharPoll = Game.time().now();
      if (this.typeSound != null) {
        Game.audio().playSound(this.typeSound, this.getEntity());
      }
    }

    // continue displaying currently displayed text
}private SpeechBubble(
      final IEntity entity,
      final String text,
      final Sound typeSound,
      SpeechBubbleAppearance appearance,
      Font font) {
    this(entity, text, appearance, font);
    this.typeSound = typeSound;
}private SpeechBubble(
      final IEntity entity,
      final String text,
      @Nullable SpeechBubbleAppearance appearance,
      @Nullable Font font) {
    if (appearance == null) {
      this.appearance = DEFAULT_APPEARANCE;
    } else {
      this.appearance = appearance;
    }

    final SpeechBubble active = activeSpeechBubbles.get(entity);
    if (active != null) {
      active.hide();
    }
    this.setFont(font);

    this.textBoxWidth = (float) (entity.getWidth() * 4);
    this.entity = entity;

    this.currentText = text;
    this.currentTextDisplayTime = DISPLAYTIME_MIN + text.length() * DISPLAYTIME_PER_LETTER;

    this.lastTextDisplay = Game.time().now();
    this.createBubbleImage();
    entity.getEnvironment().add(this, RenderType.UI);
    Game.loop().attach(this);
    activeSpeechBubbles.put(entity, this);
}
}
```
```java
class de.gurkenlabs.litiengine.gui.TextFieldComponent {
@Override
  public void render(final Graphics2D g) {
    super.render(g);
    g.setFont(this.getFont());
    final FontMetrics fm = g.getFontMetrics();

    if (this.isSelected() && Game.time().since(this.lastToggled) > this.flickerDelay) {
      this.cursorVisible = !this.cursorVisible;
      this.lastToggled = Game.time().now();
    }
    if (this.isSelected() && this.cursorVisible) {
      final Rectangle2D cursor =
          new Rectangle2D.Double(
              this.getX() + this.getTextX() + fm.stringWidth(this.getTextToRender(g)),
              this.getY() + this.getTextY(),
              this.getFont().getSize2D() * 3 / 5,
              this.getFont().getSize2D() * 1 / 5);
      g.setColor(this.getAppearance().getForeColor());
      g.fill(cursor);
    }
}
}
```
```java
class de.gurkenlabs.litiengine.entities.Prop {
public Prop(
      final Point2D location, @Nullable final String spritesheetName, final Material material) {
    super();
    this.rotation = Rotation.NONE;
    this.spritesheetName = spritesheetName;
    this.material = material;
    this.setLocation(location);
    this.updateAnimationController();
}public void setSpritesheetName(@Nullable final String spriteName) {
    this.spritesheetName = spriteName;
    this.updateAnimationController();
}
}
```
```java
class de.gurkenlabs.litiengine.tweening.Tween {
public Tween begin() {
    this.started = Game.time().now();
    this.stopped = false;
    return this;
}
}
```
```java
class de.gurkenlabs.litiengine.graphics.emitters.particles.Particle {
public void update(final Point2D emitterOrigin, final float updateRatio) {
    if (this.aliveTick == 0) {
      this.aliveTick = Game.time().now();
    }

    this.aliveTime = Game.time().since(this.aliveTick);
    if (this.timeToLiveReached()) {
      return;
    }

    if (this.colliding) {
      return;
    }

    if (this.getDeltaWidth() != 0) {
      this.width += this.getDeltaWidth() * updateRatio;
    }

    if (this.getDeltaHeight() != 0) {
      this.height += this.getDeltaHeight() * updateRatio;
    }

    if (this.getDeltaAngle() != 0) {
      this.angle += this.getDeltaAngle() * updateRatio;
    }

    // test for ray cast collision
    final float targetX = this.x + this.getVelocityX() * updateRatio;
    final float targetY = this.y + this.getVelocityY() * updateRatio;

    if (targetX == this.x && targetY == this.y) {
      return;
    }

    if (this.checkForCollision(emitterOrigin, targetX, targetY)) {
      return;
    }

    if (this.getVelocityX() != 0) {
      this.x = targetX;
    }

    if (this.getVelocityY() != 0) {
      this.y = targetY;
    }

    if (this.getAccelerationX() != 0) {
      this.velocityX += this.getAccelerationX() * updateRatio;
    }

    if (this.getAccelerationY() != 0) {
      this.velocityY += this.getAccelerationY() * updateRatio;
    }
}
}
```
```java
class de.gurkenlabs.litiengine.graphics.animation.Animation {
@Override
  public void start() {
    this.playing = true;
    if (this.getKeyframes().isEmpty()) {
      return;
    }

    this.restart();
}@Override
  public void update() {
    // do nothing if the animation is not playing or the current keyframe is not finished
    if (!this.isPlaying()
        || Game.time().since(this.lastFrameUpdate) < this.getCurrentKeyFrame().getDuration()) {
      return;
    }

    // if we are not looping and the last keyframe is finished, we terminate the animation
    if (!this.isLooping() && this.isLastKeyFrame()) {
      this.terminate();
      return;
    }

    // make sure, we stay inside the keyframe list
    final int newFrameIndex =
        (this.getKeyframes().indexOf(this.currentFrame) + 1) % this.getKeyframes().size();
    final KeyFrame previousFrame = this.currentFrame;
    this.currentFrame = this.getKeyframes().get(newFrameIndex);

    for (KeyFrameListener listener : this.listeners) {
      listener.currentFrameChanged(previousFrame, this.currentFrame);
    }

    this.lastFrameUpdate = Game.loop().getTicks();
}
}
```
```java
class de.gurkenlabs.litiengine.graphics.animation.AnimationController {
@Override
  public void update() {
    for (final Animation animation : this.getAll()) {
      animation.update();
    }

    if (this.getCurrent() != null && this.getCurrent().isPaused()) {
      return;
    }

    final boolean playbackFinished = this.getCurrent() != null && !this.getCurrent().isPlaying();
    if (playbackFinished) {
      for (final AnimationListener listener : this.listeners) {
        listener.finished(this.getCurrent());
      }
    }

    if (this.getCurrent() == null || playbackFinished) {
      if (this.getDefault() != null) {
        this.play(this.getDefault().getName());
      } else {
        this.currentAnimation = null;
      }
    }
}
}
```
```java
class de.gurkenlabs.litiengine.graphics.RenderComponent {
private void handleFade() {
    if (this.fadeOutStart != -1) {
      final long timePassed = Game.time().since(this.fadeOutStart);
      this.currentAlpha = MathUtilities.clamp(1 - timePassed / (float) this.fadeOutTime, 0, 1);
      if (this.currentAlpha == 0f) {
        this.fadeOutStart = -1;
        this.fadeOutTime = -1;
      }

      return;
    }

    if (this.fadeInStart != -1) {
      final long timePassed = Game.time().since(this.fadeInStart);
      this.currentAlpha = MathUtilities.clamp(timePassed / (float) this.fadeInTime, 0, 1);
      if (this.currentAlpha == 1f) {
        this.fadeInStart = -1;
        this.fadeInTime = -1;
        this.currentAlpha = Float.NaN;
      }
    }
}public void fadeOut(final int ms) {
    this.fadeInStart = -1;
    this.fadeInTime = -1;
    this.fadeOutStart = Game.time().now();
    this.fadeOutTime = ms;
}public void fadeIn(final int ms) {
    this.fadeOutStart = -1;
    this.fadeOutTime = -1;
    this.fadeInStart = Game.time().now();
    this.fadeInTime = ms;
}
}
```
```java
class de.gurkenlabs.litiengine.entities.Trigger {
private boolean activate(final IEntity activator, final int tar) {
    if (!this.isLoaded()
        || this.isOneTimeTrigger && this.isActivated
        || this.getActivationType() == TriggerActivation.COLLISION
            && activator != null
            && this.collisionActivated.contains(activator)) {
      return false;
    }

    if (this.getCooldown() > 0 && Game.time().since(this.lastActivation) < this.getCooldown()) {
      return false;
    }

    List<Integer> triggerTargets = this.getTargets(tar);

    final TriggerEvent te = new TriggerEvent(this, activator, triggerTargets);

    if (!this.checkActivationPredicates(te)) {
      return false;
    }

    this.isActivated = true;
    if (activator != null) {
      this.collisionActivated.add(activator);
    }

    // if we actually have a trigger target, we send the message to the target
    for (final int target : triggerTargets) {
      final IEntity entity = this.getEnvironment().get(target);
      if (entity == null) {
        log.log(
            Level.WARNING,
            "trigger [{0}] was activated, but the trigger target [{1}] could not be found on the environment",
            new Object[] {this, target});
        continue;
      }

      entity.sendMessage(this, this.message);
    }

    // also send the trigger event to all registered consumers
    for (final TriggerActivatedListener listener : this.activatedListeners) {
      listener.activated(te);
    }

    if (this.isOneTimeTrigger) {
      this.getEnvironment().remove(this);
    }

    this.lastActivation = Game.time().now();
    return true;
}
}
```
```java
class de.gurkenlabs.litiengine.graphics.Camera {
private boolean isShakeEffectActive() {
    return this.getShakeTick() != 0
        && Game.time().since(this.getShakeTick()) < this.getShakeDuration();
}@Override
  public void update() {
    if (Game.world().camera() != null && !Game.world().camera().equals(this)) {
      return;
    }

    if (this.targetZoom > 0) {
      if (Game.time().since(this.zoomTick) >= this.zoomDelay) {
        this.zoom = this.targetZoom;
        this.targetZoom = 0;
        this.zoomDelay = 0;
        this.zoomTick = 0;
        this.zoomStep = 0;
      } else {
        this.zoom += this.zoomStep;
      }

      final ZoomChangedEvent event = new ZoomChangedEvent(this, this.getZoom());
      for (final ZoomChangedListener listener : this.zoomListeners) {
        listener.zoomChanged(event);
      }
    }

    if (this.panTime > 0) {
      if (--this.panTime <= 0) {
        this.setFocus(this.targetFocus);
        this.targetFocus = null;
      } else {
        double diff = this.panTime / (this.panTime + 1.0);
        this.focus =
            new Point2D.Double(
                this.focus.getX() * diff + this.targetFocus.getX() * (1.0 - diff),
                this.focus.getY() * diff + this.targetFocus.getY() * (1.0 - diff));
      }
    }

    if (!this.isShakeEffectActive()) {
      this.shakeOffsetX = 0;
      this.shakeOffsetY = 0;
      return;
    }

    if (Game.time().since(this.lastShake) > this.shakeDelay) {
      this.shakeOffsetX = this.getShakeIntensity() * ThreadLocalRandom.current().nextGaussian();
      this.shakeOffsetY = this.getShakeIntensity() * ThreadLocalRandom.current().nextGaussian();
      this.lastShake = Game.time().now();
    }
}@Override
  public void setZoom(final float targetZoom, final int delay) {
    if (delay == 0) {

      this.zoom = targetZoom;
      this.targetZoom = 0;
      this.zoomDelay = 0;
      this.zoomTick = 0;
      this.zoomStep = 0;

      final ZoomChangedEvent event = new ZoomChangedEvent(this, targetZoom);
      for (final ZoomChangedListener listener : this.zoomListeners) {
        listener.zoomChanged(event);
      }
    } else {
      this.zoomTick = Game.time().now();
      this.targetZoom = targetZoom;
      this.zoomDelay = delay;

      final double tickduration = 1000 / (double) Game.loop().getTickRate();
      final double tickAmount = delay / tickduration;
      final float totalDelta = this.targetZoom - this.zoom;
      this.zoomStep = tickAmount > 0 ? (float) (totalDelta / tickAmount) : totalDelta;
    }
}@Override
  public void shake(final double intensity, final int delay, final int shakeDuration) {
    this.shakeTick = Game.time().now();
    this.shakeDelay = delay;
    this.shakeIntensity = intensity;
    this.shakeDuration = shakeDuration;
}
}
```
```java
class de.gurkenlabs.litiengine.entities.Creature {
public void setSpritesheetName(String spritesheetName) {
    if (this.spritesheetName != null && this.spritesheetName.equals(spritesheetName)) {
      return;
    }

    this.spritesheetName = spritesheetName;
    this.updateAnimationController();
}public boolean isIdle() {
    return Game.time().since(this.lastMoved) > IDLE_DELAY;
}@Override
  public void setLocation(final Point2D position) {
    if (this.isDead() || position == null) {
      return;
    }

    final Point2D oldLocation = this.getLocation();
    super.setLocation(position);

    if (Game.hasStarted() && this.isLoaded()) {
      this.lastMoved = Game.time().now();
      this.fireMovedEvent(
          new EntityMovedEvent(
              this, this.getX() - oldLocation.getX(), this.getY() - oldLocation.getY()));
    }
}
}
```
```java
class de.gurkenlabs.litiengine.gui.screens.ScreenManager {
public void display(final String screenName) {
    if (this.current() != null && this.current().getName().equalsIgnoreCase(screenName)) {
      log.log(
          Level.INFO,
          "Skipping displaying of screen {0} because it is already the current screen.",
          screenName);
      return;
    }

    if (this.screens.stream()
        .noneMatch(element -> element.getName().equalsIgnoreCase(screenName))) {
      log.log(
          Level.WARNING,
          "Could not display the screen {0} because there is no screen with the specified name.",
          screenName);
      return;
    }

    Screen screen = this.get(screenName);
    if (screen == null) {
      return;
    }

    this.display(screen);
}public void add(final Screen screen) {
    screen.setWidth(Game.window().getWidth());
    screen.setHeight(Game.window().getHeight());
    this.screens.add(screen);

    if (this.current() == null) {
      this.display(screen);
    }
}public void remove(Screen screen) {
    this.screens.remove(screen);
    if (this.current() == screen) {
      if (!this.screens.isEmpty()) {
        this.display(this.screens.get(0));
      } else {
        this.display((Screen) null);
      }
    }
}public void display(@Nullable final Screen screen) {
      if (Game.hasStarted() && Game.time().since(this.lastScreenChange) < this.getChangeCooldown()) {
        log.log(
            Level.INFO,
            "Skipping displaying of screen {0} because screen changing is currently on cooldown.",
            screen != null ? screen.getName() : "");
        return;
      }
  
      final Screen previous = this.current();
      if (previous != null) {
        previous.suspend();
      }
  
      if (screen != null && !this.screens.contains(screen)) {
        this.screens.add(screen);
      }
  
      this.currentScreen = screen;
      if (!Game.isInNoGUIMode() && this.current() != null) {
        this.current().prepare();
      }
  
      this.lastScreenChange = Nullability.castToNonnull(Game.loop(), "initialized before usage").getTicks();
  
      final ScreenChangedEvent event = new ScreenChangedEvent(this.current(), previous);
      for (final ScreenChangedListener listener : this.screenChangedListeners) {
        listener.changed(event);
      }
}
}
```
```java
class de.gurkenlabs.litiengine.abilities.Ability {
public boolean isOnCooldown() {
    return (this.getCurrentExecution() != null
        && this.getCurrentExecution().getExecutionTicks() > 0
        && Game.time().since(this.getCurrentExecution().getExecutionTicks())
            < this.getAttributes().cooldown().get());
}public boolean isActive() {
    return this.getCurrentExecution() != null
        && Game.time().since(this.getCurrentExecution().getExecutionTicks())
            < this.getAttributes().duration().get();
}@Nullable
  public AbilityExecution cast() {
    if (!this.canCast()) {
      return null;
    }
    this.currentExecution = new AbilityExecution(this);

    for (final AbilityCastListener listener : this.abilityCastListeners) {
      listener.abilityCast(this.currentExecution);
    }

    return this.getCurrentExecution();
}public float getRemainingCooldownInSeconds() {
    if (this.getCurrentExecution() == null
        || this.getExecutor() == null
        || this.getExecutor().isDead()) {
      return 0;
    }

    // calculate cooldown in seconds
    return (float)
        (!this.canCast()
            ? (this.getAttributes().cooldown().get()
                    - Game.time().since(this.getCurrentExecution().getExecutionTicks()))
                * 0.001
            : 0);
}
}
```
```java
class de.gurkenlabs.litiengine.entities.EntityHitEvent {
EntityHitEvent(
      final ICombatEntity hitEntity,
      @Nullable final Ability ability,
      final int damage,
      final boolean kill) {
    super(hitEntity);
    this.executor = ability != null ? ability.getExecutor() : null;
    this.hitEntity = hitEntity;
    this.ability = ability;
    this.damage = damage;
    this.kill = kill;
    this.time = Game.time().now();
}
}
```
```java
class de.gurkenlabs.litiengine.graphics.emitters.Emitter {
public void delete() {
    this.deactivate();
    if (Game.world().environment() != null) {
      Game.world().environment().remove(this);
    }
}public void activate() {
    if (this.activated) {
      return;
    }

    this.activated = true;
    this.activationTick = Game.time().now();
    Game.loop().attach(this);
}@Override
  public void update() {
    if (this.isPaused()) {
      return;
    }

    // clear particles if the effect time to life is reached
    if (this.isFinished()) {
      for (EmitterFinishedListener listener : this.finishedListeners) {
        listener.finished(this);
      }

      this.delete();
      return;
    }

    final float updateRatio = (float) this.data().getUpdateRate() / Game.loop().getTickRate();
    for (final Particle p : this.getParticles().stream().collect(Collectors.toList())) {
      if (this.particleCanBeRemoved(p)) {
        // remove dead particles
        this.particles.remove(p);
        continue;
      }

      p.update(this.getOrigin(), updateRatio);
    }

    this.aliveTime = Game.time().since(this.activationTick);
    if ((this.data().getSpawnRate() == 0
        || Game.time().since(this.lastSpawn) >= this.data().getSpawnRate())) {
      this.lastSpawn = Game.time().now();
      this.spawnParticle();
    }
}
}
```
```java
class de.gurkenlabs.litiengine.GameLoop {
@Override
  public int perform(int delay, Runnable action) {
    final long d = Game.time().toTicks(delay);

    TimedAction a = new TimedAction(this.getTicks() + d, action);
    this.actions.add(a);

    return a.getId();
}
}
```
```java
class de.gurkenlabs.litiengine.environment.EntitySpawner {
protected boolean shouldSpawn() {
    return this.lastSpawnWave == 0
        || Game.time().since(this.lastSpawnWave) >= this.getSpawnInterval();
}@Override
  public void update() {
    if (!this.shouldSpawn()) {
      return;
    }

    this.spawnNewEntities();
    this.lastSpawnWave = Game.time().now();
}
}
```
```java
class de.gurkenlabs.litiengine.graphics.FreeFlightCamera {
@Override
  public void update() {
    this.handleFreeFlightCamera();
}public FreeFlightCamera(double x, double y) {
    this(new Point2D.Double(x, y));
}
}
```
```java
class de.gurkenlabs.litiengine.environment.Environment {
public void unload() {
    if (!this.loaded) {
      return;
    }

    // unregister all updatable entities from the current environment
    for (final IEntity entity : this.allEntities.values()) {
      this.unload(entity);
    }

    this.loaded = false;
    this.fireEvent(l -> l.unloaded(this));
}private static void loadUpdatableOrEmitterEntity(IEntity entity) {
      if (entity instanceof Emitter) {
        final Emitter emitter = (Emitter) entity;
        if (emitter.isActivateOnInit()) {
          emitter.activate();
        }
      } else if (entity instanceof IUpdateable) {
        Nullability.castToNonnull(Game.loop(), "initialized through init").attach((IUpdateable) entity);
      }
}public void clear() {
    Game.physics().clear();

    this.combatEntities.clear();
    this.mobileEntities.clear();
    this.gravityForces.clear();
    this.layerEntities.clear();
    this.entitiesByTag.clear();
    this.allEntities.clear();

    for (RenderType renderType : RenderType.values()) {
      this.miscEntities.get(renderType).clear();
      this.renderListeners.get(renderType).clear();
      this.renderables.get(renderType).clear();
    }

    dispose(this.allEntities.values());
    dispose(this.triggers);
    this.emitters.clear();
    this.colliders.clear();
    this.props.clear();
    this.creatures.clear();
    this.staticShadows.clear();
    this.combatEntities.clear();
    this.mobileEntities.clear();
    this.lightSources.clear();
    this.spawnPoints.clear();
    this.soundSources.clear();
    this.mapAreas.clear();
    this.triggers.clear();

    this.ambientLight = null;
    this.staticShadowLayer = null;

    for (Map<Integer, IEntity> type : this.miscEntities.values()) {
      type.clear();
    }

    this.initialized = false;

    this.fireEvent(l -> l.cleared(this));
}private void load(final IEntity entity) {
    // an entity can only exist on one environment at a time, so remove it from the current one
    if (entity.getEnvironment() != null) {
      entity.getEnvironment().remove(entity);
    }

    // 1. add to physics engine
    loadPhysicsEntity(entity);

    // 2. register for update or activate
    loadUpdatableOrEmitterEntity(entity);

    // 3. if a gravity is defined, add a gravity force to the entity
    if (entity instanceof IMobileEntity && this.getGravity() != 0) {
      this.addGravityForce((IMobileEntity) entity);
    }

    // 4. attach all controllers
    entity.attachControllers();

    if (this.loaded && (entity instanceof LightSource || entity instanceof StaticShadow)) {
      this.updateLighting(entity);
    }

    entity.loaded(this);
}private void unload(final IEntity entity) {
    // 1. remove from physics engine
    if (entity instanceof ICollisionEntity) {
      Game.physics().remove((ICollisionEntity) entity);
    }

    // 2. unregister from update
    if (entity instanceof IUpdateable) {
      Game.loop().detach((IUpdateable) entity);
    }

    if (entity instanceof IMobileEntity) {
      this.removeGravity((IMobileEntity) entity);
    }

    // 3. detach all controllers
    entity.detachControllers();

    if (entity instanceof Emitter) {
      Emitter em = (Emitter) entity;
      em.deactivate();
    }

    if (this.loaded && (entity instanceof LightSource || entity instanceof StaticShadow)) {
      this.updateLighting(entity);
    }

    entity.removed(this);
}public void remove(final IEntity entity) {
    if (entity == null) {
      return;
    }

    this.allEntities.remove(entity.getMapId());
    Iterator<List<IEntity>> iter = this.layerEntities.values().iterator();
    while (iter.hasNext()) {
      List<IEntity> layer = iter.next();
      if (layer.remove(entity) && layer.isEmpty()) {
        iter.remove();
      }
    }
    if (this.miscEntities.get(entity.getRenderType()) != null) {
      this.miscEntities.get(entity.getRenderType()).values().remove(entity);
    }

    for (String tag : entity.getTags()) {
      if (this.getEntitiesByTag().containsKey(tag)) {
        this.getEntitiesByTag().get(tag).remove(entity);

        if (this.getEntitiesByTag().get(tag).isEmpty()) {
          this.getEntitiesByTag().remove(tag);
        }
      }
    }

    if (entity instanceof Emitter) {
      Emitter emitter = (Emitter) entity;
      this.removeEmitter(emitter);
    }

    if (entity instanceof MapArea) {
      this.mapAreas.remove(entity);
    }

    if (entity instanceof Prop) {
      this.props.remove(entity);
    }

    if (entity instanceof Creature) {
      this.creatures.remove(entity);
    }

    if (entity instanceof CollisionBox) {
      this.colliders.remove(entity);
      this.staticShadows.removeIf(x -> x.getOrigin() != null && x.getOrigin().equals(entity));
    }

    if (entity instanceof LightSource) {
      this.lightSources.remove(entity);
      this.updateLighting(entity);
    }

    if (entity instanceof Trigger) {
      this.triggers.remove(entity);
    }

    if (entity instanceof Spawnpoint) {
      this.spawnPoints.remove(entity);
    }
    if (entity instanceof SoundSource) {
      this.soundSources.remove(entity);
    }

    if (entity instanceof StaticShadow) {
      this.staticShadows.remove(entity);
      this.updateLighting(entity);
    }

    if (entity instanceof IMobileEntity) {
      this.mobileEntities.values().remove(entity);
    }

    if (entity instanceof ICombatEntity) {
      this.combatEntities.values().remove(entity);
    }

    this.unload(entity);

    this.fireEntityEvent(l -> l.entityRemoved(entity));
}
}
```
```java
class de.gurkenlabs.litiengine.physics.MovementController {
@Override
  public void update() {
    this.handleForces();
    this.handleMovement();
}
}
```
```java
class de.gurkenlabs.litiengine.Game {
static synchronized void terminate() {
        if (!initialized || gameLoop == null) {
          return;
        }
    
        hasStarted = false;
        initialized = false;
    
        config().save();
        gameLoop.terminate();
        tweenEngine.terminate();
        soundEngine.terminate();
    
        world().clear();
    
        for (final GameListener listener : gameListeners) {
          try {
            listener.terminated();
          } catch (Exception e) {
            log().log(Level.WARNING, "game listener threw an exception during shutdown", e);
          }
        }
    
        gameLoop = null;
        screenManager = null;
        gameWindow = null;
}public static synchronized void start() {
          if (!initialized) {
              throw new IllegalStateException(
                  "The game cannot be started without being first initialized. Call Game.init(...) before Game.start().");
          }
    
          if (gameLoop == null) {
              throw new IllegalStateException(
                  "Game loop is not initialized. Ensure Game.init(...) has been called successfully.");
          }
          
          Nullability.castToNonnull(gameLoop, "gameLoop cannot be null").start();
          tweenEngine.start();
          soundEngine.start();
    
          for (final GameListener listener : gameListeners) {
              listener.started();
          }
    
          hasStarted = true;
}public static synchronized void init(String... args) {
    if (initialized) {
      log().log(Level.INFO, "The game has already been initialized.");
      return;
    }

    log.init();
    handleCommandLineArguments(args);

    config().load();
    Locale.setDefault(new Locale(config().client().getCountry(), config().client().getLanguage()));

    gameLoop = new GameLoop("Main Update Loop", config().client().getMaxFps());
    loop().attach(physics());
    loop().attach(world());

    // setup default exception handling for render and update loop
    setUncaughtExceptionHandler(
        new DefaultUncaughtExceptionHandler(config().client().exitOnError()));

    screenManager = new ScreenManager();
    gameWindow = new GameWindow();

    // initialize  the game window
    window().init();
    world.setCamera(new Camera());

    for (GameListener listener : gameListeners) {
      listener.initialized(args);
    }

    if (!isInNoGUIMode()) {
      window().getRenderComponent().onRendered(g -> metrics().render(g));

      graphics()
          .addEntityRenderedListener(
              e -> DebugRenderer.renderEntityDebugInfo(e.getGraphics(), e.getEntity()));

      window().getRenderComponent().onFpsChanged(fps -> metrics().setFramesPerSecond(fps));
      window()
          .setIcons(
              Arrays.asList(
                  Resources.images().get("liti-logo-x16.png"),
                  Resources.images().get("liti-logo-x20.png"),
                  Resources.images().get("liti-logo-x32.png"),
                  Resources.images().get("liti-logo-x48.png")));

      Input.keyboard()
          .onKeyTyped(
              KeyEvent.VK_PRINTSCREEN,
              key -> {
                // don't take a screenshot if a modifier is active
                if (key.getModifiers() != 0) {
                  return;
                }

                window().getRenderComponent().takeScreenshot();
              });
    }

    Runtime.getRuntime().addShutdownHook(new Thread(Game::terminate, "Shutdown"));

    initialized = true;
}
}
```


Response Format:
Provide the answer in **XML format** as follows:

#### If the method **cannot** return `null` at the specific call site:
```xml
<response>
  <reason><![CDATA[EXPLAIN WHY THE INVOCATION Game.loop() RESULT CANNOT BE NULL.]]></reason>
  <value>NO</value>
</response>

#### If the method can return null at the specific call site:
<response>
  <reason><![CDATA[EXPLAIN WHY THE INVOCATION Game.loop() RESULT CAN BE NULL.]]></reason>
  <value>YES</value>
</response>

#### If you are unsure or If there are any methods that directly or indirectly affect the return value and are not fully disclosed, request their declarations first, in the following format:
<response>
  <reason><![CDATA[EXPLAIN WHY THIS METHOD DECLARATION IS NECESSARY AND WHY YOU CANNOT MAKE A CONFIDENT DECISION WITHOUT IT]]></reason>
  <success>false</success>
  <methods>
    <method>methodName</method>
  </methods>
</response>

Additional Notes:
Be precise in your reasoning.
If a methods return value depends on another method not provided, request its declaration before making a conclusion.
If the method can return null in this case but not in others, explain why it happens specifically for this call.

11:53:28.064 TRACE edu.ucr.cs.riple.core.checkers.nullaway.codefix.ChatGPT.ask
Retrieving response from cache
11:53:28.064 TRACE edu.ucr.cs.riple.core.checkers.nullaway.codefix.Response.tryCreate
Trying to create Response:
```xml
<response>
  <reason><![CDATA[The `Game.loop()` invocation returns the static field `gameLoop`. From the provided initialization method `Game.init`, it is clear that `gameLoop` is initialized during the game initialization process. Specifically, if the game is not already initialized, the `init` method creates a new `GameLoop` instance and assigns it to `gameLoop`. Therefore, unless the game is terminated and the `gameLoop` is set to null intentionally in the `terminate` method, `gameLoop` should always be non-null after initialization. Additionally, numerous usages of `Game.loop()` throughout the codebase imply that the field is expected to be non-null after initialization, otherwise the system would face consistent NullPointerExceptions. Given these factors, at normal operation after initialization, `Game.loop()` should not return null at the specific call site.]]></reason>
  <value>NO</value>
</response>
```
11:53:28.064 TRACE edu.ucr.cs.riple.core.checkers.nullaway.codefix.Response.<init>
Creating Response:
```xml
<response>
  <reason><![CDATA[The `Game.loop()` invocation returns the static field `gameLoop`. From the provided initialization method `Game.init`, it is clear that `gameLoop` is initialized during the game initialization process. Specifically, if the game is not already initialized, the `init` method creates a new `GameLoop` instance and assigns it to `gameLoop`. Therefore, unless the game is terminated and the `gameLoop` is set to null intentionally in the `terminate` method, `gameLoop` should always be non-null after initialization. Additionally, numerous usages of `Game.loop()` throughout the codebase imply that the field is expected to be non-null after initialization, otherwise the system would face consistent NullPointerExceptions. Given these factors, at normal operation after initialization, `Game.loop()` should not return null at the specific call site.]]></reason>
  <value>NO</value>
</response>
```
11:53:28.065 TRACE edu.ucr.cs.riple.core.checkers.nullaway.codefix.Response.<init>
Response created:
Disagreement: The `Game.loop()` invocation returns the static field `gameLoop`. From the provided initialization method `Game.init`, it is clear that `gameLoop` is initialized during the game initialization process. Specifically, if the game is not already initialized, the `init` method creates a new `GameLoop` instance and assigns it to `gameLoop`. Therefore, unless the game is terminated and the `gameLoop` is set to null intentionally in the `terminate` method, `gameLoop` should always be non-null after initialization. Additionally, numerous usages of `Game.loop()` throughout the codebase imply that the field is expected to be non-null after initialization, otherwise the system would face consistent NullPointerExceptions. Given these factors, at normal operation after initialization, `Game.loop()` should not return null at the specific call site.
11:53:28.065 TRACE edu.ucr.cs.riple.core.checkers.nullaway.codefix.AdvancedNullAwayCodeFix.resolveMethodDereferenceError
Method is not returning nullable on call site. Injecting suppression annotation.
11:53:28.065 TRACE edu.ucr.cs.riple.core.checkers.nullaway.codefix.AdvancedNullAwayCodeFix.constructCastToNonnullChange
Constructing cast to nonnull change for reason: The `Game.loop()` invocation returns the static field `gameLoop`. From the provided initialization method `Game.init`, it is clear that `gameLoop` is initialized during the game initialization process. Specifically, if the game is not already initialized, the `init` method creates a new `GameLoop` instance and assigns it to `gameLoop`. Therefore, unless the game is terminated and the `gameLoop` is set to null intentionally in the `terminate` method, `gameLoop` should always be non-null after initialization. Additionally, numerous usages of `Game.loop()` throughout the codebase imply that the field is expected to be non-null after initialization, otherwise the system would face consistent NullPointerExceptions. Given these factors, at normal operation after initialization, `Game.loop()` should not return null at the specific call site.
11:53:28.065 TRACE edu.ucr.cs.riple.core.checkers.nullaway.codefix.ChatGPT.ask
Asking ChatGPT:
For the reason you mentioned earlier:

"The `Game.loop()` invocation returns the static field `gameLoop`. From the provided initialization method `Game.init`, it is clear that `gameLoop` is initialized during the game initialization process. Specifically, if the game is not already initialized, the `init` method creates a new `GameLoop` instance and assigns it to `gameLoop`. Therefore, unless the game is terminated and the `gameLoop` is set to null intentionally in the `terminate` method, `gameLoop` should always be non-null after initialization. Additionally, numerous usages of `Game.loop()` throughout the codebase imply that the field is expected to be non-null after initialization, otherwise the system would face consistent NullPointerExceptions. Given these factors, at normal operation after initialization, `Game.loop()` should not return null at the specific call site."

in the method below, the expression Game.loop() is not nullable at the point it is used.

```java
public long now() {
    return Game.loop().getTicks();
}
```
Please Summarize the reason in max 5 words and rewrite the method so that at the line "    return Game.loop().getTicks();", at the occurrence of: "Game.loop()" is replaced with `Nullability.castToNonnull(Game.loop(), summary of reason)`
Replace "REASON" with the exact reason summary I provide to you (maximum 5 words), not with a generic explanation like "checked to be nonnull".
see the example below, for expression `foo.getBar()`, to wrap it with `Nullability.castToNonnull(foo.getBar(), "reason")`.

```java
public t(){
    String l = foo.getBar();
}
```

will be:
```java
public t(){
    String l = Nullability.castToNonnull(foo.getBar(), "checked to be nonnull");
}
```

### Instructions:

Do not import any additional classes.

Do not add Java comments.

Only modify relevant lines as required.

Return only the modified method wrapped in the XML format shown below.

Place the Java code inside the <code> tag using a CDATA block with ```java formatting.

Just give me the fixed code snippet in XML format in <response> tag like the example below. I will apply the fix to my codebase. Do not import any additional libraries or classes or add java comments. If you can provide the fixed code snippet, please provide it in the following format and place the code snippet in the <code> tag within ```java block.
<response>
  <success>true</success>
  <code><![CDATA[
  ```java
  Your fixed code snippet here
  ```
    ]]>
  </code>
</response>

11:53:28.065 TRACE edu.ucr.cs.riple.core.checkers.nullaway.codefix.ChatGPT.ask
Retrieving response from cache
11:53:28.065 TRACE edu.ucr.cs.riple.core.checkers.nullaway.codefix.Response.tryCreate
Trying to create Response:
<response>
  <success>true</success>
  <code><![CDATA[
  ```java
  public long now() {
      return Nullability.castToNonnull(Game.loop(), "initialized after initialization").getTicks();
  }
  ```
    ]]>
  </code>
</response>
11:53:28.066 TRACE edu.ucr.cs.riple.core.checkers.nullaway.codefix.Response.<init>
Creating Response:
<response>
  <success>true</success>
  <code><![CDATA[
  ```java
  public long now() {
      return Nullability.castToNonnull(Game.loop(), "initialized after initialization").getTicks();
  }
  ```
    ]]>
  </code>
</response>
11:53:28.066 TRACE edu.ucr.cs.riple.core.checkers.nullaway.codefix.Response.<init>
Response created:
public long now() {
      return Nullability.castToNonnull(Game.loop(), "initialized after initialization").getTicks();
  }
11:53:28.066 TRACE edu.ucr.cs.riple.core.checkers.nullaway.codefix.ChatGPT.fixDereferenceByAddingCastToNonnull
Fixing the error by adding castToNonnull
11:53:28.067 TRACE edu.ucr.cs.riple.core.checkers.nullaway.codefix.AdvancedNullAwayCodeFix.fixTriggeredErrorsForLocation
Resolving unresolvable error for triggered error: Type='DEREFERENCE_NULLABLE', message='dereferenced expression Game.loop() is @Nullable'
/home/nima/Developer/nullness-benchmarks/litiengine/src/de/gurkenlabs/litiengine/entities/behavior/IBehaviorController.java:9
    Game.loop().detach(this);
11:53:28.067 TRACE edu.ucr.cs.riple.core.checkers.nullaway.codefix.AdvancedNullAwayCodeFix.fix
Fixing error: Type='DEREFERENCE_NULLABLE', message='dereferenced expression Game.loop() is @Nullable'
/home/nima/Developer/nullness-benchmarks/litiengine/src/de/gurkenlabs/litiengine/entities/behavior/IBehaviorController.java:9
    Game.loop().detach(this);
11:53:28.067 TRACE edu.ucr.cs.riple.core.checkers.nullaway.codefix.AdvancedNullAwayCodeFix.resolveDereferenceError
Resolving dereference error: Type='DEREFERENCE_NULLABLE', message='dereferenced expression Game.loop() is @Nullable'
/home/nima/Developer/nullness-benchmarks/litiengine/src/de/gurkenlabs/litiengine/entities/behavior/IBehaviorController.java:9
    Game.loop().detach(this);
11:53:28.067 TRACE edu.ucr.cs.riple.core.checkers.nullaway.codefix.AdvancedNullAwayCodeFix.resolveDereferenceError
Checking nullability possibility at error point
11:53:28.067 TRACE edu.ucr.cs.riple.core.checkers.nullaway.codefix.ChatGPT.checkNullabilityPossibilityAtErrorPoint
Asking if the expression can be null at error point point
11:53:28.067 TRACE edu.ucr.cs.riple.core.checkers.nullaway.codefix.ChatGPT.ask
Asking ChatGPT:
In the method below, is there a possibility that the expression "Game.loop()" at line "Game.loop().detach(this);" is null?
public default void detach() {
    Game.loop().detach(this);
}
Give a single-word answer in XML format. If it is possible for the expression to be null, respond with:
```xml
<response>
    <reason><![CDATA[YOUR REASON]]></reason>
    <value>YES</value>
</response>
```
If it is not possible for the expression to be null, respond with:
```xml
<response>
    <reason><![CDATA[YOUR REASON]]></reason>
    <value>NO</value>
</response>
```
If you are unsure or need more information, respond with where you can ask for more details or what specific information you need.

If additional information is required, list each request inside a `<request>` tag. If no additional information is needed, omit the `<requests>` section.

Respond with:
```xml
<response>
    <reason><![CDATA[YOUR REASON]]></reason>
    <value>UNKNOWN</value>
    <!-- Include <requests> only if additional information is needed -->
    <requests>
        <request><![CDATA[YOUR REQUEST 1]]></request>
        <request><![CDATA[YOUR REQUEST 2]]></request>
    </requests>
</response>
```
11:53:28.067 TRACE edu.ucr.cs.riple.core.checkers.nullaway.codefix.ChatGPT.ask
Retrieving response from cache
11:53:28.067 TRACE edu.ucr.cs.riple.core.checkers.nullaway.codefix.Response.tryCreate
Trying to create Response:
```xml
<response>
    <reason><![CDATA[It is unclear from the provided snippet whether Game.loop() can return a null value, as it depends on the implementation details of the Game class and its loop() method, which are not provided.]]></reason>
    <value>UNKNOWN</value>
    <requests>
        <request><![CDATA[Provide the implementation of the Game class, specifically the loop() method.]]></request>
    </requests>
</response>
```
11:53:28.067 TRACE edu.ucr.cs.riple.core.checkers.nullaway.codefix.Response.<init>
Creating Response:
```xml
<response>
    <reason><![CDATA[It is unclear from the provided snippet whether Game.loop() can return a null value, as it depends on the implementation details of the Game class and its loop() method, which are not provided.]]></reason>
    <value>UNKNOWN</value>
    <requests>
        <request><![CDATA[Provide the implementation of the Game class, specifically the loop() method.]]></request>
    </requests>
</response>
```
11:53:28.068 TRACE edu.ucr.cs.riple.core.checkers.nullaway.codefix.Response.<init>
Response created:
Unknown: It is unclear from the provided snippet whether Game.loop() can return a null value, as it depends on the implementation details of the Game class and its loop() method, which are not provided.
11:53:28.068 TRACE edu.ucr.cs.riple.core.checkers.nullaway.codefix.AdvancedNullAwayCodeFix.resolveMethodDereferenceError
Resolving method dereference error.
11:53:28.068 TRACE edu.ucr.cs.riple.core.checkers.nullaway.codefix.AdvancedNullAwayCodeFix.resolveMethodDereferenceError
Method is in annotated package. Checking if the method is returning nullable.
11:53:28.068 TRACE edu.ucr.cs.riple.core.checkers.nullaway.codefix.AdvancedNullAwayCodeFix.investigateMethodReturnNullability
Checking if the method is returning nullable.
11:53:28.070 TRACE edu.ucr.cs.riple.core.checkers.nullaway.codefix.ChatGPT.checkIfMethodIsReturningNullable
Asking if the method is returning nullable: loop()
11:53:28.072 TRACE edu.ucr.cs.riple.core.checkers.nullaway.codefix.ChatGPT.ask
Asking ChatGPT:
In the method below, is there a possibility that the method returns null based only on its body? Consider the following points:

- The method may have multiple return paths; consider all return statements.
- If the method calls another method, do not assume its return value unless its full declaration is provided. Request its declaration if needed.
- The method may throw an exception instead of returning null. An exception path should not be considered a null return.
- Ensure you request the declarations of any methods whose return values directly or indirectly impact this methods return value before making a conclusion.
- Carefully analyze all conditions and prior operations that may guarantee a non-null return value.

@Nullable public static IGameLoop loop() {
    return gameLoop;
}

Here are the method definitions in addition to the method inquired:

Depth: 0
```java
class de.gurkenlabs.litiengine.Game {
@Nullable public static IGameLoop loop() {
    return gameLoop;
}
}
```


Response Format:
Provide the answer in **XML format** as follows:

#### If the method **cannot** return `null`:
```xml
<response>
  <reason><![CDATA[EXPLAIN WHY THE METHOD CANNOT RETURN NULL]]></reason>
  <value>NO</value>
</response>
```

#### If the method can return null:
```xml
<response>
  <reason><![CDATA[EXPLAIN WHY THE METHOD CAN RETURN NULL]]></reason>
  <value>YES</value>
</response>
```

#### If you are unsure or need more information, respond with where you can ask for more details or what specific information you need.

#### If you are unsure or If there are any methods that directly or indirectly affect the return value and are not fully disclosed, request their declarations first, in the following format:
<response>
  <reason><![CDATA[YOUR REASON]]></reason>
  <value>UNKNOWN</value>
  <methods>
    <method>methodName</method>
  </methods>
</response>

If additional information is required other than method declaration, list each request inside a `<request>` tag. If no additional information is needed, omit the `<requests>` section.

Respond with:
```xml
<response>
    <reason><![CDATA[YOUR REASON]]></reason>
    <value>UNKNOWN</value>
    <!-- Include <requests> only if additional information is needed -->
    <requests>
        <request><![CDATA[YOUR REQUEST 1]]></request>
        <request><![CDATA[YOUR REQUEST 2]]></request>
    </requests>
</response>
```

Additional Notes:
Be precise in your reasoning.
If a methods return value depends on another method not provided, request its declaration before making a conclusion.
If the method can return null in some cases but not others, explain under what conditions it can happen.

11:53:28.072 TRACE edu.ucr.cs.riple.core.checkers.nullaway.codefix.ChatGPT.ask
Retrieving response from cache
11:53:28.072 TRACE edu.ucr.cs.riple.core.checkers.nullaway.codefix.Response.tryCreate
Trying to create Response:
```xml
<response>
  <reason><![CDATA[The method `loop` returns the variable `gameLoop`. Without the initialization or assignment details of `gameLoop`, it's unclear whether it can be null. The possibility of `gameLoop` being uninitialized or set to null elsewhere in the program means `loop` could potentially return null. Further information on `gameLoop` is required.]]></reason>
  <value>UNKNOWN</value>
  <requests>
    <request><![CDATA[Please provide the declaration and initialization of the variable `gameLoop` in the class `de.gurkenlabs.litiengine.Game`.]]></request>
  </requests>
</response>
```
11:53:28.072 TRACE edu.ucr.cs.riple.core.checkers.nullaway.codefix.Response.<init>
Creating Response:
```xml
<response>
  <reason><![CDATA[The method `loop` returns the variable `gameLoop`. Without the initialization or assignment details of `gameLoop`, it's unclear whether it can be null. The possibility of `gameLoop` being uninitialized or set to null elsewhere in the program means `loop` could potentially return null. Further information on `gameLoop` is required.]]></reason>
  <value>UNKNOWN</value>
  <requests>
    <request><![CDATA[Please provide the declaration and initialization of the variable `gameLoop` in the class `de.gurkenlabs.litiengine.Game`.]]></request>
  </requests>
</response>
```
11:53:28.073 TRACE edu.ucr.cs.riple.core.checkers.nullaway.codefix.Response.<init>
Response created:
Unknown: The method `loop` returns the variable `gameLoop`. Without the initialization or assignment details of `gameLoop`, it's unclear whether it can be null. The possibility of `gameLoop` being uninitialized or set to null elsewhere in the program means `loop` could potentially return null. Further information on `gameLoop` is required.
11:53:28.073 TRACE edu.ucr.cs.riple.core.checkers.nullaway.codefix.AdvancedNullAwayCodeFix.investigateMethodReturnNullability
Could not determine the nullability and model did not ask for any method.
11:53:28.073 TRACE edu.ucr.cs.riple.core.checkers.nullaway.codefix.ChatGPT.checkIfMethodIsReturningNullableOnCallSite
Asking if the method is returning nullable on the call site: Game.loop()
11:53:28.314 TRACE edu.ucr.cs.riple.core.checkers.nullaway.codefix.ChatGPT.ask
Asking ChatGPT:
In the method below, is there a possibility that the method returns null at the given call site?

```java
@Nullable public static IGameLoop loop() {
    return gameLoop;
}
```

## Guidelines:
- The method may have multiple return paths; consider all return statements.
- If the method calls another method, do not assume its return value unless its full declaration is provided. Request its declaration if needed.
- The method may throw an exception instead of returning null. An exception path should not be considered a null return.
- Ensure you request the declarations of any methods whose return values directly or indirectly impact this methods return value before making a conclusion.
- If the method returns a value that is determined by a parameter, evaluate based on the actual argument at the given call site.
- Analyze based only on the specific invocation provided. Do not generalize to all possible inputs.- If the return value is guaranteed to be non-null at the call site, the answer should be a definitive NO.
- Do not generalize based on all possible inputsyour answer must be based only on the given invocation.
- Focus only on the given call site, not all possible invocations.

### call site:
Game.loop()

Here are the method definitions and the call chain for this method, showing the sequence of calls from the method to its callers at each depth level:

Depth: 0
```java
class de.gurkenlabs.litiengine.Game {
@Nullable public static IGameLoop loop() {
    return gameLoop;
}
}
```
Depth: 1
```java
class de.gurkenlabs.litiengine.environment.GameWorld {
public void loadEnvironment(@Nullable final Environment env) {
    Lock lock = Game.loop().getLock();
    lock.lock();
    try {
      unloadEnvironment();
      this.environment = env;
      if (env != null) {
        this.addEnvironment(env);

        if (env.getGravity() == 0 && this.gravity() != 0) {
          env.setGravity(this.gravity());
        }

        env.load();
        for (final EnvironmentLoadedListener listener : this.loadedListeners) {
          listener.loaded(env);
        }

        // call map specific listeners
        String mapName = getMapName(env);
        if (mapName != null && this.environmentLoadedListeners.containsKey(mapName)) {

          // for the default camera we center the camera on the environment
          if (this.camera().getClass().equals(Camera.class)) {
            camera().setFocus(env.getCenter());
          }

          for (EnvironmentLoadedListener listener : this.environmentLoadedListeners.get(mapName)) {
            listener.loaded(env);
          }
        }
      }
    } finally {
      lock.unlock();
    }
}public void setCamera(@Nullable final ICamera cam) {
      if (this.camera() != null) {
        Game.loop().detach(camera);
      }
  
      camera = cam;
  
      if (cam != null && !Game.isInNoGUIMode()) {
        Nullability.castToNonnull(Game.loop(), "synchronized initialization").attach(cam);
        cam.updateFocus();
      }
}
}
```
```java
class de.gurkenlabs.litiengine.entities.behavior.EntityNavigator {
public EntityNavigator(final IMobileEntity entity, final PathFinder pathFinder) {
    this.cancelNavigationConditions = new CopyOnWriteArrayList<>();
    this.listeners = new CopyOnWriteArrayList<>();
    this.entity = entity;
    this.pathFinder = pathFinder;
    this.setAcceptableError(DEFAULT_ACCEPTABLE_ERROR);
    Game.loop().attach(this);
}
}
```
```java
class de.gurkenlabs.litiengine.GameWindow {
private static void initializeWindowEventListeners(Window window) {
  
      window.addWindowStateListener(
          e -> {
            if (e.getNewState() == Frame.ICONIFIED) {
              Nullability.castToNonnull(Game.loop(), "initialized by Game.init").setTickRate(ICONIFIED_MAX_FPS);
            } else {
              Game.loop().setTickRate(Game.config().client().getMaxFps());
            }
          });
  
      window.addWindowFocusListener(
          new WindowFocusListener() {
            @Override
            public void windowLostFocus(WindowEvent e) {
              if (Game.config().graphics().reduceFramesWhenNotFocused()) {
                Game.loop().setTickRate(NONE_FOCUS_MAX_FPS);
              }
            }
  
            @Override
            public void windowGainedFocus(WindowEvent e) {
              Game.loop().setTickRate(Game.config().client().getMaxFps());
            }
          });
  
      window.addWindowListener(
          new WindowAdapter() {
            @Override
            public void windowClosing(final WindowEvent event) {
              Game.exit();
            }
          });
}
}
```
```java
class de.gurkenlabs.litiengine.gui.screens.ScreenManager {
public void display(@Nullable final Screen screen) {
      if (Game.hasStarted() && Game.time().since(this.lastScreenChange) < this.getChangeCooldown()) {
        log.log(
            Level.INFO,
            "Skipping displaying of screen {0} because screen changing is currently on cooldown.",
            screen != null ? screen.getName() : "");
        return;
      }
  
      final Screen previous = this.current();
      if (previous != null) {
        previous.suspend();
      }
  
      if (screen != null && !this.screens.contains(screen)) {
        this.screens.add(screen);
      }
  
      this.currentScreen = screen;
      if (!Game.isInNoGUIMode() && this.current() != null) {
        this.current().prepare();
      }
  
      this.lastScreenChange = Nullability.castToNonnull(Game.loop(), "initialized before usage").getTicks();
  
      final ScreenChangedEvent event = new ScreenChangedEvent(this.current(), previous);
      for (final ScreenChangedListener listener : this.screenChangedListeners) {
        listener.changed(event);
      }
}
}
```
```java
class de.gurkenlabs.litiengine.abilities.effects.Effect {
@Override
  public void update() {

    for (final Iterator<EffectApplication> iterator = this.getActiveAppliances().iterator();
        iterator.hasNext(); ) {
      final EffectApplication appliance = iterator.next();
      // if the effect duration is reached
      if (this.hasEnded(appliance)) {

        iterator.remove();
        this.cease(appliance);
      }
    }

    // 4. unregister if all appliances are finished
    if (this.getActiveAppliances().isEmpty()) {
      Game.loop().detach(this);
    }
}public void apply(final Shape impactArea) {
    final List<ICombatEntity> affected = this.lookForAffectedEntities(impactArea);
    for (final ICombatEntity affectedEntity : affected) {
      this.apply(affectedEntity);
    }

    this.appliances.add(new EffectApplication(affected, impactArea));

    // if it is the first appliance -> register for update
    if (this.appliances.size() == 1) {
      Game.loop().attach(this);
    }
}
}
```
```java
class de.gurkenlabs.litiengine.GameTime {
public long toTicks(final int milliseconds) {
    return this.toTicks(milliseconds, Game.loop().getTickRate());
}public long since(final long tick) {
    return toMilliseconds(Game.loop().getTicks() - tick);
}public long now() {
        return Nullability.castToNonnull(Game.loop(), "initialized after initialization").getTicks();
}public long sinceGameStart() {
    return this.toMilliseconds(Game.loop().getTicks());
}@Override
    public void loaded(Environment environment) {
      environmentLoaded = Nullability.castToNonnull(Game.loop(), "properly initialized and started").getTicks();
}public long toMilliseconds(final long ticks) {
    return this.toMilliseconds(ticks, Game.loop().getTickRate());
}
}
```
```java
class de.gurkenlabs.litiengine.GameMetrics {
@Override
    public void render(final Graphics2D g) {
      this.updateMetrics();
  
      if (!Game.config().client().showGameMetrics()) {
        return;
      }
  
      this.currentOffsetY = 0;
  
      g.setColor(this.renderColor);
  
      // render client metrics
      this.drawTitle(g, "[client]");
      this.drawMetric(g, "fps       : " + this.getFramesPerSecond());
      this.drawMetric(g, "max fps   : " + this.maxFramesPerSecond);
  
      // Use Nullability.castToNonnull to prevent NullAway warning
      this.drawMetric(g, "updatables: " + Nullability.castToNonnull(Game.loop(), "gameLoop always initialized").getUpdatableCount());
  
      // render jvm metrics if debug is enabled
      if (Game.config().debug().isDebugEnabled()) {
        this.drawTitle(g, "[jvm]");
        this.drawMetric(g, "java      : " + this.javaVersion);
        this.drawMetric(g, "memory    : " + String.format("%-5.5s", this.usedMemory) + " MB");
        this.drawMetric(g, "threads   : " + Thread.activeCount());
      }
  
      // render rendering metrics
      if (!this.renderMetrics.isEmpty()) {
        this.drawTitle(g, "[update]");
  
        for (RenderMetrics metric : this.renderMetrics) {
          this.drawMetric(g, metric.toString());
        }
  
        this.renderMetrics.clear();
      }
}
}
```
```java
class de.gurkenlabs.litiengine.graphics.emitters.Emitter {
public void deactivate() {
    if (!this.activated) {
      return;
    }

    this.activated = false;
    this.getParticles().clear();
    this.aliveTime = 0;
    this.activationTick = 0;
    this.lastSpawn = 0;
    Game.loop().detach(this);
}public void activate() {
    if (this.activated) {
      return;
    }

    this.activated = true;
    this.activationTick = Game.time().now();
    Game.loop().attach(this);
}@Override
  public void update() {
    if (this.isPaused()) {
      return;
    }

    // clear particles if the effect time to life is reached
    if (this.isFinished()) {
      for (EmitterFinishedListener listener : this.finishedListeners) {
        listener.finished(this);
      }

      this.delete();
      return;
    }

    final float updateRatio = (float) this.data().getUpdateRate() / Game.loop().getTickRate();
    for (final Particle p : this.getParticles().stream().collect(Collectors.toList())) {
      if (this.particleCanBeRemoved(p)) {
        // remove dead particles
        this.particles.remove(p);
        continue;
      }

      p.update(this.getOrigin(), updateRatio);
    }

    this.aliveTime = Game.time().since(this.activationTick);
    if ((this.data().getSpawnRate() == 0
        || Game.time().since(this.lastSpawn) >= this.data().getSpawnRate())) {
      this.lastSpawn = Game.time().now();
      this.spawnParticle();
    }
}
}
```
```java
class de.gurkenlabs.litiengine.entities.behavior.IBehaviorController {
public default void attach() {
    Game.loop().attach(this);
}public default void detach() {
    Game.loop().detach(this);
}
}
```
```java
class de.gurkenlabs.litiengine.abilities.AbilityExecution {
AbilityExecution(final Ability ability) {
        this.appliedEffects = new CopyOnWriteArrayList<>();
        this.ability = ability;
        this.executionTicks = Game.time().now();
        this.impactArea = ability.calculateImpactArea();
        this.castLocation = ability.getExecutor().getCenter();
        Nullability.castToNonnull(Game.loop(), "proper initialization done").attach(this);
}@Override
  public void update() {
    // if there a no effects to apply -> unregister this instance and we're done
    if (this.getAbility().getEffects().isEmpty()
        || this.getAbility().getEffects().size() == this.getAppliedEffects().size()) {
      Game.loop().detach(this);
      return;
    }

    // handle all effects from the ability that were not applied yet
    for (final Effect effect : this.getAbility().getEffects()) {
      // if the ability was not executed yet or the delay of the effect is not
      // yet reached
      if (this.getAppliedEffects().contains(effect)
          || Game.time().since(this.getExecutionTicks()) < effect.getDelay()) {
        continue;
      }

      effect.apply(this.getExecutionImpactArea());
      this.getAppliedEffects().add(effect);
    }
}
}
```
```java
class de.gurkenlabs.litiengine.GameWindow$3 {
@Override
            public void windowGainedFocus(WindowEvent e) {
              Game.loop().setTickRate(Game.config().client().getMaxFps());
}@Override
            public void windowLostFocus(WindowEvent e) {
              if (Game.config().graphics().reduceFramesWhenNotFocused()) {
                Game.loop().setTickRate(NONE_FOCUS_MAX_FPS);
              }
}
}
```
```java
class de.gurkenlabs.litiengine.environment.EntitySpawner {
protected void spawnNewEntities() {
    if (this.getSpawnMode() != SpawnMode.CUSTOMSPAWNPOINTS && this.getSpawnPoints().isEmpty()) {
      return;
    }

    switch (this.getSpawnMode()) {
      case ALLSPAWNPOINTS:
        for (int i = 0; i < this.getSpawnPoints().size(); i++) {
          final int index = i;
          Game.loop()
              .perform(
                  this.getSpawnDelay() + this.getSpawnDelay() * i,
                  () -> this.spawn(this.getSpawnPoints().get(index), this.getSpawnAmount()));
        }
        break;
      case ONERANDOMSPAWNPOINT:
        this.spawn(Game.random().choose(this.getSpawnPoints()), this.getSpawnAmount());
        break;
      case RANDOMSPAWNPOINTS:
        for (int i = 0; i < this.getSpawnAmount(); i++) {
          Game.loop()
              .perform(
                  this.getSpawnDelay() + this.getSpawnDelay() * i,
                  () -> this.spawn(Game.random().choose(this.getSpawnPoints()), 1));
        }
        break;
      case CUSTOMSPAWNPOINTS:
        List<Spawnpoint> spawnPoints =
            this.customSpawnpoints != null
                ? this.customSpawnpoints.apply(this)
                : this.getCustomSpawnpoints();

        int index = 0;
        for (Spawnpoint spawn : spawnPoints) {
          Game.loop()
              .perform(
                  this.getSpawnDelay() + this.getSpawnDelay() * index, () -> this.spawn(spawn, 1));
          index++;
        }
        break;
      default:
        break;
    }
}
}
```
```java
class de.gurkenlabs.litiengine.tweening.TweenEngine {
@Override
  public void start() {
    Game.loop().attach(this);
}@Override
  public void terminate() {
    Game.loop().detach(this);
}
}
```
```java
class de.gurkenlabs.litiengine.gui.SpeechBubble {
public void hide() {
    Game.world().environment().removeRenderable(this);
    Game.loop().detach(this);
    if (activeSpeechBubbles.get(this.getEntity()) != null
        && activeSpeechBubbles.remove(this.getEntity()).equals(this)) {
      activeSpeechBubbles.remove(this.getEntity());
    }

    for (SpeechBubbleListener listener : this.listeners) {
      listener.hidden();
    }
}private SpeechBubble(
      final IEntity entity,
      final String text,
      @Nullable SpeechBubbleAppearance appearance,
      @Nullable Font font) {
    if (appearance == null) {
      this.appearance = DEFAULT_APPEARANCE;
    } else {
      this.appearance = appearance;
    }

    final SpeechBubble active = activeSpeechBubbles.get(entity);
    if (active != null) {
      active.hide();
    }
    this.setFont(font);

    this.textBoxWidth = (float) (entity.getWidth() * 4);
    this.entity = entity;

    this.currentText = text;
    this.currentTextDisplayTime = DISPLAYTIME_MIN + text.length() * DISPLAYTIME_PER_LETTER;

    this.lastTextDisplay = Game.time().now();
    this.createBubbleImage();
    entity.getEnvironment().add(this, RenderType.UI);
    Game.loop().attach(this);
    activeSpeechBubbles.put(entity, this);
}
}
```
```java
class de.gurkenlabs.litiengine.entities.Prop {
private void updateAnimationController() {
    IEntityAnimationController<?> controller = this.createAnimationController();
    this.getControllers().addController(controller);
    if (Game.world().environment() != null && Game.world().environment().isLoaded()) {
      Game.loop().attach(controller);
    }
}
}
```
```java
class de.gurkenlabs.litiengine.graphics.FreeFlightCamera {
public FreeFlightCamera(final Point2D focus) {
    this.setFocus(focus);
    this.velocity = DEFAULT_SCROLL_PIXELS_PER_SECOND;
    this.scrollPadding = DEFAULT_SCROLL_PADDING;
    this.setClampToMap(true);

    Game.loop().attach(this);
}private void handleFreeFlightCamera() {
      if (Game.world().environment() == null || Game.world().environment().getMap() == null) {
        return;
      }
  
      final Point2D mouseLocation = Input.mouse().getLocation();
  
      final double scrollSpeed =
          this.getVelocity()
              / (double) Nullability.castToNonnull(Game.loop(), "gameLoop always initialized")
                  .getTickRate()
              * Game.config().input().getMouseSensitivity();
  
      double x = this.getFocus().getX();
      double y = this.getFocus().getY();
  
      double deltaX = 0;
      if (mouseLocation.getX() < this.getScrollPadding()) {
        deltaX -= scrollSpeed;
      } else if (Game.window().getResolution().getWidth() - mouseLocation.getX()
          < this.getScrollPadding()) {
        deltaX += scrollSpeed;
      }
  
      double deltaY = 0;
      if (mouseLocation.getY() < this.getScrollPadding()) {
        deltaY -= scrollSpeed;
      } else if (Game.window().getResolution().getHeight() - mouseLocation.getY()
          < this.getScrollPadding()) {
        deltaY += scrollSpeed;
      }
  
      x += deltaX;
      y += deltaY;
  
      this.setFocus(new Point2D.Double(x, y));
}
}
```
```java
class de.gurkenlabs.litiengine.environment.Environment {
private static void dispose(final Collection<? extends IEntity> entities) {
    for (final IEntity entity : entities) {
      if (entity instanceof IUpdateable) {
        Game.loop().detach((IUpdateable) entity);
      }

      entity.detachControllers();
    }
}private static void loadUpdatableOrEmitterEntity(IEntity entity) {
      if (entity instanceof Emitter) {
        final Emitter emitter = (Emitter) entity;
        if (emitter.isActivateOnInit()) {
          emitter.activate();
        }
      } else if (entity instanceof IUpdateable) {
        Nullability.castToNonnull(Game.loop(), "initialized through init").attach((IUpdateable) entity);
      }
}private void unload(final IEntity entity) {
    // 1. remove from physics engine
    if (entity instanceof ICollisionEntity) {
      Game.physics().remove((ICollisionEntity) entity);
    }

    // 2. unregister from update
    if (entity instanceof IUpdateable) {
      Game.loop().detach((IUpdateable) entity);
    }

    if (entity instanceof IMobileEntity) {
      this.removeGravity((IMobileEntity) entity);
    }

    // 3. detach all controllers
    entity.detachControllers();

    if (entity instanceof Emitter) {
      Emitter em = (Emitter) entity;
      em.deactivate();
    }

    if (this.loaded && (entity instanceof LightSource || entity instanceof StaticShadow)) {
      this.updateLighting(entity);
    }

    entity.removed(this);
}
}
```
```java
class de.gurkenlabs.litiengine.graphics.animation.Animation {
@Override
  public void update() {
    // do nothing if the animation is not playing or the current keyframe is not finished
    if (!this.isPlaying()
        || Game.time().since(this.lastFrameUpdate) < this.getCurrentKeyFrame().getDuration()) {
      return;
    }

    // if we are not looping and the last keyframe is finished, we terminate the animation
    if (!this.isLooping() && this.isLastKeyFrame()) {
      this.terminate();
      return;
    }

    // make sure, we stay inside the keyframe list
    final int newFrameIndex =
        (this.getKeyframes().indexOf(this.currentFrame) + 1) % this.getKeyframes().size();
    final KeyFrame previousFrame = this.currentFrame;
    this.currentFrame = this.getKeyframes().get(newFrameIndex);

    for (KeyFrameListener listener : this.listeners) {
      listener.currentFrameChanged(previousFrame, this.currentFrame);
    }

    this.lastFrameUpdate = Game.loop().getTicks();
}public void restart() {
    this.currentFrame = this.firstFrame;
    this.lastFrameUpdate = Game.loop().getTicks();
}
}
```
```java
class de.gurkenlabs.litiengine.physics.MovementController {
@Override
    public void attach() {
      Nullability.castToNonnull(Game.loop(), "properly initialized before use").attach(this);
}private void handleForces() {
    // clean up forces
    this.activeForces.forEach(
        x -> {
          if (x.hasEnded()) {
            this.activeForces.remove(x);
          }
        });

    if (this.activeForces.isEmpty()) {
      return;
    }

    // disable turn-on-move for force handling
    boolean turn = this.getEntity().turnOnMove();
    this.getEntity().setTurnOnMove(false);
    try {
      double deltaX = 0;
      double deltaY = 0;
      for (final Force force : this.activeForces) {
        if (force.cancelOnReached() && force.hasReached(this.getEntity())) {
          force.end();
          continue;
        }

        final Point2D collisionBoxCenter = this.getEntity().getCollisionBoxCenter();
        final double angle =
            GeometricUtilities.calcRotationAngleInDegrees(collisionBoxCenter, force.getLocation());
        final double strength =
            Game.loop().getDeltaTime() * 0.001f * force.getStrength() * Game.loop().getTimeScale();
        deltaX += GeometricUtilities.getDeltaX(angle, strength);
        deltaY += GeometricUtilities.getDeltaY(angle, strength);
      }

      final Point2D target =
          new Point2D.Double(this.getEntity().getX() + deltaX, this.getEntity().getY() + deltaY);
      final boolean success = Game.physics().move(this.getEntity(), target);
      if (!success) {
        for (final Force force : this.activeForces) {
          if (force.cancelOnCollision()) {
            force.end();
          }
        }
      }
    } finally {
      this.getEntity().setTurnOnMove(turn);
    }
}@Override
  public void detach() {
    Game.loop().detach(this);
}public void handleMovement() {
    if (!this.isMovementAllowed()) {
      this.velocity = 0;
      return;
    }

    // max distance an entity can travel within one tick
    final double maxPixelsPerTick = this.getEntity().getTickVelocity();
    final double deltaTime = Game.loop().getDeltaTime() * Game.loop().getTimeScale();

    final double acceleration =
        this.getEntity().getAcceleration() == 0
            ? maxPixelsPerTick
            : deltaTime / this.getEntity().getAcceleration() * maxPixelsPerTick;
    final double deceleration =
        this.getEntity().getDeceleration() == 0
            ? this.getVelocity()
            : deltaTime / this.getEntity().getDeceleration() * maxPixelsPerTick;

    double dx = this.getDx();
    double dy = this.getDy();
    this.setDx(0);
    this.setDy(0);

    final double deltaVelocity =
        Math.min(Math.sqrt(Math.pow(dx, 2) + Math.pow(dy, 2)), acceleration);
    if (deltaVelocity != 0) {
      double newVelocity = this.getVelocity() + deltaVelocity;
      this.setVelocity(newVelocity);
    } else {
      final double newVelocity = Math.max(0, this.getVelocity() - deceleration);
      this.setVelocity(newVelocity);
      dx = GeometricUtilities.getDeltaX(this.moveAngle);
      dy = GeometricUtilities.getDeltaY(this.moveAngle);
    }

    if (this.getVelocity() == 0) {
      this.moveAngle = 0;
      return;
    }

    // actually move entity
    this.moveEntity(dx, dy);
}
}
```
```java
class de.gurkenlabs.litiengine.graphics.animation.AnimationController {
public void detach() {
    Game.loop().detach(this);
}public void attach() {
    Game.loop().attach(this);
}
}
```
```java
class de.gurkenlabs.litiengine.graphics.Camera {
@Override
  public void setZoom(final float targetZoom, final int delay) {
    if (delay == 0) {

      this.zoom = targetZoom;
      this.targetZoom = 0;
      this.zoomDelay = 0;
      this.zoomTick = 0;
      this.zoomStep = 0;

      final ZoomChangedEvent event = new ZoomChangedEvent(this, targetZoom);
      for (final ZoomChangedListener listener : this.zoomListeners) {
        listener.zoomChanged(event);
      }
    } else {
      this.zoomTick = Game.time().now();
      this.targetZoom = targetZoom;
      this.zoomDelay = delay;

      final double tickduration = 1000 / (double) Game.loop().getTickRate();
      final double tickAmount = delay / tickduration;
      final float totalDelta = this.targetZoom - this.zoom;
      this.zoomStep = tickAmount > 0 ? (float) (totalDelta / tickAmount) : totalDelta;
    }
}
}
```
```java
class de.gurkenlabs.litiengine.Game {
public static synchronized void init(String... args) {
    if (initialized) {
      log().log(Level.INFO, "The game has already been initialized.");
      return;
    }

    log.init();
    handleCommandLineArguments(args);

    config().load();
    Locale.setDefault(new Locale(config().client().getCountry(), config().client().getLanguage()));

    gameLoop = new GameLoop("Main Update Loop", config().client().getMaxFps());
    loop().attach(physics());
    loop().attach(world());

    // setup default exception handling for render and update loop
    setUncaughtExceptionHandler(
        new DefaultUncaughtExceptionHandler(config().client().exitOnError()));

    screenManager = new ScreenManager();
    gameWindow = new GameWindow();

    // initialize  the game window
    window().init();
    world.setCamera(new Camera());

    for (GameListener listener : gameListeners) {
      listener.initialized(args);
    }

    if (!isInNoGUIMode()) {
      window().getRenderComponent().onRendered(g -> metrics().render(g));

      graphics()
          .addEntityRenderedListener(
              e -> DebugRenderer.renderEntityDebugInfo(e.getGraphics(), e.getEntity()));

      window().getRenderComponent().onFpsChanged(fps -> metrics().setFramesPerSecond(fps));
      window()
          .setIcons(
              Arrays.asList(
                  Resources.images().get("liti-logo-x16.png"),
                  Resources.images().get("liti-logo-x20.png"),
                  Resources.images().get("liti-logo-x32.png"),
                  Resources.images().get("liti-logo-x48.png")));

      Input.keyboard()
          .onKeyTyped(
              KeyEvent.VK_PRINTSCREEN,
              key -> {
                // don't take a screenshot if a modifier is active
                if (key.getModifiers() != 0) {
                  return;
                }

                window().getRenderComponent().takeScreenshot();
              });
    }

    Runtime.getRuntime().addShutdownHook(new Thread(Game::terminate, "Shutdown"));

    initialized = true;
}
}
```
```java
class de.gurkenlabs.litiengine.entities.Creature {
protected void updateAnimationController() {
        IEntityAnimationController<?> controller = this.createAnimationController();
        this.getControllers().addController(controller);
        if (Game.world().environment() != null && Game.world().environment().isLoaded()) {
            Nullability.castToNonnull(Game.loop(), "expected to be non-null").attach(controller);
        }
}@Override
  public float getTickVelocity() {
    // pixels per ms multiplied by the passed ms
    // ensure that entities don't travel too far in case of lag
    return Math.min(Game.loop().getDeltaTime(), GameLoop.TICK_DELTATIME_LAG)
        * 0.001F
        * this.getVelocity().get()
        * Game.loop().getTimeScale();
}
}
```
Depth: 2
```java
class de.gurkenlabs.litiengine.environment.GameWorld {
public void clear() {
    this.unloadEnvironment();
    this.environments.clear();
    this.setCamera(null);
    Game.physics().clear();

    this.environmentListeners.clear();
    this.environmentLoadedListeners.clear();
    this.environmentUnloadedListeners.clear();

    this.listeners.clear();
    this.loadedListeners.clear();
    this.unloadedListeners.clear();
}@Nullable
  public Environment loadEnvironment(IMap map) {
    Environment env = this.getEnvironment(map);
    this.loadEnvironment(env);
    return env;
}@Nullable
  public Environment loadEnvironment(String mapName) {
    Environment env = this.getEnvironment(mapName);
    this.loadEnvironment(env);
    return env;
}
}
```
```java
class de.gurkenlabs.litiengine.GameWindow {
GameWindow() {
    this.hostControl = new JFrame();

    this.resolutionChangedListeners = new CopyOnWriteArrayList<>();

    this.renderCanvas = new RenderComponent(Game.config().graphics().getResolution());
    this.cursor = new MouseCursor();
    if (!Game.isInNoGUIMode()) {
      this.hostControl.setBackground(Color.BLACK);
      this.hostControl.add(this.renderCanvas);

      this.initializeEventListeners();

      this.hostControl.setTitle(Game.info().getTitle());
      this.hostControl.setDefaultCloseOperation(WindowConstants.DO_NOTHING_ON_CLOSE);
      initializeWindowEventListeners(this.hostControl);
    }
}
}
```
```java
class de.gurkenlabs.litiengine.GameTime {
public long sinceEnvironmentLoad() {
    return this.since(this.environmentLoaded);
}public long since(final long tick) {
    return toMilliseconds(Game.loop().getTicks() - tick);
}public long sinceGameStart() {
    return this.toMilliseconds(Game.loop().getTicks());
}
}
```
```java
class de.gurkenlabs.litiengine.abilities.effects.Effect {
protected void cease(final EffectApplication appliance) {
    // 1. cease the effect for all affected entities
    for (final ICombatEntity entity : appliance.getAffectedEntities()) {
      this.cease(entity);
    }

    // 2. apply follow up effects
    this.getFollowUpEffects().forEach(followUp -> followUp.apply(appliance.getImpactArea()));
}protected boolean hasEnded(final EffectApplication appliance) {
    final long effectDuration = Game.time().since(appliance.getAppliedTicks());
    return effectDuration > this.getDuration();
}
}
```
```java
class de.gurkenlabs.litiengine.abilities.effects.EffectApplication {
protected EffectApplication(final List<ICombatEntity> affectedEntities, final Shape impactArea) {
    this.applied = Game.time().now();
    this.affectedEntities = affectedEntities;
    this.impactArea = impactArea;
}
}
```
```java
class de.gurkenlabs.litiengine.entities.CombatEntity {
@Override
  public boolean wasHit(int timeSpan) {
    return Game.time().since(this.lastHit) < timeSpan;
}@Override
  public void hit(final int damage, @Nullable final Ability ability) {
    if (this.isDead()) {
      return;
    }

    if (!this.isIndestructible()) {
      this.getHitPoints().modifyBaseValue(new AttributeModifier<>(Modification.SUBTRACT, damage));
    }

    final EntityHitEvent event = new EntityHitEvent(this, ability, damage, this.isDead());

    for (final CombatEntityListener listener : this.listeners) {
      listener.hit(event);
    }

    for (final CombatEntityHitListener listener : this.hitListeners) {
      listener.hit(event);
    }

    if (this.isDead()) {
      this.fireDeathEvent();
      this.setCollision(false);
    }

    this.lastHit = Game.time().now();
}
}
```
```java
class de.gurkenlabs.litiengine.graphics.ImageEffect {
protected ImageEffect(final int ttl, final String name) {
    this.ttl = ttl;
    this.name = name;
    this.aliveTick = Game.time().now();
}@Override
  public long getAliveTime() {
    return Game.time().since(this.aliveTick);
}
}
```
```java
class de.gurkenlabs.litiengine.abilities.AbilityExecution {
AbilityExecution(final Ability ability) {
        this.appliedEffects = new CopyOnWriteArrayList<>();
        this.ability = ability;
        this.executionTicks = Game.time().now();
        this.impactArea = ability.calculateImpactArea();
        this.castLocation = ability.getExecutor().getCenter();
        Nullability.castToNonnull(Game.loop(), "proper initialization done").attach(this);
}@Override
  public void update() {
    // if there a no effects to apply -> unregister this instance and we're done
    if (this.getAbility().getEffects().isEmpty()
        || this.getAbility().getEffects().size() == this.getAppliedEffects().size()) {
      Game.loop().detach(this);
      return;
    }

    // handle all effects from the ability that were not applied yet
    for (final Effect effect : this.getAbility().getEffects()) {
      // if the ability was not executed yet or the delay of the effect is not
      // yet reached
      if (this.getAppliedEffects().contains(effect)
          || Game.time().since(this.getExecutionTicks()) < effect.getDelay()) {
        continue;
      }

      effect.apply(this.getExecutionImpactArea());
      this.getAppliedEffects().add(effect);
    }
}
}
```
```java
class de.gurkenlabs.litiengine.tweening.TweenEngine {
@Override
  public void update() {
    for (final Tweenable target : this.getTweens().keySet()) {
      for (final Tween tween : this.getTweens().get(target).values()) {
        if (tween.hasStopped()) {
          continue;
        }
        final long elapsed = Game.time().since(tween.getStartTime());
        if (elapsed >= tween.getDuration()) {
          tween.stop();
          continue;
        }
        final float[] currentValues = new float[tween.getTargetValues().length];
        for (int i = 0; i < tween.getTargetValues().length; i++) {
          currentValues[i] =
              tween.getStartValues()[i]
                  + tween.getEquation().compute(elapsed / (float) tween.getDuration())
                      * (tween.getTargetValues()[i] - tween.getStartValues()[i]);
        }
        tween.getTarget().setTweenValues(tween.getType(), currentValues);
      }
    }
}
}
```
```java
class de.gurkenlabs.litiengine.gui.SpeechBubble {
public static SpeechBubble create(
      final IEntity entity, final String text, SpeechBubbleAppearance appearance, Font font) {
    return new SpeechBubble(entity, text, appearance, font);
}public static SpeechBubble create(final IEntity entity, final Font font, final String text) {
    SpeechBubbleAppearance app =
        new SpeechBubbleAppearance(
            DEFAULT_APPEARANCE.getForeColor(),
            DEFAULT_APPEARANCE.getBackgroundColor1(),
            DEFAULT_APPEARANCE.getBorderColor(),
            DEFAULT_APPEARANCE.getPadding());
    return new SpeechBubble(entity, text, app, font);
}public static SpeechBubble create(final IEntity entity, final String text) {
    return new SpeechBubble(entity, text, null, GuiProperties.getDefaultFont());
}@Override
  public void update() {
    if (this.currentText == null) {
      this.hide();
      return;
    }

    this.entityCenter = Game.world().camera().getViewportLocation(this.getEntity().getCenter());

    // old text was displayed long enough
    if (this.lastTextDisplay != 0
        && Game.time().since(this.lastTextDisplay) > this.currentTextDisplayTime) {
      this.currentText = null;
      this.lastTextDisplay = 0;
      return;
    }

    // display new text
    if (this.textIndex < this.currentText.length()
        && Game.time().since(this.lastCharPoll) > LETTER_WRITE_DELAY) {
      this.textIndex++;
      this.lastCharPoll = Game.time().now();
      if (this.typeSound != null) {
        Game.audio().playSound(this.typeSound, this.getEntity());
      }
    }

    // continue displaying currently displayed text
}private SpeechBubble(
      final IEntity entity,
      final String text,
      final Sound typeSound,
      SpeechBubbleAppearance appearance,
      Font font) {
    this(entity, text, appearance, font);
    this.typeSound = typeSound;
}private SpeechBubble(
      final IEntity entity,
      final String text,
      @Nullable SpeechBubbleAppearance appearance,
      @Nullable Font font) {
    if (appearance == null) {
      this.appearance = DEFAULT_APPEARANCE;
    } else {
      this.appearance = appearance;
    }

    final SpeechBubble active = activeSpeechBubbles.get(entity);
    if (active != null) {
      active.hide();
    }
    this.setFont(font);

    this.textBoxWidth = (float) (entity.getWidth() * 4);
    this.entity = entity;

    this.currentText = text;
    this.currentTextDisplayTime = DISPLAYTIME_MIN + text.length() * DISPLAYTIME_PER_LETTER;

    this.lastTextDisplay = Game.time().now();
    this.createBubbleImage();
    entity.getEnvironment().add(this, RenderType.UI);
    Game.loop().attach(this);
    activeSpeechBubbles.put(entity, this);
}
}
```
```java
class de.gurkenlabs.litiengine.gui.TextFieldComponent {
@Override
  public void render(final Graphics2D g) {
    super.render(g);
    g.setFont(this.getFont());
    final FontMetrics fm = g.getFontMetrics();

    if (this.isSelected() && Game.time().since(this.lastToggled) > this.flickerDelay) {
      this.cursorVisible = !this.cursorVisible;
      this.lastToggled = Game.time().now();
    }
    if (this.isSelected() && this.cursorVisible) {
      final Rectangle2D cursor =
          new Rectangle2D.Double(
              this.getX() + this.getTextX() + fm.stringWidth(this.getTextToRender(g)),
              this.getY() + this.getTextY(),
              this.getFont().getSize2D() * 3 / 5,
              this.getFont().getSize2D() * 1 / 5);
      g.setColor(this.getAppearance().getForeColor());
      g.fill(cursor);
    }
}
}
```
```java
class de.gurkenlabs.litiengine.entities.Prop {
public Prop(
      final Point2D location, @Nullable final String spritesheetName, final Material material) {
    super();
    this.rotation = Rotation.NONE;
    this.spritesheetName = spritesheetName;
    this.material = material;
    this.setLocation(location);
    this.updateAnimationController();
}public void setSpritesheetName(@Nullable final String spriteName) {
    this.spritesheetName = spriteName;
    this.updateAnimationController();
}
}
```
```java
class de.gurkenlabs.litiengine.tweening.Tween {
public Tween begin() {
    this.started = Game.time().now();
    this.stopped = false;
    return this;
}
}
```
```java
class de.gurkenlabs.litiengine.graphics.emitters.particles.Particle {
public void update(final Point2D emitterOrigin, final float updateRatio) {
    if (this.aliveTick == 0) {
      this.aliveTick = Game.time().now();
    }

    this.aliveTime = Game.time().since(this.aliveTick);
    if (this.timeToLiveReached()) {
      return;
    }

    if (this.colliding) {
      return;
    }

    if (this.getDeltaWidth() != 0) {
      this.width += this.getDeltaWidth() * updateRatio;
    }

    if (this.getDeltaHeight() != 0) {
      this.height += this.getDeltaHeight() * updateRatio;
    }

    if (this.getDeltaAngle() != 0) {
      this.angle += this.getDeltaAngle() * updateRatio;
    }

    // test for ray cast collision
    final float targetX = this.x + this.getVelocityX() * updateRatio;
    final float targetY = this.y + this.getVelocityY() * updateRatio;

    if (targetX == this.x && targetY == this.y) {
      return;
    }

    if (this.checkForCollision(emitterOrigin, targetX, targetY)) {
      return;
    }

    if (this.getVelocityX() != 0) {
      this.x = targetX;
    }

    if (this.getVelocityY() != 0) {
      this.y = targetY;
    }

    if (this.getAccelerationX() != 0) {
      this.velocityX += this.getAccelerationX() * updateRatio;
    }

    if (this.getAccelerationY() != 0) {
      this.velocityY += this.getAccelerationY() * updateRatio;
    }
}
}
```
```java
class de.gurkenlabs.litiengine.graphics.animation.Animation {
@Override
  public void start() {
    this.playing = true;
    if (this.getKeyframes().isEmpty()) {
      return;
    }

    this.restart();
}@Override
  public void update() {
    // do nothing if the animation is not playing or the current keyframe is not finished
    if (!this.isPlaying()
        || Game.time().since(this.lastFrameUpdate) < this.getCurrentKeyFrame().getDuration()) {
      return;
    }

    // if we are not looping and the last keyframe is finished, we terminate the animation
    if (!this.isLooping() && this.isLastKeyFrame()) {
      this.terminate();
      return;
    }

    // make sure, we stay inside the keyframe list
    final int newFrameIndex =
        (this.getKeyframes().indexOf(this.currentFrame) + 1) % this.getKeyframes().size();
    final KeyFrame previousFrame = this.currentFrame;
    this.currentFrame = this.getKeyframes().get(newFrameIndex);

    for (KeyFrameListener listener : this.listeners) {
      listener.currentFrameChanged(previousFrame, this.currentFrame);
    }

    this.lastFrameUpdate = Game.loop().getTicks();
}
}
```
```java
class de.gurkenlabs.litiengine.graphics.animation.AnimationController {
@Override
  public void update() {
    for (final Animation animation : this.getAll()) {
      animation.update();
    }

    if (this.getCurrent() != null && this.getCurrent().isPaused()) {
      return;
    }

    final boolean playbackFinished = this.getCurrent() != null && !this.getCurrent().isPlaying();
    if (playbackFinished) {
      for (final AnimationListener listener : this.listeners) {
        listener.finished(this.getCurrent());
      }
    }

    if (this.getCurrent() == null || playbackFinished) {
      if (this.getDefault() != null) {
        this.play(this.getDefault().getName());
      } else {
        this.currentAnimation = null;
      }
    }
}
}
```
```java
class de.gurkenlabs.litiengine.graphics.RenderComponent {
private void handleFade() {
    if (this.fadeOutStart != -1) {
      final long timePassed = Game.time().since(this.fadeOutStart);
      this.currentAlpha = MathUtilities.clamp(1 - timePassed / (float) this.fadeOutTime, 0, 1);
      if (this.currentAlpha == 0f) {
        this.fadeOutStart = -1;
        this.fadeOutTime = -1;
      }

      return;
    }

    if (this.fadeInStart != -1) {
      final long timePassed = Game.time().since(this.fadeInStart);
      this.currentAlpha = MathUtilities.clamp(timePassed / (float) this.fadeInTime, 0, 1);
      if (this.currentAlpha == 1f) {
        this.fadeInStart = -1;
        this.fadeInTime = -1;
        this.currentAlpha = Float.NaN;
      }
    }
}public void fadeOut(final int ms) {
    this.fadeInStart = -1;
    this.fadeInTime = -1;
    this.fadeOutStart = Game.time().now();
    this.fadeOutTime = ms;
}public void fadeIn(final int ms) {
    this.fadeOutStart = -1;
    this.fadeOutTime = -1;
    this.fadeInStart = Game.time().now();
    this.fadeInTime = ms;
}
}
```
```java
class de.gurkenlabs.litiengine.entities.Trigger {
private boolean activate(final IEntity activator, final int tar) {
    if (!this.isLoaded()
        || this.isOneTimeTrigger && this.isActivated
        || this.getActivationType() == TriggerActivation.COLLISION
            && activator != null
            && this.collisionActivated.contains(activator)) {
      return false;
    }

    if (this.getCooldown() > 0 && Game.time().since(this.lastActivation) < this.getCooldown()) {
      return false;
    }

    List<Integer> triggerTargets = this.getTargets(tar);

    final TriggerEvent te = new TriggerEvent(this, activator, triggerTargets);

    if (!this.checkActivationPredicates(te)) {
      return false;
    }

    this.isActivated = true;
    if (activator != null) {
      this.collisionActivated.add(activator);
    }

    // if we actually have a trigger target, we send the message to the target
    for (final int target : triggerTargets) {
      final IEntity entity = this.getEnvironment().get(target);
      if (entity == null) {
        log.log(
            Level.WARNING,
            "trigger [{0}] was activated, but the trigger target [{1}] could not be found on the environment",
            new Object[] {this, target});
        continue;
      }

      entity.sendMessage(this, this.message);
    }

    // also send the trigger event to all registered consumers
    for (final TriggerActivatedListener listener : this.activatedListeners) {
      listener.activated(te);
    }

    if (this.isOneTimeTrigger) {
      this.getEnvironment().remove(this);
    }

    this.lastActivation = Game.time().now();
    return true;
}
}
```
```java
class de.gurkenlabs.litiengine.graphics.Camera {
private boolean isShakeEffectActive() {
    return this.getShakeTick() != 0
        && Game.time().since(this.getShakeTick()) < this.getShakeDuration();
}@Override
  public void update() {
    if (Game.world().camera() != null && !Game.world().camera().equals(this)) {
      return;
    }

    if (this.targetZoom > 0) {
      if (Game.time().since(this.zoomTick) >= this.zoomDelay) {
        this.zoom = this.targetZoom;
        this.targetZoom = 0;
        this.zoomDelay = 0;
        this.zoomTick = 0;
        this.zoomStep = 0;
      } else {
        this.zoom += this.zoomStep;
      }

      final ZoomChangedEvent event = new ZoomChangedEvent(this, this.getZoom());
      for (final ZoomChangedListener listener : this.zoomListeners) {
        listener.zoomChanged(event);
      }
    }

    if (this.panTime > 0) {
      if (--this.panTime <= 0) {
        this.setFocus(this.targetFocus);
        this.targetFocus = null;
      } else {
        double diff = this.panTime / (this.panTime + 1.0);
        this.focus =
            new Point2D.Double(
                this.focus.getX() * diff + this.targetFocus.getX() * (1.0 - diff),
                this.focus.getY() * diff + this.targetFocus.getY() * (1.0 - diff));
      }
    }

    if (!this.isShakeEffectActive()) {
      this.shakeOffsetX = 0;
      this.shakeOffsetY = 0;
      return;
    }

    if (Game.time().since(this.lastShake) > this.shakeDelay) {
      this.shakeOffsetX = this.getShakeIntensity() * ThreadLocalRandom.current().nextGaussian();
      this.shakeOffsetY = this.getShakeIntensity() * ThreadLocalRandom.current().nextGaussian();
      this.lastShake = Game.time().now();
    }
}@Override
  public void setZoom(final float targetZoom, final int delay) {
    if (delay == 0) {

      this.zoom = targetZoom;
      this.targetZoom = 0;
      this.zoomDelay = 0;
      this.zoomTick = 0;
      this.zoomStep = 0;

      final ZoomChangedEvent event = new ZoomChangedEvent(this, targetZoom);
      for (final ZoomChangedListener listener : this.zoomListeners) {
        listener.zoomChanged(event);
      }
    } else {
      this.zoomTick = Game.time().now();
      this.targetZoom = targetZoom;
      this.zoomDelay = delay;

      final double tickduration = 1000 / (double) Game.loop().getTickRate();
      final double tickAmount = delay / tickduration;
      final float totalDelta = this.targetZoom - this.zoom;
      this.zoomStep = tickAmount > 0 ? (float) (totalDelta / tickAmount) : totalDelta;
    }
}@Override
  public void shake(final double intensity, final int delay, final int shakeDuration) {
    this.shakeTick = Game.time().now();
    this.shakeDelay = delay;
    this.shakeIntensity = intensity;
    this.shakeDuration = shakeDuration;
}
}
```
```java
class de.gurkenlabs.litiengine.entities.Creature {
public void setSpritesheetName(String spritesheetName) {
    if (this.spritesheetName != null && this.spritesheetName.equals(spritesheetName)) {
      return;
    }

    this.spritesheetName = spritesheetName;
    this.updateAnimationController();
}public boolean isIdle() {
    return Game.time().since(this.lastMoved) > IDLE_DELAY;
}@Override
  public void setLocation(final Point2D position) {
    if (this.isDead() || position == null) {
      return;
    }

    final Point2D oldLocation = this.getLocation();
    super.setLocation(position);

    if (Game.hasStarted() && this.isLoaded()) {
      this.lastMoved = Game.time().now();
      this.fireMovedEvent(
          new EntityMovedEvent(
              this, this.getX() - oldLocation.getX(), this.getY() - oldLocation.getY()));
    }
}
}
```
```java
class de.gurkenlabs.litiengine.gui.screens.ScreenManager {
public void display(final String screenName) {
    if (this.current() != null && this.current().getName().equalsIgnoreCase(screenName)) {
      log.log(
          Level.INFO,
          "Skipping displaying of screen {0} because it is already the current screen.",
          screenName);
      return;
    }

    if (this.screens.stream()
        .noneMatch(element -> element.getName().equalsIgnoreCase(screenName))) {
      log.log(
          Level.WARNING,
          "Could not display the screen {0} because there is no screen with the specified name.",
          screenName);
      return;
    }

    Screen screen = this.get(screenName);
    if (screen == null) {
      return;
    }

    this.display(screen);
}public void add(final Screen screen) {
    screen.setWidth(Game.window().getWidth());
    screen.setHeight(Game.window().getHeight());
    this.screens.add(screen);

    if (this.current() == null) {
      this.display(screen);
    }
}public void remove(Screen screen) {
    this.screens.remove(screen);
    if (this.current() == screen) {
      if (!this.screens.isEmpty()) {
        this.display(this.screens.get(0));
      } else {
        this.display((Screen) null);
      }
    }
}public void display(@Nullable final Screen screen) {
      if (Game.hasStarted() && Game.time().since(this.lastScreenChange) < this.getChangeCooldown()) {
        log.log(
            Level.INFO,
            "Skipping displaying of screen {0} because screen changing is currently on cooldown.",
            screen != null ? screen.getName() : "");
        return;
      }
  
      final Screen previous = this.current();
      if (previous != null) {
        previous.suspend();
      }
  
      if (screen != null && !this.screens.contains(screen)) {
        this.screens.add(screen);
      }
  
      this.currentScreen = screen;
      if (!Game.isInNoGUIMode() && this.current() != null) {
        this.current().prepare();
      }
  
      this.lastScreenChange = Nullability.castToNonnull(Game.loop(), "initialized before usage").getTicks();
  
      final ScreenChangedEvent event = new ScreenChangedEvent(this.current(), previous);
      for (final ScreenChangedListener listener : this.screenChangedListeners) {
        listener.changed(event);
      }
}
}
```
```java
class de.gurkenlabs.litiengine.abilities.Ability {
public boolean isOnCooldown() {
    return (this.getCurrentExecution() != null
        && this.getCurrentExecution().getExecutionTicks() > 0
        && Game.time().since(this.getCurrentExecution().getExecutionTicks())
            < this.getAttributes().cooldown().get());
}public boolean isActive() {
    return this.getCurrentExecution() != null
        && Game.time().since(this.getCurrentExecution().getExecutionTicks())
            < this.getAttributes().duration().get();
}@Nullable
  public AbilityExecution cast() {
    if (!this.canCast()) {
      return null;
    }
    this.currentExecution = new AbilityExecution(this);

    for (final AbilityCastListener listener : this.abilityCastListeners) {
      listener.abilityCast(this.currentExecution);
    }

    return this.getCurrentExecution();
}public float getRemainingCooldownInSeconds() {
    if (this.getCurrentExecution() == null
        || this.getExecutor() == null
        || this.getExecutor().isDead()) {
      return 0;
    }

    // calculate cooldown in seconds
    return (float)
        (!this.canCast()
            ? (this.getAttributes().cooldown().get()
                    - Game.time().since(this.getCurrentExecution().getExecutionTicks()))
                * 0.001
            : 0);
}
}
```
```java
class de.gurkenlabs.litiengine.entities.EntityHitEvent {
EntityHitEvent(
      final ICombatEntity hitEntity,
      @Nullable final Ability ability,
      final int damage,
      final boolean kill) {
    super(hitEntity);
    this.executor = ability != null ? ability.getExecutor() : null;
    this.hitEntity = hitEntity;
    this.ability = ability;
    this.damage = damage;
    this.kill = kill;
    this.time = Game.time().now();
}
}
```
```java
class de.gurkenlabs.litiengine.graphics.emitters.Emitter {
public void delete() {
    this.deactivate();
    if (Game.world().environment() != null) {
      Game.world().environment().remove(this);
    }
}public void activate() {
    if (this.activated) {
      return;
    }

    this.activated = true;
    this.activationTick = Game.time().now();
    Game.loop().attach(this);
}@Override
  public void update() {
    if (this.isPaused()) {
      return;
    }

    // clear particles if the effect time to life is reached
    if (this.isFinished()) {
      for (EmitterFinishedListener listener : this.finishedListeners) {
        listener.finished(this);
      }

      this.delete();
      return;
    }

    final float updateRatio = (float) this.data().getUpdateRate() / Game.loop().getTickRate();
    for (final Particle p : this.getParticles().stream().collect(Collectors.toList())) {
      if (this.particleCanBeRemoved(p)) {
        // remove dead particles
        this.particles.remove(p);
        continue;
      }

      p.update(this.getOrigin(), updateRatio);
    }

    this.aliveTime = Game.time().since(this.activationTick);
    if ((this.data().getSpawnRate() == 0
        || Game.time().since(this.lastSpawn) >= this.data().getSpawnRate())) {
      this.lastSpawn = Game.time().now();
      this.spawnParticle();
    }
}
}
```
```java
class de.gurkenlabs.litiengine.GameLoop {
@Override
  public int perform(int delay, Runnable action) {
    final long d = Game.time().toTicks(delay);

    TimedAction a = new TimedAction(this.getTicks() + d, action);
    this.actions.add(a);

    return a.getId();
}
}
```
```java
class de.gurkenlabs.litiengine.environment.EntitySpawner {
protected boolean shouldSpawn() {
    return this.lastSpawnWave == 0
        || Game.time().since(this.lastSpawnWave) >= this.getSpawnInterval();
}@Override
  public void update() {
    if (!this.shouldSpawn()) {
      return;
    }

    this.spawnNewEntities();
    this.lastSpawnWave = Game.time().now();
}
}
```
```java
class de.gurkenlabs.litiengine.graphics.FreeFlightCamera {
@Override
  public void update() {
    this.handleFreeFlightCamera();
}public FreeFlightCamera(double x, double y) {
    this(new Point2D.Double(x, y));
}
}
```
```java
class de.gurkenlabs.litiengine.environment.Environment {
public void unload() {
    if (!this.loaded) {
      return;
    }

    // unregister all updatable entities from the current environment
    for (final IEntity entity : this.allEntities.values()) {
      this.unload(entity);
    }

    this.loaded = false;
    this.fireEvent(l -> l.unloaded(this));
}private static void loadUpdatableOrEmitterEntity(IEntity entity) {
      if (entity instanceof Emitter) {
        final Emitter emitter = (Emitter) entity;
        if (emitter.isActivateOnInit()) {
          emitter.activate();
        }
      } else if (entity instanceof IUpdateable) {
        Nullability.castToNonnull(Game.loop(), "initialized through init").attach((IUpdateable) entity);
      }
}public void clear() {
    Game.physics().clear();

    this.combatEntities.clear();
    this.mobileEntities.clear();
    this.gravityForces.clear();
    this.layerEntities.clear();
    this.entitiesByTag.clear();
    this.allEntities.clear();

    for (RenderType renderType : RenderType.values()) {
      this.miscEntities.get(renderType).clear();
      this.renderListeners.get(renderType).clear();
      this.renderables.get(renderType).clear();
    }

    dispose(this.allEntities.values());
    dispose(this.triggers);
    this.emitters.clear();
    this.colliders.clear();
    this.props.clear();
    this.creatures.clear();
    this.staticShadows.clear();
    this.combatEntities.clear();
    this.mobileEntities.clear();
    this.lightSources.clear();
    this.spawnPoints.clear();
    this.soundSources.clear();
    this.mapAreas.clear();
    this.triggers.clear();

    this.ambientLight = null;
    this.staticShadowLayer = null;

    for (Map<Integer, IEntity> type : this.miscEntities.values()) {
      type.clear();
    }

    this.initialized = false;

    this.fireEvent(l -> l.cleared(this));
}private void load(final IEntity entity) {
    // an entity can only exist on one environment at a time, so remove it from the current one
    if (entity.getEnvironment() != null) {
      entity.getEnvironment().remove(entity);
    }

    // 1. add to physics engine
    loadPhysicsEntity(entity);

    // 2. register for update or activate
    loadUpdatableOrEmitterEntity(entity);

    // 3. if a gravity is defined, add a gravity force to the entity
    if (entity instanceof IMobileEntity && this.getGravity() != 0) {
      this.addGravityForce((IMobileEntity) entity);
    }

    // 4. attach all controllers
    entity.attachControllers();

    if (this.loaded && (entity instanceof LightSource || entity instanceof StaticShadow)) {
      this.updateLighting(entity);
    }

    entity.loaded(this);
}private void unload(final IEntity entity) {
    // 1. remove from physics engine
    if (entity instanceof ICollisionEntity) {
      Game.physics().remove((ICollisionEntity) entity);
    }

    // 2. unregister from update
    if (entity instanceof IUpdateable) {
      Game.loop().detach((IUpdateable) entity);
    }

    if (entity instanceof IMobileEntity) {
      this.removeGravity((IMobileEntity) entity);
    }

    // 3. detach all controllers
    entity.detachControllers();

    if (entity instanceof Emitter) {
      Emitter em = (Emitter) entity;
      em.deactivate();
    }

    if (this.loaded && (entity instanceof LightSource || entity instanceof StaticShadow)) {
      this.updateLighting(entity);
    }

    entity.removed(this);
}public void remove(final IEntity entity) {
    if (entity == null) {
      return;
    }

    this.allEntities.remove(entity.getMapId());
    Iterator<List<IEntity>> iter = this.layerEntities.values().iterator();
    while (iter.hasNext()) {
      List<IEntity> layer = iter.next();
      if (layer.remove(entity) && layer.isEmpty()) {
        iter.remove();
      }
    }
    if (this.miscEntities.get(entity.getRenderType()) != null) {
      this.miscEntities.get(entity.getRenderType()).values().remove(entity);
    }

    for (String tag : entity.getTags()) {
      if (this.getEntitiesByTag().containsKey(tag)) {
        this.getEntitiesByTag().get(tag).remove(entity);

        if (this.getEntitiesByTag().get(tag).isEmpty()) {
          this.getEntitiesByTag().remove(tag);
        }
      }
    }

    if (entity instanceof Emitter) {
      Emitter emitter = (Emitter) entity;
      this.removeEmitter(emitter);
    }

    if (entity instanceof MapArea) {
      this.mapAreas.remove(entity);
    }

    if (entity instanceof Prop) {
      this.props.remove(entity);
    }

    if (entity instanceof Creature) {
      this.creatures.remove(entity);
    }

    if (entity instanceof CollisionBox) {
      this.colliders.remove(entity);
      this.staticShadows.removeIf(x -> x.getOrigin() != null && x.getOrigin().equals(entity));
    }

    if (entity instanceof LightSource) {
      this.lightSources.remove(entity);
      this.updateLighting(entity);
    }

    if (entity instanceof Trigger) {
      this.triggers.remove(entity);
    }

    if (entity instanceof Spawnpoint) {
      this.spawnPoints.remove(entity);
    }
    if (entity instanceof SoundSource) {
      this.soundSources.remove(entity);
    }

    if (entity instanceof StaticShadow) {
      this.staticShadows.remove(entity);
      this.updateLighting(entity);
    }

    if (entity instanceof IMobileEntity) {
      this.mobileEntities.values().remove(entity);
    }

    if (entity instanceof ICombatEntity) {
      this.combatEntities.values().remove(entity);
    }

    this.unload(entity);

    this.fireEntityEvent(l -> l.entityRemoved(entity));
}
}
```
```java
class de.gurkenlabs.litiengine.physics.MovementController {
@Override
  public void update() {
    this.handleForces();
    this.handleMovement();
}
}
```
```java
class de.gurkenlabs.litiengine.Game {
static synchronized void terminate() {
        if (!initialized || gameLoop == null) {
          return;
        }
    
        hasStarted = false;
        initialized = false;
    
        config().save();
        gameLoop.terminate();
        tweenEngine.terminate();
        soundEngine.terminate();
    
        world().clear();
    
        for (final GameListener listener : gameListeners) {
          try {
            listener.terminated();
          } catch (Exception e) {
            log().log(Level.WARNING, "game listener threw an exception during shutdown", e);
          }
        }
    
        gameLoop = null;
        screenManager = null;
        gameWindow = null;
}public static synchronized void start() {
          if (!initialized) {
              throw new IllegalStateException(
                  "The game cannot be started without being first initialized. Call Game.init(...) before Game.start().");
          }
    
          if (gameLoop == null) {
              throw new IllegalStateException(
                  "Game loop is not initialized. Ensure Game.init(...) has been called successfully.");
          }
          
          Nullability.castToNonnull(gameLoop, "gameLoop cannot be null").start();
          tweenEngine.start();
          soundEngine.start();
    
          for (final GameListener listener : gameListeners) {
              listener.started();
          }
    
          hasStarted = true;
}public static synchronized void init(String... args) {
    if (initialized) {
      log().log(Level.INFO, "The game has already been initialized.");
      return;
    }

    log.init();
    handleCommandLineArguments(args);

    config().load();
    Locale.setDefault(new Locale(config().client().getCountry(), config().client().getLanguage()));

    gameLoop = new GameLoop("Main Update Loop", config().client().getMaxFps());
    loop().attach(physics());
    loop().attach(world());

    // setup default exception handling for render and update loop
    setUncaughtExceptionHandler(
        new DefaultUncaughtExceptionHandler(config().client().exitOnError()));

    screenManager = new ScreenManager();
    gameWindow = new GameWindow();

    // initialize  the game window
    window().init();
    world.setCamera(new Camera());

    for (GameListener listener : gameListeners) {
      listener.initialized(args);
    }

    if (!isInNoGUIMode()) {
      window().getRenderComponent().onRendered(g -> metrics().render(g));

      graphics()
          .addEntityRenderedListener(
              e -> DebugRenderer.renderEntityDebugInfo(e.getGraphics(), e.getEntity()));

      window().getRenderComponent().onFpsChanged(fps -> metrics().setFramesPerSecond(fps));
      window()
          .setIcons(
              Arrays.asList(
                  Resources.images().get("liti-logo-x16.png"),
                  Resources.images().get("liti-logo-x20.png"),
                  Resources.images().get("liti-logo-x32.png"),
                  Resources.images().get("liti-logo-x48.png")));

      Input.keyboard()
          .onKeyTyped(
              KeyEvent.VK_PRINTSCREEN,
              key -> {
                // don't take a screenshot if a modifier is active
                if (key.getModifiers() != 0) {
                  return;
                }

                window().getRenderComponent().takeScreenshot();
              });
    }

    Runtime.getRuntime().addShutdownHook(new Thread(Game::terminate, "Shutdown"));

    initialized = true;
}
}
```


Response Format:
Provide the answer in **XML format** as follows:

#### If the method **cannot** return `null` at the specific call site:
```xml
<response>
  <reason><![CDATA[EXPLAIN WHY THE INVOCATION Game.loop() RESULT CANNOT BE NULL.]]></reason>
  <value>NO</value>
</response>

#### If the method can return null at the specific call site:
<response>
  <reason><![CDATA[EXPLAIN WHY THE INVOCATION Game.loop() RESULT CAN BE NULL.]]></reason>
  <value>YES</value>
</response>

#### If you are unsure or If there are any methods that directly or indirectly affect the return value and are not fully disclosed, request their declarations first, in the following format:
<response>
  <reason><![CDATA[EXPLAIN WHY THIS METHOD DECLARATION IS NECESSARY AND WHY YOU CANNOT MAKE A CONFIDENT DECISION WITHOUT IT]]></reason>
  <success>false</success>
  <methods>
    <method>methodName</method>
  </methods>
</response>

Additional Notes:
Be precise in your reasoning.
If a methods return value depends on another method not provided, request its declaration before making a conclusion.
If the method can return null in this case but not in others, explain why it happens specifically for this call.

11:53:28.323 TRACE edu.ucr.cs.riple.core.checkers.nullaway.codefix.ChatGPT.ask
Retrieving response from cache
11:53:28.323 TRACE edu.ucr.cs.riple.core.checkers.nullaway.codefix.Response.tryCreate
Trying to create Response:
```xml
<response>
  <reason><![CDATA[The method Game.loop() returns the static field gameLoop. The initialization method for this field is provided, and it is initialized in the Game.init() method, which is a synchronized method that sets up the game environment. Once initialized, the game initialization status is set to true, preventing re-initialization without termination. This indicates that gameLoop is set up properly during the initialization phase. Furthermore, various parts of the code use Nullability.castToNonnull on Game.loop(), implying an expectation that gameLoop is non-null during the normal operation of the game. Therefore, assuming that the game is properly initialized before this usage, Game.loop() is not expected to return null at the invocation site.]]></reason>
  <value>NO</value>
</response>
```
11:53:28.323 TRACE edu.ucr.cs.riple.core.checkers.nullaway.codefix.Response.<init>
Creating Response:
```xml
<response>
  <reason><![CDATA[The method Game.loop() returns the static field gameLoop. The initialization method for this field is provided, and it is initialized in the Game.init() method, which is a synchronized method that sets up the game environment. Once initialized, the game initialization status is set to true, preventing re-initialization without termination. This indicates that gameLoop is set up properly during the initialization phase. Furthermore, various parts of the code use Nullability.castToNonnull on Game.loop(), implying an expectation that gameLoop is non-null during the normal operation of the game. Therefore, assuming that the game is properly initialized before this usage, Game.loop() is not expected to return null at the invocation site.]]></reason>
  <value>NO</value>
</response>
```
11:53:28.324 TRACE edu.ucr.cs.riple.core.checkers.nullaway.codefix.Response.<init>
Response created:
Disagreement: The method Game.loop() returns the static field gameLoop. The initialization method for this field is provided, and it is initialized in the Game.init() method, which is a synchronized method that sets up the game environment. Once initialized, the game initialization status is set to true, preventing re-initialization without termination. This indicates that gameLoop is set up properly during the initialization phase. Furthermore, various parts of the code use Nullability.castToNonnull on Game.loop(), implying an expectation that gameLoop is non-null during the normal operation of the game. Therefore, assuming that the game is properly initialized before this usage, Game.loop() is not expected to return null at the invocation site.
11:53:28.324 TRACE edu.ucr.cs.riple.core.checkers.nullaway.codefix.AdvancedNullAwayCodeFix.resolveMethodDereferenceError
Method is not returning nullable on call site. Injecting suppression annotation.
11:53:28.324 TRACE edu.ucr.cs.riple.core.checkers.nullaway.codefix.AdvancedNullAwayCodeFix.constructCastToNonnullChange
Constructing cast to nonnull change for reason: The method Game.loop() returns the static field gameLoop. The initialization method for this field is provided, and it is initialized in the Game.init() method, which is a synchronized method that sets up the game environment. Once initialized, the game initialization status is set to true, preventing re-initialization without termination. This indicates that gameLoop is set up properly during the initialization phase. Furthermore, various parts of the code use Nullability.castToNonnull on Game.loop(), implying an expectation that gameLoop is non-null during the normal operation of the game. Therefore, assuming that the game is properly initialized before this usage, Game.loop() is not expected to return null at the invocation site.
11:53:28.324 TRACE edu.ucr.cs.riple.core.checkers.nullaway.codefix.ChatGPT.ask
Asking ChatGPT:
For the reason you mentioned earlier:

"The method Game.loop() returns the static field gameLoop. The initialization method for this field is provided, and it is initialized in the Game.init() method, which is a synchronized method that sets up the game environment. Once initialized, the game initialization status is set to true, preventing re-initialization without termination. This indicates that gameLoop is set up properly during the initialization phase. Furthermore, various parts of the code use Nullability.castToNonnull on Game.loop(), implying an expectation that gameLoop is non-null during the normal operation of the game. Therefore, assuming that the game is properly initialized before this usage, Game.loop() is not expected to return null at the invocation site."

in the method below, the expression Game.loop() is not nullable at the point it is used.

```java
public default void detach() {
    Game.loop().detach(this);
}
```
Please Summarize the reason in max 5 words and rewrite the method so that at the line "    Game.loop().detach(this);", at the occurrence of: "Game.loop()" is replaced with `Nullability.castToNonnull(Game.loop(), summary of reason)`
Replace "REASON" with the exact reason summary I provide to you (maximum 5 words), not with a generic explanation like "checked to be nonnull".
see the example below, for expression `foo.getBar()`, to wrap it with `Nullability.castToNonnull(foo.getBar(), "reason")`.

```java
public t(){
    String l = foo.getBar();
}
```

will be:
```java
public t(){
    String l = Nullability.castToNonnull(foo.getBar(), "checked to be nonnull");
}
```

### Instructions:

Do not import any additional classes.

Do not add Java comments.

Only modify relevant lines as required.

Return only the modified method wrapped in the XML format shown below.

Place the Java code inside the <code> tag using a CDATA block with ```java formatting.

Just give me the fixed code snippet in XML format in <response> tag like the example below. I will apply the fix to my codebase. Do not import any additional libraries or classes or add java comments. If you can provide the fixed code snippet, please provide it in the following format and place the code snippet in the <code> tag within ```java block.
<response>
  <success>true</success>
  <code><![CDATA[
  ```java
  Your fixed code snippet here
  ```
    ]]>
  </code>
</response>

11:53:28.324 TRACE edu.ucr.cs.riple.core.checkers.nullaway.codefix.ChatGPT.ask
Retrieving response from cache
11:53:28.324 TRACE edu.ucr.cs.riple.core.checkers.nullaway.codefix.Response.tryCreate
Trying to create Response:
<response>
  <success>true</success>
  <code><![CDATA[
  ```java
  public default void detach() {
      Nullability.castToNonnull(Game.loop(), "properly initialized before usage").detach(this);
  }
  ```
  ]]>
  </code>
</response>
11:53:28.325 TRACE edu.ucr.cs.riple.core.checkers.nullaway.NullAway.lambda$resolveRemainingErrors$19
--------Exception occurred in computing fix-------- | 16
java.lang.NullPointerException: null
	at edu.ucr.cs.riple.core.checkers.nullaway.codefix.ChatGPT.fixDereferenceByAddingCastToNonnull(ChatGPT.java:476)
	at edu.ucr.cs.riple.core.checkers.nullaway.codefix.AdvancedNullAwayCodeFix.constructCastToNonnullChange(AdvancedNullAwayCodeFix.java:652)
	at edu.ucr.cs.riple.core.checkers.nullaway.codefix.AdvancedNullAwayCodeFix.resolveMethodDereferenceError(AdvancedNullAwayCodeFix.java:476)
	at edu.ucr.cs.riple.core.checkers.nullaway.codefix.AdvancedNullAwayCodeFix.resolveDereferenceErrorElementType(AdvancedNullAwayCodeFix.java:416)
	at edu.ucr.cs.riple.core.checkers.nullaway.codefix.AdvancedNullAwayCodeFix.resolveDereferenceError(AdvancedNullAwayCodeFix.java:403)
	at edu.ucr.cs.riple.core.checkers.nullaway.codefix.AdvancedNullAwayCodeFix.fix(AdvancedNullAwayCodeFix.java:138)
	at edu.ucr.cs.riple.core.checkers.nullaway.codefix.AdvancedNullAwayCodeFix.fixTriggeredErrorsForLocation(AdvancedNullAwayCodeFix.java:706)
	at edu.ucr.cs.riple.core.checkers.nullaway.codefix.AdvancedNullAwayCodeFix.resolveNullableReturnError(AdvancedNullAwayCodeFix.java:299)
	at edu.ucr.cs.riple.core.checkers.nullaway.codefix.AdvancedNullAwayCodeFix.fix(AdvancedNullAwayCodeFix.java:145)
	at edu.ucr.cs.riple.core.checkers.nullaway.codefix.AdvancedNullAwayCodeFix.lambda$resolveUninitializedField$2(AdvancedNullAwayCodeFix.java:338)
	at java.base/java.lang.Iterable.forEach(Iterable.java:75)
	at edu.ucr.cs.riple.core.checkers.nullaway.codefix.AdvancedNullAwayCodeFix.resolveUninitializedField(AdvancedNullAwayCodeFix.java:335)
	at edu.ucr.cs.riple.core.checkers.nullaway.codefix.AdvancedNullAwayCodeFix.fix(AdvancedNullAwayCodeFix.java:141)
	at edu.ucr.cs.riple.core.checkers.nullaway.NullAway.lambda$resolveRemainingErrors$19(NullAway.java:436)
	at java.base/java.util.ArrayList.forEach(ArrayList.java:1541)
	at edu.ucr.cs.riple.core.checkers.nullaway.NullAway.lambda$resolveRemainingErrors$20(NullAway.java:404)
	at java.base/java.util.HashMap.forEach(HashMap.java:1337)
	at edu.ucr.cs.riple.core.checkers.nullaway.NullAway.resolveRemainingErrors(NullAway.java:402)
	at edu.ucr.cs.riple.core.Annotator.annotate(Annotator.java:131)
	at edu.ucr.cs.riple.core.Annotator.start(Annotator.java:87)
	at edu.ucr.cs.riple.core.Main.main(Main.java:196)
