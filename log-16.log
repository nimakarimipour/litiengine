====================
Type='FIELD_NO_INIT', message='@NonNull static field gameLoop not initialized'
/home/nima/Developer/nullness-benchmarks/litiengine/src/de/gurkenlabs/litiengine/Game.java:86
  private static GameLoop gameLoop;
Log:
---NullAway.lambda$resolveRemainingErrors$17---
==============================
---NullAway.lambda$resolveRemainingErrors$17---
16 : TOP LEVEL CALL TO FIX ERROR: Type='FIELD_NO_INIT', message='@NonNull static field gameLoop not initialized'
/home/nima/Developer/nullness-benchmarks/litiengine/src/de/gurkenlabs/litiengine/Game.java:86
  private static GameLoop gameLoop;
---AdvancedNullAwayCodeFix.fix---
Fixing error: Type='FIELD_NO_INIT', message='@NonNull static field gameLoop not initialized'
/home/nima/Developer/nullness-benchmarks/litiengine/src/de/gurkenlabs/litiengine/Game.java:86
  private static GameLoop gameLoop;
---AdvancedNullAwayCodeFix.resolveUninitializedField---
Resolving uninitialized field errors for fields: [gameLoop]
---AdvancedNullAwayCodeFix.lambda$resolveUninitializedField$3---
Working on field: gameLoop
---AdvancedNullAwayCodeFix.investigateFieldNullability---
Investigating field nullability.
---AdvancedNullAwayCodeFix.investigateFieldNullability---
Checking if there is any method initializing field: gameLoop
---AdvancedNullAwayCodeFix.lambda$resolveUninitializedField$3---
Trying to fix errors for making the field nullable
---AdvancedNullAwayCodeFix.lambda$resolveUninitializedField$2---
Working on triggered error: Type='RETURN_NULLABLE', message='returning @Nullable expression from method with @NonNull return type'
/home/nima/Developer/nullness-benchmarks/litiengine/src/de/gurkenlabs/litiengine/Game.java:348
    return gameLoop;
---AdvancedNullAwayCodeFix.fix---
Fixing error: Type='RETURN_NULLABLE', message='returning @Nullable expression from method with @NonNull return type'
/home/nima/Developer/nullness-benchmarks/litiengine/src/de/gurkenlabs/litiengine/Game.java:348
    return gameLoop;
---AdvancedNullAwayCodeFix.resolveNullableReturnError---
Checking if the method is actually returning nullable.
---ChatGPT.checkNullabilityPossibilityAtErrorPoint---
Asking if the expression can be null at error point point
---ChatGPT.ask---
Asking ChatGPT:
In the method below, is there a possibility that the expression "return gameLoop;" at line "return gameLoop;" is null?
public static IGameLoop loop() {
    return gameLoop;
}
Give a single-word answer in XML format. If it is possible for the expression to be null, respond with:
```xml
<response>
    <reason><![CDATA[YOUR REASON]]></reason>
    <value>YES</value>
</response>
```
If it is not possible for the expression to be null, respond with:
```xml
<response>
    <reason><![CDATA[YOUR REASON]]></reason>
    <value>NO</value>
</response>
```
If you are unsure or need more information, respond with where you can ask for more details or what specific information you need.

If additional information is required, list each request inside a `<request>` tag. If no additional information is needed, omit the `<requests>` section.

Respond with:
```xml
<response>
    <reason><![CDATA[YOUR REASON]]></reason>
    <value>UNKNOWN</value>
    <!-- Include <requests> only if additional information is needed -->
    <requests>
        <request><![CDATA[YOUR REQUEST 1]]></request>
        <request><![CDATA[YOUR REQUEST 2]]></request>
    </requests>
</response>
```
---ChatGPT.sendRequestToOpenAI---
Retrieving response from cache
---Response.<init>---
Creating Response:
```xml
<response>
    <reason><![CDATA[The possibility of the expression "return gameLoop;" being null depends on the initialization of the "gameLoop" variable, which is not provided in the given method.]]></reason>
    <value>UNKNOWN</value>
    <requests>
        <request><![CDATA[Provide the declaration and initialization code for the "gameLoop" variable.]]></request>
    </requests>
</response>
```
---Response.<init>---
Response created:
Unknown: The possibility of the expression "return gameLoop;" being null depends on the initialization of the "gameLoop" variable, which is not provided in the given method.
---AdvancedNullAwayCodeFix.resolveNullableReturnError---
Checking if the method is a getter for field.
---AdvancedNullAwayCodeFix.resolveNullableReturnError---
Not a getter method.
---AdvancedNullAwayCodeFix.resolveNullableReturnError---
Made the method nullable and resolving triggered errors.
---AdvancedNullAwayCodeFix.fixTriggeredErrorsForLocation---
Fixing triggered errors for location: OnMethod{method='loop()', clazz='de.gurkenlabs.litiengine.Game'}
---AdvancedNullAwayCodeFix.getTriggeredErrorsFromLocation---
Impact not found, re-evaluating the location.
---AdvancedNullAwayCodeFix.fixTriggeredErrorsForLocation---
Triggered errors size: 50
---AdvancedNullAwayCodeFix.fixTriggeredErrorsForLocation---
Adding annotations for resolvable errors, size: 0
---AdvancedNullAwayCodeFix.fixTriggeredErrorsForLocation---
Resolving unresolvable error for triggered error: Type='DEREFERENCE_NULLABLE', message='dereferenced expression Game.loop() is @Nullable'
/home/nima/Developer/nullness-benchmarks/litiengine/src/de/gurkenlabs/litiengine/entities/Creature.java:253
      Game.loop().attach(controller);
---AdvancedNullAwayCodeFix.fix---
Fixing error: Type='DEREFERENCE_NULLABLE', message='dereferenced expression Game.loop() is @Nullable'
/home/nima/Developer/nullness-benchmarks/litiengine/src/de/gurkenlabs/litiengine/entities/Creature.java:253
      Game.loop().attach(controller);
---AdvancedNullAwayCodeFix.resolveDereferenceError---
Resolving dereference error: Type='DEREFERENCE_NULLABLE', message='dereferenced expression Game.loop() is @Nullable'
/home/nima/Developer/nullness-benchmarks/litiengine/src/de/gurkenlabs/litiengine/entities/Creature.java:253
      Game.loop().attach(controller);
---AdvancedNullAwayCodeFix.resolveDereferenceError---
Checking nullability possibility at error point
---ChatGPT.checkNullabilityPossibilityAtErrorPoint---
Asking if the expression can be null at error point point
---ChatGPT.ask---
Asking ChatGPT:
In the method below, is there a possibility that the expression "Game.loop()" at line "Game.loop().attach(controller);" is null?
protected void updateAnimationController() {
    IEntityAnimationController<?> controller = this.createAnimationController();
    this.getControllers().addController(controller);
    if (Game.world().environment() != null && Game.world().environment().isLoaded()) {
      Game.loop().attach(controller);
    }
}
Give a single-word answer in XML format. If it is possible for the expression to be null, respond with:
```xml
<response>
    <reason><![CDATA[YOUR REASON]]></reason>
    <value>YES</value>
</response>
```
If it is not possible for the expression to be null, respond with:
```xml
<response>
    <reason><![CDATA[YOUR REASON]]></reason>
    <value>NO</value>
</response>
```
If you are unsure or need more information, respond with where you can ask for more details or what specific information you need.

If additional information is required, list each request inside a `<request>` tag. If no additional information is needed, omit the `<requests>` section.

Respond with:
```xml
<response>
    <reason><![CDATA[YOUR REASON]]></reason>
    <value>UNKNOWN</value>
    <!-- Include <requests> only if additional information is needed -->
    <requests>
        <request><![CDATA[YOUR REQUEST 1]]></request>
        <request><![CDATA[YOUR REQUEST 2]]></request>
    </requests>
</response>
```
---ChatGPT.sendRequestToOpenAI---
Retrieving response from cache
---Response.<init>---
Creating Response:
```xml
<response>
    <reason><![CDATA[The possibility of Game.loop() being null depends on the implementation of the Game class. Without the specific implementation details of how Game and its loop method are defined and initialized, it cannot be definitively determined whether Game.loop() could return null.]]></reason>
    <value>UNKNOWN</value>
    <requests>
        <request><![CDATA[Need the implementation details of the Game class and how the loop method is initialized.]]></request>
    </requests>
</response>
```
---Response.<init>---
Response created:
Unknown: The possibility of Game.loop() being null depends on the implementation of the Game class. Without the specific implementation details of how Game and its loop method are defined and initialized, it cannot be definitively determined whether Game.loop() could return null.
---AdvancedNullAwayCodeFix.resolveMethodDereferenceError---
Resolving method dereference error.
---AdvancedNullAwayCodeFix.resolveMethodDereferenceError---
Method is in annotated package. Checking if the method is returning nullable.
---AdvancedNullAwayCodeFix.investigateMethodReturnNullability---
Checking if the method is returning nullable.
---ChatGPT.checkIfMethodIsReturningNullable---
Asking if the method is returning nullable: loop()
---ChatGPT.ask---
Asking ChatGPT:
In the method below, is there a possibility that the method returns null based only on its body? Consider the following points:

- The method may have multiple return paths; consider all return statements.
- If the method calls another method, do not assume its return value unless its full declaration is provided. Request its declaration if needed.
- The method may throw an exception instead of returning null. An exception path should not be considered a null return.
- Ensure you request the declarations of any methods whose return values directly or indirectly impact this method’s return value before making a conclusion.
- Carefully analyze all conditions and prior operations that may guarantee a non-null return value.

@Nullable public static IGameLoop loop() {
    return gameLoop;
}

Here are the method definitions in addition to the method inquired:

Depth: 0
```java
class de.gurkenlabs.litiengine.Game {
@Nullable public static IGameLoop loop() {
    return gameLoop;
}
}
```


Response Format:
Provide the answer in **XML format** as follows:

#### If the method **cannot** return `null`:
```xml
<response>
  <reason><![CDATA[EXPLAIN WHY THE METHOD CANNOT RETURN NULL]]></reason>
  <value>NO</value>
</response>
```

#### If the method can return null:
```xml
<response>
  <reason><![CDATA[EXPLAIN WHY THE METHOD CAN RETURN NULL]]></reason>
  <value>YES</value>
</response>
```

#### If you are unsure or need more information, respond with where you can ask for more details or what specific information you need.

#### If you are unsure or If there are any methods that directly or indirectly affect the return value and are not fully disclosed, request their declarations first, in the following format:
<response>
  <reason><![CDATA[YOUR REASON]]></reason>
  <value>UNKNOWN</value>
  <methods>
    <method>methodName</method>
  </methods>
</response>

If additional information is required other than method declaration, list each request inside a `<request>` tag. If no additional information is needed, omit the `<requests>` section.

Respond with:
```xml
<response>
    <reason><![CDATA[YOUR REASON]]></reason>
    <value>UNKNOWN</value>
    <!-- Include <requests> only if additional information is needed -->
    <requests>
        <request><![CDATA[YOUR REQUEST 1]]></request>
        <request><![CDATA[YOUR REQUEST 2]]></request>
    </requests>
</response>
```

Additional Notes:
Be precise in your reasoning.
If a method’s return value depends on another method not provided, request its declaration before making a conclusion.
If the method can return null in some cases but not others, explain under what conditions it can happen.

---ChatGPT.sendRequestToOpenAI---
Retrieving response from cache
---Response.<init>---
Creating Response:
```xml
<response>
  <reason><![CDATA[The method `loop` returns the variable `gameLoop`. Without the initialization or assignment details of `gameLoop`, it's unclear whether it can be null. The possibility of `gameLoop` being uninitialized or set to null elsewhere in the program means `loop` could potentially return null. Further information on `gameLoop` is required.]]></reason>
  <value>UNKNOWN</value>
  <requests>
    <request><![CDATA[Please provide the declaration and initialization of the variable `gameLoop` in the class `de.gurkenlabs.litiengine.Game`.]]></request>
  </requests>
</response>
```
---Response.<init>---
Response created:
Unknown: The method `loop` returns the variable `gameLoop`. Without the initialization or assignment details of `gameLoop`, it's unclear whether it can be null. The possibility of `gameLoop` being uninitialized or set to null elsewhere in the program means `loop` could potentially return null. Further information on `gameLoop` is required.
---AdvancedNullAwayCodeFix.investigateMethodReturnNullability---
Could not determine the nullability and model did not ask for any method.
---ChatGPT.checkIfMethodIsReturningNullableOnCallSite---
Asking if the method is returning nullable on the call site: Game.loop()
---ChatGPT.ask---
Asking ChatGPT:
In the method below, is there a possibility that the method returns null at the given call site?

```java
@Nullable public static IGameLoop loop() {
    return gameLoop;
}
```

## Guidelines:
- The method may have multiple return paths; consider all return statements.
- If the method calls another method, do not assume its return value unless its full declaration is provided. Request its declaration if needed.
- The method may throw an exception instead of returning null. An exception path should not be considered a null return.
- Ensure you request the declarations of any methods whose return values directly or indirectly impact this method’s return value before making a conclusion.
- If the method returns a value that is determined by a parameter, evaluate based on the actual argument at the given call site.
- Analyze based only on the specific invocation provided. Do not generalize to all possible inputs.- If the return value is guaranteed to be non-null at the call site, the answer should be a definitive NO.
- Do not generalize based on all possible inputs—your answer must be based only on the given invocation.
- Focus only on the given call site, not all possible invocations.

### call site:
Game.loop()

Here are the method definitions and the call chain for this method, showing the sequence of calls from the method to its callers at each depth level:

Depth: 0
```java
class de.gurkenlabs.litiengine.Game {
@Nullable public static IGameLoop loop() {
    return gameLoop;
}
}
```
Depth: 1
```java
class de.gurkenlabs.litiengine.environment.GameWorld {
public void loadEnvironment(@Nullable final Environment env) {
    Lock lock = Game.loop().getLock();
    lock.lock();
    try {
      unloadEnvironment();
      this.environment = env;
      if (env != null) {
        this.addEnvironment(env);

        if (env.getGravity() == 0 && this.gravity() != 0) {
          env.setGravity(this.gravity());
        }

        env.load();
        for (final EnvironmentLoadedListener listener : this.loadedListeners) {
          listener.loaded(env);
        }

        // call map specific listeners
        String mapName = getMapName(env);
        if (mapName != null && this.environmentLoadedListeners.containsKey(mapName)) {

          // for the default camera we center the camera on the environment
          if (this.camera().getClass().equals(Camera.class)) {
            camera().setFocus(env.getCenter());
          }

          for (EnvironmentLoadedListener listener : this.environmentLoadedListeners.get(mapName)) {
            listener.loaded(env);
          }
        }
      }
    } finally {
      lock.unlock();
    }
}public void setCamera(@Nullable final ICamera cam) {
    if (this.camera() != null) {
      Game.loop().detach(camera);
    }

    camera = cam;

    if (cam != null && !Game.isInNoGUIMode()) {
      Game.loop().attach(cam);
      cam.updateFocus();
    }
}
}
```
```java
class de.gurkenlabs.litiengine.entities.behavior.EntityNavigator {
public EntityNavigator(final IMobileEntity entity, final PathFinder pathFinder) {
    this.cancelNavigationConditions = new CopyOnWriteArrayList<>();
    this.listeners = new CopyOnWriteArrayList<>();
    this.entity = entity;
    this.pathFinder = pathFinder;
    this.setAcceptableError(DEFAULT_ACCEPTABLE_ERROR);
    Game.loop().attach(this);
}
}
```
```java
class de.gurkenlabs.litiengine.GameWindow {
private static void initializeWindowEventListeners(Window window) {

    window.addWindowStateListener(
        e -> {
          if (e.getNewState() == Frame.ICONIFIED) {
            Game.loop().setTickRate(ICONIFIED_MAX_FPS);
          } else {
            Game.loop().setTickRate(Game.config().client().getMaxFps());
          }
        });

    window.addWindowFocusListener(
        new WindowFocusListener() {
          @Override
          public void windowLostFocus(WindowEvent e) {
            if (Game.config().graphics().reduceFramesWhenNotFocused()) {
              Game.loop().setTickRate(NONE_FOCUS_MAX_FPS);
            }
          }

          @Override
          public void windowGainedFocus(WindowEvent e) {
            Game.loop().setTickRate(Game.config().client().getMaxFps());
          }
        });

    window.addWindowListener(
        new WindowAdapter() {
          @Override
          public void windowClosing(final WindowEvent event) {
            Game.exit();
          }
        });
}
}
```
```java
class de.gurkenlabs.litiengine.gui.screens.ScreenManager {
public void display(@Nullable final Screen screen) {
    if (Game.hasStarted() && Game.time().since(this.lastScreenChange) < this.getChangeCooldown()) {
      log.log(
          Level.INFO,
          "Skipping displaying of screen {0} because screen changing is currently on cooldown.",
          screen != null ? screen.getName() : "");
      return;
    }

    final Screen previous = this.current();
    if (previous != null) {
      previous.suspend();
    }

    if (screen != null && !this.screens.contains(screen)) {
      this.screens.add(screen);
    }

    this.currentScreen = screen;
    if (!Game.isInNoGUIMode() && this.current() != null) {
      this.current().prepare();
    }

    this.lastScreenChange = Game.loop().getTicks();

    final ScreenChangedEvent event = new ScreenChangedEvent(this.current(), previous);
    for (final ScreenChangedListener listener : this.screenChangedListeners) {
      listener.changed(event);
    }
}
}
```
```java
class de.gurkenlabs.litiengine.abilities.effects.Effect {
@Override
  public void update() {

    for (final Iterator<EffectApplication> iterator = this.getActiveAppliances().iterator();
        iterator.hasNext(); ) {
      final EffectApplication appliance = iterator.next();
      // if the effect duration is reached
      if (this.hasEnded(appliance)) {

        iterator.remove();
        this.cease(appliance);
      }
    }

    // 4. unregister if all appliances are finished
    if (this.getActiveAppliances().isEmpty()) {
      Game.loop().detach(this);
    }
}public void apply(final Shape impactArea) {
    final List<ICombatEntity> affected = this.lookForAffectedEntities(impactArea);
    for (final ICombatEntity affectedEntity : affected) {
      this.apply(affectedEntity);
    }

    this.appliances.add(new EffectApplication(affected, impactArea));

    // if it is the first appliance -> register for update
    if (this.appliances.size() == 1) {
      Game.loop().attach(this);
    }
}
}
```
```java
class de.gurkenlabs.litiengine.GameTime {
public long toTicks(final int milliseconds) {
    return this.toTicks(milliseconds, Game.loop().getTickRate());
}public long since(final long tick) {
    return toMilliseconds(Game.loop().getTicks() - tick);
}public long now() {
    return Game.loop().getTicks();
}public long sinceGameStart() {
    return this.toMilliseconds(Game.loop().getTicks());
}@Override
  public void loaded(Environment environment) {
    environmentLoaded = Game.loop().getTicks();
}public long toMilliseconds(final long ticks) {
    return this.toMilliseconds(ticks, Game.loop().getTickRate());
}
}
```
```java
class de.gurkenlabs.litiengine.GameMetrics {
@Override
  public void render(final Graphics2D g) {
    this.updateMetrics();

    if (!Game.config().client().showGameMetrics()) {
      return;
    }

    this.currentOffsetY = 0;

    g.setColor(this.renderColor);

    // render client metrics
    this.drawTitle(g, "[client]");
    this.drawMetric(g, "fps       : " + this.getFramesPerSecond());
    this.drawMetric(g, "max fps   : " + this.maxFramesPerSecond);
    this.drawMetric(g, "updatables: " + Game.loop().getUpdatableCount());

    // render jvm metrics if debug is enabled
    if (Game.config().debug().isDebugEnabled()) {
      this.drawTitle(g, "[jvm]");
      this.drawMetric(g, "java      : " + this.javaVersion);
      this.drawMetric(g, "memory    : " + String.format("%-5.5s", this.usedMemory) + " MB");
      this.drawMetric(g, "threads   : " + Thread.activeCount());
    }

    // render rendering metrics
    if (!this.renderMetrics.isEmpty()) {
      this.drawTitle(g, "[update]");

      for (RenderMetrics metric : this.renderMetrics) {
        this.drawMetric(g, metric.toString());
      }

      this.renderMetrics.clear();
    }
}
}
```
```java
class de.gurkenlabs.litiengine.graphics.emitters.Emitter {
public void deactivate() {
    if (!this.activated) {
      return;
    }

    this.activated = false;
    this.getParticles().clear();
    this.aliveTime = 0;
    this.activationTick = 0;
    this.lastSpawn = 0;
    Game.loop().detach(this);
}public void activate() {
    if (this.activated) {
      return;
    }

    this.activated = true;
    this.activationTick = Game.time().now();
    Game.loop().attach(this);
}@Override
  public void update() {
    if (this.isPaused()) {
      return;
    }

    // clear particles if the effect time to life is reached
    if (this.isFinished()) {
      for (EmitterFinishedListener listener : this.finishedListeners) {
        listener.finished(this);
      }

      this.delete();
      return;
    }

    final float updateRatio = (float) this.data().getUpdateRate() / Game.loop().getTickRate();
    for (final Particle p : this.getParticles().stream().collect(Collectors.toList())) {
      if (this.particleCanBeRemoved(p)) {
        // remove dead particles
        this.particles.remove(p);
        continue;
      }

      p.update(this.getOrigin(), updateRatio);
    }

    this.aliveTime = Game.time().since(this.activationTick);
    if ((this.data().getSpawnRate() == 0
        || Game.time().since(this.lastSpawn) >= this.data().getSpawnRate())) {
      this.lastSpawn = Game.time().now();
      this.spawnParticle();
    }
}
}
```
```java
class de.gurkenlabs.litiengine.entities.behavior.IBehaviorController {
public default void attach() {
    Game.loop().attach(this);
}public default void detach() {
    Game.loop().detach(this);
}
}
```
```java
class de.gurkenlabs.litiengine.abilities.AbilityExecution {
AbilityExecution(final Ability ability) {
    this.appliedEffects = new CopyOnWriteArrayList<>();
    this.ability = ability;
    this.executionTicks = Game.time().now();
    this.impactArea = ability.calculateImpactArea();
    this.castLocation = ability.getExecutor().getCenter();
    Game.loop().attach(this);
}@Override
  public void update() {
    // if there a no effects to apply -> unregister this instance and we're done
    if (this.getAbility().getEffects().isEmpty()
        || this.getAbility().getEffects().size() == this.getAppliedEffects().size()) {
      Game.loop().detach(this);
      return;
    }

    // handle all effects from the ability that were not applied yet
    for (final Effect effect : this.getAbility().getEffects()) {
      // if the ability was not executed yet or the delay of the effect is not
      // yet reached
      if (this.getAppliedEffects().contains(effect)
          || Game.time().since(this.getExecutionTicks()) < effect.getDelay()) {
        continue;
      }

      effect.apply(this.getExecutionImpactArea());
      this.getAppliedEffects().add(effect);
    }
}
}
```
```java
class de.gurkenlabs.litiengine.GameWindow$3 {
@Override
          public void windowGainedFocus(WindowEvent e) {
            Game.loop().setTickRate(Game.config().client().getMaxFps());
}@Override
          public void windowLostFocus(WindowEvent e) {
            if (Game.config().graphics().reduceFramesWhenNotFocused()) {
              Game.loop().setTickRate(NONE_FOCUS_MAX_FPS);
            }
}
}
```
```java
class de.gurkenlabs.litiengine.environment.EntitySpawner {
protected void spawnNewEntities() {
    if (this.getSpawnMode() != SpawnMode.CUSTOMSPAWNPOINTS && this.getSpawnPoints().isEmpty()) {
      return;
    }

    switch (this.getSpawnMode()) {
      case ALLSPAWNPOINTS:
        for (int i = 0; i < this.getSpawnPoints().size(); i++) {
          final int index = i;
          Game.loop()
              .perform(
                  this.getSpawnDelay() + this.getSpawnDelay() * i,
                  () -> this.spawn(this.getSpawnPoints().get(index), this.getSpawnAmount()));
        }
        break;
      case ONERANDOMSPAWNPOINT:
        this.spawn(Game.random().choose(this.getSpawnPoints()), this.getSpawnAmount());
        break;
      case RANDOMSPAWNPOINTS:
        for (int i = 0; i < this.getSpawnAmount(); i++) {
          Game.loop()
              .perform(
                  this.getSpawnDelay() + this.getSpawnDelay() * i,
                  () -> this.spawn(Game.random().choose(this.getSpawnPoints()), 1));
        }
        break;
      case CUSTOMSPAWNPOINTS:
        List<Spawnpoint> spawnPoints =
            this.customSpawnpoints != null
                ? this.customSpawnpoints.apply(this)
                : this.getCustomSpawnpoints();

        int index = 0;
        for (Spawnpoint spawn : spawnPoints) {
          Game.loop()
              .perform(
                  this.getSpawnDelay() + this.getSpawnDelay() * index, () -> this.spawn(spawn, 1));
          index++;
        }
        break;
      default:
        break;
    }
}
}
```
```java
class de.gurkenlabs.litiengine.tweening.TweenEngine {
@Override
  public void start() {
    Game.loop().attach(this);
}@Override
  public void terminate() {
    Game.loop().detach(this);
}
}
```
```java
class de.gurkenlabs.litiengine.gui.SpeechBubble {
public void hide() {
    Game.world().environment().removeRenderable(this);
    Game.loop().detach(this);
    if (activeSpeechBubbles.get(this.getEntity()) != null
        && activeSpeechBubbles.remove(this.getEntity()).equals(this)) {
      activeSpeechBubbles.remove(this.getEntity());
    }

    for (SpeechBubbleListener listener : this.listeners) {
      listener.hidden();
    }
}private SpeechBubble(
      final IEntity entity,
      final String text,
      @Nullable SpeechBubbleAppearance appearance,
      @Nullable Font font) {
    if (appearance == null) {
      this.appearance = DEFAULT_APPEARANCE;
    } else {
      this.appearance = appearance;
    }

    final SpeechBubble active = activeSpeechBubbles.get(entity);
    if (active != null) {
      active.hide();
    }
    this.setFont(font);

    this.textBoxWidth = (float) (entity.getWidth() * 4);
    this.entity = entity;

    this.currentText = text;
    this.currentTextDisplayTime = DISPLAYTIME_MIN + text.length() * DISPLAYTIME_PER_LETTER;

    this.lastTextDisplay = Game.time().now();
    this.createBubbleImage();
    entity.getEnvironment().add(this, RenderType.UI);
    Game.loop().attach(this);
    activeSpeechBubbles.put(entity, this);
}
}
```
```java
class de.gurkenlabs.litiengine.entities.Prop {
private void updateAnimationController() {
    IEntityAnimationController<?> controller = this.createAnimationController();
    this.getControllers().addController(controller);
    if (Game.world().environment() != null && Game.world().environment().isLoaded()) {
      Game.loop().attach(controller);
    }
}
}
```
```java
class de.gurkenlabs.litiengine.graphics.FreeFlightCamera {
public FreeFlightCamera(final Point2D focus) {
    this.setFocus(focus);
    this.velocity = DEFAULT_SCROLL_PIXELS_PER_SECOND;
    this.scrollPadding = DEFAULT_SCROLL_PADDING;
    this.setClampToMap(true);

    Game.loop().attach(this);
}private void handleFreeFlightCamera() {
    if (Game.world().environment() == null || Game.world().environment().getMap() == null) {
      return;
    }

    final Point2D mouseLocation = Input.mouse().getLocation();

    final double scrollSpeed =
        this.getVelocity()
            / (double) Game.loop().getTickRate()
            * Game.config().input().getMouseSensitivity();

    double x = this.getFocus().getX();
    double y = this.getFocus().getY();

    double deltaX = 0;
    if (mouseLocation.getX() < this.getScrollPadding()) {
      deltaX -= scrollSpeed;
    } else if (Game.window().getResolution().getWidth() - mouseLocation.getX()
        < this.getScrollPadding()) {
      deltaX += scrollSpeed;
    }

    double deltaY = 0;
    if (mouseLocation.getY() < this.getScrollPadding()) {
      deltaY -= scrollSpeed;
    } else if (Game.window().getResolution().getHeight() - mouseLocation.getY()
        < this.getScrollPadding()) {
      deltaY += scrollSpeed;
    }

    x += deltaX;
    y += deltaY;

    this.setFocus(new Point2D.Double(x, y));
}
}
```
```java
class de.gurkenlabs.litiengine.environment.Environment {
private static void dispose(final Collection<? extends IEntity> entities) {
    for (final IEntity entity : entities) {
      if (entity instanceof IUpdateable) {
        Game.loop().detach((IUpdateable) entity);
      }

      entity.detachControllers();
    }
}private static void loadUpdatableOrEmitterEntity(IEntity entity) {
    if (entity instanceof Emitter) {
      final Emitter emitter = (Emitter) entity;
      if (emitter.isActivateOnInit()) {
        emitter.activate();
      }
    } else if (entity instanceof IUpdateable) {
      Game.loop().attach((IUpdateable) entity);
    }
}private void unload(final IEntity entity) {
    // 1. remove from physics engine
    if (entity instanceof ICollisionEntity) {
      Game.physics().remove((ICollisionEntity) entity);
    }

    // 2. unregister from update
    if (entity instanceof IUpdateable) {
      Game.loop().detach((IUpdateable) entity);
    }

    if (entity instanceof IMobileEntity) {
      this.removeGravity((IMobileEntity) entity);
    }

    // 3. detach all controllers
    entity.detachControllers();

    if (entity instanceof Emitter) {
      Emitter em = (Emitter) entity;
      em.deactivate();
    }

    if (this.loaded && (entity instanceof LightSource || entity instanceof StaticShadow)) {
      this.updateLighting(entity);
    }

    entity.removed(this);
}
}
```
```java
class de.gurkenlabs.litiengine.graphics.animation.Animation {
@Override
  public void update() {
    // do nothing if the animation is not playing or the current keyframe is not finished
    if (!this.isPlaying()
        || Game.time().since(this.lastFrameUpdate) < this.getCurrentKeyFrame().getDuration()) {
      return;
    }

    // if we are not looping and the last keyframe is finished, we terminate the animation
    if (!this.isLooping() && this.isLastKeyFrame()) {
      this.terminate();
      return;
    }

    // make sure, we stay inside the keyframe list
    final int newFrameIndex =
        (this.getKeyframes().indexOf(this.currentFrame) + 1) % this.getKeyframes().size();
    final KeyFrame previousFrame = this.currentFrame;
    this.currentFrame = this.getKeyframes().get(newFrameIndex);

    for (KeyFrameListener listener : this.listeners) {
      listener.currentFrameChanged(previousFrame, this.currentFrame);
    }

    this.lastFrameUpdate = Game.loop().getTicks();
}public void restart() {
    this.currentFrame = this.firstFrame;
    this.lastFrameUpdate = Game.loop().getTicks();
}
}
```
```java
class de.gurkenlabs.litiengine.physics.MovementController {
@Override
  public void attach() {
    Game.loop().attach(this);
}private void handleForces() {
    // clean up forces
    this.activeForces.forEach(
        x -> {
          if (x.hasEnded()) {
            this.activeForces.remove(x);
          }
        });

    if (this.activeForces.isEmpty()) {
      return;
    }

    // disable turn-on-move for force handling
    boolean turn = this.getEntity().turnOnMove();
    this.getEntity().setTurnOnMove(false);
    try {
      double deltaX = 0;
      double deltaY = 0;
      for (final Force force : this.activeForces) {
        if (force.cancelOnReached() && force.hasReached(this.getEntity())) {
          force.end();
          continue;
        }

        final Point2D collisionBoxCenter = this.getEntity().getCollisionBoxCenter();
        final double angle =
            GeometricUtilities.calcRotationAngleInDegrees(collisionBoxCenter, force.getLocation());
        final double strength =
            Game.loop().getDeltaTime() * 0.001f * force.getStrength() * Game.loop().getTimeScale();
        deltaX += GeometricUtilities.getDeltaX(angle, strength);
        deltaY += GeometricUtilities.getDeltaY(angle, strength);
      }

      final Point2D target =
          new Point2D.Double(this.getEntity().getX() + deltaX, this.getEntity().getY() + deltaY);
      final boolean success = Game.physics().move(this.getEntity(), target);
      if (!success) {
        for (final Force force : this.activeForces) {
          if (force.cancelOnCollision()) {
            force.end();
          }
        }
      }
    } finally {
      this.getEntity().setTurnOnMove(turn);
    }
}@Override
  public void detach() {
    Game.loop().detach(this);
}public void handleMovement() {
    if (!this.isMovementAllowed()) {
      this.velocity = 0;
      return;
    }

    // max distance an entity can travel within one tick
    final double maxPixelsPerTick = this.getEntity().getTickVelocity();
    final double deltaTime = Game.loop().getDeltaTime() * Game.loop().getTimeScale();

    final double acceleration =
        this.getEntity().getAcceleration() == 0
            ? maxPixelsPerTick
            : deltaTime / this.getEntity().getAcceleration() * maxPixelsPerTick;
    final double deceleration =
        this.getEntity().getDeceleration() == 0
            ? this.getVelocity()
            : deltaTime / this.getEntity().getDeceleration() * maxPixelsPerTick;

    double dx = this.getDx();
    double dy = this.getDy();
    this.setDx(0);
    this.setDy(0);

    final double deltaVelocity =
        Math.min(Math.sqrt(Math.pow(dx, 2) + Math.pow(dy, 2)), acceleration);
    if (deltaVelocity != 0) {
      double newVelocity = this.getVelocity() + deltaVelocity;
      this.setVelocity(newVelocity);
    } else {
      final double newVelocity = Math.max(0, this.getVelocity() - deceleration);
      this.setVelocity(newVelocity);
      dx = GeometricUtilities.getDeltaX(this.moveAngle);
      dy = GeometricUtilities.getDeltaY(this.moveAngle);
    }

    if (this.getVelocity() == 0) {
      this.moveAngle = 0;
      return;
    }

    // actually move entity
    this.moveEntity(dx, dy);
}
}
```
```java
class de.gurkenlabs.litiengine.graphics.animation.AnimationController {
public void detach() {
    Game.loop().detach(this);
}public void attach() {
    Game.loop().attach(this);
}
}
```
```java
class de.gurkenlabs.litiengine.graphics.Camera {
@Override
  public void setZoom(final float targetZoom, final int delay) {
    if (delay == 0) {

      this.zoom = targetZoom;
      this.targetZoom = 0;
      this.zoomDelay = 0;
      this.zoomTick = 0;
      this.zoomStep = 0;

      final ZoomChangedEvent event = new ZoomChangedEvent(this, targetZoom);
      for (final ZoomChangedListener listener : this.zoomListeners) {
        listener.zoomChanged(event);
      }
    } else {
      this.zoomTick = Game.time().now();
      this.targetZoom = targetZoom;
      this.zoomDelay = delay;

      final double tickduration = 1000 / (double) Game.loop().getTickRate();
      final double tickAmount = delay / tickduration;
      final float totalDelta = this.targetZoom - this.zoom;
      this.zoomStep = tickAmount > 0 ? (float) (totalDelta / tickAmount) : totalDelta;
    }
}
}
```
```java
class de.gurkenlabs.litiengine.Game {
public static synchronized void init(String... args) {
    if (initialized) {
      log().log(Level.INFO, "The game has already been initialized.");
      return;
    }

    log.init();
    handleCommandLineArguments(args);

    config().load();
    Locale.setDefault(new Locale(config().client().getCountry(), config().client().getLanguage()));

    gameLoop = new GameLoop("Main Update Loop", config().client().getMaxFps());
    loop().attach(physics());
    loop().attach(world());

    // setup default exception handling for render and update loop
    setUncaughtExceptionHandler(
        new DefaultUncaughtExceptionHandler(config().client().exitOnError()));

    screenManager = new ScreenManager();
    gameWindow = new GameWindow();

    // initialize  the game window
    window().init();
    world.setCamera(new Camera());

    for (GameListener listener : gameListeners) {
      listener.initialized(args);
    }

    if (!isInNoGUIMode()) {
      window().getRenderComponent().onRendered(g -> metrics().render(g));

      graphics()
          .addEntityRenderedListener(
              e -> DebugRenderer.renderEntityDebugInfo(e.getGraphics(), e.getEntity()));

      window().getRenderComponent().onFpsChanged(fps -> metrics().setFramesPerSecond(fps));
      window()
          .setIcons(
              Arrays.asList(
                  Resources.images().get("liti-logo-x16.png"),
                  Resources.images().get("liti-logo-x20.png"),
                  Resources.images().get("liti-logo-x32.png"),
                  Resources.images().get("liti-logo-x48.png")));

      Input.keyboard()
          .onKeyTyped(
              KeyEvent.VK_PRINTSCREEN,
              key -> {
                // don't take a screenshot if a modifier is active
                if (key.getModifiers() != 0) {
                  return;
                }

                window().getRenderComponent().takeScreenshot();
              });
    }

    Runtime.getRuntime().addShutdownHook(new Thread(Game::terminate, "Shutdown"));

    initialized = true;
}
}
```
```java
class de.gurkenlabs.litiengine.entities.Creature {
protected void updateAnimationController() {
    IEntityAnimationController<?> controller = this.createAnimationController();
    this.getControllers().addController(controller);
    if (Game.world().environment() != null && Game.world().environment().isLoaded()) {
      Game.loop().attach(controller);
    }
}@Override
  public float getTickVelocity() {
    // pixels per ms multiplied by the passed ms
    // ensure that entities don't travel too far in case of lag
    return Math.min(Game.loop().getDeltaTime(), GameLoop.TICK_DELTATIME_LAG)
        * 0.001F
        * this.getVelocity().get()
        * Game.loop().getTimeScale();
}
}
```
Depth: 2
```java
class de.gurkenlabs.litiengine.environment.GameWorld {
public void clear() {
    this.unloadEnvironment();
    this.environments.clear();
    this.setCamera(null);
    Game.physics().clear();

    this.environmentListeners.clear();
    this.environmentLoadedListeners.clear();
    this.environmentUnloadedListeners.clear();

    this.listeners.clear();
    this.loadedListeners.clear();
    this.unloadedListeners.clear();
}@Nullable
  public Environment loadEnvironment(IMap map) {
    Environment env = this.getEnvironment(map);
    this.loadEnvironment(env);
    return env;
}@Nullable
  public Environment loadEnvironment(String mapName) {
    Environment env = this.getEnvironment(mapName);
    this.loadEnvironment(env);
    return env;
}
}
```
```java
class de.gurkenlabs.litiengine.GameWindow {
GameWindow() {
    this.hostControl = new JFrame();

    this.resolutionChangedListeners = new CopyOnWriteArrayList<>();

    this.renderCanvas = new RenderComponent(Game.config().graphics().getResolution());
    this.cursor = new MouseCursor();
    if (!Game.isInNoGUIMode()) {
      this.hostControl.setBackground(Color.BLACK);
      this.hostControl.add(this.renderCanvas);

      this.initializeEventListeners();

      this.hostControl.setTitle(Game.info().getTitle());
      this.hostControl.setDefaultCloseOperation(WindowConstants.DO_NOTHING_ON_CLOSE);
      initializeWindowEventListeners(this.hostControl);
    }
}
}
```
```java
class de.gurkenlabs.litiengine.GameTime {
public long sinceEnvironmentLoad() {
    return this.since(this.environmentLoaded);
}public long since(final long tick) {
    return toMilliseconds(Game.loop().getTicks() - tick);
}public long sinceGameStart() {
    return this.toMilliseconds(Game.loop().getTicks());
}
}
```
```java
class de.gurkenlabs.litiengine.abilities.effects.Effect {
protected void cease(final EffectApplication appliance) {
    // 1. cease the effect for all affected entities
    for (final ICombatEntity entity : appliance.getAffectedEntities()) {
      this.cease(entity);
    }

    // 2. apply follow up effects
    this.getFollowUpEffects().forEach(followUp -> followUp.apply(appliance.getImpactArea()));
}protected boolean hasEnded(final EffectApplication appliance) {
    final long effectDuration = Game.time().since(appliance.getAppliedTicks());
    return effectDuration > this.getDuration();
}
}
```
```java
class de.gurkenlabs.litiengine.abilities.effects.EffectApplication {
protected EffectApplication(final List<ICombatEntity> affectedEntities, final Shape impactArea) {
    this.applied = Game.time().now();
    this.affectedEntities = affectedEntities;
    this.impactArea = impactArea;
}
}
```
```java
class de.gurkenlabs.litiengine.entities.CombatEntity {
@Override
  public boolean wasHit(int timeSpan) {
    return Game.time().since(this.lastHit) < timeSpan;
}@Override
  public void hit(final int damage, @Nullable final Ability ability) {
    if (this.isDead()) {
      return;
    }

    if (!this.isIndestructible()) {
      this.getHitPoints().modifyBaseValue(new AttributeModifier<>(Modification.SUBTRACT, damage));
    }

    final EntityHitEvent event = new EntityHitEvent(this, ability, damage, this.isDead());

    for (final CombatEntityListener listener : this.listeners) {
      listener.hit(event);
    }

    for (final CombatEntityHitListener listener : this.hitListeners) {
      listener.hit(event);
    }

    if (this.isDead()) {
      this.fireDeathEvent();
      this.setCollision(false);
    }

    this.lastHit = Game.time().now();
}
}
```
```java
class de.gurkenlabs.litiengine.graphics.ImageEffect {
protected ImageEffect(final int ttl, final String name) {
    this.ttl = ttl;
    this.name = name;
    this.aliveTick = Game.time().now();
}@Override
  public long getAliveTime() {
    return Game.time().since(this.aliveTick);
}
}
```
```java
class de.gurkenlabs.litiengine.abilities.AbilityExecution {
AbilityExecution(final Ability ability) {
    this.appliedEffects = new CopyOnWriteArrayList<>();
    this.ability = ability;
    this.executionTicks = Game.time().now();
    this.impactArea = ability.calculateImpactArea();
    this.castLocation = ability.getExecutor().getCenter();
    Game.loop().attach(this);
}@Override
  public void update() {
    // if there a no effects to apply -> unregister this instance and we're done
    if (this.getAbility().getEffects().isEmpty()
        || this.getAbility().getEffects().size() == this.getAppliedEffects().size()) {
      Game.loop().detach(this);
      return;
    }

    // handle all effects from the ability that were not applied yet
    for (final Effect effect : this.getAbility().getEffects()) {
      // if the ability was not executed yet or the delay of the effect is not
      // yet reached
      if (this.getAppliedEffects().contains(effect)
          || Game.time().since(this.getExecutionTicks()) < effect.getDelay()) {
        continue;
      }

      effect.apply(this.getExecutionImpactArea());
      this.getAppliedEffects().add(effect);
    }
}
}
```
```java
class de.gurkenlabs.litiengine.tweening.TweenEngine {
@Override
  public void update() {
    for (final Tweenable target : this.getTweens().keySet()) {
      for (final Tween tween : this.getTweens().get(target).values()) {
        if (tween.hasStopped()) {
          continue;
        }
        final long elapsed = Game.time().since(tween.getStartTime());
        if (elapsed >= tween.getDuration()) {
          tween.stop();
          continue;
        }
        final float[] currentValues = new float[tween.getTargetValues().length];
        for (int i = 0; i < tween.getTargetValues().length; i++) {
          currentValues[i] =
              tween.getStartValues()[i]
                  + tween.getEquation().compute(elapsed / (float) tween.getDuration())
                      * (tween.getTargetValues()[i] - tween.getStartValues()[i]);
        }
        tween.getTarget().setTweenValues(tween.getType(), currentValues);
      }
    }
}
}
```
```java
class de.gurkenlabs.litiengine.gui.SpeechBubble {
public static SpeechBubble create(
      final IEntity entity, final String text, SpeechBubbleAppearance appearance, Font font) {
    return new SpeechBubble(entity, text, appearance, font);
}public static SpeechBubble create(final IEntity entity, final Font font, final String text) {
    SpeechBubbleAppearance app =
        new SpeechBubbleAppearance(
            DEFAULT_APPEARANCE.getForeColor(),
            DEFAULT_APPEARANCE.getBackgroundColor1(),
            DEFAULT_APPEARANCE.getBorderColor(),
            DEFAULT_APPEARANCE.getPadding());
    return new SpeechBubble(entity, text, app, font);
}public static SpeechBubble create(final IEntity entity, final String text) {
    return new SpeechBubble(entity, text, null, GuiProperties.getDefaultFont());
}@Override
  public void update() {
    if (this.currentText == null) {
      this.hide();
      return;
    }

    this.entityCenter = Game.world().camera().getViewportLocation(this.getEntity().getCenter());

    // old text was displayed long enough
    if (this.lastTextDisplay != 0
        && Game.time().since(this.lastTextDisplay) > this.currentTextDisplayTime) {
      this.currentText = null;
      this.lastTextDisplay = 0;
      return;
    }

    // display new text
    if (this.textIndex < this.currentText.length()
        && Game.time().since(this.lastCharPoll) > LETTER_WRITE_DELAY) {
      this.textIndex++;
      this.lastCharPoll = Game.time().now();
      if (this.typeSound != null) {
        Game.audio().playSound(this.typeSound, this.getEntity());
      }
    }

    // continue displaying currently displayed text
}private SpeechBubble(
      final IEntity entity,
      final String text,
      final Sound typeSound,
      SpeechBubbleAppearance appearance,
      Font font) {
    this(entity, text, appearance, font);
    this.typeSound = typeSound;
}private SpeechBubble(
      final IEntity entity,
      final String text,
      @Nullable SpeechBubbleAppearance appearance,
      @Nullable Font font) {
    if (appearance == null) {
      this.appearance = DEFAULT_APPEARANCE;
    } else {
      this.appearance = appearance;
    }

    final SpeechBubble active = activeSpeechBubbles.get(entity);
    if (active != null) {
      active.hide();
    }
    this.setFont(font);

    this.textBoxWidth = (float) (entity.getWidth() * 4);
    this.entity = entity;

    this.currentText = text;
    this.currentTextDisplayTime = DISPLAYTIME_MIN + text.length() * DISPLAYTIME_PER_LETTER;

    this.lastTextDisplay = Game.time().now();
    this.createBubbleImage();
    entity.getEnvironment().add(this, RenderType.UI);
    Game.loop().attach(this);
    activeSpeechBubbles.put(entity, this);
}
}
```
```java
class de.gurkenlabs.litiengine.gui.TextFieldComponent {
@Override
  public void render(final Graphics2D g) {
    super.render(g);
    g.setFont(this.getFont());
    final FontMetrics fm = g.getFontMetrics();

    if (this.isSelected() && Game.time().since(this.lastToggled) > this.flickerDelay) {
      this.cursorVisible = !this.cursorVisible;
      this.lastToggled = Game.time().now();
    }
    if (this.isSelected() && this.cursorVisible) {
      final Rectangle2D cursor =
          new Rectangle2D.Double(
              this.getX() + this.getTextX() + fm.stringWidth(this.getTextToRender(g)),
              this.getY() + this.getTextY(),
              this.getFont().getSize2D() * 3 / 5,
              this.getFont().getSize2D() * 1 / 5);
      g.setColor(this.getAppearance().getForeColor());
      g.fill(cursor);
    }
}
}
```
```java
class de.gurkenlabs.litiengine.entities.Prop {
public Prop(
      final Point2D location, @Nullable final String spritesheetName, final Material material) {
    super();
    this.rotation = Rotation.NONE;
    this.spritesheetName = spritesheetName;
    this.material = material;
    this.setLocation(location);
    this.updateAnimationController();
}public void setSpritesheetName(@Nullable final String spriteName) {
    this.spritesheetName = spriteName;
    this.updateAnimationController();
}
}
```
```java
class de.gurkenlabs.litiengine.tweening.Tween {
public Tween begin() {
    this.started = Game.time().now();
    this.stopped = false;
    return this;
}
}
```
```java
class de.gurkenlabs.litiengine.graphics.emitters.particles.Particle {
public void update(final Point2D emitterOrigin, final float updateRatio) {
    if (this.aliveTick == 0) {
      this.aliveTick = Game.time().now();
    }

    this.aliveTime = Game.time().since(this.aliveTick);
    if (this.timeToLiveReached()) {
      return;
    }

    if (this.colliding) {
      return;
    }

    if (this.getDeltaWidth() != 0) {
      this.width += this.getDeltaWidth() * updateRatio;
    }

    if (this.getDeltaHeight() != 0) {
      this.height += this.getDeltaHeight() * updateRatio;
    }

    if (this.getDeltaAngle() != 0) {
      this.angle += this.getDeltaAngle() * updateRatio;
    }

    // test for ray cast collision
    final float targetX = this.x + this.getVelocityX() * updateRatio;
    final float targetY = this.y + this.getVelocityY() * updateRatio;

    if (targetX == this.x && targetY == this.y) {
      return;
    }

    if (this.checkForCollision(emitterOrigin, targetX, targetY)) {
      return;
    }

    if (this.getVelocityX() != 0) {
      this.x = targetX;
    }

    if (this.getVelocityY() != 0) {
      this.y = targetY;
    }

    if (this.getAccelerationX() != 0) {
      this.velocityX += this.getAccelerationX() * updateRatio;
    }

    if (this.getAccelerationY() != 0) {
      this.velocityY += this.getAccelerationY() * updateRatio;
    }
}
}
```
```java
class de.gurkenlabs.litiengine.graphics.animation.Animation {
@Override
  public void start() {
    this.playing = true;
    if (this.getKeyframes().isEmpty()) {
      return;
    }

    this.restart();
}@Override
  public void update() {
    // do nothing if the animation is not playing or the current keyframe is not finished
    if (!this.isPlaying()
        || Game.time().since(this.lastFrameUpdate) < this.getCurrentKeyFrame().getDuration()) {
      return;
    }

    // if we are not looping and the last keyframe is finished, we terminate the animation
    if (!this.isLooping() && this.isLastKeyFrame()) {
      this.terminate();
      return;
    }

    // make sure, we stay inside the keyframe list
    final int newFrameIndex =
        (this.getKeyframes().indexOf(this.currentFrame) + 1) % this.getKeyframes().size();
    final KeyFrame previousFrame = this.currentFrame;
    this.currentFrame = this.getKeyframes().get(newFrameIndex);

    for (KeyFrameListener listener : this.listeners) {
      listener.currentFrameChanged(previousFrame, this.currentFrame);
    }

    this.lastFrameUpdate = Game.loop().getTicks();
}
}
```
```java
class de.gurkenlabs.litiengine.graphics.animation.AnimationController {
@Override
  public void update() {
    for (final Animation animation : this.getAll()) {
      animation.update();
    }

    if (this.getCurrent() != null && this.getCurrent().isPaused()) {
      return;
    }

    final boolean playbackFinished = this.getCurrent() != null && !this.getCurrent().isPlaying();
    if (playbackFinished) {
      for (final AnimationListener listener : this.listeners) {
        listener.finished(this.getCurrent());
      }
    }

    if (this.getCurrent() == null || playbackFinished) {
      if (this.getDefault() != null) {
        this.play(this.getDefault().getName());
      } else {
        this.currentAnimation = null;
      }
    }
}
}
```
```java
class de.gurkenlabs.litiengine.graphics.RenderComponent {
private void handleFade() {
    if (this.fadeOutStart != -1) {
      final long timePassed = Game.time().since(this.fadeOutStart);
      this.currentAlpha = MathUtilities.clamp(1 - timePassed / (float) this.fadeOutTime, 0, 1);
      if (this.currentAlpha == 0f) {
        this.fadeOutStart = -1;
        this.fadeOutTime = -1;
      }

      return;
    }

    if (this.fadeInStart != -1) {
      final long timePassed = Game.time().since(this.fadeInStart);
      this.currentAlpha = MathUtilities.clamp(timePassed / (float) this.fadeInTime, 0, 1);
      if (this.currentAlpha == 1f) {
        this.fadeInStart = -1;
        this.fadeInTime = -1;
        this.currentAlpha = Float.NaN;
      }
    }
}public void fadeOut(final int ms) {
    this.fadeInStart = -1;
    this.fadeInTime = -1;
    this.fadeOutStart = Game.time().now();
    this.fadeOutTime = ms;
}public void fadeIn(final int ms) {
    this.fadeOutStart = -1;
    this.fadeOutTime = -1;
    this.fadeInStart = Game.time().now();
    this.fadeInTime = ms;
}
}
```
```java
class de.gurkenlabs.litiengine.entities.Trigger {
private boolean activate(final IEntity activator, final int tar) {
    if (!this.isLoaded()
        || this.isOneTimeTrigger && this.isActivated
        || this.getActivationType() == TriggerActivation.COLLISION
            && activator != null
            && this.collisionActivated.contains(activator)) {
      return false;
    }

    if (this.getCooldown() > 0 && Game.time().since(this.lastActivation) < this.getCooldown()) {
      return false;
    }

    List<Integer> triggerTargets = this.getTargets(tar);

    final TriggerEvent te = new TriggerEvent(this, activator, triggerTargets);

    if (!this.checkActivationPredicates(te)) {
      return false;
    }

    this.isActivated = true;
    if (activator != null) {
      this.collisionActivated.add(activator);
    }

    // if we actually have a trigger target, we send the message to the target
    for (final int target : triggerTargets) {
      final IEntity entity = this.getEnvironment().get(target);
      if (entity == null) {
        log.log(
            Level.WARNING,
            "trigger [{0}] was activated, but the trigger target [{1}] could not be found on the environment",
            new Object[] {this, target});
        continue;
      }

      entity.sendMessage(this, this.message);
    }

    // also send the trigger event to all registered consumers
    for (final TriggerActivatedListener listener : this.activatedListeners) {
      listener.activated(te);
    }

    if (this.isOneTimeTrigger) {
      this.getEnvironment().remove(this);
    }

    this.lastActivation = Game.time().now();
    return true;
}
}
```
```java
class de.gurkenlabs.litiengine.graphics.Camera {
private boolean isShakeEffectActive() {
    return this.getShakeTick() != 0
        && Game.time().since(this.getShakeTick()) < this.getShakeDuration();
}@Override
  public void update() {
    if (Game.world().camera() != null && !Game.world().camera().equals(this)) {
      return;
    }

    if (this.targetZoom > 0) {
      if (Game.time().since(this.zoomTick) >= this.zoomDelay) {
        this.zoom = this.targetZoom;
        this.targetZoom = 0;
        this.zoomDelay = 0;
        this.zoomTick = 0;
        this.zoomStep = 0;
      } else {
        this.zoom += this.zoomStep;
      }

      final ZoomChangedEvent event = new ZoomChangedEvent(this, this.getZoom());
      for (final ZoomChangedListener listener : this.zoomListeners) {
        listener.zoomChanged(event);
      }
    }

    if (this.panTime > 0) {
      if (--this.panTime <= 0) {
        this.setFocus(this.targetFocus);
        this.targetFocus = null;
      } else {
        double diff = this.panTime / (this.panTime + 1.0);
        this.focus =
            new Point2D.Double(
                this.focus.getX() * diff + this.targetFocus.getX() * (1.0 - diff),
                this.focus.getY() * diff + this.targetFocus.getY() * (1.0 - diff));
      }
    }

    if (!this.isShakeEffectActive()) {
      this.shakeOffsetX = 0;
      this.shakeOffsetY = 0;
      return;
    }

    if (Game.time().since(this.lastShake) > this.shakeDelay) {
      this.shakeOffsetX = this.getShakeIntensity() * ThreadLocalRandom.current().nextGaussian();
      this.shakeOffsetY = this.getShakeIntensity() * ThreadLocalRandom.current().nextGaussian();
      this.lastShake = Game.time().now();
    }
}@Override
  public void setZoom(final float targetZoom, final int delay) {
    if (delay == 0) {

      this.zoom = targetZoom;
      this.targetZoom = 0;
      this.zoomDelay = 0;
      this.zoomTick = 0;
      this.zoomStep = 0;

      final ZoomChangedEvent event = new ZoomChangedEvent(this, targetZoom);
      for (final ZoomChangedListener listener : this.zoomListeners) {
        listener.zoomChanged(event);
      }
    } else {
      this.zoomTick = Game.time().now();
      this.targetZoom = targetZoom;
      this.zoomDelay = delay;

      final double tickduration = 1000 / (double) Game.loop().getTickRate();
      final double tickAmount = delay / tickduration;
      final float totalDelta = this.targetZoom - this.zoom;
      this.zoomStep = tickAmount > 0 ? (float) (totalDelta / tickAmount) : totalDelta;
    }
}@Override
  public void shake(final double intensity, final int delay, final int shakeDuration) {
    this.shakeTick = Game.time().now();
    this.shakeDelay = delay;
    this.shakeIntensity = intensity;
    this.shakeDuration = shakeDuration;
}
}
```
```java
class de.gurkenlabs.litiengine.entities.Creature {
public void setSpritesheetName(String spritesheetName) {
    if (this.spritesheetName != null && this.spritesheetName.equals(spritesheetName)) {
      return;
    }

    this.spritesheetName = spritesheetName;
    this.updateAnimationController();
}public boolean isIdle() {
    return Game.time().since(this.lastMoved) > IDLE_DELAY;
}@Override
  public void setLocation(final Point2D position) {
    if (this.isDead() || position == null) {
      return;
    }

    final Point2D oldLocation = this.getLocation();
    super.setLocation(position);

    if (Game.hasStarted() && this.isLoaded()) {
      this.lastMoved = Game.time().now();
      this.fireMovedEvent(
          new EntityMovedEvent(
              this, this.getX() - oldLocation.getX(), this.getY() - oldLocation.getY()));
    }
}
}
```
```java
class de.gurkenlabs.litiengine.gui.screens.ScreenManager {
public void display(final String screenName) {
    if (this.current() != null && this.current().getName().equalsIgnoreCase(screenName)) {
      log.log(
          Level.INFO,
          "Skipping displaying of screen {0} because it is already the current screen.",
          screenName);
      return;
    }

    if (this.screens.stream()
        .noneMatch(element -> element.getName().equalsIgnoreCase(screenName))) {
      log.log(
          Level.WARNING,
          "Could not display the screen {0} because there is no screen with the specified name.",
          screenName);
      return;
    }

    Screen screen = this.get(screenName);
    if (screen == null) {
      return;
    }

    this.display(screen);
}public void add(final Screen screen) {
    screen.setWidth(Game.window().getWidth());
    screen.setHeight(Game.window().getHeight());
    this.screens.add(screen);

    if (this.current() == null) {
      this.display(screen);
    }
}public void remove(Screen screen) {
    this.screens.remove(screen);
    if (this.current() == screen) {
      if (!this.screens.isEmpty()) {
        this.display(this.screens.get(0));
      } else {
        this.display((Screen) null);
      }
    }
}public void display(@Nullable final Screen screen) {
    if (Game.hasStarted() && Game.time().since(this.lastScreenChange) < this.getChangeCooldown()) {
      log.log(
          Level.INFO,
          "Skipping displaying of screen {0} because screen changing is currently on cooldown.",
          screen != null ? screen.getName() : "");
      return;
    }

    final Screen previous = this.current();
    if (previous != null) {
      previous.suspend();
    }

    if (screen != null && !this.screens.contains(screen)) {
      this.screens.add(screen);
    }

    this.currentScreen = screen;
    if (!Game.isInNoGUIMode() && this.current() != null) {
      this.current().prepare();
    }

    this.lastScreenChange = Game.loop().getTicks();

    final ScreenChangedEvent event = new ScreenChangedEvent(this.current(), previous);
    for (final ScreenChangedListener listener : this.screenChangedListeners) {
      listener.changed(event);
    }
}
}
```
```java
class de.gurkenlabs.litiengine.abilities.Ability {
public boolean isOnCooldown() {
    return (this.getCurrentExecution() != null
        && this.getCurrentExecution().getExecutionTicks() > 0
        && Game.time().since(this.getCurrentExecution().getExecutionTicks())
            < this.getAttributes().cooldown().get());
}public boolean isActive() {
    return this.getCurrentExecution() != null
        && Game.time().since(this.getCurrentExecution().getExecutionTicks())
            < this.getAttributes().duration().get();
}@Nullable
  public AbilityExecution cast() {
    if (!this.canCast()) {
      return null;
    }
    this.currentExecution = new AbilityExecution(this);

    for (final AbilityCastListener listener : this.abilityCastListeners) {
      listener.abilityCast(this.currentExecution);
    }

    return this.getCurrentExecution();
}public float getRemainingCooldownInSeconds() {
    if (this.getCurrentExecution() == null
        || this.getExecutor() == null
        || this.getExecutor().isDead()) {
      return 0;
    }

    // calculate cooldown in seconds
    return (float)
        (!this.canCast()
            ? (this.getAttributes().cooldown().get()
                    - Game.time().since(this.getCurrentExecution().getExecutionTicks()))
                * 0.001
            : 0);
}
}
```
```java
class de.gurkenlabs.litiengine.entities.EntityHitEvent {
EntityHitEvent(
      final ICombatEntity hitEntity,
      @Nullable final Ability ability,
      final int damage,
      final boolean kill) {
    super(hitEntity);
    this.executor = ability != null ? ability.getExecutor() : null;
    this.hitEntity = hitEntity;
    this.ability = ability;
    this.damage = damage;
    this.kill = kill;
    this.time = Game.time().now();
}
}
```
```java
class de.gurkenlabs.litiengine.graphics.emitters.Emitter {
public void delete() {
    this.deactivate();
    if (Game.world().environment() != null) {
      Game.world().environment().remove(this);
    }
}public void activate() {
    if (this.activated) {
      return;
    }

    this.activated = true;
    this.activationTick = Game.time().now();
    Game.loop().attach(this);
}@Override
  public void update() {
    if (this.isPaused()) {
      return;
    }

    // clear particles if the effect time to life is reached
    if (this.isFinished()) {
      for (EmitterFinishedListener listener : this.finishedListeners) {
        listener.finished(this);
      }

      this.delete();
      return;
    }

    final float updateRatio = (float) this.data().getUpdateRate() / Game.loop().getTickRate();
    for (final Particle p : this.getParticles().stream().collect(Collectors.toList())) {
      if (this.particleCanBeRemoved(p)) {
        // remove dead particles
        this.particles.remove(p);
        continue;
      }

      p.update(this.getOrigin(), updateRatio);
    }

    this.aliveTime = Game.time().since(this.activationTick);
    if ((this.data().getSpawnRate() == 0
        || Game.time().since(this.lastSpawn) >= this.data().getSpawnRate())) {
      this.lastSpawn = Game.time().now();
      this.spawnParticle();
    }
}
}
```
```java
class de.gurkenlabs.litiengine.GameLoop {
@Override
  public int perform(int delay, Runnable action) {
    final long d = Game.time().toTicks(delay);

    TimedAction a = new TimedAction(this.getTicks() + d, action);
    this.actions.add(a);

    return a.getId();
}
}
```
```java
class de.gurkenlabs.litiengine.environment.EntitySpawner {
protected boolean shouldSpawn() {
    return this.lastSpawnWave == 0
        || Game.time().since(this.lastSpawnWave) >= this.getSpawnInterval();
}@Override
  public void update() {
    if (!this.shouldSpawn()) {
      return;
    }

    this.spawnNewEntities();
    this.lastSpawnWave = Game.time().now();
}
}
```
```java
class de.gurkenlabs.litiengine.graphics.FreeFlightCamera {
@Override
  public void update() {
    this.handleFreeFlightCamera();
}public FreeFlightCamera(double x, double y) {
    this(new Point2D.Double(x, y));
}
}
```
```java
class de.gurkenlabs.litiengine.environment.Environment {
public void unload() {
    if (!this.loaded) {
      return;
    }

    // unregister all updatable entities from the current environment
    for (final IEntity entity : this.allEntities.values()) {
      this.unload(entity);
    }

    this.loaded = false;
    this.fireEvent(l -> l.unloaded(this));
}private static void loadUpdatableOrEmitterEntity(IEntity entity) {
    if (entity instanceof Emitter) {
      final Emitter emitter = (Emitter) entity;
      if (emitter.isActivateOnInit()) {
        emitter.activate();
      }
    } else if (entity instanceof IUpdateable) {
      Game.loop().attach((IUpdateable) entity);
    }
}public void clear() {
    Game.physics().clear();

    this.combatEntities.clear();
    this.mobileEntities.clear();
    this.gravityForces.clear();
    this.layerEntities.clear();
    this.entitiesByTag.clear();
    this.allEntities.clear();

    for (RenderType renderType : RenderType.values()) {
      this.miscEntities.get(renderType).clear();
      this.renderListeners.get(renderType).clear();
      this.renderables.get(renderType).clear();
    }

    dispose(this.allEntities.values());
    dispose(this.triggers);
    this.emitters.clear();
    this.colliders.clear();
    this.props.clear();
    this.creatures.clear();
    this.staticShadows.clear();
    this.combatEntities.clear();
    this.mobileEntities.clear();
    this.lightSources.clear();
    this.spawnPoints.clear();
    this.soundSources.clear();
    this.mapAreas.clear();
    this.triggers.clear();

    this.ambientLight = null;
    this.staticShadowLayer = null;

    for (Map<Integer, IEntity> type : this.miscEntities.values()) {
      type.clear();
    }

    this.initialized = false;

    this.fireEvent(l -> l.cleared(this));
}private void load(final IEntity entity) {
    // an entity can only exist on one environment at a time, so remove it from the current one
    if (entity.getEnvironment() != null) {
      entity.getEnvironment().remove(entity);
    }

    // 1. add to physics engine
    loadPhysicsEntity(entity);

    // 2. register for update or activate
    loadUpdatableOrEmitterEntity(entity);

    // 3. if a gravity is defined, add a gravity force to the entity
    if (entity instanceof IMobileEntity && this.getGravity() != 0) {
      this.addGravityForce((IMobileEntity) entity);
    }

    // 4. attach all controllers
    entity.attachControllers();

    if (this.loaded && (entity instanceof LightSource || entity instanceof StaticShadow)) {
      this.updateLighting(entity);
    }

    entity.loaded(this);
}private void unload(final IEntity entity) {
    // 1. remove from physics engine
    if (entity instanceof ICollisionEntity) {
      Game.physics().remove((ICollisionEntity) entity);
    }

    // 2. unregister from update
    if (entity instanceof IUpdateable) {
      Game.loop().detach((IUpdateable) entity);
    }

    if (entity instanceof IMobileEntity) {
      this.removeGravity((IMobileEntity) entity);
    }

    // 3. detach all controllers
    entity.detachControllers();

    if (entity instanceof Emitter) {
      Emitter em = (Emitter) entity;
      em.deactivate();
    }

    if (this.loaded && (entity instanceof LightSource || entity instanceof StaticShadow)) {
      this.updateLighting(entity);
    }

    entity.removed(this);
}public void remove(final IEntity entity) {
    if (entity == null) {
      return;
    }

    this.allEntities.remove(entity.getMapId());
    Iterator<List<IEntity>> iter = this.layerEntities.values().iterator();
    while (iter.hasNext()) {
      List<IEntity> layer = iter.next();
      if (layer.remove(entity) && layer.isEmpty()) {
        iter.remove();
      }
    }
    if (this.miscEntities.get(entity.getRenderType()) != null) {
      this.miscEntities.get(entity.getRenderType()).values().remove(entity);
    }

    for (String tag : entity.getTags()) {
      if (this.getEntitiesByTag().containsKey(tag)) {
        this.getEntitiesByTag().get(tag).remove(entity);

        if (this.getEntitiesByTag().get(tag).isEmpty()) {
          this.getEntitiesByTag().remove(tag);
        }
      }
    }

    if (entity instanceof Emitter) {
      Emitter emitter = (Emitter) entity;
      this.removeEmitter(emitter);
    }

    if (entity instanceof MapArea) {
      this.mapAreas.remove(entity);
    }

    if (entity instanceof Prop) {
      this.props.remove(entity);
    }

    if (entity instanceof Creature) {
      this.creatures.remove(entity);
    }

    if (entity instanceof CollisionBox) {
      this.colliders.remove(entity);
      this.staticShadows.removeIf(x -> x.getOrigin() != null && x.getOrigin().equals(entity));
    }

    if (entity instanceof LightSource) {
      this.lightSources.remove(entity);
      this.updateLighting(entity);
    }

    if (entity instanceof Trigger) {
      this.triggers.remove(entity);
    }

    if (entity instanceof Spawnpoint) {
      this.spawnPoints.remove(entity);
    }
    if (entity instanceof SoundSource) {
      this.soundSources.remove(entity);
    }

    if (entity instanceof StaticShadow) {
      this.staticShadows.remove(entity);
      this.updateLighting(entity);
    }

    if (entity instanceof IMobileEntity) {
      this.mobileEntities.values().remove(entity);
    }

    if (entity instanceof ICombatEntity) {
      this.combatEntities.values().remove(entity);
    }

    this.unload(entity);

    this.fireEntityEvent(l -> l.entityRemoved(entity));
}
}
```
```java
class de.gurkenlabs.litiengine.physics.MovementController {
@Override
  public void update() {
    this.handleForces();
    this.handleMovement();
}
}
```
```java
class de.gurkenlabs.litiengine.Game {
static synchronized void terminate() {
    if (!initialized) {
      return;
    }

    hasStarted = false;
    initialized = false;

    config().save();
    gameLoop.terminate();
    tweenEngine.terminate();
    soundEngine.terminate();

    world().clear();

    for (final GameListener listener : gameListeners) {
      try {
        listener.terminated();
      } catch (Exception e) {
        log().log(Level.WARNING, "game listener threw an exception during shutdown", e);
      }
    }

    gameLoop = null;
    screenManager = null;
    gameWindow = null;
}public static synchronized void start() {
    if (!initialized) {
      throw new IllegalStateException(
          "The game cannot be started without being first initialized. Call Game.init(...) before Game.start().");
    }

    gameLoop.start();
    tweenEngine.start();
    soundEngine.start();

    for (final GameListener listener : gameListeners) {
      listener.started();
    }

    hasStarted = true;
}public static synchronized void init(String... args) {
    if (initialized) {
      log().log(Level.INFO, "The game has already been initialized.");
      return;
    }

    log.init();
    handleCommandLineArguments(args);

    config().load();
    Locale.setDefault(new Locale(config().client().getCountry(), config().client().getLanguage()));

    gameLoop = new GameLoop("Main Update Loop", config().client().getMaxFps());
    loop().attach(physics());
    loop().attach(world());

    // setup default exception handling for render and update loop
    setUncaughtExceptionHandler(
        new DefaultUncaughtExceptionHandler(config().client().exitOnError()));

    screenManager = new ScreenManager();
    gameWindow = new GameWindow();

    // initialize  the game window
    window().init();
    world.setCamera(new Camera());

    for (GameListener listener : gameListeners) {
      listener.initialized(args);
    }

    if (!isInNoGUIMode()) {
      window().getRenderComponent().onRendered(g -> metrics().render(g));

      graphics()
          .addEntityRenderedListener(
              e -> DebugRenderer.renderEntityDebugInfo(e.getGraphics(), e.getEntity()));

      window().getRenderComponent().onFpsChanged(fps -> metrics().setFramesPerSecond(fps));
      window()
          .setIcons(
              Arrays.asList(
                  Resources.images().get("liti-logo-x16.png"),
                  Resources.images().get("liti-logo-x20.png"),
                  Resources.images().get("liti-logo-x32.png"),
                  Resources.images().get("liti-logo-x48.png")));

      Input.keyboard()
          .onKeyTyped(
              KeyEvent.VK_PRINTSCREEN,
              key -> {
                // don't take a screenshot if a modifier is active
                if (key.getModifiers() != 0) {
                  return;
                }

                window().getRenderComponent().takeScreenshot();
              });
    }

    Runtime.getRuntime().addShutdownHook(new Thread(Game::terminate, "Shutdown"));

    initialized = true;
}
}
```


Response Format:
Provide the answer in **XML format** as follows:

#### If the method **cannot** return `null` at the specific call site:
```xml
<response>
  <reason><![CDATA[EXPLAIN WHY THE INVOCATION Game.loop() RESULT CANNOT BE NULL.]]></reason>
  <value>NO</value>
</response>

#### If the method can return null at the specific call site:
<response>
  <reason><![CDATA[EXPLAIN WHY THE INVOCATION Game.loop() RESULT CAN BE NULL.]]></reason>
  <value>YES</value>
</response>

#### If you are unsure or If there are any methods that directly or indirectly affect the return value and are not fully disclosed, request their declarations first, in the following format:
<response>
  <reason><![CDATA[EXPLAIN WHY THIS METHOD DECLARATION IS NECESSARY AND WHY YOU CANNOT MAKE A CONFIDENT DECISION WITHOUT IT]]></reason>
  <success>false</success>
  <methods>
    <method>methodName</method>
  </methods>
</response>

Additional Notes:
Be precise in your reasoning.
If a method’s return value depends on another method not provided, request its declaration before making a conclusion.
If the method can return null in this case but not in others, explain why it happens specifically for this call.

---ChatGPT.sendRequestToOpenAI---
Retrieving response from cache
---Response.<init>---
Creating Response:
```xml
<response>
  <reason><![CDATA[The method `Game.loop()` returns the static field `gameLoop`, which is initialized in the `Game.init(String... args)` method. In this method, a new `GameLoop` object is instantiated and assigned to `gameLoop`. Since `init()` must be called before `start()`, which is implied by the requirement of initializing the game, the `gameLoop` is guaranteed to be non-null during the lifetime of the game execution where `Game.loop()` is called. The absence of any code that could set `gameLoop` to null after its initialization ensures that `Game.loop()` cannot return null.]]></reason>
  <value>NO</value>
</response>
```
---Response.<init>---
Response created:
Disagreement: The method `Game.loop()` returns the static field `gameLoop`, which is initialized in the `Game.init(String... args)` method. In this method, a new `GameLoop` object is instantiated and assigned to `gameLoop`. Since `init()` must be called before `start()`, which is implied by the requirement of initializing the game, the `gameLoop` is guaranteed to be non-null during the lifetime of the game execution where `Game.loop()` is called. The absence of any code that could set `gameLoop` to null after its initialization ensures that `Game.loop()` cannot return null.
---AdvancedNullAwayCodeFix.resolveMethodDereferenceError---
Method is not returning nullable on call site. Injecting suppression annotation.
---AdvancedNullAwayCodeFix.constructCastToNonnullChange---
Constructing cast to nonnull change for reason: The method `Game.loop()` returns the static field `gameLoop`, which is initialized in the `Game.init(String... args)` method. In this method, a new `GameLoop` object is instantiated and assigned to `gameLoop`. Since `init()` must be called before `start()`, which is implied by the requirement of initializing the game, the `gameLoop` is guaranteed to be non-null during the lifetime of the game execution where `Game.loop()` is called. The absence of any code that could set `gameLoop` to null after its initialization ensures that `Game.loop()` cannot return null.
---ChatGPT.ask---
Asking ChatGPT:
For the reason you mentioned earlier:

"The method `Game.loop()` returns the static field `gameLoop`, which is initialized in the `Game.init(String... args)` method. In this method, a new `GameLoop` object is instantiated and assigned to `gameLoop`. Since `init()` must be called before `start()`, which is implied by the requirement of initializing the game, the `gameLoop` is guaranteed to be non-null during the lifetime of the game execution where `Game.loop()` is called. The absence of any code that could set `gameLoop` to null after its initialization ensures that `Game.loop()` cannot return null."

in the method below, the expression Game.loop() is not nullable at the point it is used.

```java
protected void updateAnimationController() {
    IEntityAnimationController<?> controller = this.createAnimationController();
    this.getControllers().addController(controller);
    if (Game.world().environment() != null && Game.world().environment().isLoaded()) {
      Game.loop().attach(controller);
    }
}
```
Please Summarize the reason in max 5 words and rewrite the method so that at the line "      Game.loop().attach(controller);", at the occurrence of: "Game.loop()" is replaced with `NullabilityUtil.castToNonnull(Game.loop(), summary of reason)`
Replace "REASON" with the exact reason summary I provide to you (maximum 5 words), not with a generic explanation like "checked to be nonnull".
see the example below, for expression `foo.getBar()`, to wrap it with `NullabilityUtil.castToNonnull(foo.getBar(), "reason")`.

```java
public t(){
    String l = foo.getBar();
}
```

will be:
```java
public t(){
    String l = NullabilityUtil.castToNonnull(foo.getBar(), "checked to be nonnull");
}
```

### Instructions:

Do not import any additional classes.

Do not add Java comments.

Only modify relevant lines as required.

Return only the modified method wrapped in the XML format shown below.

Place the Java code inside the <code> tag using a CDATA block with ```java formatting.

Just give me the fixed code snippet in XML format in <response> tag like the example below. I will apply the fix to my codebase. Do not import any additional libraries or classes or add java comments. If you can provide the fixed code snippet, please provide it in the following format and place the code snippet in the <code> tag within ```java block.
<response>
  <success>true</success>
  <code><![CDATA[
  ```java
  Your fixed code snippet here
  ```
    ]]>
  </code>
</response>

---ChatGPT.sendRequestToOpenAI---
Retrieving response from cache
---Response.<init>---
Creating Response:
<response>
  <success>true</success>
  <code><![CDATA[
  ```java
  protected void updateAnimationController() {
      IEntityAnimationController<?> controller = this.createAnimationController();
      this.getControllers().addController(controller);
      if (Game.world().environment() != null && Game.world().environment().isLoaded()) {
          NullabilityUtil.castToNonnull(Game.loop(), "cannot return null").attach(controller);
      }
  }
  ```
    ]]>
  </code>
</response>
---Response.<init>---
Response created:
protected void updateAnimationController() {
      IEntityAnimationController<?> controller = this.createAnimationController();
      this.getControllers().addController(controller);
      if (Game.world().environment() != null && Game.world().environment().isLoaded()) {
          NullabilityUtil.castToNonnull(Game.loop(), "cannot return null").attach(controller);
      }
  }
---ChatGPT.fixDereferenceByAddingCastToNonnull---
Fixing the error by adding castToNonnull
---AdvancedNullAwayCodeFix.fixTriggeredErrorsForLocation---
Resolving unresolvable error for triggered error: Type='DEREFERENCE_NULLABLE', message='dereferenced expression Game.loop() is @Nullable'
/home/nima/Developer/nullness-benchmarks/litiengine/src/de/gurkenlabs/litiengine/gui/screens/ScreenManager.java:134
    this.lastScreenChange = Game.loop().getTicks();
---AdvancedNullAwayCodeFix.fix---
Fixing error: Type='DEREFERENCE_NULLABLE', message='dereferenced expression Game.loop() is @Nullable'
/home/nima/Developer/nullness-benchmarks/litiengine/src/de/gurkenlabs/litiengine/gui/screens/ScreenManager.java:134
    this.lastScreenChange = Game.loop().getTicks();
---AdvancedNullAwayCodeFix.resolveDereferenceError---
Resolving dereference error: Type='DEREFERENCE_NULLABLE', message='dereferenced expression Game.loop() is @Nullable'
/home/nima/Developer/nullness-benchmarks/litiengine/src/de/gurkenlabs/litiengine/gui/screens/ScreenManager.java:134
    this.lastScreenChange = Game.loop().getTicks();
---AdvancedNullAwayCodeFix.resolveDereferenceError---
Checking nullability possibility at error point
---ChatGPT.checkNullabilityPossibilityAtErrorPoint---
Asking if the expression can be null at error point point
---ChatGPT.ask---
Asking ChatGPT:
In the method below, is there a possibility that the expression "Game.loop()" at line "this.lastScreenChange = Game.loop().getTicks();" is null?
public void display(@Nullable final Screen screen) {
    if (Game.hasStarted() && Game.time().since(this.lastScreenChange) < this.getChangeCooldown()) {
      log.log(
          Level.INFO,
          "Skipping displaying of screen {0} because screen changing is currently on cooldown.",
          screen != null ? screen.getName() : "");
      return;
    }

    final Screen previous = this.current();
    if (previous != null) {
      previous.suspend();
    }

    if (screen != null && !this.screens.contains(screen)) {
      this.screens.add(screen);
    }

    this.currentScreen = screen;
    if (!Game.isInNoGUIMode() && this.current() != null) {
      this.current().prepare();
    }

    this.lastScreenChange = Game.loop().getTicks();

    final ScreenChangedEvent event = new ScreenChangedEvent(this.current(), previous);
    for (final ScreenChangedListener listener : this.screenChangedListeners) {
      listener.changed(event);
    }
}
Give a single-word answer in XML format. If it is possible for the expression to be null, respond with:
```xml
<response>
    <reason><![CDATA[YOUR REASON]]></reason>
    <value>YES</value>
</response>
```
If it is not possible for the expression to be null, respond with:
```xml
<response>
    <reason><![CDATA[YOUR REASON]]></reason>
    <value>NO</value>
</response>
```
If you are unsure or need more information, respond with where you can ask for more details or what specific information you need.

If additional information is required, list each request inside a `<request>` tag. If no additional information is needed, omit the `<requests>` section.

Respond with:
```xml
<response>
    <reason><![CDATA[YOUR REASON]]></reason>
    <value>UNKNOWN</value>
    <!-- Include <requests> only if additional information is needed -->
    <requests>
        <request><![CDATA[YOUR REQUEST 1]]></request>
        <request><![CDATA[YOUR REQUEST 2]]></request>
    </requests>
</response>
```
---ChatGPT.sendRequestToOpenAI---
Retrieving response from cache
---Response.<init>---
Creating Response:
```xml
<response>
    <reason><![CDATA[The possibility of Game.loop() being null depends on the implementation details of the Game class. If the Game class ensures that loop() always returns a valid instance, then it cannot be null. However, without seeing the implementation of the Game class and how it handles the loop method, we cannot conclusively determine if it can return null.]]></reason>
    <value>UNKNOWN</value>
    <requests>
        <request><![CDATA[What does the Game.loop() method return? Is there any situation where it can return null?]]></request>
        <request><![CDATA[Is there any documentation or source code available for the Game class, specifically focusing on the loop method?]]></request>
    </requests>
</response>
```
---Response.<init>---
Response created:
Unknown: The possibility of Game.loop() being null depends on the implementation details of the Game class. If the Game class ensures that loop() always returns a valid instance, then it cannot be null. However, without seeing the implementation of the Game class and how it handles the loop method, we cannot conclusively determine if it can return null.
---AdvancedNullAwayCodeFix.resolveMethodDereferenceError---
Resolving method dereference error.
---AdvancedNullAwayCodeFix.resolveMethodDereferenceError---
Method is in annotated package. Checking if the method is returning nullable.
---AdvancedNullAwayCodeFix.investigateMethodReturnNullability---
Checking if the method is returning nullable.
---ChatGPT.checkIfMethodIsReturningNullable---
Asking if the method is returning nullable: loop()
---ChatGPT.ask---
Asking ChatGPT:
In the method below, is there a possibility that the method returns null based only on its body? Consider the following points:

- The method may have multiple return paths; consider all return statements.
- If the method calls another method, do not assume its return value unless its full declaration is provided. Request its declaration if needed.
- The method may throw an exception instead of returning null. An exception path should not be considered a null return.
- Ensure you request the declarations of any methods whose return values directly or indirectly impact this method’s return value before making a conclusion.
- Carefully analyze all conditions and prior operations that may guarantee a non-null return value.

@Nullable public static IGameLoop loop() {
    return gameLoop;
}

Here are the method definitions in addition to the method inquired:

Depth: 0
```java
class de.gurkenlabs.litiengine.Game {
@Nullable public static IGameLoop loop() {
    return gameLoop;
}
}
```


Response Format:
Provide the answer in **XML format** as follows:

#### If the method **cannot** return `null`:
```xml
<response>
  <reason><![CDATA[EXPLAIN WHY THE METHOD CANNOT RETURN NULL]]></reason>
  <value>NO</value>
</response>
```

#### If the method can return null:
```xml
<response>
  <reason><![CDATA[EXPLAIN WHY THE METHOD CAN RETURN NULL]]></reason>
  <value>YES</value>
</response>
```

#### If you are unsure or need more information, respond with where you can ask for more details or what specific information you need.

#### If you are unsure or If there are any methods that directly or indirectly affect the return value and are not fully disclosed, request their declarations first, in the following format:
<response>
  <reason><![CDATA[YOUR REASON]]></reason>
  <value>UNKNOWN</value>
  <methods>
    <method>methodName</method>
  </methods>
</response>

If additional information is required other than method declaration, list each request inside a `<request>` tag. If no additional information is needed, omit the `<requests>` section.

Respond with:
```xml
<response>
    <reason><![CDATA[YOUR REASON]]></reason>
    <value>UNKNOWN</value>
    <!-- Include <requests> only if additional information is needed -->
    <requests>
        <request><![CDATA[YOUR REQUEST 1]]></request>
        <request><![CDATA[YOUR REQUEST 2]]></request>
    </requests>
</response>
```

Additional Notes:
Be precise in your reasoning.
If a method’s return value depends on another method not provided, request its declaration before making a conclusion.
If the method can return null in some cases but not others, explain under what conditions it can happen.

---ChatGPT.sendRequestToOpenAI---
Retrieving response from cache
---Response.<init>---
Creating Response:
```xml
<response>
  <reason><![CDATA[The method `loop` returns the variable `gameLoop`. Without the initialization or assignment details of `gameLoop`, it's unclear whether it can be null. The possibility of `gameLoop` being uninitialized or set to null elsewhere in the program means `loop` could potentially return null. Further information on `gameLoop` is required.]]></reason>
  <value>UNKNOWN</value>
  <requests>
    <request><![CDATA[Please provide the declaration and initialization of the variable `gameLoop` in the class `de.gurkenlabs.litiengine.Game`.]]></request>
  </requests>
</response>
```
---Response.<init>---
Response created:
Unknown: The method `loop` returns the variable `gameLoop`. Without the initialization or assignment details of `gameLoop`, it's unclear whether it can be null. The possibility of `gameLoop` being uninitialized or set to null elsewhere in the program means `loop` could potentially return null. Further information on `gameLoop` is required.
---AdvancedNullAwayCodeFix.investigateMethodReturnNullability---
Could not determine the nullability and model did not ask for any method.
---ChatGPT.checkIfMethodIsReturningNullableOnCallSite---
Asking if the method is returning nullable on the call site: Game.loop()
---ChatGPT.ask---
Asking ChatGPT:
In the method below, is there a possibility that the method returns null at the given call site?

```java
@Nullable public static IGameLoop loop() {
    return gameLoop;
}
```

## Guidelines:
- The method may have multiple return paths; consider all return statements.
- If the method calls another method, do not assume its return value unless its full declaration is provided. Request its declaration if needed.
- The method may throw an exception instead of returning null. An exception path should not be considered a null return.
- Ensure you request the declarations of any methods whose return values directly or indirectly impact this method’s return value before making a conclusion.
- If the method returns a value that is determined by a parameter, evaluate based on the actual argument at the given call site.
- Analyze based only on the specific invocation provided. Do not generalize to all possible inputs.- If the return value is guaranteed to be non-null at the call site, the answer should be a definitive NO.
- Do not generalize based on all possible inputs—your answer must be based only on the given invocation.
- Focus only on the given call site, not all possible invocations.

### call site:
Game.loop()

Here are the method definitions and the call chain for this method, showing the sequence of calls from the method to its callers at each depth level:

Depth: 0
```java
class de.gurkenlabs.litiengine.Game {
@Nullable public static IGameLoop loop() {
    return gameLoop;
}
}
```
Depth: 1
```java
class de.gurkenlabs.litiengine.environment.GameWorld {
public void loadEnvironment(@Nullable final Environment env) {
    Lock lock = Game.loop().getLock();
    lock.lock();
    try {
      unloadEnvironment();
      this.environment = env;
      if (env != null) {
        this.addEnvironment(env);

        if (env.getGravity() == 0 && this.gravity() != 0) {
          env.setGravity(this.gravity());
        }

        env.load();
        for (final EnvironmentLoadedListener listener : this.loadedListeners) {
          listener.loaded(env);
        }

        // call map specific listeners
        String mapName = getMapName(env);
        if (mapName != null && this.environmentLoadedListeners.containsKey(mapName)) {

          // for the default camera we center the camera on the environment
          if (this.camera().getClass().equals(Camera.class)) {
            camera().setFocus(env.getCenter());
          }

          for (EnvironmentLoadedListener listener : this.environmentLoadedListeners.get(mapName)) {
            listener.loaded(env);
          }
        }
      }
    } finally {
      lock.unlock();
    }
}public void setCamera(@Nullable final ICamera cam) {
    if (this.camera() != null) {
      Game.loop().detach(camera);
    }

    camera = cam;

    if (cam != null && !Game.isInNoGUIMode()) {
      Game.loop().attach(cam);
      cam.updateFocus();
    }
}
}
```
```java
class de.gurkenlabs.litiengine.entities.behavior.EntityNavigator {
public EntityNavigator(final IMobileEntity entity, final PathFinder pathFinder) {
    this.cancelNavigationConditions = new CopyOnWriteArrayList<>();
    this.listeners = new CopyOnWriteArrayList<>();
    this.entity = entity;
    this.pathFinder = pathFinder;
    this.setAcceptableError(DEFAULT_ACCEPTABLE_ERROR);
    Game.loop().attach(this);
}
}
```
```java
class de.gurkenlabs.litiengine.GameWindow {
private static void initializeWindowEventListeners(Window window) {

    window.addWindowStateListener(
        e -> {
          if (e.getNewState() == Frame.ICONIFIED) {
            Game.loop().setTickRate(ICONIFIED_MAX_FPS);
          } else {
            Game.loop().setTickRate(Game.config().client().getMaxFps());
          }
        });

    window.addWindowFocusListener(
        new WindowFocusListener() {
          @Override
          public void windowLostFocus(WindowEvent e) {
            if (Game.config().graphics().reduceFramesWhenNotFocused()) {
              Game.loop().setTickRate(NONE_FOCUS_MAX_FPS);
            }
          }

          @Override
          public void windowGainedFocus(WindowEvent e) {
            Game.loop().setTickRate(Game.config().client().getMaxFps());
          }
        });

    window.addWindowListener(
        new WindowAdapter() {
          @Override
          public void windowClosing(final WindowEvent event) {
            Game.exit();
          }
        });
}
}
```
```java
class de.gurkenlabs.litiengine.gui.screens.ScreenManager {
public void display(@Nullable final Screen screen) {
    if (Game.hasStarted() && Game.time().since(this.lastScreenChange) < this.getChangeCooldown()) {
      log.log(
          Level.INFO,
          "Skipping displaying of screen {0} because screen changing is currently on cooldown.",
          screen != null ? screen.getName() : "");
      return;
    }

    final Screen previous = this.current();
    if (previous != null) {
      previous.suspend();
    }

    if (screen != null && !this.screens.contains(screen)) {
      this.screens.add(screen);
    }

    this.currentScreen = screen;
    if (!Game.isInNoGUIMode() && this.current() != null) {
      this.current().prepare();
    }

    this.lastScreenChange = Game.loop().getTicks();

    final ScreenChangedEvent event = new ScreenChangedEvent(this.current(), previous);
    for (final ScreenChangedListener listener : this.screenChangedListeners) {
      listener.changed(event);
    }
}
}
```
```java
class de.gurkenlabs.litiengine.abilities.effects.Effect {
@Override
  public void update() {

    for (final Iterator<EffectApplication> iterator = this.getActiveAppliances().iterator();
        iterator.hasNext(); ) {
      final EffectApplication appliance = iterator.next();
      // if the effect duration is reached
      if (this.hasEnded(appliance)) {

        iterator.remove();
        this.cease(appliance);
      }
    }

    // 4. unregister if all appliances are finished
    if (this.getActiveAppliances().isEmpty()) {
      Game.loop().detach(this);
    }
}public void apply(final Shape impactArea) {
    final List<ICombatEntity> affected = this.lookForAffectedEntities(impactArea);
    for (final ICombatEntity affectedEntity : affected) {
      this.apply(affectedEntity);
    }

    this.appliances.add(new EffectApplication(affected, impactArea));

    // if it is the first appliance -> register for update
    if (this.appliances.size() == 1) {
      Game.loop().attach(this);
    }
}
}
```
```java
class de.gurkenlabs.litiengine.GameTime {
public long toTicks(final int milliseconds) {
    return this.toTicks(milliseconds, Game.loop().getTickRate());
}public long since(final long tick) {
    return toMilliseconds(Game.loop().getTicks() - tick);
}public long now() {
    return Game.loop().getTicks();
}public long sinceGameStart() {
    return this.toMilliseconds(Game.loop().getTicks());
}@Override
  public void loaded(Environment environment) {
    environmentLoaded = Game.loop().getTicks();
}public long toMilliseconds(final long ticks) {
    return this.toMilliseconds(ticks, Game.loop().getTickRate());
}
}
```
```java
class de.gurkenlabs.litiengine.GameMetrics {
@Override
  public void render(final Graphics2D g) {
    this.updateMetrics();

    if (!Game.config().client().showGameMetrics()) {
      return;
    }

    this.currentOffsetY = 0;

    g.setColor(this.renderColor);

    // render client metrics
    this.drawTitle(g, "[client]");
    this.drawMetric(g, "fps       : " + this.getFramesPerSecond());
    this.drawMetric(g, "max fps   : " + this.maxFramesPerSecond);
    this.drawMetric(g, "updatables: " + Game.loop().getUpdatableCount());

    // render jvm metrics if debug is enabled
    if (Game.config().debug().isDebugEnabled()) {
      this.drawTitle(g, "[jvm]");
      this.drawMetric(g, "java      : " + this.javaVersion);
      this.drawMetric(g, "memory    : " + String.format("%-5.5s", this.usedMemory) + " MB");
      this.drawMetric(g, "threads   : " + Thread.activeCount());
    }

    // render rendering metrics
    if (!this.renderMetrics.isEmpty()) {
      this.drawTitle(g, "[update]");

      for (RenderMetrics metric : this.renderMetrics) {
        this.drawMetric(g, metric.toString());
      }

      this.renderMetrics.clear();
    }
}
}
```
```java
class de.gurkenlabs.litiengine.graphics.emitters.Emitter {
public void deactivate() {
    if (!this.activated) {
      return;
    }

    this.activated = false;
    this.getParticles().clear();
    this.aliveTime = 0;
    this.activationTick = 0;
    this.lastSpawn = 0;
    Game.loop().detach(this);
}public void activate() {
    if (this.activated) {
      return;
    }

    this.activated = true;
    this.activationTick = Game.time().now();
    Game.loop().attach(this);
}@Override
  public void update() {
    if (this.isPaused()) {
      return;
    }

    // clear particles if the effect time to life is reached
    if (this.isFinished()) {
      for (EmitterFinishedListener listener : this.finishedListeners) {
        listener.finished(this);
      }

      this.delete();
      return;
    }

    final float updateRatio = (float) this.data().getUpdateRate() / Game.loop().getTickRate();
    for (final Particle p : this.getParticles().stream().collect(Collectors.toList())) {
      if (this.particleCanBeRemoved(p)) {
        // remove dead particles
        this.particles.remove(p);
        continue;
      }

      p.update(this.getOrigin(), updateRatio);
    }

    this.aliveTime = Game.time().since(this.activationTick);
    if ((this.data().getSpawnRate() == 0
        || Game.time().since(this.lastSpawn) >= this.data().getSpawnRate())) {
      this.lastSpawn = Game.time().now();
      this.spawnParticle();
    }
}
}
```
```java
class de.gurkenlabs.litiengine.entities.behavior.IBehaviorController {
public default void attach() {
    Game.loop().attach(this);
}public default void detach() {
    Game.loop().detach(this);
}
}
```
```java
class de.gurkenlabs.litiengine.abilities.AbilityExecution {
AbilityExecution(final Ability ability) {
    this.appliedEffects = new CopyOnWriteArrayList<>();
    this.ability = ability;
    this.executionTicks = Game.time().now();
    this.impactArea = ability.calculateImpactArea();
    this.castLocation = ability.getExecutor().getCenter();
    Game.loop().attach(this);
}@Override
  public void update() {
    // if there a no effects to apply -> unregister this instance and we're done
    if (this.getAbility().getEffects().isEmpty()
        || this.getAbility().getEffects().size() == this.getAppliedEffects().size()) {
      Game.loop().detach(this);
      return;
    }

    // handle all effects from the ability that were not applied yet
    for (final Effect effect : this.getAbility().getEffects()) {
      // if the ability was not executed yet or the delay of the effect is not
      // yet reached
      if (this.getAppliedEffects().contains(effect)
          || Game.time().since(this.getExecutionTicks()) < effect.getDelay()) {
        continue;
      }

      effect.apply(this.getExecutionImpactArea());
      this.getAppliedEffects().add(effect);
    }
}
}
```
```java
class de.gurkenlabs.litiengine.GameWindow$3 {
@Override
          public void windowGainedFocus(WindowEvent e) {
            Game.loop().setTickRate(Game.config().client().getMaxFps());
}@Override
          public void windowLostFocus(WindowEvent e) {
            if (Game.config().graphics().reduceFramesWhenNotFocused()) {
              Game.loop().setTickRate(NONE_FOCUS_MAX_FPS);
            }
}
}
```
```java
class de.gurkenlabs.litiengine.environment.EntitySpawner {
protected void spawnNewEntities() {
    if (this.getSpawnMode() != SpawnMode.CUSTOMSPAWNPOINTS && this.getSpawnPoints().isEmpty()) {
      return;
    }

    switch (this.getSpawnMode()) {
      case ALLSPAWNPOINTS:
        for (int i = 0; i < this.getSpawnPoints().size(); i++) {
          final int index = i;
          Game.loop()
              .perform(
                  this.getSpawnDelay() + this.getSpawnDelay() * i,
                  () -> this.spawn(this.getSpawnPoints().get(index), this.getSpawnAmount()));
        }
        break;
      case ONERANDOMSPAWNPOINT:
        this.spawn(Game.random().choose(this.getSpawnPoints()), this.getSpawnAmount());
        break;
      case RANDOMSPAWNPOINTS:
        for (int i = 0; i < this.getSpawnAmount(); i++) {
          Game.loop()
              .perform(
                  this.getSpawnDelay() + this.getSpawnDelay() * i,
                  () -> this.spawn(Game.random().choose(this.getSpawnPoints()), 1));
        }
        break;
      case CUSTOMSPAWNPOINTS:
        List<Spawnpoint> spawnPoints =
            this.customSpawnpoints != null
                ? this.customSpawnpoints.apply(this)
                : this.getCustomSpawnpoints();

        int index = 0;
        for (Spawnpoint spawn : spawnPoints) {
          Game.loop()
              .perform(
                  this.getSpawnDelay() + this.getSpawnDelay() * index, () -> this.spawn(spawn, 1));
          index++;
        }
        break;
      default:
        break;
    }
}
}
```
```java
class de.gurkenlabs.litiengine.tweening.TweenEngine {
@Override
  public void start() {
    Game.loop().attach(this);
}@Override
  public void terminate() {
    Game.loop().detach(this);
}
}
```
```java
class de.gurkenlabs.litiengine.gui.SpeechBubble {
public void hide() {
    Game.world().environment().removeRenderable(this);
    Game.loop().detach(this);
    if (activeSpeechBubbles.get(this.getEntity()) != null
        && activeSpeechBubbles.remove(this.getEntity()).equals(this)) {
      activeSpeechBubbles.remove(this.getEntity());
    }

    for (SpeechBubbleListener listener : this.listeners) {
      listener.hidden();
    }
}private SpeechBubble(
      final IEntity entity,
      final String text,
      @Nullable SpeechBubbleAppearance appearance,
      @Nullable Font font) {
    if (appearance == null) {
      this.appearance = DEFAULT_APPEARANCE;
    } else {
      this.appearance = appearance;
    }

    final SpeechBubble active = activeSpeechBubbles.get(entity);
    if (active != null) {
      active.hide();
    }
    this.setFont(font);

    this.textBoxWidth = (float) (entity.getWidth() * 4);
    this.entity = entity;

    this.currentText = text;
    this.currentTextDisplayTime = DISPLAYTIME_MIN + text.length() * DISPLAYTIME_PER_LETTER;

    this.lastTextDisplay = Game.time().now();
    this.createBubbleImage();
    entity.getEnvironment().add(this, RenderType.UI);
    Game.loop().attach(this);
    activeSpeechBubbles.put(entity, this);
}
}
```
```java
class de.gurkenlabs.litiengine.entities.Prop {
private void updateAnimationController() {
    IEntityAnimationController<?> controller = this.createAnimationController();
    this.getControllers().addController(controller);
    if (Game.world().environment() != null && Game.world().environment().isLoaded()) {
      Game.loop().attach(controller);
    }
}
}
```
```java
class de.gurkenlabs.litiengine.graphics.FreeFlightCamera {
public FreeFlightCamera(final Point2D focus) {
    this.setFocus(focus);
    this.velocity = DEFAULT_SCROLL_PIXELS_PER_SECOND;
    this.scrollPadding = DEFAULT_SCROLL_PADDING;
    this.setClampToMap(true);

    Game.loop().attach(this);
}private void handleFreeFlightCamera() {
    if (Game.world().environment() == null || Game.world().environment().getMap() == null) {
      return;
    }

    final Point2D mouseLocation = Input.mouse().getLocation();

    final double scrollSpeed =
        this.getVelocity()
            / (double) Game.loop().getTickRate()
            * Game.config().input().getMouseSensitivity();

    double x = this.getFocus().getX();
    double y = this.getFocus().getY();

    double deltaX = 0;
    if (mouseLocation.getX() < this.getScrollPadding()) {
      deltaX -= scrollSpeed;
    } else if (Game.window().getResolution().getWidth() - mouseLocation.getX()
        < this.getScrollPadding()) {
      deltaX += scrollSpeed;
    }

    double deltaY = 0;
    if (mouseLocation.getY() < this.getScrollPadding()) {
      deltaY -= scrollSpeed;
    } else if (Game.window().getResolution().getHeight() - mouseLocation.getY()
        < this.getScrollPadding()) {
      deltaY += scrollSpeed;
    }

    x += deltaX;
    y += deltaY;

    this.setFocus(new Point2D.Double(x, y));
}
}
```
```java
class de.gurkenlabs.litiengine.environment.Environment {
private static void dispose(final Collection<? extends IEntity> entities) {
    for (final IEntity entity : entities) {
      if (entity instanceof IUpdateable) {
        Game.loop().detach((IUpdateable) entity);
      }

      entity.detachControllers();
    }
}private static void loadUpdatableOrEmitterEntity(IEntity entity) {
    if (entity instanceof Emitter) {
      final Emitter emitter = (Emitter) entity;
      if (emitter.isActivateOnInit()) {
        emitter.activate();
      }
    } else if (entity instanceof IUpdateable) {
      Game.loop().attach((IUpdateable) entity);
    }
}private void unload(final IEntity entity) {
    // 1. remove from physics engine
    if (entity instanceof ICollisionEntity) {
      Game.physics().remove((ICollisionEntity) entity);
    }

    // 2. unregister from update
    if (entity instanceof IUpdateable) {
      Game.loop().detach((IUpdateable) entity);
    }

    if (entity instanceof IMobileEntity) {
      this.removeGravity((IMobileEntity) entity);
    }

    // 3. detach all controllers
    entity.detachControllers();

    if (entity instanceof Emitter) {
      Emitter em = (Emitter) entity;
      em.deactivate();
    }

    if (this.loaded && (entity instanceof LightSource || entity instanceof StaticShadow)) {
      this.updateLighting(entity);
    }

    entity.removed(this);
}
}
```
```java
class de.gurkenlabs.litiengine.graphics.animation.Animation {
@Override
  public void update() {
    // do nothing if the animation is not playing or the current keyframe is not finished
    if (!this.isPlaying()
        || Game.time().since(this.lastFrameUpdate) < this.getCurrentKeyFrame().getDuration()) {
      return;
    }

    // if we are not looping and the last keyframe is finished, we terminate the animation
    if (!this.isLooping() && this.isLastKeyFrame()) {
      this.terminate();
      return;
    }

    // make sure, we stay inside the keyframe list
    final int newFrameIndex =
        (this.getKeyframes().indexOf(this.currentFrame) + 1) % this.getKeyframes().size();
    final KeyFrame previousFrame = this.currentFrame;
    this.currentFrame = this.getKeyframes().get(newFrameIndex);

    for (KeyFrameListener listener : this.listeners) {
      listener.currentFrameChanged(previousFrame, this.currentFrame);
    }

    this.lastFrameUpdate = Game.loop().getTicks();
}public void restart() {
    this.currentFrame = this.firstFrame;
    this.lastFrameUpdate = Game.loop().getTicks();
}
}
```
```java
class de.gurkenlabs.litiengine.physics.MovementController {
@Override
  public void attach() {
    Game.loop().attach(this);
}private void handleForces() {
    // clean up forces
    this.activeForces.forEach(
        x -> {
          if (x.hasEnded()) {
            this.activeForces.remove(x);
          }
        });

    if (this.activeForces.isEmpty()) {
      return;
    }

    // disable turn-on-move for force handling
    boolean turn = this.getEntity().turnOnMove();
    this.getEntity().setTurnOnMove(false);
    try {
      double deltaX = 0;
      double deltaY = 0;
      for (final Force force : this.activeForces) {
        if (force.cancelOnReached() && force.hasReached(this.getEntity())) {
          force.end();
          continue;
        }

        final Point2D collisionBoxCenter = this.getEntity().getCollisionBoxCenter();
        final double angle =
            GeometricUtilities.calcRotationAngleInDegrees(collisionBoxCenter, force.getLocation());
        final double strength =
            Game.loop().getDeltaTime() * 0.001f * force.getStrength() * Game.loop().getTimeScale();
        deltaX += GeometricUtilities.getDeltaX(angle, strength);
        deltaY += GeometricUtilities.getDeltaY(angle, strength);
      }

      final Point2D target =
          new Point2D.Double(this.getEntity().getX() + deltaX, this.getEntity().getY() + deltaY);
      final boolean success = Game.physics().move(this.getEntity(), target);
      if (!success) {
        for (final Force force : this.activeForces) {
          if (force.cancelOnCollision()) {
            force.end();
          }
        }
      }
    } finally {
      this.getEntity().setTurnOnMove(turn);
    }
}@Override
  public void detach() {
    Game.loop().detach(this);
}public void handleMovement() {
    if (!this.isMovementAllowed()) {
      this.velocity = 0;
      return;
    }

    // max distance an entity can travel within one tick
    final double maxPixelsPerTick = this.getEntity().getTickVelocity();
    final double deltaTime = Game.loop().getDeltaTime() * Game.loop().getTimeScale();

    final double acceleration =
        this.getEntity().getAcceleration() == 0
            ? maxPixelsPerTick
            : deltaTime / this.getEntity().getAcceleration() * maxPixelsPerTick;
    final double deceleration =
        this.getEntity().getDeceleration() == 0
            ? this.getVelocity()
            : deltaTime / this.getEntity().getDeceleration() * maxPixelsPerTick;

    double dx = this.getDx();
    double dy = this.getDy();
    this.setDx(0);
    this.setDy(0);

    final double deltaVelocity =
        Math.min(Math.sqrt(Math.pow(dx, 2) + Math.pow(dy, 2)), acceleration);
    if (deltaVelocity != 0) {
      double newVelocity = this.getVelocity() + deltaVelocity;
      this.setVelocity(newVelocity);
    } else {
      final double newVelocity = Math.max(0, this.getVelocity() - deceleration);
      this.setVelocity(newVelocity);
      dx = GeometricUtilities.getDeltaX(this.moveAngle);
      dy = GeometricUtilities.getDeltaY(this.moveAngle);
    }

    if (this.getVelocity() == 0) {
      this.moveAngle = 0;
      return;
    }

    // actually move entity
    this.moveEntity(dx, dy);
}
}
```
```java
class de.gurkenlabs.litiengine.graphics.animation.AnimationController {
public void detach() {
    Game.loop().detach(this);
}public void attach() {
    Game.loop().attach(this);
}
}
```
```java
class de.gurkenlabs.litiengine.graphics.Camera {
@Override
  public void setZoom(final float targetZoom, final int delay) {
    if (delay == 0) {

      this.zoom = targetZoom;
      this.targetZoom = 0;
      this.zoomDelay = 0;
      this.zoomTick = 0;
      this.zoomStep = 0;

      final ZoomChangedEvent event = new ZoomChangedEvent(this, targetZoom);
      for (final ZoomChangedListener listener : this.zoomListeners) {
        listener.zoomChanged(event);
      }
    } else {
      this.zoomTick = Game.time().now();
      this.targetZoom = targetZoom;
      this.zoomDelay = delay;

      final double tickduration = 1000 / (double) Game.loop().getTickRate();
      final double tickAmount = delay / tickduration;
      final float totalDelta = this.targetZoom - this.zoom;
      this.zoomStep = tickAmount > 0 ? (float) (totalDelta / tickAmount) : totalDelta;
    }
}
}
```
```java
class de.gurkenlabs.litiengine.Game {
public static synchronized void init(String... args) {
    if (initialized) {
      log().log(Level.INFO, "The game has already been initialized.");
      return;
    }

    log.init();
    handleCommandLineArguments(args);

    config().load();
    Locale.setDefault(new Locale(config().client().getCountry(), config().client().getLanguage()));

    gameLoop = new GameLoop("Main Update Loop", config().client().getMaxFps());
    loop().attach(physics());
    loop().attach(world());

    // setup default exception handling for render and update loop
    setUncaughtExceptionHandler(
        new DefaultUncaughtExceptionHandler(config().client().exitOnError()));

    screenManager = new ScreenManager();
    gameWindow = new GameWindow();

    // initialize  the game window
    window().init();
    world.setCamera(new Camera());

    for (GameListener listener : gameListeners) {
      listener.initialized(args);
    }

    if (!isInNoGUIMode()) {
      window().getRenderComponent().onRendered(g -> metrics().render(g));

      graphics()
          .addEntityRenderedListener(
              e -> DebugRenderer.renderEntityDebugInfo(e.getGraphics(), e.getEntity()));

      window().getRenderComponent().onFpsChanged(fps -> metrics().setFramesPerSecond(fps));
      window()
          .setIcons(
              Arrays.asList(
                  Resources.images().get("liti-logo-x16.png"),
                  Resources.images().get("liti-logo-x20.png"),
                  Resources.images().get("liti-logo-x32.png"),
                  Resources.images().get("liti-logo-x48.png")));

      Input.keyboard()
          .onKeyTyped(
              KeyEvent.VK_PRINTSCREEN,
              key -> {
                // don't take a screenshot if a modifier is active
                if (key.getModifiers() != 0) {
                  return;
                }

                window().getRenderComponent().takeScreenshot();
              });
    }

    Runtime.getRuntime().addShutdownHook(new Thread(Game::terminate, "Shutdown"));

    initialized = true;
}
}
```
```java
class de.gurkenlabs.litiengine.entities.Creature {
protected void updateAnimationController() {
    IEntityAnimationController<?> controller = this.createAnimationController();
    this.getControllers().addController(controller);
    if (Game.world().environment() != null && Game.world().environment().isLoaded()) {
      Game.loop().attach(controller);
    }
}@Override
  public float getTickVelocity() {
    // pixels per ms multiplied by the passed ms
    // ensure that entities don't travel too far in case of lag
    return Math.min(Game.loop().getDeltaTime(), GameLoop.TICK_DELTATIME_LAG)
        * 0.001F
        * this.getVelocity().get()
        * Game.loop().getTimeScale();
}
}
```
Depth: 2
```java
class de.gurkenlabs.litiengine.environment.GameWorld {
public void clear() {
    this.unloadEnvironment();
    this.environments.clear();
    this.setCamera(null);
    Game.physics().clear();

    this.environmentListeners.clear();
    this.environmentLoadedListeners.clear();
    this.environmentUnloadedListeners.clear();

    this.listeners.clear();
    this.loadedListeners.clear();
    this.unloadedListeners.clear();
}@Nullable
  public Environment loadEnvironment(IMap map) {
    Environment env = this.getEnvironment(map);
    this.loadEnvironment(env);
    return env;
}@Nullable
  public Environment loadEnvironment(String mapName) {
    Environment env = this.getEnvironment(mapName);
    this.loadEnvironment(env);
    return env;
}
}
```
```java
class de.gurkenlabs.litiengine.GameWindow {
GameWindow() {
    this.hostControl = new JFrame();

    this.resolutionChangedListeners = new CopyOnWriteArrayList<>();

    this.renderCanvas = new RenderComponent(Game.config().graphics().getResolution());
    this.cursor = new MouseCursor();
    if (!Game.isInNoGUIMode()) {
      this.hostControl.setBackground(Color.BLACK);
      this.hostControl.add(this.renderCanvas);

      this.initializeEventListeners();

      this.hostControl.setTitle(Game.info().getTitle());
      this.hostControl.setDefaultCloseOperation(WindowConstants.DO_NOTHING_ON_CLOSE);
      initializeWindowEventListeners(this.hostControl);
    }
}
}
```
```java
class de.gurkenlabs.litiengine.GameTime {
public long sinceEnvironmentLoad() {
    return this.since(this.environmentLoaded);
}public long since(final long tick) {
    return toMilliseconds(Game.loop().getTicks() - tick);
}public long sinceGameStart() {
    return this.toMilliseconds(Game.loop().getTicks());
}
}
```
```java
class de.gurkenlabs.litiengine.abilities.effects.Effect {
protected void cease(final EffectApplication appliance) {
    // 1. cease the effect for all affected entities
    for (final ICombatEntity entity : appliance.getAffectedEntities()) {
      this.cease(entity);
    }

    // 2. apply follow up effects
    this.getFollowUpEffects().forEach(followUp -> followUp.apply(appliance.getImpactArea()));
}protected boolean hasEnded(final EffectApplication appliance) {
    final long effectDuration = Game.time().since(appliance.getAppliedTicks());
    return effectDuration > this.getDuration();
}
}
```
```java
class de.gurkenlabs.litiengine.abilities.effects.EffectApplication {
protected EffectApplication(final List<ICombatEntity> affectedEntities, final Shape impactArea) {
    this.applied = Game.time().now();
    this.affectedEntities = affectedEntities;
    this.impactArea = impactArea;
}
}
```
```java
class de.gurkenlabs.litiengine.entities.CombatEntity {
@Override
  public boolean wasHit(int timeSpan) {
    return Game.time().since(this.lastHit) < timeSpan;
}@Override
  public void hit(final int damage, @Nullable final Ability ability) {
    if (this.isDead()) {
      return;
    }

    if (!this.isIndestructible()) {
      this.getHitPoints().modifyBaseValue(new AttributeModifier<>(Modification.SUBTRACT, damage));
    }

    final EntityHitEvent event = new EntityHitEvent(this, ability, damage, this.isDead());

    for (final CombatEntityListener listener : this.listeners) {
      listener.hit(event);
    }

    for (final CombatEntityHitListener listener : this.hitListeners) {
      listener.hit(event);
    }

    if (this.isDead()) {
      this.fireDeathEvent();
      this.setCollision(false);
    }

    this.lastHit = Game.time().now();
}
}
```
```java
class de.gurkenlabs.litiengine.graphics.ImageEffect {
protected ImageEffect(final int ttl, final String name) {
    this.ttl = ttl;
    this.name = name;
    this.aliveTick = Game.time().now();
}@Override
  public long getAliveTime() {
    return Game.time().since(this.aliveTick);
}
}
```
```java
class de.gurkenlabs.litiengine.abilities.AbilityExecution {
AbilityExecution(final Ability ability) {
    this.appliedEffects = new CopyOnWriteArrayList<>();
    this.ability = ability;
    this.executionTicks = Game.time().now();
    this.impactArea = ability.calculateImpactArea();
    this.castLocation = ability.getExecutor().getCenter();
    Game.loop().attach(this);
}@Override
  public void update() {
    // if there a no effects to apply -> unregister this instance and we're done
    if (this.getAbility().getEffects().isEmpty()
        || this.getAbility().getEffects().size() == this.getAppliedEffects().size()) {
      Game.loop().detach(this);
      return;
    }

    // handle all effects from the ability that were not applied yet
    for (final Effect effect : this.getAbility().getEffects()) {
      // if the ability was not executed yet or the delay of the effect is not
      // yet reached
      if (this.getAppliedEffects().contains(effect)
          || Game.time().since(this.getExecutionTicks()) < effect.getDelay()) {
        continue;
      }

      effect.apply(this.getExecutionImpactArea());
      this.getAppliedEffects().add(effect);
    }
}
}
```
```java
class de.gurkenlabs.litiengine.tweening.TweenEngine {
@Override
  public void update() {
    for (final Tweenable target : this.getTweens().keySet()) {
      for (final Tween tween : this.getTweens().get(target).values()) {
        if (tween.hasStopped()) {
          continue;
        }
        final long elapsed = Game.time().since(tween.getStartTime());
        if (elapsed >= tween.getDuration()) {
          tween.stop();
          continue;
        }
        final float[] currentValues = new float[tween.getTargetValues().length];
        for (int i = 0; i < tween.getTargetValues().length; i++) {
          currentValues[i] =
              tween.getStartValues()[i]
                  + tween.getEquation().compute(elapsed / (float) tween.getDuration())
                      * (tween.getTargetValues()[i] - tween.getStartValues()[i]);
        }
        tween.getTarget().setTweenValues(tween.getType(), currentValues);
      }
    }
}
}
```
```java
class de.gurkenlabs.litiengine.gui.SpeechBubble {
public static SpeechBubble create(
      final IEntity entity, final String text, SpeechBubbleAppearance appearance, Font font) {
    return new SpeechBubble(entity, text, appearance, font);
}public static SpeechBubble create(final IEntity entity, final Font font, final String text) {
    SpeechBubbleAppearance app =
        new SpeechBubbleAppearance(
            DEFAULT_APPEARANCE.getForeColor(),
            DEFAULT_APPEARANCE.getBackgroundColor1(),
            DEFAULT_APPEARANCE.getBorderColor(),
            DEFAULT_APPEARANCE.getPadding());
    return new SpeechBubble(entity, text, app, font);
}public static SpeechBubble create(final IEntity entity, final String text) {
    return new SpeechBubble(entity, text, null, GuiProperties.getDefaultFont());
}@Override
  public void update() {
    if (this.currentText == null) {
      this.hide();
      return;
    }

    this.entityCenter = Game.world().camera().getViewportLocation(this.getEntity().getCenter());

    // old text was displayed long enough
    if (this.lastTextDisplay != 0
        && Game.time().since(this.lastTextDisplay) > this.currentTextDisplayTime) {
      this.currentText = null;
      this.lastTextDisplay = 0;
      return;
    }

    // display new text
    if (this.textIndex < this.currentText.length()
        && Game.time().since(this.lastCharPoll) > LETTER_WRITE_DELAY) {
      this.textIndex++;
      this.lastCharPoll = Game.time().now();
      if (this.typeSound != null) {
        Game.audio().playSound(this.typeSound, this.getEntity());
      }
    }

    // continue displaying currently displayed text
}private SpeechBubble(
      final IEntity entity,
      final String text,
      final Sound typeSound,
      SpeechBubbleAppearance appearance,
      Font font) {
    this(entity, text, appearance, font);
    this.typeSound = typeSound;
}private SpeechBubble(
      final IEntity entity,
      final String text,
      @Nullable SpeechBubbleAppearance appearance,
      @Nullable Font font) {
    if (appearance == null) {
      this.appearance = DEFAULT_APPEARANCE;
    } else {
      this.appearance = appearance;
    }

    final SpeechBubble active = activeSpeechBubbles.get(entity);
    if (active != null) {
      active.hide();
    }
    this.setFont(font);

    this.textBoxWidth = (float) (entity.getWidth() * 4);
    this.entity = entity;

    this.currentText = text;
    this.currentTextDisplayTime = DISPLAYTIME_MIN + text.length() * DISPLAYTIME_PER_LETTER;

    this.lastTextDisplay = Game.time().now();
    this.createBubbleImage();
    entity.getEnvironment().add(this, RenderType.UI);
    Game.loop().attach(this);
    activeSpeechBubbles.put(entity, this);
}
}
```
```java
class de.gurkenlabs.litiengine.gui.TextFieldComponent {
@Override
  public void render(final Graphics2D g) {
    super.render(g);
    g.setFont(this.getFont());
    final FontMetrics fm = g.getFontMetrics();

    if (this.isSelected() && Game.time().since(this.lastToggled) > this.flickerDelay) {
      this.cursorVisible = !this.cursorVisible;
      this.lastToggled = Game.time().now();
    }
    if (this.isSelected() && this.cursorVisible) {
      final Rectangle2D cursor =
          new Rectangle2D.Double(
              this.getX() + this.getTextX() + fm.stringWidth(this.getTextToRender(g)),
              this.getY() + this.getTextY(),
              this.getFont().getSize2D() * 3 / 5,
              this.getFont().getSize2D() * 1 / 5);
      g.setColor(this.getAppearance().getForeColor());
      g.fill(cursor);
    }
}
}
```
```java
class de.gurkenlabs.litiengine.entities.Prop {
public Prop(
      final Point2D location, @Nullable final String spritesheetName, final Material material) {
    super();
    this.rotation = Rotation.NONE;
    this.spritesheetName = spritesheetName;
    this.material = material;
    this.setLocation(location);
    this.updateAnimationController();
}public void setSpritesheetName(@Nullable final String spriteName) {
    this.spritesheetName = spriteName;
    this.updateAnimationController();
}
}
```
```java
class de.gurkenlabs.litiengine.tweening.Tween {
public Tween begin() {
    this.started = Game.time().now();
    this.stopped = false;
    return this;
}
}
```
```java
class de.gurkenlabs.litiengine.graphics.emitters.particles.Particle {
public void update(final Point2D emitterOrigin, final float updateRatio) {
    if (this.aliveTick == 0) {
      this.aliveTick = Game.time().now();
    }

    this.aliveTime = Game.time().since(this.aliveTick);
    if (this.timeToLiveReached()) {
      return;
    }

    if (this.colliding) {
      return;
    }

    if (this.getDeltaWidth() != 0) {
      this.width += this.getDeltaWidth() * updateRatio;
    }

    if (this.getDeltaHeight() != 0) {
      this.height += this.getDeltaHeight() * updateRatio;
    }

    if (this.getDeltaAngle() != 0) {
      this.angle += this.getDeltaAngle() * updateRatio;
    }

    // test for ray cast collision
    final float targetX = this.x + this.getVelocityX() * updateRatio;
    final float targetY = this.y + this.getVelocityY() * updateRatio;

    if (targetX == this.x && targetY == this.y) {
      return;
    }

    if (this.checkForCollision(emitterOrigin, targetX, targetY)) {
      return;
    }

    if (this.getVelocityX() != 0) {
      this.x = targetX;
    }

    if (this.getVelocityY() != 0) {
      this.y = targetY;
    }

    if (this.getAccelerationX() != 0) {
      this.velocityX += this.getAccelerationX() * updateRatio;
    }

    if (this.getAccelerationY() != 0) {
      this.velocityY += this.getAccelerationY() * updateRatio;
    }
}
}
```
```java
class de.gurkenlabs.litiengine.graphics.animation.Animation {
@Override
  public void start() {
    this.playing = true;
    if (this.getKeyframes().isEmpty()) {
      return;
    }

    this.restart();
}@Override
  public void update() {
    // do nothing if the animation is not playing or the current keyframe is not finished
    if (!this.isPlaying()
        || Game.time().since(this.lastFrameUpdate) < this.getCurrentKeyFrame().getDuration()) {
      return;
    }

    // if we are not looping and the last keyframe is finished, we terminate the animation
    if (!this.isLooping() && this.isLastKeyFrame()) {
      this.terminate();
      return;
    }

    // make sure, we stay inside the keyframe list
    final int newFrameIndex =
        (this.getKeyframes().indexOf(this.currentFrame) + 1) % this.getKeyframes().size();
    final KeyFrame previousFrame = this.currentFrame;
    this.currentFrame = this.getKeyframes().get(newFrameIndex);

    for (KeyFrameListener listener : this.listeners) {
      listener.currentFrameChanged(previousFrame, this.currentFrame);
    }

    this.lastFrameUpdate = Game.loop().getTicks();
}
}
```
```java
class de.gurkenlabs.litiengine.graphics.animation.AnimationController {
@Override
  public void update() {
    for (final Animation animation : this.getAll()) {
      animation.update();
    }

    if (this.getCurrent() != null && this.getCurrent().isPaused()) {
      return;
    }

    final boolean playbackFinished = this.getCurrent() != null && !this.getCurrent().isPlaying();
    if (playbackFinished) {
      for (final AnimationListener listener : this.listeners) {
        listener.finished(this.getCurrent());
      }
    }

    if (this.getCurrent() == null || playbackFinished) {
      if (this.getDefault() != null) {
        this.play(this.getDefault().getName());
      } else {
        this.currentAnimation = null;
      }
    }
}
}
```
```java
class de.gurkenlabs.litiengine.graphics.RenderComponent {
private void handleFade() {
    if (this.fadeOutStart != -1) {
      final long timePassed = Game.time().since(this.fadeOutStart);
      this.currentAlpha = MathUtilities.clamp(1 - timePassed / (float) this.fadeOutTime, 0, 1);
      if (this.currentAlpha == 0f) {
        this.fadeOutStart = -1;
        this.fadeOutTime = -1;
      }

      return;
    }

    if (this.fadeInStart != -1) {
      final long timePassed = Game.time().since(this.fadeInStart);
      this.currentAlpha = MathUtilities.clamp(timePassed / (float) this.fadeInTime, 0, 1);
      if (this.currentAlpha == 1f) {
        this.fadeInStart = -1;
        this.fadeInTime = -1;
        this.currentAlpha = Float.NaN;
      }
    }
}public void fadeOut(final int ms) {
    this.fadeInStart = -1;
    this.fadeInTime = -1;
    this.fadeOutStart = Game.time().now();
    this.fadeOutTime = ms;
}public void fadeIn(final int ms) {
    this.fadeOutStart = -1;
    this.fadeOutTime = -1;
    this.fadeInStart = Game.time().now();
    this.fadeInTime = ms;
}
}
```
```java
class de.gurkenlabs.litiengine.entities.Trigger {
private boolean activate(final IEntity activator, final int tar) {
    if (!this.isLoaded()
        || this.isOneTimeTrigger && this.isActivated
        || this.getActivationType() == TriggerActivation.COLLISION
            && activator != null
            && this.collisionActivated.contains(activator)) {
      return false;
    }

    if (this.getCooldown() > 0 && Game.time().since(this.lastActivation) < this.getCooldown()) {
      return false;
    }

    List<Integer> triggerTargets = this.getTargets(tar);

    final TriggerEvent te = new TriggerEvent(this, activator, triggerTargets);

    if (!this.checkActivationPredicates(te)) {
      return false;
    }

    this.isActivated = true;
    if (activator != null) {
      this.collisionActivated.add(activator);
    }

    // if we actually have a trigger target, we send the message to the target
    for (final int target : triggerTargets) {
      final IEntity entity = this.getEnvironment().get(target);
      if (entity == null) {
        log.log(
            Level.WARNING,
            "trigger [{0}] was activated, but the trigger target [{1}] could not be found on the environment",
            new Object[] {this, target});
        continue;
      }

      entity.sendMessage(this, this.message);
    }

    // also send the trigger event to all registered consumers
    for (final TriggerActivatedListener listener : this.activatedListeners) {
      listener.activated(te);
    }

    if (this.isOneTimeTrigger) {
      this.getEnvironment().remove(this);
    }

    this.lastActivation = Game.time().now();
    return true;
}
}
```
```java
class de.gurkenlabs.litiengine.graphics.Camera {
private boolean isShakeEffectActive() {
    return this.getShakeTick() != 0
        && Game.time().since(this.getShakeTick()) < this.getShakeDuration();
}@Override
  public void update() {
    if (Game.world().camera() != null && !Game.world().camera().equals(this)) {
      return;
    }

    if (this.targetZoom > 0) {
      if (Game.time().since(this.zoomTick) >= this.zoomDelay) {
        this.zoom = this.targetZoom;
        this.targetZoom = 0;
        this.zoomDelay = 0;
        this.zoomTick = 0;
        this.zoomStep = 0;
      } else {
        this.zoom += this.zoomStep;
      }

      final ZoomChangedEvent event = new ZoomChangedEvent(this, this.getZoom());
      for (final ZoomChangedListener listener : this.zoomListeners) {
        listener.zoomChanged(event);
      }
    }

    if (this.panTime > 0) {
      if (--this.panTime <= 0) {
        this.setFocus(this.targetFocus);
        this.targetFocus = null;
      } else {
        double diff = this.panTime / (this.panTime + 1.0);
        this.focus =
            new Point2D.Double(
                this.focus.getX() * diff + this.targetFocus.getX() * (1.0 - diff),
                this.focus.getY() * diff + this.targetFocus.getY() * (1.0 - diff));
      }
    }

    if (!this.isShakeEffectActive()) {
      this.shakeOffsetX = 0;
      this.shakeOffsetY = 0;
      return;
    }

    if (Game.time().since(this.lastShake) > this.shakeDelay) {
      this.shakeOffsetX = this.getShakeIntensity() * ThreadLocalRandom.current().nextGaussian();
      this.shakeOffsetY = this.getShakeIntensity() * ThreadLocalRandom.current().nextGaussian();
      this.lastShake = Game.time().now();
    }
}@Override
  public void setZoom(final float targetZoom, final int delay) {
    if (delay == 0) {

      this.zoom = targetZoom;
      this.targetZoom = 0;
      this.zoomDelay = 0;
      this.zoomTick = 0;
      this.zoomStep = 0;

      final ZoomChangedEvent event = new ZoomChangedEvent(this, targetZoom);
      for (final ZoomChangedListener listener : this.zoomListeners) {
        listener.zoomChanged(event);
      }
    } else {
      this.zoomTick = Game.time().now();
      this.targetZoom = targetZoom;
      this.zoomDelay = delay;

      final double tickduration = 1000 / (double) Game.loop().getTickRate();
      final double tickAmount = delay / tickduration;
      final float totalDelta = this.targetZoom - this.zoom;
      this.zoomStep = tickAmount > 0 ? (float) (totalDelta / tickAmount) : totalDelta;
    }
}@Override
  public void shake(final double intensity, final int delay, final int shakeDuration) {
    this.shakeTick = Game.time().now();
    this.shakeDelay = delay;
    this.shakeIntensity = intensity;
    this.shakeDuration = shakeDuration;
}
}
```
```java
class de.gurkenlabs.litiengine.entities.Creature {
public void setSpritesheetName(String spritesheetName) {
    if (this.spritesheetName != null && this.spritesheetName.equals(spritesheetName)) {
      return;
    }

    this.spritesheetName = spritesheetName;
    this.updateAnimationController();
}public boolean isIdle() {
    return Game.time().since(this.lastMoved) > IDLE_DELAY;
}@Override
  public void setLocation(final Point2D position) {
    if (this.isDead() || position == null) {
      return;
    }

    final Point2D oldLocation = this.getLocation();
    super.setLocation(position);

    if (Game.hasStarted() && this.isLoaded()) {
      this.lastMoved = Game.time().now();
      this.fireMovedEvent(
          new EntityMovedEvent(
              this, this.getX() - oldLocation.getX(), this.getY() - oldLocation.getY()));
    }
}
}
```
```java
class de.gurkenlabs.litiengine.gui.screens.ScreenManager {
public void display(final String screenName) {
    if (this.current() != null && this.current().getName().equalsIgnoreCase(screenName)) {
      log.log(
          Level.INFO,
          "Skipping displaying of screen {0} because it is already the current screen.",
          screenName);
      return;
    }

    if (this.screens.stream()
        .noneMatch(element -> element.getName().equalsIgnoreCase(screenName))) {
      log.log(
          Level.WARNING,
          "Could not display the screen {0} because there is no screen with the specified name.",
          screenName);
      return;
    }

    Screen screen = this.get(screenName);
    if (screen == null) {
      return;
    }

    this.display(screen);
}public void add(final Screen screen) {
    screen.setWidth(Game.window().getWidth());
    screen.setHeight(Game.window().getHeight());
    this.screens.add(screen);

    if (this.current() == null) {
      this.display(screen);
    }
}public void remove(Screen screen) {
    this.screens.remove(screen);
    if (this.current() == screen) {
      if (!this.screens.isEmpty()) {
        this.display(this.screens.get(0));
      } else {
        this.display((Screen) null);
      }
    }
}public void display(@Nullable final Screen screen) {
    if (Game.hasStarted() && Game.time().since(this.lastScreenChange) < this.getChangeCooldown()) {
      log.log(
          Level.INFO,
          "Skipping displaying of screen {0} because screen changing is currently on cooldown.",
          screen != null ? screen.getName() : "");
      return;
    }

    final Screen previous = this.current();
    if (previous != null) {
      previous.suspend();
    }

    if (screen != null && !this.screens.contains(screen)) {
      this.screens.add(screen);
    }

    this.currentScreen = screen;
    if (!Game.isInNoGUIMode() && this.current() != null) {
      this.current().prepare();
    }

    this.lastScreenChange = Game.loop().getTicks();

    final ScreenChangedEvent event = new ScreenChangedEvent(this.current(), previous);
    for (final ScreenChangedListener listener : this.screenChangedListeners) {
      listener.changed(event);
    }
}
}
```
```java
class de.gurkenlabs.litiengine.abilities.Ability {
public boolean isOnCooldown() {
    return (this.getCurrentExecution() != null
        && this.getCurrentExecution().getExecutionTicks() > 0
        && Game.time().since(this.getCurrentExecution().getExecutionTicks())
            < this.getAttributes().cooldown().get());
}public boolean isActive() {
    return this.getCurrentExecution() != null
        && Game.time().since(this.getCurrentExecution().getExecutionTicks())
            < this.getAttributes().duration().get();
}@Nullable
  public AbilityExecution cast() {
    if (!this.canCast()) {
      return null;
    }
    this.currentExecution = new AbilityExecution(this);

    for (final AbilityCastListener listener : this.abilityCastListeners) {
      listener.abilityCast(this.currentExecution);
    }

    return this.getCurrentExecution();
}public float getRemainingCooldownInSeconds() {
    if (this.getCurrentExecution() == null
        || this.getExecutor() == null
        || this.getExecutor().isDead()) {
      return 0;
    }

    // calculate cooldown in seconds
    return (float)
        (!this.canCast()
            ? (this.getAttributes().cooldown().get()
                    - Game.time().since(this.getCurrentExecution().getExecutionTicks()))
                * 0.001
            : 0);
}
}
```
```java
class de.gurkenlabs.litiengine.entities.EntityHitEvent {
EntityHitEvent(
      final ICombatEntity hitEntity,
      @Nullable final Ability ability,
      final int damage,
      final boolean kill) {
    super(hitEntity);
    this.executor = ability != null ? ability.getExecutor() : null;
    this.hitEntity = hitEntity;
    this.ability = ability;
    this.damage = damage;
    this.kill = kill;
    this.time = Game.time().now();
}
}
```
```java
class de.gurkenlabs.litiengine.graphics.emitters.Emitter {
public void delete() {
    this.deactivate();
    if (Game.world().environment() != null) {
      Game.world().environment().remove(this);
    }
}public void activate() {
    if (this.activated) {
      return;
    }

    this.activated = true;
    this.activationTick = Game.time().now();
    Game.loop().attach(this);
}@Override
  public void update() {
    if (this.isPaused()) {
      return;
    }

    // clear particles if the effect time to life is reached
    if (this.isFinished()) {
      for (EmitterFinishedListener listener : this.finishedListeners) {
        listener.finished(this);
      }

      this.delete();
      return;
    }

    final float updateRatio = (float) this.data().getUpdateRate() / Game.loop().getTickRate();
    for (final Particle p : this.getParticles().stream().collect(Collectors.toList())) {
      if (this.particleCanBeRemoved(p)) {
        // remove dead particles
        this.particles.remove(p);
        continue;
      }

      p.update(this.getOrigin(), updateRatio);
    }

    this.aliveTime = Game.time().since(this.activationTick);
    if ((this.data().getSpawnRate() == 0
        || Game.time().since(this.lastSpawn) >= this.data().getSpawnRate())) {
      this.lastSpawn = Game.time().now();
      this.spawnParticle();
    }
}
}
```
```java
class de.gurkenlabs.litiengine.GameLoop {
@Override
  public int perform(int delay, Runnable action) {
    final long d = Game.time().toTicks(delay);

    TimedAction a = new TimedAction(this.getTicks() + d, action);
    this.actions.add(a);

    return a.getId();
}
}
```
```java
class de.gurkenlabs.litiengine.environment.EntitySpawner {
protected boolean shouldSpawn() {
    return this.lastSpawnWave == 0
        || Game.time().since(this.lastSpawnWave) >= this.getSpawnInterval();
}@Override
  public void update() {
    if (!this.shouldSpawn()) {
      return;
    }

    this.spawnNewEntities();
    this.lastSpawnWave = Game.time().now();
}
}
```
```java
class de.gurkenlabs.litiengine.graphics.FreeFlightCamera {
@Override
  public void update() {
    this.handleFreeFlightCamera();
}public FreeFlightCamera(double x, double y) {
    this(new Point2D.Double(x, y));
}
}
```
```java
class de.gurkenlabs.litiengine.environment.Environment {
public void unload() {
    if (!this.loaded) {
      return;
    }

    // unregister all updatable entities from the current environment
    for (final IEntity entity : this.allEntities.values()) {
      this.unload(entity);
    }

    this.loaded = false;
    this.fireEvent(l -> l.unloaded(this));
}private static void loadUpdatableOrEmitterEntity(IEntity entity) {
    if (entity instanceof Emitter) {
      final Emitter emitter = (Emitter) entity;
      if (emitter.isActivateOnInit()) {
        emitter.activate();
      }
    } else if (entity instanceof IUpdateable) {
      Game.loop().attach((IUpdateable) entity);
    }
}public void clear() {
    Game.physics().clear();

    this.combatEntities.clear();
    this.mobileEntities.clear();
    this.gravityForces.clear();
    this.layerEntities.clear();
    this.entitiesByTag.clear();
    this.allEntities.clear();

    for (RenderType renderType : RenderType.values()) {
      this.miscEntities.get(renderType).clear();
      this.renderListeners.get(renderType).clear();
      this.renderables.get(renderType).clear();
    }

    dispose(this.allEntities.values());
    dispose(this.triggers);
    this.emitters.clear();
    this.colliders.clear();
    this.props.clear();
    this.creatures.clear();
    this.staticShadows.clear();
    this.combatEntities.clear();
    this.mobileEntities.clear();
    this.lightSources.clear();
    this.spawnPoints.clear();
    this.soundSources.clear();
    this.mapAreas.clear();
    this.triggers.clear();

    this.ambientLight = null;
    this.staticShadowLayer = null;

    for (Map<Integer, IEntity> type : this.miscEntities.values()) {
      type.clear();
    }

    this.initialized = false;

    this.fireEvent(l -> l.cleared(this));
}private void load(final IEntity entity) {
    // an entity can only exist on one environment at a time, so remove it from the current one
    if (entity.getEnvironment() != null) {
      entity.getEnvironment().remove(entity);
    }

    // 1. add to physics engine
    loadPhysicsEntity(entity);

    // 2. register for update or activate
    loadUpdatableOrEmitterEntity(entity);

    // 3. if a gravity is defined, add a gravity force to the entity
    if (entity instanceof IMobileEntity && this.getGravity() != 0) {
      this.addGravityForce((IMobileEntity) entity);
    }

    // 4. attach all controllers
    entity.attachControllers();

    if (this.loaded && (entity instanceof LightSource || entity instanceof StaticShadow)) {
      this.updateLighting(entity);
    }

    entity.loaded(this);
}private void unload(final IEntity entity) {
    // 1. remove from physics engine
    if (entity instanceof ICollisionEntity) {
      Game.physics().remove((ICollisionEntity) entity);
    }

    // 2. unregister from update
    if (entity instanceof IUpdateable) {
      Game.loop().detach((IUpdateable) entity);
    }

    if (entity instanceof IMobileEntity) {
      this.removeGravity((IMobileEntity) entity);
    }

    // 3. detach all controllers
    entity.detachControllers();

    if (entity instanceof Emitter) {
      Emitter em = (Emitter) entity;
      em.deactivate();
    }

    if (this.loaded && (entity instanceof LightSource || entity instanceof StaticShadow)) {
      this.updateLighting(entity);
    }

    entity.removed(this);
}public void remove(final IEntity entity) {
    if (entity == null) {
      return;
    }

    this.allEntities.remove(entity.getMapId());
    Iterator<List<IEntity>> iter = this.layerEntities.values().iterator();
    while (iter.hasNext()) {
      List<IEntity> layer = iter.next();
      if (layer.remove(entity) && layer.isEmpty()) {
        iter.remove();
      }
    }
    if (this.miscEntities.get(entity.getRenderType()) != null) {
      this.miscEntities.get(entity.getRenderType()).values().remove(entity);
    }

    for (String tag : entity.getTags()) {
      if (this.getEntitiesByTag().containsKey(tag)) {
        this.getEntitiesByTag().get(tag).remove(entity);

        if (this.getEntitiesByTag().get(tag).isEmpty()) {
          this.getEntitiesByTag().remove(tag);
        }
      }
    }

    if (entity instanceof Emitter) {
      Emitter emitter = (Emitter) entity;
      this.removeEmitter(emitter);
    }

    if (entity instanceof MapArea) {
      this.mapAreas.remove(entity);
    }

    if (entity instanceof Prop) {
      this.props.remove(entity);
    }

    if (entity instanceof Creature) {
      this.creatures.remove(entity);
    }

    if (entity instanceof CollisionBox) {
      this.colliders.remove(entity);
      this.staticShadows.removeIf(x -> x.getOrigin() != null && x.getOrigin().equals(entity));
    }

    if (entity instanceof LightSource) {
      this.lightSources.remove(entity);
      this.updateLighting(entity);
    }

    if (entity instanceof Trigger) {
      this.triggers.remove(entity);
    }

    if (entity instanceof Spawnpoint) {
      this.spawnPoints.remove(entity);
    }
    if (entity instanceof SoundSource) {
      this.soundSources.remove(entity);
    }

    if (entity instanceof StaticShadow) {
      this.staticShadows.remove(entity);
      this.updateLighting(entity);
    }

    if (entity instanceof IMobileEntity) {
      this.mobileEntities.values().remove(entity);
    }

    if (entity instanceof ICombatEntity) {
      this.combatEntities.values().remove(entity);
    }

    this.unload(entity);

    this.fireEntityEvent(l -> l.entityRemoved(entity));
}
}
```
```java
class de.gurkenlabs.litiengine.physics.MovementController {
@Override
  public void update() {
    this.handleForces();
    this.handleMovement();
}
}
```
```java
class de.gurkenlabs.litiengine.Game {
static synchronized void terminate() {
    if (!initialized) {
      return;
    }

    hasStarted = false;
    initialized = false;

    config().save();
    gameLoop.terminate();
    tweenEngine.terminate();
    soundEngine.terminate();

    world().clear();

    for (final GameListener listener : gameListeners) {
      try {
        listener.terminated();
      } catch (Exception e) {
        log().log(Level.WARNING, "game listener threw an exception during shutdown", e);
      }
    }

    gameLoop = null;
    screenManager = null;
    gameWindow = null;
}public static synchronized void start() {
    if (!initialized) {
      throw new IllegalStateException(
          "The game cannot be started without being first initialized. Call Game.init(...) before Game.start().");
    }

    gameLoop.start();
    tweenEngine.start();
    soundEngine.start();

    for (final GameListener listener : gameListeners) {
      listener.started();
    }

    hasStarted = true;
}public static synchronized void init(String... args) {
    if (initialized) {
      log().log(Level.INFO, "The game has already been initialized.");
      return;
    }

    log.init();
    handleCommandLineArguments(args);

    config().load();
    Locale.setDefault(new Locale(config().client().getCountry(), config().client().getLanguage()));

    gameLoop = new GameLoop("Main Update Loop", config().client().getMaxFps());
    loop().attach(physics());
    loop().attach(world());

    // setup default exception handling for render and update loop
    setUncaughtExceptionHandler(
        new DefaultUncaughtExceptionHandler(config().client().exitOnError()));

    screenManager = new ScreenManager();
    gameWindow = new GameWindow();

    // initialize  the game window
    window().init();
    world.setCamera(new Camera());

    for (GameListener listener : gameListeners) {
      listener.initialized(args);
    }

    if (!isInNoGUIMode()) {
      window().getRenderComponent().onRendered(g -> metrics().render(g));

      graphics()
          .addEntityRenderedListener(
              e -> DebugRenderer.renderEntityDebugInfo(e.getGraphics(), e.getEntity()));

      window().getRenderComponent().onFpsChanged(fps -> metrics().setFramesPerSecond(fps));
      window()
          .setIcons(
              Arrays.asList(
                  Resources.images().get("liti-logo-x16.png"),
                  Resources.images().get("liti-logo-x20.png"),
                  Resources.images().get("liti-logo-x32.png"),
                  Resources.images().get("liti-logo-x48.png")));

      Input.keyboard()
          .onKeyTyped(
              KeyEvent.VK_PRINTSCREEN,
              key -> {
                // don't take a screenshot if a modifier is active
                if (key.getModifiers() != 0) {
                  return;
                }

                window().getRenderComponent().takeScreenshot();
              });
    }

    Runtime.getRuntime().addShutdownHook(new Thread(Game::terminate, "Shutdown"));

    initialized = true;
}
}
```


Response Format:
Provide the answer in **XML format** as follows:

#### If the method **cannot** return `null` at the specific call site:
```xml
<response>
  <reason><![CDATA[EXPLAIN WHY THE INVOCATION Game.loop() RESULT CANNOT BE NULL.]]></reason>
  <value>NO</value>
</response>

#### If the method can return null at the specific call site:
<response>
  <reason><![CDATA[EXPLAIN WHY THE INVOCATION Game.loop() RESULT CAN BE NULL.]]></reason>
  <value>YES</value>
</response>

#### If you are unsure or If there are any methods that directly or indirectly affect the return value and are not fully disclosed, request their declarations first, in the following format:
<response>
  <reason><![CDATA[EXPLAIN WHY THIS METHOD DECLARATION IS NECESSARY AND WHY YOU CANNOT MAKE A CONFIDENT DECISION WITHOUT IT]]></reason>
  <success>false</success>
  <methods>
    <method>methodName</method>
  </methods>
</response>

Additional Notes:
Be precise in your reasoning.
If a method’s return value depends on another method not provided, request its declaration before making a conclusion.
If the method can return null in this case but not in others, explain why it happens specifically for this call.

---ChatGPT.sendRequestToOpenAI---
Retrieving response from cache
---Response.<init>---
Creating Response:
```xml
<response>
  <reason><![CDATA[The method `Game.loop()` returns the static field `gameLoop`, which is initialized in the `Game.init(String... args)` method. In this method, a new `GameLoop` object is instantiated and assigned to `gameLoop`. Since `init()` must be called before `start()`, which is implied by the requirement of initializing the game, the `gameLoop` is guaranteed to be non-null during the lifetime of the game execution where `Game.loop()` is called. The absence of any code that could set `gameLoop` to null after its initialization ensures that `Game.loop()` cannot return null.]]></reason>
  <value>NO</value>
</response>
```
---Response.<init>---
Response created:
Disagreement: The method `Game.loop()` returns the static field `gameLoop`, which is initialized in the `Game.init(String... args)` method. In this method, a new `GameLoop` object is instantiated and assigned to `gameLoop`. Since `init()` must be called before `start()`, which is implied by the requirement of initializing the game, the `gameLoop` is guaranteed to be non-null during the lifetime of the game execution where `Game.loop()` is called. The absence of any code that could set `gameLoop` to null after its initialization ensures that `Game.loop()` cannot return null.
---AdvancedNullAwayCodeFix.resolveMethodDereferenceError---
Method is not returning nullable on call site. Injecting suppression annotation.
---AdvancedNullAwayCodeFix.constructCastToNonnullChange---
Constructing cast to nonnull change for reason: The method `Game.loop()` returns the static field `gameLoop`, which is initialized in the `Game.init(String... args)` method. In this method, a new `GameLoop` object is instantiated and assigned to `gameLoop`. Since `init()` must be called before `start()`, which is implied by the requirement of initializing the game, the `gameLoop` is guaranteed to be non-null during the lifetime of the game execution where `Game.loop()` is called. The absence of any code that could set `gameLoop` to null after its initialization ensures that `Game.loop()` cannot return null.
---ChatGPT.ask---
Asking ChatGPT:
For the reason you mentioned earlier:

"The method `Game.loop()` returns the static field `gameLoop`, which is initialized in the `Game.init(String... args)` method. In this method, a new `GameLoop` object is instantiated and assigned to `gameLoop`. Since `init()` must be called before `start()`, which is implied by the requirement of initializing the game, the `gameLoop` is guaranteed to be non-null during the lifetime of the game execution where `Game.loop()` is called. The absence of any code that could set `gameLoop` to null after its initialization ensures that `Game.loop()` cannot return null."

in the method below, the expression Game.loop() is not nullable at the point it is used.

```java
public void display(@Nullable final Screen screen) {
    if (Game.hasStarted() && Game.time().since(this.lastScreenChange) < this.getChangeCooldown()) {
      log.log(
          Level.INFO,
          "Skipping displaying of screen {0} because screen changing is currently on cooldown.",
          screen != null ? screen.getName() : "");
      return;
    }

    final Screen previous = this.current();
    if (previous != null) {
      previous.suspend();
    }

    if (screen != null && !this.screens.contains(screen)) {
      this.screens.add(screen);
    }

    this.currentScreen = screen;
    if (!Game.isInNoGUIMode() && this.current() != null) {
      this.current().prepare();
    }

    this.lastScreenChange = Game.loop().getTicks();

    final ScreenChangedEvent event = new ScreenChangedEvent(this.current(), previous);
    for (final ScreenChangedListener listener : this.screenChangedListeners) {
      listener.changed(event);
    }
}
```
Please Summarize the reason in max 5 words and rewrite the method so that at the line "    this.lastScreenChange = Game.loop().getTicks();", at the occurrence of: "Game.loop()" is replaced with `NullabilityUtil.castToNonnull(Game.loop(), summary of reason)`
Replace "REASON" with the exact reason summary I provide to you (maximum 5 words), not with a generic explanation like "checked to be nonnull".
see the example below, for expression `foo.getBar()`, to wrap it with `NullabilityUtil.castToNonnull(foo.getBar(), "reason")`.

```java
public t(){
    String l = foo.getBar();
}
```

will be:
```java
public t(){
    String l = NullabilityUtil.castToNonnull(foo.getBar(), "checked to be nonnull");
}
```

### Instructions:

Do not import any additional classes.

Do not add Java comments.

Only modify relevant lines as required.

Return only the modified method wrapped in the XML format shown below.

Place the Java code inside the <code> tag using a CDATA block with ```java formatting.

Just give me the fixed code snippet in XML format in <response> tag like the example below. I will apply the fix to my codebase. Do not import any additional libraries or classes or add java comments. If you can provide the fixed code snippet, please provide it in the following format and place the code snippet in the <code> tag within ```java block.
<response>
  <success>true</success>
  <code><![CDATA[
  ```java
  Your fixed code snippet here
  ```
    ]]>
  </code>
</response>

---ChatGPT.sendRequestToOpenAI---
Retrieving response from cache
---Response.<init>---
Creating Response:
<response>
  <success>true</success>
  <code><![CDATA[
  ```java
public void display(final Screen screen) {
    if (Game.hasStarted() && Game.time().since(this.lastScreenChange) < this.getChangeCooldown()) {
        log.log(
            Level.INFO,
            "Skipping displaying of screen {0} because screen changing is currently on cooldown.",
            screen != null ? screen.getName() : "");
        return;
    }

    final Screen previous = this.current();
    if (previous != null) {
        previous.suspend();
    }

    if (screen != null && !this.screens.contains(screen)) {
        this.screens.add(screen);
    }

    this.currentScreen = screen;
    if (!Game.isInNoGUIMode() && this.current() != null) {
        this.current().prepare();
    }

    this.lastScreenChange = NullabilityUtil.castToNonnull(Game.loop(), "initialized before usage").getTicks();

    final ScreenChangedEvent event = new ScreenChangedEvent(this.current(), previous);
    for (final ScreenChangedListener listener : this.screenChangedListeners) {
        listener.changed(event);
    }
}
```
    ]]>
  </code>
</response>
---Response.<init>---
Response created:
public void display(final Screen screen) {
    if (Game.hasStarted() && Game.time().since(this.lastScreenChange) < this.getChangeCooldown()) {
        log.log(
            Level.INFO,
            "Skipping displaying of screen {0} because screen changing is currently on cooldown.",
            screen != null ? screen.getName() : "");
        return;
    }

    final Screen previous = this.current();
    if (previous != null) {
        previous.suspend();
    }

    if (screen != null && !this.screens.contains(screen)) {
        this.screens.add(screen);
    }

    this.currentScreen = screen;
    if (!Game.isInNoGUIMode() && this.current() != null) {
        this.current().prepare();
    }

    this.lastScreenChange = NullabilityUtil.castToNonnull(Game.loop(), "initialized before usage").getTicks();

    final ScreenChangedEvent event = new ScreenChangedEvent(this.current(), previous);
    for (final ScreenChangedListener listener : this.screenChangedListeners) {
        listener.changed(event);
    }
}
---ChatGPT.fixDereferenceByAddingCastToNonnull---
Fixing the error by adding castToNonnull
---AdvancedNullAwayCodeFix.fixTriggeredErrorsForLocation---
Resolving unresolvable error for triggered error: Type='DEREFERENCE_NULLABLE', message='dereferenced expression Game.loop() is @Nullable'
/home/nima/Developer/nullness-benchmarks/litiengine/src/de/gurkenlabs/litiengine/environment/Environment.java:2278
      Game.loop().attach((IUpdateable) entity);
---AdvancedNullAwayCodeFix.fix---
Fixing error: Type='DEREFERENCE_NULLABLE', message='dereferenced expression Game.loop() is @Nullable'
/home/nima/Developer/nullness-benchmarks/litiengine/src/de/gurkenlabs/litiengine/environment/Environment.java:2278
      Game.loop().attach((IUpdateable) entity);
---AdvancedNullAwayCodeFix.resolveDereferenceError---
Resolving dereference error: Type='DEREFERENCE_NULLABLE', message='dereferenced expression Game.loop() is @Nullable'
/home/nima/Developer/nullness-benchmarks/litiengine/src/de/gurkenlabs/litiengine/environment/Environment.java:2278
      Game.loop().attach((IUpdateable) entity);
---AdvancedNullAwayCodeFix.resolveDereferenceError---
Checking nullability possibility at error point
---ChatGPT.checkNullabilityPossibilityAtErrorPoint---
Asking if the expression can be null at error point point
---ChatGPT.ask---
Asking ChatGPT:
In the method below, is there a possibility that the expression "Game.loop()" at line "Game.loop().attach((IUpdateable) entity);" is null?
private static void loadUpdatableOrEmitterEntity(IEntity entity) {
    if (entity instanceof Emitter) {
      final Emitter emitter = (Emitter) entity;
      if (emitter.isActivateOnInit()) {
        emitter.activate();
      }
    } else if (entity instanceof IUpdateable) {
      Game.loop().attach((IUpdateable) entity);
    }
}
Give a single-word answer in XML format. If it is possible for the expression to be null, respond with:
```xml
<response>
    <reason><![CDATA[YOUR REASON]]></reason>
    <value>YES</value>
</response>
```
If it is not possible for the expression to be null, respond with:
```xml
<response>
    <reason><![CDATA[YOUR REASON]]></reason>
    <value>NO</value>
</response>
```
If you are unsure or need more information, respond with where you can ask for more details or what specific information you need.

If additional information is required, list each request inside a `<request>` tag. If no additional information is needed, omit the `<requests>` section.

Respond with:
```xml
<response>
    <reason><![CDATA[YOUR REASON]]></reason>
    <value>UNKNOWN</value>
    <!-- Include <requests> only if additional information is needed -->
    <requests>
        <request><![CDATA[YOUR REQUEST 1]]></request>
        <request><![CDATA[YOUR REQUEST 2]]></request>
    </requests>
</response>
```
---ChatGPT.sendRequestToOpenAI---
Retrieving response from cache
---Response.<init>---
Creating Response:
```xml
<response>
    <reason><![CDATA[Insufficient information is provided about the `Game.loop()` method. Without knowing the implementation details of `Game.loop()`, such as whether it has checks to ensure it always returns a non-null object, it is unclear if it can return null.]]></reason>
    <value>UNKNOWN</value>
    <requests>
        <request><![CDATA[Provide implementation or documentation details of the `Game.loop()` method to determine if it can return null.]]></request>
    </requests>
</response>
```
---Response.<init>---
Response created:
Unknown: Insufficient information is provided about the `Game.loop()` method. Without knowing the implementation details of `Game.loop()`, such as whether it has checks to ensure it always returns a non-null object, it is unclear if it can return null.
---AdvancedNullAwayCodeFix.resolveMethodDereferenceError---
Resolving method dereference error.
---AdvancedNullAwayCodeFix.resolveMethodDereferenceError---
Method is in annotated package. Checking if the method is returning nullable.
---AdvancedNullAwayCodeFix.investigateMethodReturnNullability---
Checking if the method is returning nullable.
---ChatGPT.checkIfMethodIsReturningNullable---
Asking if the method is returning nullable: loop()
---ChatGPT.ask---
Asking ChatGPT:
In the method below, is there a possibility that the method returns null based only on its body? Consider the following points:

- The method may have multiple return paths; consider all return statements.
- If the method calls another method, do not assume its return value unless its full declaration is provided. Request its declaration if needed.
- The method may throw an exception instead of returning null. An exception path should not be considered a null return.
- Ensure you request the declarations of any methods whose return values directly or indirectly impact this method’s return value before making a conclusion.
- Carefully analyze all conditions and prior operations that may guarantee a non-null return value.

@Nullable public static IGameLoop loop() {
    return gameLoop;
}

Here are the method definitions in addition to the method inquired:

Depth: 0
```java
class de.gurkenlabs.litiengine.Game {
@Nullable public static IGameLoop loop() {
    return gameLoop;
}
}
```


Response Format:
Provide the answer in **XML format** as follows:

#### If the method **cannot** return `null`:
```xml
<response>
  <reason><![CDATA[EXPLAIN WHY THE METHOD CANNOT RETURN NULL]]></reason>
  <value>NO</value>
</response>
```

#### If the method can return null:
```xml
<response>
  <reason><![CDATA[EXPLAIN WHY THE METHOD CAN RETURN NULL]]></reason>
  <value>YES</value>
</response>
```

#### If you are unsure or need more information, respond with where you can ask for more details or what specific information you need.

#### If you are unsure or If there are any methods that directly or indirectly affect the return value and are not fully disclosed, request their declarations first, in the following format:
<response>
  <reason><![CDATA[YOUR REASON]]></reason>
  <value>UNKNOWN</value>
  <methods>
    <method>methodName</method>
  </methods>
</response>

If additional information is required other than method declaration, list each request inside a `<request>` tag. If no additional information is needed, omit the `<requests>` section.

Respond with:
```xml
<response>
    <reason><![CDATA[YOUR REASON]]></reason>
    <value>UNKNOWN</value>
    <!-- Include <requests> only if additional information is needed -->
    <requests>
        <request><![CDATA[YOUR REQUEST 1]]></request>
        <request><![CDATA[YOUR REQUEST 2]]></request>
    </requests>
</response>
```

Additional Notes:
Be precise in your reasoning.
If a method’s return value depends on another method not provided, request its declaration before making a conclusion.
If the method can return null in some cases but not others, explain under what conditions it can happen.

---ChatGPT.sendRequestToOpenAI---
Retrieving response from cache
---Response.<init>---
Creating Response:
```xml
<response>
  <reason><![CDATA[The method `loop` returns the variable `gameLoop`. Without the initialization or assignment details of `gameLoop`, it's unclear whether it can be null. The possibility of `gameLoop` being uninitialized or set to null elsewhere in the program means `loop` could potentially return null. Further information on `gameLoop` is required.]]></reason>
  <value>UNKNOWN</value>
  <requests>
    <request><![CDATA[Please provide the declaration and initialization of the variable `gameLoop` in the class `de.gurkenlabs.litiengine.Game`.]]></request>
  </requests>
</response>
```
---Response.<init>---
Response created:
Unknown: The method `loop` returns the variable `gameLoop`. Without the initialization or assignment details of `gameLoop`, it's unclear whether it can be null. The possibility of `gameLoop` being uninitialized or set to null elsewhere in the program means `loop` could potentially return null. Further information on `gameLoop` is required.
---AdvancedNullAwayCodeFix.investigateMethodReturnNullability---
Could not determine the nullability and model did not ask for any method.
---ChatGPT.checkIfMethodIsReturningNullableOnCallSite---
Asking if the method is returning nullable on the call site: Game.loop()
---ChatGPT.ask---
Asking ChatGPT:
In the method below, is there a possibility that the method returns null at the given call site?

```java
@Nullable public static IGameLoop loop() {
    return gameLoop;
}
```

## Guidelines:
- The method may have multiple return paths; consider all return statements.
- If the method calls another method, do not assume its return value unless its full declaration is provided. Request its declaration if needed.
- The method may throw an exception instead of returning null. An exception path should not be considered a null return.
- Ensure you request the declarations of any methods whose return values directly or indirectly impact this method’s return value before making a conclusion.
- If the method returns a value that is determined by a parameter, evaluate based on the actual argument at the given call site.
- Analyze based only on the specific invocation provided. Do not generalize to all possible inputs.- If the return value is guaranteed to be non-null at the call site, the answer should be a definitive NO.
- Do not generalize based on all possible inputs—your answer must be based only on the given invocation.
- Focus only on the given call site, not all possible invocations.

### call site:
Game.loop()

Here are the method definitions and the call chain for this method, showing the sequence of calls from the method to its callers at each depth level:

Depth: 0
```java
class de.gurkenlabs.litiengine.Game {
@Nullable public static IGameLoop loop() {
    return gameLoop;
}
}
```
Depth: 1
```java
class de.gurkenlabs.litiengine.environment.GameWorld {
public void loadEnvironment(@Nullable final Environment env) {
    Lock lock = Game.loop().getLock();
    lock.lock();
    try {
      unloadEnvironment();
      this.environment = env;
      if (env != null) {
        this.addEnvironment(env);

        if (env.getGravity() == 0 && this.gravity() != 0) {
          env.setGravity(this.gravity());
        }

        env.load();
        for (final EnvironmentLoadedListener listener : this.loadedListeners) {
          listener.loaded(env);
        }

        // call map specific listeners
        String mapName = getMapName(env);
        if (mapName != null && this.environmentLoadedListeners.containsKey(mapName)) {

          // for the default camera we center the camera on the environment
          if (this.camera().getClass().equals(Camera.class)) {
            camera().setFocus(env.getCenter());
          }

          for (EnvironmentLoadedListener listener : this.environmentLoadedListeners.get(mapName)) {
            listener.loaded(env);
          }
        }
      }
    } finally {
      lock.unlock();
    }
}public void setCamera(@Nullable final ICamera cam) {
    if (this.camera() != null) {
      Game.loop().detach(camera);
    }

    camera = cam;

    if (cam != null && !Game.isInNoGUIMode()) {
      Game.loop().attach(cam);
      cam.updateFocus();
    }
}
}
```
```java
class de.gurkenlabs.litiengine.entities.behavior.EntityNavigator {
public EntityNavigator(final IMobileEntity entity, final PathFinder pathFinder) {
    this.cancelNavigationConditions = new CopyOnWriteArrayList<>();
    this.listeners = new CopyOnWriteArrayList<>();
    this.entity = entity;
    this.pathFinder = pathFinder;
    this.setAcceptableError(DEFAULT_ACCEPTABLE_ERROR);
    Game.loop().attach(this);
}
}
```
```java
class de.gurkenlabs.litiengine.GameWindow {
private static void initializeWindowEventListeners(Window window) {

    window.addWindowStateListener(
        e -> {
          if (e.getNewState() == Frame.ICONIFIED) {
            Game.loop().setTickRate(ICONIFIED_MAX_FPS);
          } else {
            Game.loop().setTickRate(Game.config().client().getMaxFps());
          }
        });

    window.addWindowFocusListener(
        new WindowFocusListener() {
          @Override
          public void windowLostFocus(WindowEvent e) {
            if (Game.config().graphics().reduceFramesWhenNotFocused()) {
              Game.loop().setTickRate(NONE_FOCUS_MAX_FPS);
            }
          }

          @Override
          public void windowGainedFocus(WindowEvent e) {
            Game.loop().setTickRate(Game.config().client().getMaxFps());
          }
        });

    window.addWindowListener(
        new WindowAdapter() {
          @Override
          public void windowClosing(final WindowEvent event) {
            Game.exit();
          }
        });
}
}
```
```java
class de.gurkenlabs.litiengine.gui.screens.ScreenManager {
public void display(@Nullable final Screen screen) {
    if (Game.hasStarted() && Game.time().since(this.lastScreenChange) < this.getChangeCooldown()) {
      log.log(
          Level.INFO,
          "Skipping displaying of screen {0} because screen changing is currently on cooldown.",
          screen != null ? screen.getName() : "");
      return;
    }

    final Screen previous = this.current();
    if (previous != null) {
      previous.suspend();
    }

    if (screen != null && !this.screens.contains(screen)) {
      this.screens.add(screen);
    }

    this.currentScreen = screen;
    if (!Game.isInNoGUIMode() && this.current() != null) {
      this.current().prepare();
    }

    this.lastScreenChange = Game.loop().getTicks();

    final ScreenChangedEvent event = new ScreenChangedEvent(this.current(), previous);
    for (final ScreenChangedListener listener : this.screenChangedListeners) {
      listener.changed(event);
    }
}
}
```
```java
class de.gurkenlabs.litiengine.abilities.effects.Effect {
@Override
  public void update() {

    for (final Iterator<EffectApplication> iterator = this.getActiveAppliances().iterator();
        iterator.hasNext(); ) {
      final EffectApplication appliance = iterator.next();
      // if the effect duration is reached
      if (this.hasEnded(appliance)) {

        iterator.remove();
        this.cease(appliance);
      }
    }

    // 4. unregister if all appliances are finished
    if (this.getActiveAppliances().isEmpty()) {
      Game.loop().detach(this);
    }
}public void apply(final Shape impactArea) {
    final List<ICombatEntity> affected = this.lookForAffectedEntities(impactArea);
    for (final ICombatEntity affectedEntity : affected) {
      this.apply(affectedEntity);
    }

    this.appliances.add(new EffectApplication(affected, impactArea));

    // if it is the first appliance -> register for update
    if (this.appliances.size() == 1) {
      Game.loop().attach(this);
    }
}
}
```
```java
class de.gurkenlabs.litiengine.GameTime {
public long toTicks(final int milliseconds) {
    return this.toTicks(milliseconds, Game.loop().getTickRate());
}public long since(final long tick) {
    return toMilliseconds(Game.loop().getTicks() - tick);
}public long now() {
    return Game.loop().getTicks();
}public long sinceGameStart() {
    return this.toMilliseconds(Game.loop().getTicks());
}@Override
  public void loaded(Environment environment) {
    environmentLoaded = Game.loop().getTicks();
}public long toMilliseconds(final long ticks) {
    return this.toMilliseconds(ticks, Game.loop().getTickRate());
}
}
```
```java
class de.gurkenlabs.litiengine.GameMetrics {
@Override
  public void render(final Graphics2D g) {
    this.updateMetrics();

    if (!Game.config().client().showGameMetrics()) {
      return;
    }

    this.currentOffsetY = 0;

    g.setColor(this.renderColor);

    // render client metrics
    this.drawTitle(g, "[client]");
    this.drawMetric(g, "fps       : " + this.getFramesPerSecond());
    this.drawMetric(g, "max fps   : " + this.maxFramesPerSecond);
    this.drawMetric(g, "updatables: " + Game.loop().getUpdatableCount());

    // render jvm metrics if debug is enabled
    if (Game.config().debug().isDebugEnabled()) {
      this.drawTitle(g, "[jvm]");
      this.drawMetric(g, "java      : " + this.javaVersion);
      this.drawMetric(g, "memory    : " + String.format("%-5.5s", this.usedMemory) + " MB");
      this.drawMetric(g, "threads   : " + Thread.activeCount());
    }

    // render rendering metrics
    if (!this.renderMetrics.isEmpty()) {
      this.drawTitle(g, "[update]");

      for (RenderMetrics metric : this.renderMetrics) {
        this.drawMetric(g, metric.toString());
      }

      this.renderMetrics.clear();
    }
}
}
```
```java
class de.gurkenlabs.litiengine.graphics.emitters.Emitter {
public void deactivate() {
    if (!this.activated) {
      return;
    }

    this.activated = false;
    this.getParticles().clear();
    this.aliveTime = 0;
    this.activationTick = 0;
    this.lastSpawn = 0;
    Game.loop().detach(this);
}public void activate() {
    if (this.activated) {
      return;
    }

    this.activated = true;
    this.activationTick = Game.time().now();
    Game.loop().attach(this);
}@Override
  public void update() {
    if (this.isPaused()) {
      return;
    }

    // clear particles if the effect time to life is reached
    if (this.isFinished()) {
      for (EmitterFinishedListener listener : this.finishedListeners) {
        listener.finished(this);
      }

      this.delete();
      return;
    }

    final float updateRatio = (float) this.data().getUpdateRate() / Game.loop().getTickRate();
    for (final Particle p : this.getParticles().stream().collect(Collectors.toList())) {
      if (this.particleCanBeRemoved(p)) {
        // remove dead particles
        this.particles.remove(p);
        continue;
      }

      p.update(this.getOrigin(), updateRatio);
    }

    this.aliveTime = Game.time().since(this.activationTick);
    if ((this.data().getSpawnRate() == 0
        || Game.time().since(this.lastSpawn) >= this.data().getSpawnRate())) {
      this.lastSpawn = Game.time().now();
      this.spawnParticle();
    }
}
}
```
```java
class de.gurkenlabs.litiengine.entities.behavior.IBehaviorController {
public default void attach() {
    Game.loop().attach(this);
}public default void detach() {
    Game.loop().detach(this);
}
}
```
```java
class de.gurkenlabs.litiengine.abilities.AbilityExecution {
AbilityExecution(final Ability ability) {
    this.appliedEffects = new CopyOnWriteArrayList<>();
    this.ability = ability;
    this.executionTicks = Game.time().now();
    this.impactArea = ability.calculateImpactArea();
    this.castLocation = ability.getExecutor().getCenter();
    Game.loop().attach(this);
}@Override
  public void update() {
    // if there a no effects to apply -> unregister this instance and we're done
    if (this.getAbility().getEffects().isEmpty()
        || this.getAbility().getEffects().size() == this.getAppliedEffects().size()) {
      Game.loop().detach(this);
      return;
    }

    // handle all effects from the ability that were not applied yet
    for (final Effect effect : this.getAbility().getEffects()) {
      // if the ability was not executed yet or the delay of the effect is not
      // yet reached
      if (this.getAppliedEffects().contains(effect)
          || Game.time().since(this.getExecutionTicks()) < effect.getDelay()) {
        continue;
      }

      effect.apply(this.getExecutionImpactArea());
      this.getAppliedEffects().add(effect);
    }
}
}
```
```java
class de.gurkenlabs.litiengine.GameWindow$3 {
@Override
          public void windowGainedFocus(WindowEvent e) {
            Game.loop().setTickRate(Game.config().client().getMaxFps());
}@Override
          public void windowLostFocus(WindowEvent e) {
            if (Game.config().graphics().reduceFramesWhenNotFocused()) {
              Game.loop().setTickRate(NONE_FOCUS_MAX_FPS);
            }
}
}
```
```java
class de.gurkenlabs.litiengine.environment.EntitySpawner {
protected void spawnNewEntities() {
    if (this.getSpawnMode() != SpawnMode.CUSTOMSPAWNPOINTS && this.getSpawnPoints().isEmpty()) {
      return;
    }

    switch (this.getSpawnMode()) {
      case ALLSPAWNPOINTS:
        for (int i = 0; i < this.getSpawnPoints().size(); i++) {
          final int index = i;
          Game.loop()
              .perform(
                  this.getSpawnDelay() + this.getSpawnDelay() * i,
                  () -> this.spawn(this.getSpawnPoints().get(index), this.getSpawnAmount()));
        }
        break;
      case ONERANDOMSPAWNPOINT:
        this.spawn(Game.random().choose(this.getSpawnPoints()), this.getSpawnAmount());
        break;
      case RANDOMSPAWNPOINTS:
        for (int i = 0; i < this.getSpawnAmount(); i++) {
          Game.loop()
              .perform(
                  this.getSpawnDelay() + this.getSpawnDelay() * i,
                  () -> this.spawn(Game.random().choose(this.getSpawnPoints()), 1));
        }
        break;
      case CUSTOMSPAWNPOINTS:
        List<Spawnpoint> spawnPoints =
            this.customSpawnpoints != null
                ? this.customSpawnpoints.apply(this)
                : this.getCustomSpawnpoints();

        int index = 0;
        for (Spawnpoint spawn : spawnPoints) {
          Game.loop()
              .perform(
                  this.getSpawnDelay() + this.getSpawnDelay() * index, () -> this.spawn(spawn, 1));
          index++;
        }
        break;
      default:
        break;
    }
}
}
```
```java
class de.gurkenlabs.litiengine.tweening.TweenEngine {
@Override
  public void start() {
    Game.loop().attach(this);
}@Override
  public void terminate() {
    Game.loop().detach(this);
}
}
```
```java
class de.gurkenlabs.litiengine.gui.SpeechBubble {
public void hide() {
    Game.world().environment().removeRenderable(this);
    Game.loop().detach(this);
    if (activeSpeechBubbles.get(this.getEntity()) != null
        && activeSpeechBubbles.remove(this.getEntity()).equals(this)) {
      activeSpeechBubbles.remove(this.getEntity());
    }

    for (SpeechBubbleListener listener : this.listeners) {
      listener.hidden();
    }
}private SpeechBubble(
      final IEntity entity,
      final String text,
      @Nullable SpeechBubbleAppearance appearance,
      @Nullable Font font) {
    if (appearance == null) {
      this.appearance = DEFAULT_APPEARANCE;
    } else {
      this.appearance = appearance;
    }

    final SpeechBubble active = activeSpeechBubbles.get(entity);
    if (active != null) {
      active.hide();
    }
    this.setFont(font);

    this.textBoxWidth = (float) (entity.getWidth() * 4);
    this.entity = entity;

    this.currentText = text;
    this.currentTextDisplayTime = DISPLAYTIME_MIN + text.length() * DISPLAYTIME_PER_LETTER;

    this.lastTextDisplay = Game.time().now();
    this.createBubbleImage();
    entity.getEnvironment().add(this, RenderType.UI);
    Game.loop().attach(this);
    activeSpeechBubbles.put(entity, this);
}
}
```
```java
class de.gurkenlabs.litiengine.entities.Prop {
private void updateAnimationController() {
    IEntityAnimationController<?> controller = this.createAnimationController();
    this.getControllers().addController(controller);
    if (Game.world().environment() != null && Game.world().environment().isLoaded()) {
      Game.loop().attach(controller);
    }
}
}
```
```java
class de.gurkenlabs.litiengine.graphics.FreeFlightCamera {
public FreeFlightCamera(final Point2D focus) {
    this.setFocus(focus);
    this.velocity = DEFAULT_SCROLL_PIXELS_PER_SECOND;
    this.scrollPadding = DEFAULT_SCROLL_PADDING;
    this.setClampToMap(true);

    Game.loop().attach(this);
}private void handleFreeFlightCamera() {
    if (Game.world().environment() == null || Game.world().environment().getMap() == null) {
      return;
    }

    final Point2D mouseLocation = Input.mouse().getLocation();

    final double scrollSpeed =
        this.getVelocity()
            / (double) Game.loop().getTickRate()
            * Game.config().input().getMouseSensitivity();

    double x = this.getFocus().getX();
    double y = this.getFocus().getY();

    double deltaX = 0;
    if (mouseLocation.getX() < this.getScrollPadding()) {
      deltaX -= scrollSpeed;
    } else if (Game.window().getResolution().getWidth() - mouseLocation.getX()
        < this.getScrollPadding()) {
      deltaX += scrollSpeed;
    }

    double deltaY = 0;
    if (mouseLocation.getY() < this.getScrollPadding()) {
      deltaY -= scrollSpeed;
    } else if (Game.window().getResolution().getHeight() - mouseLocation.getY()
        < this.getScrollPadding()) {
      deltaY += scrollSpeed;
    }

    x += deltaX;
    y += deltaY;

    this.setFocus(new Point2D.Double(x, y));
}
}
```
```java
class de.gurkenlabs.litiengine.environment.Environment {
private static void dispose(final Collection<? extends IEntity> entities) {
    for (final IEntity entity : entities) {
      if (entity instanceof IUpdateable) {
        Game.loop().detach((IUpdateable) entity);
      }

      entity.detachControllers();
    }
}private static void loadUpdatableOrEmitterEntity(IEntity entity) {
    if (entity instanceof Emitter) {
      final Emitter emitter = (Emitter) entity;
      if (emitter.isActivateOnInit()) {
        emitter.activate();
      }
    } else if (entity instanceof IUpdateable) {
      Game.loop().attach((IUpdateable) entity);
    }
}private void unload(final IEntity entity) {
    // 1. remove from physics engine
    if (entity instanceof ICollisionEntity) {
      Game.physics().remove((ICollisionEntity) entity);
    }

    // 2. unregister from update
    if (entity instanceof IUpdateable) {
      Game.loop().detach((IUpdateable) entity);
    }

    if (entity instanceof IMobileEntity) {
      this.removeGravity((IMobileEntity) entity);
    }

    // 3. detach all controllers
    entity.detachControllers();

    if (entity instanceof Emitter) {
      Emitter em = (Emitter) entity;
      em.deactivate();
    }

    if (this.loaded && (entity instanceof LightSource || entity instanceof StaticShadow)) {
      this.updateLighting(entity);
    }

    entity.removed(this);
}
}
```
```java
class de.gurkenlabs.litiengine.graphics.animation.Animation {
@Override
  public void update() {
    // do nothing if the animation is not playing or the current keyframe is not finished
    if (!this.isPlaying()
        || Game.time().since(this.lastFrameUpdate) < this.getCurrentKeyFrame().getDuration()) {
      return;
    }

    // if we are not looping and the last keyframe is finished, we terminate the animation
    if (!this.isLooping() && this.isLastKeyFrame()) {
      this.terminate();
      return;
    }

    // make sure, we stay inside the keyframe list
    final int newFrameIndex =
        (this.getKeyframes().indexOf(this.currentFrame) + 1) % this.getKeyframes().size();
    final KeyFrame previousFrame = this.currentFrame;
    this.currentFrame = this.getKeyframes().get(newFrameIndex);

    for (KeyFrameListener listener : this.listeners) {
      listener.currentFrameChanged(previousFrame, this.currentFrame);
    }

    this.lastFrameUpdate = Game.loop().getTicks();
}public void restart() {
    this.currentFrame = this.firstFrame;
    this.lastFrameUpdate = Game.loop().getTicks();
}
}
```
```java
class de.gurkenlabs.litiengine.physics.MovementController {
@Override
  public void attach() {
    Game.loop().attach(this);
}private void handleForces() {
    // clean up forces
    this.activeForces.forEach(
        x -> {
          if (x.hasEnded()) {
            this.activeForces.remove(x);
          }
        });

    if (this.activeForces.isEmpty()) {
      return;
    }

    // disable turn-on-move for force handling
    boolean turn = this.getEntity().turnOnMove();
    this.getEntity().setTurnOnMove(false);
    try {
      double deltaX = 0;
      double deltaY = 0;
      for (final Force force : this.activeForces) {
        if (force.cancelOnReached() && force.hasReached(this.getEntity())) {
          force.end();
          continue;
        }

        final Point2D collisionBoxCenter = this.getEntity().getCollisionBoxCenter();
        final double angle =
            GeometricUtilities.calcRotationAngleInDegrees(collisionBoxCenter, force.getLocation());
        final double strength =
            Game.loop().getDeltaTime() * 0.001f * force.getStrength() * Game.loop().getTimeScale();
        deltaX += GeometricUtilities.getDeltaX(angle, strength);
        deltaY += GeometricUtilities.getDeltaY(angle, strength);
      }

      final Point2D target =
          new Point2D.Double(this.getEntity().getX() + deltaX, this.getEntity().getY() + deltaY);
      final boolean success = Game.physics().move(this.getEntity(), target);
      if (!success) {
        for (final Force force : this.activeForces) {
          if (force.cancelOnCollision()) {
            force.end();
          }
        }
      }
    } finally {
      this.getEntity().setTurnOnMove(turn);
    }
}@Override
  public void detach() {
    Game.loop().detach(this);
}public void handleMovement() {
    if (!this.isMovementAllowed()) {
      this.velocity = 0;
      return;
    }

    // max distance an entity can travel within one tick
    final double maxPixelsPerTick = this.getEntity().getTickVelocity();
    final double deltaTime = Game.loop().getDeltaTime() * Game.loop().getTimeScale();

    final double acceleration =
        this.getEntity().getAcceleration() == 0
            ? maxPixelsPerTick
            : deltaTime / this.getEntity().getAcceleration() * maxPixelsPerTick;
    final double deceleration =
        this.getEntity().getDeceleration() == 0
            ? this.getVelocity()
            : deltaTime / this.getEntity().getDeceleration() * maxPixelsPerTick;

    double dx = this.getDx();
    double dy = this.getDy();
    this.setDx(0);
    this.setDy(0);

    final double deltaVelocity =
        Math.min(Math.sqrt(Math.pow(dx, 2) + Math.pow(dy, 2)), acceleration);
    if (deltaVelocity != 0) {
      double newVelocity = this.getVelocity() + deltaVelocity;
      this.setVelocity(newVelocity);
    } else {
      final double newVelocity = Math.max(0, this.getVelocity() - deceleration);
      this.setVelocity(newVelocity);
      dx = GeometricUtilities.getDeltaX(this.moveAngle);
      dy = GeometricUtilities.getDeltaY(this.moveAngle);
    }

    if (this.getVelocity() == 0) {
      this.moveAngle = 0;
      return;
    }

    // actually move entity
    this.moveEntity(dx, dy);
}
}
```
```java
class de.gurkenlabs.litiengine.graphics.animation.AnimationController {
public void detach() {
    Game.loop().detach(this);
}public void attach() {
    Game.loop().attach(this);
}
}
```
```java
class de.gurkenlabs.litiengine.graphics.Camera {
@Override
  public void setZoom(final float targetZoom, final int delay) {
    if (delay == 0) {

      this.zoom = targetZoom;
      this.targetZoom = 0;
      this.zoomDelay = 0;
      this.zoomTick = 0;
      this.zoomStep = 0;

      final ZoomChangedEvent event = new ZoomChangedEvent(this, targetZoom);
      for (final ZoomChangedListener listener : this.zoomListeners) {
        listener.zoomChanged(event);
      }
    } else {
      this.zoomTick = Game.time().now();
      this.targetZoom = targetZoom;
      this.zoomDelay = delay;

      final double tickduration = 1000 / (double) Game.loop().getTickRate();
      final double tickAmount = delay / tickduration;
      final float totalDelta = this.targetZoom - this.zoom;
      this.zoomStep = tickAmount > 0 ? (float) (totalDelta / tickAmount) : totalDelta;
    }
}
}
```
```java
class de.gurkenlabs.litiengine.Game {
public static synchronized void init(String... args) {
    if (initialized) {
      log().log(Level.INFO, "The game has already been initialized.");
      return;
    }

    log.init();
    handleCommandLineArguments(args);

    config().load();
    Locale.setDefault(new Locale(config().client().getCountry(), config().client().getLanguage()));

    gameLoop = new GameLoop("Main Update Loop", config().client().getMaxFps());
    loop().attach(physics());
    loop().attach(world());

    // setup default exception handling for render and update loop
    setUncaughtExceptionHandler(
        new DefaultUncaughtExceptionHandler(config().client().exitOnError()));

    screenManager = new ScreenManager();
    gameWindow = new GameWindow();

    // initialize  the game window
    window().init();
    world.setCamera(new Camera());

    for (GameListener listener : gameListeners) {
      listener.initialized(args);
    }

    if (!isInNoGUIMode()) {
      window().getRenderComponent().onRendered(g -> metrics().render(g));

      graphics()
          .addEntityRenderedListener(
              e -> DebugRenderer.renderEntityDebugInfo(e.getGraphics(), e.getEntity()));

      window().getRenderComponent().onFpsChanged(fps -> metrics().setFramesPerSecond(fps));
      window()
          .setIcons(
              Arrays.asList(
                  Resources.images().get("liti-logo-x16.png"),
                  Resources.images().get("liti-logo-x20.png"),
                  Resources.images().get("liti-logo-x32.png"),
                  Resources.images().get("liti-logo-x48.png")));

      Input.keyboard()
          .onKeyTyped(
              KeyEvent.VK_PRINTSCREEN,
              key -> {
                // don't take a screenshot if a modifier is active
                if (key.getModifiers() != 0) {
                  return;
                }

                window().getRenderComponent().takeScreenshot();
              });
    }

    Runtime.getRuntime().addShutdownHook(new Thread(Game::terminate, "Shutdown"));

    initialized = true;
}
}
```
```java
class de.gurkenlabs.litiengine.entities.Creature {
protected void updateAnimationController() {
    IEntityAnimationController<?> controller = this.createAnimationController();
    this.getControllers().addController(controller);
    if (Game.world().environment() != null && Game.world().environment().isLoaded()) {
      Game.loop().attach(controller);
    }
}@Override
  public float getTickVelocity() {
    // pixels per ms multiplied by the passed ms
    // ensure that entities don't travel too far in case of lag
    return Math.min(Game.loop().getDeltaTime(), GameLoop.TICK_DELTATIME_LAG)
        * 0.001F
        * this.getVelocity().get()
        * Game.loop().getTimeScale();
}
}
```
Depth: 2
```java
class de.gurkenlabs.litiengine.environment.GameWorld {
public void clear() {
    this.unloadEnvironment();
    this.environments.clear();
    this.setCamera(null);
    Game.physics().clear();

    this.environmentListeners.clear();
    this.environmentLoadedListeners.clear();
    this.environmentUnloadedListeners.clear();

    this.listeners.clear();
    this.loadedListeners.clear();
    this.unloadedListeners.clear();
}@Nullable
  public Environment loadEnvironment(IMap map) {
    Environment env = this.getEnvironment(map);
    this.loadEnvironment(env);
    return env;
}@Nullable
  public Environment loadEnvironment(String mapName) {
    Environment env = this.getEnvironment(mapName);
    this.loadEnvironment(env);
    return env;
}
}
```
```java
class de.gurkenlabs.litiengine.GameWindow {
GameWindow() {
    this.hostControl = new JFrame();

    this.resolutionChangedListeners = new CopyOnWriteArrayList<>();

    this.renderCanvas = new RenderComponent(Game.config().graphics().getResolution());
    this.cursor = new MouseCursor();
    if (!Game.isInNoGUIMode()) {
      this.hostControl.setBackground(Color.BLACK);
      this.hostControl.add(this.renderCanvas);

      this.initializeEventListeners();

      this.hostControl.setTitle(Game.info().getTitle());
      this.hostControl.setDefaultCloseOperation(WindowConstants.DO_NOTHING_ON_CLOSE);
      initializeWindowEventListeners(this.hostControl);
    }
}
}
```
```java
class de.gurkenlabs.litiengine.GameTime {
public long sinceEnvironmentLoad() {
    return this.since(this.environmentLoaded);
}public long since(final long tick) {
    return toMilliseconds(Game.loop().getTicks() - tick);
}public long sinceGameStart() {
    return this.toMilliseconds(Game.loop().getTicks());
}
}
```
```java
class de.gurkenlabs.litiengine.abilities.effects.Effect {
protected void cease(final EffectApplication appliance) {
    // 1. cease the effect for all affected entities
    for (final ICombatEntity entity : appliance.getAffectedEntities()) {
      this.cease(entity);
    }

    // 2. apply follow up effects
    this.getFollowUpEffects().forEach(followUp -> followUp.apply(appliance.getImpactArea()));
}protected boolean hasEnded(final EffectApplication appliance) {
    final long effectDuration = Game.time().since(appliance.getAppliedTicks());
    return effectDuration > this.getDuration();
}
}
```
```java
class de.gurkenlabs.litiengine.abilities.effects.EffectApplication {
protected EffectApplication(final List<ICombatEntity> affectedEntities, final Shape impactArea) {
    this.applied = Game.time().now();
    this.affectedEntities = affectedEntities;
    this.impactArea = impactArea;
}
}
```
```java
class de.gurkenlabs.litiengine.entities.CombatEntity {
@Override
  public boolean wasHit(int timeSpan) {
    return Game.time().since(this.lastHit) < timeSpan;
}@Override
  public void hit(final int damage, @Nullable final Ability ability) {
    if (this.isDead()) {
      return;
    }

    if (!this.isIndestructible()) {
      this.getHitPoints().modifyBaseValue(new AttributeModifier<>(Modification.SUBTRACT, damage));
    }

    final EntityHitEvent event = new EntityHitEvent(this, ability, damage, this.isDead());

    for (final CombatEntityListener listener : this.listeners) {
      listener.hit(event);
    }

    for (final CombatEntityHitListener listener : this.hitListeners) {
      listener.hit(event);
    }

    if (this.isDead()) {
      this.fireDeathEvent();
      this.setCollision(false);
    }

    this.lastHit = Game.time().now();
}
}
```
```java
class de.gurkenlabs.litiengine.graphics.ImageEffect {
protected ImageEffect(final int ttl, final String name) {
    this.ttl = ttl;
    this.name = name;
    this.aliveTick = Game.time().now();
}@Override
  public long getAliveTime() {
    return Game.time().since(this.aliveTick);
}
}
```
```java
class de.gurkenlabs.litiengine.abilities.AbilityExecution {
AbilityExecution(final Ability ability) {
    this.appliedEffects = new CopyOnWriteArrayList<>();
    this.ability = ability;
    this.executionTicks = Game.time().now();
    this.impactArea = ability.calculateImpactArea();
    this.castLocation = ability.getExecutor().getCenter();
    Game.loop().attach(this);
}@Override
  public void update() {
    // if there a no effects to apply -> unregister this instance and we're done
    if (this.getAbility().getEffects().isEmpty()
        || this.getAbility().getEffects().size() == this.getAppliedEffects().size()) {
      Game.loop().detach(this);
      return;
    }

    // handle all effects from the ability that were not applied yet
    for (final Effect effect : this.getAbility().getEffects()) {
      // if the ability was not executed yet or the delay of the effect is not
      // yet reached
      if (this.getAppliedEffects().contains(effect)
          || Game.time().since(this.getExecutionTicks()) < effect.getDelay()) {
        continue;
      }

      effect.apply(this.getExecutionImpactArea());
      this.getAppliedEffects().add(effect);
    }
}
}
```
```java
class de.gurkenlabs.litiengine.tweening.TweenEngine {
@Override
  public void update() {
    for (final Tweenable target : this.getTweens().keySet()) {
      for (final Tween tween : this.getTweens().get(target).values()) {
        if (tween.hasStopped()) {
          continue;
        }
        final long elapsed = Game.time().since(tween.getStartTime());
        if (elapsed >= tween.getDuration()) {
          tween.stop();
          continue;
        }
        final float[] currentValues = new float[tween.getTargetValues().length];
        for (int i = 0; i < tween.getTargetValues().length; i++) {
          currentValues[i] =
              tween.getStartValues()[i]
                  + tween.getEquation().compute(elapsed / (float) tween.getDuration())
                      * (tween.getTargetValues()[i] - tween.getStartValues()[i]);
        }
        tween.getTarget().setTweenValues(tween.getType(), currentValues);
      }
    }
}
}
```
```java
class de.gurkenlabs.litiengine.gui.SpeechBubble {
public static SpeechBubble create(
      final IEntity entity, final String text, SpeechBubbleAppearance appearance, Font font) {
    return new SpeechBubble(entity, text, appearance, font);
}public static SpeechBubble create(final IEntity entity, final Font font, final String text) {
    SpeechBubbleAppearance app =
        new SpeechBubbleAppearance(
            DEFAULT_APPEARANCE.getForeColor(),
            DEFAULT_APPEARANCE.getBackgroundColor1(),
            DEFAULT_APPEARANCE.getBorderColor(),
            DEFAULT_APPEARANCE.getPadding());
    return new SpeechBubble(entity, text, app, font);
}public static SpeechBubble create(final IEntity entity, final String text) {
    return new SpeechBubble(entity, text, null, GuiProperties.getDefaultFont());
}@Override
  public void update() {
    if (this.currentText == null) {
      this.hide();
      return;
    }

    this.entityCenter = Game.world().camera().getViewportLocation(this.getEntity().getCenter());

    // old text was displayed long enough
    if (this.lastTextDisplay != 0
        && Game.time().since(this.lastTextDisplay) > this.currentTextDisplayTime) {
      this.currentText = null;
      this.lastTextDisplay = 0;
      return;
    }

    // display new text
    if (this.textIndex < this.currentText.length()
        && Game.time().since(this.lastCharPoll) > LETTER_WRITE_DELAY) {
      this.textIndex++;
      this.lastCharPoll = Game.time().now();
      if (this.typeSound != null) {
        Game.audio().playSound(this.typeSound, this.getEntity());
      }
    }

    // continue displaying currently displayed text
}private SpeechBubble(
      final IEntity entity,
      final String text,
      final Sound typeSound,
      SpeechBubbleAppearance appearance,
      Font font) {
    this(entity, text, appearance, font);
    this.typeSound = typeSound;
}private SpeechBubble(
      final IEntity entity,
      final String text,
      @Nullable SpeechBubbleAppearance appearance,
      @Nullable Font font) {
    if (appearance == null) {
      this.appearance = DEFAULT_APPEARANCE;
    } else {
      this.appearance = appearance;
    }

    final SpeechBubble active = activeSpeechBubbles.get(entity);
    if (active != null) {
      active.hide();
    }
    this.setFont(font);

    this.textBoxWidth = (float) (entity.getWidth() * 4);
    this.entity = entity;

    this.currentText = text;
    this.currentTextDisplayTime = DISPLAYTIME_MIN + text.length() * DISPLAYTIME_PER_LETTER;

    this.lastTextDisplay = Game.time().now();
    this.createBubbleImage();
    entity.getEnvironment().add(this, RenderType.UI);
    Game.loop().attach(this);
    activeSpeechBubbles.put(entity, this);
}
}
```
```java
class de.gurkenlabs.litiengine.gui.TextFieldComponent {
@Override
  public void render(final Graphics2D g) {
    super.render(g);
    g.setFont(this.getFont());
    final FontMetrics fm = g.getFontMetrics();

    if (this.isSelected() && Game.time().since(this.lastToggled) > this.flickerDelay) {
      this.cursorVisible = !this.cursorVisible;
      this.lastToggled = Game.time().now();
    }
    if (this.isSelected() && this.cursorVisible) {
      final Rectangle2D cursor =
          new Rectangle2D.Double(
              this.getX() + this.getTextX() + fm.stringWidth(this.getTextToRender(g)),
              this.getY() + this.getTextY(),
              this.getFont().getSize2D() * 3 / 5,
              this.getFont().getSize2D() * 1 / 5);
      g.setColor(this.getAppearance().getForeColor());
      g.fill(cursor);
    }
}
}
```
```java
class de.gurkenlabs.litiengine.entities.Prop {
public Prop(
      final Point2D location, @Nullable final String spritesheetName, final Material material) {
    super();
    this.rotation = Rotation.NONE;
    this.spritesheetName = spritesheetName;
    this.material = material;
    this.setLocation(location);
    this.updateAnimationController();
}public void setSpritesheetName(@Nullable final String spriteName) {
    this.spritesheetName = spriteName;
    this.updateAnimationController();
}
}
```
```java
class de.gurkenlabs.litiengine.tweening.Tween {
public Tween begin() {
    this.started = Game.time().now();
    this.stopped = false;
    return this;
}
}
```
```java
class de.gurkenlabs.litiengine.graphics.emitters.particles.Particle {
public void update(final Point2D emitterOrigin, final float updateRatio) {
    if (this.aliveTick == 0) {
      this.aliveTick = Game.time().now();
    }

    this.aliveTime = Game.time().since(this.aliveTick);
    if (this.timeToLiveReached()) {
      return;
    }

    if (this.colliding) {
      return;
    }

    if (this.getDeltaWidth() != 0) {
      this.width += this.getDeltaWidth() * updateRatio;
    }

    if (this.getDeltaHeight() != 0) {
      this.height += this.getDeltaHeight() * updateRatio;
    }

    if (this.getDeltaAngle() != 0) {
      this.angle += this.getDeltaAngle() * updateRatio;
    }

    // test for ray cast collision
    final float targetX = this.x + this.getVelocityX() * updateRatio;
    final float targetY = this.y + this.getVelocityY() * updateRatio;

    if (targetX == this.x && targetY == this.y) {
      return;
    }

    if (this.checkForCollision(emitterOrigin, targetX, targetY)) {
      return;
    }

    if (this.getVelocityX() != 0) {
      this.x = targetX;
    }

    if (this.getVelocityY() != 0) {
      this.y = targetY;
    }

    if (this.getAccelerationX() != 0) {
      this.velocityX += this.getAccelerationX() * updateRatio;
    }

    if (this.getAccelerationY() != 0) {
      this.velocityY += this.getAccelerationY() * updateRatio;
    }
}
}
```
```java
class de.gurkenlabs.litiengine.graphics.animation.Animation {
@Override
  public void start() {
    this.playing = true;
    if (this.getKeyframes().isEmpty()) {
      return;
    }

    this.restart();
}@Override
  public void update() {
    // do nothing if the animation is not playing or the current keyframe is not finished
    if (!this.isPlaying()
        || Game.time().since(this.lastFrameUpdate) < this.getCurrentKeyFrame().getDuration()) {
      return;
    }

    // if we are not looping and the last keyframe is finished, we terminate the animation
    if (!this.isLooping() && this.isLastKeyFrame()) {
      this.terminate();
      return;
    }

    // make sure, we stay inside the keyframe list
    final int newFrameIndex =
        (this.getKeyframes().indexOf(this.currentFrame) + 1) % this.getKeyframes().size();
    final KeyFrame previousFrame = this.currentFrame;
    this.currentFrame = this.getKeyframes().get(newFrameIndex);

    for (KeyFrameListener listener : this.listeners) {
      listener.currentFrameChanged(previousFrame, this.currentFrame);
    }

    this.lastFrameUpdate = Game.loop().getTicks();
}
}
```
```java
class de.gurkenlabs.litiengine.graphics.animation.AnimationController {
@Override
  public void update() {
    for (final Animation animation : this.getAll()) {
      animation.update();
    }

    if (this.getCurrent() != null && this.getCurrent().isPaused()) {
      return;
    }

    final boolean playbackFinished = this.getCurrent() != null && !this.getCurrent().isPlaying();
    if (playbackFinished) {
      for (final AnimationListener listener : this.listeners) {
        listener.finished(this.getCurrent());
      }
    }

    if (this.getCurrent() == null || playbackFinished) {
      if (this.getDefault() != null) {
        this.play(this.getDefault().getName());
      } else {
        this.currentAnimation = null;
      }
    }
}
}
```
```java
class de.gurkenlabs.litiengine.graphics.RenderComponent {
private void handleFade() {
    if (this.fadeOutStart != -1) {
      final long timePassed = Game.time().since(this.fadeOutStart);
      this.currentAlpha = MathUtilities.clamp(1 - timePassed / (float) this.fadeOutTime, 0, 1);
      if (this.currentAlpha == 0f) {
        this.fadeOutStart = -1;
        this.fadeOutTime = -1;
      }

      return;
    }

    if (this.fadeInStart != -1) {
      final long timePassed = Game.time().since(this.fadeInStart);
      this.currentAlpha = MathUtilities.clamp(timePassed / (float) this.fadeInTime, 0, 1);
      if (this.currentAlpha == 1f) {
        this.fadeInStart = -1;
        this.fadeInTime = -1;
        this.currentAlpha = Float.NaN;
      }
    }
}public void fadeOut(final int ms) {
    this.fadeInStart = -1;
    this.fadeInTime = -1;
    this.fadeOutStart = Game.time().now();
    this.fadeOutTime = ms;
}public void fadeIn(final int ms) {
    this.fadeOutStart = -1;
    this.fadeOutTime = -1;
    this.fadeInStart = Game.time().now();
    this.fadeInTime = ms;
}
}
```
```java
class de.gurkenlabs.litiengine.entities.Trigger {
private boolean activate(final IEntity activator, final int tar) {
    if (!this.isLoaded()
        || this.isOneTimeTrigger && this.isActivated
        || this.getActivationType() == TriggerActivation.COLLISION
            && activator != null
            && this.collisionActivated.contains(activator)) {
      return false;
    }

    if (this.getCooldown() > 0 && Game.time().since(this.lastActivation) < this.getCooldown()) {
      return false;
    }

    List<Integer> triggerTargets = this.getTargets(tar);

    final TriggerEvent te = new TriggerEvent(this, activator, triggerTargets);

    if (!this.checkActivationPredicates(te)) {
      return false;
    }

    this.isActivated = true;
    if (activator != null) {
      this.collisionActivated.add(activator);
    }

    // if we actually have a trigger target, we send the message to the target
    for (final int target : triggerTargets) {
      final IEntity entity = this.getEnvironment().get(target);
      if (entity == null) {
        log.log(
            Level.WARNING,
            "trigger [{0}] was activated, but the trigger target [{1}] could not be found on the environment",
            new Object[] {this, target});
        continue;
      }

      entity.sendMessage(this, this.message);
    }

    // also send the trigger event to all registered consumers
    for (final TriggerActivatedListener listener : this.activatedListeners) {
      listener.activated(te);
    }

    if (this.isOneTimeTrigger) {
      this.getEnvironment().remove(this);
    }

    this.lastActivation = Game.time().now();
    return true;
}
}
```
```java
class de.gurkenlabs.litiengine.graphics.Camera {
private boolean isShakeEffectActive() {
    return this.getShakeTick() != 0
        && Game.time().since(this.getShakeTick()) < this.getShakeDuration();
}@Override
  public void update() {
    if (Game.world().camera() != null && !Game.world().camera().equals(this)) {
      return;
    }

    if (this.targetZoom > 0) {
      if (Game.time().since(this.zoomTick) >= this.zoomDelay) {
        this.zoom = this.targetZoom;
        this.targetZoom = 0;
        this.zoomDelay = 0;
        this.zoomTick = 0;
        this.zoomStep = 0;
      } else {
        this.zoom += this.zoomStep;
      }

      final ZoomChangedEvent event = new ZoomChangedEvent(this, this.getZoom());
      for (final ZoomChangedListener listener : this.zoomListeners) {
        listener.zoomChanged(event);
      }
    }

    if (this.panTime > 0) {
      if (--this.panTime <= 0) {
        this.setFocus(this.targetFocus);
        this.targetFocus = null;
      } else {
        double diff = this.panTime / (this.panTime + 1.0);
        this.focus =
            new Point2D.Double(
                this.focus.getX() * diff + this.targetFocus.getX() * (1.0 - diff),
                this.focus.getY() * diff + this.targetFocus.getY() * (1.0 - diff));
      }
    }

    if (!this.isShakeEffectActive()) {
      this.shakeOffsetX = 0;
      this.shakeOffsetY = 0;
      return;
    }

    if (Game.time().since(this.lastShake) > this.shakeDelay) {
      this.shakeOffsetX = this.getShakeIntensity() * ThreadLocalRandom.current().nextGaussian();
      this.shakeOffsetY = this.getShakeIntensity() * ThreadLocalRandom.current().nextGaussian();
      this.lastShake = Game.time().now();
    }
}@Override
  public void setZoom(final float targetZoom, final int delay) {
    if (delay == 0) {

      this.zoom = targetZoom;
      this.targetZoom = 0;
      this.zoomDelay = 0;
      this.zoomTick = 0;
      this.zoomStep = 0;

      final ZoomChangedEvent event = new ZoomChangedEvent(this, targetZoom);
      for (final ZoomChangedListener listener : this.zoomListeners) {
        listener.zoomChanged(event);
      }
    } else {
      this.zoomTick = Game.time().now();
      this.targetZoom = targetZoom;
      this.zoomDelay = delay;

      final double tickduration = 1000 / (double) Game.loop().getTickRate();
      final double tickAmount = delay / tickduration;
      final float totalDelta = this.targetZoom - this.zoom;
      this.zoomStep = tickAmount > 0 ? (float) (totalDelta / tickAmount) : totalDelta;
    }
}@Override
  public void shake(final double intensity, final int delay, final int shakeDuration) {
    this.shakeTick = Game.time().now();
    this.shakeDelay = delay;
    this.shakeIntensity = intensity;
    this.shakeDuration = shakeDuration;
}
}
```
```java
class de.gurkenlabs.litiengine.entities.Creature {
public void setSpritesheetName(String spritesheetName) {
    if (this.spritesheetName != null && this.spritesheetName.equals(spritesheetName)) {
      return;
    }

    this.spritesheetName = spritesheetName;
    this.updateAnimationController();
}public boolean isIdle() {
    return Game.time().since(this.lastMoved) > IDLE_DELAY;
}@Override
  public void setLocation(final Point2D position) {
    if (this.isDead() || position == null) {
      return;
    }

    final Point2D oldLocation = this.getLocation();
    super.setLocation(position);

    if (Game.hasStarted() && this.isLoaded()) {
      this.lastMoved = Game.time().now();
      this.fireMovedEvent(
          new EntityMovedEvent(
              this, this.getX() - oldLocation.getX(), this.getY() - oldLocation.getY()));
    }
}
}
```
```java
class de.gurkenlabs.litiengine.gui.screens.ScreenManager {
public void display(final String screenName) {
    if (this.current() != null && this.current().getName().equalsIgnoreCase(screenName)) {
      log.log(
          Level.INFO,
          "Skipping displaying of screen {0} because it is already the current screen.",
          screenName);
      return;
    }

    if (this.screens.stream()
        .noneMatch(element -> element.getName().equalsIgnoreCase(screenName))) {
      log.log(
          Level.WARNING,
          "Could not display the screen {0} because there is no screen with the specified name.",
          screenName);
      return;
    }

    Screen screen = this.get(screenName);
    if (screen == null) {
      return;
    }

    this.display(screen);
}public void add(final Screen screen) {
    screen.setWidth(Game.window().getWidth());
    screen.setHeight(Game.window().getHeight());
    this.screens.add(screen);

    if (this.current() == null) {
      this.display(screen);
    }
}public void remove(Screen screen) {
    this.screens.remove(screen);
    if (this.current() == screen) {
      if (!this.screens.isEmpty()) {
        this.display(this.screens.get(0));
      } else {
        this.display((Screen) null);
      }
    }
}public void display(@Nullable final Screen screen) {
    if (Game.hasStarted() && Game.time().since(this.lastScreenChange) < this.getChangeCooldown()) {
      log.log(
          Level.INFO,
          "Skipping displaying of screen {0} because screen changing is currently on cooldown.",
          screen != null ? screen.getName() : "");
      return;
    }

    final Screen previous = this.current();
    if (previous != null) {
      previous.suspend();
    }

    if (screen != null && !this.screens.contains(screen)) {
      this.screens.add(screen);
    }

    this.currentScreen = screen;
    if (!Game.isInNoGUIMode() && this.current() != null) {
      this.current().prepare();
    }

    this.lastScreenChange = Game.loop().getTicks();

    final ScreenChangedEvent event = new ScreenChangedEvent(this.current(), previous);
    for (final ScreenChangedListener listener : this.screenChangedListeners) {
      listener.changed(event);
    }
}
}
```
```java
class de.gurkenlabs.litiengine.abilities.Ability {
public boolean isOnCooldown() {
    return (this.getCurrentExecution() != null
        && this.getCurrentExecution().getExecutionTicks() > 0
        && Game.time().since(this.getCurrentExecution().getExecutionTicks())
            < this.getAttributes().cooldown().get());
}public boolean isActive() {
    return this.getCurrentExecution() != null
        && Game.time().since(this.getCurrentExecution().getExecutionTicks())
            < this.getAttributes().duration().get();
}@Nullable
  public AbilityExecution cast() {
    if (!this.canCast()) {
      return null;
    }
    this.currentExecution = new AbilityExecution(this);

    for (final AbilityCastListener listener : this.abilityCastListeners) {
      listener.abilityCast(this.currentExecution);
    }

    return this.getCurrentExecution();
}public float getRemainingCooldownInSeconds() {
    if (this.getCurrentExecution() == null
        || this.getExecutor() == null
        || this.getExecutor().isDead()) {
      return 0;
    }

    // calculate cooldown in seconds
    return (float)
        (!this.canCast()
            ? (this.getAttributes().cooldown().get()
                    - Game.time().since(this.getCurrentExecution().getExecutionTicks()))
                * 0.001
            : 0);
}
}
```
```java
class de.gurkenlabs.litiengine.entities.EntityHitEvent {
EntityHitEvent(
      final ICombatEntity hitEntity,
      @Nullable final Ability ability,
      final int damage,
      final boolean kill) {
    super(hitEntity);
    this.executor = ability != null ? ability.getExecutor() : null;
    this.hitEntity = hitEntity;
    this.ability = ability;
    this.damage = damage;
    this.kill = kill;
    this.time = Game.time().now();
}
}
```
```java
class de.gurkenlabs.litiengine.graphics.emitters.Emitter {
public void delete() {
    this.deactivate();
    if (Game.world().environment() != null) {
      Game.world().environment().remove(this);
    }
}public void activate() {
    if (this.activated) {
      return;
    }

    this.activated = true;
    this.activationTick = Game.time().now();
    Game.loop().attach(this);
}@Override
  public void update() {
    if (this.isPaused()) {
      return;
    }

    // clear particles if the effect time to life is reached
    if (this.isFinished()) {
      for (EmitterFinishedListener listener : this.finishedListeners) {
        listener.finished(this);
      }

      this.delete();
      return;
    }

    final float updateRatio = (float) this.data().getUpdateRate() / Game.loop().getTickRate();
    for (final Particle p : this.getParticles().stream().collect(Collectors.toList())) {
      if (this.particleCanBeRemoved(p)) {
        // remove dead particles
        this.particles.remove(p);
        continue;
      }

      p.update(this.getOrigin(), updateRatio);
    }

    this.aliveTime = Game.time().since(this.activationTick);
    if ((this.data().getSpawnRate() == 0
        || Game.time().since(this.lastSpawn) >= this.data().getSpawnRate())) {
      this.lastSpawn = Game.time().now();
      this.spawnParticle();
    }
}
}
```
```java
class de.gurkenlabs.litiengine.GameLoop {
@Override
  public int perform(int delay, Runnable action) {
    final long d = Game.time().toTicks(delay);

    TimedAction a = new TimedAction(this.getTicks() + d, action);
    this.actions.add(a);

    return a.getId();
}
}
```
```java
class de.gurkenlabs.litiengine.environment.EntitySpawner {
protected boolean shouldSpawn() {
    return this.lastSpawnWave == 0
        || Game.time().since(this.lastSpawnWave) >= this.getSpawnInterval();
}@Override
  public void update() {
    if (!this.shouldSpawn()) {
      return;
    }

    this.spawnNewEntities();
    this.lastSpawnWave = Game.time().now();
}
}
```
```java
class de.gurkenlabs.litiengine.graphics.FreeFlightCamera {
@Override
  public void update() {
    this.handleFreeFlightCamera();
}public FreeFlightCamera(double x, double y) {
    this(new Point2D.Double(x, y));
}
}
```
```java
class de.gurkenlabs.litiengine.environment.Environment {
public void unload() {
    if (!this.loaded) {
      return;
    }

    // unregister all updatable entities from the current environment
    for (final IEntity entity : this.allEntities.values()) {
      this.unload(entity);
    }

    this.loaded = false;
    this.fireEvent(l -> l.unloaded(this));
}private static void loadUpdatableOrEmitterEntity(IEntity entity) {
    if (entity instanceof Emitter) {
      final Emitter emitter = (Emitter) entity;
      if (emitter.isActivateOnInit()) {
        emitter.activate();
      }
    } else if (entity instanceof IUpdateable) {
      Game.loop().attach((IUpdateable) entity);
    }
}public void clear() {
    Game.physics().clear();

    this.combatEntities.clear();
    this.mobileEntities.clear();
    this.gravityForces.clear();
    this.layerEntities.clear();
    this.entitiesByTag.clear();
    this.allEntities.clear();

    for (RenderType renderType : RenderType.values()) {
      this.miscEntities.get(renderType).clear();
      this.renderListeners.get(renderType).clear();
      this.renderables.get(renderType).clear();
    }

    dispose(this.allEntities.values());
    dispose(this.triggers);
    this.emitters.clear();
    this.colliders.clear();
    this.props.clear();
    this.creatures.clear();
    this.staticShadows.clear();
    this.combatEntities.clear();
    this.mobileEntities.clear();
    this.lightSources.clear();
    this.spawnPoints.clear();
    this.soundSources.clear();
    this.mapAreas.clear();
    this.triggers.clear();

    this.ambientLight = null;
    this.staticShadowLayer = null;

    for (Map<Integer, IEntity> type : this.miscEntities.values()) {
      type.clear();
    }

    this.initialized = false;

    this.fireEvent(l -> l.cleared(this));
}private void load(final IEntity entity) {
    // an entity can only exist on one environment at a time, so remove it from the current one
    if (entity.getEnvironment() != null) {
      entity.getEnvironment().remove(entity);
    }

    // 1. add to physics engine
    loadPhysicsEntity(entity);

    // 2. register for update or activate
    loadUpdatableOrEmitterEntity(entity);

    // 3. if a gravity is defined, add a gravity force to the entity
    if (entity instanceof IMobileEntity && this.getGravity() != 0) {
      this.addGravityForce((IMobileEntity) entity);
    }

    // 4. attach all controllers
    entity.attachControllers();

    if (this.loaded && (entity instanceof LightSource || entity instanceof StaticShadow)) {
      this.updateLighting(entity);
    }

    entity.loaded(this);
}private void unload(final IEntity entity) {
    // 1. remove from physics engine
    if (entity instanceof ICollisionEntity) {
      Game.physics().remove((ICollisionEntity) entity);
    }

    // 2. unregister from update
    if (entity instanceof IUpdateable) {
      Game.loop().detach((IUpdateable) entity);
    }

    if (entity instanceof IMobileEntity) {
      this.removeGravity((IMobileEntity) entity);
    }

    // 3. detach all controllers
    entity.detachControllers();

    if (entity instanceof Emitter) {
      Emitter em = (Emitter) entity;
      em.deactivate();
    }

    if (this.loaded && (entity instanceof LightSource || entity instanceof StaticShadow)) {
      this.updateLighting(entity);
    }

    entity.removed(this);
}public void remove(final IEntity entity) {
    if (entity == null) {
      return;
    }

    this.allEntities.remove(entity.getMapId());
    Iterator<List<IEntity>> iter = this.layerEntities.values().iterator();
    while (iter.hasNext()) {
      List<IEntity> layer = iter.next();
      if (layer.remove(entity) && layer.isEmpty()) {
        iter.remove();
      }
    }
    if (this.miscEntities.get(entity.getRenderType()) != null) {
      this.miscEntities.get(entity.getRenderType()).values().remove(entity);
    }

    for (String tag : entity.getTags()) {
      if (this.getEntitiesByTag().containsKey(tag)) {
        this.getEntitiesByTag().get(tag).remove(entity);

        if (this.getEntitiesByTag().get(tag).isEmpty()) {
          this.getEntitiesByTag().remove(tag);
        }
      }
    }

    if (entity instanceof Emitter) {
      Emitter emitter = (Emitter) entity;
      this.removeEmitter(emitter);
    }

    if (entity instanceof MapArea) {
      this.mapAreas.remove(entity);
    }

    if (entity instanceof Prop) {
      this.props.remove(entity);
    }

    if (entity instanceof Creature) {
      this.creatures.remove(entity);
    }

    if (entity instanceof CollisionBox) {
      this.colliders.remove(entity);
      this.staticShadows.removeIf(x -> x.getOrigin() != null && x.getOrigin().equals(entity));
    }

    if (entity instanceof LightSource) {
      this.lightSources.remove(entity);
      this.updateLighting(entity);
    }

    if (entity instanceof Trigger) {
      this.triggers.remove(entity);
    }

    if (entity instanceof Spawnpoint) {
      this.spawnPoints.remove(entity);
    }
    if (entity instanceof SoundSource) {
      this.soundSources.remove(entity);
    }

    if (entity instanceof StaticShadow) {
      this.staticShadows.remove(entity);
      this.updateLighting(entity);
    }

    if (entity instanceof IMobileEntity) {
      this.mobileEntities.values().remove(entity);
    }

    if (entity instanceof ICombatEntity) {
      this.combatEntities.values().remove(entity);
    }

    this.unload(entity);

    this.fireEntityEvent(l -> l.entityRemoved(entity));
}
}
```
```java
class de.gurkenlabs.litiengine.physics.MovementController {
@Override
  public void update() {
    this.handleForces();
    this.handleMovement();
}
}
```
```java
class de.gurkenlabs.litiengine.Game {
static synchronized void terminate() {
    if (!initialized) {
      return;
    }

    hasStarted = false;
    initialized = false;

    config().save();
    gameLoop.terminate();
    tweenEngine.terminate();
    soundEngine.terminate();

    world().clear();

    for (final GameListener listener : gameListeners) {
      try {
        listener.terminated();
      } catch (Exception e) {
        log().log(Level.WARNING, "game listener threw an exception during shutdown", e);
      }
    }

    gameLoop = null;
    screenManager = null;
    gameWindow = null;
}public static synchronized void start() {
    if (!initialized) {
      throw new IllegalStateException(
          "The game cannot be started without being first initialized. Call Game.init(...) before Game.start().");
    }

    gameLoop.start();
    tweenEngine.start();
    soundEngine.start();

    for (final GameListener listener : gameListeners) {
      listener.started();
    }

    hasStarted = true;
}public static synchronized void init(String... args) {
    if (initialized) {
      log().log(Level.INFO, "The game has already been initialized.");
      return;
    }

    log.init();
    handleCommandLineArguments(args);

    config().load();
    Locale.setDefault(new Locale(config().client().getCountry(), config().client().getLanguage()));

    gameLoop = new GameLoop("Main Update Loop", config().client().getMaxFps());
    loop().attach(physics());
    loop().attach(world());

    // setup default exception handling for render and update loop
    setUncaughtExceptionHandler(
        new DefaultUncaughtExceptionHandler(config().client().exitOnError()));

    screenManager = new ScreenManager();
    gameWindow = new GameWindow();

    // initialize  the game window
    window().init();
    world.setCamera(new Camera());

    for (GameListener listener : gameListeners) {
      listener.initialized(args);
    }

    if (!isInNoGUIMode()) {
      window().getRenderComponent().onRendered(g -> metrics().render(g));

      graphics()
          .addEntityRenderedListener(
              e -> DebugRenderer.renderEntityDebugInfo(e.getGraphics(), e.getEntity()));

      window().getRenderComponent().onFpsChanged(fps -> metrics().setFramesPerSecond(fps));
      window()
          .setIcons(
              Arrays.asList(
                  Resources.images().get("liti-logo-x16.png"),
                  Resources.images().get("liti-logo-x20.png"),
                  Resources.images().get("liti-logo-x32.png"),
                  Resources.images().get("liti-logo-x48.png")));

      Input.keyboard()
          .onKeyTyped(
              KeyEvent.VK_PRINTSCREEN,
              key -> {
                // don't take a screenshot if a modifier is active
                if (key.getModifiers() != 0) {
                  return;
                }

                window().getRenderComponent().takeScreenshot();
              });
    }

    Runtime.getRuntime().addShutdownHook(new Thread(Game::terminate, "Shutdown"));

    initialized = true;
}
}
```


Response Format:
Provide the answer in **XML format** as follows:

#### If the method **cannot** return `null` at the specific call site:
```xml
<response>
  <reason><![CDATA[EXPLAIN WHY THE INVOCATION Game.loop() RESULT CANNOT BE NULL.]]></reason>
  <value>NO</value>
</response>

#### If the method can return null at the specific call site:
<response>
  <reason><![CDATA[EXPLAIN WHY THE INVOCATION Game.loop() RESULT CAN BE NULL.]]></reason>
  <value>YES</value>
</response>

#### If you are unsure or If there are any methods that directly or indirectly affect the return value and are not fully disclosed, request their declarations first, in the following format:
<response>
  <reason><![CDATA[EXPLAIN WHY THIS METHOD DECLARATION IS NECESSARY AND WHY YOU CANNOT MAKE A CONFIDENT DECISION WITHOUT IT]]></reason>
  <success>false</success>
  <methods>
    <method>methodName</method>
  </methods>
</response>

Additional Notes:
Be precise in your reasoning.
If a method’s return value depends on another method not provided, request its declaration before making a conclusion.
If the method can return null in this case but not in others, explain why it happens specifically for this call.

---ChatGPT.sendRequestToOpenAI---
Retrieving response from cache
---Response.<init>---
Creating Response:
```xml
<response>
  <reason><![CDATA[The method `Game.loop()` returns the static field `gameLoop`, which is initialized in the `Game.init(String... args)` method. In this method, a new `GameLoop` object is instantiated and assigned to `gameLoop`. Since `init()` must be called before `start()`, which is implied by the requirement of initializing the game, the `gameLoop` is guaranteed to be non-null during the lifetime of the game execution where `Game.loop()` is called. The absence of any code that could set `gameLoop` to null after its initialization ensures that `Game.loop()` cannot return null.]]></reason>
  <value>NO</value>
</response>
```
---Response.<init>---
Response created:
Disagreement: The method `Game.loop()` returns the static field `gameLoop`, which is initialized in the `Game.init(String... args)` method. In this method, a new `GameLoop` object is instantiated and assigned to `gameLoop`. Since `init()` must be called before `start()`, which is implied by the requirement of initializing the game, the `gameLoop` is guaranteed to be non-null during the lifetime of the game execution where `Game.loop()` is called. The absence of any code that could set `gameLoop` to null after its initialization ensures that `Game.loop()` cannot return null.
---AdvancedNullAwayCodeFix.resolveMethodDereferenceError---
Method is not returning nullable on call site. Injecting suppression annotation.
---AdvancedNullAwayCodeFix.constructCastToNonnullChange---
Constructing cast to nonnull change for reason: The method `Game.loop()` returns the static field `gameLoop`, which is initialized in the `Game.init(String... args)` method. In this method, a new `GameLoop` object is instantiated and assigned to `gameLoop`. Since `init()` must be called before `start()`, which is implied by the requirement of initializing the game, the `gameLoop` is guaranteed to be non-null during the lifetime of the game execution where `Game.loop()` is called. The absence of any code that could set `gameLoop` to null after its initialization ensures that `Game.loop()` cannot return null.
---ChatGPT.ask---
Asking ChatGPT:
For the reason you mentioned earlier:

"The method `Game.loop()` returns the static field `gameLoop`, which is initialized in the `Game.init(String... args)` method. In this method, a new `GameLoop` object is instantiated and assigned to `gameLoop`. Since `init()` must be called before `start()`, which is implied by the requirement of initializing the game, the `gameLoop` is guaranteed to be non-null during the lifetime of the game execution where `Game.loop()` is called. The absence of any code that could set `gameLoop` to null after its initialization ensures that `Game.loop()` cannot return null."

in the method below, the expression Game.loop() is not nullable at the point it is used.

```java
private static void loadUpdatableOrEmitterEntity(IEntity entity) {
    if (entity instanceof Emitter) {
      final Emitter emitter = (Emitter) entity;
      if (emitter.isActivateOnInit()) {
        emitter.activate();
      }
    } else if (entity instanceof IUpdateable) {
      Game.loop().attach((IUpdateable) entity);
    }
}
```
Please Summarize the reason in max 5 words and rewrite the method so that at the line "      Game.loop().attach((IUpdateable) entity);", at the occurrence of: "Game.loop()" is replaced with `NullabilityUtil.castToNonnull(Game.loop(), summary of reason)`
Replace "REASON" with the exact reason summary I provide to you (maximum 5 words), not with a generic explanation like "checked to be nonnull".
see the example below, for expression `foo.getBar()`, to wrap it with `NullabilityUtil.castToNonnull(foo.getBar(), "reason")`.

```java
public t(){
    String l = foo.getBar();
}
```

will be:
```java
public t(){
    String l = NullabilityUtil.castToNonnull(foo.getBar(), "checked to be nonnull");
}
```

### Instructions:

Do not import any additional classes.

Do not add Java comments.

Only modify relevant lines as required.

Return only the modified method wrapped in the XML format shown below.

Place the Java code inside the <code> tag using a CDATA block with ```java formatting.

Just give me the fixed code snippet in XML format in <response> tag like the example below. I will apply the fix to my codebase. Do not import any additional libraries or classes or add java comments. If you can provide the fixed code snippet, please provide it in the following format and place the code snippet in the <code> tag within ```java block.
<response>
  <success>true</success>
  <code><![CDATA[
  ```java
  Your fixed code snippet here
  ```
    ]]>
  </code>
</response>

---ChatGPT.sendRequestToOpenAI---
Retrieving response from cache
---Response.<init>---
Creating Response:
<response>
  <success>true</success>
  <code><![CDATA[
  ```java
private static void loadUpdatableOrEmitterEntity(IEntity entity) {
    if (entity instanceof Emitter) {
      final Emitter emitter = (Emitter) entity;
      if (emitter.isActivateOnInit()) {
        emitter.activate();
      }
    } else if (entity instanceof IUpdateable) {
      NullabilityUtil.castToNonnull(Game.loop(), "init ensures non-null").attach((IUpdateable) entity);
    }
}
  ```
    ]]>
  </code>
</response>
---Response.<init>---
Response created:
private static void loadUpdatableOrEmitterEntity(IEntity entity) {
    if (entity instanceof Emitter) {
      final Emitter emitter = (Emitter) entity;
      if (emitter.isActivateOnInit()) {
        emitter.activate();
      }
    } else if (entity instanceof IUpdateable) {
      NullabilityUtil.castToNonnull(Game.loop(), "init ensures non-null").attach((IUpdateable) entity);
    }
}
---ChatGPT.fixDereferenceByAddingCastToNonnull---
Fixing the error by adding castToNonnull
---AdvancedNullAwayCodeFix.fixTriggeredErrorsForLocation---
Resolving unresolvable error for triggered error: Type='DEREFERENCE_NULLABLE', message='dereferenced expression Game.loop() is @Nullable'
/home/nima/Developer/nullness-benchmarks/litiengine/src/de/gurkenlabs/litiengine/graphics/FreeFlightCamera.java:74
            / (double) Game.loop().getTickRate()
---AdvancedNullAwayCodeFix.fix---
Fixing error: Type='DEREFERENCE_NULLABLE', message='dereferenced expression Game.loop() is @Nullable'
/home/nima/Developer/nullness-benchmarks/litiengine/src/de/gurkenlabs/litiengine/graphics/FreeFlightCamera.java:74
            / (double) Game.loop().getTickRate()
---AdvancedNullAwayCodeFix.resolveDereferenceError---
Resolving dereference error: Type='DEREFERENCE_NULLABLE', message='dereferenced expression Game.loop() is @Nullable'
/home/nima/Developer/nullness-benchmarks/litiengine/src/de/gurkenlabs/litiengine/graphics/FreeFlightCamera.java:74
            / (double) Game.loop().getTickRate()
---AdvancedNullAwayCodeFix.resolveDereferenceError---
Checking nullability possibility at error point
---ChatGPT.checkNullabilityPossibilityAtErrorPoint---
Asking if the expression can be null at error point point
---ChatGPT.ask---
Asking ChatGPT:
In the method below, is there a possibility that the expression "Game.loop()" at line "/ (double) Game.loop().getTickRate()" is null?
private void handleFreeFlightCamera() {
    if (Game.world().environment() == null || Game.world().environment().getMap() == null) {
      return;
    }

    final Point2D mouseLocation = Input.mouse().getLocation();

    final double scrollSpeed =
        this.getVelocity()
            / (double) Game.loop().getTickRate()
            * Game.config().input().getMouseSensitivity();

    double x = this.getFocus().getX();
    double y = this.getFocus().getY();

    double deltaX = 0;
    if (mouseLocation.getX() < this.getScrollPadding()) {
      deltaX -= scrollSpeed;
    } else if (Game.window().getResolution().getWidth() - mouseLocation.getX()
        < this.getScrollPadding()) {
      deltaX += scrollSpeed;
    }

    double deltaY = 0;
    if (mouseLocation.getY() < this.getScrollPadding()) {
      deltaY -= scrollSpeed;
    } else if (Game.window().getResolution().getHeight() - mouseLocation.getY()
        < this.getScrollPadding()) {
      deltaY += scrollSpeed;
    }

    x += deltaX;
    y += deltaY;

    this.setFocus(new Point2D.Double(x, y));
}
Give a single-word answer in XML format. If it is possible for the expression to be null, respond with:
```xml
<response>
    <reason><![CDATA[YOUR REASON]]></reason>
    <value>YES</value>
</response>
```
If it is not possible for the expression to be null, respond with:
```xml
<response>
    <reason><![CDATA[YOUR REASON]]></reason>
    <value>NO</value>
</response>
```
If you are unsure or need more information, respond with where you can ask for more details or what specific information you need.

If additional information is required, list each request inside a `<request>` tag. If no additional information is needed, omit the `<requests>` section.

Respond with:
```xml
<response>
    <reason><![CDATA[YOUR REASON]]></reason>
    <value>UNKNOWN</value>
    <!-- Include <requests> only if additional information is needed -->
    <requests>
        <request><![CDATA[YOUR REQUEST 1]]></request>
        <request><![CDATA[YOUR REQUEST 2]]></request>
    </requests>
</response>
```
---ChatGPT.sendRequestToOpenAI---
Retrieving response from cache
---Response.<init>---
Creating Response:
```xml
<response>
    <reason><![CDATA[Without additional information on the implementation details of Game.loop(), it is not possible to definitively determine if it can return null.]]></reason>
    <value>UNKNOWN</value>
    <requests>
        <request><![CDATA[Details on the implementation of Game.loop() and whether it can return null.]]></request>
        <request><![CDATA[Information on how Game.loop() is initialized and used throughout the application.]]></request>
    </requests>
</response>
```
---Response.<init>---
Response created:
Unknown: Without additional information on the implementation details of Game.loop(), it is not possible to definitively determine if it can return null.
---AdvancedNullAwayCodeFix.resolveMethodDereferenceError---
Resolving method dereference error.
---AdvancedNullAwayCodeFix.resolveMethodDereferenceError---
Method is in annotated package. Checking if the method is returning nullable.
---AdvancedNullAwayCodeFix.investigateMethodReturnNullability---
Checking if the method is returning nullable.
---ChatGPT.checkIfMethodIsReturningNullable---
Asking if the method is returning nullable: loop()
---ChatGPT.ask---
Asking ChatGPT:
In the method below, is there a possibility that the method returns null based only on its body? Consider the following points:

- The method may have multiple return paths; consider all return statements.
- If the method calls another method, do not assume its return value unless its full declaration is provided. Request its declaration if needed.
- The method may throw an exception instead of returning null. An exception path should not be considered a null return.
- Ensure you request the declarations of any methods whose return values directly or indirectly impact this method’s return value before making a conclusion.
- Carefully analyze all conditions and prior operations that may guarantee a non-null return value.

@Nullable public static IGameLoop loop() {
    return gameLoop;
}

Here are the method definitions in addition to the method inquired:

Depth: 0
```java
class de.gurkenlabs.litiengine.Game {
@Nullable public static IGameLoop loop() {
    return gameLoop;
}
}
```


Response Format:
Provide the answer in **XML format** as follows:

#### If the method **cannot** return `null`:
```xml
<response>
  <reason><![CDATA[EXPLAIN WHY THE METHOD CANNOT RETURN NULL]]></reason>
  <value>NO</value>
</response>
```

#### If the method can return null:
```xml
<response>
  <reason><![CDATA[EXPLAIN WHY THE METHOD CAN RETURN NULL]]></reason>
  <value>YES</value>
</response>
```

#### If you are unsure or need more information, respond with where you can ask for more details or what specific information you need.

#### If you are unsure or If there are any methods that directly or indirectly affect the return value and are not fully disclosed, request their declarations first, in the following format:
<response>
  <reason><![CDATA[YOUR REASON]]></reason>
  <value>UNKNOWN</value>
  <methods>
    <method>methodName</method>
  </methods>
</response>

If additional information is required other than method declaration, list each request inside a `<request>` tag. If no additional information is needed, omit the `<requests>` section.

Respond with:
```xml
<response>
    <reason><![CDATA[YOUR REASON]]></reason>
    <value>UNKNOWN</value>
    <!-- Include <requests> only if additional information is needed -->
    <requests>
        <request><![CDATA[YOUR REQUEST 1]]></request>
        <request><![CDATA[YOUR REQUEST 2]]></request>
    </requests>
</response>
```

Additional Notes:
Be precise in your reasoning.
If a method’s return value depends on another method not provided, request its declaration before making a conclusion.
If the method can return null in some cases but not others, explain under what conditions it can happen.

---ChatGPT.sendRequestToOpenAI---
Retrieving response from cache
---Response.<init>---
Creating Response:
```xml
<response>
  <reason><![CDATA[The method `loop` returns the variable `gameLoop`. Without the initialization or assignment details of `gameLoop`, it's unclear whether it can be null. The possibility of `gameLoop` being uninitialized or set to null elsewhere in the program means `loop` could potentially return null. Further information on `gameLoop` is required.]]></reason>
  <value>UNKNOWN</value>
  <requests>
    <request><![CDATA[Please provide the declaration and initialization of the variable `gameLoop` in the class `de.gurkenlabs.litiengine.Game`.]]></request>
  </requests>
</response>
```
---Response.<init>---
Response created:
Unknown: The method `loop` returns the variable `gameLoop`. Without the initialization or assignment details of `gameLoop`, it's unclear whether it can be null. The possibility of `gameLoop` being uninitialized or set to null elsewhere in the program means `loop` could potentially return null. Further information on `gameLoop` is required.
---AdvancedNullAwayCodeFix.investigateMethodReturnNullability---
Could not determine the nullability and model did not ask for any method.
---ChatGPT.checkIfMethodIsReturningNullableOnCallSite---
Asking if the method is returning nullable on the call site: Game.loop()
---ChatGPT.ask---
Asking ChatGPT:
In the method below, is there a possibility that the method returns null at the given call site?

```java
@Nullable public static IGameLoop loop() {
    return gameLoop;
}
```

## Guidelines:
- The method may have multiple return paths; consider all return statements.
- If the method calls another method, do not assume its return value unless its full declaration is provided. Request its declaration if needed.
- The method may throw an exception instead of returning null. An exception path should not be considered a null return.
- Ensure you request the declarations of any methods whose return values directly or indirectly impact this method’s return value before making a conclusion.
- If the method returns a value that is determined by a parameter, evaluate based on the actual argument at the given call site.
- Analyze based only on the specific invocation provided. Do not generalize to all possible inputs.- If the return value is guaranteed to be non-null at the call site, the answer should be a definitive NO.
- Do not generalize based on all possible inputs—your answer must be based only on the given invocation.
- Focus only on the given call site, not all possible invocations.

### call site:
Game.loop()

Here are the method definitions and the call chain for this method, showing the sequence of calls from the method to its callers at each depth level:

Depth: 0
```java
class de.gurkenlabs.litiengine.Game {
@Nullable public static IGameLoop loop() {
    return gameLoop;
}
}
```
Depth: 1
```java
class de.gurkenlabs.litiengine.environment.GameWorld {
public void loadEnvironment(@Nullable final Environment env) {
    Lock lock = Game.loop().getLock();
    lock.lock();
    try {
      unloadEnvironment();
      this.environment = env;
      if (env != null) {
        this.addEnvironment(env);

        if (env.getGravity() == 0 && this.gravity() != 0) {
          env.setGravity(this.gravity());
        }

        env.load();
        for (final EnvironmentLoadedListener listener : this.loadedListeners) {
          listener.loaded(env);
        }

        // call map specific listeners
        String mapName = getMapName(env);
        if (mapName != null && this.environmentLoadedListeners.containsKey(mapName)) {

          // for the default camera we center the camera on the environment
          if (this.camera().getClass().equals(Camera.class)) {
            camera().setFocus(env.getCenter());
          }

          for (EnvironmentLoadedListener listener : this.environmentLoadedListeners.get(mapName)) {
            listener.loaded(env);
          }
        }
      }
    } finally {
      lock.unlock();
    }
}public void setCamera(@Nullable final ICamera cam) {
    if (this.camera() != null) {
      Game.loop().detach(camera);
    }

    camera = cam;

    if (cam != null && !Game.isInNoGUIMode()) {
      Game.loop().attach(cam);
      cam.updateFocus();
    }
}
}
```
```java
class de.gurkenlabs.litiengine.entities.behavior.EntityNavigator {
public EntityNavigator(final IMobileEntity entity, final PathFinder pathFinder) {
    this.cancelNavigationConditions = new CopyOnWriteArrayList<>();
    this.listeners = new CopyOnWriteArrayList<>();
    this.entity = entity;
    this.pathFinder = pathFinder;
    this.setAcceptableError(DEFAULT_ACCEPTABLE_ERROR);
    Game.loop().attach(this);
}
}
```
```java
class de.gurkenlabs.litiengine.GameWindow {
private static void initializeWindowEventListeners(Window window) {

    window.addWindowStateListener(
        e -> {
          if (e.getNewState() == Frame.ICONIFIED) {
            Game.loop().setTickRate(ICONIFIED_MAX_FPS);
          } else {
            Game.loop().setTickRate(Game.config().client().getMaxFps());
          }
        });

    window.addWindowFocusListener(
        new WindowFocusListener() {
          @Override
          public void windowLostFocus(WindowEvent e) {
            if (Game.config().graphics().reduceFramesWhenNotFocused()) {
              Game.loop().setTickRate(NONE_FOCUS_MAX_FPS);
            }
          }

          @Override
          public void windowGainedFocus(WindowEvent e) {
            Game.loop().setTickRate(Game.config().client().getMaxFps());
          }
        });

    window.addWindowListener(
        new WindowAdapter() {
          @Override
          public void windowClosing(final WindowEvent event) {
            Game.exit();
          }
        });
}
}
```
```java
class de.gurkenlabs.litiengine.gui.screens.ScreenManager {
public void display(@Nullable final Screen screen) {
    if (Game.hasStarted() && Game.time().since(this.lastScreenChange) < this.getChangeCooldown()) {
      log.log(
          Level.INFO,
          "Skipping displaying of screen {0} because screen changing is currently on cooldown.",
          screen != null ? screen.getName() : "");
      return;
    }

    final Screen previous = this.current();
    if (previous != null) {
      previous.suspend();
    }

    if (screen != null && !this.screens.contains(screen)) {
      this.screens.add(screen);
    }

    this.currentScreen = screen;
    if (!Game.isInNoGUIMode() && this.current() != null) {
      this.current().prepare();
    }

    this.lastScreenChange = Game.loop().getTicks();

    final ScreenChangedEvent event = new ScreenChangedEvent(this.current(), previous);
    for (final ScreenChangedListener listener : this.screenChangedListeners) {
      listener.changed(event);
    }
}
}
```
```java
class de.gurkenlabs.litiengine.abilities.effects.Effect {
@Override
  public void update() {

    for (final Iterator<EffectApplication> iterator = this.getActiveAppliances().iterator();
        iterator.hasNext(); ) {
      final EffectApplication appliance = iterator.next();
      // if the effect duration is reached
      if (this.hasEnded(appliance)) {

        iterator.remove();
        this.cease(appliance);
      }
    }

    // 4. unregister if all appliances are finished
    if (this.getActiveAppliances().isEmpty()) {
      Game.loop().detach(this);
    }
}public void apply(final Shape impactArea) {
    final List<ICombatEntity> affected = this.lookForAffectedEntities(impactArea);
    for (final ICombatEntity affectedEntity : affected) {
      this.apply(affectedEntity);
    }

    this.appliances.add(new EffectApplication(affected, impactArea));

    // if it is the first appliance -> register for update
    if (this.appliances.size() == 1) {
      Game.loop().attach(this);
    }
}
}
```
```java
class de.gurkenlabs.litiengine.GameTime {
public long toTicks(final int milliseconds) {
    return this.toTicks(milliseconds, Game.loop().getTickRate());
}public long since(final long tick) {
    return toMilliseconds(Game.loop().getTicks() - tick);
}public long now() {
    return Game.loop().getTicks();
}public long sinceGameStart() {
    return this.toMilliseconds(Game.loop().getTicks());
}@Override
  public void loaded(Environment environment) {
    environmentLoaded = Game.loop().getTicks();
}public long toMilliseconds(final long ticks) {
    return this.toMilliseconds(ticks, Game.loop().getTickRate());
}
}
```
```java
class de.gurkenlabs.litiengine.GameMetrics {
@Override
  public void render(final Graphics2D g) {
    this.updateMetrics();

    if (!Game.config().client().showGameMetrics()) {
      return;
    }

    this.currentOffsetY = 0;

    g.setColor(this.renderColor);

    // render client metrics
    this.drawTitle(g, "[client]");
    this.drawMetric(g, "fps       : " + this.getFramesPerSecond());
    this.drawMetric(g, "max fps   : " + this.maxFramesPerSecond);
    this.drawMetric(g, "updatables: " + Game.loop().getUpdatableCount());

    // render jvm metrics if debug is enabled
    if (Game.config().debug().isDebugEnabled()) {
      this.drawTitle(g, "[jvm]");
      this.drawMetric(g, "java      : " + this.javaVersion);
      this.drawMetric(g, "memory    : " + String.format("%-5.5s", this.usedMemory) + " MB");
      this.drawMetric(g, "threads   : " + Thread.activeCount());
    }

    // render rendering metrics
    if (!this.renderMetrics.isEmpty()) {
      this.drawTitle(g, "[update]");

      for (RenderMetrics metric : this.renderMetrics) {
        this.drawMetric(g, metric.toString());
      }

      this.renderMetrics.clear();
    }
}
}
```
```java
class de.gurkenlabs.litiengine.graphics.emitters.Emitter {
public void deactivate() {
    if (!this.activated) {
      return;
    }

    this.activated = false;
    this.getParticles().clear();
    this.aliveTime = 0;
    this.activationTick = 0;
    this.lastSpawn = 0;
    Game.loop().detach(this);
}public void activate() {
    if (this.activated) {
      return;
    }

    this.activated = true;
    this.activationTick = Game.time().now();
    Game.loop().attach(this);
}@Override
  public void update() {
    if (this.isPaused()) {
      return;
    }

    // clear particles if the effect time to life is reached
    if (this.isFinished()) {
      for (EmitterFinishedListener listener : this.finishedListeners) {
        listener.finished(this);
      }

      this.delete();
      return;
    }

    final float updateRatio = (float) this.data().getUpdateRate() / Game.loop().getTickRate();
    for (final Particle p : this.getParticles().stream().collect(Collectors.toList())) {
      if (this.particleCanBeRemoved(p)) {
        // remove dead particles
        this.particles.remove(p);
        continue;
      }

      p.update(this.getOrigin(), updateRatio);
    }

    this.aliveTime = Game.time().since(this.activationTick);
    if ((this.data().getSpawnRate() == 0
        || Game.time().since(this.lastSpawn) >= this.data().getSpawnRate())) {
      this.lastSpawn = Game.time().now();
      this.spawnParticle();
    }
}
}
```
```java
class de.gurkenlabs.litiengine.entities.behavior.IBehaviorController {
public default void attach() {
    Game.loop().attach(this);
}public default void detach() {
    Game.loop().detach(this);
}
}
```
```java
class de.gurkenlabs.litiengine.abilities.AbilityExecution {
AbilityExecution(final Ability ability) {
    this.appliedEffects = new CopyOnWriteArrayList<>();
    this.ability = ability;
    this.executionTicks = Game.time().now();
    this.impactArea = ability.calculateImpactArea();
    this.castLocation = ability.getExecutor().getCenter();
    Game.loop().attach(this);
}@Override
  public void update() {
    // if there a no effects to apply -> unregister this instance and we're done
    if (this.getAbility().getEffects().isEmpty()
        || this.getAbility().getEffects().size() == this.getAppliedEffects().size()) {
      Game.loop().detach(this);
      return;
    }

    // handle all effects from the ability that were not applied yet
    for (final Effect effect : this.getAbility().getEffects()) {
      // if the ability was not executed yet or the delay of the effect is not
      // yet reached
      if (this.getAppliedEffects().contains(effect)
          || Game.time().since(this.getExecutionTicks()) < effect.getDelay()) {
        continue;
      }

      effect.apply(this.getExecutionImpactArea());
      this.getAppliedEffects().add(effect);
    }
}
}
```
```java
class de.gurkenlabs.litiengine.GameWindow$3 {
@Override
          public void windowGainedFocus(WindowEvent e) {
            Game.loop().setTickRate(Game.config().client().getMaxFps());
}@Override
          public void windowLostFocus(WindowEvent e) {
            if (Game.config().graphics().reduceFramesWhenNotFocused()) {
              Game.loop().setTickRate(NONE_FOCUS_MAX_FPS);
            }
}
}
```
```java
class de.gurkenlabs.litiengine.environment.EntitySpawner {
protected void spawnNewEntities() {
    if (this.getSpawnMode() != SpawnMode.CUSTOMSPAWNPOINTS && this.getSpawnPoints().isEmpty()) {
      return;
    }

    switch (this.getSpawnMode()) {
      case ALLSPAWNPOINTS:
        for (int i = 0; i < this.getSpawnPoints().size(); i++) {
          final int index = i;
          Game.loop()
              .perform(
                  this.getSpawnDelay() + this.getSpawnDelay() * i,
                  () -> this.spawn(this.getSpawnPoints().get(index), this.getSpawnAmount()));
        }
        break;
      case ONERANDOMSPAWNPOINT:
        this.spawn(Game.random().choose(this.getSpawnPoints()), this.getSpawnAmount());
        break;
      case RANDOMSPAWNPOINTS:
        for (int i = 0; i < this.getSpawnAmount(); i++) {
          Game.loop()
              .perform(
                  this.getSpawnDelay() + this.getSpawnDelay() * i,
                  () -> this.spawn(Game.random().choose(this.getSpawnPoints()), 1));
        }
        break;
      case CUSTOMSPAWNPOINTS:
        List<Spawnpoint> spawnPoints =
            this.customSpawnpoints != null
                ? this.customSpawnpoints.apply(this)
                : this.getCustomSpawnpoints();

        int index = 0;
        for (Spawnpoint spawn : spawnPoints) {
          Game.loop()
              .perform(
                  this.getSpawnDelay() + this.getSpawnDelay() * index, () -> this.spawn(spawn, 1));
          index++;
        }
        break;
      default:
        break;
    }
}
}
```
```java
class de.gurkenlabs.litiengine.tweening.TweenEngine {
@Override
  public void start() {
    Game.loop().attach(this);
}@Override
  public void terminate() {
    Game.loop().detach(this);
}
}
```
```java
class de.gurkenlabs.litiengine.gui.SpeechBubble {
public void hide() {
    Game.world().environment().removeRenderable(this);
    Game.loop().detach(this);
    if (activeSpeechBubbles.get(this.getEntity()) != null
        && activeSpeechBubbles.remove(this.getEntity()).equals(this)) {
      activeSpeechBubbles.remove(this.getEntity());
    }

    for (SpeechBubbleListener listener : this.listeners) {
      listener.hidden();
    }
}private SpeechBubble(
      final IEntity entity,
      final String text,
      @Nullable SpeechBubbleAppearance appearance,
      @Nullable Font font) {
    if (appearance == null) {
      this.appearance = DEFAULT_APPEARANCE;
    } else {
      this.appearance = appearance;
    }

    final SpeechBubble active = activeSpeechBubbles.get(entity);
    if (active != null) {
      active.hide();
    }
    this.setFont(font);

    this.textBoxWidth = (float) (entity.getWidth() * 4);
    this.entity = entity;

    this.currentText = text;
    this.currentTextDisplayTime = DISPLAYTIME_MIN + text.length() * DISPLAYTIME_PER_LETTER;

    this.lastTextDisplay = Game.time().now();
    this.createBubbleImage();
    entity.getEnvironment().add(this, RenderType.UI);
    Game.loop().attach(this);
    activeSpeechBubbles.put(entity, this);
}
}
```
```java
class de.gurkenlabs.litiengine.entities.Prop {
private void updateAnimationController() {
    IEntityAnimationController<?> controller = this.createAnimationController();
    this.getControllers().addController(controller);
    if (Game.world().environment() != null && Game.world().environment().isLoaded()) {
      Game.loop().attach(controller);
    }
}
}
```
```java
class de.gurkenlabs.litiengine.graphics.FreeFlightCamera {
public FreeFlightCamera(final Point2D focus) {
    this.setFocus(focus);
    this.velocity = DEFAULT_SCROLL_PIXELS_PER_SECOND;
    this.scrollPadding = DEFAULT_SCROLL_PADDING;
    this.setClampToMap(true);

    Game.loop().attach(this);
}private void handleFreeFlightCamera() {
    if (Game.world().environment() == null || Game.world().environment().getMap() == null) {
      return;
    }

    final Point2D mouseLocation = Input.mouse().getLocation();

    final double scrollSpeed =
        this.getVelocity()
            / (double) Game.loop().getTickRate()
            * Game.config().input().getMouseSensitivity();

    double x = this.getFocus().getX();
    double y = this.getFocus().getY();

    double deltaX = 0;
    if (mouseLocation.getX() < this.getScrollPadding()) {
      deltaX -= scrollSpeed;
    } else if (Game.window().getResolution().getWidth() - mouseLocation.getX()
        < this.getScrollPadding()) {
      deltaX += scrollSpeed;
    }

    double deltaY = 0;
    if (mouseLocation.getY() < this.getScrollPadding()) {
      deltaY -= scrollSpeed;
    } else if (Game.window().getResolution().getHeight() - mouseLocation.getY()
        < this.getScrollPadding()) {
      deltaY += scrollSpeed;
    }

    x += deltaX;
    y += deltaY;

    this.setFocus(new Point2D.Double(x, y));
}
}
```
```java
class de.gurkenlabs.litiengine.environment.Environment {
private static void dispose(final Collection<? extends IEntity> entities) {
    for (final IEntity entity : entities) {
      if (entity instanceof IUpdateable) {
        Game.loop().detach((IUpdateable) entity);
      }

      entity.detachControllers();
    }
}private static void loadUpdatableOrEmitterEntity(IEntity entity) {
    if (entity instanceof Emitter) {
      final Emitter emitter = (Emitter) entity;
      if (emitter.isActivateOnInit()) {
        emitter.activate();
      }
    } else if (entity instanceof IUpdateable) {
      Game.loop().attach((IUpdateable) entity);
    }
}private void unload(final IEntity entity) {
    // 1. remove from physics engine
    if (entity instanceof ICollisionEntity) {
      Game.physics().remove((ICollisionEntity) entity);
    }

    // 2. unregister from update
    if (entity instanceof IUpdateable) {
      Game.loop().detach((IUpdateable) entity);
    }

    if (entity instanceof IMobileEntity) {
      this.removeGravity((IMobileEntity) entity);
    }

    // 3. detach all controllers
    entity.detachControllers();

    if (entity instanceof Emitter) {
      Emitter em = (Emitter) entity;
      em.deactivate();
    }

    if (this.loaded && (entity instanceof LightSource || entity instanceof StaticShadow)) {
      this.updateLighting(entity);
    }

    entity.removed(this);
}
}
```
```java
class de.gurkenlabs.litiengine.graphics.animation.Animation {
@Override
  public void update() {
    // do nothing if the animation is not playing or the current keyframe is not finished
    if (!this.isPlaying()
        || Game.time().since(this.lastFrameUpdate) < this.getCurrentKeyFrame().getDuration()) {
      return;
    }

    // if we are not looping and the last keyframe is finished, we terminate the animation
    if (!this.isLooping() && this.isLastKeyFrame()) {
      this.terminate();
      return;
    }

    // make sure, we stay inside the keyframe list
    final int newFrameIndex =
        (this.getKeyframes().indexOf(this.currentFrame) + 1) % this.getKeyframes().size();
    final KeyFrame previousFrame = this.currentFrame;
    this.currentFrame = this.getKeyframes().get(newFrameIndex);

    for (KeyFrameListener listener : this.listeners) {
      listener.currentFrameChanged(previousFrame, this.currentFrame);
    }

    this.lastFrameUpdate = Game.loop().getTicks();
}public void restart() {
    this.currentFrame = this.firstFrame;
    this.lastFrameUpdate = Game.loop().getTicks();
}
}
```
```java
class de.gurkenlabs.litiengine.physics.MovementController {
@Override
  public void attach() {
    Game.loop().attach(this);
}private void handleForces() {
    // clean up forces
    this.activeForces.forEach(
        x -> {
          if (x.hasEnded()) {
            this.activeForces.remove(x);
          }
        });

    if (this.activeForces.isEmpty()) {
      return;
    }

    // disable turn-on-move for force handling
    boolean turn = this.getEntity().turnOnMove();
    this.getEntity().setTurnOnMove(false);
    try {
      double deltaX = 0;
      double deltaY = 0;
      for (final Force force : this.activeForces) {
        if (force.cancelOnReached() && force.hasReached(this.getEntity())) {
          force.end();
          continue;
        }

        final Point2D collisionBoxCenter = this.getEntity().getCollisionBoxCenter();
        final double angle =
            GeometricUtilities.calcRotationAngleInDegrees(collisionBoxCenter, force.getLocation());
        final double strength =
            Game.loop().getDeltaTime() * 0.001f * force.getStrength() * Game.loop().getTimeScale();
        deltaX += GeometricUtilities.getDeltaX(angle, strength);
        deltaY += GeometricUtilities.getDeltaY(angle, strength);
      }

      final Point2D target =
          new Point2D.Double(this.getEntity().getX() + deltaX, this.getEntity().getY() + deltaY);
      final boolean success = Game.physics().move(this.getEntity(), target);
      if (!success) {
        for (final Force force : this.activeForces) {
          if (force.cancelOnCollision()) {
            force.end();
          }
        }
      }
    } finally {
      this.getEntity().setTurnOnMove(turn);
    }
}@Override
  public void detach() {
    Game.loop().detach(this);
}public void handleMovement() {
    if (!this.isMovementAllowed()) {
      this.velocity = 0;
      return;
    }

    // max distance an entity can travel within one tick
    final double maxPixelsPerTick = this.getEntity().getTickVelocity();
    final double deltaTime = Game.loop().getDeltaTime() * Game.loop().getTimeScale();

    final double acceleration =
        this.getEntity().getAcceleration() == 0
            ? maxPixelsPerTick
            : deltaTime / this.getEntity().getAcceleration() * maxPixelsPerTick;
    final double deceleration =
        this.getEntity().getDeceleration() == 0
            ? this.getVelocity()
            : deltaTime / this.getEntity().getDeceleration() * maxPixelsPerTick;

    double dx = this.getDx();
    double dy = this.getDy();
    this.setDx(0);
    this.setDy(0);

    final double deltaVelocity =
        Math.min(Math.sqrt(Math.pow(dx, 2) + Math.pow(dy, 2)), acceleration);
    if (deltaVelocity != 0) {
      double newVelocity = this.getVelocity() + deltaVelocity;
      this.setVelocity(newVelocity);
    } else {
      final double newVelocity = Math.max(0, this.getVelocity() - deceleration);
      this.setVelocity(newVelocity);
      dx = GeometricUtilities.getDeltaX(this.moveAngle);
      dy = GeometricUtilities.getDeltaY(this.moveAngle);
    }

    if (this.getVelocity() == 0) {
      this.moveAngle = 0;
      return;
    }

    // actually move entity
    this.moveEntity(dx, dy);
}
}
```
```java
class de.gurkenlabs.litiengine.graphics.animation.AnimationController {
public void detach() {
    Game.loop().detach(this);
}public void attach() {
    Game.loop().attach(this);
}
}
```
```java
class de.gurkenlabs.litiengine.graphics.Camera {
@Override
  public void setZoom(final float targetZoom, final int delay) {
    if (delay == 0) {

      this.zoom = targetZoom;
      this.targetZoom = 0;
      this.zoomDelay = 0;
      this.zoomTick = 0;
      this.zoomStep = 0;

      final ZoomChangedEvent event = new ZoomChangedEvent(this, targetZoom);
      for (final ZoomChangedListener listener : this.zoomListeners) {
        listener.zoomChanged(event);
      }
    } else {
      this.zoomTick = Game.time().now();
      this.targetZoom = targetZoom;
      this.zoomDelay = delay;

      final double tickduration = 1000 / (double) Game.loop().getTickRate();
      final double tickAmount = delay / tickduration;
      final float totalDelta = this.targetZoom - this.zoom;
      this.zoomStep = tickAmount > 0 ? (float) (totalDelta / tickAmount) : totalDelta;
    }
}
}
```
```java
class de.gurkenlabs.litiengine.Game {
public static synchronized void init(String... args) {
    if (initialized) {
      log().log(Level.INFO, "The game has already been initialized.");
      return;
    }

    log.init();
    handleCommandLineArguments(args);

    config().load();
    Locale.setDefault(new Locale(config().client().getCountry(), config().client().getLanguage()));

    gameLoop = new GameLoop("Main Update Loop", config().client().getMaxFps());
    loop().attach(physics());
    loop().attach(world());

    // setup default exception handling for render and update loop
    setUncaughtExceptionHandler(
        new DefaultUncaughtExceptionHandler(config().client().exitOnError()));

    screenManager = new ScreenManager();
    gameWindow = new GameWindow();

    // initialize  the game window
    window().init();
    world.setCamera(new Camera());

    for (GameListener listener : gameListeners) {
      listener.initialized(args);
    }

    if (!isInNoGUIMode()) {
      window().getRenderComponent().onRendered(g -> metrics().render(g));

      graphics()
          .addEntityRenderedListener(
              e -> DebugRenderer.renderEntityDebugInfo(e.getGraphics(), e.getEntity()));

      window().getRenderComponent().onFpsChanged(fps -> metrics().setFramesPerSecond(fps));
      window()
          .setIcons(
              Arrays.asList(
                  Resources.images().get("liti-logo-x16.png"),
                  Resources.images().get("liti-logo-x20.png"),
                  Resources.images().get("liti-logo-x32.png"),
                  Resources.images().get("liti-logo-x48.png")));

      Input.keyboard()
          .onKeyTyped(
              KeyEvent.VK_PRINTSCREEN,
              key -> {
                // don't take a screenshot if a modifier is active
                if (key.getModifiers() != 0) {
                  return;
                }

                window().getRenderComponent().takeScreenshot();
              });
    }

    Runtime.getRuntime().addShutdownHook(new Thread(Game::terminate, "Shutdown"));

    initialized = true;
}
}
```
```java
class de.gurkenlabs.litiengine.entities.Creature {
protected void updateAnimationController() {
    IEntityAnimationController<?> controller = this.createAnimationController();
    this.getControllers().addController(controller);
    if (Game.world().environment() != null && Game.world().environment().isLoaded()) {
      Game.loop().attach(controller);
    }
}@Override
  public float getTickVelocity() {
    // pixels per ms multiplied by the passed ms
    // ensure that entities don't travel too far in case of lag
    return Math.min(Game.loop().getDeltaTime(), GameLoop.TICK_DELTATIME_LAG)
        * 0.001F
        * this.getVelocity().get()
        * Game.loop().getTimeScale();
}
}
```
Depth: 2
```java
class de.gurkenlabs.litiengine.environment.GameWorld {
public void clear() {
    this.unloadEnvironment();
    this.environments.clear();
    this.setCamera(null);
    Game.physics().clear();

    this.environmentListeners.clear();
    this.environmentLoadedListeners.clear();
    this.environmentUnloadedListeners.clear();

    this.listeners.clear();
    this.loadedListeners.clear();
    this.unloadedListeners.clear();
}@Nullable
  public Environment loadEnvironment(IMap map) {
    Environment env = this.getEnvironment(map);
    this.loadEnvironment(env);
    return env;
}@Nullable
  public Environment loadEnvironment(String mapName) {
    Environment env = this.getEnvironment(mapName);
    this.loadEnvironment(env);
    return env;
}
}
```
```java
class de.gurkenlabs.litiengine.GameWindow {
GameWindow() {
    this.hostControl = new JFrame();

    this.resolutionChangedListeners = new CopyOnWriteArrayList<>();

    this.renderCanvas = new RenderComponent(Game.config().graphics().getResolution());
    this.cursor = new MouseCursor();
    if (!Game.isInNoGUIMode()) {
      this.hostControl.setBackground(Color.BLACK);
      this.hostControl.add(this.renderCanvas);

      this.initializeEventListeners();

      this.hostControl.setTitle(Game.info().getTitle());
      this.hostControl.setDefaultCloseOperation(WindowConstants.DO_NOTHING_ON_CLOSE);
      initializeWindowEventListeners(this.hostControl);
    }
}
}
```
```java
class de.gurkenlabs.litiengine.GameTime {
public long sinceEnvironmentLoad() {
    return this.since(this.environmentLoaded);
}public long since(final long tick) {
    return toMilliseconds(Game.loop().getTicks() - tick);
}public long sinceGameStart() {
    return this.toMilliseconds(Game.loop().getTicks());
}
}
```
```java
class de.gurkenlabs.litiengine.abilities.effects.Effect {
protected void cease(final EffectApplication appliance) {
    // 1. cease the effect for all affected entities
    for (final ICombatEntity entity : appliance.getAffectedEntities()) {
      this.cease(entity);
    }

    // 2. apply follow up effects
    this.getFollowUpEffects().forEach(followUp -> followUp.apply(appliance.getImpactArea()));
}protected boolean hasEnded(final EffectApplication appliance) {
    final long effectDuration = Game.time().since(appliance.getAppliedTicks());
    return effectDuration > this.getDuration();
}
}
```
```java
class de.gurkenlabs.litiengine.abilities.effects.EffectApplication {
protected EffectApplication(final List<ICombatEntity> affectedEntities, final Shape impactArea) {
    this.applied = Game.time().now();
    this.affectedEntities = affectedEntities;
    this.impactArea = impactArea;
}
}
```
```java
class de.gurkenlabs.litiengine.entities.CombatEntity {
@Override
  public boolean wasHit(int timeSpan) {
    return Game.time().since(this.lastHit) < timeSpan;
}@Override
  public void hit(final int damage, @Nullable final Ability ability) {
    if (this.isDead()) {
      return;
    }

    if (!this.isIndestructible()) {
      this.getHitPoints().modifyBaseValue(new AttributeModifier<>(Modification.SUBTRACT, damage));
    }

    final EntityHitEvent event = new EntityHitEvent(this, ability, damage, this.isDead());

    for (final CombatEntityListener listener : this.listeners) {
      listener.hit(event);
    }

    for (final CombatEntityHitListener listener : this.hitListeners) {
      listener.hit(event);
    }

    if (this.isDead()) {
      this.fireDeathEvent();
      this.setCollision(false);
    }

    this.lastHit = Game.time().now();
}
}
```
```java
class de.gurkenlabs.litiengine.graphics.ImageEffect {
protected ImageEffect(final int ttl, final String name) {
    this.ttl = ttl;
    this.name = name;
    this.aliveTick = Game.time().now();
}@Override
  public long getAliveTime() {
    return Game.time().since(this.aliveTick);
}
}
```
```java
class de.gurkenlabs.litiengine.abilities.AbilityExecution {
AbilityExecution(final Ability ability) {
    this.appliedEffects = new CopyOnWriteArrayList<>();
    this.ability = ability;
    this.executionTicks = Game.time().now();
    this.impactArea = ability.calculateImpactArea();
    this.castLocation = ability.getExecutor().getCenter();
    Game.loop().attach(this);
}@Override
  public void update() {
    // if there a no effects to apply -> unregister this instance and we're done
    if (this.getAbility().getEffects().isEmpty()
        || this.getAbility().getEffects().size() == this.getAppliedEffects().size()) {
      Game.loop().detach(this);
      return;
    }

    // handle all effects from the ability that were not applied yet
    for (final Effect effect : this.getAbility().getEffects()) {
      // if the ability was not executed yet or the delay of the effect is not
      // yet reached
      if (this.getAppliedEffects().contains(effect)
          || Game.time().since(this.getExecutionTicks()) < effect.getDelay()) {
        continue;
      }

      effect.apply(this.getExecutionImpactArea());
      this.getAppliedEffects().add(effect);
    }
}
}
```
```java
class de.gurkenlabs.litiengine.tweening.TweenEngine {
@Override
  public void update() {
    for (final Tweenable target : this.getTweens().keySet()) {
      for (final Tween tween : this.getTweens().get(target).values()) {
        if (tween.hasStopped()) {
          continue;
        }
        final long elapsed = Game.time().since(tween.getStartTime());
        if (elapsed >= tween.getDuration()) {
          tween.stop();
          continue;
        }
        final float[] currentValues = new float[tween.getTargetValues().length];
        for (int i = 0; i < tween.getTargetValues().length; i++) {
          currentValues[i] =
              tween.getStartValues()[i]
                  + tween.getEquation().compute(elapsed / (float) tween.getDuration())
                      * (tween.getTargetValues()[i] - tween.getStartValues()[i]);
        }
        tween.getTarget().setTweenValues(tween.getType(), currentValues);
      }
    }
}
}
```
```java
class de.gurkenlabs.litiengine.gui.SpeechBubble {
public static SpeechBubble create(
      final IEntity entity, final String text, SpeechBubbleAppearance appearance, Font font) {
    return new SpeechBubble(entity, text, appearance, font);
}public static SpeechBubble create(final IEntity entity, final Font font, final String text) {
    SpeechBubbleAppearance app =
        new SpeechBubbleAppearance(
            DEFAULT_APPEARANCE.getForeColor(),
            DEFAULT_APPEARANCE.getBackgroundColor1(),
            DEFAULT_APPEARANCE.getBorderColor(),
            DEFAULT_APPEARANCE.getPadding());
    return new SpeechBubble(entity, text, app, font);
}public static SpeechBubble create(final IEntity entity, final String text) {
    return new SpeechBubble(entity, text, null, GuiProperties.getDefaultFont());
}@Override
  public void update() {
    if (this.currentText == null) {
      this.hide();
      return;
    }

    this.entityCenter = Game.world().camera().getViewportLocation(this.getEntity().getCenter());

    // old text was displayed long enough
    if (this.lastTextDisplay != 0
        && Game.time().since(this.lastTextDisplay) > this.currentTextDisplayTime) {
      this.currentText = null;
      this.lastTextDisplay = 0;
      return;
    }

    // display new text
    if (this.textIndex < this.currentText.length()
        && Game.time().since(this.lastCharPoll) > LETTER_WRITE_DELAY) {
      this.textIndex++;
      this.lastCharPoll = Game.time().now();
      if (this.typeSound != null) {
        Game.audio().playSound(this.typeSound, this.getEntity());
      }
    }

    // continue displaying currently displayed text
}private SpeechBubble(
      final IEntity entity,
      final String text,
      final Sound typeSound,
      SpeechBubbleAppearance appearance,
      Font font) {
    this(entity, text, appearance, font);
    this.typeSound = typeSound;
}private SpeechBubble(
      final IEntity entity,
      final String text,
      @Nullable SpeechBubbleAppearance appearance,
      @Nullable Font font) {
    if (appearance == null) {
      this.appearance = DEFAULT_APPEARANCE;
    } else {
      this.appearance = appearance;
    }

    final SpeechBubble active = activeSpeechBubbles.get(entity);
    if (active != null) {
      active.hide();
    }
    this.setFont(font);

    this.textBoxWidth = (float) (entity.getWidth() * 4);
    this.entity = entity;

    this.currentText = text;
    this.currentTextDisplayTime = DISPLAYTIME_MIN + text.length() * DISPLAYTIME_PER_LETTER;

    this.lastTextDisplay = Game.time().now();
    this.createBubbleImage();
    entity.getEnvironment().add(this, RenderType.UI);
    Game.loop().attach(this);
    activeSpeechBubbles.put(entity, this);
}
}
```
```java
class de.gurkenlabs.litiengine.gui.TextFieldComponent {
@Override
  public void render(final Graphics2D g) {
    super.render(g);
    g.setFont(this.getFont());
    final FontMetrics fm = g.getFontMetrics();

    if (this.isSelected() && Game.time().since(this.lastToggled) > this.flickerDelay) {
      this.cursorVisible = !this.cursorVisible;
      this.lastToggled = Game.time().now();
    }
    if (this.isSelected() && this.cursorVisible) {
      final Rectangle2D cursor =
          new Rectangle2D.Double(
              this.getX() + this.getTextX() + fm.stringWidth(this.getTextToRender(g)),
              this.getY() + this.getTextY(),
              this.getFont().getSize2D() * 3 / 5,
              this.getFont().getSize2D() * 1 / 5);
      g.setColor(this.getAppearance().getForeColor());
      g.fill(cursor);
    }
}
}
```
```java
class de.gurkenlabs.litiengine.entities.Prop {
public Prop(
      final Point2D location, @Nullable final String spritesheetName, final Material material) {
    super();
    this.rotation = Rotation.NONE;
    this.spritesheetName = spritesheetName;
    this.material = material;
    this.setLocation(location);
    this.updateAnimationController();
}public void setSpritesheetName(@Nullable final String spriteName) {
    this.spritesheetName = spriteName;
    this.updateAnimationController();
}
}
```
```java
class de.gurkenlabs.litiengine.tweening.Tween {
public Tween begin() {
    this.started = Game.time().now();
    this.stopped = false;
    return this;
}
}
```
```java
class de.gurkenlabs.litiengine.graphics.emitters.particles.Particle {
public void update(final Point2D emitterOrigin, final float updateRatio) {
    if (this.aliveTick == 0) {
      this.aliveTick = Game.time().now();
    }

    this.aliveTime = Game.time().since(this.aliveTick);
    if (this.timeToLiveReached()) {
      return;
    }

    if (this.colliding) {
      return;
    }

    if (this.getDeltaWidth() != 0) {
      this.width += this.getDeltaWidth() * updateRatio;
    }

    if (this.getDeltaHeight() != 0) {
      this.height += this.getDeltaHeight() * updateRatio;
    }

    if (this.getDeltaAngle() != 0) {
      this.angle += this.getDeltaAngle() * updateRatio;
    }

    // test for ray cast collision
    final float targetX = this.x + this.getVelocityX() * updateRatio;
    final float targetY = this.y + this.getVelocityY() * updateRatio;

    if (targetX == this.x && targetY == this.y) {
      return;
    }

    if (this.checkForCollision(emitterOrigin, targetX, targetY)) {
      return;
    }

    if (this.getVelocityX() != 0) {
      this.x = targetX;
    }

    if (this.getVelocityY() != 0) {
      this.y = targetY;
    }

    if (this.getAccelerationX() != 0) {
      this.velocityX += this.getAccelerationX() * updateRatio;
    }

    if (this.getAccelerationY() != 0) {
      this.velocityY += this.getAccelerationY() * updateRatio;
    }
}
}
```
```java
class de.gurkenlabs.litiengine.graphics.animation.Animation {
@Override
  public void start() {
    this.playing = true;
    if (this.getKeyframes().isEmpty()) {
      return;
    }

    this.restart();
}@Override
  public void update() {
    // do nothing if the animation is not playing or the current keyframe is not finished
    if (!this.isPlaying()
        || Game.time().since(this.lastFrameUpdate) < this.getCurrentKeyFrame().getDuration()) {
      return;
    }

    // if we are not looping and the last keyframe is finished, we terminate the animation
    if (!this.isLooping() && this.isLastKeyFrame()) {
      this.terminate();
      return;
    }

    // make sure, we stay inside the keyframe list
    final int newFrameIndex =
        (this.getKeyframes().indexOf(this.currentFrame) + 1) % this.getKeyframes().size();
    final KeyFrame previousFrame = this.currentFrame;
    this.currentFrame = this.getKeyframes().get(newFrameIndex);

    for (KeyFrameListener listener : this.listeners) {
      listener.currentFrameChanged(previousFrame, this.currentFrame);
    }

    this.lastFrameUpdate = Game.loop().getTicks();
}
}
```
```java
class de.gurkenlabs.litiengine.graphics.animation.AnimationController {
@Override
  public void update() {
    for (final Animation animation : this.getAll()) {
      animation.update();
    }

    if (this.getCurrent() != null && this.getCurrent().isPaused()) {
      return;
    }

    final boolean playbackFinished = this.getCurrent() != null && !this.getCurrent().isPlaying();
    if (playbackFinished) {
      for (final AnimationListener listener : this.listeners) {
        listener.finished(this.getCurrent());
      }
    }

    if (this.getCurrent() == null || playbackFinished) {
      if (this.getDefault() != null) {
        this.play(this.getDefault().getName());
      } else {
        this.currentAnimation = null;
      }
    }
}
}
```
```java
class de.gurkenlabs.litiengine.graphics.RenderComponent {
private void handleFade() {
    if (this.fadeOutStart != -1) {
      final long timePassed = Game.time().since(this.fadeOutStart);
      this.currentAlpha = MathUtilities.clamp(1 - timePassed / (float) this.fadeOutTime, 0, 1);
      if (this.currentAlpha == 0f) {
        this.fadeOutStart = -1;
        this.fadeOutTime = -1;
      }

      return;
    }

    if (this.fadeInStart != -1) {
      final long timePassed = Game.time().since(this.fadeInStart);
      this.currentAlpha = MathUtilities.clamp(timePassed / (float) this.fadeInTime, 0, 1);
      if (this.currentAlpha == 1f) {
        this.fadeInStart = -1;
        this.fadeInTime = -1;
        this.currentAlpha = Float.NaN;
      }
    }
}public void fadeOut(final int ms) {
    this.fadeInStart = -1;
    this.fadeInTime = -1;
    this.fadeOutStart = Game.time().now();
    this.fadeOutTime = ms;
}public void fadeIn(final int ms) {
    this.fadeOutStart = -1;
    this.fadeOutTime = -1;
    this.fadeInStart = Game.time().now();
    this.fadeInTime = ms;
}
}
```
```java
class de.gurkenlabs.litiengine.entities.Trigger {
private boolean activate(final IEntity activator, final int tar) {
    if (!this.isLoaded()
        || this.isOneTimeTrigger && this.isActivated
        || this.getActivationType() == TriggerActivation.COLLISION
            && activator != null
            && this.collisionActivated.contains(activator)) {
      return false;
    }

    if (this.getCooldown() > 0 && Game.time().since(this.lastActivation) < this.getCooldown()) {
      return false;
    }

    List<Integer> triggerTargets = this.getTargets(tar);

    final TriggerEvent te = new TriggerEvent(this, activator, triggerTargets);

    if (!this.checkActivationPredicates(te)) {
      return false;
    }

    this.isActivated = true;
    if (activator != null) {
      this.collisionActivated.add(activator);
    }

    // if we actually have a trigger target, we send the message to the target
    for (final int target : triggerTargets) {
      final IEntity entity = this.getEnvironment().get(target);
      if (entity == null) {
        log.log(
            Level.WARNING,
            "trigger [{0}] was activated, but the trigger target [{1}] could not be found on the environment",
            new Object[] {this, target});
        continue;
      }

      entity.sendMessage(this, this.message);
    }

    // also send the trigger event to all registered consumers
    for (final TriggerActivatedListener listener : this.activatedListeners) {
      listener.activated(te);
    }

    if (this.isOneTimeTrigger) {
      this.getEnvironment().remove(this);
    }

    this.lastActivation = Game.time().now();
    return true;
}
}
```
```java
class de.gurkenlabs.litiengine.graphics.Camera {
private boolean isShakeEffectActive() {
    return this.getShakeTick() != 0
        && Game.time().since(this.getShakeTick()) < this.getShakeDuration();
}@Override
  public void update() {
    if (Game.world().camera() != null && !Game.world().camera().equals(this)) {
      return;
    }

    if (this.targetZoom > 0) {
      if (Game.time().since(this.zoomTick) >= this.zoomDelay) {
        this.zoom = this.targetZoom;
        this.targetZoom = 0;
        this.zoomDelay = 0;
        this.zoomTick = 0;
        this.zoomStep = 0;
      } else {
        this.zoom += this.zoomStep;
      }

      final ZoomChangedEvent event = new ZoomChangedEvent(this, this.getZoom());
      for (final ZoomChangedListener listener : this.zoomListeners) {
        listener.zoomChanged(event);
      }
    }

    if (this.panTime > 0) {
      if (--this.panTime <= 0) {
        this.setFocus(this.targetFocus);
        this.targetFocus = null;
      } else {
        double diff = this.panTime / (this.panTime + 1.0);
        this.focus =
            new Point2D.Double(
                this.focus.getX() * diff + this.targetFocus.getX() * (1.0 - diff),
                this.focus.getY() * diff + this.targetFocus.getY() * (1.0 - diff));
      }
    }

    if (!this.isShakeEffectActive()) {
      this.shakeOffsetX = 0;
      this.shakeOffsetY = 0;
      return;
    }

    if (Game.time().since(this.lastShake) > this.shakeDelay) {
      this.shakeOffsetX = this.getShakeIntensity() * ThreadLocalRandom.current().nextGaussian();
      this.shakeOffsetY = this.getShakeIntensity() * ThreadLocalRandom.current().nextGaussian();
      this.lastShake = Game.time().now();
    }
}@Override
  public void setZoom(final float targetZoom, final int delay) {
    if (delay == 0) {

      this.zoom = targetZoom;
      this.targetZoom = 0;
      this.zoomDelay = 0;
      this.zoomTick = 0;
      this.zoomStep = 0;

      final ZoomChangedEvent event = new ZoomChangedEvent(this, targetZoom);
      for (final ZoomChangedListener listener : this.zoomListeners) {
        listener.zoomChanged(event);
      }
    } else {
      this.zoomTick = Game.time().now();
      this.targetZoom = targetZoom;
      this.zoomDelay = delay;

      final double tickduration = 1000 / (double) Game.loop().getTickRate();
      final double tickAmount = delay / tickduration;
      final float totalDelta = this.targetZoom - this.zoom;
      this.zoomStep = tickAmount > 0 ? (float) (totalDelta / tickAmount) : totalDelta;
    }
}@Override
  public void shake(final double intensity, final int delay, final int shakeDuration) {
    this.shakeTick = Game.time().now();
    this.shakeDelay = delay;
    this.shakeIntensity = intensity;
    this.shakeDuration = shakeDuration;
}
}
```
```java
class de.gurkenlabs.litiengine.entities.Creature {
public void setSpritesheetName(String spritesheetName) {
    if (this.spritesheetName != null && this.spritesheetName.equals(spritesheetName)) {
      return;
    }

    this.spritesheetName = spritesheetName;
    this.updateAnimationController();
}public boolean isIdle() {
    return Game.time().since(this.lastMoved) > IDLE_DELAY;
}@Override
  public void setLocation(final Point2D position) {
    if (this.isDead() || position == null) {
      return;
    }

    final Point2D oldLocation = this.getLocation();
    super.setLocation(position);

    if (Game.hasStarted() && this.isLoaded()) {
      this.lastMoved = Game.time().now();
      this.fireMovedEvent(
          new EntityMovedEvent(
              this, this.getX() - oldLocation.getX(), this.getY() - oldLocation.getY()));
    }
}
}
```
```java
class de.gurkenlabs.litiengine.gui.screens.ScreenManager {
public void display(final String screenName) {
    if (this.current() != null && this.current().getName().equalsIgnoreCase(screenName)) {
      log.log(
          Level.INFO,
          "Skipping displaying of screen {0} because it is already the current screen.",
          screenName);
      return;
    }

    if (this.screens.stream()
        .noneMatch(element -> element.getName().equalsIgnoreCase(screenName))) {
      log.log(
          Level.WARNING,
          "Could not display the screen {0} because there is no screen with the specified name.",
          screenName);
      return;
    }

    Screen screen = this.get(screenName);
    if (screen == null) {
      return;
    }

    this.display(screen);
}public void add(final Screen screen) {
    screen.setWidth(Game.window().getWidth());
    screen.setHeight(Game.window().getHeight());
    this.screens.add(screen);

    if (this.current() == null) {
      this.display(screen);
    }
}public void remove(Screen screen) {
    this.screens.remove(screen);
    if (this.current() == screen) {
      if (!this.screens.isEmpty()) {
        this.display(this.screens.get(0));
      } else {
        this.display((Screen) null);
      }
    }
}public void display(@Nullable final Screen screen) {
    if (Game.hasStarted() && Game.time().since(this.lastScreenChange) < this.getChangeCooldown()) {
      log.log(
          Level.INFO,
          "Skipping displaying of screen {0} because screen changing is currently on cooldown.",
          screen != null ? screen.getName() : "");
      return;
    }

    final Screen previous = this.current();
    if (previous != null) {
      previous.suspend();
    }

    if (screen != null && !this.screens.contains(screen)) {
      this.screens.add(screen);
    }

    this.currentScreen = screen;
    if (!Game.isInNoGUIMode() && this.current() != null) {
      this.current().prepare();
    }

    this.lastScreenChange = Game.loop().getTicks();

    final ScreenChangedEvent event = new ScreenChangedEvent(this.current(), previous);
    for (final ScreenChangedListener listener : this.screenChangedListeners) {
      listener.changed(event);
    }
}
}
```
```java
class de.gurkenlabs.litiengine.abilities.Ability {
public boolean isOnCooldown() {
    return (this.getCurrentExecution() != null
        && this.getCurrentExecution().getExecutionTicks() > 0
        && Game.time().since(this.getCurrentExecution().getExecutionTicks())
            < this.getAttributes().cooldown().get());
}public boolean isActive() {
    return this.getCurrentExecution() != null
        && Game.time().since(this.getCurrentExecution().getExecutionTicks())
            < this.getAttributes().duration().get();
}@Nullable
  public AbilityExecution cast() {
    if (!this.canCast()) {
      return null;
    }
    this.currentExecution = new AbilityExecution(this);

    for (final AbilityCastListener listener : this.abilityCastListeners) {
      listener.abilityCast(this.currentExecution);
    }

    return this.getCurrentExecution();
}public float getRemainingCooldownInSeconds() {
    if (this.getCurrentExecution() == null
        || this.getExecutor() == null
        || this.getExecutor().isDead()) {
      return 0;
    }

    // calculate cooldown in seconds
    return (float)
        (!this.canCast()
            ? (this.getAttributes().cooldown().get()
                    - Game.time().since(this.getCurrentExecution().getExecutionTicks()))
                * 0.001
            : 0);
}
}
```
```java
class de.gurkenlabs.litiengine.entities.EntityHitEvent {
EntityHitEvent(
      final ICombatEntity hitEntity,
      @Nullable final Ability ability,
      final int damage,
      final boolean kill) {
    super(hitEntity);
    this.executor = ability != null ? ability.getExecutor() : null;
    this.hitEntity = hitEntity;
    this.ability = ability;
    this.damage = damage;
    this.kill = kill;
    this.time = Game.time().now();
}
}
```
```java
class de.gurkenlabs.litiengine.graphics.emitters.Emitter {
public void delete() {
    this.deactivate();
    if (Game.world().environment() != null) {
      Game.world().environment().remove(this);
    }
}public void activate() {
    if (this.activated) {
      return;
    }

    this.activated = true;
    this.activationTick = Game.time().now();
    Game.loop().attach(this);
}@Override
  public void update() {
    if (this.isPaused()) {
      return;
    }

    // clear particles if the effect time to life is reached
    if (this.isFinished()) {
      for (EmitterFinishedListener listener : this.finishedListeners) {
        listener.finished(this);
      }

      this.delete();
      return;
    }

    final float updateRatio = (float) this.data().getUpdateRate() / Game.loop().getTickRate();
    for (final Particle p : this.getParticles().stream().collect(Collectors.toList())) {
      if (this.particleCanBeRemoved(p)) {
        // remove dead particles
        this.particles.remove(p);
        continue;
      }

      p.update(this.getOrigin(), updateRatio);
    }

    this.aliveTime = Game.time().since(this.activationTick);
    if ((this.data().getSpawnRate() == 0
        || Game.time().since(this.lastSpawn) >= this.data().getSpawnRate())) {
      this.lastSpawn = Game.time().now();
      this.spawnParticle();
    }
}
}
```
```java
class de.gurkenlabs.litiengine.GameLoop {
@Override
  public int perform(int delay, Runnable action) {
    final long d = Game.time().toTicks(delay);

    TimedAction a = new TimedAction(this.getTicks() + d, action);
    this.actions.add(a);

    return a.getId();
}
}
```
```java
class de.gurkenlabs.litiengine.environment.EntitySpawner {
protected boolean shouldSpawn() {
    return this.lastSpawnWave == 0
        || Game.time().since(this.lastSpawnWave) >= this.getSpawnInterval();
}@Override
  public void update() {
    if (!this.shouldSpawn()) {
      return;
    }

    this.spawnNewEntities();
    this.lastSpawnWave = Game.time().now();
}
}
```
```java
class de.gurkenlabs.litiengine.graphics.FreeFlightCamera {
@Override
  public void update() {
    this.handleFreeFlightCamera();
}public FreeFlightCamera(double x, double y) {
    this(new Point2D.Double(x, y));
}
}
```
```java
class de.gurkenlabs.litiengine.environment.Environment {
public void unload() {
    if (!this.loaded) {
      return;
    }

    // unregister all updatable entities from the current environment
    for (final IEntity entity : this.allEntities.values()) {
      this.unload(entity);
    }

    this.loaded = false;
    this.fireEvent(l -> l.unloaded(this));
}private static void loadUpdatableOrEmitterEntity(IEntity entity) {
    if (entity instanceof Emitter) {
      final Emitter emitter = (Emitter) entity;
      if (emitter.isActivateOnInit()) {
        emitter.activate();
      }
    } else if (entity instanceof IUpdateable) {
      Game.loop().attach((IUpdateable) entity);
    }
}public void clear() {
    Game.physics().clear();

    this.combatEntities.clear();
    this.mobileEntities.clear();
    this.gravityForces.clear();
    this.layerEntities.clear();
    this.entitiesByTag.clear();
    this.allEntities.clear();

    for (RenderType renderType : RenderType.values()) {
      this.miscEntities.get(renderType).clear();
      this.renderListeners.get(renderType).clear();
      this.renderables.get(renderType).clear();
    }

    dispose(this.allEntities.values());
    dispose(this.triggers);
    this.emitters.clear();
    this.colliders.clear();
    this.props.clear();
    this.creatures.clear();
    this.staticShadows.clear();
    this.combatEntities.clear();
    this.mobileEntities.clear();
    this.lightSources.clear();
    this.spawnPoints.clear();
    this.soundSources.clear();
    this.mapAreas.clear();
    this.triggers.clear();

    this.ambientLight = null;
    this.staticShadowLayer = null;

    for (Map<Integer, IEntity> type : this.miscEntities.values()) {
      type.clear();
    }

    this.initialized = false;

    this.fireEvent(l -> l.cleared(this));
}private void load(final IEntity entity) {
    // an entity can only exist on one environment at a time, so remove it from the current one
    if (entity.getEnvironment() != null) {
      entity.getEnvironment().remove(entity);
    }

    // 1. add to physics engine
    loadPhysicsEntity(entity);

    // 2. register for update or activate
    loadUpdatableOrEmitterEntity(entity);

    // 3. if a gravity is defined, add a gravity force to the entity
    if (entity instanceof IMobileEntity && this.getGravity() != 0) {
      this.addGravityForce((IMobileEntity) entity);
    }

    // 4. attach all controllers
    entity.attachControllers();

    if (this.loaded && (entity instanceof LightSource || entity instanceof StaticShadow)) {
      this.updateLighting(entity);
    }

    entity.loaded(this);
}private void unload(final IEntity entity) {
    // 1. remove from physics engine
    if (entity instanceof ICollisionEntity) {
      Game.physics().remove((ICollisionEntity) entity);
    }

    // 2. unregister from update
    if (entity instanceof IUpdateable) {
      Game.loop().detach((IUpdateable) entity);
    }

    if (entity instanceof IMobileEntity) {
      this.removeGravity((IMobileEntity) entity);
    }

    // 3. detach all controllers
    entity.detachControllers();

    if (entity instanceof Emitter) {
      Emitter em = (Emitter) entity;
      em.deactivate();
    }

    if (this.loaded && (entity instanceof LightSource || entity instanceof StaticShadow)) {
      this.updateLighting(entity);
    }

    entity.removed(this);
}public void remove(final IEntity entity) {
    if (entity == null) {
      return;
    }

    this.allEntities.remove(entity.getMapId());
    Iterator<List<IEntity>> iter = this.layerEntities.values().iterator();
    while (iter.hasNext()) {
      List<IEntity> layer = iter.next();
      if (layer.remove(entity) && layer.isEmpty()) {
        iter.remove();
      }
    }
    if (this.miscEntities.get(entity.getRenderType()) != null) {
      this.miscEntities.get(entity.getRenderType()).values().remove(entity);
    }

    for (String tag : entity.getTags()) {
      if (this.getEntitiesByTag().containsKey(tag)) {
        this.getEntitiesByTag().get(tag).remove(entity);

        if (this.getEntitiesByTag().get(tag).isEmpty()) {
          this.getEntitiesByTag().remove(tag);
        }
      }
    }

    if (entity instanceof Emitter) {
      Emitter emitter = (Emitter) entity;
      this.removeEmitter(emitter);
    }

    if (entity instanceof MapArea) {
      this.mapAreas.remove(entity);
    }

    if (entity instanceof Prop) {
      this.props.remove(entity);
    }

    if (entity instanceof Creature) {
      this.creatures.remove(entity);
    }

    if (entity instanceof CollisionBox) {
      this.colliders.remove(entity);
      this.staticShadows.removeIf(x -> x.getOrigin() != null && x.getOrigin().equals(entity));
    }

    if (entity instanceof LightSource) {
      this.lightSources.remove(entity);
      this.updateLighting(entity);
    }

    if (entity instanceof Trigger) {
      this.triggers.remove(entity);
    }

    if (entity instanceof Spawnpoint) {
      this.spawnPoints.remove(entity);
    }
    if (entity instanceof SoundSource) {
      this.soundSources.remove(entity);
    }

    if (entity instanceof StaticShadow) {
      this.staticShadows.remove(entity);
      this.updateLighting(entity);
    }

    if (entity instanceof IMobileEntity) {
      this.mobileEntities.values().remove(entity);
    }

    if (entity instanceof ICombatEntity) {
      this.combatEntities.values().remove(entity);
    }

    this.unload(entity);

    this.fireEntityEvent(l -> l.entityRemoved(entity));
}
}
```
```java
class de.gurkenlabs.litiengine.physics.MovementController {
@Override
  public void update() {
    this.handleForces();
    this.handleMovement();
}
}
```
```java
class de.gurkenlabs.litiengine.Game {
static synchronized void terminate() {
    if (!initialized) {
      return;
    }

    hasStarted = false;
    initialized = false;

    config().save();
    gameLoop.terminate();
    tweenEngine.terminate();
    soundEngine.terminate();

    world().clear();

    for (final GameListener listener : gameListeners) {
      try {
        listener.terminated();
      } catch (Exception e) {
        log().log(Level.WARNING, "game listener threw an exception during shutdown", e);
      }
    }

    gameLoop = null;
    screenManager = null;
    gameWindow = null;
}public static synchronized void start() {
    if (!initialized) {
      throw new IllegalStateException(
          "The game cannot be started without being first initialized. Call Game.init(...) before Game.start().");
    }

    gameLoop.start();
    tweenEngine.start();
    soundEngine.start();

    for (final GameListener listener : gameListeners) {
      listener.started();
    }

    hasStarted = true;
}public static synchronized void init(String... args) {
    if (initialized) {
      log().log(Level.INFO, "The game has already been initialized.");
      return;
    }

    log.init();
    handleCommandLineArguments(args);

    config().load();
    Locale.setDefault(new Locale(config().client().getCountry(), config().client().getLanguage()));

    gameLoop = new GameLoop("Main Update Loop", config().client().getMaxFps());
    loop().attach(physics());
    loop().attach(world());

    // setup default exception handling for render and update loop
    setUncaughtExceptionHandler(
        new DefaultUncaughtExceptionHandler(config().client().exitOnError()));

    screenManager = new ScreenManager();
    gameWindow = new GameWindow();

    // initialize  the game window
    window().init();
    world.setCamera(new Camera());

    for (GameListener listener : gameListeners) {
      listener.initialized(args);
    }

    if (!isInNoGUIMode()) {
      window().getRenderComponent().onRendered(g -> metrics().render(g));

      graphics()
          .addEntityRenderedListener(
              e -> DebugRenderer.renderEntityDebugInfo(e.getGraphics(), e.getEntity()));

      window().getRenderComponent().onFpsChanged(fps -> metrics().setFramesPerSecond(fps));
      window()
          .setIcons(
              Arrays.asList(
                  Resources.images().get("liti-logo-x16.png"),
                  Resources.images().get("liti-logo-x20.png"),
                  Resources.images().get("liti-logo-x32.png"),
                  Resources.images().get("liti-logo-x48.png")));

      Input.keyboard()
          .onKeyTyped(
              KeyEvent.VK_PRINTSCREEN,
              key -> {
                // don't take a screenshot if a modifier is active
                if (key.getModifiers() != 0) {
                  return;
                }

                window().getRenderComponent().takeScreenshot();
              });
    }

    Runtime.getRuntime().addShutdownHook(new Thread(Game::terminate, "Shutdown"));

    initialized = true;
}
}
```


Response Format:
Provide the answer in **XML format** as follows:

#### If the method **cannot** return `null` at the specific call site:
```xml
<response>
  <reason><![CDATA[EXPLAIN WHY THE INVOCATION Game.loop() RESULT CANNOT BE NULL.]]></reason>
  <value>NO</value>
</response>

#### If the method can return null at the specific call site:
<response>
  <reason><![CDATA[EXPLAIN WHY THE INVOCATION Game.loop() RESULT CAN BE NULL.]]></reason>
  <value>YES</value>
</response>

#### If you are unsure or If there are any methods that directly or indirectly affect the return value and are not fully disclosed, request their declarations first, in the following format:
<response>
  <reason><![CDATA[EXPLAIN WHY THIS METHOD DECLARATION IS NECESSARY AND WHY YOU CANNOT MAKE A CONFIDENT DECISION WITHOUT IT]]></reason>
  <success>false</success>
  <methods>
    <method>methodName</method>
  </methods>
</response>

Additional Notes:
Be precise in your reasoning.
If a method’s return value depends on another method not provided, request its declaration before making a conclusion.
If the method can return null in this case but not in others, explain why it happens specifically for this call.

---ChatGPT.sendRequestToOpenAI---
Retrieving response from cache
---Response.<init>---
Creating Response:
```xml
<response>
  <reason><![CDATA[The method `Game.loop()` returns the static field `gameLoop`, which is initialized in the `Game.init(String... args)` method. In this method, a new `GameLoop` object is instantiated and assigned to `gameLoop`. Since `init()` must be called before `start()`, which is implied by the requirement of initializing the game, the `gameLoop` is guaranteed to be non-null during the lifetime of the game execution where `Game.loop()` is called. The absence of any code that could set `gameLoop` to null after its initialization ensures that `Game.loop()` cannot return null.]]></reason>
  <value>NO</value>
</response>
```
---Response.<init>---
Response created:
Disagreement: The method `Game.loop()` returns the static field `gameLoop`, which is initialized in the `Game.init(String... args)` method. In this method, a new `GameLoop` object is instantiated and assigned to `gameLoop`. Since `init()` must be called before `start()`, which is implied by the requirement of initializing the game, the `gameLoop` is guaranteed to be non-null during the lifetime of the game execution where `Game.loop()` is called. The absence of any code that could set `gameLoop` to null after its initialization ensures that `Game.loop()` cannot return null.
---AdvancedNullAwayCodeFix.resolveMethodDereferenceError---
Method is not returning nullable on call site. Injecting suppression annotation.
---AdvancedNullAwayCodeFix.constructCastToNonnullChange---
Constructing cast to nonnull change for reason: The method `Game.loop()` returns the static field `gameLoop`, which is initialized in the `Game.init(String... args)` method. In this method, a new `GameLoop` object is instantiated and assigned to `gameLoop`. Since `init()` must be called before `start()`, which is implied by the requirement of initializing the game, the `gameLoop` is guaranteed to be non-null during the lifetime of the game execution where `Game.loop()` is called. The absence of any code that could set `gameLoop` to null after its initialization ensures that `Game.loop()` cannot return null.
---ChatGPT.ask---
Asking ChatGPT:
For the reason you mentioned earlier:

"The method `Game.loop()` returns the static field `gameLoop`, which is initialized in the `Game.init(String... args)` method. In this method, a new `GameLoop` object is instantiated and assigned to `gameLoop`. Since `init()` must be called before `start()`, which is implied by the requirement of initializing the game, the `gameLoop` is guaranteed to be non-null during the lifetime of the game execution where `Game.loop()` is called. The absence of any code that could set `gameLoop` to null after its initialization ensures that `Game.loop()` cannot return null."

in the method below, the expression Game.loop() is not nullable at the point it is used.

```java
private void handleFreeFlightCamera() {
    if (Game.world().environment() == null || Game.world().environment().getMap() == null) {
      return;
    }

    final Point2D mouseLocation = Input.mouse().getLocation();

    final double scrollSpeed =
        this.getVelocity()
            / (double) Game.loop().getTickRate()
            * Game.config().input().getMouseSensitivity();

    double x = this.getFocus().getX();
    double y = this.getFocus().getY();

    double deltaX = 0;
    if (mouseLocation.getX() < this.getScrollPadding()) {
      deltaX -= scrollSpeed;
    } else if (Game.window().getResolution().getWidth() - mouseLocation.getX()
        < this.getScrollPadding()) {
      deltaX += scrollSpeed;
    }

    double deltaY = 0;
    if (mouseLocation.getY() < this.getScrollPadding()) {
      deltaY -= scrollSpeed;
    } else if (Game.window().getResolution().getHeight() - mouseLocation.getY()
        < this.getScrollPadding()) {
      deltaY += scrollSpeed;
    }

    x += deltaX;
    y += deltaY;

    this.setFocus(new Point2D.Double(x, y));
}
```
Please Summarize the reason in max 5 words and rewrite the method so that at the line "            / (double) Game.loop().getTickRate()", at the occurrence of: "Game.loop()" is replaced with `NullabilityUtil.castToNonnull(Game.loop(), summary of reason)`
Replace "REASON" with the exact reason summary I provide to you (maximum 5 words), not with a generic explanation like "checked to be nonnull".
see the example below, for expression `foo.getBar()`, to wrap it with `NullabilityUtil.castToNonnull(foo.getBar(), "reason")`.

```java
public t(){
    String l = foo.getBar();
}
```

will be:
```java
public t(){
    String l = NullabilityUtil.castToNonnull(foo.getBar(), "checked to be nonnull");
}
```

### Instructions:

Do not import any additional classes.

Do not add Java comments.

Only modify relevant lines as required.

Return only the modified method wrapped in the XML format shown below.

Place the Java code inside the <code> tag using a CDATA block with ```java formatting.

Just give me the fixed code snippet in XML format in <response> tag like the example below. I will apply the fix to my codebase. Do not import any additional libraries or classes or add java comments. If you can provide the fixed code snippet, please provide it in the following format and place the code snippet in the <code> tag within ```java block.
<response>
  <success>true</success>
  <code><![CDATA[
  ```java
  Your fixed code snippet here
  ```
    ]]>
  </code>
</response>

---ChatGPT.sendRequestToOpenAI---
Retrieving response from cache
---Response.<init>---
Creating Response:
<response>
  <success>true</success>
  <code><![CDATA[
  ```java
private void handleFreeFlightCamera() {
    if (Game.world().environment() == null || Game.world().environment().getMap() == null) {
      return;
    }

    final Point2D mouseLocation = Input.mouse().getLocation();

    final double scrollSpeed =
        this.getVelocity()
            / (double) NullabilityUtil.castToNonnull(Game.loop(), "properly initialized").getTickRate()
            * Game.config().input().getMouseSensitivity();

    double x = this.getFocus().getX();
    double y = this.getFocus().getY();

    double deltaX = 0;
    if (mouseLocation.getX() < this.getScrollPadding()) {
      deltaX -= scrollSpeed;
    } else if (Game.window().getResolution().getWidth() - mouseLocation.getX()
        < this.getScrollPadding()) {
      deltaX += scrollSpeed;
    }

    double deltaY = 0;
    if (mouseLocation.getY() < this.getScrollPadding()) {
      deltaY -= scrollSpeed;
    } else if (Game.window().getResolution().getHeight() - mouseLocation.getY()
        < this.getScrollPadding()) {
      deltaY += scrollSpeed;
    }

    x += deltaX;
    y += deltaY;

    this.setFocus(new Point2D.Double(x, y));
}
  ```
    ]]>
  </code>
</response>
---Response.<init>---
Response created:
private void handleFreeFlightCamera() {
    if (Game.world().environment() == null || Game.world().environment().getMap() == null) {
      return;
    }

    final Point2D mouseLocation = Input.mouse().getLocation();

    final double scrollSpeed =
        this.getVelocity()
            / (double) NullabilityUtil.castToNonnull(Game.loop(), "properly initialized").getTickRate()
            * Game.config().input().getMouseSensitivity();

    double x = this.getFocus().getX();
    double y = this.getFocus().getY();

    double deltaX = 0;
    if (mouseLocation.getX() < this.getScrollPadding()) {
      deltaX -= scrollSpeed;
    } else if (Game.window().getResolution().getWidth() - mouseLocation.getX()
        < this.getScrollPadding()) {
      deltaX += scrollSpeed;
    }

    double deltaY = 0;
    if (mouseLocation.getY() < this.getScrollPadding()) {
      deltaY -= scrollSpeed;
    } else if (Game.window().getResolution().getHeight() - mouseLocation.getY()
        < this.getScrollPadding()) {
      deltaY += scrollSpeed;
    }

    x += deltaX;
    y += deltaY;

    this.setFocus(new Point2D.Double(x, y));
}
---ChatGPT.fixDereferenceByAddingCastToNonnull---
Fixing the error by adding castToNonnull
---AdvancedNullAwayCodeFix.fixTriggeredErrorsForLocation---
Resolving unresolvable error for triggered error: Type='DEREFERENCE_NULLABLE', message='dereferenced expression Game.loop() is @Nullable'
/home/nima/Developer/nullness-benchmarks/litiengine/src/de/gurkenlabs/litiengine/abilities/effects/Effect.java:84
      Game.loop().attach(this);
---AdvancedNullAwayCodeFix.fix---
Fixing error: Type='DEREFERENCE_NULLABLE', message='dereferenced expression Game.loop() is @Nullable'
/home/nima/Developer/nullness-benchmarks/litiengine/src/de/gurkenlabs/litiengine/abilities/effects/Effect.java:84
      Game.loop().attach(this);
---AdvancedNullAwayCodeFix.resolveDereferenceError---
Resolving dereference error: Type='DEREFERENCE_NULLABLE', message='dereferenced expression Game.loop() is @Nullable'
/home/nima/Developer/nullness-benchmarks/litiengine/src/de/gurkenlabs/litiengine/abilities/effects/Effect.java:84
      Game.loop().attach(this);
---AdvancedNullAwayCodeFix.resolveDereferenceError---
Checking nullability possibility at error point
---ChatGPT.checkNullabilityPossibilityAtErrorPoint---
Asking if the expression can be null at error point point
---ChatGPT.ask---
Asking ChatGPT:
In the method below, is there a possibility that the expression "Game.loop()" at line "Game.loop().attach(this);" is null?
public void apply(final Shape impactArea) {
    final List<ICombatEntity> affected = this.lookForAffectedEntities(impactArea);
    for (final ICombatEntity affectedEntity : affected) {
      this.apply(affectedEntity);
    }

    this.appliances.add(new EffectApplication(affected, impactArea));

    // if it is the first appliance -> register for update
    if (this.appliances.size() == 1) {
      Game.loop().attach(this);
    }
}
Give a single-word answer in XML format. If it is possible for the expression to be null, respond with:
```xml
<response>
    <reason><![CDATA[YOUR REASON]]></reason>
    <value>YES</value>
</response>
```
If it is not possible for the expression to be null, respond with:
```xml
<response>
    <reason><![CDATA[YOUR REASON]]></reason>
    <value>NO</value>
</response>
```
If you are unsure or need more information, respond with where you can ask for more details or what specific information you need.

If additional information is required, list each request inside a `<request>` tag. If no additional information is needed, omit the `<requests>` section.

Respond with:
```xml
<response>
    <reason><![CDATA[YOUR REASON]]></reason>
    <value>UNKNOWN</value>
    <!-- Include <requests> only if additional information is needed -->
    <requests>
        <request><![CDATA[YOUR REQUEST 1]]></request>
        <request><![CDATA[YOUR REQUEST 2]]></request>
    </requests>
</response>
```
---ChatGPT.sendRequestToOpenAI---
Retrieving response from cache
---Response.<init>---
Creating Response:
```xml
<response>
    <reason><![CDATA[The nullability of Game.loop() depends on the implementation of the Game class, which is not provided in the given context. Without knowledge of how Game.loop() is implemented and initialized, it is impossible to determine if it can be null.]]></reason>
    <value>UNKNOWN</value>
    <requests>
        <request><![CDATA[Please provide the implementation details of the Game class, specifically the method loop().]]></request>
        <request><![CDATA[Clarify the initialization process of the Game class to determine the state of the loop() method.]]></request>
    </requests>
</response>
```
---Response.<init>---
Response created:
Unknown: The nullability of Game.loop() depends on the implementation of the Game class, which is not provided in the given context. Without knowledge of how Game.loop() is implemented and initialized, it is impossible to determine if it can be null.
---AdvancedNullAwayCodeFix.resolveMethodDereferenceError---
Resolving method dereference error.
---AdvancedNullAwayCodeFix.resolveMethodDereferenceError---
Method is in annotated package. Checking if the method is returning nullable.
---AdvancedNullAwayCodeFix.investigateMethodReturnNullability---
Checking if the method is returning nullable.
---ChatGPT.checkIfMethodIsReturningNullable---
Asking if the method is returning nullable: loop()
---ChatGPT.ask---
Asking ChatGPT:
In the method below, is there a possibility that the method returns null based only on its body? Consider the following points:

- The method may have multiple return paths; consider all return statements.
- If the method calls another method, do not assume its return value unless its full declaration is provided. Request its declaration if needed.
- The method may throw an exception instead of returning null. An exception path should not be considered a null return.
- Ensure you request the declarations of any methods whose return values directly or indirectly impact this method’s return value before making a conclusion.
- Carefully analyze all conditions and prior operations that may guarantee a non-null return value.

@Nullable public static IGameLoop loop() {
    return gameLoop;
}

Here are the method definitions in addition to the method inquired:

Depth: 0
```java
class de.gurkenlabs.litiengine.Game {
@Nullable public static IGameLoop loop() {
    return gameLoop;
}
}
```


Response Format:
Provide the answer in **XML format** as follows:

#### If the method **cannot** return `null`:
```xml
<response>
  <reason><![CDATA[EXPLAIN WHY THE METHOD CANNOT RETURN NULL]]></reason>
  <value>NO</value>
</response>
```

#### If the method can return null:
```xml
<response>
  <reason><![CDATA[EXPLAIN WHY THE METHOD CAN RETURN NULL]]></reason>
  <value>YES</value>
</response>
```

#### If you are unsure or need more information, respond with where you can ask for more details or what specific information you need.

#### If you are unsure or If there are any methods that directly or indirectly affect the return value and are not fully disclosed, request their declarations first, in the following format:
<response>
  <reason><![CDATA[YOUR REASON]]></reason>
  <value>UNKNOWN</value>
  <methods>
    <method>methodName</method>
  </methods>
</response>

If additional information is required other than method declaration, list each request inside a `<request>` tag. If no additional information is needed, omit the `<requests>` section.

Respond with:
```xml
<response>
    <reason><![CDATA[YOUR REASON]]></reason>
    <value>UNKNOWN</value>
    <!-- Include <requests> only if additional information is needed -->
    <requests>
        <request><![CDATA[YOUR REQUEST 1]]></request>
        <request><![CDATA[YOUR REQUEST 2]]></request>
    </requests>
</response>
```

Additional Notes:
Be precise in your reasoning.
If a method’s return value depends on another method not provided, request its declaration before making a conclusion.
If the method can return null in some cases but not others, explain under what conditions it can happen.

---ChatGPT.sendRequestToOpenAI---
Retrieving response from cache
---Response.<init>---
Creating Response:
```xml
<response>
  <reason><![CDATA[The method `loop` returns the variable `gameLoop`. Without the initialization or assignment details of `gameLoop`, it's unclear whether it can be null. The possibility of `gameLoop` being uninitialized or set to null elsewhere in the program means `loop` could potentially return null. Further information on `gameLoop` is required.]]></reason>
  <value>UNKNOWN</value>
  <requests>
    <request><![CDATA[Please provide the declaration and initialization of the variable `gameLoop` in the class `de.gurkenlabs.litiengine.Game`.]]></request>
  </requests>
</response>
```
---Response.<init>---
Response created:
Unknown: The method `loop` returns the variable `gameLoop`. Without the initialization or assignment details of `gameLoop`, it's unclear whether it can be null. The possibility of `gameLoop` being uninitialized or set to null elsewhere in the program means `loop` could potentially return null. Further information on `gameLoop` is required.
---AdvancedNullAwayCodeFix.investigateMethodReturnNullability---
Could not determine the nullability and model did not ask for any method.
---ChatGPT.checkIfMethodIsReturningNullableOnCallSite---
Asking if the method is returning nullable on the call site: Game.loop()
---ChatGPT.ask---
Asking ChatGPT:
In the method below, is there a possibility that the method returns null at the given call site?

```java
@Nullable public static IGameLoop loop() {
    return gameLoop;
}
```

## Guidelines:
- The method may have multiple return paths; consider all return statements.
- If the method calls another method, do not assume its return value unless its full declaration is provided. Request its declaration if needed.
- The method may throw an exception instead of returning null. An exception path should not be considered a null return.
- Ensure you request the declarations of any methods whose return values directly or indirectly impact this method’s return value before making a conclusion.
- If the method returns a value that is determined by a parameter, evaluate based on the actual argument at the given call site.
- Analyze based only on the specific invocation provided. Do not generalize to all possible inputs.- If the return value is guaranteed to be non-null at the call site, the answer should be a definitive NO.
- Do not generalize based on all possible inputs—your answer must be based only on the given invocation.
- Focus only on the given call site, not all possible invocations.

### call site:
Game.loop()

Here are the method definitions and the call chain for this method, showing the sequence of calls from the method to its callers at each depth level:

Depth: 0
```java
class de.gurkenlabs.litiengine.Game {
@Nullable public static IGameLoop loop() {
    return gameLoop;
}
}
```
Depth: 1
```java
class de.gurkenlabs.litiengine.environment.GameWorld {
public void loadEnvironment(@Nullable final Environment env) {
    Lock lock = Game.loop().getLock();
    lock.lock();
    try {
      unloadEnvironment();
      this.environment = env;
      if (env != null) {
        this.addEnvironment(env);

        if (env.getGravity() == 0 && this.gravity() != 0) {
          env.setGravity(this.gravity());
        }

        env.load();
        for (final EnvironmentLoadedListener listener : this.loadedListeners) {
          listener.loaded(env);
        }

        // call map specific listeners
        String mapName = getMapName(env);
        if (mapName != null && this.environmentLoadedListeners.containsKey(mapName)) {

          // for the default camera we center the camera on the environment
          if (this.camera().getClass().equals(Camera.class)) {
            camera().setFocus(env.getCenter());
          }

          for (EnvironmentLoadedListener listener : this.environmentLoadedListeners.get(mapName)) {
            listener.loaded(env);
          }
        }
      }
    } finally {
      lock.unlock();
    }
}public void setCamera(@Nullable final ICamera cam) {
    if (this.camera() != null) {
      Game.loop().detach(camera);
    }

    camera = cam;

    if (cam != null && !Game.isInNoGUIMode()) {
      Game.loop().attach(cam);
      cam.updateFocus();
    }
}
}
```
```java
class de.gurkenlabs.litiengine.entities.behavior.EntityNavigator {
public EntityNavigator(final IMobileEntity entity, final PathFinder pathFinder) {
    this.cancelNavigationConditions = new CopyOnWriteArrayList<>();
    this.listeners = new CopyOnWriteArrayList<>();
    this.entity = entity;
    this.pathFinder = pathFinder;
    this.setAcceptableError(DEFAULT_ACCEPTABLE_ERROR);
    Game.loop().attach(this);
}
}
```
```java
class de.gurkenlabs.litiengine.GameWindow {
private static void initializeWindowEventListeners(Window window) {

    window.addWindowStateListener(
        e -> {
          if (e.getNewState() == Frame.ICONIFIED) {
            Game.loop().setTickRate(ICONIFIED_MAX_FPS);
          } else {
            Game.loop().setTickRate(Game.config().client().getMaxFps());
          }
        });

    window.addWindowFocusListener(
        new WindowFocusListener() {
          @Override
          public void windowLostFocus(WindowEvent e) {
            if (Game.config().graphics().reduceFramesWhenNotFocused()) {
              Game.loop().setTickRate(NONE_FOCUS_MAX_FPS);
            }
          }

          @Override
          public void windowGainedFocus(WindowEvent e) {
            Game.loop().setTickRate(Game.config().client().getMaxFps());
          }
        });

    window.addWindowListener(
        new WindowAdapter() {
          @Override
          public void windowClosing(final WindowEvent event) {
            Game.exit();
          }
        });
}
}
```
```java
class de.gurkenlabs.litiengine.gui.screens.ScreenManager {
public void display(@Nullable final Screen screen) {
    if (Game.hasStarted() && Game.time().since(this.lastScreenChange) < this.getChangeCooldown()) {
      log.log(
          Level.INFO,
          "Skipping displaying of screen {0} because screen changing is currently on cooldown.",
          screen != null ? screen.getName() : "");
      return;
    }

    final Screen previous = this.current();
    if (previous != null) {
      previous.suspend();
    }

    if (screen != null && !this.screens.contains(screen)) {
      this.screens.add(screen);
    }

    this.currentScreen = screen;
    if (!Game.isInNoGUIMode() && this.current() != null) {
      this.current().prepare();
    }

    this.lastScreenChange = Game.loop().getTicks();

    final ScreenChangedEvent event = new ScreenChangedEvent(this.current(), previous);
    for (final ScreenChangedListener listener : this.screenChangedListeners) {
      listener.changed(event);
    }
}
}
```
```java
class de.gurkenlabs.litiengine.abilities.effects.Effect {
@Override
  public void update() {

    for (final Iterator<EffectApplication> iterator = this.getActiveAppliances().iterator();
        iterator.hasNext(); ) {
      final EffectApplication appliance = iterator.next();
      // if the effect duration is reached
      if (this.hasEnded(appliance)) {

        iterator.remove();
        this.cease(appliance);
      }
    }

    // 4. unregister if all appliances are finished
    if (this.getActiveAppliances().isEmpty()) {
      Game.loop().detach(this);
    }
}public void apply(final Shape impactArea) {
    final List<ICombatEntity> affected = this.lookForAffectedEntities(impactArea);
    for (final ICombatEntity affectedEntity : affected) {
      this.apply(affectedEntity);
    }

    this.appliances.add(new EffectApplication(affected, impactArea));

    // if it is the first appliance -> register for update
    if (this.appliances.size() == 1) {
      Game.loop().attach(this);
    }
}
}
```
```java
class de.gurkenlabs.litiengine.GameTime {
public long toTicks(final int milliseconds) {
    return this.toTicks(milliseconds, Game.loop().getTickRate());
}public long since(final long tick) {
    return toMilliseconds(Game.loop().getTicks() - tick);
}public long now() {
    return Game.loop().getTicks();
}public long sinceGameStart() {
    return this.toMilliseconds(Game.loop().getTicks());
}@Override
  public void loaded(Environment environment) {
    environmentLoaded = Game.loop().getTicks();
}public long toMilliseconds(final long ticks) {
    return this.toMilliseconds(ticks, Game.loop().getTickRate());
}
}
```
```java
class de.gurkenlabs.litiengine.GameMetrics {
@Override
  public void render(final Graphics2D g) {
    this.updateMetrics();

    if (!Game.config().client().showGameMetrics()) {
      return;
    }

    this.currentOffsetY = 0;

    g.setColor(this.renderColor);

    // render client metrics
    this.drawTitle(g, "[client]");
    this.drawMetric(g, "fps       : " + this.getFramesPerSecond());
    this.drawMetric(g, "max fps   : " + this.maxFramesPerSecond);
    this.drawMetric(g, "updatables: " + Game.loop().getUpdatableCount());

    // render jvm metrics if debug is enabled
    if (Game.config().debug().isDebugEnabled()) {
      this.drawTitle(g, "[jvm]");
      this.drawMetric(g, "java      : " + this.javaVersion);
      this.drawMetric(g, "memory    : " + String.format("%-5.5s", this.usedMemory) + " MB");
      this.drawMetric(g, "threads   : " + Thread.activeCount());
    }

    // render rendering metrics
    if (!this.renderMetrics.isEmpty()) {
      this.drawTitle(g, "[update]");

      for (RenderMetrics metric : this.renderMetrics) {
        this.drawMetric(g, metric.toString());
      }

      this.renderMetrics.clear();
    }
}
}
```
```java
class de.gurkenlabs.litiengine.graphics.emitters.Emitter {
public void deactivate() {
    if (!this.activated) {
      return;
    }

    this.activated = false;
    this.getParticles().clear();
    this.aliveTime = 0;
    this.activationTick = 0;
    this.lastSpawn = 0;
    Game.loop().detach(this);
}public void activate() {
    if (this.activated) {
      return;
    }

    this.activated = true;
    this.activationTick = Game.time().now();
    Game.loop().attach(this);
}@Override
  public void update() {
    if (this.isPaused()) {
      return;
    }

    // clear particles if the effect time to life is reached
    if (this.isFinished()) {
      for (EmitterFinishedListener listener : this.finishedListeners) {
        listener.finished(this);
      }

      this.delete();
      return;
    }

    final float updateRatio = (float) this.data().getUpdateRate() / Game.loop().getTickRate();
    for (final Particle p : this.getParticles().stream().collect(Collectors.toList())) {
      if (this.particleCanBeRemoved(p)) {
        // remove dead particles
        this.particles.remove(p);
        continue;
      }

      p.update(this.getOrigin(), updateRatio);
    }

    this.aliveTime = Game.time().since(this.activationTick);
    if ((this.data().getSpawnRate() == 0
        || Game.time().since(this.lastSpawn) >= this.data().getSpawnRate())) {
      this.lastSpawn = Game.time().now();
      this.spawnParticle();
    }
}
}
```
```java
class de.gurkenlabs.litiengine.entities.behavior.IBehaviorController {
public default void attach() {
    Game.loop().attach(this);
}public default void detach() {
    Game.loop().detach(this);
}
}
```
```java
class de.gurkenlabs.litiengine.abilities.AbilityExecution {
AbilityExecution(final Ability ability) {
    this.appliedEffects = new CopyOnWriteArrayList<>();
    this.ability = ability;
    this.executionTicks = Game.time().now();
    this.impactArea = ability.calculateImpactArea();
    this.castLocation = ability.getExecutor().getCenter();
    Game.loop().attach(this);
}@Override
  public void update() {
    // if there a no effects to apply -> unregister this instance and we're done
    if (this.getAbility().getEffects().isEmpty()
        || this.getAbility().getEffects().size() == this.getAppliedEffects().size()) {
      Game.loop().detach(this);
      return;
    }

    // handle all effects from the ability that were not applied yet
    for (final Effect effect : this.getAbility().getEffects()) {
      // if the ability was not executed yet or the delay of the effect is not
      // yet reached
      if (this.getAppliedEffects().contains(effect)
          || Game.time().since(this.getExecutionTicks()) < effect.getDelay()) {
        continue;
      }

      effect.apply(this.getExecutionImpactArea());
      this.getAppliedEffects().add(effect);
    }
}
}
```
```java
class de.gurkenlabs.litiengine.GameWindow$3 {
@Override
          public void windowGainedFocus(WindowEvent e) {
            Game.loop().setTickRate(Game.config().client().getMaxFps());
}@Override
          public void windowLostFocus(WindowEvent e) {
            if (Game.config().graphics().reduceFramesWhenNotFocused()) {
              Game.loop().setTickRate(NONE_FOCUS_MAX_FPS);
            }
}
}
```
```java
class de.gurkenlabs.litiengine.environment.EntitySpawner {
protected void spawnNewEntities() {
    if (this.getSpawnMode() != SpawnMode.CUSTOMSPAWNPOINTS && this.getSpawnPoints().isEmpty()) {
      return;
    }

    switch (this.getSpawnMode()) {
      case ALLSPAWNPOINTS:
        for (int i = 0; i < this.getSpawnPoints().size(); i++) {
          final int index = i;
          Game.loop()
              .perform(
                  this.getSpawnDelay() + this.getSpawnDelay() * i,
                  () -> this.spawn(this.getSpawnPoints().get(index), this.getSpawnAmount()));
        }
        break;
      case ONERANDOMSPAWNPOINT:
        this.spawn(Game.random().choose(this.getSpawnPoints()), this.getSpawnAmount());
        break;
      case RANDOMSPAWNPOINTS:
        for (int i = 0; i < this.getSpawnAmount(); i++) {
          Game.loop()
              .perform(
                  this.getSpawnDelay() + this.getSpawnDelay() * i,
                  () -> this.spawn(Game.random().choose(this.getSpawnPoints()), 1));
        }
        break;
      case CUSTOMSPAWNPOINTS:
        List<Spawnpoint> spawnPoints =
            this.customSpawnpoints != null
                ? this.customSpawnpoints.apply(this)
                : this.getCustomSpawnpoints();

        int index = 0;
        for (Spawnpoint spawn : spawnPoints) {
          Game.loop()
              .perform(
                  this.getSpawnDelay() + this.getSpawnDelay() * index, () -> this.spawn(spawn, 1));
          index++;
        }
        break;
      default:
        break;
    }
}
}
```
```java
class de.gurkenlabs.litiengine.tweening.TweenEngine {
@Override
  public void start() {
    Game.loop().attach(this);
}@Override
  public void terminate() {
    Game.loop().detach(this);
}
}
```
```java
class de.gurkenlabs.litiengine.gui.SpeechBubble {
public void hide() {
    Game.world().environment().removeRenderable(this);
    Game.loop().detach(this);
    if (activeSpeechBubbles.get(this.getEntity()) != null
        && activeSpeechBubbles.remove(this.getEntity()).equals(this)) {
      activeSpeechBubbles.remove(this.getEntity());
    }

    for (SpeechBubbleListener listener : this.listeners) {
      listener.hidden();
    }
}private SpeechBubble(
      final IEntity entity,
      final String text,
      @Nullable SpeechBubbleAppearance appearance,
      @Nullable Font font) {
    if (appearance == null) {
      this.appearance = DEFAULT_APPEARANCE;
    } else {
      this.appearance = appearance;
    }

    final SpeechBubble active = activeSpeechBubbles.get(entity);
    if (active != null) {
      active.hide();
    }
    this.setFont(font);

    this.textBoxWidth = (float) (entity.getWidth() * 4);
    this.entity = entity;

    this.currentText = text;
    this.currentTextDisplayTime = DISPLAYTIME_MIN + text.length() * DISPLAYTIME_PER_LETTER;

    this.lastTextDisplay = Game.time().now();
    this.createBubbleImage();
    entity.getEnvironment().add(this, RenderType.UI);
    Game.loop().attach(this);
    activeSpeechBubbles.put(entity, this);
}
}
```
```java
class de.gurkenlabs.litiengine.entities.Prop {
private void updateAnimationController() {
    IEntityAnimationController<?> controller = this.createAnimationController();
    this.getControllers().addController(controller);
    if (Game.world().environment() != null && Game.world().environment().isLoaded()) {
      Game.loop().attach(controller);
    }
}
}
```
```java
class de.gurkenlabs.litiengine.graphics.FreeFlightCamera {
public FreeFlightCamera(final Point2D focus) {
    this.setFocus(focus);
    this.velocity = DEFAULT_SCROLL_PIXELS_PER_SECOND;
    this.scrollPadding = DEFAULT_SCROLL_PADDING;
    this.setClampToMap(true);

    Game.loop().attach(this);
}private void handleFreeFlightCamera() {
    if (Game.world().environment() == null || Game.world().environment().getMap() == null) {
      return;
    }

    final Point2D mouseLocation = Input.mouse().getLocation();

    final double scrollSpeed =
        this.getVelocity()
            / (double) Game.loop().getTickRate()
            * Game.config().input().getMouseSensitivity();

    double x = this.getFocus().getX();
    double y = this.getFocus().getY();

    double deltaX = 0;
    if (mouseLocation.getX() < this.getScrollPadding()) {
      deltaX -= scrollSpeed;
    } else if (Game.window().getResolution().getWidth() - mouseLocation.getX()
        < this.getScrollPadding()) {
      deltaX += scrollSpeed;
    }

    double deltaY = 0;
    if (mouseLocation.getY() < this.getScrollPadding()) {
      deltaY -= scrollSpeed;
    } else if (Game.window().getResolution().getHeight() - mouseLocation.getY()
        < this.getScrollPadding()) {
      deltaY += scrollSpeed;
    }

    x += deltaX;
    y += deltaY;

    this.setFocus(new Point2D.Double(x, y));
}
}
```
```java
class de.gurkenlabs.litiengine.environment.Environment {
private static void dispose(final Collection<? extends IEntity> entities) {
    for (final IEntity entity : entities) {
      if (entity instanceof IUpdateable) {
        Game.loop().detach((IUpdateable) entity);
      }

      entity.detachControllers();
    }
}private static void loadUpdatableOrEmitterEntity(IEntity entity) {
    if (entity instanceof Emitter) {
      final Emitter emitter = (Emitter) entity;
      if (emitter.isActivateOnInit()) {
        emitter.activate();
      }
    } else if (entity instanceof IUpdateable) {
      Game.loop().attach((IUpdateable) entity);
    }
}private void unload(final IEntity entity) {
    // 1. remove from physics engine
    if (entity instanceof ICollisionEntity) {
      Game.physics().remove((ICollisionEntity) entity);
    }

    // 2. unregister from update
    if (entity instanceof IUpdateable) {
      Game.loop().detach((IUpdateable) entity);
    }

    if (entity instanceof IMobileEntity) {
      this.removeGravity((IMobileEntity) entity);
    }

    // 3. detach all controllers
    entity.detachControllers();

    if (entity instanceof Emitter) {
      Emitter em = (Emitter) entity;
      em.deactivate();
    }

    if (this.loaded && (entity instanceof LightSource || entity instanceof StaticShadow)) {
      this.updateLighting(entity);
    }

    entity.removed(this);
}
}
```
```java
class de.gurkenlabs.litiengine.graphics.animation.Animation {
@Override
  public void update() {
    // do nothing if the animation is not playing or the current keyframe is not finished
    if (!this.isPlaying()
        || Game.time().since(this.lastFrameUpdate) < this.getCurrentKeyFrame().getDuration()) {
      return;
    }

    // if we are not looping and the last keyframe is finished, we terminate the animation
    if (!this.isLooping() && this.isLastKeyFrame()) {
      this.terminate();
      return;
    }

    // make sure, we stay inside the keyframe list
    final int newFrameIndex =
        (this.getKeyframes().indexOf(this.currentFrame) + 1) % this.getKeyframes().size();
    final KeyFrame previousFrame = this.currentFrame;
    this.currentFrame = this.getKeyframes().get(newFrameIndex);

    for (KeyFrameListener listener : this.listeners) {
      listener.currentFrameChanged(previousFrame, this.currentFrame);
    }

    this.lastFrameUpdate = Game.loop().getTicks();
}public void restart() {
    this.currentFrame = this.firstFrame;
    this.lastFrameUpdate = Game.loop().getTicks();
}
}
```
```java
class de.gurkenlabs.litiengine.physics.MovementController {
@Override
  public void attach() {
    Game.loop().attach(this);
}private void handleForces() {
    // clean up forces
    this.activeForces.forEach(
        x -> {
          if (x.hasEnded()) {
            this.activeForces.remove(x);
          }
        });

    if (this.activeForces.isEmpty()) {
      return;
    }

    // disable turn-on-move for force handling
    boolean turn = this.getEntity().turnOnMove();
    this.getEntity().setTurnOnMove(false);
    try {
      double deltaX = 0;
      double deltaY = 0;
      for (final Force force : this.activeForces) {
        if (force.cancelOnReached() && force.hasReached(this.getEntity())) {
          force.end();
          continue;
        }

        final Point2D collisionBoxCenter = this.getEntity().getCollisionBoxCenter();
        final double angle =
            GeometricUtilities.calcRotationAngleInDegrees(collisionBoxCenter, force.getLocation());
        final double strength =
            Game.loop().getDeltaTime() * 0.001f * force.getStrength() * Game.loop().getTimeScale();
        deltaX += GeometricUtilities.getDeltaX(angle, strength);
        deltaY += GeometricUtilities.getDeltaY(angle, strength);
      }

      final Point2D target =
          new Point2D.Double(this.getEntity().getX() + deltaX, this.getEntity().getY() + deltaY);
      final boolean success = Game.physics().move(this.getEntity(), target);
      if (!success) {
        for (final Force force : this.activeForces) {
          if (force.cancelOnCollision()) {
            force.end();
          }
        }
      }
    } finally {
      this.getEntity().setTurnOnMove(turn);
    }
}@Override
  public void detach() {
    Game.loop().detach(this);
}public void handleMovement() {
    if (!this.isMovementAllowed()) {
      this.velocity = 0;
      return;
    }

    // max distance an entity can travel within one tick
    final double maxPixelsPerTick = this.getEntity().getTickVelocity();
    final double deltaTime = Game.loop().getDeltaTime() * Game.loop().getTimeScale();

    final double acceleration =
        this.getEntity().getAcceleration() == 0
            ? maxPixelsPerTick
            : deltaTime / this.getEntity().getAcceleration() * maxPixelsPerTick;
    final double deceleration =
        this.getEntity().getDeceleration() == 0
            ? this.getVelocity()
            : deltaTime / this.getEntity().getDeceleration() * maxPixelsPerTick;

    double dx = this.getDx();
    double dy = this.getDy();
    this.setDx(0);
    this.setDy(0);

    final double deltaVelocity =
        Math.min(Math.sqrt(Math.pow(dx, 2) + Math.pow(dy, 2)), acceleration);
    if (deltaVelocity != 0) {
      double newVelocity = this.getVelocity() + deltaVelocity;
      this.setVelocity(newVelocity);
    } else {
      final double newVelocity = Math.max(0, this.getVelocity() - deceleration);
      this.setVelocity(newVelocity);
      dx = GeometricUtilities.getDeltaX(this.moveAngle);
      dy = GeometricUtilities.getDeltaY(this.moveAngle);
    }

    if (this.getVelocity() == 0) {
      this.moveAngle = 0;
      return;
    }

    // actually move entity
    this.moveEntity(dx, dy);
}
}
```
```java
class de.gurkenlabs.litiengine.graphics.animation.AnimationController {
public void detach() {
    Game.loop().detach(this);
}public void attach() {
    Game.loop().attach(this);
}
}
```
```java
class de.gurkenlabs.litiengine.graphics.Camera {
@Override
  public void setZoom(final float targetZoom, final int delay) {
    if (delay == 0) {

      this.zoom = targetZoom;
      this.targetZoom = 0;
      this.zoomDelay = 0;
      this.zoomTick = 0;
      this.zoomStep = 0;

      final ZoomChangedEvent event = new ZoomChangedEvent(this, targetZoom);
      for (final ZoomChangedListener listener : this.zoomListeners) {
        listener.zoomChanged(event);
      }
    } else {
      this.zoomTick = Game.time().now();
      this.targetZoom = targetZoom;
      this.zoomDelay = delay;

      final double tickduration = 1000 / (double) Game.loop().getTickRate();
      final double tickAmount = delay / tickduration;
      final float totalDelta = this.targetZoom - this.zoom;
      this.zoomStep = tickAmount > 0 ? (float) (totalDelta / tickAmount) : totalDelta;
    }
}
}
```
```java
class de.gurkenlabs.litiengine.Game {
public static synchronized void init(String... args) {
    if (initialized) {
      log().log(Level.INFO, "The game has already been initialized.");
      return;
    }

    log.init();
    handleCommandLineArguments(args);

    config().load();
    Locale.setDefault(new Locale(config().client().getCountry(), config().client().getLanguage()));

    gameLoop = new GameLoop("Main Update Loop", config().client().getMaxFps());
    loop().attach(physics());
    loop().attach(world());

    // setup default exception handling for render and update loop
    setUncaughtExceptionHandler(
        new DefaultUncaughtExceptionHandler(config().client().exitOnError()));

    screenManager = new ScreenManager();
    gameWindow = new GameWindow();

    // initialize  the game window
    window().init();
    world.setCamera(new Camera());

    for (GameListener listener : gameListeners) {
      listener.initialized(args);
    }

    if (!isInNoGUIMode()) {
      window().getRenderComponent().onRendered(g -> metrics().render(g));

      graphics()
          .addEntityRenderedListener(
              e -> DebugRenderer.renderEntityDebugInfo(e.getGraphics(), e.getEntity()));

      window().getRenderComponent().onFpsChanged(fps -> metrics().setFramesPerSecond(fps));
      window()
          .setIcons(
              Arrays.asList(
                  Resources.images().get("liti-logo-x16.png"),
                  Resources.images().get("liti-logo-x20.png"),
                  Resources.images().get("liti-logo-x32.png"),
                  Resources.images().get("liti-logo-x48.png")));

      Input.keyboard()
          .onKeyTyped(
              KeyEvent.VK_PRINTSCREEN,
              key -> {
                // don't take a screenshot if a modifier is active
                if (key.getModifiers() != 0) {
                  return;
                }

                window().getRenderComponent().takeScreenshot();
              });
    }

    Runtime.getRuntime().addShutdownHook(new Thread(Game::terminate, "Shutdown"));

    initialized = true;
}
}
```
```java
class de.gurkenlabs.litiengine.entities.Creature {
protected void updateAnimationController() {
    IEntityAnimationController<?> controller = this.createAnimationController();
    this.getControllers().addController(controller);
    if (Game.world().environment() != null && Game.world().environment().isLoaded()) {
      Game.loop().attach(controller);
    }
}@Override
  public float getTickVelocity() {
    // pixels per ms multiplied by the passed ms
    // ensure that entities don't travel too far in case of lag
    return Math.min(Game.loop().getDeltaTime(), GameLoop.TICK_DELTATIME_LAG)
        * 0.001F
        * this.getVelocity().get()
        * Game.loop().getTimeScale();
}
}
```
Depth: 2
```java
class de.gurkenlabs.litiengine.environment.GameWorld {
public void clear() {
    this.unloadEnvironment();
    this.environments.clear();
    this.setCamera(null);
    Game.physics().clear();

    this.environmentListeners.clear();
    this.environmentLoadedListeners.clear();
    this.environmentUnloadedListeners.clear();

    this.listeners.clear();
    this.loadedListeners.clear();
    this.unloadedListeners.clear();
}@Nullable
  public Environment loadEnvironment(IMap map) {
    Environment env = this.getEnvironment(map);
    this.loadEnvironment(env);
    return env;
}@Nullable
  public Environment loadEnvironment(String mapName) {
    Environment env = this.getEnvironment(mapName);
    this.loadEnvironment(env);
    return env;
}
}
```
```java
class de.gurkenlabs.litiengine.GameWindow {
GameWindow() {
    this.hostControl = new JFrame();

    this.resolutionChangedListeners = new CopyOnWriteArrayList<>();

    this.renderCanvas = new RenderComponent(Game.config().graphics().getResolution());
    this.cursor = new MouseCursor();
    if (!Game.isInNoGUIMode()) {
      this.hostControl.setBackground(Color.BLACK);
      this.hostControl.add(this.renderCanvas);

      this.initializeEventListeners();

      this.hostControl.setTitle(Game.info().getTitle());
      this.hostControl.setDefaultCloseOperation(WindowConstants.DO_NOTHING_ON_CLOSE);
      initializeWindowEventListeners(this.hostControl);
    }
}
}
```
```java
class de.gurkenlabs.litiengine.GameTime {
public long sinceEnvironmentLoad() {
    return this.since(this.environmentLoaded);
}public long since(final long tick) {
    return toMilliseconds(Game.loop().getTicks() - tick);
}public long sinceGameStart() {
    return this.toMilliseconds(Game.loop().getTicks());
}
}
```
```java
class de.gurkenlabs.litiengine.abilities.effects.Effect {
protected void cease(final EffectApplication appliance) {
    // 1. cease the effect for all affected entities
    for (final ICombatEntity entity : appliance.getAffectedEntities()) {
      this.cease(entity);
    }

    // 2. apply follow up effects
    this.getFollowUpEffects().forEach(followUp -> followUp.apply(appliance.getImpactArea()));
}protected boolean hasEnded(final EffectApplication appliance) {
    final long effectDuration = Game.time().since(appliance.getAppliedTicks());
    return effectDuration > this.getDuration();
}
}
```
```java
class de.gurkenlabs.litiengine.abilities.effects.EffectApplication {
protected EffectApplication(final List<ICombatEntity> affectedEntities, final Shape impactArea) {
    this.applied = Game.time().now();
    this.affectedEntities = affectedEntities;
    this.impactArea = impactArea;
}
}
```
```java
class de.gurkenlabs.litiengine.entities.CombatEntity {
@Override
  public boolean wasHit(int timeSpan) {
    return Game.time().since(this.lastHit) < timeSpan;
}@Override
  public void hit(final int damage, @Nullable final Ability ability) {
    if (this.isDead()) {
      return;
    }

    if (!this.isIndestructible()) {
      this.getHitPoints().modifyBaseValue(new AttributeModifier<>(Modification.SUBTRACT, damage));
    }

    final EntityHitEvent event = new EntityHitEvent(this, ability, damage, this.isDead());

    for (final CombatEntityListener listener : this.listeners) {
      listener.hit(event);
    }

    for (final CombatEntityHitListener listener : this.hitListeners) {
      listener.hit(event);
    }

    if (this.isDead()) {
      this.fireDeathEvent();
      this.setCollision(false);
    }

    this.lastHit = Game.time().now();
}
}
```
```java
class de.gurkenlabs.litiengine.graphics.ImageEffect {
protected ImageEffect(final int ttl, final String name) {
    this.ttl = ttl;
    this.name = name;
    this.aliveTick = Game.time().now();
}@Override
  public long getAliveTime() {
    return Game.time().since(this.aliveTick);
}
}
```
```java
class de.gurkenlabs.litiengine.abilities.AbilityExecution {
AbilityExecution(final Ability ability) {
    this.appliedEffects = new CopyOnWriteArrayList<>();
    this.ability = ability;
    this.executionTicks = Game.time().now();
    this.impactArea = ability.calculateImpactArea();
    this.castLocation = ability.getExecutor().getCenter();
    Game.loop().attach(this);
}@Override
  public void update() {
    // if there a no effects to apply -> unregister this instance and we're done
    if (this.getAbility().getEffects().isEmpty()
        || this.getAbility().getEffects().size() == this.getAppliedEffects().size()) {
      Game.loop().detach(this);
      return;
    }

    // handle all effects from the ability that were not applied yet
    for (final Effect effect : this.getAbility().getEffects()) {
      // if the ability was not executed yet or the delay of the effect is not
      // yet reached
      if (this.getAppliedEffects().contains(effect)
          || Game.time().since(this.getExecutionTicks()) < effect.getDelay()) {
        continue;
      }

      effect.apply(this.getExecutionImpactArea());
      this.getAppliedEffects().add(effect);
    }
}
}
```
```java
class de.gurkenlabs.litiengine.tweening.TweenEngine {
@Override
  public void update() {
    for (final Tweenable target : this.getTweens().keySet()) {
      for (final Tween tween : this.getTweens().get(target).values()) {
        if (tween.hasStopped()) {
          continue;
        }
        final long elapsed = Game.time().since(tween.getStartTime());
        if (elapsed >= tween.getDuration()) {
          tween.stop();
          continue;
        }
        final float[] currentValues = new float[tween.getTargetValues().length];
        for (int i = 0; i < tween.getTargetValues().length; i++) {
          currentValues[i] =
              tween.getStartValues()[i]
                  + tween.getEquation().compute(elapsed / (float) tween.getDuration())
                      * (tween.getTargetValues()[i] - tween.getStartValues()[i]);
        }
        tween.getTarget().setTweenValues(tween.getType(), currentValues);
      }
    }
}
}
```
```java
class de.gurkenlabs.litiengine.gui.SpeechBubble {
public static SpeechBubble create(
      final IEntity entity, final String text, SpeechBubbleAppearance appearance, Font font) {
    return new SpeechBubble(entity, text, appearance, font);
}public static SpeechBubble create(final IEntity entity, final Font font, final String text) {
    SpeechBubbleAppearance app =
        new SpeechBubbleAppearance(
            DEFAULT_APPEARANCE.getForeColor(),
            DEFAULT_APPEARANCE.getBackgroundColor1(),
            DEFAULT_APPEARANCE.getBorderColor(),
            DEFAULT_APPEARANCE.getPadding());
    return new SpeechBubble(entity, text, app, font);
}public static SpeechBubble create(final IEntity entity, final String text) {
    return new SpeechBubble(entity, text, null, GuiProperties.getDefaultFont());
}@Override
  public void update() {
    if (this.currentText == null) {
      this.hide();
      return;
    }

    this.entityCenter = Game.world().camera().getViewportLocation(this.getEntity().getCenter());

    // old text was displayed long enough
    if (this.lastTextDisplay != 0
        && Game.time().since(this.lastTextDisplay) > this.currentTextDisplayTime) {
      this.currentText = null;
      this.lastTextDisplay = 0;
      return;
    }

    // display new text
    if (this.textIndex < this.currentText.length()
        && Game.time().since(this.lastCharPoll) > LETTER_WRITE_DELAY) {
      this.textIndex++;
      this.lastCharPoll = Game.time().now();
      if (this.typeSound != null) {
        Game.audio().playSound(this.typeSound, this.getEntity());
      }
    }

    // continue displaying currently displayed text
}private SpeechBubble(
      final IEntity entity,
      final String text,
      final Sound typeSound,
      SpeechBubbleAppearance appearance,
      Font font) {
    this(entity, text, appearance, font);
    this.typeSound = typeSound;
}private SpeechBubble(
      final IEntity entity,
      final String text,
      @Nullable SpeechBubbleAppearance appearance,
      @Nullable Font font) {
    if (appearance == null) {
      this.appearance = DEFAULT_APPEARANCE;
    } else {
      this.appearance = appearance;
    }

    final SpeechBubble active = activeSpeechBubbles.get(entity);
    if (active != null) {
      active.hide();
    }
    this.setFont(font);

    this.textBoxWidth = (float) (entity.getWidth() * 4);
    this.entity = entity;

    this.currentText = text;
    this.currentTextDisplayTime = DISPLAYTIME_MIN + text.length() * DISPLAYTIME_PER_LETTER;

    this.lastTextDisplay = Game.time().now();
    this.createBubbleImage();
    entity.getEnvironment().add(this, RenderType.UI);
    Game.loop().attach(this);
    activeSpeechBubbles.put(entity, this);
}
}
```
```java
class de.gurkenlabs.litiengine.gui.TextFieldComponent {
@Override
  public void render(final Graphics2D g) {
    super.render(g);
    g.setFont(this.getFont());
    final FontMetrics fm = g.getFontMetrics();

    if (this.isSelected() && Game.time().since(this.lastToggled) > this.flickerDelay) {
      this.cursorVisible = !this.cursorVisible;
      this.lastToggled = Game.time().now();
    }
    if (this.isSelected() && this.cursorVisible) {
      final Rectangle2D cursor =
          new Rectangle2D.Double(
              this.getX() + this.getTextX() + fm.stringWidth(this.getTextToRender(g)),
              this.getY() + this.getTextY(),
              this.getFont().getSize2D() * 3 / 5,
              this.getFont().getSize2D() * 1 / 5);
      g.setColor(this.getAppearance().getForeColor());
      g.fill(cursor);
    }
}
}
```
```java
class de.gurkenlabs.litiengine.entities.Prop {
public Prop(
      final Point2D location, @Nullable final String spritesheetName, final Material material) {
    super();
    this.rotation = Rotation.NONE;
    this.spritesheetName = spritesheetName;
    this.material = material;
    this.setLocation(location);
    this.updateAnimationController();
}public void setSpritesheetName(@Nullable final String spriteName) {
    this.spritesheetName = spriteName;
    this.updateAnimationController();
}
}
```
```java
class de.gurkenlabs.litiengine.tweening.Tween {
public Tween begin() {
    this.started = Game.time().now();
    this.stopped = false;
    return this;
}
}
```
```java
class de.gurkenlabs.litiengine.graphics.emitters.particles.Particle {
public void update(final Point2D emitterOrigin, final float updateRatio) {
    if (this.aliveTick == 0) {
      this.aliveTick = Game.time().now();
    }

    this.aliveTime = Game.time().since(this.aliveTick);
    if (this.timeToLiveReached()) {
      return;
    }

    if (this.colliding) {
      return;
    }

    if (this.getDeltaWidth() != 0) {
      this.width += this.getDeltaWidth() * updateRatio;
    }

    if (this.getDeltaHeight() != 0) {
      this.height += this.getDeltaHeight() * updateRatio;
    }

    if (this.getDeltaAngle() != 0) {
      this.angle += this.getDeltaAngle() * updateRatio;
    }

    // test for ray cast collision
    final float targetX = this.x + this.getVelocityX() * updateRatio;
    final float targetY = this.y + this.getVelocityY() * updateRatio;

    if (targetX == this.x && targetY == this.y) {
      return;
    }

    if (this.checkForCollision(emitterOrigin, targetX, targetY)) {
      return;
    }

    if (this.getVelocityX() != 0) {
      this.x = targetX;
    }

    if (this.getVelocityY() != 0) {
      this.y = targetY;
    }

    if (this.getAccelerationX() != 0) {
      this.velocityX += this.getAccelerationX() * updateRatio;
    }

    if (this.getAccelerationY() != 0) {
      this.velocityY += this.getAccelerationY() * updateRatio;
    }
}
}
```
```java
class de.gurkenlabs.litiengine.graphics.animation.Animation {
@Override
  public void start() {
    this.playing = true;
    if (this.getKeyframes().isEmpty()) {
      return;
    }

    this.restart();
}@Override
  public void update() {
    // do nothing if the animation is not playing or the current keyframe is not finished
    if (!this.isPlaying()
        || Game.time().since(this.lastFrameUpdate) < this.getCurrentKeyFrame().getDuration()) {
      return;
    }

    // if we are not looping and the last keyframe is finished, we terminate the animation
    if (!this.isLooping() && this.isLastKeyFrame()) {
      this.terminate();
      return;
    }

    // make sure, we stay inside the keyframe list
    final int newFrameIndex =
        (this.getKeyframes().indexOf(this.currentFrame) + 1) % this.getKeyframes().size();
    final KeyFrame previousFrame = this.currentFrame;
    this.currentFrame = this.getKeyframes().get(newFrameIndex);

    for (KeyFrameListener listener : this.listeners) {
      listener.currentFrameChanged(previousFrame, this.currentFrame);
    }

    this.lastFrameUpdate = Game.loop().getTicks();
}
}
```
```java
class de.gurkenlabs.litiengine.graphics.animation.AnimationController {
@Override
  public void update() {
    for (final Animation animation : this.getAll()) {
      animation.update();
    }

    if (this.getCurrent() != null && this.getCurrent().isPaused()) {
      return;
    }

    final boolean playbackFinished = this.getCurrent() != null && !this.getCurrent().isPlaying();
    if (playbackFinished) {
      for (final AnimationListener listener : this.listeners) {
        listener.finished(this.getCurrent());
      }
    }

    if (this.getCurrent() == null || playbackFinished) {
      if (this.getDefault() != null) {
        this.play(this.getDefault().getName());
      } else {
        this.currentAnimation = null;
      }
    }
}
}
```
```java
class de.gurkenlabs.litiengine.graphics.RenderComponent {
private void handleFade() {
    if (this.fadeOutStart != -1) {
      final long timePassed = Game.time().since(this.fadeOutStart);
      this.currentAlpha = MathUtilities.clamp(1 - timePassed / (float) this.fadeOutTime, 0, 1);
      if (this.currentAlpha == 0f) {
        this.fadeOutStart = -1;
        this.fadeOutTime = -1;
      }

      return;
    }

    if (this.fadeInStart != -1) {
      final long timePassed = Game.time().since(this.fadeInStart);
      this.currentAlpha = MathUtilities.clamp(timePassed / (float) this.fadeInTime, 0, 1);
      if (this.currentAlpha == 1f) {
        this.fadeInStart = -1;
        this.fadeInTime = -1;
        this.currentAlpha = Float.NaN;
      }
    }
}public void fadeOut(final int ms) {
    this.fadeInStart = -1;
    this.fadeInTime = -1;
    this.fadeOutStart = Game.time().now();
    this.fadeOutTime = ms;
}public void fadeIn(final int ms) {
    this.fadeOutStart = -1;
    this.fadeOutTime = -1;
    this.fadeInStart = Game.time().now();
    this.fadeInTime = ms;
}
}
```
```java
class de.gurkenlabs.litiengine.entities.Trigger {
private boolean activate(final IEntity activator, final int tar) {
    if (!this.isLoaded()
        || this.isOneTimeTrigger && this.isActivated
        || this.getActivationType() == TriggerActivation.COLLISION
            && activator != null
            && this.collisionActivated.contains(activator)) {
      return false;
    }

    if (this.getCooldown() > 0 && Game.time().since(this.lastActivation) < this.getCooldown()) {
      return false;
    }

    List<Integer> triggerTargets = this.getTargets(tar);

    final TriggerEvent te = new TriggerEvent(this, activator, triggerTargets);

    if (!this.checkActivationPredicates(te)) {
      return false;
    }

    this.isActivated = true;
    if (activator != null) {
      this.collisionActivated.add(activator);
    }

    // if we actually have a trigger target, we send the message to the target
    for (final int target : triggerTargets) {
      final IEntity entity = this.getEnvironment().get(target);
      if (entity == null) {
        log.log(
            Level.WARNING,
            "trigger [{0}] was activated, but the trigger target [{1}] could not be found on the environment",
            new Object[] {this, target});
        continue;
      }

      entity.sendMessage(this, this.message);
    }

    // also send the trigger event to all registered consumers
    for (final TriggerActivatedListener listener : this.activatedListeners) {
      listener.activated(te);
    }

    if (this.isOneTimeTrigger) {
      this.getEnvironment().remove(this);
    }

    this.lastActivation = Game.time().now();
    return true;
}
}
```
```java
class de.gurkenlabs.litiengine.graphics.Camera {
private boolean isShakeEffectActive() {
    return this.getShakeTick() != 0
        && Game.time().since(this.getShakeTick()) < this.getShakeDuration();
}@Override
  public void update() {
    if (Game.world().camera() != null && !Game.world().camera().equals(this)) {
      return;
    }

    if (this.targetZoom > 0) {
      if (Game.time().since(this.zoomTick) >= this.zoomDelay) {
        this.zoom = this.targetZoom;
        this.targetZoom = 0;
        this.zoomDelay = 0;
        this.zoomTick = 0;
        this.zoomStep = 0;
      } else {
        this.zoom += this.zoomStep;
      }

      final ZoomChangedEvent event = new ZoomChangedEvent(this, this.getZoom());
      for (final ZoomChangedListener listener : this.zoomListeners) {
        listener.zoomChanged(event);
      }
    }

    if (this.panTime > 0) {
      if (--this.panTime <= 0) {
        this.setFocus(this.targetFocus);
        this.targetFocus = null;
      } else {
        double diff = this.panTime / (this.panTime + 1.0);
        this.focus =
            new Point2D.Double(
                this.focus.getX() * diff + this.targetFocus.getX() * (1.0 - diff),
                this.focus.getY() * diff + this.targetFocus.getY() * (1.0 - diff));
      }
    }

    if (!this.isShakeEffectActive()) {
      this.shakeOffsetX = 0;
      this.shakeOffsetY = 0;
      return;
    }

    if (Game.time().since(this.lastShake) > this.shakeDelay) {
      this.shakeOffsetX = this.getShakeIntensity() * ThreadLocalRandom.current().nextGaussian();
      this.shakeOffsetY = this.getShakeIntensity() * ThreadLocalRandom.current().nextGaussian();
      this.lastShake = Game.time().now();
    }
}@Override
  public void setZoom(final float targetZoom, final int delay) {
    if (delay == 0) {

      this.zoom = targetZoom;
      this.targetZoom = 0;
      this.zoomDelay = 0;
      this.zoomTick = 0;
      this.zoomStep = 0;

      final ZoomChangedEvent event = new ZoomChangedEvent(this, targetZoom);
      for (final ZoomChangedListener listener : this.zoomListeners) {
        listener.zoomChanged(event);
      }
    } else {
      this.zoomTick = Game.time().now();
      this.targetZoom = targetZoom;
      this.zoomDelay = delay;

      final double tickduration = 1000 / (double) Game.loop().getTickRate();
      final double tickAmount = delay / tickduration;
      final float totalDelta = this.targetZoom - this.zoom;
      this.zoomStep = tickAmount > 0 ? (float) (totalDelta / tickAmount) : totalDelta;
    }
}@Override
  public void shake(final double intensity, final int delay, final int shakeDuration) {
    this.shakeTick = Game.time().now();
    this.shakeDelay = delay;
    this.shakeIntensity = intensity;
    this.shakeDuration = shakeDuration;
}
}
```
```java
class de.gurkenlabs.litiengine.entities.Creature {
public void setSpritesheetName(String spritesheetName) {
    if (this.spritesheetName != null && this.spritesheetName.equals(spritesheetName)) {
      return;
    }

    this.spritesheetName = spritesheetName;
    this.updateAnimationController();
}public boolean isIdle() {
    return Game.time().since(this.lastMoved) > IDLE_DELAY;
}@Override
  public void setLocation(final Point2D position) {
    if (this.isDead() || position == null) {
      return;
    }

    final Point2D oldLocation = this.getLocation();
    super.setLocation(position);

    if (Game.hasStarted() && this.isLoaded()) {
      this.lastMoved = Game.time().now();
      this.fireMovedEvent(
          new EntityMovedEvent(
              this, this.getX() - oldLocation.getX(), this.getY() - oldLocation.getY()));
    }
}
}
```
```java
class de.gurkenlabs.litiengine.gui.screens.ScreenManager {
public void display(final String screenName) {
    if (this.current() != null && this.current().getName().equalsIgnoreCase(screenName)) {
      log.log(
          Level.INFO,
          "Skipping displaying of screen {0} because it is already the current screen.",
          screenName);
      return;
    }

    if (this.screens.stream()
        .noneMatch(element -> element.getName().equalsIgnoreCase(screenName))) {
      log.log(
          Level.WARNING,
          "Could not display the screen {0} because there is no screen with the specified name.",
          screenName);
      return;
    }

    Screen screen = this.get(screenName);
    if (screen == null) {
      return;
    }

    this.display(screen);
}public void add(final Screen screen) {
    screen.setWidth(Game.window().getWidth());
    screen.setHeight(Game.window().getHeight());
    this.screens.add(screen);

    if (this.current() == null) {
      this.display(screen);
    }
}public void remove(Screen screen) {
    this.screens.remove(screen);
    if (this.current() == screen) {
      if (!this.screens.isEmpty()) {
        this.display(this.screens.get(0));
      } else {
        this.display((Screen) null);
      }
    }
}public void display(@Nullable final Screen screen) {
    if (Game.hasStarted() && Game.time().since(this.lastScreenChange) < this.getChangeCooldown()) {
      log.log(
          Level.INFO,
          "Skipping displaying of screen {0} because screen changing is currently on cooldown.",
          screen != null ? screen.getName() : "");
      return;
    }

    final Screen previous = this.current();
    if (previous != null) {
      previous.suspend();
    }

    if (screen != null && !this.screens.contains(screen)) {
      this.screens.add(screen);
    }

    this.currentScreen = screen;
    if (!Game.isInNoGUIMode() && this.current() != null) {
      this.current().prepare();
    }

    this.lastScreenChange = Game.loop().getTicks();

    final ScreenChangedEvent event = new ScreenChangedEvent(this.current(), previous);
    for (final ScreenChangedListener listener : this.screenChangedListeners) {
      listener.changed(event);
    }
}
}
```
```java
class de.gurkenlabs.litiengine.abilities.Ability {
public boolean isOnCooldown() {
    return (this.getCurrentExecution() != null
        && this.getCurrentExecution().getExecutionTicks() > 0
        && Game.time().since(this.getCurrentExecution().getExecutionTicks())
            < this.getAttributes().cooldown().get());
}public boolean isActive() {
    return this.getCurrentExecution() != null
        && Game.time().since(this.getCurrentExecution().getExecutionTicks())
            < this.getAttributes().duration().get();
}@Nullable
  public AbilityExecution cast() {
    if (!this.canCast()) {
      return null;
    }
    this.currentExecution = new AbilityExecution(this);

    for (final AbilityCastListener listener : this.abilityCastListeners) {
      listener.abilityCast(this.currentExecution);
    }

    return this.getCurrentExecution();
}public float getRemainingCooldownInSeconds() {
    if (this.getCurrentExecution() == null
        || this.getExecutor() == null
        || this.getExecutor().isDead()) {
      return 0;
    }

    // calculate cooldown in seconds
    return (float)
        (!this.canCast()
            ? (this.getAttributes().cooldown().get()
                    - Game.time().since(this.getCurrentExecution().getExecutionTicks()))
                * 0.001
            : 0);
}
}
```
```java
class de.gurkenlabs.litiengine.entities.EntityHitEvent {
EntityHitEvent(
      final ICombatEntity hitEntity,
      @Nullable final Ability ability,
      final int damage,
      final boolean kill) {
    super(hitEntity);
    this.executor = ability != null ? ability.getExecutor() : null;
    this.hitEntity = hitEntity;
    this.ability = ability;
    this.damage = damage;
    this.kill = kill;
    this.time = Game.time().now();
}
}
```
```java
class de.gurkenlabs.litiengine.graphics.emitters.Emitter {
public void delete() {
    this.deactivate();
    if (Game.world().environment() != null) {
      Game.world().environment().remove(this);
    }
}public void activate() {
    if (this.activated) {
      return;
    }

    this.activated = true;
    this.activationTick = Game.time().now();
    Game.loop().attach(this);
}@Override
  public void update() {
    if (this.isPaused()) {
      return;
    }

    // clear particles if the effect time to life is reached
    if (this.isFinished()) {
      for (EmitterFinishedListener listener : this.finishedListeners) {
        listener.finished(this);
      }

      this.delete();
      return;
    }

    final float updateRatio = (float) this.data().getUpdateRate() / Game.loop().getTickRate();
    for (final Particle p : this.getParticles().stream().collect(Collectors.toList())) {
      if (this.particleCanBeRemoved(p)) {
        // remove dead particles
        this.particles.remove(p);
        continue;
      }

      p.update(this.getOrigin(), updateRatio);
    }

    this.aliveTime = Game.time().since(this.activationTick);
    if ((this.data().getSpawnRate() == 0
        || Game.time().since(this.lastSpawn) >= this.data().getSpawnRate())) {
      this.lastSpawn = Game.time().now();
      this.spawnParticle();
    }
}
}
```
```java
class de.gurkenlabs.litiengine.GameLoop {
@Override
  public int perform(int delay, Runnable action) {
    final long d = Game.time().toTicks(delay);

    TimedAction a = new TimedAction(this.getTicks() + d, action);
    this.actions.add(a);

    return a.getId();
}
}
```
```java
class de.gurkenlabs.litiengine.environment.EntitySpawner {
protected boolean shouldSpawn() {
    return this.lastSpawnWave == 0
        || Game.time().since(this.lastSpawnWave) >= this.getSpawnInterval();
}@Override
  public void update() {
    if (!this.shouldSpawn()) {
      return;
    }

    this.spawnNewEntities();
    this.lastSpawnWave = Game.time().now();
}
}
```
```java
class de.gurkenlabs.litiengine.graphics.FreeFlightCamera {
@Override
  public void update() {
    this.handleFreeFlightCamera();
}public FreeFlightCamera(double x, double y) {
    this(new Point2D.Double(x, y));
}
}
```
```java
class de.gurkenlabs.litiengine.environment.Environment {
public void unload() {
    if (!this.loaded) {
      return;
    }

    // unregister all updatable entities from the current environment
    for (final IEntity entity : this.allEntities.values()) {
      this.unload(entity);
    }

    this.loaded = false;
    this.fireEvent(l -> l.unloaded(this));
}private static void loadUpdatableOrEmitterEntity(IEntity entity) {
    if (entity instanceof Emitter) {
      final Emitter emitter = (Emitter) entity;
      if (emitter.isActivateOnInit()) {
        emitter.activate();
      }
    } else if (entity instanceof IUpdateable) {
      Game.loop().attach((IUpdateable) entity);
    }
}public void clear() {
    Game.physics().clear();

    this.combatEntities.clear();
    this.mobileEntities.clear();
    this.gravityForces.clear();
    this.layerEntities.clear();
    this.entitiesByTag.clear();
    this.allEntities.clear();

    for (RenderType renderType : RenderType.values()) {
      this.miscEntities.get(renderType).clear();
      this.renderListeners.get(renderType).clear();
      this.renderables.get(renderType).clear();
    }

    dispose(this.allEntities.values());
    dispose(this.triggers);
    this.emitters.clear();
    this.colliders.clear();
    this.props.clear();
    this.creatures.clear();
    this.staticShadows.clear();
    this.combatEntities.clear();
    this.mobileEntities.clear();
    this.lightSources.clear();
    this.spawnPoints.clear();
    this.soundSources.clear();
    this.mapAreas.clear();
    this.triggers.clear();

    this.ambientLight = null;
    this.staticShadowLayer = null;

    for (Map<Integer, IEntity> type : this.miscEntities.values()) {
      type.clear();
    }

    this.initialized = false;

    this.fireEvent(l -> l.cleared(this));
}private void load(final IEntity entity) {
    // an entity can only exist on one environment at a time, so remove it from the current one
    if (entity.getEnvironment() != null) {
      entity.getEnvironment().remove(entity);
    }

    // 1. add to physics engine
    loadPhysicsEntity(entity);

    // 2. register for update or activate
    loadUpdatableOrEmitterEntity(entity);

    // 3. if a gravity is defined, add a gravity force to the entity
    if (entity instanceof IMobileEntity && this.getGravity() != 0) {
      this.addGravityForce((IMobileEntity) entity);
    }

    // 4. attach all controllers
    entity.attachControllers();

    if (this.loaded && (entity instanceof LightSource || entity instanceof StaticShadow)) {
      this.updateLighting(entity);
    }

    entity.loaded(this);
}private void unload(final IEntity entity) {
    // 1. remove from physics engine
    if (entity instanceof ICollisionEntity) {
      Game.physics().remove((ICollisionEntity) entity);
    }

    // 2. unregister from update
    if (entity instanceof IUpdateable) {
      Game.loop().detach((IUpdateable) entity);
    }

    if (entity instanceof IMobileEntity) {
      this.removeGravity((IMobileEntity) entity);
    }

    // 3. detach all controllers
    entity.detachControllers();

    if (entity instanceof Emitter) {
      Emitter em = (Emitter) entity;
      em.deactivate();
    }

    if (this.loaded && (entity instanceof LightSource || entity instanceof StaticShadow)) {
      this.updateLighting(entity);
    }

    entity.removed(this);
}public void remove(final IEntity entity) {
    if (entity == null) {
      return;
    }

    this.allEntities.remove(entity.getMapId());
    Iterator<List<IEntity>> iter = this.layerEntities.values().iterator();
    while (iter.hasNext()) {
      List<IEntity> layer = iter.next();
      if (layer.remove(entity) && layer.isEmpty()) {
        iter.remove();
      }
    }
    if (this.miscEntities.get(entity.getRenderType()) != null) {
      this.miscEntities.get(entity.getRenderType()).values().remove(entity);
    }

    for (String tag : entity.getTags()) {
      if (this.getEntitiesByTag().containsKey(tag)) {
        this.getEntitiesByTag().get(tag).remove(entity);

        if (this.getEntitiesByTag().get(tag).isEmpty()) {
          this.getEntitiesByTag().remove(tag);
        }
      }
    }

    if (entity instanceof Emitter) {
      Emitter emitter = (Emitter) entity;
      this.removeEmitter(emitter);
    }

    if (entity instanceof MapArea) {
      this.mapAreas.remove(entity);
    }

    if (entity instanceof Prop) {
      this.props.remove(entity);
    }

    if (entity instanceof Creature) {
      this.creatures.remove(entity);
    }

    if (entity instanceof CollisionBox) {
      this.colliders.remove(entity);
      this.staticShadows.removeIf(x -> x.getOrigin() != null && x.getOrigin().equals(entity));
    }

    if (entity instanceof LightSource) {
      this.lightSources.remove(entity);
      this.updateLighting(entity);
    }

    if (entity instanceof Trigger) {
      this.triggers.remove(entity);
    }

    if (entity instanceof Spawnpoint) {
      this.spawnPoints.remove(entity);
    }
    if (entity instanceof SoundSource) {
      this.soundSources.remove(entity);
    }

    if (entity instanceof StaticShadow) {
      this.staticShadows.remove(entity);
      this.updateLighting(entity);
    }

    if (entity instanceof IMobileEntity) {
      this.mobileEntities.values().remove(entity);
    }

    if (entity instanceof ICombatEntity) {
      this.combatEntities.values().remove(entity);
    }

    this.unload(entity);

    this.fireEntityEvent(l -> l.entityRemoved(entity));
}
}
```
```java
class de.gurkenlabs.litiengine.physics.MovementController {
@Override
  public void update() {
    this.handleForces();
    this.handleMovement();
}
}
```
```java
class de.gurkenlabs.litiengine.Game {
static synchronized void terminate() {
    if (!initialized) {
      return;
    }

    hasStarted = false;
    initialized = false;

    config().save();
    gameLoop.terminate();
    tweenEngine.terminate();
    soundEngine.terminate();

    world().clear();

    for (final GameListener listener : gameListeners) {
      try {
        listener.terminated();
      } catch (Exception e) {
        log().log(Level.WARNING, "game listener threw an exception during shutdown", e);
      }
    }

    gameLoop = null;
    screenManager = null;
    gameWindow = null;
}public static synchronized void start() {
    if (!initialized) {
      throw new IllegalStateException(
          "The game cannot be started without being first initialized. Call Game.init(...) before Game.start().");
    }

    gameLoop.start();
    tweenEngine.start();
    soundEngine.start();

    for (final GameListener listener : gameListeners) {
      listener.started();
    }

    hasStarted = true;
}public static synchronized void init(String... args) {
    if (initialized) {
      log().log(Level.INFO, "The game has already been initialized.");
      return;
    }

    log.init();
    handleCommandLineArguments(args);

    config().load();
    Locale.setDefault(new Locale(config().client().getCountry(), config().client().getLanguage()));

    gameLoop = new GameLoop("Main Update Loop", config().client().getMaxFps());
    loop().attach(physics());
    loop().attach(world());

    // setup default exception handling for render and update loop
    setUncaughtExceptionHandler(
        new DefaultUncaughtExceptionHandler(config().client().exitOnError()));

    screenManager = new ScreenManager();
    gameWindow = new GameWindow();

    // initialize  the game window
    window().init();
    world.setCamera(new Camera());

    for (GameListener listener : gameListeners) {
      listener.initialized(args);
    }

    if (!isInNoGUIMode()) {
      window().getRenderComponent().onRendered(g -> metrics().render(g));

      graphics()
          .addEntityRenderedListener(
              e -> DebugRenderer.renderEntityDebugInfo(e.getGraphics(), e.getEntity()));

      window().getRenderComponent().onFpsChanged(fps -> metrics().setFramesPerSecond(fps));
      window()
          .setIcons(
              Arrays.asList(
                  Resources.images().get("liti-logo-x16.png"),
                  Resources.images().get("liti-logo-x20.png"),
                  Resources.images().get("liti-logo-x32.png"),
                  Resources.images().get("liti-logo-x48.png")));

      Input.keyboard()
          .onKeyTyped(
              KeyEvent.VK_PRINTSCREEN,
              key -> {
                // don't take a screenshot if a modifier is active
                if (key.getModifiers() != 0) {
                  return;
                }

                window().getRenderComponent().takeScreenshot();
              });
    }

    Runtime.getRuntime().addShutdownHook(new Thread(Game::terminate, "Shutdown"));

    initialized = true;
}
}
```


Response Format:
Provide the answer in **XML format** as follows:

#### If the method **cannot** return `null` at the specific call site:
```xml
<response>
  <reason><![CDATA[EXPLAIN WHY THE INVOCATION Game.loop() RESULT CANNOT BE NULL.]]></reason>
  <value>NO</value>
</response>

#### If the method can return null at the specific call site:
<response>
  <reason><![CDATA[EXPLAIN WHY THE INVOCATION Game.loop() RESULT CAN BE NULL.]]></reason>
  <value>YES</value>
</response>

#### If you are unsure or If there are any methods that directly or indirectly affect the return value and are not fully disclosed, request their declarations first, in the following format:
<response>
  <reason><![CDATA[EXPLAIN WHY THIS METHOD DECLARATION IS NECESSARY AND WHY YOU CANNOT MAKE A CONFIDENT DECISION WITHOUT IT]]></reason>
  <success>false</success>
  <methods>
    <method>methodName</method>
  </methods>
</response>

Additional Notes:
Be precise in your reasoning.
If a method’s return value depends on another method not provided, request its declaration before making a conclusion.
If the method can return null in this case but not in others, explain why it happens specifically for this call.

---ChatGPT.sendRequestToOpenAI---
Retrieving response from cache
---Response.<init>---
Creating Response:
```xml
<response>
  <reason><![CDATA[The method `Game.loop()` returns the static field `gameLoop`, which is initialized in the `Game.init(String... args)` method. In this method, a new `GameLoop` object is instantiated and assigned to `gameLoop`. Since `init()` must be called before `start()`, which is implied by the requirement of initializing the game, the `gameLoop` is guaranteed to be non-null during the lifetime of the game execution where `Game.loop()` is called. The absence of any code that could set `gameLoop` to null after its initialization ensures that `Game.loop()` cannot return null.]]></reason>
  <value>NO</value>
</response>
```
---Response.<init>---
Response created:
Disagreement: The method `Game.loop()` returns the static field `gameLoop`, which is initialized in the `Game.init(String... args)` method. In this method, a new `GameLoop` object is instantiated and assigned to `gameLoop`. Since `init()` must be called before `start()`, which is implied by the requirement of initializing the game, the `gameLoop` is guaranteed to be non-null during the lifetime of the game execution where `Game.loop()` is called. The absence of any code that could set `gameLoop` to null after its initialization ensures that `Game.loop()` cannot return null.
---AdvancedNullAwayCodeFix.resolveMethodDereferenceError---
Method is not returning nullable on call site. Injecting suppression annotation.
---AdvancedNullAwayCodeFix.constructCastToNonnullChange---
Constructing cast to nonnull change for reason: The method `Game.loop()` returns the static field `gameLoop`, which is initialized in the `Game.init(String... args)` method. In this method, a new `GameLoop` object is instantiated and assigned to `gameLoop`. Since `init()` must be called before `start()`, which is implied by the requirement of initializing the game, the `gameLoop` is guaranteed to be non-null during the lifetime of the game execution where `Game.loop()` is called. The absence of any code that could set `gameLoop` to null after its initialization ensures that `Game.loop()` cannot return null.
---ChatGPT.ask---
Asking ChatGPT:
For the reason you mentioned earlier:

"The method `Game.loop()` returns the static field `gameLoop`, which is initialized in the `Game.init(String... args)` method. In this method, a new `GameLoop` object is instantiated and assigned to `gameLoop`. Since `init()` must be called before `start()`, which is implied by the requirement of initializing the game, the `gameLoop` is guaranteed to be non-null during the lifetime of the game execution where `Game.loop()` is called. The absence of any code that could set `gameLoop` to null after its initialization ensures that `Game.loop()` cannot return null."

in the method below, the expression Game.loop() is not nullable at the point it is used.

```java
public void apply(final Shape impactArea) {
    final List<ICombatEntity> affected = this.lookForAffectedEntities(impactArea);
    for (final ICombatEntity affectedEntity : affected) {
      this.apply(affectedEntity);
    }

    this.appliances.add(new EffectApplication(affected, impactArea));

    // if it is the first appliance -> register for update
    if (this.appliances.size() == 1) {
      Game.loop().attach(this);
    }
}
```
Please Summarize the reason in max 5 words and rewrite the method so that at the line "      Game.loop().attach(this);", at the occurrence of: "Game.loop()" is replaced with `NullabilityUtil.castToNonnull(Game.loop(), summary of reason)`
Replace "REASON" with the exact reason summary I provide to you (maximum 5 words), not with a generic explanation like "checked to be nonnull".
see the example below, for expression `foo.getBar()`, to wrap it with `NullabilityUtil.castToNonnull(foo.getBar(), "reason")`.

```java
public t(){
    String l = foo.getBar();
}
```

will be:
```java
public t(){
    String l = NullabilityUtil.castToNonnull(foo.getBar(), "checked to be nonnull");
}
```

### Instructions:

Do not import any additional classes.

Do not add Java comments.

Only modify relevant lines as required.

Return only the modified method wrapped in the XML format shown below.

Place the Java code inside the <code> tag using a CDATA block with ```java formatting.

Just give me the fixed code snippet in XML format in <response> tag like the example below. I will apply the fix to my codebase. Do not import any additional libraries or classes or add java comments. If you can provide the fixed code snippet, please provide it in the following format and place the code snippet in the <code> tag within ```java block.
<response>
  <success>true</success>
  <code><![CDATA[
  ```java
  Your fixed code snippet here
  ```
    ]]>
  </code>
</response>

---ChatGPT.sendRequestToOpenAI---
Retrieving response from cache
---Response.<init>---
Creating Response:
<response>
  <success>true</success>
  <code><![CDATA[
  ```java
public void apply(final Shape impactArea) {
    final List<ICombatEntity> affected = this.lookForAffectedEntities(impactArea);
    for (final ICombatEntity affectedEntity : affected) {
      this.apply(affectedEntity);
    }

    this.appliances.add(new EffectApplication(affected, impactArea));

    // if it is the first appliance -> register for update
    if (this.appliances.size() == 1) {
      NullabilityUtil.castToNonnull(Game.loop(), "always initialized before use").attach(this);
    }
}
  ```
    ]]>
  </code>
</response>
---Response.<init>---
Response created:
public void apply(final Shape impactArea) {
    final List<ICombatEntity> affected = this.lookForAffectedEntities(impactArea);
    for (final ICombatEntity affectedEntity : affected) {
      this.apply(affectedEntity);
    }

    this.appliances.add(new EffectApplication(affected, impactArea));

    // if it is the first appliance -> register for update
    if (this.appliances.size() == 1) {
      NullabilityUtil.castToNonnull(Game.loop(), "always initialized before use").attach(this);
    }
}
---ChatGPT.fixDereferenceByAddingCastToNonnull---
Fixing the error by adding castToNonnull
---AdvancedNullAwayCodeFix.fixTriggeredErrorsForLocation---
Resolving unresolvable error for triggered error: Type='DEREFERENCE_NULLABLE', message='dereferenced expression Game.loop() is @Nullable'
/home/nima/Developer/nullness-benchmarks/litiengine/src/de/gurkenlabs/litiengine/abilities/effects/Effect.java:168
      Game.loop().detach(this);
---AdvancedNullAwayCodeFix.fix---
Fixing error: Type='DEREFERENCE_NULLABLE', message='dereferenced expression Game.loop() is @Nullable'
/home/nima/Developer/nullness-benchmarks/litiengine/src/de/gurkenlabs/litiengine/abilities/effects/Effect.java:168
      Game.loop().detach(this);
---AdvancedNullAwayCodeFix.resolveDereferenceError---
Resolving dereference error: Type='DEREFERENCE_NULLABLE', message='dereferenced expression Game.loop() is @Nullable'
/home/nima/Developer/nullness-benchmarks/litiengine/src/de/gurkenlabs/litiengine/abilities/effects/Effect.java:168
      Game.loop().detach(this);
---AdvancedNullAwayCodeFix.resolveDereferenceError---
Checking nullability possibility at error point
---ChatGPT.checkNullabilityPossibilityAtErrorPoint---
Asking if the expression can be null at error point point
---ChatGPT.ask---
Asking ChatGPT:
In the method below, is there a possibility that the expression "Game.loop()" at line "Game.loop().detach(this);" is null?
@Override
  public void update() {

    for (final Iterator<EffectApplication> iterator = this.getActiveAppliances().iterator();
        iterator.hasNext(); ) {
      final EffectApplication appliance = iterator.next();
      // if the effect duration is reached
      if (this.hasEnded(appliance)) {

        iterator.remove();
        this.cease(appliance);
      }
    }

    // 4. unregister if all appliances are finished
    if (this.getActiveAppliances().isEmpty()) {
      Game.loop().detach(this);
    }
}
Give a single-word answer in XML format. If it is possible for the expression to be null, respond with:
```xml
<response>
    <reason><![CDATA[YOUR REASON]]></reason>
    <value>YES</value>
</response>
```
If it is not possible for the expression to be null, respond with:
```xml
<response>
    <reason><![CDATA[YOUR REASON]]></reason>
    <value>NO</value>
</response>
```
If you are unsure or need more information, respond with where you can ask for more details or what specific information you need.

If additional information is required, list each request inside a `<request>` tag. If no additional information is needed, omit the `<requests>` section.

Respond with:
```xml
<response>
    <reason><![CDATA[YOUR REASON]]></reason>
    <value>UNKNOWN</value>
    <!-- Include <requests> only if additional information is needed -->
    <requests>
        <request><![CDATA[YOUR REQUEST 1]]></request>
        <request><![CDATA[YOUR REQUEST 2]]></request>
    </requests>
</response>
```
---ChatGPT.sendRequestToOpenAI---
Retrieving response from cache
---Response.<init>---
Creating Response:
```xml
<response>
    <reason><![CDATA[The possibility of the expression Game.loop() being null depends on how the static method loop() in the Game class is implemented. Without access to the implementation details of the Game class, such as the loop() method ensuring a non-null return value, we cannot definitively determine if it can be null.]]></reason>
    <value>UNKNOWN</value>
    <requests>
        <request><![CDATA[Please provide the implementation details of the Game.loop() method.]]></request>
    </requests>
</response>
```
---Response.<init>---
Response created:
Unknown: The possibility of the expression Game.loop() being null depends on how the static method loop() in the Game class is implemented. Without access to the implementation details of the Game class, such as the loop() method ensuring a non-null return value, we cannot definitively determine if it can be null.
---AdvancedNullAwayCodeFix.resolveMethodDereferenceError---
Resolving method dereference error.
---AdvancedNullAwayCodeFix.resolveMethodDereferenceError---
Method is in annotated package. Checking if the method is returning nullable.
---AdvancedNullAwayCodeFix.investigateMethodReturnNullability---
Checking if the method is returning nullable.
---ChatGPT.checkIfMethodIsReturningNullable---
Asking if the method is returning nullable: loop()
---ChatGPT.ask---
Asking ChatGPT:
In the method below, is there a possibility that the method returns null based only on its body? Consider the following points:

- The method may have multiple return paths; consider all return statements.
- If the method calls another method, do not assume its return value unless its full declaration is provided. Request its declaration if needed.
- The method may throw an exception instead of returning null. An exception path should not be considered a null return.
- Ensure you request the declarations of any methods whose return values directly or indirectly impact this method’s return value before making a conclusion.
- Carefully analyze all conditions and prior operations that may guarantee a non-null return value.

@Nullable public static IGameLoop loop() {
    return gameLoop;
}

Here are the method definitions in addition to the method inquired:

Depth: 0
```java
class de.gurkenlabs.litiengine.Game {
@Nullable public static IGameLoop loop() {
    return gameLoop;
}
}
```


Response Format:
Provide the answer in **XML format** as follows:

#### If the method **cannot** return `null`:
```xml
<response>
  <reason><![CDATA[EXPLAIN WHY THE METHOD CANNOT RETURN NULL]]></reason>
  <value>NO</value>
</response>
```

#### If the method can return null:
```xml
<response>
  <reason><![CDATA[EXPLAIN WHY THE METHOD CAN RETURN NULL]]></reason>
  <value>YES</value>
</response>
```

#### If you are unsure or need more information, respond with where you can ask for more details or what specific information you need.

#### If you are unsure or If there are any methods that directly or indirectly affect the return value and are not fully disclosed, request their declarations first, in the following format:
<response>
  <reason><![CDATA[YOUR REASON]]></reason>
  <value>UNKNOWN</value>
  <methods>
    <method>methodName</method>
  </methods>
</response>

If additional information is required other than method declaration, list each request inside a `<request>` tag. If no additional information is needed, omit the `<requests>` section.

Respond with:
```xml
<response>
    <reason><![CDATA[YOUR REASON]]></reason>
    <value>UNKNOWN</value>
    <!-- Include <requests> only if additional information is needed -->
    <requests>
        <request><![CDATA[YOUR REQUEST 1]]></request>
        <request><![CDATA[YOUR REQUEST 2]]></request>
    </requests>
</response>
```

Additional Notes:
Be precise in your reasoning.
If a method’s return value depends on another method not provided, request its declaration before making a conclusion.
If the method can return null in some cases but not others, explain under what conditions it can happen.

---ChatGPT.sendRequestToOpenAI---
Retrieving response from cache
---Response.<init>---
Creating Response:
```xml
<response>
  <reason><![CDATA[The method `loop` returns the variable `gameLoop`. Without the initialization or assignment details of `gameLoop`, it's unclear whether it can be null. The possibility of `gameLoop` being uninitialized or set to null elsewhere in the program means `loop` could potentially return null. Further information on `gameLoop` is required.]]></reason>
  <value>UNKNOWN</value>
  <requests>
    <request><![CDATA[Please provide the declaration and initialization of the variable `gameLoop` in the class `de.gurkenlabs.litiengine.Game`.]]></request>
  </requests>
</response>
```
---Response.<init>---
Response created:
Unknown: The method `loop` returns the variable `gameLoop`. Without the initialization or assignment details of `gameLoop`, it's unclear whether it can be null. The possibility of `gameLoop` being uninitialized or set to null elsewhere in the program means `loop` could potentially return null. Further information on `gameLoop` is required.
---AdvancedNullAwayCodeFix.investigateMethodReturnNullability---
Could not determine the nullability and model did not ask for any method.
---ChatGPT.checkIfMethodIsReturningNullableOnCallSite---
Asking if the method is returning nullable on the call site: Game.loop()
---ChatGPT.ask---
Asking ChatGPT:
In the method below, is there a possibility that the method returns null at the given call site?

```java
@Nullable public static IGameLoop loop() {
    return gameLoop;
}
```

## Guidelines:
- The method may have multiple return paths; consider all return statements.
- If the method calls another method, do not assume its return value unless its full declaration is provided. Request its declaration if needed.
- The method may throw an exception instead of returning null. An exception path should not be considered a null return.
- Ensure you request the declarations of any methods whose return values directly or indirectly impact this method’s return value before making a conclusion.
- If the method returns a value that is determined by a parameter, evaluate based on the actual argument at the given call site.
- Analyze based only on the specific invocation provided. Do not generalize to all possible inputs.- If the return value is guaranteed to be non-null at the call site, the answer should be a definitive NO.
- Do not generalize based on all possible inputs—your answer must be based only on the given invocation.
- Focus only on the given call site, not all possible invocations.

### call site:
Game.loop()

Here are the method definitions and the call chain for this method, showing the sequence of calls from the method to its callers at each depth level:

Depth: 0
```java
class de.gurkenlabs.litiengine.Game {
@Nullable public static IGameLoop loop() {
    return gameLoop;
}
}
```
Depth: 1
```java
class de.gurkenlabs.litiengine.environment.GameWorld {
public void loadEnvironment(@Nullable final Environment env) {
    Lock lock = Game.loop().getLock();
    lock.lock();
    try {
      unloadEnvironment();
      this.environment = env;
      if (env != null) {
        this.addEnvironment(env);

        if (env.getGravity() == 0 && this.gravity() != 0) {
          env.setGravity(this.gravity());
        }

        env.load();
        for (final EnvironmentLoadedListener listener : this.loadedListeners) {
          listener.loaded(env);
        }

        // call map specific listeners
        String mapName = getMapName(env);
        if (mapName != null && this.environmentLoadedListeners.containsKey(mapName)) {

          // for the default camera we center the camera on the environment
          if (this.camera().getClass().equals(Camera.class)) {
            camera().setFocus(env.getCenter());
          }

          for (EnvironmentLoadedListener listener : this.environmentLoadedListeners.get(mapName)) {
            listener.loaded(env);
          }
        }
      }
    } finally {
      lock.unlock();
    }
}public void setCamera(@Nullable final ICamera cam) {
    if (this.camera() != null) {
      Game.loop().detach(camera);
    }

    camera = cam;

    if (cam != null && !Game.isInNoGUIMode()) {
      Game.loop().attach(cam);
      cam.updateFocus();
    }
}
}
```
```java
class de.gurkenlabs.litiengine.entities.behavior.EntityNavigator {
public EntityNavigator(final IMobileEntity entity, final PathFinder pathFinder) {
    this.cancelNavigationConditions = new CopyOnWriteArrayList<>();
    this.listeners = new CopyOnWriteArrayList<>();
    this.entity = entity;
    this.pathFinder = pathFinder;
    this.setAcceptableError(DEFAULT_ACCEPTABLE_ERROR);
    Game.loop().attach(this);
}
}
```
```java
class de.gurkenlabs.litiengine.GameWindow {
private static void initializeWindowEventListeners(Window window) {

    window.addWindowStateListener(
        e -> {
          if (e.getNewState() == Frame.ICONIFIED) {
            Game.loop().setTickRate(ICONIFIED_MAX_FPS);
          } else {
            Game.loop().setTickRate(Game.config().client().getMaxFps());
          }
        });

    window.addWindowFocusListener(
        new WindowFocusListener() {
          @Override
          public void windowLostFocus(WindowEvent e) {
            if (Game.config().graphics().reduceFramesWhenNotFocused()) {
              Game.loop().setTickRate(NONE_FOCUS_MAX_FPS);
            }
          }

          @Override
          public void windowGainedFocus(WindowEvent e) {
            Game.loop().setTickRate(Game.config().client().getMaxFps());
          }
        });

    window.addWindowListener(
        new WindowAdapter() {
          @Override
          public void windowClosing(final WindowEvent event) {
            Game.exit();
          }
        });
}
}
```
```java
class de.gurkenlabs.litiengine.gui.screens.ScreenManager {
public void display(@Nullable final Screen screen) {
    if (Game.hasStarted() && Game.time().since(this.lastScreenChange) < this.getChangeCooldown()) {
      log.log(
          Level.INFO,
          "Skipping displaying of screen {0} because screen changing is currently on cooldown.",
          screen != null ? screen.getName() : "");
      return;
    }

    final Screen previous = this.current();
    if (previous != null) {
      previous.suspend();
    }

    if (screen != null && !this.screens.contains(screen)) {
      this.screens.add(screen);
    }

    this.currentScreen = screen;
    if (!Game.isInNoGUIMode() && this.current() != null) {
      this.current().prepare();
    }

    this.lastScreenChange = Game.loop().getTicks();

    final ScreenChangedEvent event = new ScreenChangedEvent(this.current(), previous);
    for (final ScreenChangedListener listener : this.screenChangedListeners) {
      listener.changed(event);
    }
}
}
```
```java
class de.gurkenlabs.litiengine.abilities.effects.Effect {
@Override
  public void update() {

    for (final Iterator<EffectApplication> iterator = this.getActiveAppliances().iterator();
        iterator.hasNext(); ) {
      final EffectApplication appliance = iterator.next();
      // if the effect duration is reached
      if (this.hasEnded(appliance)) {

        iterator.remove();
        this.cease(appliance);
      }
    }

    // 4. unregister if all appliances are finished
    if (this.getActiveAppliances().isEmpty()) {
      Game.loop().detach(this);
    }
}public void apply(final Shape impactArea) {
    final List<ICombatEntity> affected = this.lookForAffectedEntities(impactArea);
    for (final ICombatEntity affectedEntity : affected) {
      this.apply(affectedEntity);
    }

    this.appliances.add(new EffectApplication(affected, impactArea));

    // if it is the first appliance -> register for update
    if (this.appliances.size() == 1) {
      Game.loop().attach(this);
    }
}
}
```
```java
class de.gurkenlabs.litiengine.GameTime {
public long toTicks(final int milliseconds) {
    return this.toTicks(milliseconds, Game.loop().getTickRate());
}public long since(final long tick) {
    return toMilliseconds(Game.loop().getTicks() - tick);
}public long now() {
    return Game.loop().getTicks();
}public long sinceGameStart() {
    return this.toMilliseconds(Game.loop().getTicks());
}@Override
  public void loaded(Environment environment) {
    environmentLoaded = Game.loop().getTicks();
}public long toMilliseconds(final long ticks) {
    return this.toMilliseconds(ticks, Game.loop().getTickRate());
}
}
```
```java
class de.gurkenlabs.litiengine.GameMetrics {
@Override
  public void render(final Graphics2D g) {
    this.updateMetrics();

    if (!Game.config().client().showGameMetrics()) {
      return;
    }

    this.currentOffsetY = 0;

    g.setColor(this.renderColor);

    // render client metrics
    this.drawTitle(g, "[client]");
    this.drawMetric(g, "fps       : " + this.getFramesPerSecond());
    this.drawMetric(g, "max fps   : " + this.maxFramesPerSecond);
    this.drawMetric(g, "updatables: " + Game.loop().getUpdatableCount());

    // render jvm metrics if debug is enabled
    if (Game.config().debug().isDebugEnabled()) {
      this.drawTitle(g, "[jvm]");
      this.drawMetric(g, "java      : " + this.javaVersion);
      this.drawMetric(g, "memory    : " + String.format("%-5.5s", this.usedMemory) + " MB");
      this.drawMetric(g, "threads   : " + Thread.activeCount());
    }

    // render rendering metrics
    if (!this.renderMetrics.isEmpty()) {
      this.drawTitle(g, "[update]");

      for (RenderMetrics metric : this.renderMetrics) {
        this.drawMetric(g, metric.toString());
      }

      this.renderMetrics.clear();
    }
}
}
```
```java
class de.gurkenlabs.litiengine.graphics.emitters.Emitter {
public void deactivate() {
    if (!this.activated) {
      return;
    }

    this.activated = false;
    this.getParticles().clear();
    this.aliveTime = 0;
    this.activationTick = 0;
    this.lastSpawn = 0;
    Game.loop().detach(this);
}public void activate() {
    if (this.activated) {
      return;
    }

    this.activated = true;
    this.activationTick = Game.time().now();
    Game.loop().attach(this);
}@Override
  public void update() {
    if (this.isPaused()) {
      return;
    }

    // clear particles if the effect time to life is reached
    if (this.isFinished()) {
      for (EmitterFinishedListener listener : this.finishedListeners) {
        listener.finished(this);
      }

      this.delete();
      return;
    }

    final float updateRatio = (float) this.data().getUpdateRate() / Game.loop().getTickRate();
    for (final Particle p : this.getParticles().stream().collect(Collectors.toList())) {
      if (this.particleCanBeRemoved(p)) {
        // remove dead particles
        this.particles.remove(p);
        continue;
      }

      p.update(this.getOrigin(), updateRatio);
    }

    this.aliveTime = Game.time().since(this.activationTick);
    if ((this.data().getSpawnRate() == 0
        || Game.time().since(this.lastSpawn) >= this.data().getSpawnRate())) {
      this.lastSpawn = Game.time().now();
      this.spawnParticle();
    }
}
}
```
```java
class de.gurkenlabs.litiengine.entities.behavior.IBehaviorController {
public default void attach() {
    Game.loop().attach(this);
}public default void detach() {
    Game.loop().detach(this);
}
}
```
```java
class de.gurkenlabs.litiengine.abilities.AbilityExecution {
AbilityExecution(final Ability ability) {
    this.appliedEffects = new CopyOnWriteArrayList<>();
    this.ability = ability;
    this.executionTicks = Game.time().now();
    this.impactArea = ability.calculateImpactArea();
    this.castLocation = ability.getExecutor().getCenter();
    Game.loop().attach(this);
}@Override
  public void update() {
    // if there a no effects to apply -> unregister this instance and we're done
    if (this.getAbility().getEffects().isEmpty()
        || this.getAbility().getEffects().size() == this.getAppliedEffects().size()) {
      Game.loop().detach(this);
      return;
    }

    // handle all effects from the ability that were not applied yet
    for (final Effect effect : this.getAbility().getEffects()) {
      // if the ability was not executed yet or the delay of the effect is not
      // yet reached
      if (this.getAppliedEffects().contains(effect)
          || Game.time().since(this.getExecutionTicks()) < effect.getDelay()) {
        continue;
      }

      effect.apply(this.getExecutionImpactArea());
      this.getAppliedEffects().add(effect);
    }
}
}
```
```java
class de.gurkenlabs.litiengine.GameWindow$3 {
@Override
          public void windowGainedFocus(WindowEvent e) {
            Game.loop().setTickRate(Game.config().client().getMaxFps());
}@Override
          public void windowLostFocus(WindowEvent e) {
            if (Game.config().graphics().reduceFramesWhenNotFocused()) {
              Game.loop().setTickRate(NONE_FOCUS_MAX_FPS);
            }
}
}
```
```java
class de.gurkenlabs.litiengine.environment.EntitySpawner {
protected void spawnNewEntities() {
    if (this.getSpawnMode() != SpawnMode.CUSTOMSPAWNPOINTS && this.getSpawnPoints().isEmpty()) {
      return;
    }

    switch (this.getSpawnMode()) {
      case ALLSPAWNPOINTS:
        for (int i = 0; i < this.getSpawnPoints().size(); i++) {
          final int index = i;
          Game.loop()
              .perform(
                  this.getSpawnDelay() + this.getSpawnDelay() * i,
                  () -> this.spawn(this.getSpawnPoints().get(index), this.getSpawnAmount()));
        }
        break;
      case ONERANDOMSPAWNPOINT:
        this.spawn(Game.random().choose(this.getSpawnPoints()), this.getSpawnAmount());
        break;
      case RANDOMSPAWNPOINTS:
        for (int i = 0; i < this.getSpawnAmount(); i++) {
          Game.loop()
              .perform(
                  this.getSpawnDelay() + this.getSpawnDelay() * i,
                  () -> this.spawn(Game.random().choose(this.getSpawnPoints()), 1));
        }
        break;
      case CUSTOMSPAWNPOINTS:
        List<Spawnpoint> spawnPoints =
            this.customSpawnpoints != null
                ? this.customSpawnpoints.apply(this)
                : this.getCustomSpawnpoints();

        int index = 0;
        for (Spawnpoint spawn : spawnPoints) {
          Game.loop()
              .perform(
                  this.getSpawnDelay() + this.getSpawnDelay() * index, () -> this.spawn(spawn, 1));
          index++;
        }
        break;
      default:
        break;
    }
}
}
```
```java
class de.gurkenlabs.litiengine.tweening.TweenEngine {
@Override
  public void start() {
    Game.loop().attach(this);
}@Override
  public void terminate() {
    Game.loop().detach(this);
}
}
```
```java
class de.gurkenlabs.litiengine.gui.SpeechBubble {
public void hide() {
    Game.world().environment().removeRenderable(this);
    Game.loop().detach(this);
    if (activeSpeechBubbles.get(this.getEntity()) != null
        && activeSpeechBubbles.remove(this.getEntity()).equals(this)) {
      activeSpeechBubbles.remove(this.getEntity());
    }

    for (SpeechBubbleListener listener : this.listeners) {
      listener.hidden();
    }
}private SpeechBubble(
      final IEntity entity,
      final String text,
      @Nullable SpeechBubbleAppearance appearance,
      @Nullable Font font) {
    if (appearance == null) {
      this.appearance = DEFAULT_APPEARANCE;
    } else {
      this.appearance = appearance;
    }

    final SpeechBubble active = activeSpeechBubbles.get(entity);
    if (active != null) {
      active.hide();
    }
    this.setFont(font);

    this.textBoxWidth = (float) (entity.getWidth() * 4);
    this.entity = entity;

    this.currentText = text;
    this.currentTextDisplayTime = DISPLAYTIME_MIN + text.length() * DISPLAYTIME_PER_LETTER;

    this.lastTextDisplay = Game.time().now();
    this.createBubbleImage();
    entity.getEnvironment().add(this, RenderType.UI);
    Game.loop().attach(this);
    activeSpeechBubbles.put(entity, this);
}
}
```
```java
class de.gurkenlabs.litiengine.entities.Prop {
private void updateAnimationController() {
    IEntityAnimationController<?> controller = this.createAnimationController();
    this.getControllers().addController(controller);
    if (Game.world().environment() != null && Game.world().environment().isLoaded()) {
      Game.loop().attach(controller);
    }
}
}
```
```java
class de.gurkenlabs.litiengine.graphics.FreeFlightCamera {
public FreeFlightCamera(final Point2D focus) {
    this.setFocus(focus);
    this.velocity = DEFAULT_SCROLL_PIXELS_PER_SECOND;
    this.scrollPadding = DEFAULT_SCROLL_PADDING;
    this.setClampToMap(true);

    Game.loop().attach(this);
}private void handleFreeFlightCamera() {
    if (Game.world().environment() == null || Game.world().environment().getMap() == null) {
      return;
    }

    final Point2D mouseLocation = Input.mouse().getLocation();

    final double scrollSpeed =
        this.getVelocity()
            / (double) Game.loop().getTickRate()
            * Game.config().input().getMouseSensitivity();

    double x = this.getFocus().getX();
    double y = this.getFocus().getY();

    double deltaX = 0;
    if (mouseLocation.getX() < this.getScrollPadding()) {
      deltaX -= scrollSpeed;
    } else if (Game.window().getResolution().getWidth() - mouseLocation.getX()
        < this.getScrollPadding()) {
      deltaX += scrollSpeed;
    }

    double deltaY = 0;
    if (mouseLocation.getY() < this.getScrollPadding()) {
      deltaY -= scrollSpeed;
    } else if (Game.window().getResolution().getHeight() - mouseLocation.getY()
        < this.getScrollPadding()) {
      deltaY += scrollSpeed;
    }

    x += deltaX;
    y += deltaY;

    this.setFocus(new Point2D.Double(x, y));
}
}
```
```java
class de.gurkenlabs.litiengine.environment.Environment {
private static void dispose(final Collection<? extends IEntity> entities) {
    for (final IEntity entity : entities) {
      if (entity instanceof IUpdateable) {
        Game.loop().detach((IUpdateable) entity);
      }

      entity.detachControllers();
    }
}private static void loadUpdatableOrEmitterEntity(IEntity entity) {
    if (entity instanceof Emitter) {
      final Emitter emitter = (Emitter) entity;
      if (emitter.isActivateOnInit()) {
        emitter.activate();
      }
    } else if (entity instanceof IUpdateable) {
      Game.loop().attach((IUpdateable) entity);
    }
}private void unload(final IEntity entity) {
    // 1. remove from physics engine
    if (entity instanceof ICollisionEntity) {
      Game.physics().remove((ICollisionEntity) entity);
    }

    // 2. unregister from update
    if (entity instanceof IUpdateable) {
      Game.loop().detach((IUpdateable) entity);
    }

    if (entity instanceof IMobileEntity) {
      this.removeGravity((IMobileEntity) entity);
    }

    // 3. detach all controllers
    entity.detachControllers();

    if (entity instanceof Emitter) {
      Emitter em = (Emitter) entity;
      em.deactivate();
    }

    if (this.loaded && (entity instanceof LightSource || entity instanceof StaticShadow)) {
      this.updateLighting(entity);
    }

    entity.removed(this);
}
}
```
```java
class de.gurkenlabs.litiengine.graphics.animation.Animation {
@Override
  public void update() {
    // do nothing if the animation is not playing or the current keyframe is not finished
    if (!this.isPlaying()
        || Game.time().since(this.lastFrameUpdate) < this.getCurrentKeyFrame().getDuration()) {
      return;
    }

    // if we are not looping and the last keyframe is finished, we terminate the animation
    if (!this.isLooping() && this.isLastKeyFrame()) {
      this.terminate();
      return;
    }

    // make sure, we stay inside the keyframe list
    final int newFrameIndex =
        (this.getKeyframes().indexOf(this.currentFrame) + 1) % this.getKeyframes().size();
    final KeyFrame previousFrame = this.currentFrame;
    this.currentFrame = this.getKeyframes().get(newFrameIndex);

    for (KeyFrameListener listener : this.listeners) {
      listener.currentFrameChanged(previousFrame, this.currentFrame);
    }

    this.lastFrameUpdate = Game.loop().getTicks();
}public void restart() {
    this.currentFrame = this.firstFrame;
    this.lastFrameUpdate = Game.loop().getTicks();
}
}
```
```java
class de.gurkenlabs.litiengine.physics.MovementController {
@Override
  public void attach() {
    Game.loop().attach(this);
}private void handleForces() {
    // clean up forces
    this.activeForces.forEach(
        x -> {
          if (x.hasEnded()) {
            this.activeForces.remove(x);
          }
        });

    if (this.activeForces.isEmpty()) {
      return;
    }

    // disable turn-on-move for force handling
    boolean turn = this.getEntity().turnOnMove();
    this.getEntity().setTurnOnMove(false);
    try {
      double deltaX = 0;
      double deltaY = 0;
      for (final Force force : this.activeForces) {
        if (force.cancelOnReached() && force.hasReached(this.getEntity())) {
          force.end();
          continue;
        }

        final Point2D collisionBoxCenter = this.getEntity().getCollisionBoxCenter();
        final double angle =
            GeometricUtilities.calcRotationAngleInDegrees(collisionBoxCenter, force.getLocation());
        final double strength =
            Game.loop().getDeltaTime() * 0.001f * force.getStrength() * Game.loop().getTimeScale();
        deltaX += GeometricUtilities.getDeltaX(angle, strength);
        deltaY += GeometricUtilities.getDeltaY(angle, strength);
      }

      final Point2D target =
          new Point2D.Double(this.getEntity().getX() + deltaX, this.getEntity().getY() + deltaY);
      final boolean success = Game.physics().move(this.getEntity(), target);
      if (!success) {
        for (final Force force : this.activeForces) {
          if (force.cancelOnCollision()) {
            force.end();
          }
        }
      }
    } finally {
      this.getEntity().setTurnOnMove(turn);
    }
}@Override
  public void detach() {
    Game.loop().detach(this);
}public void handleMovement() {
    if (!this.isMovementAllowed()) {
      this.velocity = 0;
      return;
    }

    // max distance an entity can travel within one tick
    final double maxPixelsPerTick = this.getEntity().getTickVelocity();
    final double deltaTime = Game.loop().getDeltaTime() * Game.loop().getTimeScale();

    final double acceleration =
        this.getEntity().getAcceleration() == 0
            ? maxPixelsPerTick
            : deltaTime / this.getEntity().getAcceleration() * maxPixelsPerTick;
    final double deceleration =
        this.getEntity().getDeceleration() == 0
            ? this.getVelocity()
            : deltaTime / this.getEntity().getDeceleration() * maxPixelsPerTick;

    double dx = this.getDx();
    double dy = this.getDy();
    this.setDx(0);
    this.setDy(0);

    final double deltaVelocity =
        Math.min(Math.sqrt(Math.pow(dx, 2) + Math.pow(dy, 2)), acceleration);
    if (deltaVelocity != 0) {
      double newVelocity = this.getVelocity() + deltaVelocity;
      this.setVelocity(newVelocity);
    } else {
      final double newVelocity = Math.max(0, this.getVelocity() - deceleration);
      this.setVelocity(newVelocity);
      dx = GeometricUtilities.getDeltaX(this.moveAngle);
      dy = GeometricUtilities.getDeltaY(this.moveAngle);
    }

    if (this.getVelocity() == 0) {
      this.moveAngle = 0;
      return;
    }

    // actually move entity
    this.moveEntity(dx, dy);
}
}
```
```java
class de.gurkenlabs.litiengine.graphics.animation.AnimationController {
public void detach() {
    Game.loop().detach(this);
}public void attach() {
    Game.loop().attach(this);
}
}
```
```java
class de.gurkenlabs.litiengine.graphics.Camera {
@Override
  public void setZoom(final float targetZoom, final int delay) {
    if (delay == 0) {

      this.zoom = targetZoom;
      this.targetZoom = 0;
      this.zoomDelay = 0;
      this.zoomTick = 0;
      this.zoomStep = 0;

      final ZoomChangedEvent event = new ZoomChangedEvent(this, targetZoom);
      for (final ZoomChangedListener listener : this.zoomListeners) {
        listener.zoomChanged(event);
      }
    } else {
      this.zoomTick = Game.time().now();
      this.targetZoom = targetZoom;
      this.zoomDelay = delay;

      final double tickduration = 1000 / (double) Game.loop().getTickRate();
      final double tickAmount = delay / tickduration;
      final float totalDelta = this.targetZoom - this.zoom;
      this.zoomStep = tickAmount > 0 ? (float) (totalDelta / tickAmount) : totalDelta;
    }
}
}
```
```java
class de.gurkenlabs.litiengine.Game {
public static synchronized void init(String... args) {
    if (initialized) {
      log().log(Level.INFO, "The game has already been initialized.");
      return;
    }

    log.init();
    handleCommandLineArguments(args);

    config().load();
    Locale.setDefault(new Locale(config().client().getCountry(), config().client().getLanguage()));

    gameLoop = new GameLoop("Main Update Loop", config().client().getMaxFps());
    loop().attach(physics());
    loop().attach(world());

    // setup default exception handling for render and update loop
    setUncaughtExceptionHandler(
        new DefaultUncaughtExceptionHandler(config().client().exitOnError()));

    screenManager = new ScreenManager();
    gameWindow = new GameWindow();

    // initialize  the game window
    window().init();
    world.setCamera(new Camera());

    for (GameListener listener : gameListeners) {
      listener.initialized(args);
    }

    if (!isInNoGUIMode()) {
      window().getRenderComponent().onRendered(g -> metrics().render(g));

      graphics()
          .addEntityRenderedListener(
              e -> DebugRenderer.renderEntityDebugInfo(e.getGraphics(), e.getEntity()));

      window().getRenderComponent().onFpsChanged(fps -> metrics().setFramesPerSecond(fps));
      window()
          .setIcons(
              Arrays.asList(
                  Resources.images().get("liti-logo-x16.png"),
                  Resources.images().get("liti-logo-x20.png"),
                  Resources.images().get("liti-logo-x32.png"),
                  Resources.images().get("liti-logo-x48.png")));

      Input.keyboard()
          .onKeyTyped(
              KeyEvent.VK_PRINTSCREEN,
              key -> {
                // don't take a screenshot if a modifier is active
                if (key.getModifiers() != 0) {
                  return;
                }

                window().getRenderComponent().takeScreenshot();
              });
    }

    Runtime.getRuntime().addShutdownHook(new Thread(Game::terminate, "Shutdown"));

    initialized = true;
}
}
```
```java
class de.gurkenlabs.litiengine.entities.Creature {
protected void updateAnimationController() {
    IEntityAnimationController<?> controller = this.createAnimationController();
    this.getControllers().addController(controller);
    if (Game.world().environment() != null && Game.world().environment().isLoaded()) {
      Game.loop().attach(controller);
    }
}@Override
  public float getTickVelocity() {
    // pixels per ms multiplied by the passed ms
    // ensure that entities don't travel too far in case of lag
    return Math.min(Game.loop().getDeltaTime(), GameLoop.TICK_DELTATIME_LAG)
        * 0.001F
        * this.getVelocity().get()
        * Game.loop().getTimeScale();
}
}
```
Depth: 2
```java
class de.gurkenlabs.litiengine.environment.GameWorld {
public void clear() {
    this.unloadEnvironment();
    this.environments.clear();
    this.setCamera(null);
    Game.physics().clear();

    this.environmentListeners.clear();
    this.environmentLoadedListeners.clear();
    this.environmentUnloadedListeners.clear();

    this.listeners.clear();
    this.loadedListeners.clear();
    this.unloadedListeners.clear();
}@Nullable
  public Environment loadEnvironment(IMap map) {
    Environment env = this.getEnvironment(map);
    this.loadEnvironment(env);
    return env;
}@Nullable
  public Environment loadEnvironment(String mapName) {
    Environment env = this.getEnvironment(mapName);
    this.loadEnvironment(env);
    return env;
}
}
```
```java
class de.gurkenlabs.litiengine.GameWindow {
GameWindow() {
    this.hostControl = new JFrame();

    this.resolutionChangedListeners = new CopyOnWriteArrayList<>();

    this.renderCanvas = new RenderComponent(Game.config().graphics().getResolution());
    this.cursor = new MouseCursor();
    if (!Game.isInNoGUIMode()) {
      this.hostControl.setBackground(Color.BLACK);
      this.hostControl.add(this.renderCanvas);

      this.initializeEventListeners();

      this.hostControl.setTitle(Game.info().getTitle());
      this.hostControl.setDefaultCloseOperation(WindowConstants.DO_NOTHING_ON_CLOSE);
      initializeWindowEventListeners(this.hostControl);
    }
}
}
```
```java
class de.gurkenlabs.litiengine.GameTime {
public long sinceEnvironmentLoad() {
    return this.since(this.environmentLoaded);
}public long since(final long tick) {
    return toMilliseconds(Game.loop().getTicks() - tick);
}public long sinceGameStart() {
    return this.toMilliseconds(Game.loop().getTicks());
}
}
```
```java
class de.gurkenlabs.litiengine.abilities.effects.Effect {
protected void cease(final EffectApplication appliance) {
    // 1. cease the effect for all affected entities
    for (final ICombatEntity entity : appliance.getAffectedEntities()) {
      this.cease(entity);
    }

    // 2. apply follow up effects
    this.getFollowUpEffects().forEach(followUp -> followUp.apply(appliance.getImpactArea()));
}protected boolean hasEnded(final EffectApplication appliance) {
    final long effectDuration = Game.time().since(appliance.getAppliedTicks());
    return effectDuration > this.getDuration();
}
}
```
```java
class de.gurkenlabs.litiengine.abilities.effects.EffectApplication {
protected EffectApplication(final List<ICombatEntity> affectedEntities, final Shape impactArea) {
    this.applied = Game.time().now();
    this.affectedEntities = affectedEntities;
    this.impactArea = impactArea;
}
}
```
```java
class de.gurkenlabs.litiengine.entities.CombatEntity {
@Override
  public boolean wasHit(int timeSpan) {
    return Game.time().since(this.lastHit) < timeSpan;
}@Override
  public void hit(final int damage, @Nullable final Ability ability) {
    if (this.isDead()) {
      return;
    }

    if (!this.isIndestructible()) {
      this.getHitPoints().modifyBaseValue(new AttributeModifier<>(Modification.SUBTRACT, damage));
    }

    final EntityHitEvent event = new EntityHitEvent(this, ability, damage, this.isDead());

    for (final CombatEntityListener listener : this.listeners) {
      listener.hit(event);
    }

    for (final CombatEntityHitListener listener : this.hitListeners) {
      listener.hit(event);
    }

    if (this.isDead()) {
      this.fireDeathEvent();
      this.setCollision(false);
    }

    this.lastHit = Game.time().now();
}
}
```
```java
class de.gurkenlabs.litiengine.graphics.ImageEffect {
protected ImageEffect(final int ttl, final String name) {
    this.ttl = ttl;
    this.name = name;
    this.aliveTick = Game.time().now();
}@Override
  public long getAliveTime() {
    return Game.time().since(this.aliveTick);
}
}
```
```java
class de.gurkenlabs.litiengine.abilities.AbilityExecution {
AbilityExecution(final Ability ability) {
    this.appliedEffects = new CopyOnWriteArrayList<>();
    this.ability = ability;
    this.executionTicks = Game.time().now();
    this.impactArea = ability.calculateImpactArea();
    this.castLocation = ability.getExecutor().getCenter();
    Game.loop().attach(this);
}@Override
  public void update() {
    // if there a no effects to apply -> unregister this instance and we're done
    if (this.getAbility().getEffects().isEmpty()
        || this.getAbility().getEffects().size() == this.getAppliedEffects().size()) {
      Game.loop().detach(this);
      return;
    }

    // handle all effects from the ability that were not applied yet
    for (final Effect effect : this.getAbility().getEffects()) {
      // if the ability was not executed yet or the delay of the effect is not
      // yet reached
      if (this.getAppliedEffects().contains(effect)
          || Game.time().since(this.getExecutionTicks()) < effect.getDelay()) {
        continue;
      }

      effect.apply(this.getExecutionImpactArea());
      this.getAppliedEffects().add(effect);
    }
}
}
```
```java
class de.gurkenlabs.litiengine.tweening.TweenEngine {
@Override
  public void update() {
    for (final Tweenable target : this.getTweens().keySet()) {
      for (final Tween tween : this.getTweens().get(target).values()) {
        if (tween.hasStopped()) {
          continue;
        }
        final long elapsed = Game.time().since(tween.getStartTime());
        if (elapsed >= tween.getDuration()) {
          tween.stop();
          continue;
        }
        final float[] currentValues = new float[tween.getTargetValues().length];
        for (int i = 0; i < tween.getTargetValues().length; i++) {
          currentValues[i] =
              tween.getStartValues()[i]
                  + tween.getEquation().compute(elapsed / (float) tween.getDuration())
                      * (tween.getTargetValues()[i] - tween.getStartValues()[i]);
        }
        tween.getTarget().setTweenValues(tween.getType(), currentValues);
      }
    }
}
}
```
```java
class de.gurkenlabs.litiengine.gui.SpeechBubble {
public static SpeechBubble create(
      final IEntity entity, final String text, SpeechBubbleAppearance appearance, Font font) {
    return new SpeechBubble(entity, text, appearance, font);
}public static SpeechBubble create(final IEntity entity, final Font font, final String text) {
    SpeechBubbleAppearance app =
        new SpeechBubbleAppearance(
            DEFAULT_APPEARANCE.getForeColor(),
            DEFAULT_APPEARANCE.getBackgroundColor1(),
            DEFAULT_APPEARANCE.getBorderColor(),
            DEFAULT_APPEARANCE.getPadding());
    return new SpeechBubble(entity, text, app, font);
}public static SpeechBubble create(final IEntity entity, final String text) {
    return new SpeechBubble(entity, text, null, GuiProperties.getDefaultFont());
}@Override
  public void update() {
    if (this.currentText == null) {
      this.hide();
      return;
    }

    this.entityCenter = Game.world().camera().getViewportLocation(this.getEntity().getCenter());

    // old text was displayed long enough
    if (this.lastTextDisplay != 0
        && Game.time().since(this.lastTextDisplay) > this.currentTextDisplayTime) {
      this.currentText = null;
      this.lastTextDisplay = 0;
      return;
    }

    // display new text
    if (this.textIndex < this.currentText.length()
        && Game.time().since(this.lastCharPoll) > LETTER_WRITE_DELAY) {
      this.textIndex++;
      this.lastCharPoll = Game.time().now();
      if (this.typeSound != null) {
        Game.audio().playSound(this.typeSound, this.getEntity());
      }
    }

    // continue displaying currently displayed text
}private SpeechBubble(
      final IEntity entity,
      final String text,
      final Sound typeSound,
      SpeechBubbleAppearance appearance,
      Font font) {
    this(entity, text, appearance, font);
    this.typeSound = typeSound;
}private SpeechBubble(
      final IEntity entity,
      final String text,
      @Nullable SpeechBubbleAppearance appearance,
      @Nullable Font font) {
    if (appearance == null) {
      this.appearance = DEFAULT_APPEARANCE;
    } else {
      this.appearance = appearance;
    }

    final SpeechBubble active = activeSpeechBubbles.get(entity);
    if (active != null) {
      active.hide();
    }
    this.setFont(font);

    this.textBoxWidth = (float) (entity.getWidth() * 4);
    this.entity = entity;

    this.currentText = text;
    this.currentTextDisplayTime = DISPLAYTIME_MIN + text.length() * DISPLAYTIME_PER_LETTER;

    this.lastTextDisplay = Game.time().now();
    this.createBubbleImage();
    entity.getEnvironment().add(this, RenderType.UI);
    Game.loop().attach(this);
    activeSpeechBubbles.put(entity, this);
}
}
```
```java
class de.gurkenlabs.litiengine.gui.TextFieldComponent {
@Override
  public void render(final Graphics2D g) {
    super.render(g);
    g.setFont(this.getFont());
    final FontMetrics fm = g.getFontMetrics();

    if (this.isSelected() && Game.time().since(this.lastToggled) > this.flickerDelay) {
      this.cursorVisible = !this.cursorVisible;
      this.lastToggled = Game.time().now();
    }
    if (this.isSelected() && this.cursorVisible) {
      final Rectangle2D cursor =
          new Rectangle2D.Double(
              this.getX() + this.getTextX() + fm.stringWidth(this.getTextToRender(g)),
              this.getY() + this.getTextY(),
              this.getFont().getSize2D() * 3 / 5,
              this.getFont().getSize2D() * 1 / 5);
      g.setColor(this.getAppearance().getForeColor());
      g.fill(cursor);
    }
}
}
```
```java
class de.gurkenlabs.litiengine.entities.Prop {
public Prop(
      final Point2D location, @Nullable final String spritesheetName, final Material material) {
    super();
    this.rotation = Rotation.NONE;
    this.spritesheetName = spritesheetName;
    this.material = material;
    this.setLocation(location);
    this.updateAnimationController();
}public void setSpritesheetName(@Nullable final String spriteName) {
    this.spritesheetName = spriteName;
    this.updateAnimationController();
}
}
```
```java
class de.gurkenlabs.litiengine.tweening.Tween {
public Tween begin() {
    this.started = Game.time().now();
    this.stopped = false;
    return this;
}
}
```
```java
class de.gurkenlabs.litiengine.graphics.emitters.particles.Particle {
public void update(final Point2D emitterOrigin, final float updateRatio) {
    if (this.aliveTick == 0) {
      this.aliveTick = Game.time().now();
    }

    this.aliveTime = Game.time().since(this.aliveTick);
    if (this.timeToLiveReached()) {
      return;
    }

    if (this.colliding) {
      return;
    }

    if (this.getDeltaWidth() != 0) {
      this.width += this.getDeltaWidth() * updateRatio;
    }

    if (this.getDeltaHeight() != 0) {
      this.height += this.getDeltaHeight() * updateRatio;
    }

    if (this.getDeltaAngle() != 0) {
      this.angle += this.getDeltaAngle() * updateRatio;
    }

    // test for ray cast collision
    final float targetX = this.x + this.getVelocityX() * updateRatio;
    final float targetY = this.y + this.getVelocityY() * updateRatio;

    if (targetX == this.x && targetY == this.y) {
      return;
    }

    if (this.checkForCollision(emitterOrigin, targetX, targetY)) {
      return;
    }

    if (this.getVelocityX() != 0) {
      this.x = targetX;
    }

    if (this.getVelocityY() != 0) {
      this.y = targetY;
    }

    if (this.getAccelerationX() != 0) {
      this.velocityX += this.getAccelerationX() * updateRatio;
    }

    if (this.getAccelerationY() != 0) {
      this.velocityY += this.getAccelerationY() * updateRatio;
    }
}
}
```
```java
class de.gurkenlabs.litiengine.graphics.animation.Animation {
@Override
  public void start() {
    this.playing = true;
    if (this.getKeyframes().isEmpty()) {
      return;
    }

    this.restart();
}@Override
  public void update() {
    // do nothing if the animation is not playing or the current keyframe is not finished
    if (!this.isPlaying()
        || Game.time().since(this.lastFrameUpdate) < this.getCurrentKeyFrame().getDuration()) {
      return;
    }

    // if we are not looping and the last keyframe is finished, we terminate the animation
    if (!this.isLooping() && this.isLastKeyFrame()) {
      this.terminate();
      return;
    }

    // make sure, we stay inside the keyframe list
    final int newFrameIndex =
        (this.getKeyframes().indexOf(this.currentFrame) + 1) % this.getKeyframes().size();
    final KeyFrame previousFrame = this.currentFrame;
    this.currentFrame = this.getKeyframes().get(newFrameIndex);

    for (KeyFrameListener listener : this.listeners) {
      listener.currentFrameChanged(previousFrame, this.currentFrame);
    }

    this.lastFrameUpdate = Game.loop().getTicks();
}
}
```
```java
class de.gurkenlabs.litiengine.graphics.animation.AnimationController {
@Override
  public void update() {
    for (final Animation animation : this.getAll()) {
      animation.update();
    }

    if (this.getCurrent() != null && this.getCurrent().isPaused()) {
      return;
    }

    final boolean playbackFinished = this.getCurrent() != null && !this.getCurrent().isPlaying();
    if (playbackFinished) {
      for (final AnimationListener listener : this.listeners) {
        listener.finished(this.getCurrent());
      }
    }

    if (this.getCurrent() == null || playbackFinished) {
      if (this.getDefault() != null) {
        this.play(this.getDefault().getName());
      } else {
        this.currentAnimation = null;
      }
    }
}
}
```
```java
class de.gurkenlabs.litiengine.graphics.RenderComponent {
private void handleFade() {
    if (this.fadeOutStart != -1) {
      final long timePassed = Game.time().since(this.fadeOutStart);
      this.currentAlpha = MathUtilities.clamp(1 - timePassed / (float) this.fadeOutTime, 0, 1);
      if (this.currentAlpha == 0f) {
        this.fadeOutStart = -1;
        this.fadeOutTime = -1;
      }

      return;
    }

    if (this.fadeInStart != -1) {
      final long timePassed = Game.time().since(this.fadeInStart);
      this.currentAlpha = MathUtilities.clamp(timePassed / (float) this.fadeInTime, 0, 1);
      if (this.currentAlpha == 1f) {
        this.fadeInStart = -1;
        this.fadeInTime = -1;
        this.currentAlpha = Float.NaN;
      }
    }
}public void fadeOut(final int ms) {
    this.fadeInStart = -1;
    this.fadeInTime = -1;
    this.fadeOutStart = Game.time().now();
    this.fadeOutTime = ms;
}public void fadeIn(final int ms) {
    this.fadeOutStart = -1;
    this.fadeOutTime = -1;
    this.fadeInStart = Game.time().now();
    this.fadeInTime = ms;
}
}
```
```java
class de.gurkenlabs.litiengine.entities.Trigger {
private boolean activate(final IEntity activator, final int tar) {
    if (!this.isLoaded()
        || this.isOneTimeTrigger && this.isActivated
        || this.getActivationType() == TriggerActivation.COLLISION
            && activator != null
            && this.collisionActivated.contains(activator)) {
      return false;
    }

    if (this.getCooldown() > 0 && Game.time().since(this.lastActivation) < this.getCooldown()) {
      return false;
    }

    List<Integer> triggerTargets = this.getTargets(tar);

    final TriggerEvent te = new TriggerEvent(this, activator, triggerTargets);

    if (!this.checkActivationPredicates(te)) {
      return false;
    }

    this.isActivated = true;
    if (activator != null) {
      this.collisionActivated.add(activator);
    }

    // if we actually have a trigger target, we send the message to the target
    for (final int target : triggerTargets) {
      final IEntity entity = this.getEnvironment().get(target);
      if (entity == null) {
        log.log(
            Level.WARNING,
            "trigger [{0}] was activated, but the trigger target [{1}] could not be found on the environment",
            new Object[] {this, target});
        continue;
      }

      entity.sendMessage(this, this.message);
    }

    // also send the trigger event to all registered consumers
    for (final TriggerActivatedListener listener : this.activatedListeners) {
      listener.activated(te);
    }

    if (this.isOneTimeTrigger) {
      this.getEnvironment().remove(this);
    }

    this.lastActivation = Game.time().now();
    return true;
}
}
```
```java
class de.gurkenlabs.litiengine.graphics.Camera {
private boolean isShakeEffectActive() {
    return this.getShakeTick() != 0
        && Game.time().since(this.getShakeTick()) < this.getShakeDuration();
}@Override
  public void update() {
    if (Game.world().camera() != null && !Game.world().camera().equals(this)) {
      return;
    }

    if (this.targetZoom > 0) {
      if (Game.time().since(this.zoomTick) >= this.zoomDelay) {
        this.zoom = this.targetZoom;
        this.targetZoom = 0;
        this.zoomDelay = 0;
        this.zoomTick = 0;
        this.zoomStep = 0;
      } else {
        this.zoom += this.zoomStep;
      }

      final ZoomChangedEvent event = new ZoomChangedEvent(this, this.getZoom());
      for (final ZoomChangedListener listener : this.zoomListeners) {
        listener.zoomChanged(event);
      }
    }

    if (this.panTime > 0) {
      if (--this.panTime <= 0) {
        this.setFocus(this.targetFocus);
        this.targetFocus = null;
      } else {
        double diff = this.panTime / (this.panTime + 1.0);
        this.focus =
            new Point2D.Double(
                this.focus.getX() * diff + this.targetFocus.getX() * (1.0 - diff),
                this.focus.getY() * diff + this.targetFocus.getY() * (1.0 - diff));
      }
    }

    if (!this.isShakeEffectActive()) {
      this.shakeOffsetX = 0;
      this.shakeOffsetY = 0;
      return;
    }

    if (Game.time().since(this.lastShake) > this.shakeDelay) {
      this.shakeOffsetX = this.getShakeIntensity() * ThreadLocalRandom.current().nextGaussian();
      this.shakeOffsetY = this.getShakeIntensity() * ThreadLocalRandom.current().nextGaussian();
      this.lastShake = Game.time().now();
    }
}@Override
  public void setZoom(final float targetZoom, final int delay) {
    if (delay == 0) {

      this.zoom = targetZoom;
      this.targetZoom = 0;
      this.zoomDelay = 0;
      this.zoomTick = 0;
      this.zoomStep = 0;

      final ZoomChangedEvent event = new ZoomChangedEvent(this, targetZoom);
      for (final ZoomChangedListener listener : this.zoomListeners) {
        listener.zoomChanged(event);
      }
    } else {
      this.zoomTick = Game.time().now();
      this.targetZoom = targetZoom;
      this.zoomDelay = delay;

      final double tickduration = 1000 / (double) Game.loop().getTickRate();
      final double tickAmount = delay / tickduration;
      final float totalDelta = this.targetZoom - this.zoom;
      this.zoomStep = tickAmount > 0 ? (float) (totalDelta / tickAmount) : totalDelta;
    }
}@Override
  public void shake(final double intensity, final int delay, final int shakeDuration) {
    this.shakeTick = Game.time().now();
    this.shakeDelay = delay;
    this.shakeIntensity = intensity;
    this.shakeDuration = shakeDuration;
}
}
```
```java
class de.gurkenlabs.litiengine.entities.Creature {
public void setSpritesheetName(String spritesheetName) {
    if (this.spritesheetName != null && this.spritesheetName.equals(spritesheetName)) {
      return;
    }

    this.spritesheetName = spritesheetName;
    this.updateAnimationController();
}public boolean isIdle() {
    return Game.time().since(this.lastMoved) > IDLE_DELAY;
}@Override
  public void setLocation(final Point2D position) {
    if (this.isDead() || position == null) {
      return;
    }

    final Point2D oldLocation = this.getLocation();
    super.setLocation(position);

    if (Game.hasStarted() && this.isLoaded()) {
      this.lastMoved = Game.time().now();
      this.fireMovedEvent(
          new EntityMovedEvent(
              this, this.getX() - oldLocation.getX(), this.getY() - oldLocation.getY()));
    }
}
}
```
```java
class de.gurkenlabs.litiengine.gui.screens.ScreenManager {
public void display(final String screenName) {
    if (this.current() != null && this.current().getName().equalsIgnoreCase(screenName)) {
      log.log(
          Level.INFO,
          "Skipping displaying of screen {0} because it is already the current screen.",
          screenName);
      return;
    }

    if (this.screens.stream()
        .noneMatch(element -> element.getName().equalsIgnoreCase(screenName))) {
      log.log(
          Level.WARNING,
          "Could not display the screen {0} because there is no screen with the specified name.",
          screenName);
      return;
    }

    Screen screen = this.get(screenName);
    if (screen == null) {
      return;
    }

    this.display(screen);
}public void add(final Screen screen) {
    screen.setWidth(Game.window().getWidth());
    screen.setHeight(Game.window().getHeight());
    this.screens.add(screen);

    if (this.current() == null) {
      this.display(screen);
    }
}public void remove(Screen screen) {
    this.screens.remove(screen);
    if (this.current() == screen) {
      if (!this.screens.isEmpty()) {
        this.display(this.screens.get(0));
      } else {
        this.display((Screen) null);
      }
    }
}public void display(@Nullable final Screen screen) {
    if (Game.hasStarted() && Game.time().since(this.lastScreenChange) < this.getChangeCooldown()) {
      log.log(
          Level.INFO,
          "Skipping displaying of screen {0} because screen changing is currently on cooldown.",
          screen != null ? screen.getName() : "");
      return;
    }

    final Screen previous = this.current();
    if (previous != null) {
      previous.suspend();
    }

    if (screen != null && !this.screens.contains(screen)) {
      this.screens.add(screen);
    }

    this.currentScreen = screen;
    if (!Game.isInNoGUIMode() && this.current() != null) {
      this.current().prepare();
    }

    this.lastScreenChange = Game.loop().getTicks();

    final ScreenChangedEvent event = new ScreenChangedEvent(this.current(), previous);
    for (final ScreenChangedListener listener : this.screenChangedListeners) {
      listener.changed(event);
    }
}
}
```
```java
class de.gurkenlabs.litiengine.abilities.Ability {
public boolean isOnCooldown() {
    return (this.getCurrentExecution() != null
        && this.getCurrentExecution().getExecutionTicks() > 0
        && Game.time().since(this.getCurrentExecution().getExecutionTicks())
            < this.getAttributes().cooldown().get());
}public boolean isActive() {
    return this.getCurrentExecution() != null
        && Game.time().since(this.getCurrentExecution().getExecutionTicks())
            < this.getAttributes().duration().get();
}@Nullable
  public AbilityExecution cast() {
    if (!this.canCast()) {
      return null;
    }
    this.currentExecution = new AbilityExecution(this);

    for (final AbilityCastListener listener : this.abilityCastListeners) {
      listener.abilityCast(this.currentExecution);
    }

    return this.getCurrentExecution();
}public float getRemainingCooldownInSeconds() {
    if (this.getCurrentExecution() == null
        || this.getExecutor() == null
        || this.getExecutor().isDead()) {
      return 0;
    }

    // calculate cooldown in seconds
    return (float)
        (!this.canCast()
            ? (this.getAttributes().cooldown().get()
                    - Game.time().since(this.getCurrentExecution().getExecutionTicks()))
                * 0.001
            : 0);
}
}
```
```java
class de.gurkenlabs.litiengine.entities.EntityHitEvent {
EntityHitEvent(
      final ICombatEntity hitEntity,
      @Nullable final Ability ability,
      final int damage,
      final boolean kill) {
    super(hitEntity);
    this.executor = ability != null ? ability.getExecutor() : null;
    this.hitEntity = hitEntity;
    this.ability = ability;
    this.damage = damage;
    this.kill = kill;
    this.time = Game.time().now();
}
}
```
```java
class de.gurkenlabs.litiengine.graphics.emitters.Emitter {
public void delete() {
    this.deactivate();
    if (Game.world().environment() != null) {
      Game.world().environment().remove(this);
    }
}public void activate() {
    if (this.activated) {
      return;
    }

    this.activated = true;
    this.activationTick = Game.time().now();
    Game.loop().attach(this);
}@Override
  public void update() {
    if (this.isPaused()) {
      return;
    }

    // clear particles if the effect time to life is reached
    if (this.isFinished()) {
      for (EmitterFinishedListener listener : this.finishedListeners) {
        listener.finished(this);
      }

      this.delete();
      return;
    }

    final float updateRatio = (float) this.data().getUpdateRate() / Game.loop().getTickRate();
    for (final Particle p : this.getParticles().stream().collect(Collectors.toList())) {
      if (this.particleCanBeRemoved(p)) {
        // remove dead particles
        this.particles.remove(p);
        continue;
      }

      p.update(this.getOrigin(), updateRatio);
    }

    this.aliveTime = Game.time().since(this.activationTick);
    if ((this.data().getSpawnRate() == 0
        || Game.time().since(this.lastSpawn) >= this.data().getSpawnRate())) {
      this.lastSpawn = Game.time().now();
      this.spawnParticle();
    }
}
}
```
```java
class de.gurkenlabs.litiengine.GameLoop {
@Override
  public int perform(int delay, Runnable action) {
    final long d = Game.time().toTicks(delay);

    TimedAction a = new TimedAction(this.getTicks() + d, action);
    this.actions.add(a);

    return a.getId();
}
}
```
```java
class de.gurkenlabs.litiengine.environment.EntitySpawner {
protected boolean shouldSpawn() {
    return this.lastSpawnWave == 0
        || Game.time().since(this.lastSpawnWave) >= this.getSpawnInterval();
}@Override
  public void update() {
    if (!this.shouldSpawn()) {
      return;
    }

    this.spawnNewEntities();
    this.lastSpawnWave = Game.time().now();
}
}
```
```java
class de.gurkenlabs.litiengine.graphics.FreeFlightCamera {
@Override
  public void update() {
    this.handleFreeFlightCamera();
}public FreeFlightCamera(double x, double y) {
    this(new Point2D.Double(x, y));
}
}
```
```java
class de.gurkenlabs.litiengine.environment.Environment {
public void unload() {
    if (!this.loaded) {
      return;
    }

    // unregister all updatable entities from the current environment
    for (final IEntity entity : this.allEntities.values()) {
      this.unload(entity);
    }

    this.loaded = false;
    this.fireEvent(l -> l.unloaded(this));
}private static void loadUpdatableOrEmitterEntity(IEntity entity) {
    if (entity instanceof Emitter) {
      final Emitter emitter = (Emitter) entity;
      if (emitter.isActivateOnInit()) {
        emitter.activate();
      }
    } else if (entity instanceof IUpdateable) {
      Game.loop().attach((IUpdateable) entity);
    }
}public void clear() {
    Game.physics().clear();

    this.combatEntities.clear();
    this.mobileEntities.clear();
    this.gravityForces.clear();
    this.layerEntities.clear();
    this.entitiesByTag.clear();
    this.allEntities.clear();

    for (RenderType renderType : RenderType.values()) {
      this.miscEntities.get(renderType).clear();
      this.renderListeners.get(renderType).clear();
      this.renderables.get(renderType).clear();
    }

    dispose(this.allEntities.values());
    dispose(this.triggers);
    this.emitters.clear();
    this.colliders.clear();
    this.props.clear();
    this.creatures.clear();
    this.staticShadows.clear();
    this.combatEntities.clear();
    this.mobileEntities.clear();
    this.lightSources.clear();
    this.spawnPoints.clear();
    this.soundSources.clear();
    this.mapAreas.clear();
    this.triggers.clear();

    this.ambientLight = null;
    this.staticShadowLayer = null;

    for (Map<Integer, IEntity> type : this.miscEntities.values()) {
      type.clear();
    }

    this.initialized = false;

    this.fireEvent(l -> l.cleared(this));
}private void load(final IEntity entity) {
    // an entity can only exist on one environment at a time, so remove it from the current one
    if (entity.getEnvironment() != null) {
      entity.getEnvironment().remove(entity);
    }

    // 1. add to physics engine
    loadPhysicsEntity(entity);

    // 2. register for update or activate
    loadUpdatableOrEmitterEntity(entity);

    // 3. if a gravity is defined, add a gravity force to the entity
    if (entity instanceof IMobileEntity && this.getGravity() != 0) {
      this.addGravityForce((IMobileEntity) entity);
    }

    // 4. attach all controllers
    entity.attachControllers();

    if (this.loaded && (entity instanceof LightSource || entity instanceof StaticShadow)) {
      this.updateLighting(entity);
    }

    entity.loaded(this);
}private void unload(final IEntity entity) {
    // 1. remove from physics engine
    if (entity instanceof ICollisionEntity) {
      Game.physics().remove((ICollisionEntity) entity);
    }

    // 2. unregister from update
    if (entity instanceof IUpdateable) {
      Game.loop().detach((IUpdateable) entity);
    }

    if (entity instanceof IMobileEntity) {
      this.removeGravity((IMobileEntity) entity);
    }

    // 3. detach all controllers
    entity.detachControllers();

    if (entity instanceof Emitter) {
      Emitter em = (Emitter) entity;
      em.deactivate();
    }

    if (this.loaded && (entity instanceof LightSource || entity instanceof StaticShadow)) {
      this.updateLighting(entity);
    }

    entity.removed(this);
}public void remove(final IEntity entity) {
    if (entity == null) {
      return;
    }

    this.allEntities.remove(entity.getMapId());
    Iterator<List<IEntity>> iter = this.layerEntities.values().iterator();
    while (iter.hasNext()) {
      List<IEntity> layer = iter.next();
      if (layer.remove(entity) && layer.isEmpty()) {
        iter.remove();
      }
    }
    if (this.miscEntities.get(entity.getRenderType()) != null) {
      this.miscEntities.get(entity.getRenderType()).values().remove(entity);
    }

    for (String tag : entity.getTags()) {
      if (this.getEntitiesByTag().containsKey(tag)) {
        this.getEntitiesByTag().get(tag).remove(entity);

        if (this.getEntitiesByTag().get(tag).isEmpty()) {
          this.getEntitiesByTag().remove(tag);
        }
      }
    }

    if (entity instanceof Emitter) {
      Emitter emitter = (Emitter) entity;
      this.removeEmitter(emitter);
    }

    if (entity instanceof MapArea) {
      this.mapAreas.remove(entity);
    }

    if (entity instanceof Prop) {
      this.props.remove(entity);
    }

    if (entity instanceof Creature) {
      this.creatures.remove(entity);
    }

    if (entity instanceof CollisionBox) {
      this.colliders.remove(entity);
      this.staticShadows.removeIf(x -> x.getOrigin() != null && x.getOrigin().equals(entity));
    }

    if (entity instanceof LightSource) {
      this.lightSources.remove(entity);
      this.updateLighting(entity);
    }

    if (entity instanceof Trigger) {
      this.triggers.remove(entity);
    }

    if (entity instanceof Spawnpoint) {
      this.spawnPoints.remove(entity);
    }
    if (entity instanceof SoundSource) {
      this.soundSources.remove(entity);
    }

    if (entity instanceof StaticShadow) {
      this.staticShadows.remove(entity);
      this.updateLighting(entity);
    }

    if (entity instanceof IMobileEntity) {
      this.mobileEntities.values().remove(entity);
    }

    if (entity instanceof ICombatEntity) {
      this.combatEntities.values().remove(entity);
    }

    this.unload(entity);

    this.fireEntityEvent(l -> l.entityRemoved(entity));
}
}
```
```java
class de.gurkenlabs.litiengine.physics.MovementController {
@Override
  public void update() {
    this.handleForces();
    this.handleMovement();
}
}
```
```java
class de.gurkenlabs.litiengine.Game {
static synchronized void terminate() {
    if (!initialized) {
      return;
    }

    hasStarted = false;
    initialized = false;

    config().save();
    gameLoop.terminate();
    tweenEngine.terminate();
    soundEngine.terminate();

    world().clear();

    for (final GameListener listener : gameListeners) {
      try {
        listener.terminated();
      } catch (Exception e) {
        log().log(Level.WARNING, "game listener threw an exception during shutdown", e);
      }
    }

    gameLoop = null;
    screenManager = null;
    gameWindow = null;
}public static synchronized void start() {
    if (!initialized) {
      throw new IllegalStateException(
          "The game cannot be started without being first initialized. Call Game.init(...) before Game.start().");
    }

    gameLoop.start();
    tweenEngine.start();
    soundEngine.start();

    for (final GameListener listener : gameListeners) {
      listener.started();
    }

    hasStarted = true;
}public static synchronized void init(String... args) {
    if (initialized) {
      log().log(Level.INFO, "The game has already been initialized.");
      return;
    }

    log.init();
    handleCommandLineArguments(args);

    config().load();
    Locale.setDefault(new Locale(config().client().getCountry(), config().client().getLanguage()));

    gameLoop = new GameLoop("Main Update Loop", config().client().getMaxFps());
    loop().attach(physics());
    loop().attach(world());

    // setup default exception handling for render and update loop
    setUncaughtExceptionHandler(
        new DefaultUncaughtExceptionHandler(config().client().exitOnError()));

    screenManager = new ScreenManager();
    gameWindow = new GameWindow();

    // initialize  the game window
    window().init();
    world.setCamera(new Camera());

    for (GameListener listener : gameListeners) {
      listener.initialized(args);
    }

    if (!isInNoGUIMode()) {
      window().getRenderComponent().onRendered(g -> metrics().render(g));

      graphics()
          .addEntityRenderedListener(
              e -> DebugRenderer.renderEntityDebugInfo(e.getGraphics(), e.getEntity()));

      window().getRenderComponent().onFpsChanged(fps -> metrics().setFramesPerSecond(fps));
      window()
          .setIcons(
              Arrays.asList(
                  Resources.images().get("liti-logo-x16.png"),
                  Resources.images().get("liti-logo-x20.png"),
                  Resources.images().get("liti-logo-x32.png"),
                  Resources.images().get("liti-logo-x48.png")));

      Input.keyboard()
          .onKeyTyped(
              KeyEvent.VK_PRINTSCREEN,
              key -> {
                // don't take a screenshot if a modifier is active
                if (key.getModifiers() != 0) {
                  return;
                }

                window().getRenderComponent().takeScreenshot();
              });
    }

    Runtime.getRuntime().addShutdownHook(new Thread(Game::terminate, "Shutdown"));

    initialized = true;
}
}
```


Response Format:
Provide the answer in **XML format** as follows:

#### If the method **cannot** return `null` at the specific call site:
```xml
<response>
  <reason><![CDATA[EXPLAIN WHY THE INVOCATION Game.loop() RESULT CANNOT BE NULL.]]></reason>
  <value>NO</value>
</response>

#### If the method can return null at the specific call site:
<response>
  <reason><![CDATA[EXPLAIN WHY THE INVOCATION Game.loop() RESULT CAN BE NULL.]]></reason>
  <value>YES</value>
</response>

#### If you are unsure or If there are any methods that directly or indirectly affect the return value and are not fully disclosed, request their declarations first, in the following format:
<response>
  <reason><![CDATA[EXPLAIN WHY THIS METHOD DECLARATION IS NECESSARY AND WHY YOU CANNOT MAKE A CONFIDENT DECISION WITHOUT IT]]></reason>
  <success>false</success>
  <methods>
    <method>methodName</method>
  </methods>
</response>

Additional Notes:
Be precise in your reasoning.
If a method’s return value depends on another method not provided, request its declaration before making a conclusion.
If the method can return null in this case but not in others, explain why it happens specifically for this call.

---ChatGPT.sendRequestToOpenAI---
Retrieving response from cache
---Response.<init>---
Creating Response:
```xml
<response>
  <reason><![CDATA[The method `Game.loop()` returns the static field `gameLoop`, which is initialized in the `Game.init(String... args)` method. In this method, a new `GameLoop` object is instantiated and assigned to `gameLoop`. Since `init()` must be called before `start()`, which is implied by the requirement of initializing the game, the `gameLoop` is guaranteed to be non-null during the lifetime of the game execution where `Game.loop()` is called. The absence of any code that could set `gameLoop` to null after its initialization ensures that `Game.loop()` cannot return null.]]></reason>
  <value>NO</value>
</response>
```
---Response.<init>---
Response created:
Disagreement: The method `Game.loop()` returns the static field `gameLoop`, which is initialized in the `Game.init(String... args)` method. In this method, a new `GameLoop` object is instantiated and assigned to `gameLoop`. Since `init()` must be called before `start()`, which is implied by the requirement of initializing the game, the `gameLoop` is guaranteed to be non-null during the lifetime of the game execution where `Game.loop()` is called. The absence of any code that could set `gameLoop` to null after its initialization ensures that `Game.loop()` cannot return null.
---AdvancedNullAwayCodeFix.resolveMethodDereferenceError---
Method is not returning nullable on call site. Injecting suppression annotation.
---AdvancedNullAwayCodeFix.constructCastToNonnullChange---
Constructing cast to nonnull change for reason: The method `Game.loop()` returns the static field `gameLoop`, which is initialized in the `Game.init(String... args)` method. In this method, a new `GameLoop` object is instantiated and assigned to `gameLoop`. Since `init()` must be called before `start()`, which is implied by the requirement of initializing the game, the `gameLoop` is guaranteed to be non-null during the lifetime of the game execution where `Game.loop()` is called. The absence of any code that could set `gameLoop` to null after its initialization ensures that `Game.loop()` cannot return null.
---ChatGPT.ask---
Asking ChatGPT:
For the reason you mentioned earlier:

"The method `Game.loop()` returns the static field `gameLoop`, which is initialized in the `Game.init(String... args)` method. In this method, a new `GameLoop` object is instantiated and assigned to `gameLoop`. Since `init()` must be called before `start()`, which is implied by the requirement of initializing the game, the `gameLoop` is guaranteed to be non-null during the lifetime of the game execution where `Game.loop()` is called. The absence of any code that could set `gameLoop` to null after its initialization ensures that `Game.loop()` cannot return null."

in the method below, the expression Game.loop() is not nullable at the point it is used.

```java
@Override
  public void update() {

    for (final Iterator<EffectApplication> iterator = this.getActiveAppliances().iterator();
        iterator.hasNext(); ) {
      final EffectApplication appliance = iterator.next();
      // if the effect duration is reached
      if (this.hasEnded(appliance)) {

        iterator.remove();
        this.cease(appliance);
      }
    }

    // 4. unregister if all appliances are finished
    if (this.getActiveAppliances().isEmpty()) {
      Game.loop().detach(this);
    }
}
```
Please Summarize the reason in max 5 words and rewrite the method so that at the line "      Game.loop().detach(this);", at the occurrence of: "Game.loop()" is replaced with `NullabilityUtil.castToNonnull(Game.loop(), summary of reason)`
Replace "REASON" with the exact reason summary I provide to you (maximum 5 words), not with a generic explanation like "checked to be nonnull".
see the example below, for expression `foo.getBar()`, to wrap it with `NullabilityUtil.castToNonnull(foo.getBar(), "reason")`.

```java
public t(){
    String l = foo.getBar();
}
```

will be:
```java
public t(){
    String l = NullabilityUtil.castToNonnull(foo.getBar(), "checked to be nonnull");
}
```

### Instructions:

Do not import any additional classes.

Do not add Java comments.

Only modify relevant lines as required.

Return only the modified method wrapped in the XML format shown below.

Place the Java code inside the <code> tag using a CDATA block with ```java formatting.

Just give me the fixed code snippet in XML format in <response> tag like the example below. I will apply the fix to my codebase. Do not import any additional libraries or classes or add java comments. If you can provide the fixed code snippet, please provide it in the following format and place the code snippet in the <code> tag within ```java block.
<response>
  <success>true</success>
  <code><![CDATA[
  ```java
  Your fixed code snippet here
  ```
    ]]>
  </code>
</response>

---ChatGPT.sendRequestToOpenAI---
Retrieving response from cache
---Response.<init>---
Creating Response:
```xml
<response>
  <success>true</success>
  <code><![CDATA[
  ```java
@Override
  public void update() {

    for (final Iterator<EffectApplication> iterator = this.getActiveAppliances().iterator();
        iterator.hasNext(); ) {
      final EffectApplication appliance = iterator.next();
      if (this.hasEnded(appliance)) {

        iterator.remove();
        this.cease(appliance);
      }
    }

    if (this.getActiveAppliances().isEmpty()) {
      NullabilityUtil.castToNonnull(Game.loop(), "ensured non-null post-init").detach(this);
    }
}
  ```
    ]]>
  </code>
</response>
```
---Response.<init>---
Response created:
@Override
  public void update() {

    for (final Iterator<EffectApplication> iterator = this.getActiveAppliances().iterator();
        iterator.hasNext(); ) {
      final EffectApplication appliance = iterator.next();
      if (this.hasEnded(appliance)) {

        iterator.remove();
        this.cease(appliance);
      }
    }

    if (this.getActiveAppliances().isEmpty()) {
      NullabilityUtil.castToNonnull(Game.loop(), "ensured non-null post-init").detach(this);
    }
}
---ChatGPT.fixDereferenceByAddingCastToNonnull---
Fixing the error by adding castToNonnull
---AdvancedNullAwayCodeFix.fixTriggeredErrorsForLocation---
Resolving unresolvable error for triggered error: Type='DEREFERENCE_NULLABLE', message='dereferenced expression loop() is @Nullable'
/home/nima/Developer/nullness-benchmarks/litiengine/src/de/gurkenlabs/litiengine/Game.java:454
    loop().attach(physics());
---AdvancedNullAwayCodeFix.fix---
Fixing error: Type='DEREFERENCE_NULLABLE', message='dereferenced expression loop() is @Nullable'
/home/nima/Developer/nullness-benchmarks/litiengine/src/de/gurkenlabs/litiengine/Game.java:454
    loop().attach(physics());
---AdvancedNullAwayCodeFix.resolveDereferenceError---
Resolving dereference error: Type='DEREFERENCE_NULLABLE', message='dereferenced expression loop() is @Nullable'
/home/nima/Developer/nullness-benchmarks/litiengine/src/de/gurkenlabs/litiengine/Game.java:454
    loop().attach(physics());
---AdvancedNullAwayCodeFix.resolveDereferenceError---
Checking nullability possibility at error point
---ChatGPT.checkNullabilityPossibilityAtErrorPoint---
Asking if the expression can be null at error point point
---ChatGPT.ask---
Asking ChatGPT:
In the method below, is there a possibility that the expression "loop()" at line "loop().attach(physics());" is null?
public static synchronized void init(String... args) {
    if (initialized) {
      log().log(Level.INFO, "The game has already been initialized.");
      return;
    }

    log.init();
    handleCommandLineArguments(args);

    config().load();
    Locale.setDefault(new Locale(config().client().getCountry(), config().client().getLanguage()));

    gameLoop = new GameLoop("Main Update Loop", config().client().getMaxFps());
    loop().attach(physics());
    loop().attach(world());

    // setup default exception handling for render and update loop
    setUncaughtExceptionHandler(
        new DefaultUncaughtExceptionHandler(config().client().exitOnError()));

    screenManager = new ScreenManager();
    gameWindow = new GameWindow();

    // initialize  the game window
    window().init();
    world.setCamera(new Camera());

    for (GameListener listener : gameListeners) {
      listener.initialized(args);
    }

    if (!isInNoGUIMode()) {
      window().getRenderComponent().onRendered(g -> metrics().render(g));

      graphics()
          .addEntityRenderedListener(
              e -> DebugRenderer.renderEntityDebugInfo(e.getGraphics(), e.getEntity()));

      window().getRenderComponent().onFpsChanged(fps -> metrics().setFramesPerSecond(fps));
      window()
          .setIcons(
              Arrays.asList(
                  Resources.images().get("liti-logo-x16.png"),
                  Resources.images().get("liti-logo-x20.png"),
                  Resources.images().get("liti-logo-x32.png"),
                  Resources.images().get("liti-logo-x48.png")));

      Input.keyboard()
          .onKeyTyped(
              KeyEvent.VK_PRINTSCREEN,
              key -> {
                // don't take a screenshot if a modifier is active
                if (key.getModifiers() != 0) {
                  return;
                }

                window().getRenderComponent().takeScreenshot();
              });
    }

    Runtime.getRuntime().addShutdownHook(new Thread(Game::terminate, "Shutdown"));

    initialized = true;
}
Give a single-word answer in XML format. If it is possible for the expression to be null, respond with:
```xml
<response>
    <reason><![CDATA[YOUR REASON]]></reason>
    <value>YES</value>
</response>
```
If it is not possible for the expression to be null, respond with:
```xml
<response>
    <reason><![CDATA[YOUR REASON]]></reason>
    <value>NO</value>
</response>
```
If you are unsure or need more information, respond with where you can ask for more details or what specific information you need.

If additional information is required, list each request inside a `<request>` tag. If no additional information is needed, omit the `<requests>` section.

Respond with:
```xml
<response>
    <reason><![CDATA[YOUR REASON]]></reason>
    <value>UNKNOWN</value>
    <!-- Include <requests> only if additional information is needed -->
    <requests>
        <request><![CDATA[YOUR REQUEST 1]]></request>
        <request><![CDATA[YOUR REQUEST 2]]></request>
    </requests>
</response>
```
---ChatGPT.sendRequestToOpenAI---
Retrieving response from cache
---Response.<init>---
Creating Response:
```xml
<response>
    <reason><![CDATA[The possibility of the expression "loop()" being null depends on its implementation, which is not provided in the code snippet. Without the implementation details of the "loop()" method, it's impossible to determine whether it can return null or not.]]></reason>
    <value>UNKNOWN</value>
    <requests>
        <request><![CDATA[Provide the implementation of the "loop()" method.]]></request>
        <request><![CDATA[Provide details about the initialization and assignment of the gameLoop variable.]]></request>
    </requests>
</response>
```
---Response.<init>---
Response created:
Unknown: The possibility of the expression "loop()" being null depends on its implementation, which is not provided in the code snippet. Without the implementation details of the "loop()" method, it's impossible to determine whether it can return null or not.
---AdvancedNullAwayCodeFix.resolveMethodDereferenceError---
Resolving method dereference error.
---AdvancedNullAwayCodeFix.resolveMethodDereferenceError---
Method is in annotated package. Checking if the method is returning nullable.
---AdvancedNullAwayCodeFix.investigateMethodReturnNullability---
Checking if the method is returning nullable.
---ChatGPT.checkIfMethodIsReturningNullable---
Asking if the method is returning nullable: loop()
---ChatGPT.ask---
Asking ChatGPT:
In the method below, is there a possibility that the method returns null based only on its body? Consider the following points:

- The method may have multiple return paths; consider all return statements.
- If the method calls another method, do not assume its return value unless its full declaration is provided. Request its declaration if needed.
- The method may throw an exception instead of returning null. An exception path should not be considered a null return.
- Ensure you request the declarations of any methods whose return values directly or indirectly impact this method’s return value before making a conclusion.
- Carefully analyze all conditions and prior operations that may guarantee a non-null return value.

@Nullable public static IGameLoop loop() {
    return gameLoop;
}

Here are the method definitions in addition to the method inquired:

Depth: 0
```java
class de.gurkenlabs.litiengine.Game {
@Nullable public static IGameLoop loop() {
    return gameLoop;
}
}
```


Response Format:
Provide the answer in **XML format** as follows:

#### If the method **cannot** return `null`:
```xml
<response>
  <reason><![CDATA[EXPLAIN WHY THE METHOD CANNOT RETURN NULL]]></reason>
  <value>NO</value>
</response>
```

#### If the method can return null:
```xml
<response>
  <reason><![CDATA[EXPLAIN WHY THE METHOD CAN RETURN NULL]]></reason>
  <value>YES</value>
</response>
```

#### If you are unsure or need more information, respond with where you can ask for more details or what specific information you need.

#### If you are unsure or If there are any methods that directly or indirectly affect the return value and are not fully disclosed, request their declarations first, in the following format:
<response>
  <reason><![CDATA[YOUR REASON]]></reason>
  <value>UNKNOWN</value>
  <methods>
    <method>methodName</method>
  </methods>
</response>

If additional information is required other than method declaration, list each request inside a `<request>` tag. If no additional information is needed, omit the `<requests>` section.

Respond with:
```xml
<response>
    <reason><![CDATA[YOUR REASON]]></reason>
    <value>UNKNOWN</value>
    <!-- Include <requests> only if additional information is needed -->
    <requests>
        <request><![CDATA[YOUR REQUEST 1]]></request>
        <request><![CDATA[YOUR REQUEST 2]]></request>
    </requests>
</response>
```

Additional Notes:
Be precise in your reasoning.
If a method’s return value depends on another method not provided, request its declaration before making a conclusion.
If the method can return null in some cases but not others, explain under what conditions it can happen.

---ChatGPT.sendRequestToOpenAI---
Retrieving response from cache
---Response.<init>---
Creating Response:
```xml
<response>
  <reason><![CDATA[The method `loop` returns the variable `gameLoop`. Without the initialization or assignment details of `gameLoop`, it's unclear whether it can be null. The possibility of `gameLoop` being uninitialized or set to null elsewhere in the program means `loop` could potentially return null. Further information on `gameLoop` is required.]]></reason>
  <value>UNKNOWN</value>
  <requests>
    <request><![CDATA[Please provide the declaration and initialization of the variable `gameLoop` in the class `de.gurkenlabs.litiengine.Game`.]]></request>
  </requests>
</response>
```
---Response.<init>---
Response created:
Unknown: The method `loop` returns the variable `gameLoop`. Without the initialization or assignment details of `gameLoop`, it's unclear whether it can be null. The possibility of `gameLoop` being uninitialized or set to null elsewhere in the program means `loop` could potentially return null. Further information on `gameLoop` is required.
---AdvancedNullAwayCodeFix.investigateMethodReturnNullability---
Could not determine the nullability and model did not ask for any method.
---ChatGPT.checkIfMethodIsReturningNullableOnCallSite---
Asking if the method is returning nullable on the call site: loop()
---ChatGPT.ask---
Asking ChatGPT:
In the method below, is there a possibility that the method returns null at the given call site?

```java
@Nullable public static IGameLoop loop() {
    return gameLoop;
}
```

## Guidelines:
- The method may have multiple return paths; consider all return statements.
- If the method calls another method, do not assume its return value unless its full declaration is provided. Request its declaration if needed.
- The method may throw an exception instead of returning null. An exception path should not be considered a null return.
- Ensure you request the declarations of any methods whose return values directly or indirectly impact this method’s return value before making a conclusion.
- If the method returns a value that is determined by a parameter, evaluate based on the actual argument at the given call site.
- Analyze based only on the specific invocation provided. Do not generalize to all possible inputs.- If the return value is guaranteed to be non-null at the call site, the answer should be a definitive NO.
- Do not generalize based on all possible inputs—your answer must be based only on the given invocation.
- Focus only on the given call site, not all possible invocations.

### call site:
loop()

Here are the method definitions and the call chain for this method, showing the sequence of calls from the method to its callers at each depth level:

Depth: 0
```java
class de.gurkenlabs.litiengine.Game {
@Nullable public static IGameLoop loop() {
    return gameLoop;
}
}
```
Depth: 1
```java
class de.gurkenlabs.litiengine.environment.GameWorld {
public void loadEnvironment(@Nullable final Environment env) {
    Lock lock = Game.loop().getLock();
    lock.lock();
    try {
      unloadEnvironment();
      this.environment = env;
      if (env != null) {
        this.addEnvironment(env);

        if (env.getGravity() == 0 && this.gravity() != 0) {
          env.setGravity(this.gravity());
        }

        env.load();
        for (final EnvironmentLoadedListener listener : this.loadedListeners) {
          listener.loaded(env);
        }

        // call map specific listeners
        String mapName = getMapName(env);
        if (mapName != null && this.environmentLoadedListeners.containsKey(mapName)) {

          // for the default camera we center the camera on the environment
          if (this.camera().getClass().equals(Camera.class)) {
            camera().setFocus(env.getCenter());
          }

          for (EnvironmentLoadedListener listener : this.environmentLoadedListeners.get(mapName)) {
            listener.loaded(env);
          }
        }
      }
    } finally {
      lock.unlock();
    }
}public void setCamera(@Nullable final ICamera cam) {
    if (this.camera() != null) {
      Game.loop().detach(camera);
    }

    camera = cam;

    if (cam != null && !Game.isInNoGUIMode()) {
      Game.loop().attach(cam);
      cam.updateFocus();
    }
}
}
```
```java
class de.gurkenlabs.litiengine.entities.behavior.EntityNavigator {
public EntityNavigator(final IMobileEntity entity, final PathFinder pathFinder) {
    this.cancelNavigationConditions = new CopyOnWriteArrayList<>();
    this.listeners = new CopyOnWriteArrayList<>();
    this.entity = entity;
    this.pathFinder = pathFinder;
    this.setAcceptableError(DEFAULT_ACCEPTABLE_ERROR);
    Game.loop().attach(this);
}
}
```
```java
class de.gurkenlabs.litiengine.GameWindow {
private static void initializeWindowEventListeners(Window window) {

    window.addWindowStateListener(
        e -> {
          if (e.getNewState() == Frame.ICONIFIED) {
            Game.loop().setTickRate(ICONIFIED_MAX_FPS);
          } else {
            Game.loop().setTickRate(Game.config().client().getMaxFps());
          }
        });

    window.addWindowFocusListener(
        new WindowFocusListener() {
          @Override
          public void windowLostFocus(WindowEvent e) {
            if (Game.config().graphics().reduceFramesWhenNotFocused()) {
              Game.loop().setTickRate(NONE_FOCUS_MAX_FPS);
            }
          }

          @Override
          public void windowGainedFocus(WindowEvent e) {
            Game.loop().setTickRate(Game.config().client().getMaxFps());
          }
        });

    window.addWindowListener(
        new WindowAdapter() {
          @Override
          public void windowClosing(final WindowEvent event) {
            Game.exit();
          }
        });
}
}
```
```java
class de.gurkenlabs.litiengine.gui.screens.ScreenManager {
public void display(@Nullable final Screen screen) {
    if (Game.hasStarted() && Game.time().since(this.lastScreenChange) < this.getChangeCooldown()) {
      log.log(
          Level.INFO,
          "Skipping displaying of screen {0} because screen changing is currently on cooldown.",
          screen != null ? screen.getName() : "");
      return;
    }

    final Screen previous = this.current();
    if (previous != null) {
      previous.suspend();
    }

    if (screen != null && !this.screens.contains(screen)) {
      this.screens.add(screen);
    }

    this.currentScreen = screen;
    if (!Game.isInNoGUIMode() && this.current() != null) {
      this.current().prepare();
    }

    this.lastScreenChange = Game.loop().getTicks();

    final ScreenChangedEvent event = new ScreenChangedEvent(this.current(), previous);
    for (final ScreenChangedListener listener : this.screenChangedListeners) {
      listener.changed(event);
    }
}
}
```
```java
class de.gurkenlabs.litiengine.abilities.effects.Effect {
@Override
  public void update() {

    for (final Iterator<EffectApplication> iterator = this.getActiveAppliances().iterator();
        iterator.hasNext(); ) {
      final EffectApplication appliance = iterator.next();
      // if the effect duration is reached
      if (this.hasEnded(appliance)) {

        iterator.remove();
        this.cease(appliance);
      }
    }

    // 4. unregister if all appliances are finished
    if (this.getActiveAppliances().isEmpty()) {
      Game.loop().detach(this);
    }
}public void apply(final Shape impactArea) {
    final List<ICombatEntity> affected = this.lookForAffectedEntities(impactArea);
    for (final ICombatEntity affectedEntity : affected) {
      this.apply(affectedEntity);
    }

    this.appliances.add(new EffectApplication(affected, impactArea));

    // if it is the first appliance -> register for update
    if (this.appliances.size() == 1) {
      Game.loop().attach(this);
    }
}
}
```
```java
class de.gurkenlabs.litiengine.GameTime {
public long toTicks(final int milliseconds) {
    return this.toTicks(milliseconds, Game.loop().getTickRate());
}public long since(final long tick) {
    return toMilliseconds(Game.loop().getTicks() - tick);
}public long now() {
    return Game.loop().getTicks();
}public long sinceGameStart() {
    return this.toMilliseconds(Game.loop().getTicks());
}@Override
  public void loaded(Environment environment) {
    environmentLoaded = Game.loop().getTicks();
}public long toMilliseconds(final long ticks) {
    return this.toMilliseconds(ticks, Game.loop().getTickRate());
}
}
```
```java
class de.gurkenlabs.litiengine.GameMetrics {
@Override
  public void render(final Graphics2D g) {
    this.updateMetrics();

    if (!Game.config().client().showGameMetrics()) {
      return;
    }

    this.currentOffsetY = 0;

    g.setColor(this.renderColor);

    // render client metrics
    this.drawTitle(g, "[client]");
    this.drawMetric(g, "fps       : " + this.getFramesPerSecond());
    this.drawMetric(g, "max fps   : " + this.maxFramesPerSecond);
    this.drawMetric(g, "updatables: " + Game.loop().getUpdatableCount());

    // render jvm metrics if debug is enabled
    if (Game.config().debug().isDebugEnabled()) {
      this.drawTitle(g, "[jvm]");
      this.drawMetric(g, "java      : " + this.javaVersion);
      this.drawMetric(g, "memory    : " + String.format("%-5.5s", this.usedMemory) + " MB");
      this.drawMetric(g, "threads   : " + Thread.activeCount());
    }

    // render rendering metrics
    if (!this.renderMetrics.isEmpty()) {
      this.drawTitle(g, "[update]");

      for (RenderMetrics metric : this.renderMetrics) {
        this.drawMetric(g, metric.toString());
      }

      this.renderMetrics.clear();
    }
}
}
```
```java
class de.gurkenlabs.litiengine.graphics.emitters.Emitter {
public void deactivate() {
    if (!this.activated) {
      return;
    }

    this.activated = false;
    this.getParticles().clear();
    this.aliveTime = 0;
    this.activationTick = 0;
    this.lastSpawn = 0;
    Game.loop().detach(this);
}public void activate() {
    if (this.activated) {
      return;
    }

    this.activated = true;
    this.activationTick = Game.time().now();
    Game.loop().attach(this);
}@Override
  public void update() {
    if (this.isPaused()) {
      return;
    }

    // clear particles if the effect time to life is reached
    if (this.isFinished()) {
      for (EmitterFinishedListener listener : this.finishedListeners) {
        listener.finished(this);
      }

      this.delete();
      return;
    }

    final float updateRatio = (float) this.data().getUpdateRate() / Game.loop().getTickRate();
    for (final Particle p : this.getParticles().stream().collect(Collectors.toList())) {
      if (this.particleCanBeRemoved(p)) {
        // remove dead particles
        this.particles.remove(p);
        continue;
      }

      p.update(this.getOrigin(), updateRatio);
    }

    this.aliveTime = Game.time().since(this.activationTick);
    if ((this.data().getSpawnRate() == 0
        || Game.time().since(this.lastSpawn) >= this.data().getSpawnRate())) {
      this.lastSpawn = Game.time().now();
      this.spawnParticle();
    }
}
}
```
```java
class de.gurkenlabs.litiengine.entities.behavior.IBehaviorController {
public default void attach() {
    Game.loop().attach(this);
}public default void detach() {
    Game.loop().detach(this);
}
}
```
```java
class de.gurkenlabs.litiengine.abilities.AbilityExecution {
AbilityExecution(final Ability ability) {
    this.appliedEffects = new CopyOnWriteArrayList<>();
    this.ability = ability;
    this.executionTicks = Game.time().now();
    this.impactArea = ability.calculateImpactArea();
    this.castLocation = ability.getExecutor().getCenter();
    Game.loop().attach(this);
}@Override
  public void update() {
    // if there a no effects to apply -> unregister this instance and we're done
    if (this.getAbility().getEffects().isEmpty()
        || this.getAbility().getEffects().size() == this.getAppliedEffects().size()) {
      Game.loop().detach(this);
      return;
    }

    // handle all effects from the ability that were not applied yet
    for (final Effect effect : this.getAbility().getEffects()) {
      // if the ability was not executed yet or the delay of the effect is not
      // yet reached
      if (this.getAppliedEffects().contains(effect)
          || Game.time().since(this.getExecutionTicks()) < effect.getDelay()) {
        continue;
      }

      effect.apply(this.getExecutionImpactArea());
      this.getAppliedEffects().add(effect);
    }
}
}
```
```java
class de.gurkenlabs.litiengine.GameWindow$3 {
@Override
          public void windowGainedFocus(WindowEvent e) {
            Game.loop().setTickRate(Game.config().client().getMaxFps());
}@Override
          public void windowLostFocus(WindowEvent e) {
            if (Game.config().graphics().reduceFramesWhenNotFocused()) {
              Game.loop().setTickRate(NONE_FOCUS_MAX_FPS);
            }
}
}
```
```java
class de.gurkenlabs.litiengine.environment.EntitySpawner {
protected void spawnNewEntities() {
    if (this.getSpawnMode() != SpawnMode.CUSTOMSPAWNPOINTS && this.getSpawnPoints().isEmpty()) {
      return;
    }

    switch (this.getSpawnMode()) {
      case ALLSPAWNPOINTS:
        for (int i = 0; i < this.getSpawnPoints().size(); i++) {
          final int index = i;
          Game.loop()
              .perform(
                  this.getSpawnDelay() + this.getSpawnDelay() * i,
                  () -> this.spawn(this.getSpawnPoints().get(index), this.getSpawnAmount()));
        }
        break;
      case ONERANDOMSPAWNPOINT:
        this.spawn(Game.random().choose(this.getSpawnPoints()), this.getSpawnAmount());
        break;
      case RANDOMSPAWNPOINTS:
        for (int i = 0; i < this.getSpawnAmount(); i++) {
          Game.loop()
              .perform(
                  this.getSpawnDelay() + this.getSpawnDelay() * i,
                  () -> this.spawn(Game.random().choose(this.getSpawnPoints()), 1));
        }
        break;
      case CUSTOMSPAWNPOINTS:
        List<Spawnpoint> spawnPoints =
            this.customSpawnpoints != null
                ? this.customSpawnpoints.apply(this)
                : this.getCustomSpawnpoints();

        int index = 0;
        for (Spawnpoint spawn : spawnPoints) {
          Game.loop()
              .perform(
                  this.getSpawnDelay() + this.getSpawnDelay() * index, () -> this.spawn(spawn, 1));
          index++;
        }
        break;
      default:
        break;
    }
}
}
```
```java
class de.gurkenlabs.litiengine.tweening.TweenEngine {
@Override
  public void start() {
    Game.loop().attach(this);
}@Override
  public void terminate() {
    Game.loop().detach(this);
}
}
```
```java
class de.gurkenlabs.litiengine.gui.SpeechBubble {
public void hide() {
    Game.world().environment().removeRenderable(this);
    Game.loop().detach(this);
    if (activeSpeechBubbles.get(this.getEntity()) != null
        && activeSpeechBubbles.remove(this.getEntity()).equals(this)) {
      activeSpeechBubbles.remove(this.getEntity());
    }

    for (SpeechBubbleListener listener : this.listeners) {
      listener.hidden();
    }
}private SpeechBubble(
      final IEntity entity,
      final String text,
      @Nullable SpeechBubbleAppearance appearance,
      @Nullable Font font) {
    if (appearance == null) {
      this.appearance = DEFAULT_APPEARANCE;
    } else {
      this.appearance = appearance;
    }

    final SpeechBubble active = activeSpeechBubbles.get(entity);
    if (active != null) {
      active.hide();
    }
    this.setFont(font);

    this.textBoxWidth = (float) (entity.getWidth() * 4);
    this.entity = entity;

    this.currentText = text;
    this.currentTextDisplayTime = DISPLAYTIME_MIN + text.length() * DISPLAYTIME_PER_LETTER;

    this.lastTextDisplay = Game.time().now();
    this.createBubbleImage();
    entity.getEnvironment().add(this, RenderType.UI);
    Game.loop().attach(this);
    activeSpeechBubbles.put(entity, this);
}
}
```
```java
class de.gurkenlabs.litiengine.entities.Prop {
private void updateAnimationController() {
    IEntityAnimationController<?> controller = this.createAnimationController();
    this.getControllers().addController(controller);
    if (Game.world().environment() != null && Game.world().environment().isLoaded()) {
      Game.loop().attach(controller);
    }
}
}
```
```java
class de.gurkenlabs.litiengine.graphics.FreeFlightCamera {
public FreeFlightCamera(final Point2D focus) {
    this.setFocus(focus);
    this.velocity = DEFAULT_SCROLL_PIXELS_PER_SECOND;
    this.scrollPadding = DEFAULT_SCROLL_PADDING;
    this.setClampToMap(true);

    Game.loop().attach(this);
}private void handleFreeFlightCamera() {
    if (Game.world().environment() == null || Game.world().environment().getMap() == null) {
      return;
    }

    final Point2D mouseLocation = Input.mouse().getLocation();

    final double scrollSpeed =
        this.getVelocity()
            / (double) Game.loop().getTickRate()
            * Game.config().input().getMouseSensitivity();

    double x = this.getFocus().getX();
    double y = this.getFocus().getY();

    double deltaX = 0;
    if (mouseLocation.getX() < this.getScrollPadding()) {
      deltaX -= scrollSpeed;
    } else if (Game.window().getResolution().getWidth() - mouseLocation.getX()
        < this.getScrollPadding()) {
      deltaX += scrollSpeed;
    }

    double deltaY = 0;
    if (mouseLocation.getY() < this.getScrollPadding()) {
      deltaY -= scrollSpeed;
    } else if (Game.window().getResolution().getHeight() - mouseLocation.getY()
        < this.getScrollPadding()) {
      deltaY += scrollSpeed;
    }

    x += deltaX;
    y += deltaY;

    this.setFocus(new Point2D.Double(x, y));
}
}
```
```java
class de.gurkenlabs.litiengine.environment.Environment {
private static void dispose(final Collection<? extends IEntity> entities) {
    for (final IEntity entity : entities) {
      if (entity instanceof IUpdateable) {
        Game.loop().detach((IUpdateable) entity);
      }

      entity.detachControllers();
    }
}private static void loadUpdatableOrEmitterEntity(IEntity entity) {
    if (entity instanceof Emitter) {
      final Emitter emitter = (Emitter) entity;
      if (emitter.isActivateOnInit()) {
        emitter.activate();
      }
    } else if (entity instanceof IUpdateable) {
      Game.loop().attach((IUpdateable) entity);
    }
}private void unload(final IEntity entity) {
    // 1. remove from physics engine
    if (entity instanceof ICollisionEntity) {
      Game.physics().remove((ICollisionEntity) entity);
    }

    // 2. unregister from update
    if (entity instanceof IUpdateable) {
      Game.loop().detach((IUpdateable) entity);
    }

    if (entity instanceof IMobileEntity) {
      this.removeGravity((IMobileEntity) entity);
    }

    // 3. detach all controllers
    entity.detachControllers();

    if (entity instanceof Emitter) {
      Emitter em = (Emitter) entity;
      em.deactivate();
    }

    if (this.loaded && (entity instanceof LightSource || entity instanceof StaticShadow)) {
      this.updateLighting(entity);
    }

    entity.removed(this);
}
}
```
```java
class de.gurkenlabs.litiengine.graphics.animation.Animation {
@Override
  public void update() {
    // do nothing if the animation is not playing or the current keyframe is not finished
    if (!this.isPlaying()
        || Game.time().since(this.lastFrameUpdate) < this.getCurrentKeyFrame().getDuration()) {
      return;
    }

    // if we are not looping and the last keyframe is finished, we terminate the animation
    if (!this.isLooping() && this.isLastKeyFrame()) {
      this.terminate();
      return;
    }

    // make sure, we stay inside the keyframe list
    final int newFrameIndex =
        (this.getKeyframes().indexOf(this.currentFrame) + 1) % this.getKeyframes().size();
    final KeyFrame previousFrame = this.currentFrame;
    this.currentFrame = this.getKeyframes().get(newFrameIndex);

    for (KeyFrameListener listener : this.listeners) {
      listener.currentFrameChanged(previousFrame, this.currentFrame);
    }

    this.lastFrameUpdate = Game.loop().getTicks();
}public void restart() {
    this.currentFrame = this.firstFrame;
    this.lastFrameUpdate = Game.loop().getTicks();
}
}
```
```java
class de.gurkenlabs.litiengine.physics.MovementController {
@Override
  public void attach() {
    Game.loop().attach(this);
}private void handleForces() {
    // clean up forces
    this.activeForces.forEach(
        x -> {
          if (x.hasEnded()) {
            this.activeForces.remove(x);
          }
        });

    if (this.activeForces.isEmpty()) {
      return;
    }

    // disable turn-on-move for force handling
    boolean turn = this.getEntity().turnOnMove();
    this.getEntity().setTurnOnMove(false);
    try {
      double deltaX = 0;
      double deltaY = 0;
      for (final Force force : this.activeForces) {
        if (force.cancelOnReached() && force.hasReached(this.getEntity())) {
          force.end();
          continue;
        }

        final Point2D collisionBoxCenter = this.getEntity().getCollisionBoxCenter();
        final double angle =
            GeometricUtilities.calcRotationAngleInDegrees(collisionBoxCenter, force.getLocation());
        final double strength =
            Game.loop().getDeltaTime() * 0.001f * force.getStrength() * Game.loop().getTimeScale();
        deltaX += GeometricUtilities.getDeltaX(angle, strength);
        deltaY += GeometricUtilities.getDeltaY(angle, strength);
      }

      final Point2D target =
          new Point2D.Double(this.getEntity().getX() + deltaX, this.getEntity().getY() + deltaY);
      final boolean success = Game.physics().move(this.getEntity(), target);
      if (!success) {
        for (final Force force : this.activeForces) {
          if (force.cancelOnCollision()) {
            force.end();
          }
        }
      }
    } finally {
      this.getEntity().setTurnOnMove(turn);
    }
}@Override
  public void detach() {
    Game.loop().detach(this);
}public void handleMovement() {
    if (!this.isMovementAllowed()) {
      this.velocity = 0;
      return;
    }

    // max distance an entity can travel within one tick
    final double maxPixelsPerTick = this.getEntity().getTickVelocity();
    final double deltaTime = Game.loop().getDeltaTime() * Game.loop().getTimeScale();

    final double acceleration =
        this.getEntity().getAcceleration() == 0
            ? maxPixelsPerTick
            : deltaTime / this.getEntity().getAcceleration() * maxPixelsPerTick;
    final double deceleration =
        this.getEntity().getDeceleration() == 0
            ? this.getVelocity()
            : deltaTime / this.getEntity().getDeceleration() * maxPixelsPerTick;

    double dx = this.getDx();
    double dy = this.getDy();
    this.setDx(0);
    this.setDy(0);

    final double deltaVelocity =
        Math.min(Math.sqrt(Math.pow(dx, 2) + Math.pow(dy, 2)), acceleration);
    if (deltaVelocity != 0) {
      double newVelocity = this.getVelocity() + deltaVelocity;
      this.setVelocity(newVelocity);
    } else {
      final double newVelocity = Math.max(0, this.getVelocity() - deceleration);
      this.setVelocity(newVelocity);
      dx = GeometricUtilities.getDeltaX(this.moveAngle);
      dy = GeometricUtilities.getDeltaY(this.moveAngle);
    }

    if (this.getVelocity() == 0) {
      this.moveAngle = 0;
      return;
    }

    // actually move entity
    this.moveEntity(dx, dy);
}
}
```
```java
class de.gurkenlabs.litiengine.graphics.animation.AnimationController {
public void detach() {
    Game.loop().detach(this);
}public void attach() {
    Game.loop().attach(this);
}
}
```
```java
class de.gurkenlabs.litiengine.graphics.Camera {
@Override
  public void setZoom(final float targetZoom, final int delay) {
    if (delay == 0) {

      this.zoom = targetZoom;
      this.targetZoom = 0;
      this.zoomDelay = 0;
      this.zoomTick = 0;
      this.zoomStep = 0;

      final ZoomChangedEvent event = new ZoomChangedEvent(this, targetZoom);
      for (final ZoomChangedListener listener : this.zoomListeners) {
        listener.zoomChanged(event);
      }
    } else {
      this.zoomTick = Game.time().now();
      this.targetZoom = targetZoom;
      this.zoomDelay = delay;

      final double tickduration = 1000 / (double) Game.loop().getTickRate();
      final double tickAmount = delay / tickduration;
      final float totalDelta = this.targetZoom - this.zoom;
      this.zoomStep = tickAmount > 0 ? (float) (totalDelta / tickAmount) : totalDelta;
    }
}
}
```
```java
class de.gurkenlabs.litiengine.Game {
public static synchronized void init(String... args) {
    if (initialized) {
      log().log(Level.INFO, "The game has already been initialized.");
      return;
    }

    log.init();
    handleCommandLineArguments(args);

    config().load();
    Locale.setDefault(new Locale(config().client().getCountry(), config().client().getLanguage()));

    gameLoop = new GameLoop("Main Update Loop", config().client().getMaxFps());
    loop().attach(physics());
    loop().attach(world());

    // setup default exception handling for render and update loop
    setUncaughtExceptionHandler(
        new DefaultUncaughtExceptionHandler(config().client().exitOnError()));

    screenManager = new ScreenManager();
    gameWindow = new GameWindow();

    // initialize  the game window
    window().init();
    world.setCamera(new Camera());

    for (GameListener listener : gameListeners) {
      listener.initialized(args);
    }

    if (!isInNoGUIMode()) {
      window().getRenderComponent().onRendered(g -> metrics().render(g));

      graphics()
          .addEntityRenderedListener(
              e -> DebugRenderer.renderEntityDebugInfo(e.getGraphics(), e.getEntity()));

      window().getRenderComponent().onFpsChanged(fps -> metrics().setFramesPerSecond(fps));
      window()
          .setIcons(
              Arrays.asList(
                  Resources.images().get("liti-logo-x16.png"),
                  Resources.images().get("liti-logo-x20.png"),
                  Resources.images().get("liti-logo-x32.png"),
                  Resources.images().get("liti-logo-x48.png")));

      Input.keyboard()
          .onKeyTyped(
              KeyEvent.VK_PRINTSCREEN,
              key -> {
                // don't take a screenshot if a modifier is active
                if (key.getModifiers() != 0) {
                  return;
                }

                window().getRenderComponent().takeScreenshot();
              });
    }

    Runtime.getRuntime().addShutdownHook(new Thread(Game::terminate, "Shutdown"));

    initialized = true;
}
}
```
```java
class de.gurkenlabs.litiengine.entities.Creature {
protected void updateAnimationController() {
    IEntityAnimationController<?> controller = this.createAnimationController();
    this.getControllers().addController(controller);
    if (Game.world().environment() != null && Game.world().environment().isLoaded()) {
      Game.loop().attach(controller);
    }
}@Override
  public float getTickVelocity() {
    // pixels per ms multiplied by the passed ms
    // ensure that entities don't travel too far in case of lag
    return Math.min(Game.loop().getDeltaTime(), GameLoop.TICK_DELTATIME_LAG)
        * 0.001F
        * this.getVelocity().get()
        * Game.loop().getTimeScale();
}
}
```
Depth: 2
```java
class de.gurkenlabs.litiengine.environment.GameWorld {
public void clear() {
    this.unloadEnvironment();
    this.environments.clear();
    this.setCamera(null);
    Game.physics().clear();

    this.environmentListeners.clear();
    this.environmentLoadedListeners.clear();
    this.environmentUnloadedListeners.clear();

    this.listeners.clear();
    this.loadedListeners.clear();
    this.unloadedListeners.clear();
}@Nullable
  public Environment loadEnvironment(IMap map) {
    Environment env = this.getEnvironment(map);
    this.loadEnvironment(env);
    return env;
}@Nullable
  public Environment loadEnvironment(String mapName) {
    Environment env = this.getEnvironment(mapName);
    this.loadEnvironment(env);
    return env;
}
}
```
```java
class de.gurkenlabs.litiengine.GameWindow {
GameWindow() {
    this.hostControl = new JFrame();

    this.resolutionChangedListeners = new CopyOnWriteArrayList<>();

    this.renderCanvas = new RenderComponent(Game.config().graphics().getResolution());
    this.cursor = new MouseCursor();
    if (!Game.isInNoGUIMode()) {
      this.hostControl.setBackground(Color.BLACK);
      this.hostControl.add(this.renderCanvas);

      this.initializeEventListeners();

      this.hostControl.setTitle(Game.info().getTitle());
      this.hostControl.setDefaultCloseOperation(WindowConstants.DO_NOTHING_ON_CLOSE);
      initializeWindowEventListeners(this.hostControl);
    }
}
}
```
```java
class de.gurkenlabs.litiengine.GameTime {
public long sinceEnvironmentLoad() {
    return this.since(this.environmentLoaded);
}public long since(final long tick) {
    return toMilliseconds(Game.loop().getTicks() - tick);
}public long sinceGameStart() {
    return this.toMilliseconds(Game.loop().getTicks());
}
}
```
```java
class de.gurkenlabs.litiengine.abilities.effects.Effect {
protected void cease(final EffectApplication appliance) {
    // 1. cease the effect for all affected entities
    for (final ICombatEntity entity : appliance.getAffectedEntities()) {
      this.cease(entity);
    }

    // 2. apply follow up effects
    this.getFollowUpEffects().forEach(followUp -> followUp.apply(appliance.getImpactArea()));
}protected boolean hasEnded(final EffectApplication appliance) {
    final long effectDuration = Game.time().since(appliance.getAppliedTicks());
    return effectDuration > this.getDuration();
}
}
```
```java
class de.gurkenlabs.litiengine.abilities.effects.EffectApplication {
protected EffectApplication(final List<ICombatEntity> affectedEntities, final Shape impactArea) {
    this.applied = Game.time().now();
    this.affectedEntities = affectedEntities;
    this.impactArea = impactArea;
}
}
```
```java
class de.gurkenlabs.litiengine.entities.CombatEntity {
@Override
  public boolean wasHit(int timeSpan) {
    return Game.time().since(this.lastHit) < timeSpan;
}@Override
  public void hit(final int damage, @Nullable final Ability ability) {
    if (this.isDead()) {
      return;
    }

    if (!this.isIndestructible()) {
      this.getHitPoints().modifyBaseValue(new AttributeModifier<>(Modification.SUBTRACT, damage));
    }

    final EntityHitEvent event = new EntityHitEvent(this, ability, damage, this.isDead());

    for (final CombatEntityListener listener : this.listeners) {
      listener.hit(event);
    }

    for (final CombatEntityHitListener listener : this.hitListeners) {
      listener.hit(event);
    }

    if (this.isDead()) {
      this.fireDeathEvent();
      this.setCollision(false);
    }

    this.lastHit = Game.time().now();
}
}
```
```java
class de.gurkenlabs.litiengine.graphics.ImageEffect {
protected ImageEffect(final int ttl, final String name) {
    this.ttl = ttl;
    this.name = name;
    this.aliveTick = Game.time().now();
}@Override
  public long getAliveTime() {
    return Game.time().since(this.aliveTick);
}
}
```
```java
class de.gurkenlabs.litiengine.abilities.AbilityExecution {
AbilityExecution(final Ability ability) {
    this.appliedEffects = new CopyOnWriteArrayList<>();
    this.ability = ability;
    this.executionTicks = Game.time().now();
    this.impactArea = ability.calculateImpactArea();
    this.castLocation = ability.getExecutor().getCenter();
    Game.loop().attach(this);
}@Override
  public void update() {
    // if there a no effects to apply -> unregister this instance and we're done
    if (this.getAbility().getEffects().isEmpty()
        || this.getAbility().getEffects().size() == this.getAppliedEffects().size()) {
      Game.loop().detach(this);
      return;
    }

    // handle all effects from the ability that were not applied yet
    for (final Effect effect : this.getAbility().getEffects()) {
      // if the ability was not executed yet or the delay of the effect is not
      // yet reached
      if (this.getAppliedEffects().contains(effect)
          || Game.time().since(this.getExecutionTicks()) < effect.getDelay()) {
        continue;
      }

      effect.apply(this.getExecutionImpactArea());
      this.getAppliedEffects().add(effect);
    }
}
}
```
```java
class de.gurkenlabs.litiengine.tweening.TweenEngine {
@Override
  public void update() {
    for (final Tweenable target : this.getTweens().keySet()) {
      for (final Tween tween : this.getTweens().get(target).values()) {
        if (tween.hasStopped()) {
          continue;
        }
        final long elapsed = Game.time().since(tween.getStartTime());
        if (elapsed >= tween.getDuration()) {
          tween.stop();
          continue;
        }
        final float[] currentValues = new float[tween.getTargetValues().length];
        for (int i = 0; i < tween.getTargetValues().length; i++) {
          currentValues[i] =
              tween.getStartValues()[i]
                  + tween.getEquation().compute(elapsed / (float) tween.getDuration())
                      * (tween.getTargetValues()[i] - tween.getStartValues()[i]);
        }
        tween.getTarget().setTweenValues(tween.getType(), currentValues);
      }
    }
}
}
```
```java
class de.gurkenlabs.litiengine.gui.SpeechBubble {
public static SpeechBubble create(
      final IEntity entity, final String text, SpeechBubbleAppearance appearance, Font font) {
    return new SpeechBubble(entity, text, appearance, font);
}public static SpeechBubble create(final IEntity entity, final Font font, final String text) {
    SpeechBubbleAppearance app =
        new SpeechBubbleAppearance(
            DEFAULT_APPEARANCE.getForeColor(),
            DEFAULT_APPEARANCE.getBackgroundColor1(),
            DEFAULT_APPEARANCE.getBorderColor(),
            DEFAULT_APPEARANCE.getPadding());
    return new SpeechBubble(entity, text, app, font);
}public static SpeechBubble create(final IEntity entity, final String text) {
    return new SpeechBubble(entity, text, null, GuiProperties.getDefaultFont());
}@Override
  public void update() {
    if (this.currentText == null) {
      this.hide();
      return;
    }

    this.entityCenter = Game.world().camera().getViewportLocation(this.getEntity().getCenter());

    // old text was displayed long enough
    if (this.lastTextDisplay != 0
        && Game.time().since(this.lastTextDisplay) > this.currentTextDisplayTime) {
      this.currentText = null;
      this.lastTextDisplay = 0;
      return;
    }

    // display new text
    if (this.textIndex < this.currentText.length()
        && Game.time().since(this.lastCharPoll) > LETTER_WRITE_DELAY) {
      this.textIndex++;
      this.lastCharPoll = Game.time().now();
      if (this.typeSound != null) {
        Game.audio().playSound(this.typeSound, this.getEntity());
      }
    }

    // continue displaying currently displayed text
}private SpeechBubble(
      final IEntity entity,
      final String text,
      final Sound typeSound,
      SpeechBubbleAppearance appearance,
      Font font) {
    this(entity, text, appearance, font);
    this.typeSound = typeSound;
}private SpeechBubble(
      final IEntity entity,
      final String text,
      @Nullable SpeechBubbleAppearance appearance,
      @Nullable Font font) {
    if (appearance == null) {
      this.appearance = DEFAULT_APPEARANCE;
    } else {
      this.appearance = appearance;
    }

    final SpeechBubble active = activeSpeechBubbles.get(entity);
    if (active != null) {
      active.hide();
    }
    this.setFont(font);

    this.textBoxWidth = (float) (entity.getWidth() * 4);
    this.entity = entity;

    this.currentText = text;
    this.currentTextDisplayTime = DISPLAYTIME_MIN + text.length() * DISPLAYTIME_PER_LETTER;

    this.lastTextDisplay = Game.time().now();
    this.createBubbleImage();
    entity.getEnvironment().add(this, RenderType.UI);
    Game.loop().attach(this);
    activeSpeechBubbles.put(entity, this);
}
}
```
```java
class de.gurkenlabs.litiengine.gui.TextFieldComponent {
@Override
  public void render(final Graphics2D g) {
    super.render(g);
    g.setFont(this.getFont());
    final FontMetrics fm = g.getFontMetrics();

    if (this.isSelected() && Game.time().since(this.lastToggled) > this.flickerDelay) {
      this.cursorVisible = !this.cursorVisible;
      this.lastToggled = Game.time().now();
    }
    if (this.isSelected() && this.cursorVisible) {
      final Rectangle2D cursor =
          new Rectangle2D.Double(
              this.getX() + this.getTextX() + fm.stringWidth(this.getTextToRender(g)),
              this.getY() + this.getTextY(),
              this.getFont().getSize2D() * 3 / 5,
              this.getFont().getSize2D() * 1 / 5);
      g.setColor(this.getAppearance().getForeColor());
      g.fill(cursor);
    }
}
}
```
```java
class de.gurkenlabs.litiengine.entities.Prop {
public Prop(
      final Point2D location, @Nullable final String spritesheetName, final Material material) {
    super();
    this.rotation = Rotation.NONE;
    this.spritesheetName = spritesheetName;
    this.material = material;
    this.setLocation(location);
    this.updateAnimationController();
}public void setSpritesheetName(@Nullable final String spriteName) {
    this.spritesheetName = spriteName;
    this.updateAnimationController();
}
}
```
```java
class de.gurkenlabs.litiengine.tweening.Tween {
public Tween begin() {
    this.started = Game.time().now();
    this.stopped = false;
    return this;
}
}
```
```java
class de.gurkenlabs.litiengine.graphics.emitters.particles.Particle {
public void update(final Point2D emitterOrigin, final float updateRatio) {
    if (this.aliveTick == 0) {
      this.aliveTick = Game.time().now();
    }

    this.aliveTime = Game.time().since(this.aliveTick);
    if (this.timeToLiveReached()) {
      return;
    }

    if (this.colliding) {
      return;
    }

    if (this.getDeltaWidth() != 0) {
      this.width += this.getDeltaWidth() * updateRatio;
    }

    if (this.getDeltaHeight() != 0) {
      this.height += this.getDeltaHeight() * updateRatio;
    }

    if (this.getDeltaAngle() != 0) {
      this.angle += this.getDeltaAngle() * updateRatio;
    }

    // test for ray cast collision
    final float targetX = this.x + this.getVelocityX() * updateRatio;
    final float targetY = this.y + this.getVelocityY() * updateRatio;

    if (targetX == this.x && targetY == this.y) {
      return;
    }

    if (this.checkForCollision(emitterOrigin, targetX, targetY)) {
      return;
    }

    if (this.getVelocityX() != 0) {
      this.x = targetX;
    }

    if (this.getVelocityY() != 0) {
      this.y = targetY;
    }

    if (this.getAccelerationX() != 0) {
      this.velocityX += this.getAccelerationX() * updateRatio;
    }

    if (this.getAccelerationY() != 0) {
      this.velocityY += this.getAccelerationY() * updateRatio;
    }
}
}
```
```java
class de.gurkenlabs.litiengine.graphics.animation.Animation {
@Override
  public void start() {
    this.playing = true;
    if (this.getKeyframes().isEmpty()) {
      return;
    }

    this.restart();
}@Override
  public void update() {
    // do nothing if the animation is not playing or the current keyframe is not finished
    if (!this.isPlaying()
        || Game.time().since(this.lastFrameUpdate) < this.getCurrentKeyFrame().getDuration()) {
      return;
    }

    // if we are not looping and the last keyframe is finished, we terminate the animation
    if (!this.isLooping() && this.isLastKeyFrame()) {
      this.terminate();
      return;
    }

    // make sure, we stay inside the keyframe list
    final int newFrameIndex =
        (this.getKeyframes().indexOf(this.currentFrame) + 1) % this.getKeyframes().size();
    final KeyFrame previousFrame = this.currentFrame;
    this.currentFrame = this.getKeyframes().get(newFrameIndex);

    for (KeyFrameListener listener : this.listeners) {
      listener.currentFrameChanged(previousFrame, this.currentFrame);
    }

    this.lastFrameUpdate = Game.loop().getTicks();
}
}
```
```java
class de.gurkenlabs.litiengine.graphics.animation.AnimationController {
@Override
  public void update() {
    for (final Animation animation : this.getAll()) {
      animation.update();
    }

    if (this.getCurrent() != null && this.getCurrent().isPaused()) {
      return;
    }

    final boolean playbackFinished = this.getCurrent() != null && !this.getCurrent().isPlaying();
    if (playbackFinished) {
      for (final AnimationListener listener : this.listeners) {
        listener.finished(this.getCurrent());
      }
    }

    if (this.getCurrent() == null || playbackFinished) {
      if (this.getDefault() != null) {
        this.play(this.getDefault().getName());
      } else {
        this.currentAnimation = null;
      }
    }
}
}
```
```java
class de.gurkenlabs.litiengine.graphics.RenderComponent {
private void handleFade() {
    if (this.fadeOutStart != -1) {
      final long timePassed = Game.time().since(this.fadeOutStart);
      this.currentAlpha = MathUtilities.clamp(1 - timePassed / (float) this.fadeOutTime, 0, 1);
      if (this.currentAlpha == 0f) {
        this.fadeOutStart = -1;
        this.fadeOutTime = -1;
      }

      return;
    }

    if (this.fadeInStart != -1) {
      final long timePassed = Game.time().since(this.fadeInStart);
      this.currentAlpha = MathUtilities.clamp(timePassed / (float) this.fadeInTime, 0, 1);
      if (this.currentAlpha == 1f) {
        this.fadeInStart = -1;
        this.fadeInTime = -1;
        this.currentAlpha = Float.NaN;
      }
    }
}public void fadeOut(final int ms) {
    this.fadeInStart = -1;
    this.fadeInTime = -1;
    this.fadeOutStart = Game.time().now();
    this.fadeOutTime = ms;
}public void fadeIn(final int ms) {
    this.fadeOutStart = -1;
    this.fadeOutTime = -1;
    this.fadeInStart = Game.time().now();
    this.fadeInTime = ms;
}
}
```
```java
class de.gurkenlabs.litiengine.entities.Trigger {
private boolean activate(final IEntity activator, final int tar) {
    if (!this.isLoaded()
        || this.isOneTimeTrigger && this.isActivated
        || this.getActivationType() == TriggerActivation.COLLISION
            && activator != null
            && this.collisionActivated.contains(activator)) {
      return false;
    }

    if (this.getCooldown() > 0 && Game.time().since(this.lastActivation) < this.getCooldown()) {
      return false;
    }

    List<Integer> triggerTargets = this.getTargets(tar);

    final TriggerEvent te = new TriggerEvent(this, activator, triggerTargets);

    if (!this.checkActivationPredicates(te)) {
      return false;
    }

    this.isActivated = true;
    if (activator != null) {
      this.collisionActivated.add(activator);
    }

    // if we actually have a trigger target, we send the message to the target
    for (final int target : triggerTargets) {
      final IEntity entity = this.getEnvironment().get(target);
      if (entity == null) {
        log.log(
            Level.WARNING,
            "trigger [{0}] was activated, but the trigger target [{1}] could not be found on the environment",
            new Object[] {this, target});
        continue;
      }

      entity.sendMessage(this, this.message);
    }

    // also send the trigger event to all registered consumers
    for (final TriggerActivatedListener listener : this.activatedListeners) {
      listener.activated(te);
    }

    if (this.isOneTimeTrigger) {
      this.getEnvironment().remove(this);
    }

    this.lastActivation = Game.time().now();
    return true;
}
}
```
```java
class de.gurkenlabs.litiengine.graphics.Camera {
private boolean isShakeEffectActive() {
    return this.getShakeTick() != 0
        && Game.time().since(this.getShakeTick()) < this.getShakeDuration();
}@Override
  public void update() {
    if (Game.world().camera() != null && !Game.world().camera().equals(this)) {
      return;
    }

    if (this.targetZoom > 0) {
      if (Game.time().since(this.zoomTick) >= this.zoomDelay) {
        this.zoom = this.targetZoom;
        this.targetZoom = 0;
        this.zoomDelay = 0;
        this.zoomTick = 0;
        this.zoomStep = 0;
      } else {
        this.zoom += this.zoomStep;
      }

      final ZoomChangedEvent event = new ZoomChangedEvent(this, this.getZoom());
      for (final ZoomChangedListener listener : this.zoomListeners) {
        listener.zoomChanged(event);
      }
    }

    if (this.panTime > 0) {
      if (--this.panTime <= 0) {
        this.setFocus(this.targetFocus);
        this.targetFocus = null;
      } else {
        double diff = this.panTime / (this.panTime + 1.0);
        this.focus =
            new Point2D.Double(
                this.focus.getX() * diff + this.targetFocus.getX() * (1.0 - diff),
                this.focus.getY() * diff + this.targetFocus.getY() * (1.0 - diff));
      }
    }

    if (!this.isShakeEffectActive()) {
      this.shakeOffsetX = 0;
      this.shakeOffsetY = 0;
      return;
    }

    if (Game.time().since(this.lastShake) > this.shakeDelay) {
      this.shakeOffsetX = this.getShakeIntensity() * ThreadLocalRandom.current().nextGaussian();
      this.shakeOffsetY = this.getShakeIntensity() * ThreadLocalRandom.current().nextGaussian();
      this.lastShake = Game.time().now();
    }
}@Override
  public void setZoom(final float targetZoom, final int delay) {
    if (delay == 0) {

      this.zoom = targetZoom;
      this.targetZoom = 0;
      this.zoomDelay = 0;
      this.zoomTick = 0;
      this.zoomStep = 0;

      final ZoomChangedEvent event = new ZoomChangedEvent(this, targetZoom);
      for (final ZoomChangedListener listener : this.zoomListeners) {
        listener.zoomChanged(event);
      }
    } else {
      this.zoomTick = Game.time().now();
      this.targetZoom = targetZoom;
      this.zoomDelay = delay;

      final double tickduration = 1000 / (double) Game.loop().getTickRate();
      final double tickAmount = delay / tickduration;
      final float totalDelta = this.targetZoom - this.zoom;
      this.zoomStep = tickAmount > 0 ? (float) (totalDelta / tickAmount) : totalDelta;
    }
}@Override
  public void shake(final double intensity, final int delay, final int shakeDuration) {
    this.shakeTick = Game.time().now();
    this.shakeDelay = delay;
    this.shakeIntensity = intensity;
    this.shakeDuration = shakeDuration;
}
}
```
```java
class de.gurkenlabs.litiengine.entities.Creature {
public void setSpritesheetName(String spritesheetName) {
    if (this.spritesheetName != null && this.spritesheetName.equals(spritesheetName)) {
      return;
    }

    this.spritesheetName = spritesheetName;
    this.updateAnimationController();
}public boolean isIdle() {
    return Game.time().since(this.lastMoved) > IDLE_DELAY;
}@Override
  public void setLocation(final Point2D position) {
    if (this.isDead() || position == null) {
      return;
    }

    final Point2D oldLocation = this.getLocation();
    super.setLocation(position);

    if (Game.hasStarted() && this.isLoaded()) {
      this.lastMoved = Game.time().now();
      this.fireMovedEvent(
          new EntityMovedEvent(
              this, this.getX() - oldLocation.getX(), this.getY() - oldLocation.getY()));
    }
}
}
```
```java
class de.gurkenlabs.litiengine.gui.screens.ScreenManager {
public void display(final String screenName) {
    if (this.current() != null && this.current().getName().equalsIgnoreCase(screenName)) {
      log.log(
          Level.INFO,
          "Skipping displaying of screen {0} because it is already the current screen.",
          screenName);
      return;
    }

    if (this.screens.stream()
        .noneMatch(element -> element.getName().equalsIgnoreCase(screenName))) {
      log.log(
          Level.WARNING,
          "Could not display the screen {0} because there is no screen with the specified name.",
          screenName);
      return;
    }

    Screen screen = this.get(screenName);
    if (screen == null) {
      return;
    }

    this.display(screen);
}public void add(final Screen screen) {
    screen.setWidth(Game.window().getWidth());
    screen.setHeight(Game.window().getHeight());
    this.screens.add(screen);

    if (this.current() == null) {
      this.display(screen);
    }
}public void remove(Screen screen) {
    this.screens.remove(screen);
    if (this.current() == screen) {
      if (!this.screens.isEmpty()) {
        this.display(this.screens.get(0));
      } else {
        this.display((Screen) null);
      }
    }
}public void display(@Nullable final Screen screen) {
    if (Game.hasStarted() && Game.time().since(this.lastScreenChange) < this.getChangeCooldown()) {
      log.log(
          Level.INFO,
          "Skipping displaying of screen {0} because screen changing is currently on cooldown.",
          screen != null ? screen.getName() : "");
      return;
    }

    final Screen previous = this.current();
    if (previous != null) {
      previous.suspend();
    }

    if (screen != null && !this.screens.contains(screen)) {
      this.screens.add(screen);
    }

    this.currentScreen = screen;
    if (!Game.isInNoGUIMode() && this.current() != null) {
      this.current().prepare();
    }

    this.lastScreenChange = Game.loop().getTicks();

    final ScreenChangedEvent event = new ScreenChangedEvent(this.current(), previous);
    for (final ScreenChangedListener listener : this.screenChangedListeners) {
      listener.changed(event);
    }
}
}
```
```java
class de.gurkenlabs.litiengine.abilities.Ability {
public boolean isOnCooldown() {
    return (this.getCurrentExecution() != null
        && this.getCurrentExecution().getExecutionTicks() > 0
        && Game.time().since(this.getCurrentExecution().getExecutionTicks())
            < this.getAttributes().cooldown().get());
}public boolean isActive() {
    return this.getCurrentExecution() != null
        && Game.time().since(this.getCurrentExecution().getExecutionTicks())
            < this.getAttributes().duration().get();
}@Nullable
  public AbilityExecution cast() {
    if (!this.canCast()) {
      return null;
    }
    this.currentExecution = new AbilityExecution(this);

    for (final AbilityCastListener listener : this.abilityCastListeners) {
      listener.abilityCast(this.currentExecution);
    }

    return this.getCurrentExecution();
}public float getRemainingCooldownInSeconds() {
    if (this.getCurrentExecution() == null
        || this.getExecutor() == null
        || this.getExecutor().isDead()) {
      return 0;
    }

    // calculate cooldown in seconds
    return (float)
        (!this.canCast()
            ? (this.getAttributes().cooldown().get()
                    - Game.time().since(this.getCurrentExecution().getExecutionTicks()))
                * 0.001
            : 0);
}
}
```
```java
class de.gurkenlabs.litiengine.entities.EntityHitEvent {
EntityHitEvent(
      final ICombatEntity hitEntity,
      @Nullable final Ability ability,
      final int damage,
      final boolean kill) {
    super(hitEntity);
    this.executor = ability != null ? ability.getExecutor() : null;
    this.hitEntity = hitEntity;
    this.ability = ability;
    this.damage = damage;
    this.kill = kill;
    this.time = Game.time().now();
}
}
```
```java
class de.gurkenlabs.litiengine.graphics.emitters.Emitter {
public void delete() {
    this.deactivate();
    if (Game.world().environment() != null) {
      Game.world().environment().remove(this);
    }
}public void activate() {
    if (this.activated) {
      return;
    }

    this.activated = true;
    this.activationTick = Game.time().now();
    Game.loop().attach(this);
}@Override
  public void update() {
    if (this.isPaused()) {
      return;
    }

    // clear particles if the effect time to life is reached
    if (this.isFinished()) {
      for (EmitterFinishedListener listener : this.finishedListeners) {
        listener.finished(this);
      }

      this.delete();
      return;
    }

    final float updateRatio = (float) this.data().getUpdateRate() / Game.loop().getTickRate();
    for (final Particle p : this.getParticles().stream().collect(Collectors.toList())) {
      if (this.particleCanBeRemoved(p)) {
        // remove dead particles
        this.particles.remove(p);
        continue;
      }

      p.update(this.getOrigin(), updateRatio);
    }

    this.aliveTime = Game.time().since(this.activationTick);
    if ((this.data().getSpawnRate() == 0
        || Game.time().since(this.lastSpawn) >= this.data().getSpawnRate())) {
      this.lastSpawn = Game.time().now();
      this.spawnParticle();
    }
}
}
```
```java
class de.gurkenlabs.litiengine.GameLoop {
@Override
  public int perform(int delay, Runnable action) {
    final long d = Game.time().toTicks(delay);

    TimedAction a = new TimedAction(this.getTicks() + d, action);
    this.actions.add(a);

    return a.getId();
}
}
```
```java
class de.gurkenlabs.litiengine.environment.EntitySpawner {
protected boolean shouldSpawn() {
    return this.lastSpawnWave == 0
        || Game.time().since(this.lastSpawnWave) >= this.getSpawnInterval();
}@Override
  public void update() {
    if (!this.shouldSpawn()) {
      return;
    }

    this.spawnNewEntities();
    this.lastSpawnWave = Game.time().now();
}
}
```
```java
class de.gurkenlabs.litiengine.graphics.FreeFlightCamera {
@Override
  public void update() {
    this.handleFreeFlightCamera();
}public FreeFlightCamera(double x, double y) {
    this(new Point2D.Double(x, y));
}
}
```
```java
class de.gurkenlabs.litiengine.environment.Environment {
public void unload() {
    if (!this.loaded) {
      return;
    }

    // unregister all updatable entities from the current environment
    for (final IEntity entity : this.allEntities.values()) {
      this.unload(entity);
    }

    this.loaded = false;
    this.fireEvent(l -> l.unloaded(this));
}private static void loadUpdatableOrEmitterEntity(IEntity entity) {
    if (entity instanceof Emitter) {
      final Emitter emitter = (Emitter) entity;
      if (emitter.isActivateOnInit()) {
        emitter.activate();
      }
    } else if (entity instanceof IUpdateable) {
      Game.loop().attach((IUpdateable) entity);
    }
}public void clear() {
    Game.physics().clear();

    this.combatEntities.clear();
    this.mobileEntities.clear();
    this.gravityForces.clear();
    this.layerEntities.clear();
    this.entitiesByTag.clear();
    this.allEntities.clear();

    for (RenderType renderType : RenderType.values()) {
      this.miscEntities.get(renderType).clear();
      this.renderListeners.get(renderType).clear();
      this.renderables.get(renderType).clear();
    }

    dispose(this.allEntities.values());
    dispose(this.triggers);
    this.emitters.clear();
    this.colliders.clear();
    this.props.clear();
    this.creatures.clear();
    this.staticShadows.clear();
    this.combatEntities.clear();
    this.mobileEntities.clear();
    this.lightSources.clear();
    this.spawnPoints.clear();
    this.soundSources.clear();
    this.mapAreas.clear();
    this.triggers.clear();

    this.ambientLight = null;
    this.staticShadowLayer = null;

    for (Map<Integer, IEntity> type : this.miscEntities.values()) {
      type.clear();
    }

    this.initialized = false;

    this.fireEvent(l -> l.cleared(this));
}private void load(final IEntity entity) {
    // an entity can only exist on one environment at a time, so remove it from the current one
    if (entity.getEnvironment() != null) {
      entity.getEnvironment().remove(entity);
    }

    // 1. add to physics engine
    loadPhysicsEntity(entity);

    // 2. register for update or activate
    loadUpdatableOrEmitterEntity(entity);

    // 3. if a gravity is defined, add a gravity force to the entity
    if (entity instanceof IMobileEntity && this.getGravity() != 0) {
      this.addGravityForce((IMobileEntity) entity);
    }

    // 4. attach all controllers
    entity.attachControllers();

    if (this.loaded && (entity instanceof LightSource || entity instanceof StaticShadow)) {
      this.updateLighting(entity);
    }

    entity.loaded(this);
}private void unload(final IEntity entity) {
    // 1. remove from physics engine
    if (entity instanceof ICollisionEntity) {
      Game.physics().remove((ICollisionEntity) entity);
    }

    // 2. unregister from update
    if (entity instanceof IUpdateable) {
      Game.loop().detach((IUpdateable) entity);
    }

    if (entity instanceof IMobileEntity) {
      this.removeGravity((IMobileEntity) entity);
    }

    // 3. detach all controllers
    entity.detachControllers();

    if (entity instanceof Emitter) {
      Emitter em = (Emitter) entity;
      em.deactivate();
    }

    if (this.loaded && (entity instanceof LightSource || entity instanceof StaticShadow)) {
      this.updateLighting(entity);
    }

    entity.removed(this);
}public void remove(final IEntity entity) {
    if (entity == null) {
      return;
    }

    this.allEntities.remove(entity.getMapId());
    Iterator<List<IEntity>> iter = this.layerEntities.values().iterator();
    while (iter.hasNext()) {
      List<IEntity> layer = iter.next();
      if (layer.remove(entity) && layer.isEmpty()) {
        iter.remove();
      }
    }
    if (this.miscEntities.get(entity.getRenderType()) != null) {
      this.miscEntities.get(entity.getRenderType()).values().remove(entity);
    }

    for (String tag : entity.getTags()) {
      if (this.getEntitiesByTag().containsKey(tag)) {
        this.getEntitiesByTag().get(tag).remove(entity);

        if (this.getEntitiesByTag().get(tag).isEmpty()) {
          this.getEntitiesByTag().remove(tag);
        }
      }
    }

    if (entity instanceof Emitter) {
      Emitter emitter = (Emitter) entity;
      this.removeEmitter(emitter);
    }

    if (entity instanceof MapArea) {
      this.mapAreas.remove(entity);
    }

    if (entity instanceof Prop) {
      this.props.remove(entity);
    }

    if (entity instanceof Creature) {
      this.creatures.remove(entity);
    }

    if (entity instanceof CollisionBox) {
      this.colliders.remove(entity);
      this.staticShadows.removeIf(x -> x.getOrigin() != null && x.getOrigin().equals(entity));
    }

    if (entity instanceof LightSource) {
      this.lightSources.remove(entity);
      this.updateLighting(entity);
    }

    if (entity instanceof Trigger) {
      this.triggers.remove(entity);
    }

    if (entity instanceof Spawnpoint) {
      this.spawnPoints.remove(entity);
    }
    if (entity instanceof SoundSource) {
      this.soundSources.remove(entity);
    }

    if (entity instanceof StaticShadow) {
      this.staticShadows.remove(entity);
      this.updateLighting(entity);
    }

    if (entity instanceof IMobileEntity) {
      this.mobileEntities.values().remove(entity);
    }

    if (entity instanceof ICombatEntity) {
      this.combatEntities.values().remove(entity);
    }

    this.unload(entity);

    this.fireEntityEvent(l -> l.entityRemoved(entity));
}
}
```
```java
class de.gurkenlabs.litiengine.physics.MovementController {
@Override
  public void update() {
    this.handleForces();
    this.handleMovement();
}
}
```
```java
class de.gurkenlabs.litiengine.Game {
static synchronized void terminate() {
    if (!initialized) {
      return;
    }

    hasStarted = false;
    initialized = false;

    config().save();
    gameLoop.terminate();
    tweenEngine.terminate();
    soundEngine.terminate();

    world().clear();

    for (final GameListener listener : gameListeners) {
      try {
        listener.terminated();
      } catch (Exception e) {
        log().log(Level.WARNING, "game listener threw an exception during shutdown", e);
      }
    }

    gameLoop = null;
    screenManager = null;
    gameWindow = null;
}public static synchronized void start() {
    if (!initialized) {
      throw new IllegalStateException(
          "The game cannot be started without being first initialized. Call Game.init(...) before Game.start().");
    }

    gameLoop.start();
    tweenEngine.start();
    soundEngine.start();

    for (final GameListener listener : gameListeners) {
      listener.started();
    }

    hasStarted = true;
}public static synchronized void init(String... args) {
    if (initialized) {
      log().log(Level.INFO, "The game has already been initialized.");
      return;
    }

    log.init();
    handleCommandLineArguments(args);

    config().load();
    Locale.setDefault(new Locale(config().client().getCountry(), config().client().getLanguage()));

    gameLoop = new GameLoop("Main Update Loop", config().client().getMaxFps());
    loop().attach(physics());
    loop().attach(world());

    // setup default exception handling for render and update loop
    setUncaughtExceptionHandler(
        new DefaultUncaughtExceptionHandler(config().client().exitOnError()));

    screenManager = new ScreenManager();
    gameWindow = new GameWindow();

    // initialize  the game window
    window().init();
    world.setCamera(new Camera());

    for (GameListener listener : gameListeners) {
      listener.initialized(args);
    }

    if (!isInNoGUIMode()) {
      window().getRenderComponent().onRendered(g -> metrics().render(g));

      graphics()
          .addEntityRenderedListener(
              e -> DebugRenderer.renderEntityDebugInfo(e.getGraphics(), e.getEntity()));

      window().getRenderComponent().onFpsChanged(fps -> metrics().setFramesPerSecond(fps));
      window()
          .setIcons(
              Arrays.asList(
                  Resources.images().get("liti-logo-x16.png"),
                  Resources.images().get("liti-logo-x20.png"),
                  Resources.images().get("liti-logo-x32.png"),
                  Resources.images().get("liti-logo-x48.png")));

      Input.keyboard()
          .onKeyTyped(
              KeyEvent.VK_PRINTSCREEN,
              key -> {
                // don't take a screenshot if a modifier is active
                if (key.getModifiers() != 0) {
                  return;
                }

                window().getRenderComponent().takeScreenshot();
              });
    }

    Runtime.getRuntime().addShutdownHook(new Thread(Game::terminate, "Shutdown"));

    initialized = true;
}
}
```


Response Format:
Provide the answer in **XML format** as follows:

#### If the method **cannot** return `null` at the specific call site:
```xml
<response>
  <reason><![CDATA[EXPLAIN WHY THE INVOCATION loop() RESULT CANNOT BE NULL.]]></reason>
  <value>NO</value>
</response>

#### If the method can return null at the specific call site:
<response>
  <reason><![CDATA[EXPLAIN WHY THE INVOCATION loop() RESULT CAN BE NULL.]]></reason>
  <value>YES</value>
</response>

#### If you are unsure or If there are any methods that directly or indirectly affect the return value and are not fully disclosed, request their declarations first, in the following format:
<response>
  <reason><![CDATA[EXPLAIN WHY THIS METHOD DECLARATION IS NECESSARY AND WHY YOU CANNOT MAKE A CONFIDENT DECISION WITHOUT IT]]></reason>
  <success>false</success>
  <methods>
    <method>methodName</method>
  </methods>
</response>

Additional Notes:
Be precise in your reasoning.
If a method’s return value depends on another method not provided, request its declaration before making a conclusion.
If the method can return null in this case but not in others, explain why it happens specifically for this call.

---ChatGPT.sendRequestToOpenAI---
Retrieving response from cache
---Response.<init>---
Creating Response:
```xml
<response>
  <reason><![CDATA[The `loop()` method returns the static field `gameLoop`. According to the provided code, `gameLoop` is initialized in the `Game.init(String... args)` method, which is called before `Game.start()` as indicated in the `Game.start()` method logic. The initialization sets `gameLoop` to a new instance of `GameLoop`, ensuring it is not null when `Game.start()` is called. Therefore, at the call site, `loop()` cannot return null because `Game.start()` cannot be invoked without having initialized the game through `Game.init(...),` which guarantees `gameLoop` is non-null.]]></reason>
  <value>NO</value>
</response>
```
---Response.<init>---
Response created:
Disagreement: The `loop()` method returns the static field `gameLoop`. According to the provided code, `gameLoop` is initialized in the `Game.init(String... args)` method, which is called before `Game.start()` as indicated in the `Game.start()` method logic. The initialization sets `gameLoop` to a new instance of `GameLoop`, ensuring it is not null when `Game.start()` is called. Therefore, at the call site, `loop()` cannot return null because `Game.start()` cannot be invoked without having initialized the game through `Game.init(...),` which guarantees `gameLoop` is non-null.
---AdvancedNullAwayCodeFix.resolveMethodDereferenceError---
Method is not returning nullable on call site. Injecting suppression annotation.
---AdvancedNullAwayCodeFix.constructCastToNonnullChange---
Constructing cast to nonnull change for reason: The `loop()` method returns the static field `gameLoop`. According to the provided code, `gameLoop` is initialized in the `Game.init(String... args)` method, which is called before `Game.start()` as indicated in the `Game.start()` method logic. The initialization sets `gameLoop` to a new instance of `GameLoop`, ensuring it is not null when `Game.start()` is called. Therefore, at the call site, `loop()` cannot return null because `Game.start()` cannot be invoked without having initialized the game through `Game.init(...),` which guarantees `gameLoop` is non-null.
---ChatGPT.ask---
Asking ChatGPT:
For the reason you mentioned earlier:

"The `loop()` method returns the static field `gameLoop`. According to the provided code, `gameLoop` is initialized in the `Game.init(String... args)` method, which is called before `Game.start()` as indicated in the `Game.start()` method logic. The initialization sets `gameLoop` to a new instance of `GameLoop`, ensuring it is not null when `Game.start()` is called. Therefore, at the call site, `loop()` cannot return null because `Game.start()` cannot be invoked without having initialized the game through `Game.init(...),` which guarantees `gameLoop` is non-null."

in the method below, the expression loop() is not nullable at the point it is used.

```java
public static synchronized void init(String... args) {
    if (initialized) {
      log().log(Level.INFO, "The game has already been initialized.");
      return;
    }

    log.init();
    handleCommandLineArguments(args);

    config().load();
    Locale.setDefault(new Locale(config().client().getCountry(), config().client().getLanguage()));

    gameLoop = new GameLoop("Main Update Loop", config().client().getMaxFps());
    loop().attach(physics());
    loop().attach(world());

    // setup default exception handling for render and update loop
    setUncaughtExceptionHandler(
        new DefaultUncaughtExceptionHandler(config().client().exitOnError()));

    screenManager = new ScreenManager();
    gameWindow = new GameWindow();

    // initialize  the game window
    window().init();
    world.setCamera(new Camera());

    for (GameListener listener : gameListeners) {
      listener.initialized(args);
    }

    if (!isInNoGUIMode()) {
      window().getRenderComponent().onRendered(g -> metrics().render(g));

      graphics()
          .addEntityRenderedListener(
              e -> DebugRenderer.renderEntityDebugInfo(e.getGraphics(), e.getEntity()));

      window().getRenderComponent().onFpsChanged(fps -> metrics().setFramesPerSecond(fps));
      window()
          .setIcons(
              Arrays.asList(
                  Resources.images().get("liti-logo-x16.png"),
                  Resources.images().get("liti-logo-x20.png"),
                  Resources.images().get("liti-logo-x32.png"),
                  Resources.images().get("liti-logo-x48.png")));

      Input.keyboard()
          .onKeyTyped(
              KeyEvent.VK_PRINTSCREEN,
              key -> {
                // don't take a screenshot if a modifier is active
                if (key.getModifiers() != 0) {
                  return;
                }

                window().getRenderComponent().takeScreenshot();
              });
    }

    Runtime.getRuntime().addShutdownHook(new Thread(Game::terminate, "Shutdown"));

    initialized = true;
}
```
Please Summarize the reason in max 5 words and rewrite the method so that at the line "    loop().attach(physics());", at the occurrence of: "loop()" is replaced with `NullabilityUtil.castToNonnull(loop(), summary of reason)`
Replace "REASON" with the exact reason summary I provide to you (maximum 5 words), not with a generic explanation like "checked to be nonnull".
see the example below, for expression `foo.getBar()`, to wrap it with `NullabilityUtil.castToNonnull(foo.getBar(), "reason")`.

```java
public t(){
    String l = foo.getBar();
}
```

will be:
```java
public t(){
    String l = NullabilityUtil.castToNonnull(foo.getBar(), "checked to be nonnull");
}
```

### Instructions:

Do not import any additional classes.

Do not add Java comments.

Only modify relevant lines as required.

Return only the modified method wrapped in the XML format shown below.

Place the Java code inside the <code> tag using a CDATA block with ```java formatting.

Just give me the fixed code snippet in XML format in <response> tag like the example below. I will apply the fix to my codebase. Do not import any additional libraries or classes or add java comments. If you can provide the fixed code snippet, please provide it in the following format and place the code snippet in the <code> tag within ```java block.
<response>
  <success>true</success>
  <code><![CDATA[
  ```java
  Your fixed code snippet here
  ```
    ]]>
  </code>
</response>

---ChatGPT.sendRequestToOpenAI---
Retrieving response from cache
---Response.<init>---
Creating Response:
```xml
<response>
  <success>true</success>
  <code><![CDATA[
  ```java
public static synchronized void init(String... args) {
    if (initialized) {
      log().log(Level.INFO, "The game has already been initialized.");
      return;
    }

    log.init();
    handleCommandLineArguments(args);

    config().load();
    Locale.setDefault(new Locale(config().client().getCountry(), config().client().getLanguage()));

    gameLoop = new GameLoop("Main Update Loop", config().client().getMaxFps());
    NullabilityUtil.castToNonnull(loop(), "gameLoop is non-nullified").attach(physics());
    loop().attach(world());

    setUncaughtExceptionHandler(
        new DefaultUncaughtExceptionHandler(config().client().exitOnError()));

    screenManager = new ScreenManager();
    gameWindow = new GameWindow();

    window().init();
    world.setCamera(new Camera());

    for (GameListener listener : gameListeners) {
      listener.initialized(args);
    }

    if (!isInNoGUIMode()) {
      window().getRenderComponent().onRendered(g -> metrics().render(g));

      graphics()
          .addEntityRenderedListener(
              e -> DebugRenderer.renderEntityDebugInfo(e.getGraphics(), e.getEntity()));

      window().getRenderComponent().onFpsChanged(fps -> metrics().setFramesPerSecond(fps));
      window()
          .setIcons(
              Arrays.asList(
                  Resources.images().get("liti-logo-x16.png"),
                  Resources.images().get("liti-logo-x20.png"),
                  Resources.images().get("liti-logo-x32.png"),
                  Resources.images().get("liti-logo-x48.png")));

      Input.keyboard()
          .onKeyTyped(
              KeyEvent.VK_PRINTSCREEN,
              key -> {
                if (key.getModifiers() != 0) {
                  return;
                }

                window().getRenderComponent().takeScreenshot();
              });
    }

    Runtime.getRuntime().addShutdownHook(new Thread(Game::terminate, "Shutdown"));

    initialized = true;
}
  ```
    ]]>
  </code>
</response>
```
---Response.<init>---
Response created:
public static synchronized void init(String... args) {
    if (initialized) {
      log().log(Level.INFO, "The game has already been initialized.");
      return;
    }

    log.init();
    handleCommandLineArguments(args);

    config().load();
    Locale.setDefault(new Locale(config().client().getCountry(), config().client().getLanguage()));

    gameLoop = new GameLoop("Main Update Loop", config().client().getMaxFps());
    NullabilityUtil.castToNonnull(loop(), "gameLoop is non-nullified").attach(physics());
    loop().attach(world());

    setUncaughtExceptionHandler(
        new DefaultUncaughtExceptionHandler(config().client().exitOnError()));

    screenManager = new ScreenManager();
    gameWindow = new GameWindow();

    window().init();
    world.setCamera(new Camera());

    for (GameListener listener : gameListeners) {
      listener.initialized(args);
    }

    if (!isInNoGUIMode()) {
      window().getRenderComponent().onRendered(g -> metrics().render(g));

      graphics()
          .addEntityRenderedListener(
              e -> DebugRenderer.renderEntityDebugInfo(e.getGraphics(), e.getEntity()));

      window().getRenderComponent().onFpsChanged(fps -> metrics().setFramesPerSecond(fps));
      window()
          .setIcons(
              Arrays.asList(
                  Resources.images().get("liti-logo-x16.png"),
                  Resources.images().get("liti-logo-x20.png"),
                  Resources.images().get("liti-logo-x32.png"),
                  Resources.images().get("liti-logo-x48.png")));

      Input.keyboard()
          .onKeyTyped(
              KeyEvent.VK_PRINTSCREEN,
              key -> {
                if (key.getModifiers() != 0) {
                  return;
                }

                window().getRenderComponent().takeScreenshot();
              });
    }

    Runtime.getRuntime().addShutdownHook(new Thread(Game::terminate, "Shutdown"));

    initialized = true;
}
---ChatGPT.fixDereferenceByAddingCastToNonnull---
Fixing the error by adding castToNonnull
---AdvancedNullAwayCodeFix.fixTriggeredErrorsForLocation---
Resolving unresolvable error for triggered error: Type='DEREFERENCE_NULLABLE', message='dereferenced expression Game.loop() is @Nullable'
/home/nima/Developer/nullness-benchmarks/litiengine/src/de/gurkenlabs/litiengine/GameMetrics.java:88
    this.drawMetric(g, "updatables: " + Game.loop().getUpdatableCount());
---AdvancedNullAwayCodeFix.fix---
Fixing error: Type='DEREFERENCE_NULLABLE', message='dereferenced expression Game.loop() is @Nullable'
/home/nima/Developer/nullness-benchmarks/litiengine/src/de/gurkenlabs/litiengine/GameMetrics.java:88
    this.drawMetric(g, "updatables: " + Game.loop().getUpdatableCount());
---AdvancedNullAwayCodeFix.resolveDereferenceError---
Resolving dereference error: Type='DEREFERENCE_NULLABLE', message='dereferenced expression Game.loop() is @Nullable'
/home/nima/Developer/nullness-benchmarks/litiengine/src/de/gurkenlabs/litiengine/GameMetrics.java:88
    this.drawMetric(g, "updatables: " + Game.loop().getUpdatableCount());
---AdvancedNullAwayCodeFix.resolveDereferenceError---
Checking nullability possibility at error point
---ChatGPT.checkNullabilityPossibilityAtErrorPoint---
Asking if the expression can be null at error point point
---ChatGPT.ask---
Asking ChatGPT:
In the method below, is there a possibility that the expression "Game.loop()" at line "this.drawMetric(g, "updatables: " + Game.loop().getUpdatableCount());" is null?
@Override
  public void render(final Graphics2D g) {
    this.updateMetrics();

    if (!Game.config().client().showGameMetrics()) {
      return;
    }

    this.currentOffsetY = 0;

    g.setColor(this.renderColor);

    // render client metrics
    this.drawTitle(g, "[client]");
    this.drawMetric(g, "fps       : " + this.getFramesPerSecond());
    this.drawMetric(g, "max fps   : " + this.maxFramesPerSecond);
    this.drawMetric(g, "updatables: " + Game.loop().getUpdatableCount());

    // render jvm metrics if debug is enabled
    if (Game.config().debug().isDebugEnabled()) {
      this.drawTitle(g, "[jvm]");
      this.drawMetric(g, "java      : " + this.javaVersion);
      this.drawMetric(g, "memory    : " + String.format("%-5.5s", this.usedMemory) + " MB");
      this.drawMetric(g, "threads   : " + Thread.activeCount());
    }

    // render rendering metrics
    if (!this.renderMetrics.isEmpty()) {
      this.drawTitle(g, "[update]");

      for (RenderMetrics metric : this.renderMetrics) {
        this.drawMetric(g, metric.toString());
      }

      this.renderMetrics.clear();
    }
}
Give a single-word answer in XML format. If it is possible for the expression to be null, respond with:
```xml
<response>
    <reason><![CDATA[YOUR REASON]]></reason>
    <value>YES</value>
</response>
```
If it is not possible for the expression to be null, respond with:
```xml
<response>
    <reason><![CDATA[YOUR REASON]]></reason>
    <value>NO</value>
</response>
```
If you are unsure or need more information, respond with where you can ask for more details or what specific information you need.

If additional information is required, list each request inside a `<request>` tag. If no additional information is needed, omit the `<requests>` section.

Respond with:
```xml
<response>
    <reason><![CDATA[YOUR REASON]]></reason>
    <value>UNKNOWN</value>
    <!-- Include <requests> only if additional information is needed -->
    <requests>
        <request><![CDATA[YOUR REQUEST 1]]></request>
        <request><![CDATA[YOUR REQUEST 2]]></request>
    </requests>
</response>
```
---ChatGPT.sendRequestToOpenAI---
Retrieving response from cache
---Response.<init>---
Creating Response:
```xml
<response>
    <reason><![CDATA[Without seeing the implementation of Game.loop(), it's impossible to determine if it can return null.]]></reason>
    <value>UNKNOWN</value>
    <requests>
        <request><![CDATA[Provide the implementation details of Game.loop().]]></request>
    </requests>
</response>
```
---Response.<init>---
Response created:
Unknown: Without seeing the implementation of Game.loop(), it's impossible to determine if it can return null.
---AdvancedNullAwayCodeFix.resolveMethodDereferenceError---
Resolving method dereference error.
---AdvancedNullAwayCodeFix.resolveMethodDereferenceError---
Method is in annotated package. Checking if the method is returning nullable.
---AdvancedNullAwayCodeFix.investigateMethodReturnNullability---
Checking if the method is returning nullable.
---ChatGPT.checkIfMethodIsReturningNullable---
Asking if the method is returning nullable: loop()
---ChatGPT.ask---
Asking ChatGPT:
In the method below, is there a possibility that the method returns null based only on its body? Consider the following points:

- The method may have multiple return paths; consider all return statements.
- If the method calls another method, do not assume its return value unless its full declaration is provided. Request its declaration if needed.
- The method may throw an exception instead of returning null. An exception path should not be considered a null return.
- Ensure you request the declarations of any methods whose return values directly or indirectly impact this method’s return value before making a conclusion.
- Carefully analyze all conditions and prior operations that may guarantee a non-null return value.

@Nullable public static IGameLoop loop() {
    return gameLoop;
}

Here are the method definitions in addition to the method inquired:

Depth: 0
```java
class de.gurkenlabs.litiengine.Game {
@Nullable public static IGameLoop loop() {
    return gameLoop;
}
}
```


Response Format:
Provide the answer in **XML format** as follows:

#### If the method **cannot** return `null`:
```xml
<response>
  <reason><![CDATA[EXPLAIN WHY THE METHOD CANNOT RETURN NULL]]></reason>
  <value>NO</value>
</response>
```

#### If the method can return null:
```xml
<response>
  <reason><![CDATA[EXPLAIN WHY THE METHOD CAN RETURN NULL]]></reason>
  <value>YES</value>
</response>
```

#### If you are unsure or need more information, respond with where you can ask for more details or what specific information you need.

#### If you are unsure or If there are any methods that directly or indirectly affect the return value and are not fully disclosed, request their declarations first, in the following format:
<response>
  <reason><![CDATA[YOUR REASON]]></reason>
  <value>UNKNOWN</value>
  <methods>
    <method>methodName</method>
  </methods>
</response>

If additional information is required other than method declaration, list each request inside a `<request>` tag. If no additional information is needed, omit the `<requests>` section.

Respond with:
```xml
<response>
    <reason><![CDATA[YOUR REASON]]></reason>
    <value>UNKNOWN</value>
    <!-- Include <requests> only if additional information is needed -->
    <requests>
        <request><![CDATA[YOUR REQUEST 1]]></request>
        <request><![CDATA[YOUR REQUEST 2]]></request>
    </requests>
</response>
```

Additional Notes:
Be precise in your reasoning.
If a method’s return value depends on another method not provided, request its declaration before making a conclusion.
If the method can return null in some cases but not others, explain under what conditions it can happen.

---ChatGPT.sendRequestToOpenAI---
Retrieving response from cache
---Response.<init>---
Creating Response:
```xml
<response>
  <reason><![CDATA[The method `loop` returns the variable `gameLoop`. Without the initialization or assignment details of `gameLoop`, it's unclear whether it can be null. The possibility of `gameLoop` being uninitialized or set to null elsewhere in the program means `loop` could potentially return null. Further information on `gameLoop` is required.]]></reason>
  <value>UNKNOWN</value>
  <requests>
    <request><![CDATA[Please provide the declaration and initialization of the variable `gameLoop` in the class `de.gurkenlabs.litiengine.Game`.]]></request>
  </requests>
</response>
```
---Response.<init>---
Response created:
Unknown: The method `loop` returns the variable `gameLoop`. Without the initialization or assignment details of `gameLoop`, it's unclear whether it can be null. The possibility of `gameLoop` being uninitialized or set to null elsewhere in the program means `loop` could potentially return null. Further information on `gameLoop` is required.
---AdvancedNullAwayCodeFix.investigateMethodReturnNullability---
Could not determine the nullability and model did not ask for any method.
---ChatGPT.checkIfMethodIsReturningNullableOnCallSite---
Asking if the method is returning nullable on the call site: Game.loop()
---ChatGPT.ask---
Asking ChatGPT:
In the method below, is there a possibility that the method returns null at the given call site?

```java
@Nullable public static IGameLoop loop() {
    return gameLoop;
}
```

## Guidelines:
- The method may have multiple return paths; consider all return statements.
- If the method calls another method, do not assume its return value unless its full declaration is provided. Request its declaration if needed.
- The method may throw an exception instead of returning null. An exception path should not be considered a null return.
- Ensure you request the declarations of any methods whose return values directly or indirectly impact this method’s return value before making a conclusion.
- If the method returns a value that is determined by a parameter, evaluate based on the actual argument at the given call site.
- Analyze based only on the specific invocation provided. Do not generalize to all possible inputs.- If the return value is guaranteed to be non-null at the call site, the answer should be a definitive NO.
- Do not generalize based on all possible inputs—your answer must be based only on the given invocation.
- Focus only on the given call site, not all possible invocations.

### call site:
Game.loop()

Here are the method definitions and the call chain for this method, showing the sequence of calls from the method to its callers at each depth level:

Depth: 0
```java
class de.gurkenlabs.litiengine.Game {
@Nullable public static IGameLoop loop() {
    return gameLoop;
}
}
```
Depth: 1
```java
class de.gurkenlabs.litiengine.environment.GameWorld {
public void loadEnvironment(@Nullable final Environment env) {
    Lock lock = Game.loop().getLock();
    lock.lock();
    try {
      unloadEnvironment();
      this.environment = env;
      if (env != null) {
        this.addEnvironment(env);

        if (env.getGravity() == 0 && this.gravity() != 0) {
          env.setGravity(this.gravity());
        }

        env.load();
        for (final EnvironmentLoadedListener listener : this.loadedListeners) {
          listener.loaded(env);
        }

        // call map specific listeners
        String mapName = getMapName(env);
        if (mapName != null && this.environmentLoadedListeners.containsKey(mapName)) {

          // for the default camera we center the camera on the environment
          if (this.camera().getClass().equals(Camera.class)) {
            camera().setFocus(env.getCenter());
          }

          for (EnvironmentLoadedListener listener : this.environmentLoadedListeners.get(mapName)) {
            listener.loaded(env);
          }
        }
      }
    } finally {
      lock.unlock();
    }
}public void setCamera(@Nullable final ICamera cam) {
    if (this.camera() != null) {
      Game.loop().detach(camera);
    }

    camera = cam;

    if (cam != null && !Game.isInNoGUIMode()) {
      Game.loop().attach(cam);
      cam.updateFocus();
    }
}
}
```
```java
class de.gurkenlabs.litiengine.entities.behavior.EntityNavigator {
public EntityNavigator(final IMobileEntity entity, final PathFinder pathFinder) {
    this.cancelNavigationConditions = new CopyOnWriteArrayList<>();
    this.listeners = new CopyOnWriteArrayList<>();
    this.entity = entity;
    this.pathFinder = pathFinder;
    this.setAcceptableError(DEFAULT_ACCEPTABLE_ERROR);
    Game.loop().attach(this);
}
}
```
```java
class de.gurkenlabs.litiengine.GameWindow {
private static void initializeWindowEventListeners(Window window) {

    window.addWindowStateListener(
        e -> {
          if (e.getNewState() == Frame.ICONIFIED) {
            Game.loop().setTickRate(ICONIFIED_MAX_FPS);
          } else {
            Game.loop().setTickRate(Game.config().client().getMaxFps());
          }
        });

    window.addWindowFocusListener(
        new WindowFocusListener() {
          @Override
          public void windowLostFocus(WindowEvent e) {
            if (Game.config().graphics().reduceFramesWhenNotFocused()) {
              Game.loop().setTickRate(NONE_FOCUS_MAX_FPS);
            }
          }

          @Override
          public void windowGainedFocus(WindowEvent e) {
            Game.loop().setTickRate(Game.config().client().getMaxFps());
          }
        });

    window.addWindowListener(
        new WindowAdapter() {
          @Override
          public void windowClosing(final WindowEvent event) {
            Game.exit();
          }
        });
}
}
```
```java
class de.gurkenlabs.litiengine.gui.screens.ScreenManager {
public void display(@Nullable final Screen screen) {
    if (Game.hasStarted() && Game.time().since(this.lastScreenChange) < this.getChangeCooldown()) {
      log.log(
          Level.INFO,
          "Skipping displaying of screen {0} because screen changing is currently on cooldown.",
          screen != null ? screen.getName() : "");
      return;
    }

    final Screen previous = this.current();
    if (previous != null) {
      previous.suspend();
    }

    if (screen != null && !this.screens.contains(screen)) {
      this.screens.add(screen);
    }

    this.currentScreen = screen;
    if (!Game.isInNoGUIMode() && this.current() != null) {
      this.current().prepare();
    }

    this.lastScreenChange = Game.loop().getTicks();

    final ScreenChangedEvent event = new ScreenChangedEvent(this.current(), previous);
    for (final ScreenChangedListener listener : this.screenChangedListeners) {
      listener.changed(event);
    }
}
}
```
```java
class de.gurkenlabs.litiengine.abilities.effects.Effect {
@Override
  public void update() {

    for (final Iterator<EffectApplication> iterator = this.getActiveAppliances().iterator();
        iterator.hasNext(); ) {
      final EffectApplication appliance = iterator.next();
      // if the effect duration is reached
      if (this.hasEnded(appliance)) {

        iterator.remove();
        this.cease(appliance);
      }
    }

    // 4. unregister if all appliances are finished
    if (this.getActiveAppliances().isEmpty()) {
      Game.loop().detach(this);
    }
}public void apply(final Shape impactArea) {
    final List<ICombatEntity> affected = this.lookForAffectedEntities(impactArea);
    for (final ICombatEntity affectedEntity : affected) {
      this.apply(affectedEntity);
    }

    this.appliances.add(new EffectApplication(affected, impactArea));

    // if it is the first appliance -> register for update
    if (this.appliances.size() == 1) {
      Game.loop().attach(this);
    }
}
}
```
```java
class de.gurkenlabs.litiengine.GameTime {
public long toTicks(final int milliseconds) {
    return this.toTicks(milliseconds, Game.loop().getTickRate());
}public long since(final long tick) {
    return toMilliseconds(Game.loop().getTicks() - tick);
}public long now() {
    return Game.loop().getTicks();
}public long sinceGameStart() {
    return this.toMilliseconds(Game.loop().getTicks());
}@Override
  public void loaded(Environment environment) {
    environmentLoaded = Game.loop().getTicks();
}public long toMilliseconds(final long ticks) {
    return this.toMilliseconds(ticks, Game.loop().getTickRate());
}
}
```
```java
class de.gurkenlabs.litiengine.GameMetrics {
@Override
  public void render(final Graphics2D g) {
    this.updateMetrics();

    if (!Game.config().client().showGameMetrics()) {
      return;
    }

    this.currentOffsetY = 0;

    g.setColor(this.renderColor);

    // render client metrics
    this.drawTitle(g, "[client]");
    this.drawMetric(g, "fps       : " + this.getFramesPerSecond());
    this.drawMetric(g, "max fps   : " + this.maxFramesPerSecond);
    this.drawMetric(g, "updatables: " + Game.loop().getUpdatableCount());

    // render jvm metrics if debug is enabled
    if (Game.config().debug().isDebugEnabled()) {
      this.drawTitle(g, "[jvm]");
      this.drawMetric(g, "java      : " + this.javaVersion);
      this.drawMetric(g, "memory    : " + String.format("%-5.5s", this.usedMemory) + " MB");
      this.drawMetric(g, "threads   : " + Thread.activeCount());
    }

    // render rendering metrics
    if (!this.renderMetrics.isEmpty()) {
      this.drawTitle(g, "[update]");

      for (RenderMetrics metric : this.renderMetrics) {
        this.drawMetric(g, metric.toString());
      }

      this.renderMetrics.clear();
    }
}
}
```
```java
class de.gurkenlabs.litiengine.graphics.emitters.Emitter {
public void deactivate() {
    if (!this.activated) {
      return;
    }

    this.activated = false;
    this.getParticles().clear();
    this.aliveTime = 0;
    this.activationTick = 0;
    this.lastSpawn = 0;
    Game.loop().detach(this);
}public void activate() {
    if (this.activated) {
      return;
    }

    this.activated = true;
    this.activationTick = Game.time().now();
    Game.loop().attach(this);
}@Override
  public void update() {
    if (this.isPaused()) {
      return;
    }

    // clear particles if the effect time to life is reached
    if (this.isFinished()) {
      for (EmitterFinishedListener listener : this.finishedListeners) {
        listener.finished(this);
      }

      this.delete();
      return;
    }

    final float updateRatio = (float) this.data().getUpdateRate() / Game.loop().getTickRate();
    for (final Particle p : this.getParticles().stream().collect(Collectors.toList())) {
      if (this.particleCanBeRemoved(p)) {
        // remove dead particles
        this.particles.remove(p);
        continue;
      }

      p.update(this.getOrigin(), updateRatio);
    }

    this.aliveTime = Game.time().since(this.activationTick);
    if ((this.data().getSpawnRate() == 0
        || Game.time().since(this.lastSpawn) >= this.data().getSpawnRate())) {
      this.lastSpawn = Game.time().now();
      this.spawnParticle();
    }
}
}
```
```java
class de.gurkenlabs.litiengine.entities.behavior.IBehaviorController {
public default void attach() {
    Game.loop().attach(this);
}public default void detach() {
    Game.loop().detach(this);
}
}
```
```java
class de.gurkenlabs.litiengine.abilities.AbilityExecution {
AbilityExecution(final Ability ability) {
    this.appliedEffects = new CopyOnWriteArrayList<>();
    this.ability = ability;
    this.executionTicks = Game.time().now();
    this.impactArea = ability.calculateImpactArea();
    this.castLocation = ability.getExecutor().getCenter();
    Game.loop().attach(this);
}@Override
  public void update() {
    // if there a no effects to apply -> unregister this instance and we're done
    if (this.getAbility().getEffects().isEmpty()
        || this.getAbility().getEffects().size() == this.getAppliedEffects().size()) {
      Game.loop().detach(this);
      return;
    }

    // handle all effects from the ability that were not applied yet
    for (final Effect effect : this.getAbility().getEffects()) {
      // if the ability was not executed yet or the delay of the effect is not
      // yet reached
      if (this.getAppliedEffects().contains(effect)
          || Game.time().since(this.getExecutionTicks()) < effect.getDelay()) {
        continue;
      }

      effect.apply(this.getExecutionImpactArea());
      this.getAppliedEffects().add(effect);
    }
}
}
```
```java
class de.gurkenlabs.litiengine.GameWindow$3 {
@Override
          public void windowGainedFocus(WindowEvent e) {
            Game.loop().setTickRate(Game.config().client().getMaxFps());
}@Override
          public void windowLostFocus(WindowEvent e) {
            if (Game.config().graphics().reduceFramesWhenNotFocused()) {
              Game.loop().setTickRate(NONE_FOCUS_MAX_FPS);
            }
}
}
```
```java
class de.gurkenlabs.litiengine.environment.EntitySpawner {
protected void spawnNewEntities() {
    if (this.getSpawnMode() != SpawnMode.CUSTOMSPAWNPOINTS && this.getSpawnPoints().isEmpty()) {
      return;
    }

    switch (this.getSpawnMode()) {
      case ALLSPAWNPOINTS:
        for (int i = 0; i < this.getSpawnPoints().size(); i++) {
          final int index = i;
          Game.loop()
              .perform(
                  this.getSpawnDelay() + this.getSpawnDelay() * i,
                  () -> this.spawn(this.getSpawnPoints().get(index), this.getSpawnAmount()));
        }
        break;
      case ONERANDOMSPAWNPOINT:
        this.spawn(Game.random().choose(this.getSpawnPoints()), this.getSpawnAmount());
        break;
      case RANDOMSPAWNPOINTS:
        for (int i = 0; i < this.getSpawnAmount(); i++) {
          Game.loop()
              .perform(
                  this.getSpawnDelay() + this.getSpawnDelay() * i,
                  () -> this.spawn(Game.random().choose(this.getSpawnPoints()), 1));
        }
        break;
      case CUSTOMSPAWNPOINTS:
        List<Spawnpoint> spawnPoints =
            this.customSpawnpoints != null
                ? this.customSpawnpoints.apply(this)
                : this.getCustomSpawnpoints();

        int index = 0;
        for (Spawnpoint spawn : spawnPoints) {
          Game.loop()
              .perform(
                  this.getSpawnDelay() + this.getSpawnDelay() * index, () -> this.spawn(spawn, 1));
          index++;
        }
        break;
      default:
        break;
    }
}
}
```
```java
class de.gurkenlabs.litiengine.tweening.TweenEngine {
@Override
  public void start() {
    Game.loop().attach(this);
}@Override
  public void terminate() {
    Game.loop().detach(this);
}
}
```
```java
class de.gurkenlabs.litiengine.gui.SpeechBubble {
public void hide() {
    Game.world().environment().removeRenderable(this);
    Game.loop().detach(this);
    if (activeSpeechBubbles.get(this.getEntity()) != null
        && activeSpeechBubbles.remove(this.getEntity()).equals(this)) {
      activeSpeechBubbles.remove(this.getEntity());
    }

    for (SpeechBubbleListener listener : this.listeners) {
      listener.hidden();
    }
}private SpeechBubble(
      final IEntity entity,
      final String text,
      @Nullable SpeechBubbleAppearance appearance,
      @Nullable Font font) {
    if (appearance == null) {
      this.appearance = DEFAULT_APPEARANCE;
    } else {
      this.appearance = appearance;
    }

    final SpeechBubble active = activeSpeechBubbles.get(entity);
    if (active != null) {
      active.hide();
    }
    this.setFont(font);

    this.textBoxWidth = (float) (entity.getWidth() * 4);
    this.entity = entity;

    this.currentText = text;
    this.currentTextDisplayTime = DISPLAYTIME_MIN + text.length() * DISPLAYTIME_PER_LETTER;

    this.lastTextDisplay = Game.time().now();
    this.createBubbleImage();
    entity.getEnvironment().add(this, RenderType.UI);
    Game.loop().attach(this);
    activeSpeechBubbles.put(entity, this);
}
}
```
```java
class de.gurkenlabs.litiengine.entities.Prop {
private void updateAnimationController() {
    IEntityAnimationController<?> controller = this.createAnimationController();
    this.getControllers().addController(controller);
    if (Game.world().environment() != null && Game.world().environment().isLoaded()) {
      Game.loop().attach(controller);
    }
}
}
```
```java
class de.gurkenlabs.litiengine.graphics.FreeFlightCamera {
public FreeFlightCamera(final Point2D focus) {
    this.setFocus(focus);
    this.velocity = DEFAULT_SCROLL_PIXELS_PER_SECOND;
    this.scrollPadding = DEFAULT_SCROLL_PADDING;
    this.setClampToMap(true);

    Game.loop().attach(this);
}private void handleFreeFlightCamera() {
    if (Game.world().environment() == null || Game.world().environment().getMap() == null) {
      return;
    }

    final Point2D mouseLocation = Input.mouse().getLocation();

    final double scrollSpeed =
        this.getVelocity()
            / (double) Game.loop().getTickRate()
            * Game.config().input().getMouseSensitivity();

    double x = this.getFocus().getX();
    double y = this.getFocus().getY();

    double deltaX = 0;
    if (mouseLocation.getX() < this.getScrollPadding()) {
      deltaX -= scrollSpeed;
    } else if (Game.window().getResolution().getWidth() - mouseLocation.getX()
        < this.getScrollPadding()) {
      deltaX += scrollSpeed;
    }

    double deltaY = 0;
    if (mouseLocation.getY() < this.getScrollPadding()) {
      deltaY -= scrollSpeed;
    } else if (Game.window().getResolution().getHeight() - mouseLocation.getY()
        < this.getScrollPadding()) {
      deltaY += scrollSpeed;
    }

    x += deltaX;
    y += deltaY;

    this.setFocus(new Point2D.Double(x, y));
}
}
```
```java
class de.gurkenlabs.litiengine.environment.Environment {
private static void dispose(final Collection<? extends IEntity> entities) {
    for (final IEntity entity : entities) {
      if (entity instanceof IUpdateable) {
        Game.loop().detach((IUpdateable) entity);
      }

      entity.detachControllers();
    }
}private static void loadUpdatableOrEmitterEntity(IEntity entity) {
    if (entity instanceof Emitter) {
      final Emitter emitter = (Emitter) entity;
      if (emitter.isActivateOnInit()) {
        emitter.activate();
      }
    } else if (entity instanceof IUpdateable) {
      Game.loop().attach((IUpdateable) entity);
    }
}private void unload(final IEntity entity) {
    // 1. remove from physics engine
    if (entity instanceof ICollisionEntity) {
      Game.physics().remove((ICollisionEntity) entity);
    }

    // 2. unregister from update
    if (entity instanceof IUpdateable) {
      Game.loop().detach((IUpdateable) entity);
    }

    if (entity instanceof IMobileEntity) {
      this.removeGravity((IMobileEntity) entity);
    }

    // 3. detach all controllers
    entity.detachControllers();

    if (entity instanceof Emitter) {
      Emitter em = (Emitter) entity;
      em.deactivate();
    }

    if (this.loaded && (entity instanceof LightSource || entity instanceof StaticShadow)) {
      this.updateLighting(entity);
    }

    entity.removed(this);
}
}
```
```java
class de.gurkenlabs.litiengine.graphics.animation.Animation {
@Override
  public void update() {
    // do nothing if the animation is not playing or the current keyframe is not finished
    if (!this.isPlaying()
        || Game.time().since(this.lastFrameUpdate) < this.getCurrentKeyFrame().getDuration()) {
      return;
    }

    // if we are not looping and the last keyframe is finished, we terminate the animation
    if (!this.isLooping() && this.isLastKeyFrame()) {
      this.terminate();
      return;
    }

    // make sure, we stay inside the keyframe list
    final int newFrameIndex =
        (this.getKeyframes().indexOf(this.currentFrame) + 1) % this.getKeyframes().size();
    final KeyFrame previousFrame = this.currentFrame;
    this.currentFrame = this.getKeyframes().get(newFrameIndex);

    for (KeyFrameListener listener : this.listeners) {
      listener.currentFrameChanged(previousFrame, this.currentFrame);
    }

    this.lastFrameUpdate = Game.loop().getTicks();
}public void restart() {
    this.currentFrame = this.firstFrame;
    this.lastFrameUpdate = Game.loop().getTicks();
}
}
```
```java
class de.gurkenlabs.litiengine.physics.MovementController {
@Override
  public void attach() {
    Game.loop().attach(this);
}private void handleForces() {
    // clean up forces
    this.activeForces.forEach(
        x -> {
          if (x.hasEnded()) {
            this.activeForces.remove(x);
          }
        });

    if (this.activeForces.isEmpty()) {
      return;
    }

    // disable turn-on-move for force handling
    boolean turn = this.getEntity().turnOnMove();
    this.getEntity().setTurnOnMove(false);
    try {
      double deltaX = 0;
      double deltaY = 0;
      for (final Force force : this.activeForces) {
        if (force.cancelOnReached() && force.hasReached(this.getEntity())) {
          force.end();
          continue;
        }

        final Point2D collisionBoxCenter = this.getEntity().getCollisionBoxCenter();
        final double angle =
            GeometricUtilities.calcRotationAngleInDegrees(collisionBoxCenter, force.getLocation());
        final double strength =
            Game.loop().getDeltaTime() * 0.001f * force.getStrength() * Game.loop().getTimeScale();
        deltaX += GeometricUtilities.getDeltaX(angle, strength);
        deltaY += GeometricUtilities.getDeltaY(angle, strength);
      }

      final Point2D target =
          new Point2D.Double(this.getEntity().getX() + deltaX, this.getEntity().getY() + deltaY);
      final boolean success = Game.physics().move(this.getEntity(), target);
      if (!success) {
        for (final Force force : this.activeForces) {
          if (force.cancelOnCollision()) {
            force.end();
          }
        }
      }
    } finally {
      this.getEntity().setTurnOnMove(turn);
    }
}@Override
  public void detach() {
    Game.loop().detach(this);
}public void handleMovement() {
    if (!this.isMovementAllowed()) {
      this.velocity = 0;
      return;
    }

    // max distance an entity can travel within one tick
    final double maxPixelsPerTick = this.getEntity().getTickVelocity();
    final double deltaTime = Game.loop().getDeltaTime() * Game.loop().getTimeScale();

    final double acceleration =
        this.getEntity().getAcceleration() == 0
            ? maxPixelsPerTick
            : deltaTime / this.getEntity().getAcceleration() * maxPixelsPerTick;
    final double deceleration =
        this.getEntity().getDeceleration() == 0
            ? this.getVelocity()
            : deltaTime / this.getEntity().getDeceleration() * maxPixelsPerTick;

    double dx = this.getDx();
    double dy = this.getDy();
    this.setDx(0);
    this.setDy(0);

    final double deltaVelocity =
        Math.min(Math.sqrt(Math.pow(dx, 2) + Math.pow(dy, 2)), acceleration);
    if (deltaVelocity != 0) {
      double newVelocity = this.getVelocity() + deltaVelocity;
      this.setVelocity(newVelocity);
    } else {
      final double newVelocity = Math.max(0, this.getVelocity() - deceleration);
      this.setVelocity(newVelocity);
      dx = GeometricUtilities.getDeltaX(this.moveAngle);
      dy = GeometricUtilities.getDeltaY(this.moveAngle);
    }

    if (this.getVelocity() == 0) {
      this.moveAngle = 0;
      return;
    }

    // actually move entity
    this.moveEntity(dx, dy);
}
}
```
```java
class de.gurkenlabs.litiengine.graphics.animation.AnimationController {
public void detach() {
    Game.loop().detach(this);
}public void attach() {
    Game.loop().attach(this);
}
}
```
```java
class de.gurkenlabs.litiengine.graphics.Camera {
@Override
  public void setZoom(final float targetZoom, final int delay) {
    if (delay == 0) {

      this.zoom = targetZoom;
      this.targetZoom = 0;
      this.zoomDelay = 0;
      this.zoomTick = 0;
      this.zoomStep = 0;

      final ZoomChangedEvent event = new ZoomChangedEvent(this, targetZoom);
      for (final ZoomChangedListener listener : this.zoomListeners) {
        listener.zoomChanged(event);
      }
    } else {
      this.zoomTick = Game.time().now();
      this.targetZoom = targetZoom;
      this.zoomDelay = delay;

      final double tickduration = 1000 / (double) Game.loop().getTickRate();
      final double tickAmount = delay / tickduration;
      final float totalDelta = this.targetZoom - this.zoom;
      this.zoomStep = tickAmount > 0 ? (float) (totalDelta / tickAmount) : totalDelta;
    }
}
}
```
```java
class de.gurkenlabs.litiengine.Game {
public static synchronized void init(String... args) {
    if (initialized) {
      log().log(Level.INFO, "The game has already been initialized.");
      return;
    }

    log.init();
    handleCommandLineArguments(args);

    config().load();
    Locale.setDefault(new Locale(config().client().getCountry(), config().client().getLanguage()));

    gameLoop = new GameLoop("Main Update Loop", config().client().getMaxFps());
    loop().attach(physics());
    loop().attach(world());

    // setup default exception handling for render and update loop
    setUncaughtExceptionHandler(
        new DefaultUncaughtExceptionHandler(config().client().exitOnError()));

    screenManager = new ScreenManager();
    gameWindow = new GameWindow();

    // initialize  the game window
    window().init();
    world.setCamera(new Camera());

    for (GameListener listener : gameListeners) {
      listener.initialized(args);
    }

    if (!isInNoGUIMode()) {
      window().getRenderComponent().onRendered(g -> metrics().render(g));

      graphics()
          .addEntityRenderedListener(
              e -> DebugRenderer.renderEntityDebugInfo(e.getGraphics(), e.getEntity()));

      window().getRenderComponent().onFpsChanged(fps -> metrics().setFramesPerSecond(fps));
      window()
          .setIcons(
              Arrays.asList(
                  Resources.images().get("liti-logo-x16.png"),
                  Resources.images().get("liti-logo-x20.png"),
                  Resources.images().get("liti-logo-x32.png"),
                  Resources.images().get("liti-logo-x48.png")));

      Input.keyboard()
          .onKeyTyped(
              KeyEvent.VK_PRINTSCREEN,
              key -> {
                // don't take a screenshot if a modifier is active
                if (key.getModifiers() != 0) {
                  return;
                }

                window().getRenderComponent().takeScreenshot();
              });
    }

    Runtime.getRuntime().addShutdownHook(new Thread(Game::terminate, "Shutdown"));

    initialized = true;
}
}
```
```java
class de.gurkenlabs.litiengine.entities.Creature {
protected void updateAnimationController() {
    IEntityAnimationController<?> controller = this.createAnimationController();
    this.getControllers().addController(controller);
    if (Game.world().environment() != null && Game.world().environment().isLoaded()) {
      Game.loop().attach(controller);
    }
}@Override
  public float getTickVelocity() {
    // pixels per ms multiplied by the passed ms
    // ensure that entities don't travel too far in case of lag
    return Math.min(Game.loop().getDeltaTime(), GameLoop.TICK_DELTATIME_LAG)
        * 0.001F
        * this.getVelocity().get()
        * Game.loop().getTimeScale();
}
}
```
Depth: 2
```java
class de.gurkenlabs.litiengine.environment.GameWorld {
public void clear() {
    this.unloadEnvironment();
    this.environments.clear();
    this.setCamera(null);
    Game.physics().clear();

    this.environmentListeners.clear();
    this.environmentLoadedListeners.clear();
    this.environmentUnloadedListeners.clear();

    this.listeners.clear();
    this.loadedListeners.clear();
    this.unloadedListeners.clear();
}@Nullable
  public Environment loadEnvironment(IMap map) {
    Environment env = this.getEnvironment(map);
    this.loadEnvironment(env);
    return env;
}@Nullable
  public Environment loadEnvironment(String mapName) {
    Environment env = this.getEnvironment(mapName);
    this.loadEnvironment(env);
    return env;
}
}
```
```java
class de.gurkenlabs.litiengine.GameWindow {
GameWindow() {
    this.hostControl = new JFrame();

    this.resolutionChangedListeners = new CopyOnWriteArrayList<>();

    this.renderCanvas = new RenderComponent(Game.config().graphics().getResolution());
    this.cursor = new MouseCursor();
    if (!Game.isInNoGUIMode()) {
      this.hostControl.setBackground(Color.BLACK);
      this.hostControl.add(this.renderCanvas);

      this.initializeEventListeners();

      this.hostControl.setTitle(Game.info().getTitle());
      this.hostControl.setDefaultCloseOperation(WindowConstants.DO_NOTHING_ON_CLOSE);
      initializeWindowEventListeners(this.hostControl);
    }
}
}
```
```java
class de.gurkenlabs.litiengine.GameTime {
public long sinceEnvironmentLoad() {
    return this.since(this.environmentLoaded);
}public long since(final long tick) {
    return toMilliseconds(Game.loop().getTicks() - tick);
}public long sinceGameStart() {
    return this.toMilliseconds(Game.loop().getTicks());
}
}
```
```java
class de.gurkenlabs.litiengine.abilities.effects.Effect {
protected void cease(final EffectApplication appliance) {
    // 1. cease the effect for all affected entities
    for (final ICombatEntity entity : appliance.getAffectedEntities()) {
      this.cease(entity);
    }

    // 2. apply follow up effects
    this.getFollowUpEffects().forEach(followUp -> followUp.apply(appliance.getImpactArea()));
}protected boolean hasEnded(final EffectApplication appliance) {
    final long effectDuration = Game.time().since(appliance.getAppliedTicks());
    return effectDuration > this.getDuration();
}
}
```
```java
class de.gurkenlabs.litiengine.abilities.effects.EffectApplication {
protected EffectApplication(final List<ICombatEntity> affectedEntities, final Shape impactArea) {
    this.applied = Game.time().now();
    this.affectedEntities = affectedEntities;
    this.impactArea = impactArea;
}
}
```
```java
class de.gurkenlabs.litiengine.entities.CombatEntity {
@Override
  public boolean wasHit(int timeSpan) {
    return Game.time().since(this.lastHit) < timeSpan;
}@Override
  public void hit(final int damage, @Nullable final Ability ability) {
    if (this.isDead()) {
      return;
    }

    if (!this.isIndestructible()) {
      this.getHitPoints().modifyBaseValue(new AttributeModifier<>(Modification.SUBTRACT, damage));
    }

    final EntityHitEvent event = new EntityHitEvent(this, ability, damage, this.isDead());

    for (final CombatEntityListener listener : this.listeners) {
      listener.hit(event);
    }

    for (final CombatEntityHitListener listener : this.hitListeners) {
      listener.hit(event);
    }

    if (this.isDead()) {
      this.fireDeathEvent();
      this.setCollision(false);
    }

    this.lastHit = Game.time().now();
}
}
```
```java
class de.gurkenlabs.litiengine.graphics.ImageEffect {
protected ImageEffect(final int ttl, final String name) {
    this.ttl = ttl;
    this.name = name;
    this.aliveTick = Game.time().now();
}@Override
  public long getAliveTime() {
    return Game.time().since(this.aliveTick);
}
}
```
```java
class de.gurkenlabs.litiengine.abilities.AbilityExecution {
AbilityExecution(final Ability ability) {
    this.appliedEffects = new CopyOnWriteArrayList<>();
    this.ability = ability;
    this.executionTicks = Game.time().now();
    this.impactArea = ability.calculateImpactArea();
    this.castLocation = ability.getExecutor().getCenter();
    Game.loop().attach(this);
}@Override
  public void update() {
    // if there a no effects to apply -> unregister this instance and we're done
    if (this.getAbility().getEffects().isEmpty()
        || this.getAbility().getEffects().size() == this.getAppliedEffects().size()) {
      Game.loop().detach(this);
      return;
    }

    // handle all effects from the ability that were not applied yet
    for (final Effect effect : this.getAbility().getEffects()) {
      // if the ability was not executed yet or the delay of the effect is not
      // yet reached
      if (this.getAppliedEffects().contains(effect)
          || Game.time().since(this.getExecutionTicks()) < effect.getDelay()) {
        continue;
      }

      effect.apply(this.getExecutionImpactArea());
      this.getAppliedEffects().add(effect);
    }
}
}
```
```java
class de.gurkenlabs.litiengine.tweening.TweenEngine {
@Override
  public void update() {
    for (final Tweenable target : this.getTweens().keySet()) {
      for (final Tween tween : this.getTweens().get(target).values()) {
        if (tween.hasStopped()) {
          continue;
        }
        final long elapsed = Game.time().since(tween.getStartTime());
        if (elapsed >= tween.getDuration()) {
          tween.stop();
          continue;
        }
        final float[] currentValues = new float[tween.getTargetValues().length];
        for (int i = 0; i < tween.getTargetValues().length; i++) {
          currentValues[i] =
              tween.getStartValues()[i]
                  + tween.getEquation().compute(elapsed / (float) tween.getDuration())
                      * (tween.getTargetValues()[i] - tween.getStartValues()[i]);
        }
        tween.getTarget().setTweenValues(tween.getType(), currentValues);
      }
    }
}
}
```
```java
class de.gurkenlabs.litiengine.gui.SpeechBubble {
public static SpeechBubble create(
      final IEntity entity, final String text, SpeechBubbleAppearance appearance, Font font) {
    return new SpeechBubble(entity, text, appearance, font);
}public static SpeechBubble create(final IEntity entity, final Font font, final String text) {
    SpeechBubbleAppearance app =
        new SpeechBubbleAppearance(
            DEFAULT_APPEARANCE.getForeColor(),
            DEFAULT_APPEARANCE.getBackgroundColor1(),
            DEFAULT_APPEARANCE.getBorderColor(),
            DEFAULT_APPEARANCE.getPadding());
    return new SpeechBubble(entity, text, app, font);
}public static SpeechBubble create(final IEntity entity, final String text) {
    return new SpeechBubble(entity, text, null, GuiProperties.getDefaultFont());
}@Override
  public void update() {
    if (this.currentText == null) {
      this.hide();
      return;
    }

    this.entityCenter = Game.world().camera().getViewportLocation(this.getEntity().getCenter());

    // old text was displayed long enough
    if (this.lastTextDisplay != 0
        && Game.time().since(this.lastTextDisplay) > this.currentTextDisplayTime) {
      this.currentText = null;
      this.lastTextDisplay = 0;
      return;
    }

    // display new text
    if (this.textIndex < this.currentText.length()
        && Game.time().since(this.lastCharPoll) > LETTER_WRITE_DELAY) {
      this.textIndex++;
      this.lastCharPoll = Game.time().now();
      if (this.typeSound != null) {
        Game.audio().playSound(this.typeSound, this.getEntity());
      }
    }

    // continue displaying currently displayed text
}private SpeechBubble(
      final IEntity entity,
      final String text,
      final Sound typeSound,
      SpeechBubbleAppearance appearance,
      Font font) {
    this(entity, text, appearance, font);
    this.typeSound = typeSound;
}private SpeechBubble(
      final IEntity entity,
      final String text,
      @Nullable SpeechBubbleAppearance appearance,
      @Nullable Font font) {
    if (appearance == null) {
      this.appearance = DEFAULT_APPEARANCE;
    } else {
      this.appearance = appearance;
    }

    final SpeechBubble active = activeSpeechBubbles.get(entity);
    if (active != null) {
      active.hide();
    }
    this.setFont(font);

    this.textBoxWidth = (float) (entity.getWidth() * 4);
    this.entity = entity;

    this.currentText = text;
    this.currentTextDisplayTime = DISPLAYTIME_MIN + text.length() * DISPLAYTIME_PER_LETTER;

    this.lastTextDisplay = Game.time().now();
    this.createBubbleImage();
    entity.getEnvironment().add(this, RenderType.UI);
    Game.loop().attach(this);
    activeSpeechBubbles.put(entity, this);
}
}
```
```java
class de.gurkenlabs.litiengine.gui.TextFieldComponent {
@Override
  public void render(final Graphics2D g) {
    super.render(g);
    g.setFont(this.getFont());
    final FontMetrics fm = g.getFontMetrics();

    if (this.isSelected() && Game.time().since(this.lastToggled) > this.flickerDelay) {
      this.cursorVisible = !this.cursorVisible;
      this.lastToggled = Game.time().now();
    }
    if (this.isSelected() && this.cursorVisible) {
      final Rectangle2D cursor =
          new Rectangle2D.Double(
              this.getX() + this.getTextX() + fm.stringWidth(this.getTextToRender(g)),
              this.getY() + this.getTextY(),
              this.getFont().getSize2D() * 3 / 5,
              this.getFont().getSize2D() * 1 / 5);
      g.setColor(this.getAppearance().getForeColor());
      g.fill(cursor);
    }
}
}
```
```java
class de.gurkenlabs.litiengine.entities.Prop {
public Prop(
      final Point2D location, @Nullable final String spritesheetName, final Material material) {
    super();
    this.rotation = Rotation.NONE;
    this.spritesheetName = spritesheetName;
    this.material = material;
    this.setLocation(location);
    this.updateAnimationController();
}public void setSpritesheetName(@Nullable final String spriteName) {
    this.spritesheetName = spriteName;
    this.updateAnimationController();
}
}
```
```java
class de.gurkenlabs.litiengine.tweening.Tween {
public Tween begin() {
    this.started = Game.time().now();
    this.stopped = false;
    return this;
}
}
```
```java
class de.gurkenlabs.litiengine.graphics.emitters.particles.Particle {
public void update(final Point2D emitterOrigin, final float updateRatio) {
    if (this.aliveTick == 0) {
      this.aliveTick = Game.time().now();
    }

    this.aliveTime = Game.time().since(this.aliveTick);
    if (this.timeToLiveReached()) {
      return;
    }

    if (this.colliding) {
      return;
    }

    if (this.getDeltaWidth() != 0) {
      this.width += this.getDeltaWidth() * updateRatio;
    }

    if (this.getDeltaHeight() != 0) {
      this.height += this.getDeltaHeight() * updateRatio;
    }

    if (this.getDeltaAngle() != 0) {
      this.angle += this.getDeltaAngle() * updateRatio;
    }

    // test for ray cast collision
    final float targetX = this.x + this.getVelocityX() * updateRatio;
    final float targetY = this.y + this.getVelocityY() * updateRatio;

    if (targetX == this.x && targetY == this.y) {
      return;
    }

    if (this.checkForCollision(emitterOrigin, targetX, targetY)) {
      return;
    }

    if (this.getVelocityX() != 0) {
      this.x = targetX;
    }

    if (this.getVelocityY() != 0) {
      this.y = targetY;
    }

    if (this.getAccelerationX() != 0) {
      this.velocityX += this.getAccelerationX() * updateRatio;
    }

    if (this.getAccelerationY() != 0) {
      this.velocityY += this.getAccelerationY() * updateRatio;
    }
}
}
```
```java
class de.gurkenlabs.litiengine.graphics.animation.Animation {
@Override
  public void start() {
    this.playing = true;
    if (this.getKeyframes().isEmpty()) {
      return;
    }

    this.restart();
}@Override
  public void update() {
    // do nothing if the animation is not playing or the current keyframe is not finished
    if (!this.isPlaying()
        || Game.time().since(this.lastFrameUpdate) < this.getCurrentKeyFrame().getDuration()) {
      return;
    }

    // if we are not looping and the last keyframe is finished, we terminate the animation
    if (!this.isLooping() && this.isLastKeyFrame()) {
      this.terminate();
      return;
    }

    // make sure, we stay inside the keyframe list
    final int newFrameIndex =
        (this.getKeyframes().indexOf(this.currentFrame) + 1) % this.getKeyframes().size();
    final KeyFrame previousFrame = this.currentFrame;
    this.currentFrame = this.getKeyframes().get(newFrameIndex);

    for (KeyFrameListener listener : this.listeners) {
      listener.currentFrameChanged(previousFrame, this.currentFrame);
    }

    this.lastFrameUpdate = Game.loop().getTicks();
}
}
```
```java
class de.gurkenlabs.litiengine.graphics.animation.AnimationController {
@Override
  public void update() {
    for (final Animation animation : this.getAll()) {
      animation.update();
    }

    if (this.getCurrent() != null && this.getCurrent().isPaused()) {
      return;
    }

    final boolean playbackFinished = this.getCurrent() != null && !this.getCurrent().isPlaying();
    if (playbackFinished) {
      for (final AnimationListener listener : this.listeners) {
        listener.finished(this.getCurrent());
      }
    }

    if (this.getCurrent() == null || playbackFinished) {
      if (this.getDefault() != null) {
        this.play(this.getDefault().getName());
      } else {
        this.currentAnimation = null;
      }
    }
}
}
```
```java
class de.gurkenlabs.litiengine.graphics.RenderComponent {
private void handleFade() {
    if (this.fadeOutStart != -1) {
      final long timePassed = Game.time().since(this.fadeOutStart);
      this.currentAlpha = MathUtilities.clamp(1 - timePassed / (float) this.fadeOutTime, 0, 1);
      if (this.currentAlpha == 0f) {
        this.fadeOutStart = -1;
        this.fadeOutTime = -1;
      }

      return;
    }

    if (this.fadeInStart != -1) {
      final long timePassed = Game.time().since(this.fadeInStart);
      this.currentAlpha = MathUtilities.clamp(timePassed / (float) this.fadeInTime, 0, 1);
      if (this.currentAlpha == 1f) {
        this.fadeInStart = -1;
        this.fadeInTime = -1;
        this.currentAlpha = Float.NaN;
      }
    }
}public void fadeOut(final int ms) {
    this.fadeInStart = -1;
    this.fadeInTime = -1;
    this.fadeOutStart = Game.time().now();
    this.fadeOutTime = ms;
}public void fadeIn(final int ms) {
    this.fadeOutStart = -1;
    this.fadeOutTime = -1;
    this.fadeInStart = Game.time().now();
    this.fadeInTime = ms;
}
}
```
```java
class de.gurkenlabs.litiengine.entities.Trigger {
private boolean activate(final IEntity activator, final int tar) {
    if (!this.isLoaded()
        || this.isOneTimeTrigger && this.isActivated
        || this.getActivationType() == TriggerActivation.COLLISION
            && activator != null
            && this.collisionActivated.contains(activator)) {
      return false;
    }

    if (this.getCooldown() > 0 && Game.time().since(this.lastActivation) < this.getCooldown()) {
      return false;
    }

    List<Integer> triggerTargets = this.getTargets(tar);

    final TriggerEvent te = new TriggerEvent(this, activator, triggerTargets);

    if (!this.checkActivationPredicates(te)) {
      return false;
    }

    this.isActivated = true;
    if (activator != null) {
      this.collisionActivated.add(activator);
    }

    // if we actually have a trigger target, we send the message to the target
    for (final int target : triggerTargets) {
      final IEntity entity = this.getEnvironment().get(target);
      if (entity == null) {
        log.log(
            Level.WARNING,
            "trigger [{0}] was activated, but the trigger target [{1}] could not be found on the environment",
            new Object[] {this, target});
        continue;
      }

      entity.sendMessage(this, this.message);
    }

    // also send the trigger event to all registered consumers
    for (final TriggerActivatedListener listener : this.activatedListeners) {
      listener.activated(te);
    }

    if (this.isOneTimeTrigger) {
      this.getEnvironment().remove(this);
    }

    this.lastActivation = Game.time().now();
    return true;
}
}
```
```java
class de.gurkenlabs.litiengine.graphics.Camera {
private boolean isShakeEffectActive() {
    return this.getShakeTick() != 0
        && Game.time().since(this.getShakeTick()) < this.getShakeDuration();
}@Override
  public void update() {
    if (Game.world().camera() != null && !Game.world().camera().equals(this)) {
      return;
    }

    if (this.targetZoom > 0) {
      if (Game.time().since(this.zoomTick) >= this.zoomDelay) {
        this.zoom = this.targetZoom;
        this.targetZoom = 0;
        this.zoomDelay = 0;
        this.zoomTick = 0;
        this.zoomStep = 0;
      } else {
        this.zoom += this.zoomStep;
      }

      final ZoomChangedEvent event = new ZoomChangedEvent(this, this.getZoom());
      for (final ZoomChangedListener listener : this.zoomListeners) {
        listener.zoomChanged(event);
      }
    }

    if (this.panTime > 0) {
      if (--this.panTime <= 0) {
        this.setFocus(this.targetFocus);
        this.targetFocus = null;
      } else {
        double diff = this.panTime / (this.panTime + 1.0);
        this.focus =
            new Point2D.Double(
                this.focus.getX() * diff + this.targetFocus.getX() * (1.0 - diff),
                this.focus.getY() * diff + this.targetFocus.getY() * (1.0 - diff));
      }
    }

    if (!this.isShakeEffectActive()) {
      this.shakeOffsetX = 0;
      this.shakeOffsetY = 0;
      return;
    }

    if (Game.time().since(this.lastShake) > this.shakeDelay) {
      this.shakeOffsetX = this.getShakeIntensity() * ThreadLocalRandom.current().nextGaussian();
      this.shakeOffsetY = this.getShakeIntensity() * ThreadLocalRandom.current().nextGaussian();
      this.lastShake = Game.time().now();
    }
}@Override
  public void setZoom(final float targetZoom, final int delay) {
    if (delay == 0) {

      this.zoom = targetZoom;
      this.targetZoom = 0;
      this.zoomDelay = 0;
      this.zoomTick = 0;
      this.zoomStep = 0;

      final ZoomChangedEvent event = new ZoomChangedEvent(this, targetZoom);
      for (final ZoomChangedListener listener : this.zoomListeners) {
        listener.zoomChanged(event);
      }
    } else {
      this.zoomTick = Game.time().now();
      this.targetZoom = targetZoom;
      this.zoomDelay = delay;

      final double tickduration = 1000 / (double) Game.loop().getTickRate();
      final double tickAmount = delay / tickduration;
      final float totalDelta = this.targetZoom - this.zoom;
      this.zoomStep = tickAmount > 0 ? (float) (totalDelta / tickAmount) : totalDelta;
    }
}@Override
  public void shake(final double intensity, final int delay, final int shakeDuration) {
    this.shakeTick = Game.time().now();
    this.shakeDelay = delay;
    this.shakeIntensity = intensity;
    this.shakeDuration = shakeDuration;
}
}
```
```java
class de.gurkenlabs.litiengine.entities.Creature {
public void setSpritesheetName(String spritesheetName) {
    if (this.spritesheetName != null && this.spritesheetName.equals(spritesheetName)) {
      return;
    }

    this.spritesheetName = spritesheetName;
    this.updateAnimationController();
}public boolean isIdle() {
    return Game.time().since(this.lastMoved) > IDLE_DELAY;
}@Override
  public void setLocation(final Point2D position) {
    if (this.isDead() || position == null) {
      return;
    }

    final Point2D oldLocation = this.getLocation();
    super.setLocation(position);

    if (Game.hasStarted() && this.isLoaded()) {
      this.lastMoved = Game.time().now();
      this.fireMovedEvent(
          new EntityMovedEvent(
              this, this.getX() - oldLocation.getX(), this.getY() - oldLocation.getY()));
    }
}
}
```
```java
class de.gurkenlabs.litiengine.gui.screens.ScreenManager {
public void display(final String screenName) {
    if (this.current() != null && this.current().getName().equalsIgnoreCase(screenName)) {
      log.log(
          Level.INFO,
          "Skipping displaying of screen {0} because it is already the current screen.",
          screenName);
      return;
    }

    if (this.screens.stream()
        .noneMatch(element -> element.getName().equalsIgnoreCase(screenName))) {
      log.log(
          Level.WARNING,
          "Could not display the screen {0} because there is no screen with the specified name.",
          screenName);
      return;
    }

    Screen screen = this.get(screenName);
    if (screen == null) {
      return;
    }

    this.display(screen);
}public void add(final Screen screen) {
    screen.setWidth(Game.window().getWidth());
    screen.setHeight(Game.window().getHeight());
    this.screens.add(screen);

    if (this.current() == null) {
      this.display(screen);
    }
}public void remove(Screen screen) {
    this.screens.remove(screen);
    if (this.current() == screen) {
      if (!this.screens.isEmpty()) {
        this.display(this.screens.get(0));
      } else {
        this.display((Screen) null);
      }
    }
}public void display(@Nullable final Screen screen) {
    if (Game.hasStarted() && Game.time().since(this.lastScreenChange) < this.getChangeCooldown()) {
      log.log(
          Level.INFO,
          "Skipping displaying of screen {0} because screen changing is currently on cooldown.",
          screen != null ? screen.getName() : "");
      return;
    }

    final Screen previous = this.current();
    if (previous != null) {
      previous.suspend();
    }

    if (screen != null && !this.screens.contains(screen)) {
      this.screens.add(screen);
    }

    this.currentScreen = screen;
    if (!Game.isInNoGUIMode() && this.current() != null) {
      this.current().prepare();
    }

    this.lastScreenChange = Game.loop().getTicks();

    final ScreenChangedEvent event = new ScreenChangedEvent(this.current(), previous);
    for (final ScreenChangedListener listener : this.screenChangedListeners) {
      listener.changed(event);
    }
}
}
```
```java
class de.gurkenlabs.litiengine.abilities.Ability {
public boolean isOnCooldown() {
    return (this.getCurrentExecution() != null
        && this.getCurrentExecution().getExecutionTicks() > 0
        && Game.time().since(this.getCurrentExecution().getExecutionTicks())
            < this.getAttributes().cooldown().get());
}public boolean isActive() {
    return this.getCurrentExecution() != null
        && Game.time().since(this.getCurrentExecution().getExecutionTicks())
            < this.getAttributes().duration().get();
}@Nullable
  public AbilityExecution cast() {
    if (!this.canCast()) {
      return null;
    }
    this.currentExecution = new AbilityExecution(this);

    for (final AbilityCastListener listener : this.abilityCastListeners) {
      listener.abilityCast(this.currentExecution);
    }

    return this.getCurrentExecution();
}public float getRemainingCooldownInSeconds() {
    if (this.getCurrentExecution() == null
        || this.getExecutor() == null
        || this.getExecutor().isDead()) {
      return 0;
    }

    // calculate cooldown in seconds
    return (float)
        (!this.canCast()
            ? (this.getAttributes().cooldown().get()
                    - Game.time().since(this.getCurrentExecution().getExecutionTicks()))
                * 0.001
            : 0);
}
}
```
```java
class de.gurkenlabs.litiengine.entities.EntityHitEvent {
EntityHitEvent(
      final ICombatEntity hitEntity,
      @Nullable final Ability ability,
      final int damage,
      final boolean kill) {
    super(hitEntity);
    this.executor = ability != null ? ability.getExecutor() : null;
    this.hitEntity = hitEntity;
    this.ability = ability;
    this.damage = damage;
    this.kill = kill;
    this.time = Game.time().now();
}
}
```
```java
class de.gurkenlabs.litiengine.graphics.emitters.Emitter {
public void delete() {
    this.deactivate();
    if (Game.world().environment() != null) {
      Game.world().environment().remove(this);
    }
}public void activate() {
    if (this.activated) {
      return;
    }

    this.activated = true;
    this.activationTick = Game.time().now();
    Game.loop().attach(this);
}@Override
  public void update() {
    if (this.isPaused()) {
      return;
    }

    // clear particles if the effect time to life is reached
    if (this.isFinished()) {
      for (EmitterFinishedListener listener : this.finishedListeners) {
        listener.finished(this);
      }

      this.delete();
      return;
    }

    final float updateRatio = (float) this.data().getUpdateRate() / Game.loop().getTickRate();
    for (final Particle p : this.getParticles().stream().collect(Collectors.toList())) {
      if (this.particleCanBeRemoved(p)) {
        // remove dead particles
        this.particles.remove(p);
        continue;
      }

      p.update(this.getOrigin(), updateRatio);
    }

    this.aliveTime = Game.time().since(this.activationTick);
    if ((this.data().getSpawnRate() == 0
        || Game.time().since(this.lastSpawn) >= this.data().getSpawnRate())) {
      this.lastSpawn = Game.time().now();
      this.spawnParticle();
    }
}
}
```
```java
class de.gurkenlabs.litiengine.GameLoop {
@Override
  public int perform(int delay, Runnable action) {
    final long d = Game.time().toTicks(delay);

    TimedAction a = new TimedAction(this.getTicks() + d, action);
    this.actions.add(a);

    return a.getId();
}
}
```
```java
class de.gurkenlabs.litiengine.environment.EntitySpawner {
protected boolean shouldSpawn() {
    return this.lastSpawnWave == 0
        || Game.time().since(this.lastSpawnWave) >= this.getSpawnInterval();
}@Override
  public void update() {
    if (!this.shouldSpawn()) {
      return;
    }

    this.spawnNewEntities();
    this.lastSpawnWave = Game.time().now();
}
}
```
```java
class de.gurkenlabs.litiengine.graphics.FreeFlightCamera {
@Override
  public void update() {
    this.handleFreeFlightCamera();
}public FreeFlightCamera(double x, double y) {
    this(new Point2D.Double(x, y));
}
}
```
```java
class de.gurkenlabs.litiengine.environment.Environment {
public void unload() {
    if (!this.loaded) {
      return;
    }

    // unregister all updatable entities from the current environment
    for (final IEntity entity : this.allEntities.values()) {
      this.unload(entity);
    }

    this.loaded = false;
    this.fireEvent(l -> l.unloaded(this));
}private static void loadUpdatableOrEmitterEntity(IEntity entity) {
    if (entity instanceof Emitter) {
      final Emitter emitter = (Emitter) entity;
      if (emitter.isActivateOnInit()) {
        emitter.activate();
      }
    } else if (entity instanceof IUpdateable) {
      Game.loop().attach((IUpdateable) entity);
    }
}public void clear() {
    Game.physics().clear();

    this.combatEntities.clear();
    this.mobileEntities.clear();
    this.gravityForces.clear();
    this.layerEntities.clear();
    this.entitiesByTag.clear();
    this.allEntities.clear();

    for (RenderType renderType : RenderType.values()) {
      this.miscEntities.get(renderType).clear();
      this.renderListeners.get(renderType).clear();
      this.renderables.get(renderType).clear();
    }

    dispose(this.allEntities.values());
    dispose(this.triggers);
    this.emitters.clear();
    this.colliders.clear();
    this.props.clear();
    this.creatures.clear();
    this.staticShadows.clear();
    this.combatEntities.clear();
    this.mobileEntities.clear();
    this.lightSources.clear();
    this.spawnPoints.clear();
    this.soundSources.clear();
    this.mapAreas.clear();
    this.triggers.clear();

    this.ambientLight = null;
    this.staticShadowLayer = null;

    for (Map<Integer, IEntity> type : this.miscEntities.values()) {
      type.clear();
    }

    this.initialized = false;

    this.fireEvent(l -> l.cleared(this));
}private void load(final IEntity entity) {
    // an entity can only exist on one environment at a time, so remove it from the current one
    if (entity.getEnvironment() != null) {
      entity.getEnvironment().remove(entity);
    }

    // 1. add to physics engine
    loadPhysicsEntity(entity);

    // 2. register for update or activate
    loadUpdatableOrEmitterEntity(entity);

    // 3. if a gravity is defined, add a gravity force to the entity
    if (entity instanceof IMobileEntity && this.getGravity() != 0) {
      this.addGravityForce((IMobileEntity) entity);
    }

    // 4. attach all controllers
    entity.attachControllers();

    if (this.loaded && (entity instanceof LightSource || entity instanceof StaticShadow)) {
      this.updateLighting(entity);
    }

    entity.loaded(this);
}private void unload(final IEntity entity) {
    // 1. remove from physics engine
    if (entity instanceof ICollisionEntity) {
      Game.physics().remove((ICollisionEntity) entity);
    }

    // 2. unregister from update
    if (entity instanceof IUpdateable) {
      Game.loop().detach((IUpdateable) entity);
    }

    if (entity instanceof IMobileEntity) {
      this.removeGravity((IMobileEntity) entity);
    }

    // 3. detach all controllers
    entity.detachControllers();

    if (entity instanceof Emitter) {
      Emitter em = (Emitter) entity;
      em.deactivate();
    }

    if (this.loaded && (entity instanceof LightSource || entity instanceof StaticShadow)) {
      this.updateLighting(entity);
    }

    entity.removed(this);
}public void remove(final IEntity entity) {
    if (entity == null) {
      return;
    }

    this.allEntities.remove(entity.getMapId());
    Iterator<List<IEntity>> iter = this.layerEntities.values().iterator();
    while (iter.hasNext()) {
      List<IEntity> layer = iter.next();
      if (layer.remove(entity) && layer.isEmpty()) {
        iter.remove();
      }
    }
    if (this.miscEntities.get(entity.getRenderType()) != null) {
      this.miscEntities.get(entity.getRenderType()).values().remove(entity);
    }

    for (String tag : entity.getTags()) {
      if (this.getEntitiesByTag().containsKey(tag)) {
        this.getEntitiesByTag().get(tag).remove(entity);

        if (this.getEntitiesByTag().get(tag).isEmpty()) {
          this.getEntitiesByTag().remove(tag);
        }
      }
    }

    if (entity instanceof Emitter) {
      Emitter emitter = (Emitter) entity;
      this.removeEmitter(emitter);
    }

    if (entity instanceof MapArea) {
      this.mapAreas.remove(entity);
    }

    if (entity instanceof Prop) {
      this.props.remove(entity);
    }

    if (entity instanceof Creature) {
      this.creatures.remove(entity);
    }

    if (entity instanceof CollisionBox) {
      this.colliders.remove(entity);
      this.staticShadows.removeIf(x -> x.getOrigin() != null && x.getOrigin().equals(entity));
    }

    if (entity instanceof LightSource) {
      this.lightSources.remove(entity);
      this.updateLighting(entity);
    }

    if (entity instanceof Trigger) {
      this.triggers.remove(entity);
    }

    if (entity instanceof Spawnpoint) {
      this.spawnPoints.remove(entity);
    }
    if (entity instanceof SoundSource) {
      this.soundSources.remove(entity);
    }

    if (entity instanceof StaticShadow) {
      this.staticShadows.remove(entity);
      this.updateLighting(entity);
    }

    if (entity instanceof IMobileEntity) {
      this.mobileEntities.values().remove(entity);
    }

    if (entity instanceof ICombatEntity) {
      this.combatEntities.values().remove(entity);
    }

    this.unload(entity);

    this.fireEntityEvent(l -> l.entityRemoved(entity));
}
}
```
```java
class de.gurkenlabs.litiengine.physics.MovementController {
@Override
  public void update() {
    this.handleForces();
    this.handleMovement();
}
}
```
```java
class de.gurkenlabs.litiengine.Game {
static synchronized void terminate() {
    if (!initialized) {
      return;
    }

    hasStarted = false;
    initialized = false;

    config().save();
    gameLoop.terminate();
    tweenEngine.terminate();
    soundEngine.terminate();

    world().clear();

    for (final GameListener listener : gameListeners) {
      try {
        listener.terminated();
      } catch (Exception e) {
        log().log(Level.WARNING, "game listener threw an exception during shutdown", e);
      }
    }

    gameLoop = null;
    screenManager = null;
    gameWindow = null;
}public static synchronized void start() {
    if (!initialized) {
      throw new IllegalStateException(
          "The game cannot be started without being first initialized. Call Game.init(...) before Game.start().");
    }

    gameLoop.start();
    tweenEngine.start();
    soundEngine.start();

    for (final GameListener listener : gameListeners) {
      listener.started();
    }

    hasStarted = true;
}public static synchronized void init(String... args) {
    if (initialized) {
      log().log(Level.INFO, "The game has already been initialized.");
      return;
    }

    log.init();
    handleCommandLineArguments(args);

    config().load();
    Locale.setDefault(new Locale(config().client().getCountry(), config().client().getLanguage()));

    gameLoop = new GameLoop("Main Update Loop", config().client().getMaxFps());
    loop().attach(physics());
    loop().attach(world());

    // setup default exception handling for render and update loop
    setUncaughtExceptionHandler(
        new DefaultUncaughtExceptionHandler(config().client().exitOnError()));

    screenManager = new ScreenManager();
    gameWindow = new GameWindow();

    // initialize  the game window
    window().init();
    world.setCamera(new Camera());

    for (GameListener listener : gameListeners) {
      listener.initialized(args);
    }

    if (!isInNoGUIMode()) {
      window().getRenderComponent().onRendered(g -> metrics().render(g));

      graphics()
          .addEntityRenderedListener(
              e -> DebugRenderer.renderEntityDebugInfo(e.getGraphics(), e.getEntity()));

      window().getRenderComponent().onFpsChanged(fps -> metrics().setFramesPerSecond(fps));
      window()
          .setIcons(
              Arrays.asList(
                  Resources.images().get("liti-logo-x16.png"),
                  Resources.images().get("liti-logo-x20.png"),
                  Resources.images().get("liti-logo-x32.png"),
                  Resources.images().get("liti-logo-x48.png")));

      Input.keyboard()
          .onKeyTyped(
              KeyEvent.VK_PRINTSCREEN,
              key -> {
                // don't take a screenshot if a modifier is active
                if (key.getModifiers() != 0) {
                  return;
                }

                window().getRenderComponent().takeScreenshot();
              });
    }

    Runtime.getRuntime().addShutdownHook(new Thread(Game::terminate, "Shutdown"));

    initialized = true;
}
}
```


Response Format:
Provide the answer in **XML format** as follows:

#### If the method **cannot** return `null` at the specific call site:
```xml
<response>
  <reason><![CDATA[EXPLAIN WHY THE INVOCATION Game.loop() RESULT CANNOT BE NULL.]]></reason>
  <value>NO</value>
</response>

#### If the method can return null at the specific call site:
<response>
  <reason><![CDATA[EXPLAIN WHY THE INVOCATION Game.loop() RESULT CAN BE NULL.]]></reason>
  <value>YES</value>
</response>

#### If you are unsure or If there are any methods that directly or indirectly affect the return value and are not fully disclosed, request their declarations first, in the following format:
<response>
  <reason><![CDATA[EXPLAIN WHY THIS METHOD DECLARATION IS NECESSARY AND WHY YOU CANNOT MAKE A CONFIDENT DECISION WITHOUT IT]]></reason>
  <success>false</success>
  <methods>
    <method>methodName</method>
  </methods>
</response>

Additional Notes:
Be precise in your reasoning.
If a method’s return value depends on another method not provided, request its declaration before making a conclusion.
If the method can return null in this case but not in others, explain why it happens specifically for this call.

---ChatGPT.sendRequestToOpenAI---
Retrieving response from cache
---Response.<init>---
Creating Response:
```xml
<response>
  <reason><![CDATA[The method `Game.loop()` returns the static field `gameLoop`, which is initialized in the `Game.init(String... args)` method. In this method, a new `GameLoop` object is instantiated and assigned to `gameLoop`. Since `init()` must be called before `start()`, which is implied by the requirement of initializing the game, the `gameLoop` is guaranteed to be non-null during the lifetime of the game execution where `Game.loop()` is called. The absence of any code that could set `gameLoop` to null after its initialization ensures that `Game.loop()` cannot return null.]]></reason>
  <value>NO</value>
</response>
```
---Response.<init>---
Response created:
Disagreement: The method `Game.loop()` returns the static field `gameLoop`, which is initialized in the `Game.init(String... args)` method. In this method, a new `GameLoop` object is instantiated and assigned to `gameLoop`. Since `init()` must be called before `start()`, which is implied by the requirement of initializing the game, the `gameLoop` is guaranteed to be non-null during the lifetime of the game execution where `Game.loop()` is called. The absence of any code that could set `gameLoop` to null after its initialization ensures that `Game.loop()` cannot return null.
---AdvancedNullAwayCodeFix.resolveMethodDereferenceError---
Method is not returning nullable on call site. Injecting suppression annotation.
---AdvancedNullAwayCodeFix.constructCastToNonnullChange---
Constructing cast to nonnull change for reason: The method `Game.loop()` returns the static field `gameLoop`, which is initialized in the `Game.init(String... args)` method. In this method, a new `GameLoop` object is instantiated and assigned to `gameLoop`. Since `init()` must be called before `start()`, which is implied by the requirement of initializing the game, the `gameLoop` is guaranteed to be non-null during the lifetime of the game execution where `Game.loop()` is called. The absence of any code that could set `gameLoop` to null after its initialization ensures that `Game.loop()` cannot return null.
---ChatGPT.ask---
Asking ChatGPT:
For the reason you mentioned earlier:

"The method `Game.loop()` returns the static field `gameLoop`, which is initialized in the `Game.init(String... args)` method. In this method, a new `GameLoop` object is instantiated and assigned to `gameLoop`. Since `init()` must be called before `start()`, which is implied by the requirement of initializing the game, the `gameLoop` is guaranteed to be non-null during the lifetime of the game execution where `Game.loop()` is called. The absence of any code that could set `gameLoop` to null after its initialization ensures that `Game.loop()` cannot return null."

in the method below, the expression Game.loop() is not nullable at the point it is used.

```java
@Override
  public void render(final Graphics2D g) {
    this.updateMetrics();

    if (!Game.config().client().showGameMetrics()) {
      return;
    }

    this.currentOffsetY = 0;

    g.setColor(this.renderColor);

    // render client metrics
    this.drawTitle(g, "[client]");
    this.drawMetric(g, "fps       : " + this.getFramesPerSecond());
    this.drawMetric(g, "max fps   : " + this.maxFramesPerSecond);
    this.drawMetric(g, "updatables: " + Game.loop().getUpdatableCount());

    // render jvm metrics if debug is enabled
    if (Game.config().debug().isDebugEnabled()) {
      this.drawTitle(g, "[jvm]");
      this.drawMetric(g, "java      : " + this.javaVersion);
      this.drawMetric(g, "memory    : " + String.format("%-5.5s", this.usedMemory) + " MB");
      this.drawMetric(g, "threads   : " + Thread.activeCount());
    }

    // render rendering metrics
    if (!this.renderMetrics.isEmpty()) {
      this.drawTitle(g, "[update]");

      for (RenderMetrics metric : this.renderMetrics) {
        this.drawMetric(g, metric.toString());
      }

      this.renderMetrics.clear();
    }
}
```
Please Summarize the reason in max 5 words and rewrite the method so that at the line "    this.drawMetric(g, "updatables: " + Game.loop().getUpdatableCount());", at the occurrence of: "Game.loop()" is replaced with `NullabilityUtil.castToNonnull(Game.loop(), summary of reason)`
Replace "REASON" with the exact reason summary I provide to you (maximum 5 words), not with a generic explanation like "checked to be nonnull".
see the example below, for expression `foo.getBar()`, to wrap it with `NullabilityUtil.castToNonnull(foo.getBar(), "reason")`.

```java
public t(){
    String l = foo.getBar();
}
```

will be:
```java
public t(){
    String l = NullabilityUtil.castToNonnull(foo.getBar(), "checked to be nonnull");
}
```

### Instructions:

Do not import any additional classes.

Do not add Java comments.

Only modify relevant lines as required.

Return only the modified method wrapped in the XML format shown below.

Place the Java code inside the <code> tag using a CDATA block with ```java formatting.

Just give me the fixed code snippet in XML format in <response> tag like the example below. I will apply the fix to my codebase. Do not import any additional libraries or classes or add java comments. If you can provide the fixed code snippet, please provide it in the following format and place the code snippet in the <code> tag within ```java block.
<response>
  <success>true</success>
  <code><![CDATA[
  ```java
  Your fixed code snippet here
  ```
    ]]>
  </code>
</response>

---ChatGPT.sendRequestToOpenAI---
Retrieving response from cache
---Response.<init>---
Creating Response:
<response>
  <success>true</success>
  <code><![CDATA[
  ```java
@Override
  public void render(final Graphics2D g) {
    this.updateMetrics();

    if (!Game.config().client().showGameMetrics()) {
      return;
    }

    this.currentOffsetY = 0;

    g.setColor(this.renderColor);

    // render client metrics
    this.drawTitle(g, "[client]");
    this.drawMetric(g, "fps       : " + this.getFramesPerSecond());
    this.drawMetric(g, "max fps   : " + this.maxFramesPerSecond);
    this.drawMetric(g, "updatables: " + NullabilityUtil.castToNonnull(Game.loop(), "not nullable after init").getUpdatableCount());

    // render jvm metrics if debug is enabled
    if (Game.config().debug().isDebugEnabled()) {
      this.drawTitle(g, "[jvm]");
      this.drawMetric(g, "java      : " + this.javaVersion);
      this.drawMetric(g, "memory    : " + String.format("%-5.5s", this.usedMemory) + " MB");
      this.drawMetric(g, "threads   : " + Thread.activeCount());
    }

    // render rendering metrics
    if (!this.renderMetrics.isEmpty()) {
      this.drawTitle(g, "[update]");

      for (RenderMetrics metric : this.renderMetrics) {
        this.drawMetric(g, metric.toString());
      }

      this.renderMetrics.clear();
    }
}
  ```
    ]]>
  </code>
</response>
---Response.<init>---
Response created:
@Override
  public void render(final Graphics2D g) {
    this.updateMetrics();

    if (!Game.config().client().showGameMetrics()) {
      return;
    }

    this.currentOffsetY = 0;

    g.setColor(this.renderColor);

    // render client metrics
    this.drawTitle(g, "[client]");
    this.drawMetric(g, "fps       : " + this.getFramesPerSecond());
    this.drawMetric(g, "max fps   : " + this.maxFramesPerSecond);
    this.drawMetric(g, "updatables: " + NullabilityUtil.castToNonnull(Game.loop(), "not nullable after init").getUpdatableCount());

    // render jvm metrics if debug is enabled
    if (Game.config().debug().isDebugEnabled()) {
      this.drawTitle(g, "[jvm]");
      this.drawMetric(g, "java      : " + this.javaVersion);
      this.drawMetric(g, "memory    : " + String.format("%-5.5s", this.usedMemory) + " MB");
      this.drawMetric(g, "threads   : " + Thread.activeCount());
    }

    // render rendering metrics
    if (!this.renderMetrics.isEmpty()) {
      this.drawTitle(g, "[update]");

      for (RenderMetrics metric : this.renderMetrics) {
        this.drawMetric(g, metric.toString());
      }

      this.renderMetrics.clear();
    }
}
---ChatGPT.fixDereferenceByAddingCastToNonnull---
Fixing the error by adding castToNonnull
---AdvancedNullAwayCodeFix.fixTriggeredErrorsForLocation---
Resolving unresolvable error for triggered error: Type='DEREFERENCE_NULLABLE', message='dereferenced expression Game.loop() is @Nullable'
/home/nima/Developer/nullness-benchmarks/litiengine/src/de/gurkenlabs/litiengine/abilities/AbilityExecution.java:24
    Game.loop().attach(this);
---AdvancedNullAwayCodeFix.fix---
Fixing error: Type='DEREFERENCE_NULLABLE', message='dereferenced expression Game.loop() is @Nullable'
/home/nima/Developer/nullness-benchmarks/litiengine/src/de/gurkenlabs/litiengine/abilities/AbilityExecution.java:24
    Game.loop().attach(this);
---AdvancedNullAwayCodeFix.resolveDereferenceError---
Resolving dereference error: Type='DEREFERENCE_NULLABLE', message='dereferenced expression Game.loop() is @Nullable'
/home/nima/Developer/nullness-benchmarks/litiengine/src/de/gurkenlabs/litiengine/abilities/AbilityExecution.java:24
    Game.loop().attach(this);
---AdvancedNullAwayCodeFix.resolveDereferenceError---
Checking nullability possibility at error point
---ChatGPT.checkNullabilityPossibilityAtErrorPoint---
Asking if the expression can be null at error point point
---ChatGPT.ask---
Asking ChatGPT:
In the method below, is there a possibility that the expression "Game.loop()" at line "Game.loop().attach(this);" is null?
AbilityExecution(final Ability ability) {
    this.appliedEffects = new CopyOnWriteArrayList<>();
    this.ability = ability;
    this.executionTicks = Game.time().now();
    this.impactArea = ability.calculateImpactArea();
    this.castLocation = ability.getExecutor().getCenter();
    Game.loop().attach(this);
}
Give a single-word answer in XML format. If it is possible for the expression to be null, respond with:
```xml
<response>
    <reason><![CDATA[YOUR REASON]]></reason>
    <value>YES</value>
</response>
```
If it is not possible for the expression to be null, respond with:
```xml
<response>
    <reason><![CDATA[YOUR REASON]]></reason>
    <value>NO</value>
</response>
```
If you are unsure or need more information, respond with where you can ask for more details or what specific information you need.

If additional information is required, list each request inside a `<request>` tag. If no additional information is needed, omit the `<requests>` section.

Respond with:
```xml
<response>
    <reason><![CDATA[YOUR REASON]]></reason>
    <value>UNKNOWN</value>
    <!-- Include <requests> only if additional information is needed -->
    <requests>
        <request><![CDATA[YOUR REQUEST 1]]></request>
        <request><![CDATA[YOUR REQUEST 2]]></request>
    </requests>
</response>
```
---ChatGPT.sendRequestToOpenAI---
Retrieving response from cache
---Response.<init>---
Creating Response:
```xml
<response>
    <reason><![CDATA[The nullability of Game.loop() depends on the context and implementation of the Game class which is not provided. If Game.loop() is guaranteed to be initialized before AbilityExecution is called, then it's not null; otherwise, it could be null.]]></reason>
    <value>UNKNOWN</value>
    <requests>
        <request><![CDATA[Provide the implementation of the Game class or details about how Game.loop() is initialized.]]></request>
    </requests>
</response>
```
---Response.<init>---
Response created:
Unknown: The nullability of Game.loop() depends on the context and implementation of the Game class which is not provided. If Game.loop() is guaranteed to be initialized before AbilityExecution is called, then it's not null; otherwise, it could be null.
---AdvancedNullAwayCodeFix.resolveMethodDereferenceError---
Resolving method dereference error.
---AdvancedNullAwayCodeFix.resolveMethodDereferenceError---
Method is in annotated package. Checking if the method is returning nullable.
---AdvancedNullAwayCodeFix.investigateMethodReturnNullability---
Checking if the method is returning nullable.
---ChatGPT.checkIfMethodIsReturningNullable---
Asking if the method is returning nullable: loop()
---ChatGPT.ask---
Asking ChatGPT:
In the method below, is there a possibility that the method returns null based only on its body? Consider the following points:

- The method may have multiple return paths; consider all return statements.
- If the method calls another method, do not assume its return value unless its full declaration is provided. Request its declaration if needed.
- The method may throw an exception instead of returning null. An exception path should not be considered a null return.
- Ensure you request the declarations of any methods whose return values directly or indirectly impact this method’s return value before making a conclusion.
- Carefully analyze all conditions and prior operations that may guarantee a non-null return value.

@Nullable public static IGameLoop loop() {
    return gameLoop;
}

Here are the method definitions in addition to the method inquired:

Depth: 0
```java
class de.gurkenlabs.litiengine.Game {
@Nullable public static IGameLoop loop() {
    return gameLoop;
}
}
```


Response Format:
Provide the answer in **XML format** as follows:

#### If the method **cannot** return `null`:
```xml
<response>
  <reason><![CDATA[EXPLAIN WHY THE METHOD CANNOT RETURN NULL]]></reason>
  <value>NO</value>
</response>
```

#### If the method can return null:
```xml
<response>
  <reason><![CDATA[EXPLAIN WHY THE METHOD CAN RETURN NULL]]></reason>
  <value>YES</value>
</response>
```

#### If you are unsure or need more information, respond with where you can ask for more details or what specific information you need.

#### If you are unsure or If there are any methods that directly or indirectly affect the return value and are not fully disclosed, request their declarations first, in the following format:
<response>
  <reason><![CDATA[YOUR REASON]]></reason>
  <value>UNKNOWN</value>
  <methods>
    <method>methodName</method>
  </methods>
</response>

If additional information is required other than method declaration, list each request inside a `<request>` tag. If no additional information is needed, omit the `<requests>` section.

Respond with:
```xml
<response>
    <reason><![CDATA[YOUR REASON]]></reason>
    <value>UNKNOWN</value>
    <!-- Include <requests> only if additional information is needed -->
    <requests>
        <request><![CDATA[YOUR REQUEST 1]]></request>
        <request><![CDATA[YOUR REQUEST 2]]></request>
    </requests>
</response>
```

Additional Notes:
Be precise in your reasoning.
If a method’s return value depends on another method not provided, request its declaration before making a conclusion.
If the method can return null in some cases but not others, explain under what conditions it can happen.

---ChatGPT.sendRequestToOpenAI---
Retrieving response from cache
---Response.<init>---
Creating Response:
```xml
<response>
  <reason><![CDATA[The method `loop` returns the variable `gameLoop`. Without the initialization or assignment details of `gameLoop`, it's unclear whether it can be null. The possibility of `gameLoop` being uninitialized or set to null elsewhere in the program means `loop` could potentially return null. Further information on `gameLoop` is required.]]></reason>
  <value>UNKNOWN</value>
  <requests>
    <request><![CDATA[Please provide the declaration and initialization of the variable `gameLoop` in the class `de.gurkenlabs.litiengine.Game`.]]></request>
  </requests>
</response>
```
---Response.<init>---
Response created:
Unknown: The method `loop` returns the variable `gameLoop`. Without the initialization or assignment details of `gameLoop`, it's unclear whether it can be null. The possibility of `gameLoop` being uninitialized or set to null elsewhere in the program means `loop` could potentially return null. Further information on `gameLoop` is required.
---AdvancedNullAwayCodeFix.investigateMethodReturnNullability---
Could not determine the nullability and model did not ask for any method.
---ChatGPT.checkIfMethodIsReturningNullableOnCallSite---
Asking if the method is returning nullable on the call site: Game.loop()
---ChatGPT.ask---
Asking ChatGPT:
In the method below, is there a possibility that the method returns null at the given call site?

```java
@Nullable public static IGameLoop loop() {
    return gameLoop;
}
```

## Guidelines:
- The method may have multiple return paths; consider all return statements.
- If the method calls another method, do not assume its return value unless its full declaration is provided. Request its declaration if needed.
- The method may throw an exception instead of returning null. An exception path should not be considered a null return.
- Ensure you request the declarations of any methods whose return values directly or indirectly impact this method’s return value before making a conclusion.
- If the method returns a value that is determined by a parameter, evaluate based on the actual argument at the given call site.
- Analyze based only on the specific invocation provided. Do not generalize to all possible inputs.- If the return value is guaranteed to be non-null at the call site, the answer should be a definitive NO.
- Do not generalize based on all possible inputs—your answer must be based only on the given invocation.
- Focus only on the given call site, not all possible invocations.

### call site:
Game.loop()

Here are the method definitions and the call chain for this method, showing the sequence of calls from the method to its callers at each depth level:

Depth: 0
```java
class de.gurkenlabs.litiengine.Game {
@Nullable public static IGameLoop loop() {
    return gameLoop;
}
}
```
Depth: 1
```java
class de.gurkenlabs.litiengine.environment.GameWorld {
public void loadEnvironment(@Nullable final Environment env) {
    Lock lock = Game.loop().getLock();
    lock.lock();
    try {
      unloadEnvironment();
      this.environment = env;
      if (env != null) {
        this.addEnvironment(env);

        if (env.getGravity() == 0 && this.gravity() != 0) {
          env.setGravity(this.gravity());
        }

        env.load();
        for (final EnvironmentLoadedListener listener : this.loadedListeners) {
          listener.loaded(env);
        }

        // call map specific listeners
        String mapName = getMapName(env);
        if (mapName != null && this.environmentLoadedListeners.containsKey(mapName)) {

          // for the default camera we center the camera on the environment
          if (this.camera().getClass().equals(Camera.class)) {
            camera().setFocus(env.getCenter());
          }

          for (EnvironmentLoadedListener listener : this.environmentLoadedListeners.get(mapName)) {
            listener.loaded(env);
          }
        }
      }
    } finally {
      lock.unlock();
    }
}public void setCamera(@Nullable final ICamera cam) {
    if (this.camera() != null) {
      Game.loop().detach(camera);
    }

    camera = cam;

    if (cam != null && !Game.isInNoGUIMode()) {
      Game.loop().attach(cam);
      cam.updateFocus();
    }
}
}
```
```java
class de.gurkenlabs.litiengine.entities.behavior.EntityNavigator {
public EntityNavigator(final IMobileEntity entity, final PathFinder pathFinder) {
    this.cancelNavigationConditions = new CopyOnWriteArrayList<>();
    this.listeners = new CopyOnWriteArrayList<>();
    this.entity = entity;
    this.pathFinder = pathFinder;
    this.setAcceptableError(DEFAULT_ACCEPTABLE_ERROR);
    Game.loop().attach(this);
}
}
```
```java
class de.gurkenlabs.litiengine.GameWindow {
private static void initializeWindowEventListeners(Window window) {

    window.addWindowStateListener(
        e -> {
          if (e.getNewState() == Frame.ICONIFIED) {
            Game.loop().setTickRate(ICONIFIED_MAX_FPS);
          } else {
            Game.loop().setTickRate(Game.config().client().getMaxFps());
          }
        });

    window.addWindowFocusListener(
        new WindowFocusListener() {
          @Override
          public void windowLostFocus(WindowEvent e) {
            if (Game.config().graphics().reduceFramesWhenNotFocused()) {
              Game.loop().setTickRate(NONE_FOCUS_MAX_FPS);
            }
          }

          @Override
          public void windowGainedFocus(WindowEvent e) {
            Game.loop().setTickRate(Game.config().client().getMaxFps());
          }
        });

    window.addWindowListener(
        new WindowAdapter() {
          @Override
          public void windowClosing(final WindowEvent event) {
            Game.exit();
          }
        });
}
}
```
```java
class de.gurkenlabs.litiengine.gui.screens.ScreenManager {
public void display(@Nullable final Screen screen) {
    if (Game.hasStarted() && Game.time().since(this.lastScreenChange) < this.getChangeCooldown()) {
      log.log(
          Level.INFO,
          "Skipping displaying of screen {0} because screen changing is currently on cooldown.",
          screen != null ? screen.getName() : "");
      return;
    }

    final Screen previous = this.current();
    if (previous != null) {
      previous.suspend();
    }

    if (screen != null && !this.screens.contains(screen)) {
      this.screens.add(screen);
    }

    this.currentScreen = screen;
    if (!Game.isInNoGUIMode() && this.current() != null) {
      this.current().prepare();
    }

    this.lastScreenChange = Game.loop().getTicks();

    final ScreenChangedEvent event = new ScreenChangedEvent(this.current(), previous);
    for (final ScreenChangedListener listener : this.screenChangedListeners) {
      listener.changed(event);
    }
}
}
```
```java
class de.gurkenlabs.litiengine.abilities.effects.Effect {
@Override
  public void update() {

    for (final Iterator<EffectApplication> iterator = this.getActiveAppliances().iterator();
        iterator.hasNext(); ) {
      final EffectApplication appliance = iterator.next();
      // if the effect duration is reached
      if (this.hasEnded(appliance)) {

        iterator.remove();
        this.cease(appliance);
      }
    }

    // 4. unregister if all appliances are finished
    if (this.getActiveAppliances().isEmpty()) {
      Game.loop().detach(this);
    }
}public void apply(final Shape impactArea) {
    final List<ICombatEntity> affected = this.lookForAffectedEntities(impactArea);
    for (final ICombatEntity affectedEntity : affected) {
      this.apply(affectedEntity);
    }

    this.appliances.add(new EffectApplication(affected, impactArea));

    // if it is the first appliance -> register for update
    if (this.appliances.size() == 1) {
      Game.loop().attach(this);
    }
}
}
```
```java
class de.gurkenlabs.litiengine.GameTime {
public long toTicks(final int milliseconds) {
    return this.toTicks(milliseconds, Game.loop().getTickRate());
}public long since(final long tick) {
    return toMilliseconds(Game.loop().getTicks() - tick);
}public long now() {
    return Game.loop().getTicks();
}public long sinceGameStart() {
    return this.toMilliseconds(Game.loop().getTicks());
}@Override
  public void loaded(Environment environment) {
    environmentLoaded = Game.loop().getTicks();
}public long toMilliseconds(final long ticks) {
    return this.toMilliseconds(ticks, Game.loop().getTickRate());
}
}
```
```java
class de.gurkenlabs.litiengine.GameMetrics {
@Override
  public void render(final Graphics2D g) {
    this.updateMetrics();

    if (!Game.config().client().showGameMetrics()) {
      return;
    }

    this.currentOffsetY = 0;

    g.setColor(this.renderColor);

    // render client metrics
    this.drawTitle(g, "[client]");
    this.drawMetric(g, "fps       : " + this.getFramesPerSecond());
    this.drawMetric(g, "max fps   : " + this.maxFramesPerSecond);
    this.drawMetric(g, "updatables: " + Game.loop().getUpdatableCount());

    // render jvm metrics if debug is enabled
    if (Game.config().debug().isDebugEnabled()) {
      this.drawTitle(g, "[jvm]");
      this.drawMetric(g, "java      : " + this.javaVersion);
      this.drawMetric(g, "memory    : " + String.format("%-5.5s", this.usedMemory) + " MB");
      this.drawMetric(g, "threads   : " + Thread.activeCount());
    }

    // render rendering metrics
    if (!this.renderMetrics.isEmpty()) {
      this.drawTitle(g, "[update]");

      for (RenderMetrics metric : this.renderMetrics) {
        this.drawMetric(g, metric.toString());
      }

      this.renderMetrics.clear();
    }
}
}
```
```java
class de.gurkenlabs.litiengine.graphics.emitters.Emitter {
public void deactivate() {
    if (!this.activated) {
      return;
    }

    this.activated = false;
    this.getParticles().clear();
    this.aliveTime = 0;
    this.activationTick = 0;
    this.lastSpawn = 0;
    Game.loop().detach(this);
}public void activate() {
    if (this.activated) {
      return;
    }

    this.activated = true;
    this.activationTick = Game.time().now();
    Game.loop().attach(this);
}@Override
  public void update() {
    if (this.isPaused()) {
      return;
    }

    // clear particles if the effect time to life is reached
    if (this.isFinished()) {
      for (EmitterFinishedListener listener : this.finishedListeners) {
        listener.finished(this);
      }

      this.delete();
      return;
    }

    final float updateRatio = (float) this.data().getUpdateRate() / Game.loop().getTickRate();
    for (final Particle p : this.getParticles().stream().collect(Collectors.toList())) {
      if (this.particleCanBeRemoved(p)) {
        // remove dead particles
        this.particles.remove(p);
        continue;
      }

      p.update(this.getOrigin(), updateRatio);
    }

    this.aliveTime = Game.time().since(this.activationTick);
    if ((this.data().getSpawnRate() == 0
        || Game.time().since(this.lastSpawn) >= this.data().getSpawnRate())) {
      this.lastSpawn = Game.time().now();
      this.spawnParticle();
    }
}
}
```
```java
class de.gurkenlabs.litiengine.entities.behavior.IBehaviorController {
public default void attach() {
    Game.loop().attach(this);
}public default void detach() {
    Game.loop().detach(this);
}
}
```
```java
class de.gurkenlabs.litiengine.abilities.AbilityExecution {
AbilityExecution(final Ability ability) {
    this.appliedEffects = new CopyOnWriteArrayList<>();
    this.ability = ability;
    this.executionTicks = Game.time().now();
    this.impactArea = ability.calculateImpactArea();
    this.castLocation = ability.getExecutor().getCenter();
    Game.loop().attach(this);
}@Override
  public void update() {
    // if there a no effects to apply -> unregister this instance and we're done
    if (this.getAbility().getEffects().isEmpty()
        || this.getAbility().getEffects().size() == this.getAppliedEffects().size()) {
      Game.loop().detach(this);
      return;
    }

    // handle all effects from the ability that were not applied yet
    for (final Effect effect : this.getAbility().getEffects()) {
      // if the ability was not executed yet or the delay of the effect is not
      // yet reached
      if (this.getAppliedEffects().contains(effect)
          || Game.time().since(this.getExecutionTicks()) < effect.getDelay()) {
        continue;
      }

      effect.apply(this.getExecutionImpactArea());
      this.getAppliedEffects().add(effect);
    }
}
}
```
```java
class de.gurkenlabs.litiengine.GameWindow$3 {
@Override
          public void windowGainedFocus(WindowEvent e) {
            Game.loop().setTickRate(Game.config().client().getMaxFps());
}@Override
          public void windowLostFocus(WindowEvent e) {
            if (Game.config().graphics().reduceFramesWhenNotFocused()) {
              Game.loop().setTickRate(NONE_FOCUS_MAX_FPS);
            }
}
}
```
```java
class de.gurkenlabs.litiengine.environment.EntitySpawner {
protected void spawnNewEntities() {
    if (this.getSpawnMode() != SpawnMode.CUSTOMSPAWNPOINTS && this.getSpawnPoints().isEmpty()) {
      return;
    }

    switch (this.getSpawnMode()) {
      case ALLSPAWNPOINTS:
        for (int i = 0; i < this.getSpawnPoints().size(); i++) {
          final int index = i;
          Game.loop()
              .perform(
                  this.getSpawnDelay() + this.getSpawnDelay() * i,
                  () -> this.spawn(this.getSpawnPoints().get(index), this.getSpawnAmount()));
        }
        break;
      case ONERANDOMSPAWNPOINT:
        this.spawn(Game.random().choose(this.getSpawnPoints()), this.getSpawnAmount());
        break;
      case RANDOMSPAWNPOINTS:
        for (int i = 0; i < this.getSpawnAmount(); i++) {
          Game.loop()
              .perform(
                  this.getSpawnDelay() + this.getSpawnDelay() * i,
                  () -> this.spawn(Game.random().choose(this.getSpawnPoints()), 1));
        }
        break;
      case CUSTOMSPAWNPOINTS:
        List<Spawnpoint> spawnPoints =
            this.customSpawnpoints != null
                ? this.customSpawnpoints.apply(this)
                : this.getCustomSpawnpoints();

        int index = 0;
        for (Spawnpoint spawn : spawnPoints) {
          Game.loop()
              .perform(
                  this.getSpawnDelay() + this.getSpawnDelay() * index, () -> this.spawn(spawn, 1));
          index++;
        }
        break;
      default:
        break;
    }
}
}
```
```java
class de.gurkenlabs.litiengine.tweening.TweenEngine {
@Override
  public void start() {
    Game.loop().attach(this);
}@Override
  public void terminate() {
    Game.loop().detach(this);
}
}
```
```java
class de.gurkenlabs.litiengine.gui.SpeechBubble {
public void hide() {
    Game.world().environment().removeRenderable(this);
    Game.loop().detach(this);
    if (activeSpeechBubbles.get(this.getEntity()) != null
        && activeSpeechBubbles.remove(this.getEntity()).equals(this)) {
      activeSpeechBubbles.remove(this.getEntity());
    }

    for (SpeechBubbleListener listener : this.listeners) {
      listener.hidden();
    }
}private SpeechBubble(
      final IEntity entity,
      final String text,
      @Nullable SpeechBubbleAppearance appearance,
      @Nullable Font font) {
    if (appearance == null) {
      this.appearance = DEFAULT_APPEARANCE;
    } else {
      this.appearance = appearance;
    }

    final SpeechBubble active = activeSpeechBubbles.get(entity);
    if (active != null) {
      active.hide();
    }
    this.setFont(font);

    this.textBoxWidth = (float) (entity.getWidth() * 4);
    this.entity = entity;

    this.currentText = text;
    this.currentTextDisplayTime = DISPLAYTIME_MIN + text.length() * DISPLAYTIME_PER_LETTER;

    this.lastTextDisplay = Game.time().now();
    this.createBubbleImage();
    entity.getEnvironment().add(this, RenderType.UI);
    Game.loop().attach(this);
    activeSpeechBubbles.put(entity, this);
}
}
```
```java
class de.gurkenlabs.litiengine.entities.Prop {
private void updateAnimationController() {
    IEntityAnimationController<?> controller = this.createAnimationController();
    this.getControllers().addController(controller);
    if (Game.world().environment() != null && Game.world().environment().isLoaded()) {
      Game.loop().attach(controller);
    }
}
}
```
```java
class de.gurkenlabs.litiengine.graphics.FreeFlightCamera {
public FreeFlightCamera(final Point2D focus) {
    this.setFocus(focus);
    this.velocity = DEFAULT_SCROLL_PIXELS_PER_SECOND;
    this.scrollPadding = DEFAULT_SCROLL_PADDING;
    this.setClampToMap(true);

    Game.loop().attach(this);
}private void handleFreeFlightCamera() {
    if (Game.world().environment() == null || Game.world().environment().getMap() == null) {
      return;
    }

    final Point2D mouseLocation = Input.mouse().getLocation();

    final double scrollSpeed =
        this.getVelocity()
            / (double) Game.loop().getTickRate()
            * Game.config().input().getMouseSensitivity();

    double x = this.getFocus().getX();
    double y = this.getFocus().getY();

    double deltaX = 0;
    if (mouseLocation.getX() < this.getScrollPadding()) {
      deltaX -= scrollSpeed;
    } else if (Game.window().getResolution().getWidth() - mouseLocation.getX()
        < this.getScrollPadding()) {
      deltaX += scrollSpeed;
    }

    double deltaY = 0;
    if (mouseLocation.getY() < this.getScrollPadding()) {
      deltaY -= scrollSpeed;
    } else if (Game.window().getResolution().getHeight() - mouseLocation.getY()
        < this.getScrollPadding()) {
      deltaY += scrollSpeed;
    }

    x += deltaX;
    y += deltaY;

    this.setFocus(new Point2D.Double(x, y));
}
}
```
```java
class de.gurkenlabs.litiengine.environment.Environment {
private static void dispose(final Collection<? extends IEntity> entities) {
    for (final IEntity entity : entities) {
      if (entity instanceof IUpdateable) {
        Game.loop().detach((IUpdateable) entity);
      }

      entity.detachControllers();
    }
}private static void loadUpdatableOrEmitterEntity(IEntity entity) {
    if (entity instanceof Emitter) {
      final Emitter emitter = (Emitter) entity;
      if (emitter.isActivateOnInit()) {
        emitter.activate();
      }
    } else if (entity instanceof IUpdateable) {
      Game.loop().attach((IUpdateable) entity);
    }
}private void unload(final IEntity entity) {
    // 1. remove from physics engine
    if (entity instanceof ICollisionEntity) {
      Game.physics().remove((ICollisionEntity) entity);
    }

    // 2. unregister from update
    if (entity instanceof IUpdateable) {
      Game.loop().detach((IUpdateable) entity);
    }

    if (entity instanceof IMobileEntity) {
      this.removeGravity((IMobileEntity) entity);
    }

    // 3. detach all controllers
    entity.detachControllers();

    if (entity instanceof Emitter) {
      Emitter em = (Emitter) entity;
      em.deactivate();
    }

    if (this.loaded && (entity instanceof LightSource || entity instanceof StaticShadow)) {
      this.updateLighting(entity);
    }

    entity.removed(this);
}
}
```
```java
class de.gurkenlabs.litiengine.graphics.animation.Animation {
@Override
  public void update() {
    // do nothing if the animation is not playing or the current keyframe is not finished
    if (!this.isPlaying()
        || Game.time().since(this.lastFrameUpdate) < this.getCurrentKeyFrame().getDuration()) {
      return;
    }

    // if we are not looping and the last keyframe is finished, we terminate the animation
    if (!this.isLooping() && this.isLastKeyFrame()) {
      this.terminate();
      return;
    }

    // make sure, we stay inside the keyframe list
    final int newFrameIndex =
        (this.getKeyframes().indexOf(this.currentFrame) + 1) % this.getKeyframes().size();
    final KeyFrame previousFrame = this.currentFrame;
    this.currentFrame = this.getKeyframes().get(newFrameIndex);

    for (KeyFrameListener listener : this.listeners) {
      listener.currentFrameChanged(previousFrame, this.currentFrame);
    }

    this.lastFrameUpdate = Game.loop().getTicks();
}public void restart() {
    this.currentFrame = this.firstFrame;
    this.lastFrameUpdate = Game.loop().getTicks();
}
}
```
```java
class de.gurkenlabs.litiengine.physics.MovementController {
@Override
  public void attach() {
    Game.loop().attach(this);
}private void handleForces() {
    // clean up forces
    this.activeForces.forEach(
        x -> {
          if (x.hasEnded()) {
            this.activeForces.remove(x);
          }
        });

    if (this.activeForces.isEmpty()) {
      return;
    }

    // disable turn-on-move for force handling
    boolean turn = this.getEntity().turnOnMove();
    this.getEntity().setTurnOnMove(false);
    try {
      double deltaX = 0;
      double deltaY = 0;
      for (final Force force : this.activeForces) {
        if (force.cancelOnReached() && force.hasReached(this.getEntity())) {
          force.end();
          continue;
        }

        final Point2D collisionBoxCenter = this.getEntity().getCollisionBoxCenter();
        final double angle =
            GeometricUtilities.calcRotationAngleInDegrees(collisionBoxCenter, force.getLocation());
        final double strength =
            Game.loop().getDeltaTime() * 0.001f * force.getStrength() * Game.loop().getTimeScale();
        deltaX += GeometricUtilities.getDeltaX(angle, strength);
        deltaY += GeometricUtilities.getDeltaY(angle, strength);
      }

      final Point2D target =
          new Point2D.Double(this.getEntity().getX() + deltaX, this.getEntity().getY() + deltaY);
      final boolean success = Game.physics().move(this.getEntity(), target);
      if (!success) {
        for (final Force force : this.activeForces) {
          if (force.cancelOnCollision()) {
            force.end();
          }
        }
      }
    } finally {
      this.getEntity().setTurnOnMove(turn);
    }
}@Override
  public void detach() {
    Game.loop().detach(this);
}public void handleMovement() {
    if (!this.isMovementAllowed()) {
      this.velocity = 0;
      return;
    }

    // max distance an entity can travel within one tick
    final double maxPixelsPerTick = this.getEntity().getTickVelocity();
    final double deltaTime = Game.loop().getDeltaTime() * Game.loop().getTimeScale();

    final double acceleration =
        this.getEntity().getAcceleration() == 0
            ? maxPixelsPerTick
            : deltaTime / this.getEntity().getAcceleration() * maxPixelsPerTick;
    final double deceleration =
        this.getEntity().getDeceleration() == 0
            ? this.getVelocity()
            : deltaTime / this.getEntity().getDeceleration() * maxPixelsPerTick;

    double dx = this.getDx();
    double dy = this.getDy();
    this.setDx(0);
    this.setDy(0);

    final double deltaVelocity =
        Math.min(Math.sqrt(Math.pow(dx, 2) + Math.pow(dy, 2)), acceleration);
    if (deltaVelocity != 0) {
      double newVelocity = this.getVelocity() + deltaVelocity;
      this.setVelocity(newVelocity);
    } else {
      final double newVelocity = Math.max(0, this.getVelocity() - deceleration);
      this.setVelocity(newVelocity);
      dx = GeometricUtilities.getDeltaX(this.moveAngle);
      dy = GeometricUtilities.getDeltaY(this.moveAngle);
    }

    if (this.getVelocity() == 0) {
      this.moveAngle = 0;
      return;
    }

    // actually move entity
    this.moveEntity(dx, dy);
}
}
```
```java
class de.gurkenlabs.litiengine.graphics.animation.AnimationController {
public void detach() {
    Game.loop().detach(this);
}public void attach() {
    Game.loop().attach(this);
}
}
```
```java
class de.gurkenlabs.litiengine.graphics.Camera {
@Override
  public void setZoom(final float targetZoom, final int delay) {
    if (delay == 0) {

      this.zoom = targetZoom;
      this.targetZoom = 0;
      this.zoomDelay = 0;
      this.zoomTick = 0;
      this.zoomStep = 0;

      final ZoomChangedEvent event = new ZoomChangedEvent(this, targetZoom);
      for (final ZoomChangedListener listener : this.zoomListeners) {
        listener.zoomChanged(event);
      }
    } else {
      this.zoomTick = Game.time().now();
      this.targetZoom = targetZoom;
      this.zoomDelay = delay;

      final double tickduration = 1000 / (double) Game.loop().getTickRate();
      final double tickAmount = delay / tickduration;
      final float totalDelta = this.targetZoom - this.zoom;
      this.zoomStep = tickAmount > 0 ? (float) (totalDelta / tickAmount) : totalDelta;
    }
}
}
```
```java
class de.gurkenlabs.litiengine.Game {
public static synchronized void init(String... args) {
    if (initialized) {
      log().log(Level.INFO, "The game has already been initialized.");
      return;
    }

    log.init();
    handleCommandLineArguments(args);

    config().load();
    Locale.setDefault(new Locale(config().client().getCountry(), config().client().getLanguage()));

    gameLoop = new GameLoop("Main Update Loop", config().client().getMaxFps());
    loop().attach(physics());
    loop().attach(world());

    // setup default exception handling for render and update loop
    setUncaughtExceptionHandler(
        new DefaultUncaughtExceptionHandler(config().client().exitOnError()));

    screenManager = new ScreenManager();
    gameWindow = new GameWindow();

    // initialize  the game window
    window().init();
    world.setCamera(new Camera());

    for (GameListener listener : gameListeners) {
      listener.initialized(args);
    }

    if (!isInNoGUIMode()) {
      window().getRenderComponent().onRendered(g -> metrics().render(g));

      graphics()
          .addEntityRenderedListener(
              e -> DebugRenderer.renderEntityDebugInfo(e.getGraphics(), e.getEntity()));

      window().getRenderComponent().onFpsChanged(fps -> metrics().setFramesPerSecond(fps));
      window()
          .setIcons(
              Arrays.asList(
                  Resources.images().get("liti-logo-x16.png"),
                  Resources.images().get("liti-logo-x20.png"),
                  Resources.images().get("liti-logo-x32.png"),
                  Resources.images().get("liti-logo-x48.png")));

      Input.keyboard()
          .onKeyTyped(
              KeyEvent.VK_PRINTSCREEN,
              key -> {
                // don't take a screenshot if a modifier is active
                if (key.getModifiers() != 0) {
                  return;
                }

                window().getRenderComponent().takeScreenshot();
              });
    }

    Runtime.getRuntime().addShutdownHook(new Thread(Game::terminate, "Shutdown"));

    initialized = true;
}
}
```
```java
class de.gurkenlabs.litiengine.entities.Creature {
protected void updateAnimationController() {
    IEntityAnimationController<?> controller = this.createAnimationController();
    this.getControllers().addController(controller);
    if (Game.world().environment() != null && Game.world().environment().isLoaded()) {
      Game.loop().attach(controller);
    }
}@Override
  public float getTickVelocity() {
    // pixels per ms multiplied by the passed ms
    // ensure that entities don't travel too far in case of lag
    return Math.min(Game.loop().getDeltaTime(), GameLoop.TICK_DELTATIME_LAG)
        * 0.001F
        * this.getVelocity().get()
        * Game.loop().getTimeScale();
}
}
```
Depth: 2
```java
class de.gurkenlabs.litiengine.environment.GameWorld {
public void clear() {
    this.unloadEnvironment();
    this.environments.clear();
    this.setCamera(null);
    Game.physics().clear();

    this.environmentListeners.clear();
    this.environmentLoadedListeners.clear();
    this.environmentUnloadedListeners.clear();

    this.listeners.clear();
    this.loadedListeners.clear();
    this.unloadedListeners.clear();
}@Nullable
  public Environment loadEnvironment(IMap map) {
    Environment env = this.getEnvironment(map);
    this.loadEnvironment(env);
    return env;
}@Nullable
  public Environment loadEnvironment(String mapName) {
    Environment env = this.getEnvironment(mapName);
    this.loadEnvironment(env);
    return env;
}
}
```
```java
class de.gurkenlabs.litiengine.GameWindow {
GameWindow() {
    this.hostControl = new JFrame();

    this.resolutionChangedListeners = new CopyOnWriteArrayList<>();

    this.renderCanvas = new RenderComponent(Game.config().graphics().getResolution());
    this.cursor = new MouseCursor();
    if (!Game.isInNoGUIMode()) {
      this.hostControl.setBackground(Color.BLACK);
      this.hostControl.add(this.renderCanvas);

      this.initializeEventListeners();

      this.hostControl.setTitle(Game.info().getTitle());
      this.hostControl.setDefaultCloseOperation(WindowConstants.DO_NOTHING_ON_CLOSE);
      initializeWindowEventListeners(this.hostControl);
    }
}
}
```
```java
class de.gurkenlabs.litiengine.GameTime {
public long sinceEnvironmentLoad() {
    return this.since(this.environmentLoaded);
}public long since(final long tick) {
    return toMilliseconds(Game.loop().getTicks() - tick);
}public long sinceGameStart() {
    return this.toMilliseconds(Game.loop().getTicks());
}
}
```
```java
class de.gurkenlabs.litiengine.abilities.effects.Effect {
protected void cease(final EffectApplication appliance) {
    // 1. cease the effect for all affected entities
    for (final ICombatEntity entity : appliance.getAffectedEntities()) {
      this.cease(entity);
    }

    // 2. apply follow up effects
    this.getFollowUpEffects().forEach(followUp -> followUp.apply(appliance.getImpactArea()));
}protected boolean hasEnded(final EffectApplication appliance) {
    final long effectDuration = Game.time().since(appliance.getAppliedTicks());
    return effectDuration > this.getDuration();
}
}
```
```java
class de.gurkenlabs.litiengine.abilities.effects.EffectApplication {
protected EffectApplication(final List<ICombatEntity> affectedEntities, final Shape impactArea) {
    this.applied = Game.time().now();
    this.affectedEntities = affectedEntities;
    this.impactArea = impactArea;
}
}
```
```java
class de.gurkenlabs.litiengine.entities.CombatEntity {
@Override
  public boolean wasHit(int timeSpan) {
    return Game.time().since(this.lastHit) < timeSpan;
}@Override
  public void hit(final int damage, @Nullable final Ability ability) {
    if (this.isDead()) {
      return;
    }

    if (!this.isIndestructible()) {
      this.getHitPoints().modifyBaseValue(new AttributeModifier<>(Modification.SUBTRACT, damage));
    }

    final EntityHitEvent event = new EntityHitEvent(this, ability, damage, this.isDead());

    for (final CombatEntityListener listener : this.listeners) {
      listener.hit(event);
    }

    for (final CombatEntityHitListener listener : this.hitListeners) {
      listener.hit(event);
    }

    if (this.isDead()) {
      this.fireDeathEvent();
      this.setCollision(false);
    }

    this.lastHit = Game.time().now();
}
}
```
```java
class de.gurkenlabs.litiengine.graphics.ImageEffect {
protected ImageEffect(final int ttl, final String name) {
    this.ttl = ttl;
    this.name = name;
    this.aliveTick = Game.time().now();
}@Override
  public long getAliveTime() {
    return Game.time().since(this.aliveTick);
}
}
```
```java
class de.gurkenlabs.litiengine.abilities.AbilityExecution {
AbilityExecution(final Ability ability) {
    this.appliedEffects = new CopyOnWriteArrayList<>();
    this.ability = ability;
    this.executionTicks = Game.time().now();
    this.impactArea = ability.calculateImpactArea();
    this.castLocation = ability.getExecutor().getCenter();
    Game.loop().attach(this);
}@Override
  public void update() {
    // if there a no effects to apply -> unregister this instance and we're done
    if (this.getAbility().getEffects().isEmpty()
        || this.getAbility().getEffects().size() == this.getAppliedEffects().size()) {
      Game.loop().detach(this);
      return;
    }

    // handle all effects from the ability that were not applied yet
    for (final Effect effect : this.getAbility().getEffects()) {
      // if the ability was not executed yet or the delay of the effect is not
      // yet reached
      if (this.getAppliedEffects().contains(effect)
          || Game.time().since(this.getExecutionTicks()) < effect.getDelay()) {
        continue;
      }

      effect.apply(this.getExecutionImpactArea());
      this.getAppliedEffects().add(effect);
    }
}
}
```
```java
class de.gurkenlabs.litiengine.tweening.TweenEngine {
@Override
  public void update() {
    for (final Tweenable target : this.getTweens().keySet()) {
      for (final Tween tween : this.getTweens().get(target).values()) {
        if (tween.hasStopped()) {
          continue;
        }
        final long elapsed = Game.time().since(tween.getStartTime());
        if (elapsed >= tween.getDuration()) {
          tween.stop();
          continue;
        }
        final float[] currentValues = new float[tween.getTargetValues().length];
        for (int i = 0; i < tween.getTargetValues().length; i++) {
          currentValues[i] =
              tween.getStartValues()[i]
                  + tween.getEquation().compute(elapsed / (float) tween.getDuration())
                      * (tween.getTargetValues()[i] - tween.getStartValues()[i]);
        }
        tween.getTarget().setTweenValues(tween.getType(), currentValues);
      }
    }
}
}
```
```java
class de.gurkenlabs.litiengine.gui.SpeechBubble {
public static SpeechBubble create(
      final IEntity entity, final String text, SpeechBubbleAppearance appearance, Font font) {
    return new SpeechBubble(entity, text, appearance, font);
}public static SpeechBubble create(final IEntity entity, final Font font, final String text) {
    SpeechBubbleAppearance app =
        new SpeechBubbleAppearance(
            DEFAULT_APPEARANCE.getForeColor(),
            DEFAULT_APPEARANCE.getBackgroundColor1(),
            DEFAULT_APPEARANCE.getBorderColor(),
            DEFAULT_APPEARANCE.getPadding());
    return new SpeechBubble(entity, text, app, font);
}public static SpeechBubble create(final IEntity entity, final String text) {
    return new SpeechBubble(entity, text, null, GuiProperties.getDefaultFont());
}@Override
  public void update() {
    if (this.currentText == null) {
      this.hide();
      return;
    }

    this.entityCenter = Game.world().camera().getViewportLocation(this.getEntity().getCenter());

    // old text was displayed long enough
    if (this.lastTextDisplay != 0
        && Game.time().since(this.lastTextDisplay) > this.currentTextDisplayTime) {
      this.currentText = null;
      this.lastTextDisplay = 0;
      return;
    }

    // display new text
    if (this.textIndex < this.currentText.length()
        && Game.time().since(this.lastCharPoll) > LETTER_WRITE_DELAY) {
      this.textIndex++;
      this.lastCharPoll = Game.time().now();
      if (this.typeSound != null) {
        Game.audio().playSound(this.typeSound, this.getEntity());
      }
    }

    // continue displaying currently displayed text
}private SpeechBubble(
      final IEntity entity,
      final String text,
      final Sound typeSound,
      SpeechBubbleAppearance appearance,
      Font font) {
    this(entity, text, appearance, font);
    this.typeSound = typeSound;
}private SpeechBubble(
      final IEntity entity,
      final String text,
      @Nullable SpeechBubbleAppearance appearance,
      @Nullable Font font) {
    if (appearance == null) {
      this.appearance = DEFAULT_APPEARANCE;
    } else {
      this.appearance = appearance;
    }

    final SpeechBubble active = activeSpeechBubbles.get(entity);
    if (active != null) {
      active.hide();
    }
    this.setFont(font);

    this.textBoxWidth = (float) (entity.getWidth() * 4);
    this.entity = entity;

    this.currentText = text;
    this.currentTextDisplayTime = DISPLAYTIME_MIN + text.length() * DISPLAYTIME_PER_LETTER;

    this.lastTextDisplay = Game.time().now();
    this.createBubbleImage();
    entity.getEnvironment().add(this, RenderType.UI);
    Game.loop().attach(this);
    activeSpeechBubbles.put(entity, this);
}
}
```
```java
class de.gurkenlabs.litiengine.gui.TextFieldComponent {
@Override
  public void render(final Graphics2D g) {
    super.render(g);
    g.setFont(this.getFont());
    final FontMetrics fm = g.getFontMetrics();

    if (this.isSelected() && Game.time().since(this.lastToggled) > this.flickerDelay) {
      this.cursorVisible = !this.cursorVisible;
      this.lastToggled = Game.time().now();
    }
    if (this.isSelected() && this.cursorVisible) {
      final Rectangle2D cursor =
          new Rectangle2D.Double(
              this.getX() + this.getTextX() + fm.stringWidth(this.getTextToRender(g)),
              this.getY() + this.getTextY(),
              this.getFont().getSize2D() * 3 / 5,
              this.getFont().getSize2D() * 1 / 5);
      g.setColor(this.getAppearance().getForeColor());
      g.fill(cursor);
    }
}
}
```
```java
class de.gurkenlabs.litiengine.entities.Prop {
public Prop(
      final Point2D location, @Nullable final String spritesheetName, final Material material) {
    super();
    this.rotation = Rotation.NONE;
    this.spritesheetName = spritesheetName;
    this.material = material;
    this.setLocation(location);
    this.updateAnimationController();
}public void setSpritesheetName(@Nullable final String spriteName) {
    this.spritesheetName = spriteName;
    this.updateAnimationController();
}
}
```
```java
class de.gurkenlabs.litiengine.tweening.Tween {
public Tween begin() {
    this.started = Game.time().now();
    this.stopped = false;
    return this;
}
}
```
```java
class de.gurkenlabs.litiengine.graphics.emitters.particles.Particle {
public void update(final Point2D emitterOrigin, final float updateRatio) {
    if (this.aliveTick == 0) {
      this.aliveTick = Game.time().now();
    }

    this.aliveTime = Game.time().since(this.aliveTick);
    if (this.timeToLiveReached()) {
      return;
    }

    if (this.colliding) {
      return;
    }

    if (this.getDeltaWidth() != 0) {
      this.width += this.getDeltaWidth() * updateRatio;
    }

    if (this.getDeltaHeight() != 0) {
      this.height += this.getDeltaHeight() * updateRatio;
    }

    if (this.getDeltaAngle() != 0) {
      this.angle += this.getDeltaAngle() * updateRatio;
    }

    // test for ray cast collision
    final float targetX = this.x + this.getVelocityX() * updateRatio;
    final float targetY = this.y + this.getVelocityY() * updateRatio;

    if (targetX == this.x && targetY == this.y) {
      return;
    }

    if (this.checkForCollision(emitterOrigin, targetX, targetY)) {
      return;
    }

    if (this.getVelocityX() != 0) {
      this.x = targetX;
    }

    if (this.getVelocityY() != 0) {
      this.y = targetY;
    }

    if (this.getAccelerationX() != 0) {
      this.velocityX += this.getAccelerationX() * updateRatio;
    }

    if (this.getAccelerationY() != 0) {
      this.velocityY += this.getAccelerationY() * updateRatio;
    }
}
}
```
```java
class de.gurkenlabs.litiengine.graphics.animation.Animation {
@Override
  public void start() {
    this.playing = true;
    if (this.getKeyframes().isEmpty()) {
      return;
    }

    this.restart();
}@Override
  public void update() {
    // do nothing if the animation is not playing or the current keyframe is not finished
    if (!this.isPlaying()
        || Game.time().since(this.lastFrameUpdate) < this.getCurrentKeyFrame().getDuration()) {
      return;
    }

    // if we are not looping and the last keyframe is finished, we terminate the animation
    if (!this.isLooping() && this.isLastKeyFrame()) {
      this.terminate();
      return;
    }

    // make sure, we stay inside the keyframe list
    final int newFrameIndex =
        (this.getKeyframes().indexOf(this.currentFrame) + 1) % this.getKeyframes().size();
    final KeyFrame previousFrame = this.currentFrame;
    this.currentFrame = this.getKeyframes().get(newFrameIndex);

    for (KeyFrameListener listener : this.listeners) {
      listener.currentFrameChanged(previousFrame, this.currentFrame);
    }

    this.lastFrameUpdate = Game.loop().getTicks();
}
}
```
```java
class de.gurkenlabs.litiengine.graphics.animation.AnimationController {
@Override
  public void update() {
    for (final Animation animation : this.getAll()) {
      animation.update();
    }

    if (this.getCurrent() != null && this.getCurrent().isPaused()) {
      return;
    }

    final boolean playbackFinished = this.getCurrent() != null && !this.getCurrent().isPlaying();
    if (playbackFinished) {
      for (final AnimationListener listener : this.listeners) {
        listener.finished(this.getCurrent());
      }
    }

    if (this.getCurrent() == null || playbackFinished) {
      if (this.getDefault() != null) {
        this.play(this.getDefault().getName());
      } else {
        this.currentAnimation = null;
      }
    }
}
}
```
```java
class de.gurkenlabs.litiengine.graphics.RenderComponent {
private void handleFade() {
    if (this.fadeOutStart != -1) {
      final long timePassed = Game.time().since(this.fadeOutStart);
      this.currentAlpha = MathUtilities.clamp(1 - timePassed / (float) this.fadeOutTime, 0, 1);
      if (this.currentAlpha == 0f) {
        this.fadeOutStart = -1;
        this.fadeOutTime = -1;
      }

      return;
    }

    if (this.fadeInStart != -1) {
      final long timePassed = Game.time().since(this.fadeInStart);
      this.currentAlpha = MathUtilities.clamp(timePassed / (float) this.fadeInTime, 0, 1);
      if (this.currentAlpha == 1f) {
        this.fadeInStart = -1;
        this.fadeInTime = -1;
        this.currentAlpha = Float.NaN;
      }
    }
}public void fadeOut(final int ms) {
    this.fadeInStart = -1;
    this.fadeInTime = -1;
    this.fadeOutStart = Game.time().now();
    this.fadeOutTime = ms;
}public void fadeIn(final int ms) {
    this.fadeOutStart = -1;
    this.fadeOutTime = -1;
    this.fadeInStart = Game.time().now();
    this.fadeInTime = ms;
}
}
```
```java
class de.gurkenlabs.litiengine.entities.Trigger {
private boolean activate(final IEntity activator, final int tar) {
    if (!this.isLoaded()
        || this.isOneTimeTrigger && this.isActivated
        || this.getActivationType() == TriggerActivation.COLLISION
            && activator != null
            && this.collisionActivated.contains(activator)) {
      return false;
    }

    if (this.getCooldown() > 0 && Game.time().since(this.lastActivation) < this.getCooldown()) {
      return false;
    }

    List<Integer> triggerTargets = this.getTargets(tar);

    final TriggerEvent te = new TriggerEvent(this, activator, triggerTargets);

    if (!this.checkActivationPredicates(te)) {
      return false;
    }

    this.isActivated = true;
    if (activator != null) {
      this.collisionActivated.add(activator);
    }

    // if we actually have a trigger target, we send the message to the target
    for (final int target : triggerTargets) {
      final IEntity entity = this.getEnvironment().get(target);
      if (entity == null) {
        log.log(
            Level.WARNING,
            "trigger [{0}] was activated, but the trigger target [{1}] could not be found on the environment",
            new Object[] {this, target});
        continue;
      }

      entity.sendMessage(this, this.message);
    }

    // also send the trigger event to all registered consumers
    for (final TriggerActivatedListener listener : this.activatedListeners) {
      listener.activated(te);
    }

    if (this.isOneTimeTrigger) {
      this.getEnvironment().remove(this);
    }

    this.lastActivation = Game.time().now();
    return true;
}
}
```
```java
class de.gurkenlabs.litiengine.graphics.Camera {
private boolean isShakeEffectActive() {
    return this.getShakeTick() != 0
        && Game.time().since(this.getShakeTick()) < this.getShakeDuration();
}@Override
  public void update() {
    if (Game.world().camera() != null && !Game.world().camera().equals(this)) {
      return;
    }

    if (this.targetZoom > 0) {
      if (Game.time().since(this.zoomTick) >= this.zoomDelay) {
        this.zoom = this.targetZoom;
        this.targetZoom = 0;
        this.zoomDelay = 0;
        this.zoomTick = 0;
        this.zoomStep = 0;
      } else {
        this.zoom += this.zoomStep;
      }

      final ZoomChangedEvent event = new ZoomChangedEvent(this, this.getZoom());
      for (final ZoomChangedListener listener : this.zoomListeners) {
        listener.zoomChanged(event);
      }
    }

    if (this.panTime > 0) {
      if (--this.panTime <= 0) {
        this.setFocus(this.targetFocus);
        this.targetFocus = null;
      } else {
        double diff = this.panTime / (this.panTime + 1.0);
        this.focus =
            new Point2D.Double(
                this.focus.getX() * diff + this.targetFocus.getX() * (1.0 - diff),
                this.focus.getY() * diff + this.targetFocus.getY() * (1.0 - diff));
      }
    }

    if (!this.isShakeEffectActive()) {
      this.shakeOffsetX = 0;
      this.shakeOffsetY = 0;
      return;
    }

    if (Game.time().since(this.lastShake) > this.shakeDelay) {
      this.shakeOffsetX = this.getShakeIntensity() * ThreadLocalRandom.current().nextGaussian();
      this.shakeOffsetY = this.getShakeIntensity() * ThreadLocalRandom.current().nextGaussian();
      this.lastShake = Game.time().now();
    }
}@Override
  public void setZoom(final float targetZoom, final int delay) {
    if (delay == 0) {

      this.zoom = targetZoom;
      this.targetZoom = 0;
      this.zoomDelay = 0;
      this.zoomTick = 0;
      this.zoomStep = 0;

      final ZoomChangedEvent event = new ZoomChangedEvent(this, targetZoom);
      for (final ZoomChangedListener listener : this.zoomListeners) {
        listener.zoomChanged(event);
      }
    } else {
      this.zoomTick = Game.time().now();
      this.targetZoom = targetZoom;
      this.zoomDelay = delay;

      final double tickduration = 1000 / (double) Game.loop().getTickRate();
      final double tickAmount = delay / tickduration;
      final float totalDelta = this.targetZoom - this.zoom;
      this.zoomStep = tickAmount > 0 ? (float) (totalDelta / tickAmount) : totalDelta;
    }
}@Override
  public void shake(final double intensity, final int delay, final int shakeDuration) {
    this.shakeTick = Game.time().now();
    this.shakeDelay = delay;
    this.shakeIntensity = intensity;
    this.shakeDuration = shakeDuration;
}
}
```
```java
class de.gurkenlabs.litiengine.entities.Creature {
public void setSpritesheetName(String spritesheetName) {
    if (this.spritesheetName != null && this.spritesheetName.equals(spritesheetName)) {
      return;
    }

    this.spritesheetName = spritesheetName;
    this.updateAnimationController();
}public boolean isIdle() {
    return Game.time().since(this.lastMoved) > IDLE_DELAY;
}@Override
  public void setLocation(final Point2D position) {
    if (this.isDead() || position == null) {
      return;
    }

    final Point2D oldLocation = this.getLocation();
    super.setLocation(position);

    if (Game.hasStarted() && this.isLoaded()) {
      this.lastMoved = Game.time().now();
      this.fireMovedEvent(
          new EntityMovedEvent(
              this, this.getX() - oldLocation.getX(), this.getY() - oldLocation.getY()));
    }
}
}
```
```java
class de.gurkenlabs.litiengine.gui.screens.ScreenManager {
public void display(final String screenName) {
    if (this.current() != null && this.current().getName().equalsIgnoreCase(screenName)) {
      log.log(
          Level.INFO,
          "Skipping displaying of screen {0} because it is already the current screen.",
          screenName);
      return;
    }

    if (this.screens.stream()
        .noneMatch(element -> element.getName().equalsIgnoreCase(screenName))) {
      log.log(
          Level.WARNING,
          "Could not display the screen {0} because there is no screen with the specified name.",
          screenName);
      return;
    }

    Screen screen = this.get(screenName);
    if (screen == null) {
      return;
    }

    this.display(screen);
}public void add(final Screen screen) {
    screen.setWidth(Game.window().getWidth());
    screen.setHeight(Game.window().getHeight());
    this.screens.add(screen);

    if (this.current() == null) {
      this.display(screen);
    }
}public void remove(Screen screen) {
    this.screens.remove(screen);
    if (this.current() == screen) {
      if (!this.screens.isEmpty()) {
        this.display(this.screens.get(0));
      } else {
        this.display((Screen) null);
      }
    }
}public void display(@Nullable final Screen screen) {
    if (Game.hasStarted() && Game.time().since(this.lastScreenChange) < this.getChangeCooldown()) {
      log.log(
          Level.INFO,
          "Skipping displaying of screen {0} because screen changing is currently on cooldown.",
          screen != null ? screen.getName() : "");
      return;
    }

    final Screen previous = this.current();
    if (previous != null) {
      previous.suspend();
    }

    if (screen != null && !this.screens.contains(screen)) {
      this.screens.add(screen);
    }

    this.currentScreen = screen;
    if (!Game.isInNoGUIMode() && this.current() != null) {
      this.current().prepare();
    }

    this.lastScreenChange = Game.loop().getTicks();

    final ScreenChangedEvent event = new ScreenChangedEvent(this.current(), previous);
    for (final ScreenChangedListener listener : this.screenChangedListeners) {
      listener.changed(event);
    }
}
}
```
```java
class de.gurkenlabs.litiengine.abilities.Ability {
public boolean isOnCooldown() {
    return (this.getCurrentExecution() != null
        && this.getCurrentExecution().getExecutionTicks() > 0
        && Game.time().since(this.getCurrentExecution().getExecutionTicks())
            < this.getAttributes().cooldown().get());
}public boolean isActive() {
    return this.getCurrentExecution() != null
        && Game.time().since(this.getCurrentExecution().getExecutionTicks())
            < this.getAttributes().duration().get();
}@Nullable
  public AbilityExecution cast() {
    if (!this.canCast()) {
      return null;
    }
    this.currentExecution = new AbilityExecution(this);

    for (final AbilityCastListener listener : this.abilityCastListeners) {
      listener.abilityCast(this.currentExecution);
    }

    return this.getCurrentExecution();
}public float getRemainingCooldownInSeconds() {
    if (this.getCurrentExecution() == null
        || this.getExecutor() == null
        || this.getExecutor().isDead()) {
      return 0;
    }

    // calculate cooldown in seconds
    return (float)
        (!this.canCast()
            ? (this.getAttributes().cooldown().get()
                    - Game.time().since(this.getCurrentExecution().getExecutionTicks()))
                * 0.001
            : 0);
}
}
```
```java
class de.gurkenlabs.litiengine.entities.EntityHitEvent {
EntityHitEvent(
      final ICombatEntity hitEntity,
      @Nullable final Ability ability,
      final int damage,
      final boolean kill) {
    super(hitEntity);
    this.executor = ability != null ? ability.getExecutor() : null;
    this.hitEntity = hitEntity;
    this.ability = ability;
    this.damage = damage;
    this.kill = kill;
    this.time = Game.time().now();
}
}
```
```java
class de.gurkenlabs.litiengine.graphics.emitters.Emitter {
public void delete() {
    this.deactivate();
    if (Game.world().environment() != null) {
      Game.world().environment().remove(this);
    }
}public void activate() {
    if (this.activated) {
      return;
    }

    this.activated = true;
    this.activationTick = Game.time().now();
    Game.loop().attach(this);
}@Override
  public void update() {
    if (this.isPaused()) {
      return;
    }

    // clear particles if the effect time to life is reached
    if (this.isFinished()) {
      for (EmitterFinishedListener listener : this.finishedListeners) {
        listener.finished(this);
      }

      this.delete();
      return;
    }

    final float updateRatio = (float) this.data().getUpdateRate() / Game.loop().getTickRate();
    for (final Particle p : this.getParticles().stream().collect(Collectors.toList())) {
      if (this.particleCanBeRemoved(p)) {
        // remove dead particles
        this.particles.remove(p);
        continue;
      }

      p.update(this.getOrigin(), updateRatio);
    }

    this.aliveTime = Game.time().since(this.activationTick);
    if ((this.data().getSpawnRate() == 0
        || Game.time().since(this.lastSpawn) >= this.data().getSpawnRate())) {
      this.lastSpawn = Game.time().now();
      this.spawnParticle();
    }
}
}
```
```java
class de.gurkenlabs.litiengine.GameLoop {
@Override
  public int perform(int delay, Runnable action) {
    final long d = Game.time().toTicks(delay);

    TimedAction a = new TimedAction(this.getTicks() + d, action);
    this.actions.add(a);

    return a.getId();
}
}
```
```java
class de.gurkenlabs.litiengine.environment.EntitySpawner {
protected boolean shouldSpawn() {
    return this.lastSpawnWave == 0
        || Game.time().since(this.lastSpawnWave) >= this.getSpawnInterval();
}@Override
  public void update() {
    if (!this.shouldSpawn()) {
      return;
    }

    this.spawnNewEntities();
    this.lastSpawnWave = Game.time().now();
}
}
```
```java
class de.gurkenlabs.litiengine.graphics.FreeFlightCamera {
@Override
  public void update() {
    this.handleFreeFlightCamera();
}public FreeFlightCamera(double x, double y) {
    this(new Point2D.Double(x, y));
}
}
```
```java
class de.gurkenlabs.litiengine.environment.Environment {
public void unload() {
    if (!this.loaded) {
      return;
    }

    // unregister all updatable entities from the current environment
    for (final IEntity entity : this.allEntities.values()) {
      this.unload(entity);
    }

    this.loaded = false;
    this.fireEvent(l -> l.unloaded(this));
}private static void loadUpdatableOrEmitterEntity(IEntity entity) {
    if (entity instanceof Emitter) {
      final Emitter emitter = (Emitter) entity;
      if (emitter.isActivateOnInit()) {
        emitter.activate();
      }
    } else if (entity instanceof IUpdateable) {
      Game.loop().attach((IUpdateable) entity);
    }
}public void clear() {
    Game.physics().clear();

    this.combatEntities.clear();
    this.mobileEntities.clear();
    this.gravityForces.clear();
    this.layerEntities.clear();
    this.entitiesByTag.clear();
    this.allEntities.clear();

    for (RenderType renderType : RenderType.values()) {
      this.miscEntities.get(renderType).clear();
      this.renderListeners.get(renderType).clear();
      this.renderables.get(renderType).clear();
    }

    dispose(this.allEntities.values());
    dispose(this.triggers);
    this.emitters.clear();
    this.colliders.clear();
    this.props.clear();
    this.creatures.clear();
    this.staticShadows.clear();
    this.combatEntities.clear();
    this.mobileEntities.clear();
    this.lightSources.clear();
    this.spawnPoints.clear();
    this.soundSources.clear();
    this.mapAreas.clear();
    this.triggers.clear();

    this.ambientLight = null;
    this.staticShadowLayer = null;

    for (Map<Integer, IEntity> type : this.miscEntities.values()) {
      type.clear();
    }

    this.initialized = false;

    this.fireEvent(l -> l.cleared(this));
}private void load(final IEntity entity) {
    // an entity can only exist on one environment at a time, so remove it from the current one
    if (entity.getEnvironment() != null) {
      entity.getEnvironment().remove(entity);
    }

    // 1. add to physics engine
    loadPhysicsEntity(entity);

    // 2. register for update or activate
    loadUpdatableOrEmitterEntity(entity);

    // 3. if a gravity is defined, add a gravity force to the entity
    if (entity instanceof IMobileEntity && this.getGravity() != 0) {
      this.addGravityForce((IMobileEntity) entity);
    }

    // 4. attach all controllers
    entity.attachControllers();

    if (this.loaded && (entity instanceof LightSource || entity instanceof StaticShadow)) {
      this.updateLighting(entity);
    }

    entity.loaded(this);
}private void unload(final IEntity entity) {
    // 1. remove from physics engine
    if (entity instanceof ICollisionEntity) {
      Game.physics().remove((ICollisionEntity) entity);
    }

    // 2. unregister from update
    if (entity instanceof IUpdateable) {
      Game.loop().detach((IUpdateable) entity);
    }

    if (entity instanceof IMobileEntity) {
      this.removeGravity((IMobileEntity) entity);
    }

    // 3. detach all controllers
    entity.detachControllers();

    if (entity instanceof Emitter) {
      Emitter em = (Emitter) entity;
      em.deactivate();
    }

    if (this.loaded && (entity instanceof LightSource || entity instanceof StaticShadow)) {
      this.updateLighting(entity);
    }

    entity.removed(this);
}public void remove(final IEntity entity) {
    if (entity == null) {
      return;
    }

    this.allEntities.remove(entity.getMapId());
    Iterator<List<IEntity>> iter = this.layerEntities.values().iterator();
    while (iter.hasNext()) {
      List<IEntity> layer = iter.next();
      if (layer.remove(entity) && layer.isEmpty()) {
        iter.remove();
      }
    }
    if (this.miscEntities.get(entity.getRenderType()) != null) {
      this.miscEntities.get(entity.getRenderType()).values().remove(entity);
    }

    for (String tag : entity.getTags()) {
      if (this.getEntitiesByTag().containsKey(tag)) {
        this.getEntitiesByTag().get(tag).remove(entity);

        if (this.getEntitiesByTag().get(tag).isEmpty()) {
          this.getEntitiesByTag().remove(tag);
        }
      }
    }

    if (entity instanceof Emitter) {
      Emitter emitter = (Emitter) entity;
      this.removeEmitter(emitter);
    }

    if (entity instanceof MapArea) {
      this.mapAreas.remove(entity);
    }

    if (entity instanceof Prop) {
      this.props.remove(entity);
    }

    if (entity instanceof Creature) {
      this.creatures.remove(entity);
    }

    if (entity instanceof CollisionBox) {
      this.colliders.remove(entity);
      this.staticShadows.removeIf(x -> x.getOrigin() != null && x.getOrigin().equals(entity));
    }

    if (entity instanceof LightSource) {
      this.lightSources.remove(entity);
      this.updateLighting(entity);
    }

    if (entity instanceof Trigger) {
      this.triggers.remove(entity);
    }

    if (entity instanceof Spawnpoint) {
      this.spawnPoints.remove(entity);
    }
    if (entity instanceof SoundSource) {
      this.soundSources.remove(entity);
    }

    if (entity instanceof StaticShadow) {
      this.staticShadows.remove(entity);
      this.updateLighting(entity);
    }

    if (entity instanceof IMobileEntity) {
      this.mobileEntities.values().remove(entity);
    }

    if (entity instanceof ICombatEntity) {
      this.combatEntities.values().remove(entity);
    }

    this.unload(entity);

    this.fireEntityEvent(l -> l.entityRemoved(entity));
}
}
```
```java
class de.gurkenlabs.litiengine.physics.MovementController {
@Override
  public void update() {
    this.handleForces();
    this.handleMovement();
}
}
```
```java
class de.gurkenlabs.litiengine.Game {
static synchronized void terminate() {
    if (!initialized) {
      return;
    }

    hasStarted = false;
    initialized = false;

    config().save();
    gameLoop.terminate();
    tweenEngine.terminate();
    soundEngine.terminate();

    world().clear();

    for (final GameListener listener : gameListeners) {
      try {
        listener.terminated();
      } catch (Exception e) {
        log().log(Level.WARNING, "game listener threw an exception during shutdown", e);
      }
    }

    gameLoop = null;
    screenManager = null;
    gameWindow = null;
}public static synchronized void start() {
    if (!initialized) {
      throw new IllegalStateException(
          "The game cannot be started without being first initialized. Call Game.init(...) before Game.start().");
    }

    gameLoop.start();
    tweenEngine.start();
    soundEngine.start();

    for (final GameListener listener : gameListeners) {
      listener.started();
    }

    hasStarted = true;
}public static synchronized void init(String... args) {
    if (initialized) {
      log().log(Level.INFO, "The game has already been initialized.");
      return;
    }

    log.init();
    handleCommandLineArguments(args);

    config().load();
    Locale.setDefault(new Locale(config().client().getCountry(), config().client().getLanguage()));

    gameLoop = new GameLoop("Main Update Loop", config().client().getMaxFps());
    loop().attach(physics());
    loop().attach(world());

    // setup default exception handling for render and update loop
    setUncaughtExceptionHandler(
        new DefaultUncaughtExceptionHandler(config().client().exitOnError()));

    screenManager = new ScreenManager();
    gameWindow = new GameWindow();

    // initialize  the game window
    window().init();
    world.setCamera(new Camera());

    for (GameListener listener : gameListeners) {
      listener.initialized(args);
    }

    if (!isInNoGUIMode()) {
      window().getRenderComponent().onRendered(g -> metrics().render(g));

      graphics()
          .addEntityRenderedListener(
              e -> DebugRenderer.renderEntityDebugInfo(e.getGraphics(), e.getEntity()));

      window().getRenderComponent().onFpsChanged(fps -> metrics().setFramesPerSecond(fps));
      window()
          .setIcons(
              Arrays.asList(
                  Resources.images().get("liti-logo-x16.png"),
                  Resources.images().get("liti-logo-x20.png"),
                  Resources.images().get("liti-logo-x32.png"),
                  Resources.images().get("liti-logo-x48.png")));

      Input.keyboard()
          .onKeyTyped(
              KeyEvent.VK_PRINTSCREEN,
              key -> {
                // don't take a screenshot if a modifier is active
                if (key.getModifiers() != 0) {
                  return;
                }

                window().getRenderComponent().takeScreenshot();
              });
    }

    Runtime.getRuntime().addShutdownHook(new Thread(Game::terminate, "Shutdown"));

    initialized = true;
}
}
```


Response Format:
Provide the answer in **XML format** as follows:

#### If the method **cannot** return `null` at the specific call site:
```xml
<response>
  <reason><![CDATA[EXPLAIN WHY THE INVOCATION Game.loop() RESULT CANNOT BE NULL.]]></reason>
  <value>NO</value>
</response>

#### If the method can return null at the specific call site:
<response>
  <reason><![CDATA[EXPLAIN WHY THE INVOCATION Game.loop() RESULT CAN BE NULL.]]></reason>
  <value>YES</value>
</response>

#### If you are unsure or If there are any methods that directly or indirectly affect the return value and are not fully disclosed, request their declarations first, in the following format:
<response>
  <reason><![CDATA[EXPLAIN WHY THIS METHOD DECLARATION IS NECESSARY AND WHY YOU CANNOT MAKE A CONFIDENT DECISION WITHOUT IT]]></reason>
  <success>false</success>
  <methods>
    <method>methodName</method>
  </methods>
</response>

Additional Notes:
Be precise in your reasoning.
If a method’s return value depends on another method not provided, request its declaration before making a conclusion.
If the method can return null in this case but not in others, explain why it happens specifically for this call.

---ChatGPT.sendRequestToOpenAI---
Retrieving response from cache
---Response.<init>---
Creating Response:
```xml
<response>
  <reason><![CDATA[The method `Game.loop()` returns the static field `gameLoop`, which is initialized in the `Game.init(String... args)` method. In this method, a new `GameLoop` object is instantiated and assigned to `gameLoop`. Since `init()` must be called before `start()`, which is implied by the requirement of initializing the game, the `gameLoop` is guaranteed to be non-null during the lifetime of the game execution where `Game.loop()` is called. The absence of any code that could set `gameLoop` to null after its initialization ensures that `Game.loop()` cannot return null.]]></reason>
  <value>NO</value>
</response>
```
---Response.<init>---
Response created:
Disagreement: The method `Game.loop()` returns the static field `gameLoop`, which is initialized in the `Game.init(String... args)` method. In this method, a new `GameLoop` object is instantiated and assigned to `gameLoop`. Since `init()` must be called before `start()`, which is implied by the requirement of initializing the game, the `gameLoop` is guaranteed to be non-null during the lifetime of the game execution where `Game.loop()` is called. The absence of any code that could set `gameLoop` to null after its initialization ensures that `Game.loop()` cannot return null.
---AdvancedNullAwayCodeFix.resolveMethodDereferenceError---
Method is not returning nullable on call site. Injecting suppression annotation.
---AdvancedNullAwayCodeFix.constructCastToNonnullChange---
Constructing cast to nonnull change for reason: The method `Game.loop()` returns the static field `gameLoop`, which is initialized in the `Game.init(String... args)` method. In this method, a new `GameLoop` object is instantiated and assigned to `gameLoop`. Since `init()` must be called before `start()`, which is implied by the requirement of initializing the game, the `gameLoop` is guaranteed to be non-null during the lifetime of the game execution where `Game.loop()` is called. The absence of any code that could set `gameLoop` to null after its initialization ensures that `Game.loop()` cannot return null.
---ChatGPT.ask---
Asking ChatGPT:
For the reason you mentioned earlier:

"The method `Game.loop()` returns the static field `gameLoop`, which is initialized in the `Game.init(String... args)` method. In this method, a new `GameLoop` object is instantiated and assigned to `gameLoop`. Since `init()` must be called before `start()`, which is implied by the requirement of initializing the game, the `gameLoop` is guaranteed to be non-null during the lifetime of the game execution where `Game.loop()` is called. The absence of any code that could set `gameLoop` to null after its initialization ensures that `Game.loop()` cannot return null."

in the method below, the expression Game.loop() is not nullable at the point it is used.

```java
AbilityExecution(final Ability ability) {
    this.appliedEffects = new CopyOnWriteArrayList<>();
    this.ability = ability;
    this.executionTicks = Game.time().now();
    this.impactArea = ability.calculateImpactArea();
    this.castLocation = ability.getExecutor().getCenter();
    Game.loop().attach(this);
}
```
Please Summarize the reason in max 5 words and rewrite the method so that at the line "    Game.loop().attach(this);", at the occurrence of: "Game.loop()" is replaced with `NullabilityUtil.castToNonnull(Game.loop(), summary of reason)`
Replace "REASON" with the exact reason summary I provide to you (maximum 5 words), not with a generic explanation like "checked to be nonnull".
see the example below, for expression `foo.getBar()`, to wrap it with `NullabilityUtil.castToNonnull(foo.getBar(), "reason")`.

```java
public t(){
    String l = foo.getBar();
}
```

will be:
```java
public t(){
    String l = NullabilityUtil.castToNonnull(foo.getBar(), "checked to be nonnull");
}
```

### Instructions:

Do not import any additional classes.

Do not add Java comments.

Only modify relevant lines as required.

Return only the modified method wrapped in the XML format shown below.

Place the Java code inside the <code> tag using a CDATA block with ```java formatting.

Just give me the fixed code snippet in XML format in <response> tag like the example below. I will apply the fix to my codebase. Do not import any additional libraries or classes or add java comments. If you can provide the fixed code snippet, please provide it in the following format and place the code snippet in the <code> tag within ```java block.
<response>
  <success>true</success>
  <code><![CDATA[
  ```java
  Your fixed code snippet here
  ```
    ]]>
  </code>
</response>

---ChatGPT.sendRequestToOpenAI---
Retrieving response from cache
---Response.<init>---
Creating Response:
```xml
<response>
  <success>true</success>
  <code><![CDATA[
  ```java
AbilityExecution(final Ability ability) {
    this.appliedEffects = new CopyOnWriteArrayList<>();
    this.ability = ability;
    this.executionTicks = Game.time().now();
    this.impactArea = ability.calculateImpactArea();
    this.castLocation = ability.getExecutor().getCenter();
    NullabilityUtil.castToNonnull(Game.loop(), "initialized in Game.init").attach(this);
}
  ```
  ]]>
  </code>
</response>
```
---Response.<init>---
Response created:
AbilityExecution(final Ability ability) {
    this.appliedEffects = new CopyOnWriteArrayList<>();
    this.ability = ability;
    this.executionTicks = Game.time().now();
    this.impactArea = ability.calculateImpactArea();
    this.castLocation = ability.getExecutor().getCenter();
    NullabilityUtil.castToNonnull(Game.loop(), "initialized in Game.init").attach(this);
}
---ChatGPT.fixDereferenceByAddingCastToNonnull---
Fixing the error by adding castToNonnull
---AdvancedNullAwayCodeFix.fixTriggeredErrorsForLocation---
Resolving unresolvable error for triggered error: Type='DEREFERENCE_NULLABLE', message='dereferenced expression Game.loop() is @Nullable'
/home/nima/Developer/nullness-benchmarks/litiengine/src/de/gurkenlabs/litiengine/physics/MovementController.java:31
    Game.loop().attach(this);
---AdvancedNullAwayCodeFix.fix---
Fixing error: Type='DEREFERENCE_NULLABLE', message='dereferenced expression Game.loop() is @Nullable'
/home/nima/Developer/nullness-benchmarks/litiengine/src/de/gurkenlabs/litiengine/physics/MovementController.java:31
    Game.loop().attach(this);
---AdvancedNullAwayCodeFix.resolveDereferenceError---
Resolving dereference error: Type='DEREFERENCE_NULLABLE', message='dereferenced expression Game.loop() is @Nullable'
/home/nima/Developer/nullness-benchmarks/litiengine/src/de/gurkenlabs/litiengine/physics/MovementController.java:31
    Game.loop().attach(this);
---AdvancedNullAwayCodeFix.resolveDereferenceError---
Checking nullability possibility at error point
---ChatGPT.checkNullabilityPossibilityAtErrorPoint---
Asking if the expression can be null at error point point
---ChatGPT.ask---
Asking ChatGPT:
In the method below, is there a possibility that the expression "Game.loop()" at line "Game.loop().attach(this);" is null?
@Override
  public void attach() {
    Game.loop().attach(this);
}
Give a single-word answer in XML format. If it is possible for the expression to be null, respond with:
```xml
<response>
    <reason><![CDATA[YOUR REASON]]></reason>
    <value>YES</value>
</response>
```
If it is not possible for the expression to be null, respond with:
```xml
<response>
    <reason><![CDATA[YOUR REASON]]></reason>
    <value>NO</value>
</response>
```
If you are unsure or need more information, respond with where you can ask for more details or what specific information you need.

If additional information is required, list each request inside a `<request>` tag. If no additional information is needed, omit the `<requests>` section.

Respond with:
```xml
<response>
    <reason><![CDATA[YOUR REASON]]></reason>
    <value>UNKNOWN</value>
    <!-- Include <requests> only if additional information is needed -->
    <requests>
        <request><![CDATA[YOUR REQUEST 1]]></request>
        <request><![CDATA[YOUR REQUEST 2]]></request>
    </requests>
</response>
```
---ChatGPT.sendRequestToOpenAI---
Retrieving response from cache
---Response.<init>---
Creating Response:
```xml
<response>
    <reason><![CDATA[Without additional information on the implementation details of the Game class and its loop method, it is unclear if Game.loop() can return null.]]></reason>
    <value>UNKNOWN</value>
    <requests>
        <request><![CDATA[Provide the implementation or documentation of the Game.loop() method.]]></request>
        <request><![CDATA[Clarify if there are conditions under which Game.loop() is expected to return null.]]></request>
    </requests>
</response>
```
---Response.<init>---
Response created:
Unknown: Without additional information on the implementation details of the Game class and its loop method, it is unclear if Game.loop() can return null.
---AdvancedNullAwayCodeFix.resolveMethodDereferenceError---
Resolving method dereference error.
---AdvancedNullAwayCodeFix.resolveMethodDereferenceError---
Method is in annotated package. Checking if the method is returning nullable.
---AdvancedNullAwayCodeFix.investigateMethodReturnNullability---
Checking if the method is returning nullable.
---ChatGPT.checkIfMethodIsReturningNullable---
Asking if the method is returning nullable: loop()
---ChatGPT.ask---
Asking ChatGPT:
In the method below, is there a possibility that the method returns null based only on its body? Consider the following points:

- The method may have multiple return paths; consider all return statements.
- If the method calls another method, do not assume its return value unless its full declaration is provided. Request its declaration if needed.
- The method may throw an exception instead of returning null. An exception path should not be considered a null return.
- Ensure you request the declarations of any methods whose return values directly or indirectly impact this method’s return value before making a conclusion.
- Carefully analyze all conditions and prior operations that may guarantee a non-null return value.

@Nullable public static IGameLoop loop() {
    return gameLoop;
}

Here are the method definitions in addition to the method inquired:

Depth: 0
```java
class de.gurkenlabs.litiengine.Game {
@Nullable public static IGameLoop loop() {
    return gameLoop;
}
}
```


Response Format:
Provide the answer in **XML format** as follows:

#### If the method **cannot** return `null`:
```xml
<response>
  <reason><![CDATA[EXPLAIN WHY THE METHOD CANNOT RETURN NULL]]></reason>
  <value>NO</value>
</response>
```

#### If the method can return null:
```xml
<response>
  <reason><![CDATA[EXPLAIN WHY THE METHOD CAN RETURN NULL]]></reason>
  <value>YES</value>
</response>
```

#### If you are unsure or need more information, respond with where you can ask for more details or what specific information you need.

#### If you are unsure or If there are any methods that directly or indirectly affect the return value and are not fully disclosed, request their declarations first, in the following format:
<response>
  <reason><![CDATA[YOUR REASON]]></reason>
  <value>UNKNOWN</value>
  <methods>
    <method>methodName</method>
  </methods>
</response>

If additional information is required other than method declaration, list each request inside a `<request>` tag. If no additional information is needed, omit the `<requests>` section.

Respond with:
```xml
<response>
    <reason><![CDATA[YOUR REASON]]></reason>
    <value>UNKNOWN</value>
    <!-- Include <requests> only if additional information is needed -->
    <requests>
        <request><![CDATA[YOUR REQUEST 1]]></request>
        <request><![CDATA[YOUR REQUEST 2]]></request>
    </requests>
</response>
```

Additional Notes:
Be precise in your reasoning.
If a method’s return value depends on another method not provided, request its declaration before making a conclusion.
If the method can return null in some cases but not others, explain under what conditions it can happen.

---ChatGPT.sendRequestToOpenAI---
Retrieving response from cache
---Response.<init>---
Creating Response:
```xml
<response>
  <reason><![CDATA[The method `loop` returns the variable `gameLoop`. Without the initialization or assignment details of `gameLoop`, it's unclear whether it can be null. The possibility of `gameLoop` being uninitialized or set to null elsewhere in the program means `loop` could potentially return null. Further information on `gameLoop` is required.]]></reason>
  <value>UNKNOWN</value>
  <requests>
    <request><![CDATA[Please provide the declaration and initialization of the variable `gameLoop` in the class `de.gurkenlabs.litiengine.Game`.]]></request>
  </requests>
</response>
```
---Response.<init>---
Response created:
Unknown: The method `loop` returns the variable `gameLoop`. Without the initialization or assignment details of `gameLoop`, it's unclear whether it can be null. The possibility of `gameLoop` being uninitialized or set to null elsewhere in the program means `loop` could potentially return null. Further information on `gameLoop` is required.
---AdvancedNullAwayCodeFix.investigateMethodReturnNullability---
Could not determine the nullability and model did not ask for any method.
---ChatGPT.checkIfMethodIsReturningNullableOnCallSite---
Asking if the method is returning nullable on the call site: Game.loop()
---ChatGPT.ask---
Asking ChatGPT:
In the method below, is there a possibility that the method returns null at the given call site?

```java
@Nullable public static IGameLoop loop() {
    return gameLoop;
}
```

## Guidelines:
- The method may have multiple return paths; consider all return statements.
- If the method calls another method, do not assume its return value unless its full declaration is provided. Request its declaration if needed.
- The method may throw an exception instead of returning null. An exception path should not be considered a null return.
- Ensure you request the declarations of any methods whose return values directly or indirectly impact this method’s return value before making a conclusion.
- If the method returns a value that is determined by a parameter, evaluate based on the actual argument at the given call site.
- Analyze based only on the specific invocation provided. Do not generalize to all possible inputs.- If the return value is guaranteed to be non-null at the call site, the answer should be a definitive NO.
- Do not generalize based on all possible inputs—your answer must be based only on the given invocation.
- Focus only on the given call site, not all possible invocations.

### call site:
Game.loop()

Here are the method definitions and the call chain for this method, showing the sequence of calls from the method to its callers at each depth level:

Depth: 0
```java
class de.gurkenlabs.litiengine.Game {
@Nullable public static IGameLoop loop() {
    return gameLoop;
}
}
```
Depth: 1
```java
class de.gurkenlabs.litiengine.environment.GameWorld {
public void loadEnvironment(@Nullable final Environment env) {
    Lock lock = Game.loop().getLock();
    lock.lock();
    try {
      unloadEnvironment();
      this.environment = env;
      if (env != null) {
        this.addEnvironment(env);

        if (env.getGravity() == 0 && this.gravity() != 0) {
          env.setGravity(this.gravity());
        }

        env.load();
        for (final EnvironmentLoadedListener listener : this.loadedListeners) {
          listener.loaded(env);
        }

        // call map specific listeners
        String mapName = getMapName(env);
        if (mapName != null && this.environmentLoadedListeners.containsKey(mapName)) {

          // for the default camera we center the camera on the environment
          if (this.camera().getClass().equals(Camera.class)) {
            camera().setFocus(env.getCenter());
          }

          for (EnvironmentLoadedListener listener : this.environmentLoadedListeners.get(mapName)) {
            listener.loaded(env);
          }
        }
      }
    } finally {
      lock.unlock();
    }
}public void setCamera(@Nullable final ICamera cam) {
    if (this.camera() != null) {
      Game.loop().detach(camera);
    }

    camera = cam;

    if (cam != null && !Game.isInNoGUIMode()) {
      Game.loop().attach(cam);
      cam.updateFocus();
    }
}
}
```
```java
class de.gurkenlabs.litiengine.entities.behavior.EntityNavigator {
public EntityNavigator(final IMobileEntity entity, final PathFinder pathFinder) {
    this.cancelNavigationConditions = new CopyOnWriteArrayList<>();
    this.listeners = new CopyOnWriteArrayList<>();
    this.entity = entity;
    this.pathFinder = pathFinder;
    this.setAcceptableError(DEFAULT_ACCEPTABLE_ERROR);
    Game.loop().attach(this);
}
}
```
```java
class de.gurkenlabs.litiengine.GameWindow {
private static void initializeWindowEventListeners(Window window) {

    window.addWindowStateListener(
        e -> {
          if (e.getNewState() == Frame.ICONIFIED) {
            Game.loop().setTickRate(ICONIFIED_MAX_FPS);
          } else {
            Game.loop().setTickRate(Game.config().client().getMaxFps());
          }
        });

    window.addWindowFocusListener(
        new WindowFocusListener() {
          @Override
          public void windowLostFocus(WindowEvent e) {
            if (Game.config().graphics().reduceFramesWhenNotFocused()) {
              Game.loop().setTickRate(NONE_FOCUS_MAX_FPS);
            }
          }

          @Override
          public void windowGainedFocus(WindowEvent e) {
            Game.loop().setTickRate(Game.config().client().getMaxFps());
          }
        });

    window.addWindowListener(
        new WindowAdapter() {
          @Override
          public void windowClosing(final WindowEvent event) {
            Game.exit();
          }
        });
}
}
```
```java
class de.gurkenlabs.litiengine.gui.screens.ScreenManager {
public void display(@Nullable final Screen screen) {
    if (Game.hasStarted() && Game.time().since(this.lastScreenChange) < this.getChangeCooldown()) {
      log.log(
          Level.INFO,
          "Skipping displaying of screen {0} because screen changing is currently on cooldown.",
          screen != null ? screen.getName() : "");
      return;
    }

    final Screen previous = this.current();
    if (previous != null) {
      previous.suspend();
    }

    if (screen != null && !this.screens.contains(screen)) {
      this.screens.add(screen);
    }

    this.currentScreen = screen;
    if (!Game.isInNoGUIMode() && this.current() != null) {
      this.current().prepare();
    }

    this.lastScreenChange = Game.loop().getTicks();

    final ScreenChangedEvent event = new ScreenChangedEvent(this.current(), previous);
    for (final ScreenChangedListener listener : this.screenChangedListeners) {
      listener.changed(event);
    }
}
}
```
```java
class de.gurkenlabs.litiengine.abilities.effects.Effect {
@Override
  public void update() {

    for (final Iterator<EffectApplication> iterator = this.getActiveAppliances().iterator();
        iterator.hasNext(); ) {
      final EffectApplication appliance = iterator.next();
      // if the effect duration is reached
      if (this.hasEnded(appliance)) {

        iterator.remove();
        this.cease(appliance);
      }
    }

    // 4. unregister if all appliances are finished
    if (this.getActiveAppliances().isEmpty()) {
      Game.loop().detach(this);
    }
}public void apply(final Shape impactArea) {
    final List<ICombatEntity> affected = this.lookForAffectedEntities(impactArea);
    for (final ICombatEntity affectedEntity : affected) {
      this.apply(affectedEntity);
    }

    this.appliances.add(new EffectApplication(affected, impactArea));

    // if it is the first appliance -> register for update
    if (this.appliances.size() == 1) {
      Game.loop().attach(this);
    }
}
}
```
```java
class de.gurkenlabs.litiengine.GameTime {
public long toTicks(final int milliseconds) {
    return this.toTicks(milliseconds, Game.loop().getTickRate());
}public long since(final long tick) {
    return toMilliseconds(Game.loop().getTicks() - tick);
}public long now() {
    return Game.loop().getTicks();
}public long sinceGameStart() {
    return this.toMilliseconds(Game.loop().getTicks());
}@Override
  public void loaded(Environment environment) {
    environmentLoaded = Game.loop().getTicks();
}public long toMilliseconds(final long ticks) {
    return this.toMilliseconds(ticks, Game.loop().getTickRate());
}
}
```
```java
class de.gurkenlabs.litiengine.GameMetrics {
@Override
  public void render(final Graphics2D g) {
    this.updateMetrics();

    if (!Game.config().client().showGameMetrics()) {
      return;
    }

    this.currentOffsetY = 0;

    g.setColor(this.renderColor);

    // render client metrics
    this.drawTitle(g, "[client]");
    this.drawMetric(g, "fps       : " + this.getFramesPerSecond());
    this.drawMetric(g, "max fps   : " + this.maxFramesPerSecond);
    this.drawMetric(g, "updatables: " + Game.loop().getUpdatableCount());

    // render jvm metrics if debug is enabled
    if (Game.config().debug().isDebugEnabled()) {
      this.drawTitle(g, "[jvm]");
      this.drawMetric(g, "java      : " + this.javaVersion);
      this.drawMetric(g, "memory    : " + String.format("%-5.5s", this.usedMemory) + " MB");
      this.drawMetric(g, "threads   : " + Thread.activeCount());
    }

    // render rendering metrics
    if (!this.renderMetrics.isEmpty()) {
      this.drawTitle(g, "[update]");

      for (RenderMetrics metric : this.renderMetrics) {
        this.drawMetric(g, metric.toString());
      }

      this.renderMetrics.clear();
    }
}
}
```
```java
class de.gurkenlabs.litiengine.graphics.emitters.Emitter {
public void deactivate() {
    if (!this.activated) {
      return;
    }

    this.activated = false;
    this.getParticles().clear();
    this.aliveTime = 0;
    this.activationTick = 0;
    this.lastSpawn = 0;
    Game.loop().detach(this);
}public void activate() {
    if (this.activated) {
      return;
    }

    this.activated = true;
    this.activationTick = Game.time().now();
    Game.loop().attach(this);
}@Override
  public void update() {
    if (this.isPaused()) {
      return;
    }

    // clear particles if the effect time to life is reached
    if (this.isFinished()) {
      for (EmitterFinishedListener listener : this.finishedListeners) {
        listener.finished(this);
      }

      this.delete();
      return;
    }

    final float updateRatio = (float) this.data().getUpdateRate() / Game.loop().getTickRate();
    for (final Particle p : this.getParticles().stream().collect(Collectors.toList())) {
      if (this.particleCanBeRemoved(p)) {
        // remove dead particles
        this.particles.remove(p);
        continue;
      }

      p.update(this.getOrigin(), updateRatio);
    }

    this.aliveTime = Game.time().since(this.activationTick);
    if ((this.data().getSpawnRate() == 0
        || Game.time().since(this.lastSpawn) >= this.data().getSpawnRate())) {
      this.lastSpawn = Game.time().now();
      this.spawnParticle();
    }
}
}
```
```java
class de.gurkenlabs.litiengine.entities.behavior.IBehaviorController {
public default void attach() {
    Game.loop().attach(this);
}public default void detach() {
    Game.loop().detach(this);
}
}
```
```java
class de.gurkenlabs.litiengine.abilities.AbilityExecution {
AbilityExecution(final Ability ability) {
    this.appliedEffects = new CopyOnWriteArrayList<>();
    this.ability = ability;
    this.executionTicks = Game.time().now();
    this.impactArea = ability.calculateImpactArea();
    this.castLocation = ability.getExecutor().getCenter();
    Game.loop().attach(this);
}@Override
  public void update() {
    // if there a no effects to apply -> unregister this instance and we're done
    if (this.getAbility().getEffects().isEmpty()
        || this.getAbility().getEffects().size() == this.getAppliedEffects().size()) {
      Game.loop().detach(this);
      return;
    }

    // handle all effects from the ability that were not applied yet
    for (final Effect effect : this.getAbility().getEffects()) {
      // if the ability was not executed yet or the delay of the effect is not
      // yet reached
      if (this.getAppliedEffects().contains(effect)
          || Game.time().since(this.getExecutionTicks()) < effect.getDelay()) {
        continue;
      }

      effect.apply(this.getExecutionImpactArea());
      this.getAppliedEffects().add(effect);
    }
}
}
```
```java
class de.gurkenlabs.litiengine.GameWindow$3 {
@Override
          public void windowGainedFocus(WindowEvent e) {
            Game.loop().setTickRate(Game.config().client().getMaxFps());
}@Override
          public void windowLostFocus(WindowEvent e) {
            if (Game.config().graphics().reduceFramesWhenNotFocused()) {
              Game.loop().setTickRate(NONE_FOCUS_MAX_FPS);
            }
}
}
```
```java
class de.gurkenlabs.litiengine.environment.EntitySpawner {
protected void spawnNewEntities() {
    if (this.getSpawnMode() != SpawnMode.CUSTOMSPAWNPOINTS && this.getSpawnPoints().isEmpty()) {
      return;
    }

    switch (this.getSpawnMode()) {
      case ALLSPAWNPOINTS:
        for (int i = 0; i < this.getSpawnPoints().size(); i++) {
          final int index = i;
          Game.loop()
              .perform(
                  this.getSpawnDelay() + this.getSpawnDelay() * i,
                  () -> this.spawn(this.getSpawnPoints().get(index), this.getSpawnAmount()));
        }
        break;
      case ONERANDOMSPAWNPOINT:
        this.spawn(Game.random().choose(this.getSpawnPoints()), this.getSpawnAmount());
        break;
      case RANDOMSPAWNPOINTS:
        for (int i = 0; i < this.getSpawnAmount(); i++) {
          Game.loop()
              .perform(
                  this.getSpawnDelay() + this.getSpawnDelay() * i,
                  () -> this.spawn(Game.random().choose(this.getSpawnPoints()), 1));
        }
        break;
      case CUSTOMSPAWNPOINTS:
        List<Spawnpoint> spawnPoints =
            this.customSpawnpoints != null
                ? this.customSpawnpoints.apply(this)
                : this.getCustomSpawnpoints();

        int index = 0;
        for (Spawnpoint spawn : spawnPoints) {
          Game.loop()
              .perform(
                  this.getSpawnDelay() + this.getSpawnDelay() * index, () -> this.spawn(spawn, 1));
          index++;
        }
        break;
      default:
        break;
    }
}
}
```
```java
class de.gurkenlabs.litiengine.tweening.TweenEngine {
@Override
  public void start() {
    Game.loop().attach(this);
}@Override
  public void terminate() {
    Game.loop().detach(this);
}
}
```
```java
class de.gurkenlabs.litiengine.gui.SpeechBubble {
public void hide() {
    Game.world().environment().removeRenderable(this);
    Game.loop().detach(this);
    if (activeSpeechBubbles.get(this.getEntity()) != null
        && activeSpeechBubbles.remove(this.getEntity()).equals(this)) {
      activeSpeechBubbles.remove(this.getEntity());
    }

    for (SpeechBubbleListener listener : this.listeners) {
      listener.hidden();
    }
}private SpeechBubble(
      final IEntity entity,
      final String text,
      @Nullable SpeechBubbleAppearance appearance,
      @Nullable Font font) {
    if (appearance == null) {
      this.appearance = DEFAULT_APPEARANCE;
    } else {
      this.appearance = appearance;
    }

    final SpeechBubble active = activeSpeechBubbles.get(entity);
    if (active != null) {
      active.hide();
    }
    this.setFont(font);

    this.textBoxWidth = (float) (entity.getWidth() * 4);
    this.entity = entity;

    this.currentText = text;
    this.currentTextDisplayTime = DISPLAYTIME_MIN + text.length() * DISPLAYTIME_PER_LETTER;

    this.lastTextDisplay = Game.time().now();
    this.createBubbleImage();
    entity.getEnvironment().add(this, RenderType.UI);
    Game.loop().attach(this);
    activeSpeechBubbles.put(entity, this);
}
}
```
```java
class de.gurkenlabs.litiengine.entities.Prop {
private void updateAnimationController() {
    IEntityAnimationController<?> controller = this.createAnimationController();
    this.getControllers().addController(controller);
    if (Game.world().environment() != null && Game.world().environment().isLoaded()) {
      Game.loop().attach(controller);
    }
}
}
```
```java
class de.gurkenlabs.litiengine.graphics.FreeFlightCamera {
public FreeFlightCamera(final Point2D focus) {
    this.setFocus(focus);
    this.velocity = DEFAULT_SCROLL_PIXELS_PER_SECOND;
    this.scrollPadding = DEFAULT_SCROLL_PADDING;
    this.setClampToMap(true);

    Game.loop().attach(this);
}private void handleFreeFlightCamera() {
    if (Game.world().environment() == null || Game.world().environment().getMap() == null) {
      return;
    }

    final Point2D mouseLocation = Input.mouse().getLocation();

    final double scrollSpeed =
        this.getVelocity()
            / (double) Game.loop().getTickRate()
            * Game.config().input().getMouseSensitivity();

    double x = this.getFocus().getX();
    double y = this.getFocus().getY();

    double deltaX = 0;
    if (mouseLocation.getX() < this.getScrollPadding()) {
      deltaX -= scrollSpeed;
    } else if (Game.window().getResolution().getWidth() - mouseLocation.getX()
        < this.getScrollPadding()) {
      deltaX += scrollSpeed;
    }

    double deltaY = 0;
    if (mouseLocation.getY() < this.getScrollPadding()) {
      deltaY -= scrollSpeed;
    } else if (Game.window().getResolution().getHeight() - mouseLocation.getY()
        < this.getScrollPadding()) {
      deltaY += scrollSpeed;
    }

    x += deltaX;
    y += deltaY;

    this.setFocus(new Point2D.Double(x, y));
}
}
```
```java
class de.gurkenlabs.litiengine.environment.Environment {
private static void dispose(final Collection<? extends IEntity> entities) {
    for (final IEntity entity : entities) {
      if (entity instanceof IUpdateable) {
        Game.loop().detach((IUpdateable) entity);
      }

      entity.detachControllers();
    }
}private static void loadUpdatableOrEmitterEntity(IEntity entity) {
    if (entity instanceof Emitter) {
      final Emitter emitter = (Emitter) entity;
      if (emitter.isActivateOnInit()) {
        emitter.activate();
      }
    } else if (entity instanceof IUpdateable) {
      Game.loop().attach((IUpdateable) entity);
    }
}private void unload(final IEntity entity) {
    // 1. remove from physics engine
    if (entity instanceof ICollisionEntity) {
      Game.physics().remove((ICollisionEntity) entity);
    }

    // 2. unregister from update
    if (entity instanceof IUpdateable) {
      Game.loop().detach((IUpdateable) entity);
    }

    if (entity instanceof IMobileEntity) {
      this.removeGravity((IMobileEntity) entity);
    }

    // 3. detach all controllers
    entity.detachControllers();

    if (entity instanceof Emitter) {
      Emitter em = (Emitter) entity;
      em.deactivate();
    }

    if (this.loaded && (entity instanceof LightSource || entity instanceof StaticShadow)) {
      this.updateLighting(entity);
    }

    entity.removed(this);
}
}
```
```java
class de.gurkenlabs.litiengine.graphics.animation.Animation {
@Override
  public void update() {
    // do nothing if the animation is not playing or the current keyframe is not finished
    if (!this.isPlaying()
        || Game.time().since(this.lastFrameUpdate) < this.getCurrentKeyFrame().getDuration()) {
      return;
    }

    // if we are not looping and the last keyframe is finished, we terminate the animation
    if (!this.isLooping() && this.isLastKeyFrame()) {
      this.terminate();
      return;
    }

    // make sure, we stay inside the keyframe list
    final int newFrameIndex =
        (this.getKeyframes().indexOf(this.currentFrame) + 1) % this.getKeyframes().size();
    final KeyFrame previousFrame = this.currentFrame;
    this.currentFrame = this.getKeyframes().get(newFrameIndex);

    for (KeyFrameListener listener : this.listeners) {
      listener.currentFrameChanged(previousFrame, this.currentFrame);
    }

    this.lastFrameUpdate = Game.loop().getTicks();
}public void restart() {
    this.currentFrame = this.firstFrame;
    this.lastFrameUpdate = Game.loop().getTicks();
}
}
```
```java
class de.gurkenlabs.litiengine.physics.MovementController {
@Override
  public void attach() {
    Game.loop().attach(this);
}private void handleForces() {
    // clean up forces
    this.activeForces.forEach(
        x -> {
          if (x.hasEnded()) {
            this.activeForces.remove(x);
          }
        });

    if (this.activeForces.isEmpty()) {
      return;
    }

    // disable turn-on-move for force handling
    boolean turn = this.getEntity().turnOnMove();
    this.getEntity().setTurnOnMove(false);
    try {
      double deltaX = 0;
      double deltaY = 0;
      for (final Force force : this.activeForces) {
        if (force.cancelOnReached() && force.hasReached(this.getEntity())) {
          force.end();
          continue;
        }

        final Point2D collisionBoxCenter = this.getEntity().getCollisionBoxCenter();
        final double angle =
            GeometricUtilities.calcRotationAngleInDegrees(collisionBoxCenter, force.getLocation());
        final double strength =
            Game.loop().getDeltaTime() * 0.001f * force.getStrength() * Game.loop().getTimeScale();
        deltaX += GeometricUtilities.getDeltaX(angle, strength);
        deltaY += GeometricUtilities.getDeltaY(angle, strength);
      }

      final Point2D target =
          new Point2D.Double(this.getEntity().getX() + deltaX, this.getEntity().getY() + deltaY);
      final boolean success = Game.physics().move(this.getEntity(), target);
      if (!success) {
        for (final Force force : this.activeForces) {
          if (force.cancelOnCollision()) {
            force.end();
          }
        }
      }
    } finally {
      this.getEntity().setTurnOnMove(turn);
    }
}@Override
  public void detach() {
    Game.loop().detach(this);
}public void handleMovement() {
    if (!this.isMovementAllowed()) {
      this.velocity = 0;
      return;
    }

    // max distance an entity can travel within one tick
    final double maxPixelsPerTick = this.getEntity().getTickVelocity();
    final double deltaTime = Game.loop().getDeltaTime() * Game.loop().getTimeScale();

    final double acceleration =
        this.getEntity().getAcceleration() == 0
            ? maxPixelsPerTick
            : deltaTime / this.getEntity().getAcceleration() * maxPixelsPerTick;
    final double deceleration =
        this.getEntity().getDeceleration() == 0
            ? this.getVelocity()
            : deltaTime / this.getEntity().getDeceleration() * maxPixelsPerTick;

    double dx = this.getDx();
    double dy = this.getDy();
    this.setDx(0);
    this.setDy(0);

    final double deltaVelocity =
        Math.min(Math.sqrt(Math.pow(dx, 2) + Math.pow(dy, 2)), acceleration);
    if (deltaVelocity != 0) {
      double newVelocity = this.getVelocity() + deltaVelocity;
      this.setVelocity(newVelocity);
    } else {
      final double newVelocity = Math.max(0, this.getVelocity() - deceleration);
      this.setVelocity(newVelocity);
      dx = GeometricUtilities.getDeltaX(this.moveAngle);
      dy = GeometricUtilities.getDeltaY(this.moveAngle);
    }

    if (this.getVelocity() == 0) {
      this.moveAngle = 0;
      return;
    }

    // actually move entity
    this.moveEntity(dx, dy);
}
}
```
```java
class de.gurkenlabs.litiengine.graphics.animation.AnimationController {
public void detach() {
    Game.loop().detach(this);
}public void attach() {
    Game.loop().attach(this);
}
}
```
```java
class de.gurkenlabs.litiengine.graphics.Camera {
@Override
  public void setZoom(final float targetZoom, final int delay) {
    if (delay == 0) {

      this.zoom = targetZoom;
      this.targetZoom = 0;
      this.zoomDelay = 0;
      this.zoomTick = 0;
      this.zoomStep = 0;

      final ZoomChangedEvent event = new ZoomChangedEvent(this, targetZoom);
      for (final ZoomChangedListener listener : this.zoomListeners) {
        listener.zoomChanged(event);
      }
    } else {
      this.zoomTick = Game.time().now();
      this.targetZoom = targetZoom;
      this.zoomDelay = delay;

      final double tickduration = 1000 / (double) Game.loop().getTickRate();
      final double tickAmount = delay / tickduration;
      final float totalDelta = this.targetZoom - this.zoom;
      this.zoomStep = tickAmount > 0 ? (float) (totalDelta / tickAmount) : totalDelta;
    }
}
}
```
```java
class de.gurkenlabs.litiengine.Game {
public static synchronized void init(String... args) {
    if (initialized) {
      log().log(Level.INFO, "The game has already been initialized.");
      return;
    }

    log.init();
    handleCommandLineArguments(args);

    config().load();
    Locale.setDefault(new Locale(config().client().getCountry(), config().client().getLanguage()));

    gameLoop = new GameLoop("Main Update Loop", config().client().getMaxFps());
    loop().attach(physics());
    loop().attach(world());

    // setup default exception handling for render and update loop
    setUncaughtExceptionHandler(
        new DefaultUncaughtExceptionHandler(config().client().exitOnError()));

    screenManager = new ScreenManager();
    gameWindow = new GameWindow();

    // initialize  the game window
    window().init();
    world.setCamera(new Camera());

    for (GameListener listener : gameListeners) {
      listener.initialized(args);
    }

    if (!isInNoGUIMode()) {
      window().getRenderComponent().onRendered(g -> metrics().render(g));

      graphics()
          .addEntityRenderedListener(
              e -> DebugRenderer.renderEntityDebugInfo(e.getGraphics(), e.getEntity()));

      window().getRenderComponent().onFpsChanged(fps -> metrics().setFramesPerSecond(fps));
      window()
          .setIcons(
              Arrays.asList(
                  Resources.images().get("liti-logo-x16.png"),
                  Resources.images().get("liti-logo-x20.png"),
                  Resources.images().get("liti-logo-x32.png"),
                  Resources.images().get("liti-logo-x48.png")));

      Input.keyboard()
          .onKeyTyped(
              KeyEvent.VK_PRINTSCREEN,
              key -> {
                // don't take a screenshot if a modifier is active
                if (key.getModifiers() != 0) {
                  return;
                }

                window().getRenderComponent().takeScreenshot();
              });
    }

    Runtime.getRuntime().addShutdownHook(new Thread(Game::terminate, "Shutdown"));

    initialized = true;
}
}
```
```java
class de.gurkenlabs.litiengine.entities.Creature {
protected void updateAnimationController() {
    IEntityAnimationController<?> controller = this.createAnimationController();
    this.getControllers().addController(controller);
    if (Game.world().environment() != null && Game.world().environment().isLoaded()) {
      Game.loop().attach(controller);
    }
}@Override
  public float getTickVelocity() {
    // pixels per ms multiplied by the passed ms
    // ensure that entities don't travel too far in case of lag
    return Math.min(Game.loop().getDeltaTime(), GameLoop.TICK_DELTATIME_LAG)
        * 0.001F
        * this.getVelocity().get()
        * Game.loop().getTimeScale();
}
}
```
Depth: 2
```java
class de.gurkenlabs.litiengine.environment.GameWorld {
public void clear() {
    this.unloadEnvironment();
    this.environments.clear();
    this.setCamera(null);
    Game.physics().clear();

    this.environmentListeners.clear();
    this.environmentLoadedListeners.clear();
    this.environmentUnloadedListeners.clear();

    this.listeners.clear();
    this.loadedListeners.clear();
    this.unloadedListeners.clear();
}@Nullable
  public Environment loadEnvironment(IMap map) {
    Environment env = this.getEnvironment(map);
    this.loadEnvironment(env);
    return env;
}@Nullable
  public Environment loadEnvironment(String mapName) {
    Environment env = this.getEnvironment(mapName);
    this.loadEnvironment(env);
    return env;
}
}
```
```java
class de.gurkenlabs.litiengine.GameWindow {
GameWindow() {
    this.hostControl = new JFrame();

    this.resolutionChangedListeners = new CopyOnWriteArrayList<>();

    this.renderCanvas = new RenderComponent(Game.config().graphics().getResolution());
    this.cursor = new MouseCursor();
    if (!Game.isInNoGUIMode()) {
      this.hostControl.setBackground(Color.BLACK);
      this.hostControl.add(this.renderCanvas);

      this.initializeEventListeners();

      this.hostControl.setTitle(Game.info().getTitle());
      this.hostControl.setDefaultCloseOperation(WindowConstants.DO_NOTHING_ON_CLOSE);
      initializeWindowEventListeners(this.hostControl);
    }
}
}
```
```java
class de.gurkenlabs.litiengine.GameTime {
public long sinceEnvironmentLoad() {
    return this.since(this.environmentLoaded);
}public long since(final long tick) {
    return toMilliseconds(Game.loop().getTicks() - tick);
}public long sinceGameStart() {
    return this.toMilliseconds(Game.loop().getTicks());
}
}
```
```java
class de.gurkenlabs.litiengine.abilities.effects.Effect {
protected void cease(final EffectApplication appliance) {
    // 1. cease the effect for all affected entities
    for (final ICombatEntity entity : appliance.getAffectedEntities()) {
      this.cease(entity);
    }

    // 2. apply follow up effects
    this.getFollowUpEffects().forEach(followUp -> followUp.apply(appliance.getImpactArea()));
}protected boolean hasEnded(final EffectApplication appliance) {
    final long effectDuration = Game.time().since(appliance.getAppliedTicks());
    return effectDuration > this.getDuration();
}
}
```
```java
class de.gurkenlabs.litiengine.abilities.effects.EffectApplication {
protected EffectApplication(final List<ICombatEntity> affectedEntities, final Shape impactArea) {
    this.applied = Game.time().now();
    this.affectedEntities = affectedEntities;
    this.impactArea = impactArea;
}
}
```
```java
class de.gurkenlabs.litiengine.entities.CombatEntity {
@Override
  public boolean wasHit(int timeSpan) {
    return Game.time().since(this.lastHit) < timeSpan;
}@Override
  public void hit(final int damage, @Nullable final Ability ability) {
    if (this.isDead()) {
      return;
    }

    if (!this.isIndestructible()) {
      this.getHitPoints().modifyBaseValue(new AttributeModifier<>(Modification.SUBTRACT, damage));
    }

    final EntityHitEvent event = new EntityHitEvent(this, ability, damage, this.isDead());

    for (final CombatEntityListener listener : this.listeners) {
      listener.hit(event);
    }

    for (final CombatEntityHitListener listener : this.hitListeners) {
      listener.hit(event);
    }

    if (this.isDead()) {
      this.fireDeathEvent();
      this.setCollision(false);
    }

    this.lastHit = Game.time().now();
}
}
```
```java
class de.gurkenlabs.litiengine.graphics.ImageEffect {
protected ImageEffect(final int ttl, final String name) {
    this.ttl = ttl;
    this.name = name;
    this.aliveTick = Game.time().now();
}@Override
  public long getAliveTime() {
    return Game.time().since(this.aliveTick);
}
}
```
```java
class de.gurkenlabs.litiengine.abilities.AbilityExecution {
AbilityExecution(final Ability ability) {
    this.appliedEffects = new CopyOnWriteArrayList<>();
    this.ability = ability;
    this.executionTicks = Game.time().now();
    this.impactArea = ability.calculateImpactArea();
    this.castLocation = ability.getExecutor().getCenter();
    Game.loop().attach(this);
}@Override
  public void update() {
    // if there a no effects to apply -> unregister this instance and we're done
    if (this.getAbility().getEffects().isEmpty()
        || this.getAbility().getEffects().size() == this.getAppliedEffects().size()) {
      Game.loop().detach(this);
      return;
    }

    // handle all effects from the ability that were not applied yet
    for (final Effect effect : this.getAbility().getEffects()) {
      // if the ability was not executed yet or the delay of the effect is not
      // yet reached
      if (this.getAppliedEffects().contains(effect)
          || Game.time().since(this.getExecutionTicks()) < effect.getDelay()) {
        continue;
      }

      effect.apply(this.getExecutionImpactArea());
      this.getAppliedEffects().add(effect);
    }
}
}
```
```java
class de.gurkenlabs.litiengine.tweening.TweenEngine {
@Override
  public void update() {
    for (final Tweenable target : this.getTweens().keySet()) {
      for (final Tween tween : this.getTweens().get(target).values()) {
        if (tween.hasStopped()) {
          continue;
        }
        final long elapsed = Game.time().since(tween.getStartTime());
        if (elapsed >= tween.getDuration()) {
          tween.stop();
          continue;
        }
        final float[] currentValues = new float[tween.getTargetValues().length];
        for (int i = 0; i < tween.getTargetValues().length; i++) {
          currentValues[i] =
              tween.getStartValues()[i]
                  + tween.getEquation().compute(elapsed / (float) tween.getDuration())
                      * (tween.getTargetValues()[i] - tween.getStartValues()[i]);
        }
        tween.getTarget().setTweenValues(tween.getType(), currentValues);
      }
    }
}
}
```
```java
class de.gurkenlabs.litiengine.gui.SpeechBubble {
public static SpeechBubble create(
      final IEntity entity, final String text, SpeechBubbleAppearance appearance, Font font) {
    return new SpeechBubble(entity, text, appearance, font);
}public static SpeechBubble create(final IEntity entity, final Font font, final String text) {
    SpeechBubbleAppearance app =
        new SpeechBubbleAppearance(
            DEFAULT_APPEARANCE.getForeColor(),
            DEFAULT_APPEARANCE.getBackgroundColor1(),
            DEFAULT_APPEARANCE.getBorderColor(),
            DEFAULT_APPEARANCE.getPadding());
    return new SpeechBubble(entity, text, app, font);
}public static SpeechBubble create(final IEntity entity, final String text) {
    return new SpeechBubble(entity, text, null, GuiProperties.getDefaultFont());
}@Override
  public void update() {
    if (this.currentText == null) {
      this.hide();
      return;
    }

    this.entityCenter = Game.world().camera().getViewportLocation(this.getEntity().getCenter());

    // old text was displayed long enough
    if (this.lastTextDisplay != 0
        && Game.time().since(this.lastTextDisplay) > this.currentTextDisplayTime) {
      this.currentText = null;
      this.lastTextDisplay = 0;
      return;
    }

    // display new text
    if (this.textIndex < this.currentText.length()
        && Game.time().since(this.lastCharPoll) > LETTER_WRITE_DELAY) {
      this.textIndex++;
      this.lastCharPoll = Game.time().now();
      if (this.typeSound != null) {
        Game.audio().playSound(this.typeSound, this.getEntity());
      }
    }

    // continue displaying currently displayed text
}private SpeechBubble(
      final IEntity entity,
      final String text,
      final Sound typeSound,
      SpeechBubbleAppearance appearance,
      Font font) {
    this(entity, text, appearance, font);
    this.typeSound = typeSound;
}private SpeechBubble(
      final IEntity entity,
      final String text,
      @Nullable SpeechBubbleAppearance appearance,
      @Nullable Font font) {
    if (appearance == null) {
      this.appearance = DEFAULT_APPEARANCE;
    } else {
      this.appearance = appearance;
    }

    final SpeechBubble active = activeSpeechBubbles.get(entity);
    if (active != null) {
      active.hide();
    }
    this.setFont(font);

    this.textBoxWidth = (float) (entity.getWidth() * 4);
    this.entity = entity;

    this.currentText = text;
    this.currentTextDisplayTime = DISPLAYTIME_MIN + text.length() * DISPLAYTIME_PER_LETTER;

    this.lastTextDisplay = Game.time().now();
    this.createBubbleImage();
    entity.getEnvironment().add(this, RenderType.UI);
    Game.loop().attach(this);
    activeSpeechBubbles.put(entity, this);
}
}
```
```java
class de.gurkenlabs.litiengine.gui.TextFieldComponent {
@Override
  public void render(final Graphics2D g) {
    super.render(g);
    g.setFont(this.getFont());
    final FontMetrics fm = g.getFontMetrics();

    if (this.isSelected() && Game.time().since(this.lastToggled) > this.flickerDelay) {
      this.cursorVisible = !this.cursorVisible;
      this.lastToggled = Game.time().now();
    }
    if (this.isSelected() && this.cursorVisible) {
      final Rectangle2D cursor =
          new Rectangle2D.Double(
              this.getX() + this.getTextX() + fm.stringWidth(this.getTextToRender(g)),
              this.getY() + this.getTextY(),
              this.getFont().getSize2D() * 3 / 5,
              this.getFont().getSize2D() * 1 / 5);
      g.setColor(this.getAppearance().getForeColor());
      g.fill(cursor);
    }
}
}
```
```java
class de.gurkenlabs.litiengine.entities.Prop {
public Prop(
      final Point2D location, @Nullable final String spritesheetName, final Material material) {
    super();
    this.rotation = Rotation.NONE;
    this.spritesheetName = spritesheetName;
    this.material = material;
    this.setLocation(location);
    this.updateAnimationController();
}public void setSpritesheetName(@Nullable final String spriteName) {
    this.spritesheetName = spriteName;
    this.updateAnimationController();
}
}
```
```java
class de.gurkenlabs.litiengine.tweening.Tween {
public Tween begin() {
    this.started = Game.time().now();
    this.stopped = false;
    return this;
}
}
```
```java
class de.gurkenlabs.litiengine.graphics.emitters.particles.Particle {
public void update(final Point2D emitterOrigin, final float updateRatio) {
    if (this.aliveTick == 0) {
      this.aliveTick = Game.time().now();
    }

    this.aliveTime = Game.time().since(this.aliveTick);
    if (this.timeToLiveReached()) {
      return;
    }

    if (this.colliding) {
      return;
    }

    if (this.getDeltaWidth() != 0) {
      this.width += this.getDeltaWidth() * updateRatio;
    }

    if (this.getDeltaHeight() != 0) {
      this.height += this.getDeltaHeight() * updateRatio;
    }

    if (this.getDeltaAngle() != 0) {
      this.angle += this.getDeltaAngle() * updateRatio;
    }

    // test for ray cast collision
    final float targetX = this.x + this.getVelocityX() * updateRatio;
    final float targetY = this.y + this.getVelocityY() * updateRatio;

    if (targetX == this.x && targetY == this.y) {
      return;
    }

    if (this.checkForCollision(emitterOrigin, targetX, targetY)) {
      return;
    }

    if (this.getVelocityX() != 0) {
      this.x = targetX;
    }

    if (this.getVelocityY() != 0) {
      this.y = targetY;
    }

    if (this.getAccelerationX() != 0) {
      this.velocityX += this.getAccelerationX() * updateRatio;
    }

    if (this.getAccelerationY() != 0) {
      this.velocityY += this.getAccelerationY() * updateRatio;
    }
}
}
```
```java
class de.gurkenlabs.litiengine.graphics.animation.Animation {
@Override
  public void start() {
    this.playing = true;
    if (this.getKeyframes().isEmpty()) {
      return;
    }

    this.restart();
}@Override
  public void update() {
    // do nothing if the animation is not playing or the current keyframe is not finished
    if (!this.isPlaying()
        || Game.time().since(this.lastFrameUpdate) < this.getCurrentKeyFrame().getDuration()) {
      return;
    }

    // if we are not looping and the last keyframe is finished, we terminate the animation
    if (!this.isLooping() && this.isLastKeyFrame()) {
      this.terminate();
      return;
    }

    // make sure, we stay inside the keyframe list
    final int newFrameIndex =
        (this.getKeyframes().indexOf(this.currentFrame) + 1) % this.getKeyframes().size();
    final KeyFrame previousFrame = this.currentFrame;
    this.currentFrame = this.getKeyframes().get(newFrameIndex);

    for (KeyFrameListener listener : this.listeners) {
      listener.currentFrameChanged(previousFrame, this.currentFrame);
    }

    this.lastFrameUpdate = Game.loop().getTicks();
}
}
```
```java
class de.gurkenlabs.litiengine.graphics.animation.AnimationController {
@Override
  public void update() {
    for (final Animation animation : this.getAll()) {
      animation.update();
    }

    if (this.getCurrent() != null && this.getCurrent().isPaused()) {
      return;
    }

    final boolean playbackFinished = this.getCurrent() != null && !this.getCurrent().isPlaying();
    if (playbackFinished) {
      for (final AnimationListener listener : this.listeners) {
        listener.finished(this.getCurrent());
      }
    }

    if (this.getCurrent() == null || playbackFinished) {
      if (this.getDefault() != null) {
        this.play(this.getDefault().getName());
      } else {
        this.currentAnimation = null;
      }
    }
}
}
```
```java
class de.gurkenlabs.litiengine.graphics.RenderComponent {
private void handleFade() {
    if (this.fadeOutStart != -1) {
      final long timePassed = Game.time().since(this.fadeOutStart);
      this.currentAlpha = MathUtilities.clamp(1 - timePassed / (float) this.fadeOutTime, 0, 1);
      if (this.currentAlpha == 0f) {
        this.fadeOutStart = -1;
        this.fadeOutTime = -1;
      }

      return;
    }

    if (this.fadeInStart != -1) {
      final long timePassed = Game.time().since(this.fadeInStart);
      this.currentAlpha = MathUtilities.clamp(timePassed / (float) this.fadeInTime, 0, 1);
      if (this.currentAlpha == 1f) {
        this.fadeInStart = -1;
        this.fadeInTime = -1;
        this.currentAlpha = Float.NaN;
      }
    }
}public void fadeOut(final int ms) {
    this.fadeInStart = -1;
    this.fadeInTime = -1;
    this.fadeOutStart = Game.time().now();
    this.fadeOutTime = ms;
}public void fadeIn(final int ms) {
    this.fadeOutStart = -1;
    this.fadeOutTime = -1;
    this.fadeInStart = Game.time().now();
    this.fadeInTime = ms;
}
}
```
```java
class de.gurkenlabs.litiengine.entities.Trigger {
private boolean activate(final IEntity activator, final int tar) {
    if (!this.isLoaded()
        || this.isOneTimeTrigger && this.isActivated
        || this.getActivationType() == TriggerActivation.COLLISION
            && activator != null
            && this.collisionActivated.contains(activator)) {
      return false;
    }

    if (this.getCooldown() > 0 && Game.time().since(this.lastActivation) < this.getCooldown()) {
      return false;
    }

    List<Integer> triggerTargets = this.getTargets(tar);

    final TriggerEvent te = new TriggerEvent(this, activator, triggerTargets);

    if (!this.checkActivationPredicates(te)) {
      return false;
    }

    this.isActivated = true;
    if (activator != null) {
      this.collisionActivated.add(activator);
    }

    // if we actually have a trigger target, we send the message to the target
    for (final int target : triggerTargets) {
      final IEntity entity = this.getEnvironment().get(target);
      if (entity == null) {
        log.log(
            Level.WARNING,
            "trigger [{0}] was activated, but the trigger target [{1}] could not be found on the environment",
            new Object[] {this, target});
        continue;
      }

      entity.sendMessage(this, this.message);
    }

    // also send the trigger event to all registered consumers
    for (final TriggerActivatedListener listener : this.activatedListeners) {
      listener.activated(te);
    }

    if (this.isOneTimeTrigger) {
      this.getEnvironment().remove(this);
    }

    this.lastActivation = Game.time().now();
    return true;
}
}
```
```java
class de.gurkenlabs.litiengine.graphics.Camera {
private boolean isShakeEffectActive() {
    return this.getShakeTick() != 0
        && Game.time().since(this.getShakeTick()) < this.getShakeDuration();
}@Override
  public void update() {
    if (Game.world().camera() != null && !Game.world().camera().equals(this)) {
      return;
    }

    if (this.targetZoom > 0) {
      if (Game.time().since(this.zoomTick) >= this.zoomDelay) {
        this.zoom = this.targetZoom;
        this.targetZoom = 0;
        this.zoomDelay = 0;
        this.zoomTick = 0;
        this.zoomStep = 0;
      } else {
        this.zoom += this.zoomStep;
      }

      final ZoomChangedEvent event = new ZoomChangedEvent(this, this.getZoom());
      for (final ZoomChangedListener listener : this.zoomListeners) {
        listener.zoomChanged(event);
      }
    }

    if (this.panTime > 0) {
      if (--this.panTime <= 0) {
        this.setFocus(this.targetFocus);
        this.targetFocus = null;
      } else {
        double diff = this.panTime / (this.panTime + 1.0);
        this.focus =
            new Point2D.Double(
                this.focus.getX() * diff + this.targetFocus.getX() * (1.0 - diff),
                this.focus.getY() * diff + this.targetFocus.getY() * (1.0 - diff));
      }
    }

    if (!this.isShakeEffectActive()) {
      this.shakeOffsetX = 0;
      this.shakeOffsetY = 0;
      return;
    }

    if (Game.time().since(this.lastShake) > this.shakeDelay) {
      this.shakeOffsetX = this.getShakeIntensity() * ThreadLocalRandom.current().nextGaussian();
      this.shakeOffsetY = this.getShakeIntensity() * ThreadLocalRandom.current().nextGaussian();
      this.lastShake = Game.time().now();
    }
}@Override
  public void setZoom(final float targetZoom, final int delay) {
    if (delay == 0) {

      this.zoom = targetZoom;
      this.targetZoom = 0;
      this.zoomDelay = 0;
      this.zoomTick = 0;
      this.zoomStep = 0;

      final ZoomChangedEvent event = new ZoomChangedEvent(this, targetZoom);
      for (final ZoomChangedListener listener : this.zoomListeners) {
        listener.zoomChanged(event);
      }
    } else {
      this.zoomTick = Game.time().now();
      this.targetZoom = targetZoom;
      this.zoomDelay = delay;

      final double tickduration = 1000 / (double) Game.loop().getTickRate();
      final double tickAmount = delay / tickduration;
      final float totalDelta = this.targetZoom - this.zoom;
      this.zoomStep = tickAmount > 0 ? (float) (totalDelta / tickAmount) : totalDelta;
    }
}@Override
  public void shake(final double intensity, final int delay, final int shakeDuration) {
    this.shakeTick = Game.time().now();
    this.shakeDelay = delay;
    this.shakeIntensity = intensity;
    this.shakeDuration = shakeDuration;
}
}
```
```java
class de.gurkenlabs.litiengine.entities.Creature {
public void setSpritesheetName(String spritesheetName) {
    if (this.spritesheetName != null && this.spritesheetName.equals(spritesheetName)) {
      return;
    }

    this.spritesheetName = spritesheetName;
    this.updateAnimationController();
}public boolean isIdle() {
    return Game.time().since(this.lastMoved) > IDLE_DELAY;
}@Override
  public void setLocation(final Point2D position) {
    if (this.isDead() || position == null) {
      return;
    }

    final Point2D oldLocation = this.getLocation();
    super.setLocation(position);

    if (Game.hasStarted() && this.isLoaded()) {
      this.lastMoved = Game.time().now();
      this.fireMovedEvent(
          new EntityMovedEvent(
              this, this.getX() - oldLocation.getX(), this.getY() - oldLocation.getY()));
    }
}
}
```
```java
class de.gurkenlabs.litiengine.gui.screens.ScreenManager {
public void display(final String screenName) {
    if (this.current() != null && this.current().getName().equalsIgnoreCase(screenName)) {
      log.log(
          Level.INFO,
          "Skipping displaying of screen {0} because it is already the current screen.",
          screenName);
      return;
    }

    if (this.screens.stream()
        .noneMatch(element -> element.getName().equalsIgnoreCase(screenName))) {
      log.log(
          Level.WARNING,
          "Could not display the screen {0} because there is no screen with the specified name.",
          screenName);
      return;
    }

    Screen screen = this.get(screenName);
    if (screen == null) {
      return;
    }

    this.display(screen);
}public void add(final Screen screen) {
    screen.setWidth(Game.window().getWidth());
    screen.setHeight(Game.window().getHeight());
    this.screens.add(screen);

    if (this.current() == null) {
      this.display(screen);
    }
}public void remove(Screen screen) {
    this.screens.remove(screen);
    if (this.current() == screen) {
      if (!this.screens.isEmpty()) {
        this.display(this.screens.get(0));
      } else {
        this.display((Screen) null);
      }
    }
}public void display(@Nullable final Screen screen) {
    if (Game.hasStarted() && Game.time().since(this.lastScreenChange) < this.getChangeCooldown()) {
      log.log(
          Level.INFO,
          "Skipping displaying of screen {0} because screen changing is currently on cooldown.",
          screen != null ? screen.getName() : "");
      return;
    }

    final Screen previous = this.current();
    if (previous != null) {
      previous.suspend();
    }

    if (screen != null && !this.screens.contains(screen)) {
      this.screens.add(screen);
    }

    this.currentScreen = screen;
    if (!Game.isInNoGUIMode() && this.current() != null) {
      this.current().prepare();
    }

    this.lastScreenChange = Game.loop().getTicks();

    final ScreenChangedEvent event = new ScreenChangedEvent(this.current(), previous);
    for (final ScreenChangedListener listener : this.screenChangedListeners) {
      listener.changed(event);
    }
}
}
```
```java
class de.gurkenlabs.litiengine.abilities.Ability {
public boolean isOnCooldown() {
    return (this.getCurrentExecution() != null
        && this.getCurrentExecution().getExecutionTicks() > 0
        && Game.time().since(this.getCurrentExecution().getExecutionTicks())
            < this.getAttributes().cooldown().get());
}public boolean isActive() {
    return this.getCurrentExecution() != null
        && Game.time().since(this.getCurrentExecution().getExecutionTicks())
            < this.getAttributes().duration().get();
}@Nullable
  public AbilityExecution cast() {
    if (!this.canCast()) {
      return null;
    }
    this.currentExecution = new AbilityExecution(this);

    for (final AbilityCastListener listener : this.abilityCastListeners) {
      listener.abilityCast(this.currentExecution);
    }

    return this.getCurrentExecution();
}public float getRemainingCooldownInSeconds() {
    if (this.getCurrentExecution() == null
        || this.getExecutor() == null
        || this.getExecutor().isDead()) {
      return 0;
    }

    // calculate cooldown in seconds
    return (float)
        (!this.canCast()
            ? (this.getAttributes().cooldown().get()
                    - Game.time().since(this.getCurrentExecution().getExecutionTicks()))
                * 0.001
            : 0);
}
}
```
```java
class de.gurkenlabs.litiengine.entities.EntityHitEvent {
EntityHitEvent(
      final ICombatEntity hitEntity,
      @Nullable final Ability ability,
      final int damage,
      final boolean kill) {
    super(hitEntity);
    this.executor = ability != null ? ability.getExecutor() : null;
    this.hitEntity = hitEntity;
    this.ability = ability;
    this.damage = damage;
    this.kill = kill;
    this.time = Game.time().now();
}
}
```
```java
class de.gurkenlabs.litiengine.graphics.emitters.Emitter {
public void delete() {
    this.deactivate();
    if (Game.world().environment() != null) {
      Game.world().environment().remove(this);
    }
}public void activate() {
    if (this.activated) {
      return;
    }

    this.activated = true;
    this.activationTick = Game.time().now();
    Game.loop().attach(this);
}@Override
  public void update() {
    if (this.isPaused()) {
      return;
    }

    // clear particles if the effect time to life is reached
    if (this.isFinished()) {
      for (EmitterFinishedListener listener : this.finishedListeners) {
        listener.finished(this);
      }

      this.delete();
      return;
    }

    final float updateRatio = (float) this.data().getUpdateRate() / Game.loop().getTickRate();
    for (final Particle p : this.getParticles().stream().collect(Collectors.toList())) {
      if (this.particleCanBeRemoved(p)) {
        // remove dead particles
        this.particles.remove(p);
        continue;
      }

      p.update(this.getOrigin(), updateRatio);
    }

    this.aliveTime = Game.time().since(this.activationTick);
    if ((this.data().getSpawnRate() == 0
        || Game.time().since(this.lastSpawn) >= this.data().getSpawnRate())) {
      this.lastSpawn = Game.time().now();
      this.spawnParticle();
    }
}
}
```
```java
class de.gurkenlabs.litiengine.GameLoop {
@Override
  public int perform(int delay, Runnable action) {
    final long d = Game.time().toTicks(delay);

    TimedAction a = new TimedAction(this.getTicks() + d, action);
    this.actions.add(a);

    return a.getId();
}
}
```
```java
class de.gurkenlabs.litiengine.environment.EntitySpawner {
protected boolean shouldSpawn() {
    return this.lastSpawnWave == 0
        || Game.time().since(this.lastSpawnWave) >= this.getSpawnInterval();
}@Override
  public void update() {
    if (!this.shouldSpawn()) {
      return;
    }

    this.spawnNewEntities();
    this.lastSpawnWave = Game.time().now();
}
}
```
```java
class de.gurkenlabs.litiengine.graphics.FreeFlightCamera {
@Override
  public void update() {
    this.handleFreeFlightCamera();
}public FreeFlightCamera(double x, double y) {
    this(new Point2D.Double(x, y));
}
}
```
```java
class de.gurkenlabs.litiengine.environment.Environment {
public void unload() {
    if (!this.loaded) {
      return;
    }

    // unregister all updatable entities from the current environment
    for (final IEntity entity : this.allEntities.values()) {
      this.unload(entity);
    }

    this.loaded = false;
    this.fireEvent(l -> l.unloaded(this));
}private static void loadUpdatableOrEmitterEntity(IEntity entity) {
    if (entity instanceof Emitter) {
      final Emitter emitter = (Emitter) entity;
      if (emitter.isActivateOnInit()) {
        emitter.activate();
      }
    } else if (entity instanceof IUpdateable) {
      Game.loop().attach((IUpdateable) entity);
    }
}public void clear() {
    Game.physics().clear();

    this.combatEntities.clear();
    this.mobileEntities.clear();
    this.gravityForces.clear();
    this.layerEntities.clear();
    this.entitiesByTag.clear();
    this.allEntities.clear();

    for (RenderType renderType : RenderType.values()) {
      this.miscEntities.get(renderType).clear();
      this.renderListeners.get(renderType).clear();
      this.renderables.get(renderType).clear();
    }

    dispose(this.allEntities.values());
    dispose(this.triggers);
    this.emitters.clear();
    this.colliders.clear();
    this.props.clear();
    this.creatures.clear();
    this.staticShadows.clear();
    this.combatEntities.clear();
    this.mobileEntities.clear();
    this.lightSources.clear();
    this.spawnPoints.clear();
    this.soundSources.clear();
    this.mapAreas.clear();
    this.triggers.clear();

    this.ambientLight = null;
    this.staticShadowLayer = null;

    for (Map<Integer, IEntity> type : this.miscEntities.values()) {
      type.clear();
    }

    this.initialized = false;

    this.fireEvent(l -> l.cleared(this));
}private void load(final IEntity entity) {
    // an entity can only exist on one environment at a time, so remove it from the current one
    if (entity.getEnvironment() != null) {
      entity.getEnvironment().remove(entity);
    }

    // 1. add to physics engine
    loadPhysicsEntity(entity);

    // 2. register for update or activate
    loadUpdatableOrEmitterEntity(entity);

    // 3. if a gravity is defined, add a gravity force to the entity
    if (entity instanceof IMobileEntity && this.getGravity() != 0) {
      this.addGravityForce((IMobileEntity) entity);
    }

    // 4. attach all controllers
    entity.attachControllers();

    if (this.loaded && (entity instanceof LightSource || entity instanceof StaticShadow)) {
      this.updateLighting(entity);
    }

    entity.loaded(this);
}private void unload(final IEntity entity) {
    // 1. remove from physics engine
    if (entity instanceof ICollisionEntity) {
      Game.physics().remove((ICollisionEntity) entity);
    }

    // 2. unregister from update
    if (entity instanceof IUpdateable) {
      Game.loop().detach((IUpdateable) entity);
    }

    if (entity instanceof IMobileEntity) {
      this.removeGravity((IMobileEntity) entity);
    }

    // 3. detach all controllers
    entity.detachControllers();

    if (entity instanceof Emitter) {
      Emitter em = (Emitter) entity;
      em.deactivate();
    }

    if (this.loaded && (entity instanceof LightSource || entity instanceof StaticShadow)) {
      this.updateLighting(entity);
    }

    entity.removed(this);
}public void remove(final IEntity entity) {
    if (entity == null) {
      return;
    }

    this.allEntities.remove(entity.getMapId());
    Iterator<List<IEntity>> iter = this.layerEntities.values().iterator();
    while (iter.hasNext()) {
      List<IEntity> layer = iter.next();
      if (layer.remove(entity) && layer.isEmpty()) {
        iter.remove();
      }
    }
    if (this.miscEntities.get(entity.getRenderType()) != null) {
      this.miscEntities.get(entity.getRenderType()).values().remove(entity);
    }

    for (String tag : entity.getTags()) {
      if (this.getEntitiesByTag().containsKey(tag)) {
        this.getEntitiesByTag().get(tag).remove(entity);

        if (this.getEntitiesByTag().get(tag).isEmpty()) {
          this.getEntitiesByTag().remove(tag);
        }
      }
    }

    if (entity instanceof Emitter) {
      Emitter emitter = (Emitter) entity;
      this.removeEmitter(emitter);
    }

    if (entity instanceof MapArea) {
      this.mapAreas.remove(entity);
    }

    if (entity instanceof Prop) {
      this.props.remove(entity);
    }

    if (entity instanceof Creature) {
      this.creatures.remove(entity);
    }

    if (entity instanceof CollisionBox) {
      this.colliders.remove(entity);
      this.staticShadows.removeIf(x -> x.getOrigin() != null && x.getOrigin().equals(entity));
    }

    if (entity instanceof LightSource) {
      this.lightSources.remove(entity);
      this.updateLighting(entity);
    }

    if (entity instanceof Trigger) {
      this.triggers.remove(entity);
    }

    if (entity instanceof Spawnpoint) {
      this.spawnPoints.remove(entity);
    }
    if (entity instanceof SoundSource) {
      this.soundSources.remove(entity);
    }

    if (entity instanceof StaticShadow) {
      this.staticShadows.remove(entity);
      this.updateLighting(entity);
    }

    if (entity instanceof IMobileEntity) {
      this.mobileEntities.values().remove(entity);
    }

    if (entity instanceof ICombatEntity) {
      this.combatEntities.values().remove(entity);
    }

    this.unload(entity);

    this.fireEntityEvent(l -> l.entityRemoved(entity));
}
}
```
```java
class de.gurkenlabs.litiengine.physics.MovementController {
@Override
  public void update() {
    this.handleForces();
    this.handleMovement();
}
}
```
```java
class de.gurkenlabs.litiengine.Game {
static synchronized void terminate() {
    if (!initialized) {
      return;
    }

    hasStarted = false;
    initialized = false;

    config().save();
    gameLoop.terminate();
    tweenEngine.terminate();
    soundEngine.terminate();

    world().clear();

    for (final GameListener listener : gameListeners) {
      try {
        listener.terminated();
      } catch (Exception e) {
        log().log(Level.WARNING, "game listener threw an exception during shutdown", e);
      }
    }

    gameLoop = null;
    screenManager = null;
    gameWindow = null;
}public static synchronized void start() {
    if (!initialized) {
      throw new IllegalStateException(
          "The game cannot be started without being first initialized. Call Game.init(...) before Game.start().");
    }

    gameLoop.start();
    tweenEngine.start();
    soundEngine.start();

    for (final GameListener listener : gameListeners) {
      listener.started();
    }

    hasStarted = true;
}public static synchronized void init(String... args) {
    if (initialized) {
      log().log(Level.INFO, "The game has already been initialized.");
      return;
    }

    log.init();
    handleCommandLineArguments(args);

    config().load();
    Locale.setDefault(new Locale(config().client().getCountry(), config().client().getLanguage()));

    gameLoop = new GameLoop("Main Update Loop", config().client().getMaxFps());
    loop().attach(physics());
    loop().attach(world());

    // setup default exception handling for render and update loop
    setUncaughtExceptionHandler(
        new DefaultUncaughtExceptionHandler(config().client().exitOnError()));

    screenManager = new ScreenManager();
    gameWindow = new GameWindow();

    // initialize  the game window
    window().init();
    world.setCamera(new Camera());

    for (GameListener listener : gameListeners) {
      listener.initialized(args);
    }

    if (!isInNoGUIMode()) {
      window().getRenderComponent().onRendered(g -> metrics().render(g));

      graphics()
          .addEntityRenderedListener(
              e -> DebugRenderer.renderEntityDebugInfo(e.getGraphics(), e.getEntity()));

      window().getRenderComponent().onFpsChanged(fps -> metrics().setFramesPerSecond(fps));
      window()
          .setIcons(
              Arrays.asList(
                  Resources.images().get("liti-logo-x16.png"),
                  Resources.images().get("liti-logo-x20.png"),
                  Resources.images().get("liti-logo-x32.png"),
                  Resources.images().get("liti-logo-x48.png")));

      Input.keyboard()
          .onKeyTyped(
              KeyEvent.VK_PRINTSCREEN,
              key -> {
                // don't take a screenshot if a modifier is active
                if (key.getModifiers() != 0) {
                  return;
                }

                window().getRenderComponent().takeScreenshot();
              });
    }

    Runtime.getRuntime().addShutdownHook(new Thread(Game::terminate, "Shutdown"));

    initialized = true;
}
}
```


Response Format:
Provide the answer in **XML format** as follows:

#### If the method **cannot** return `null` at the specific call site:
```xml
<response>
  <reason><![CDATA[EXPLAIN WHY THE INVOCATION Game.loop() RESULT CANNOT BE NULL.]]></reason>
  <value>NO</value>
</response>

#### If the method can return null at the specific call site:
<response>
  <reason><![CDATA[EXPLAIN WHY THE INVOCATION Game.loop() RESULT CAN BE NULL.]]></reason>
  <value>YES</value>
</response>

#### If you are unsure or If there are any methods that directly or indirectly affect the return value and are not fully disclosed, request their declarations first, in the following format:
<response>
  <reason><![CDATA[EXPLAIN WHY THIS METHOD DECLARATION IS NECESSARY AND WHY YOU CANNOT MAKE A CONFIDENT DECISION WITHOUT IT]]></reason>
  <success>false</success>
  <methods>
    <method>methodName</method>
  </methods>
</response>

Additional Notes:
Be precise in your reasoning.
If a method’s return value depends on another method not provided, request its declaration before making a conclusion.
If the method can return null in this case but not in others, explain why it happens specifically for this call.

---ChatGPT.sendRequestToOpenAI---
Retrieving response from cache
---Response.<init>---
Creating Response:
```xml
<response>
  <reason><![CDATA[The method `Game.loop()` returns the static field `gameLoop`, which is initialized in the `Game.init(String... args)` method. In this method, a new `GameLoop` object is instantiated and assigned to `gameLoop`. Since `init()` must be called before `start()`, which is implied by the requirement of initializing the game, the `gameLoop` is guaranteed to be non-null during the lifetime of the game execution where `Game.loop()` is called. The absence of any code that could set `gameLoop` to null after its initialization ensures that `Game.loop()` cannot return null.]]></reason>
  <value>NO</value>
</response>
```
---Response.<init>---
Response created:
Disagreement: The method `Game.loop()` returns the static field `gameLoop`, which is initialized in the `Game.init(String... args)` method. In this method, a new `GameLoop` object is instantiated and assigned to `gameLoop`. Since `init()` must be called before `start()`, which is implied by the requirement of initializing the game, the `gameLoop` is guaranteed to be non-null during the lifetime of the game execution where `Game.loop()` is called. The absence of any code that could set `gameLoop` to null after its initialization ensures that `Game.loop()` cannot return null.
---AdvancedNullAwayCodeFix.resolveMethodDereferenceError---
Method is not returning nullable on call site. Injecting suppression annotation.
---AdvancedNullAwayCodeFix.constructCastToNonnullChange---
Constructing cast to nonnull change for reason: The method `Game.loop()` returns the static field `gameLoop`, which is initialized in the `Game.init(String... args)` method. In this method, a new `GameLoop` object is instantiated and assigned to `gameLoop`. Since `init()` must be called before `start()`, which is implied by the requirement of initializing the game, the `gameLoop` is guaranteed to be non-null during the lifetime of the game execution where `Game.loop()` is called. The absence of any code that could set `gameLoop` to null after its initialization ensures that `Game.loop()` cannot return null.
---ChatGPT.ask---
Asking ChatGPT:
For the reason you mentioned earlier:

"The method `Game.loop()` returns the static field `gameLoop`, which is initialized in the `Game.init(String... args)` method. In this method, a new `GameLoop` object is instantiated and assigned to `gameLoop`. Since `init()` must be called before `start()`, which is implied by the requirement of initializing the game, the `gameLoop` is guaranteed to be non-null during the lifetime of the game execution where `Game.loop()` is called. The absence of any code that could set `gameLoop` to null after its initialization ensures that `Game.loop()` cannot return null."

in the method below, the expression Game.loop() is not nullable at the point it is used.

```java
@Override
  public void attach() {
    Game.loop().attach(this);
}
```
Please Summarize the reason in max 5 words and rewrite the method so that at the line "    Game.loop().attach(this);", at the occurrence of: "Game.loop()" is replaced with `NullabilityUtil.castToNonnull(Game.loop(), summary of reason)`
Replace "REASON" with the exact reason summary I provide to you (maximum 5 words), not with a generic explanation like "checked to be nonnull".
see the example below, for expression `foo.getBar()`, to wrap it with `NullabilityUtil.castToNonnull(foo.getBar(), "reason")`.

```java
public t(){
    String l = foo.getBar();
}
```

will be:
```java
public t(){
    String l = NullabilityUtil.castToNonnull(foo.getBar(), "checked to be nonnull");
}
```

### Instructions:

Do not import any additional classes.

Do not add Java comments.

Only modify relevant lines as required.

Return only the modified method wrapped in the XML format shown below.

Place the Java code inside the <code> tag using a CDATA block with ```java formatting.

Just give me the fixed code snippet in XML format in <response> tag like the example below. I will apply the fix to my codebase. Do not import any additional libraries or classes or add java comments. If you can provide the fixed code snippet, please provide it in the following format and place the code snippet in the <code> tag within ```java block.
<response>
  <success>true</success>
  <code><![CDATA[
  ```java
  Your fixed code snippet here
  ```
    ]]>
  </code>
</response>

---ChatGPT.sendRequestToOpenAI---
Retrieving response from cache
---Response.<init>---
Creating Response:
<response>
  <success>true</success>
  <code><![CDATA[
  ```java
@Override
  public void attach() {
    NullabilityUtil.castToNonnull(Game.loop(), "initialized before usage").attach(this);
}
  ```
    ]]>
  </code>
</response>
---Response.<init>---
Response created:
@Override
  public void attach() {
    NullabilityUtil.castToNonnull(Game.loop(), "initialized before usage").attach(this);
}
---ChatGPT.fixDereferenceByAddingCastToNonnull---
Fixing the error by adding castToNonnull
---AdvancedNullAwayCodeFix.fixTriggeredErrorsForLocation---
Resolving unresolvable error for triggered error: Type='DEREFERENCE_NULLABLE', message='dereferenced expression Game.loop() is @Nullable'
/home/nima/Developer/nullness-benchmarks/litiengine/src/de/gurkenlabs/litiengine/GameTime.java:111
    environmentLoaded = Game.loop().getTicks();
---AdvancedNullAwayCodeFix.fix---
Fixing error: Type='DEREFERENCE_NULLABLE', message='dereferenced expression Game.loop() is @Nullable'
/home/nima/Developer/nullness-benchmarks/litiengine/src/de/gurkenlabs/litiengine/GameTime.java:111
    environmentLoaded = Game.loop().getTicks();
---AdvancedNullAwayCodeFix.resolveDereferenceError---
Resolving dereference error: Type='DEREFERENCE_NULLABLE', message='dereferenced expression Game.loop() is @Nullable'
/home/nima/Developer/nullness-benchmarks/litiengine/src/de/gurkenlabs/litiengine/GameTime.java:111
    environmentLoaded = Game.loop().getTicks();
---AdvancedNullAwayCodeFix.resolveDereferenceError---
Checking nullability possibility at error point
---ChatGPT.checkNullabilityPossibilityAtErrorPoint---
Asking if the expression can be null at error point point
---ChatGPT.ask---
Asking ChatGPT:
In the method below, is there a possibility that the expression "Game.loop()" at line "environmentLoaded = Game.loop().getTicks();" is null?
@Override
  public void loaded(Environment environment) {
    environmentLoaded = Game.loop().getTicks();
}
Give a single-word answer in XML format. If it is possible for the expression to be null, respond with:
```xml
<response>
    <reason><![CDATA[YOUR REASON]]></reason>
    <value>YES</value>
</response>
```
If it is not possible for the expression to be null, respond with:
```xml
<response>
    <reason><![CDATA[YOUR REASON]]></reason>
    <value>NO</value>
</response>
```
If you are unsure or need more information, respond with where you can ask for more details or what specific information you need.

If additional information is required, list each request inside a `<request>` tag. If no additional information is needed, omit the `<requests>` section.

Respond with:
```xml
<response>
    <reason><![CDATA[YOUR REASON]]></reason>
    <value>UNKNOWN</value>
    <!-- Include <requests> only if additional information is needed -->
    <requests>
        <request><![CDATA[YOUR REQUEST 1]]></request>
        <request><![CDATA[YOUR REQUEST 2]]></request>
    </requests>
</response>
```
---ChatGPT.sendRequestToOpenAI---
Retrieving response from cache
---Response.<init>---
Creating Response:
```xml
<response>
    <reason><![CDATA[Without additional context about what "Game.loop()" returns and its implementation, it is unclear whether the expression can be null.]]></reason>
    <value>UNKNOWN</value>
    <requests>
        <request><![CDATA[Information about the return value of "Game.loop()".]]></request>
        <request><![CDATA[Details on the "Game" class implementation.]]></request>
    </requests>
</response>
```
---Response.<init>---
Response created:
Unknown: Without additional context about what "Game.loop()" returns and its implementation, it is unclear whether the expression can be null.
---AdvancedNullAwayCodeFix.resolveMethodDereferenceError---
Resolving method dereference error.
---AdvancedNullAwayCodeFix.resolveMethodDereferenceError---
Method is in annotated package. Checking if the method is returning nullable.
---AdvancedNullAwayCodeFix.investigateMethodReturnNullability---
Checking if the method is returning nullable.
---ChatGPT.checkIfMethodIsReturningNullable---
Asking if the method is returning nullable: loop()
---ChatGPT.ask---
Asking ChatGPT:
In the method below, is there a possibility that the method returns null based only on its body? Consider the following points:

- The method may have multiple return paths; consider all return statements.
- If the method calls another method, do not assume its return value unless its full declaration is provided. Request its declaration if needed.
- The method may throw an exception instead of returning null. An exception path should not be considered a null return.
- Ensure you request the declarations of any methods whose return values directly or indirectly impact this method’s return value before making a conclusion.
- Carefully analyze all conditions and prior operations that may guarantee a non-null return value.

@Nullable public static IGameLoop loop() {
    return gameLoop;
}

Here are the method definitions in addition to the method inquired:

Depth: 0
```java
class de.gurkenlabs.litiengine.Game {
@Nullable public static IGameLoop loop() {
    return gameLoop;
}
}
```


Response Format:
Provide the answer in **XML format** as follows:

#### If the method **cannot** return `null`:
```xml
<response>
  <reason><![CDATA[EXPLAIN WHY THE METHOD CANNOT RETURN NULL]]></reason>
  <value>NO</value>
</response>
```

#### If the method can return null:
```xml
<response>
  <reason><![CDATA[EXPLAIN WHY THE METHOD CAN RETURN NULL]]></reason>
  <value>YES</value>
</response>
```

#### If you are unsure or need more information, respond with where you can ask for more details or what specific information you need.

#### If you are unsure or If there are any methods that directly or indirectly affect the return value and are not fully disclosed, request their declarations first, in the following format:
<response>
  <reason><![CDATA[YOUR REASON]]></reason>
  <value>UNKNOWN</value>
  <methods>
    <method>methodName</method>
  </methods>
</response>

If additional information is required other than method declaration, list each request inside a `<request>` tag. If no additional information is needed, omit the `<requests>` section.

Respond with:
```xml
<response>
    <reason><![CDATA[YOUR REASON]]></reason>
    <value>UNKNOWN</value>
    <!-- Include <requests> only if additional information is needed -->
    <requests>
        <request><![CDATA[YOUR REQUEST 1]]></request>
        <request><![CDATA[YOUR REQUEST 2]]></request>
    </requests>
</response>
```

Additional Notes:
Be precise in your reasoning.
If a method’s return value depends on another method not provided, request its declaration before making a conclusion.
If the method can return null in some cases but not others, explain under what conditions it can happen.

---ChatGPT.sendRequestToOpenAI---
Retrieving response from cache
---Response.<init>---
Creating Response:
```xml
<response>
  <reason><![CDATA[The method `loop` returns the variable `gameLoop`. Without the initialization or assignment details of `gameLoop`, it's unclear whether it can be null. The possibility of `gameLoop` being uninitialized or set to null elsewhere in the program means `loop` could potentially return null. Further information on `gameLoop` is required.]]></reason>
  <value>UNKNOWN</value>
  <requests>
    <request><![CDATA[Please provide the declaration and initialization of the variable `gameLoop` in the class `de.gurkenlabs.litiengine.Game`.]]></request>
  </requests>
</response>
```
---Response.<init>---
Response created:
Unknown: The method `loop` returns the variable `gameLoop`. Without the initialization or assignment details of `gameLoop`, it's unclear whether it can be null. The possibility of `gameLoop` being uninitialized or set to null elsewhere in the program means `loop` could potentially return null. Further information on `gameLoop` is required.
---AdvancedNullAwayCodeFix.investigateMethodReturnNullability---
Could not determine the nullability and model did not ask for any method.
---ChatGPT.checkIfMethodIsReturningNullableOnCallSite---
Asking if the method is returning nullable on the call site: Game.loop()
---ChatGPT.ask---
Asking ChatGPT:
In the method below, is there a possibility that the method returns null at the given call site?

```java
@Nullable public static IGameLoop loop() {
    return gameLoop;
}
```

## Guidelines:
- The method may have multiple return paths; consider all return statements.
- If the method calls another method, do not assume its return value unless its full declaration is provided. Request its declaration if needed.
- The method may throw an exception instead of returning null. An exception path should not be considered a null return.
- Ensure you request the declarations of any methods whose return values directly or indirectly impact this method’s return value before making a conclusion.
- If the method returns a value that is determined by a parameter, evaluate based on the actual argument at the given call site.
- Analyze based only on the specific invocation provided. Do not generalize to all possible inputs.- If the return value is guaranteed to be non-null at the call site, the answer should be a definitive NO.
- Do not generalize based on all possible inputs—your answer must be based only on the given invocation.
- Focus only on the given call site, not all possible invocations.

### call site:
Game.loop()

Here are the method definitions and the call chain for this method, showing the sequence of calls from the method to its callers at each depth level:

Depth: 0
```java
class de.gurkenlabs.litiengine.Game {
@Nullable public static IGameLoop loop() {
    return gameLoop;
}
}
```
Depth: 1
```java
class de.gurkenlabs.litiengine.environment.GameWorld {
public void loadEnvironment(@Nullable final Environment env) {
    Lock lock = Game.loop().getLock();
    lock.lock();
    try {
      unloadEnvironment();
      this.environment = env;
      if (env != null) {
        this.addEnvironment(env);

        if (env.getGravity() == 0 && this.gravity() != 0) {
          env.setGravity(this.gravity());
        }

        env.load();
        for (final EnvironmentLoadedListener listener : this.loadedListeners) {
          listener.loaded(env);
        }

        // call map specific listeners
        String mapName = getMapName(env);
        if (mapName != null && this.environmentLoadedListeners.containsKey(mapName)) {

          // for the default camera we center the camera on the environment
          if (this.camera().getClass().equals(Camera.class)) {
            camera().setFocus(env.getCenter());
          }

          for (EnvironmentLoadedListener listener : this.environmentLoadedListeners.get(mapName)) {
            listener.loaded(env);
          }
        }
      }
    } finally {
      lock.unlock();
    }
}public void setCamera(@Nullable final ICamera cam) {
    if (this.camera() != null) {
      Game.loop().detach(camera);
    }

    camera = cam;

    if (cam != null && !Game.isInNoGUIMode()) {
      Game.loop().attach(cam);
      cam.updateFocus();
    }
}
}
```
```java
class de.gurkenlabs.litiengine.entities.behavior.EntityNavigator {
public EntityNavigator(final IMobileEntity entity, final PathFinder pathFinder) {
    this.cancelNavigationConditions = new CopyOnWriteArrayList<>();
    this.listeners = new CopyOnWriteArrayList<>();
    this.entity = entity;
    this.pathFinder = pathFinder;
    this.setAcceptableError(DEFAULT_ACCEPTABLE_ERROR);
    Game.loop().attach(this);
}
}
```
```java
class de.gurkenlabs.litiengine.GameWindow {
private static void initializeWindowEventListeners(Window window) {

    window.addWindowStateListener(
        e -> {
          if (e.getNewState() == Frame.ICONIFIED) {
            Game.loop().setTickRate(ICONIFIED_MAX_FPS);
          } else {
            Game.loop().setTickRate(Game.config().client().getMaxFps());
          }
        });

    window.addWindowFocusListener(
        new WindowFocusListener() {
          @Override
          public void windowLostFocus(WindowEvent e) {
            if (Game.config().graphics().reduceFramesWhenNotFocused()) {
              Game.loop().setTickRate(NONE_FOCUS_MAX_FPS);
            }
          }

          @Override
          public void windowGainedFocus(WindowEvent e) {
            Game.loop().setTickRate(Game.config().client().getMaxFps());
          }
        });

    window.addWindowListener(
        new WindowAdapter() {
          @Override
          public void windowClosing(final WindowEvent event) {
            Game.exit();
          }
        });
}
}
```
```java
class de.gurkenlabs.litiengine.gui.screens.ScreenManager {
public void display(@Nullable final Screen screen) {
    if (Game.hasStarted() && Game.time().since(this.lastScreenChange) < this.getChangeCooldown()) {
      log.log(
          Level.INFO,
          "Skipping displaying of screen {0} because screen changing is currently on cooldown.",
          screen != null ? screen.getName() : "");
      return;
    }

    final Screen previous = this.current();
    if (previous != null) {
      previous.suspend();
    }

    if (screen != null && !this.screens.contains(screen)) {
      this.screens.add(screen);
    }

    this.currentScreen = screen;
    if (!Game.isInNoGUIMode() && this.current() != null) {
      this.current().prepare();
    }

    this.lastScreenChange = Game.loop().getTicks();

    final ScreenChangedEvent event = new ScreenChangedEvent(this.current(), previous);
    for (final ScreenChangedListener listener : this.screenChangedListeners) {
      listener.changed(event);
    }
}
}
```
```java
class de.gurkenlabs.litiengine.abilities.effects.Effect {
@Override
  public void update() {

    for (final Iterator<EffectApplication> iterator = this.getActiveAppliances().iterator();
        iterator.hasNext(); ) {
      final EffectApplication appliance = iterator.next();
      // if the effect duration is reached
      if (this.hasEnded(appliance)) {

        iterator.remove();
        this.cease(appliance);
      }
    }

    // 4. unregister if all appliances are finished
    if (this.getActiveAppliances().isEmpty()) {
      Game.loop().detach(this);
    }
}public void apply(final Shape impactArea) {
    final List<ICombatEntity> affected = this.lookForAffectedEntities(impactArea);
    for (final ICombatEntity affectedEntity : affected) {
      this.apply(affectedEntity);
    }

    this.appliances.add(new EffectApplication(affected, impactArea));

    // if it is the first appliance -> register for update
    if (this.appliances.size() == 1) {
      Game.loop().attach(this);
    }
}
}
```
```java
class de.gurkenlabs.litiengine.GameTime {
public long toTicks(final int milliseconds) {
    return this.toTicks(milliseconds, Game.loop().getTickRate());
}public long since(final long tick) {
    return toMilliseconds(Game.loop().getTicks() - tick);
}public long now() {
    return Game.loop().getTicks();
}public long sinceGameStart() {
    return this.toMilliseconds(Game.loop().getTicks());
}@Override
  public void loaded(Environment environment) {
    environmentLoaded = Game.loop().getTicks();
}public long toMilliseconds(final long ticks) {
    return this.toMilliseconds(ticks, Game.loop().getTickRate());
}
}
```
```java
class de.gurkenlabs.litiengine.GameMetrics {
@Override
  public void render(final Graphics2D g) {
    this.updateMetrics();

    if (!Game.config().client().showGameMetrics()) {
      return;
    }

    this.currentOffsetY = 0;

    g.setColor(this.renderColor);

    // render client metrics
    this.drawTitle(g, "[client]");
    this.drawMetric(g, "fps       : " + this.getFramesPerSecond());
    this.drawMetric(g, "max fps   : " + this.maxFramesPerSecond);
    this.drawMetric(g, "updatables: " + Game.loop().getUpdatableCount());

    // render jvm metrics if debug is enabled
    if (Game.config().debug().isDebugEnabled()) {
      this.drawTitle(g, "[jvm]");
      this.drawMetric(g, "java      : " + this.javaVersion);
      this.drawMetric(g, "memory    : " + String.format("%-5.5s", this.usedMemory) + " MB");
      this.drawMetric(g, "threads   : " + Thread.activeCount());
    }

    // render rendering metrics
    if (!this.renderMetrics.isEmpty()) {
      this.drawTitle(g, "[update]");

      for (RenderMetrics metric : this.renderMetrics) {
        this.drawMetric(g, metric.toString());
      }

      this.renderMetrics.clear();
    }
}
}
```
```java
class de.gurkenlabs.litiengine.graphics.emitters.Emitter {
public void deactivate() {
    if (!this.activated) {
      return;
    }

    this.activated = false;
    this.getParticles().clear();
    this.aliveTime = 0;
    this.activationTick = 0;
    this.lastSpawn = 0;
    Game.loop().detach(this);
}public void activate() {
    if (this.activated) {
      return;
    }

    this.activated = true;
    this.activationTick = Game.time().now();
    Game.loop().attach(this);
}@Override
  public void update() {
    if (this.isPaused()) {
      return;
    }

    // clear particles if the effect time to life is reached
    if (this.isFinished()) {
      for (EmitterFinishedListener listener : this.finishedListeners) {
        listener.finished(this);
      }

      this.delete();
      return;
    }

    final float updateRatio = (float) this.data().getUpdateRate() / Game.loop().getTickRate();
    for (final Particle p : this.getParticles().stream().collect(Collectors.toList())) {
      if (this.particleCanBeRemoved(p)) {
        // remove dead particles
        this.particles.remove(p);
        continue;
      }

      p.update(this.getOrigin(), updateRatio);
    }

    this.aliveTime = Game.time().since(this.activationTick);
    if ((this.data().getSpawnRate() == 0
        || Game.time().since(this.lastSpawn) >= this.data().getSpawnRate())) {
      this.lastSpawn = Game.time().now();
      this.spawnParticle();
    }
}
}
```
```java
class de.gurkenlabs.litiengine.entities.behavior.IBehaviorController {
public default void attach() {
    Game.loop().attach(this);
}public default void detach() {
    Game.loop().detach(this);
}
}
```
```java
class de.gurkenlabs.litiengine.abilities.AbilityExecution {
AbilityExecution(final Ability ability) {
    this.appliedEffects = new CopyOnWriteArrayList<>();
    this.ability = ability;
    this.executionTicks = Game.time().now();
    this.impactArea = ability.calculateImpactArea();
    this.castLocation = ability.getExecutor().getCenter();
    Game.loop().attach(this);
}@Override
  public void update() {
    // if there a no effects to apply -> unregister this instance and we're done
    if (this.getAbility().getEffects().isEmpty()
        || this.getAbility().getEffects().size() == this.getAppliedEffects().size()) {
      Game.loop().detach(this);
      return;
    }

    // handle all effects from the ability that were not applied yet
    for (final Effect effect : this.getAbility().getEffects()) {
      // if the ability was not executed yet or the delay of the effect is not
      // yet reached
      if (this.getAppliedEffects().contains(effect)
          || Game.time().since(this.getExecutionTicks()) < effect.getDelay()) {
        continue;
      }

      effect.apply(this.getExecutionImpactArea());
      this.getAppliedEffects().add(effect);
    }
}
}
```
```java
class de.gurkenlabs.litiengine.GameWindow$3 {
@Override
          public void windowGainedFocus(WindowEvent e) {
            Game.loop().setTickRate(Game.config().client().getMaxFps());
}@Override
          public void windowLostFocus(WindowEvent e) {
            if (Game.config().graphics().reduceFramesWhenNotFocused()) {
              Game.loop().setTickRate(NONE_FOCUS_MAX_FPS);
            }
}
}
```
```java
class de.gurkenlabs.litiengine.environment.EntitySpawner {
protected void spawnNewEntities() {
    if (this.getSpawnMode() != SpawnMode.CUSTOMSPAWNPOINTS && this.getSpawnPoints().isEmpty()) {
      return;
    }

    switch (this.getSpawnMode()) {
      case ALLSPAWNPOINTS:
        for (int i = 0; i < this.getSpawnPoints().size(); i++) {
          final int index = i;
          Game.loop()
              .perform(
                  this.getSpawnDelay() + this.getSpawnDelay() * i,
                  () -> this.spawn(this.getSpawnPoints().get(index), this.getSpawnAmount()));
        }
        break;
      case ONERANDOMSPAWNPOINT:
        this.spawn(Game.random().choose(this.getSpawnPoints()), this.getSpawnAmount());
        break;
      case RANDOMSPAWNPOINTS:
        for (int i = 0; i < this.getSpawnAmount(); i++) {
          Game.loop()
              .perform(
                  this.getSpawnDelay() + this.getSpawnDelay() * i,
                  () -> this.spawn(Game.random().choose(this.getSpawnPoints()), 1));
        }
        break;
      case CUSTOMSPAWNPOINTS:
        List<Spawnpoint> spawnPoints =
            this.customSpawnpoints != null
                ? this.customSpawnpoints.apply(this)
                : this.getCustomSpawnpoints();

        int index = 0;
        for (Spawnpoint spawn : spawnPoints) {
          Game.loop()
              .perform(
                  this.getSpawnDelay() + this.getSpawnDelay() * index, () -> this.spawn(spawn, 1));
          index++;
        }
        break;
      default:
        break;
    }
}
}
```
```java
class de.gurkenlabs.litiengine.tweening.TweenEngine {
@Override
  public void start() {
    Game.loop().attach(this);
}@Override
  public void terminate() {
    Game.loop().detach(this);
}
}
```
```java
class de.gurkenlabs.litiengine.gui.SpeechBubble {
public void hide() {
    Game.world().environment().removeRenderable(this);
    Game.loop().detach(this);
    if (activeSpeechBubbles.get(this.getEntity()) != null
        && activeSpeechBubbles.remove(this.getEntity()).equals(this)) {
      activeSpeechBubbles.remove(this.getEntity());
    }

    for (SpeechBubbleListener listener : this.listeners) {
      listener.hidden();
    }
}private SpeechBubble(
      final IEntity entity,
      final String text,
      @Nullable SpeechBubbleAppearance appearance,
      @Nullable Font font) {
    if (appearance == null) {
      this.appearance = DEFAULT_APPEARANCE;
    } else {
      this.appearance = appearance;
    }

    final SpeechBubble active = activeSpeechBubbles.get(entity);
    if (active != null) {
      active.hide();
    }
    this.setFont(font);

    this.textBoxWidth = (float) (entity.getWidth() * 4);
    this.entity = entity;

    this.currentText = text;
    this.currentTextDisplayTime = DISPLAYTIME_MIN + text.length() * DISPLAYTIME_PER_LETTER;

    this.lastTextDisplay = Game.time().now();
    this.createBubbleImage();
    entity.getEnvironment().add(this, RenderType.UI);
    Game.loop().attach(this);
    activeSpeechBubbles.put(entity, this);
}
}
```
```java
class de.gurkenlabs.litiengine.entities.Prop {
private void updateAnimationController() {
    IEntityAnimationController<?> controller = this.createAnimationController();
    this.getControllers().addController(controller);
    if (Game.world().environment() != null && Game.world().environment().isLoaded()) {
      Game.loop().attach(controller);
    }
}
}
```
```java
class de.gurkenlabs.litiengine.graphics.FreeFlightCamera {
public FreeFlightCamera(final Point2D focus) {
    this.setFocus(focus);
    this.velocity = DEFAULT_SCROLL_PIXELS_PER_SECOND;
    this.scrollPadding = DEFAULT_SCROLL_PADDING;
    this.setClampToMap(true);

    Game.loop().attach(this);
}private void handleFreeFlightCamera() {
    if (Game.world().environment() == null || Game.world().environment().getMap() == null) {
      return;
    }

    final Point2D mouseLocation = Input.mouse().getLocation();

    final double scrollSpeed =
        this.getVelocity()
            / (double) Game.loop().getTickRate()
            * Game.config().input().getMouseSensitivity();

    double x = this.getFocus().getX();
    double y = this.getFocus().getY();

    double deltaX = 0;
    if (mouseLocation.getX() < this.getScrollPadding()) {
      deltaX -= scrollSpeed;
    } else if (Game.window().getResolution().getWidth() - mouseLocation.getX()
        < this.getScrollPadding()) {
      deltaX += scrollSpeed;
    }

    double deltaY = 0;
    if (mouseLocation.getY() < this.getScrollPadding()) {
      deltaY -= scrollSpeed;
    } else if (Game.window().getResolution().getHeight() - mouseLocation.getY()
        < this.getScrollPadding()) {
      deltaY += scrollSpeed;
    }

    x += deltaX;
    y += deltaY;

    this.setFocus(new Point2D.Double(x, y));
}
}
```
```java
class de.gurkenlabs.litiengine.environment.Environment {
private static void dispose(final Collection<? extends IEntity> entities) {
    for (final IEntity entity : entities) {
      if (entity instanceof IUpdateable) {
        Game.loop().detach((IUpdateable) entity);
      }

      entity.detachControllers();
    }
}private static void loadUpdatableOrEmitterEntity(IEntity entity) {
    if (entity instanceof Emitter) {
      final Emitter emitter = (Emitter) entity;
      if (emitter.isActivateOnInit()) {
        emitter.activate();
      }
    } else if (entity instanceof IUpdateable) {
      Game.loop().attach((IUpdateable) entity);
    }
}private void unload(final IEntity entity) {
    // 1. remove from physics engine
    if (entity instanceof ICollisionEntity) {
      Game.physics().remove((ICollisionEntity) entity);
    }

    // 2. unregister from update
    if (entity instanceof IUpdateable) {
      Game.loop().detach((IUpdateable) entity);
    }

    if (entity instanceof IMobileEntity) {
      this.removeGravity((IMobileEntity) entity);
    }

    // 3. detach all controllers
    entity.detachControllers();

    if (entity instanceof Emitter) {
      Emitter em = (Emitter) entity;
      em.deactivate();
    }

    if (this.loaded && (entity instanceof LightSource || entity instanceof StaticShadow)) {
      this.updateLighting(entity);
    }

    entity.removed(this);
}
}
```
```java
class de.gurkenlabs.litiengine.graphics.animation.Animation {
@Override
  public void update() {
    // do nothing if the animation is not playing or the current keyframe is not finished
    if (!this.isPlaying()
        || Game.time().since(this.lastFrameUpdate) < this.getCurrentKeyFrame().getDuration()) {
      return;
    }

    // if we are not looping and the last keyframe is finished, we terminate the animation
    if (!this.isLooping() && this.isLastKeyFrame()) {
      this.terminate();
      return;
    }

    // make sure, we stay inside the keyframe list
    final int newFrameIndex =
        (this.getKeyframes().indexOf(this.currentFrame) + 1) % this.getKeyframes().size();
    final KeyFrame previousFrame = this.currentFrame;
    this.currentFrame = this.getKeyframes().get(newFrameIndex);

    for (KeyFrameListener listener : this.listeners) {
      listener.currentFrameChanged(previousFrame, this.currentFrame);
    }

    this.lastFrameUpdate = Game.loop().getTicks();
}public void restart() {
    this.currentFrame = this.firstFrame;
    this.lastFrameUpdate = Game.loop().getTicks();
}
}
```
```java
class de.gurkenlabs.litiengine.physics.MovementController {
@Override
  public void attach() {
    Game.loop().attach(this);
}private void handleForces() {
    // clean up forces
    this.activeForces.forEach(
        x -> {
          if (x.hasEnded()) {
            this.activeForces.remove(x);
          }
        });

    if (this.activeForces.isEmpty()) {
      return;
    }

    // disable turn-on-move for force handling
    boolean turn = this.getEntity().turnOnMove();
    this.getEntity().setTurnOnMove(false);
    try {
      double deltaX = 0;
      double deltaY = 0;
      for (final Force force : this.activeForces) {
        if (force.cancelOnReached() && force.hasReached(this.getEntity())) {
          force.end();
          continue;
        }

        final Point2D collisionBoxCenter = this.getEntity().getCollisionBoxCenter();
        final double angle =
            GeometricUtilities.calcRotationAngleInDegrees(collisionBoxCenter, force.getLocation());
        final double strength =
            Game.loop().getDeltaTime() * 0.001f * force.getStrength() * Game.loop().getTimeScale();
        deltaX += GeometricUtilities.getDeltaX(angle, strength);
        deltaY += GeometricUtilities.getDeltaY(angle, strength);
      }

      final Point2D target =
          new Point2D.Double(this.getEntity().getX() + deltaX, this.getEntity().getY() + deltaY);
      final boolean success = Game.physics().move(this.getEntity(), target);
      if (!success) {
        for (final Force force : this.activeForces) {
          if (force.cancelOnCollision()) {
            force.end();
          }
        }
      }
    } finally {
      this.getEntity().setTurnOnMove(turn);
    }
}@Override
  public void detach() {
    Game.loop().detach(this);
}public void handleMovement() {
    if (!this.isMovementAllowed()) {
      this.velocity = 0;
      return;
    }

    // max distance an entity can travel within one tick
    final double maxPixelsPerTick = this.getEntity().getTickVelocity();
    final double deltaTime = Game.loop().getDeltaTime() * Game.loop().getTimeScale();

    final double acceleration =
        this.getEntity().getAcceleration() == 0
            ? maxPixelsPerTick
            : deltaTime / this.getEntity().getAcceleration() * maxPixelsPerTick;
    final double deceleration =
        this.getEntity().getDeceleration() == 0
            ? this.getVelocity()
            : deltaTime / this.getEntity().getDeceleration() * maxPixelsPerTick;

    double dx = this.getDx();
    double dy = this.getDy();
    this.setDx(0);
    this.setDy(0);

    final double deltaVelocity =
        Math.min(Math.sqrt(Math.pow(dx, 2) + Math.pow(dy, 2)), acceleration);
    if (deltaVelocity != 0) {
      double newVelocity = this.getVelocity() + deltaVelocity;
      this.setVelocity(newVelocity);
    } else {
      final double newVelocity = Math.max(0, this.getVelocity() - deceleration);
      this.setVelocity(newVelocity);
      dx = GeometricUtilities.getDeltaX(this.moveAngle);
      dy = GeometricUtilities.getDeltaY(this.moveAngle);
    }

    if (this.getVelocity() == 0) {
      this.moveAngle = 0;
      return;
    }

    // actually move entity
    this.moveEntity(dx, dy);
}
}
```
```java
class de.gurkenlabs.litiengine.graphics.animation.AnimationController {
public void detach() {
    Game.loop().detach(this);
}public void attach() {
    Game.loop().attach(this);
}
}
```
```java
class de.gurkenlabs.litiengine.graphics.Camera {
@Override
  public void setZoom(final float targetZoom, final int delay) {
    if (delay == 0) {

      this.zoom = targetZoom;
      this.targetZoom = 0;
      this.zoomDelay = 0;
      this.zoomTick = 0;
      this.zoomStep = 0;

      final ZoomChangedEvent event = new ZoomChangedEvent(this, targetZoom);
      for (final ZoomChangedListener listener : this.zoomListeners) {
        listener.zoomChanged(event);
      }
    } else {
      this.zoomTick = Game.time().now();
      this.targetZoom = targetZoom;
      this.zoomDelay = delay;

      final double tickduration = 1000 / (double) Game.loop().getTickRate();
      final double tickAmount = delay / tickduration;
      final float totalDelta = this.targetZoom - this.zoom;
      this.zoomStep = tickAmount > 0 ? (float) (totalDelta / tickAmount) : totalDelta;
    }
}
}
```
```java
class de.gurkenlabs.litiengine.Game {
public static synchronized void init(String... args) {
    if (initialized) {
      log().log(Level.INFO, "The game has already been initialized.");
      return;
    }

    log.init();
    handleCommandLineArguments(args);

    config().load();
    Locale.setDefault(new Locale(config().client().getCountry(), config().client().getLanguage()));

    gameLoop = new GameLoop("Main Update Loop", config().client().getMaxFps());
    loop().attach(physics());
    loop().attach(world());

    // setup default exception handling for render and update loop
    setUncaughtExceptionHandler(
        new DefaultUncaughtExceptionHandler(config().client().exitOnError()));

    screenManager = new ScreenManager();
    gameWindow = new GameWindow();

    // initialize  the game window
    window().init();
    world.setCamera(new Camera());

    for (GameListener listener : gameListeners) {
      listener.initialized(args);
    }

    if (!isInNoGUIMode()) {
      window().getRenderComponent().onRendered(g -> metrics().render(g));

      graphics()
          .addEntityRenderedListener(
              e -> DebugRenderer.renderEntityDebugInfo(e.getGraphics(), e.getEntity()));

      window().getRenderComponent().onFpsChanged(fps -> metrics().setFramesPerSecond(fps));
      window()
          .setIcons(
              Arrays.asList(
                  Resources.images().get("liti-logo-x16.png"),
                  Resources.images().get("liti-logo-x20.png"),
                  Resources.images().get("liti-logo-x32.png"),
                  Resources.images().get("liti-logo-x48.png")));

      Input.keyboard()
          .onKeyTyped(
              KeyEvent.VK_PRINTSCREEN,
              key -> {
                // don't take a screenshot if a modifier is active
                if (key.getModifiers() != 0) {
                  return;
                }

                window().getRenderComponent().takeScreenshot();
              });
    }

    Runtime.getRuntime().addShutdownHook(new Thread(Game::terminate, "Shutdown"));

    initialized = true;
}
}
```
```java
class de.gurkenlabs.litiengine.entities.Creature {
protected void updateAnimationController() {
    IEntityAnimationController<?> controller = this.createAnimationController();
    this.getControllers().addController(controller);
    if (Game.world().environment() != null && Game.world().environment().isLoaded()) {
      Game.loop().attach(controller);
    }
}@Override
  public float getTickVelocity() {
    // pixels per ms multiplied by the passed ms
    // ensure that entities don't travel too far in case of lag
    return Math.min(Game.loop().getDeltaTime(), GameLoop.TICK_DELTATIME_LAG)
        * 0.001F
        * this.getVelocity().get()
        * Game.loop().getTimeScale();
}
}
```
Depth: 2
```java
class de.gurkenlabs.litiengine.environment.GameWorld {
public void clear() {
    this.unloadEnvironment();
    this.environments.clear();
    this.setCamera(null);
    Game.physics().clear();

    this.environmentListeners.clear();
    this.environmentLoadedListeners.clear();
    this.environmentUnloadedListeners.clear();

    this.listeners.clear();
    this.loadedListeners.clear();
    this.unloadedListeners.clear();
}@Nullable
  public Environment loadEnvironment(IMap map) {
    Environment env = this.getEnvironment(map);
    this.loadEnvironment(env);
    return env;
}@Nullable
  public Environment loadEnvironment(String mapName) {
    Environment env = this.getEnvironment(mapName);
    this.loadEnvironment(env);
    return env;
}
}
```
```java
class de.gurkenlabs.litiengine.GameWindow {
GameWindow() {
    this.hostControl = new JFrame();

    this.resolutionChangedListeners = new CopyOnWriteArrayList<>();

    this.renderCanvas = new RenderComponent(Game.config().graphics().getResolution());
    this.cursor = new MouseCursor();
    if (!Game.isInNoGUIMode()) {
      this.hostControl.setBackground(Color.BLACK);
      this.hostControl.add(this.renderCanvas);

      this.initializeEventListeners();

      this.hostControl.setTitle(Game.info().getTitle());
      this.hostControl.setDefaultCloseOperation(WindowConstants.DO_NOTHING_ON_CLOSE);
      initializeWindowEventListeners(this.hostControl);
    }
}
}
```
```java
class de.gurkenlabs.litiengine.GameTime {
public long sinceEnvironmentLoad() {
    return this.since(this.environmentLoaded);
}public long since(final long tick) {
    return toMilliseconds(Game.loop().getTicks() - tick);
}public long sinceGameStart() {
    return this.toMilliseconds(Game.loop().getTicks());
}
}
```
```java
class de.gurkenlabs.litiengine.abilities.effects.Effect {
protected void cease(final EffectApplication appliance) {
    // 1. cease the effect for all affected entities
    for (final ICombatEntity entity : appliance.getAffectedEntities()) {
      this.cease(entity);
    }

    // 2. apply follow up effects
    this.getFollowUpEffects().forEach(followUp -> followUp.apply(appliance.getImpactArea()));
}protected boolean hasEnded(final EffectApplication appliance) {
    final long effectDuration = Game.time().since(appliance.getAppliedTicks());
    return effectDuration > this.getDuration();
}
}
```
```java
class de.gurkenlabs.litiengine.abilities.effects.EffectApplication {
protected EffectApplication(final List<ICombatEntity> affectedEntities, final Shape impactArea) {
    this.applied = Game.time().now();
    this.affectedEntities = affectedEntities;
    this.impactArea = impactArea;
}
}
```
```java
class de.gurkenlabs.litiengine.entities.CombatEntity {
@Override
  public boolean wasHit(int timeSpan) {
    return Game.time().since(this.lastHit) < timeSpan;
}@Override
  public void hit(final int damage, @Nullable final Ability ability) {
    if (this.isDead()) {
      return;
    }

    if (!this.isIndestructible()) {
      this.getHitPoints().modifyBaseValue(new AttributeModifier<>(Modification.SUBTRACT, damage));
    }

    final EntityHitEvent event = new EntityHitEvent(this, ability, damage, this.isDead());

    for (final CombatEntityListener listener : this.listeners) {
      listener.hit(event);
    }

    for (final CombatEntityHitListener listener : this.hitListeners) {
      listener.hit(event);
    }

    if (this.isDead()) {
      this.fireDeathEvent();
      this.setCollision(false);
    }

    this.lastHit = Game.time().now();
}
}
```
```java
class de.gurkenlabs.litiengine.graphics.ImageEffect {
protected ImageEffect(final int ttl, final String name) {
    this.ttl = ttl;
    this.name = name;
    this.aliveTick = Game.time().now();
}@Override
  public long getAliveTime() {
    return Game.time().since(this.aliveTick);
}
}
```
```java
class de.gurkenlabs.litiengine.abilities.AbilityExecution {
AbilityExecution(final Ability ability) {
    this.appliedEffects = new CopyOnWriteArrayList<>();
    this.ability = ability;
    this.executionTicks = Game.time().now();
    this.impactArea = ability.calculateImpactArea();
    this.castLocation = ability.getExecutor().getCenter();
    Game.loop().attach(this);
}@Override
  public void update() {
    // if there a no effects to apply -> unregister this instance and we're done
    if (this.getAbility().getEffects().isEmpty()
        || this.getAbility().getEffects().size() == this.getAppliedEffects().size()) {
      Game.loop().detach(this);
      return;
    }

    // handle all effects from the ability that were not applied yet
    for (final Effect effect : this.getAbility().getEffects()) {
      // if the ability was not executed yet or the delay of the effect is not
      // yet reached
      if (this.getAppliedEffects().contains(effect)
          || Game.time().since(this.getExecutionTicks()) < effect.getDelay()) {
        continue;
      }

      effect.apply(this.getExecutionImpactArea());
      this.getAppliedEffects().add(effect);
    }
}
}
```
```java
class de.gurkenlabs.litiengine.tweening.TweenEngine {
@Override
  public void update() {
    for (final Tweenable target : this.getTweens().keySet()) {
      for (final Tween tween : this.getTweens().get(target).values()) {
        if (tween.hasStopped()) {
          continue;
        }
        final long elapsed = Game.time().since(tween.getStartTime());
        if (elapsed >= tween.getDuration()) {
          tween.stop();
          continue;
        }
        final float[] currentValues = new float[tween.getTargetValues().length];
        for (int i = 0; i < tween.getTargetValues().length; i++) {
          currentValues[i] =
              tween.getStartValues()[i]
                  + tween.getEquation().compute(elapsed / (float) tween.getDuration())
                      * (tween.getTargetValues()[i] - tween.getStartValues()[i]);
        }
        tween.getTarget().setTweenValues(tween.getType(), currentValues);
      }
    }
}
}
```
```java
class de.gurkenlabs.litiengine.gui.SpeechBubble {
public static SpeechBubble create(
      final IEntity entity, final String text, SpeechBubbleAppearance appearance, Font font) {
    return new SpeechBubble(entity, text, appearance, font);
}public static SpeechBubble create(final IEntity entity, final Font font, final String text) {
    SpeechBubbleAppearance app =
        new SpeechBubbleAppearance(
            DEFAULT_APPEARANCE.getForeColor(),
            DEFAULT_APPEARANCE.getBackgroundColor1(),
            DEFAULT_APPEARANCE.getBorderColor(),
            DEFAULT_APPEARANCE.getPadding());
    return new SpeechBubble(entity, text, app, font);
}public static SpeechBubble create(final IEntity entity, final String text) {
    return new SpeechBubble(entity, text, null, GuiProperties.getDefaultFont());
}@Override
  public void update() {
    if (this.currentText == null) {
      this.hide();
      return;
    }

    this.entityCenter = Game.world().camera().getViewportLocation(this.getEntity().getCenter());

    // old text was displayed long enough
    if (this.lastTextDisplay != 0
        && Game.time().since(this.lastTextDisplay) > this.currentTextDisplayTime) {
      this.currentText = null;
      this.lastTextDisplay = 0;
      return;
    }

    // display new text
    if (this.textIndex < this.currentText.length()
        && Game.time().since(this.lastCharPoll) > LETTER_WRITE_DELAY) {
      this.textIndex++;
      this.lastCharPoll = Game.time().now();
      if (this.typeSound != null) {
        Game.audio().playSound(this.typeSound, this.getEntity());
      }
    }

    // continue displaying currently displayed text
}private SpeechBubble(
      final IEntity entity,
      final String text,
      final Sound typeSound,
      SpeechBubbleAppearance appearance,
      Font font) {
    this(entity, text, appearance, font);
    this.typeSound = typeSound;
}private SpeechBubble(
      final IEntity entity,
      final String text,
      @Nullable SpeechBubbleAppearance appearance,
      @Nullable Font font) {
    if (appearance == null) {
      this.appearance = DEFAULT_APPEARANCE;
    } else {
      this.appearance = appearance;
    }

    final SpeechBubble active = activeSpeechBubbles.get(entity);
    if (active != null) {
      active.hide();
    }
    this.setFont(font);

    this.textBoxWidth = (float) (entity.getWidth() * 4);
    this.entity = entity;

    this.currentText = text;
    this.currentTextDisplayTime = DISPLAYTIME_MIN + text.length() * DISPLAYTIME_PER_LETTER;

    this.lastTextDisplay = Game.time().now();
    this.createBubbleImage();
    entity.getEnvironment().add(this, RenderType.UI);
    Game.loop().attach(this);
    activeSpeechBubbles.put(entity, this);
}
}
```
```java
class de.gurkenlabs.litiengine.gui.TextFieldComponent {
@Override
  public void render(final Graphics2D g) {
    super.render(g);
    g.setFont(this.getFont());
    final FontMetrics fm = g.getFontMetrics();

    if (this.isSelected() && Game.time().since(this.lastToggled) > this.flickerDelay) {
      this.cursorVisible = !this.cursorVisible;
      this.lastToggled = Game.time().now();
    }
    if (this.isSelected() && this.cursorVisible) {
      final Rectangle2D cursor =
          new Rectangle2D.Double(
              this.getX() + this.getTextX() + fm.stringWidth(this.getTextToRender(g)),
              this.getY() + this.getTextY(),
              this.getFont().getSize2D() * 3 / 5,
              this.getFont().getSize2D() * 1 / 5);
      g.setColor(this.getAppearance().getForeColor());
      g.fill(cursor);
    }
}
}
```
```java
class de.gurkenlabs.litiengine.entities.Prop {
public Prop(
      final Point2D location, @Nullable final String spritesheetName, final Material material) {
    super();
    this.rotation = Rotation.NONE;
    this.spritesheetName = spritesheetName;
    this.material = material;
    this.setLocation(location);
    this.updateAnimationController();
}public void setSpritesheetName(@Nullable final String spriteName) {
    this.spritesheetName = spriteName;
    this.updateAnimationController();
}
}
```
```java
class de.gurkenlabs.litiengine.tweening.Tween {
public Tween begin() {
    this.started = Game.time().now();
    this.stopped = false;
    return this;
}
}
```
```java
class de.gurkenlabs.litiengine.graphics.emitters.particles.Particle {
public void update(final Point2D emitterOrigin, final float updateRatio) {
    if (this.aliveTick == 0) {
      this.aliveTick = Game.time().now();
    }

    this.aliveTime = Game.time().since(this.aliveTick);
    if (this.timeToLiveReached()) {
      return;
    }

    if (this.colliding) {
      return;
    }

    if (this.getDeltaWidth() != 0) {
      this.width += this.getDeltaWidth() * updateRatio;
    }

    if (this.getDeltaHeight() != 0) {
      this.height += this.getDeltaHeight() * updateRatio;
    }

    if (this.getDeltaAngle() != 0) {
      this.angle += this.getDeltaAngle() * updateRatio;
    }

    // test for ray cast collision
    final float targetX = this.x + this.getVelocityX() * updateRatio;
    final float targetY = this.y + this.getVelocityY() * updateRatio;

    if (targetX == this.x && targetY == this.y) {
      return;
    }

    if (this.checkForCollision(emitterOrigin, targetX, targetY)) {
      return;
    }

    if (this.getVelocityX() != 0) {
      this.x = targetX;
    }

    if (this.getVelocityY() != 0) {
      this.y = targetY;
    }

    if (this.getAccelerationX() != 0) {
      this.velocityX += this.getAccelerationX() * updateRatio;
    }

    if (this.getAccelerationY() != 0) {
      this.velocityY += this.getAccelerationY() * updateRatio;
    }
}
}
```
```java
class de.gurkenlabs.litiengine.graphics.animation.Animation {
@Override
  public void start() {
    this.playing = true;
    if (this.getKeyframes().isEmpty()) {
      return;
    }

    this.restart();
}@Override
  public void update() {
    // do nothing if the animation is not playing or the current keyframe is not finished
    if (!this.isPlaying()
        || Game.time().since(this.lastFrameUpdate) < this.getCurrentKeyFrame().getDuration()) {
      return;
    }

    // if we are not looping and the last keyframe is finished, we terminate the animation
    if (!this.isLooping() && this.isLastKeyFrame()) {
      this.terminate();
      return;
    }

    // make sure, we stay inside the keyframe list
    final int newFrameIndex =
        (this.getKeyframes().indexOf(this.currentFrame) + 1) % this.getKeyframes().size();
    final KeyFrame previousFrame = this.currentFrame;
    this.currentFrame = this.getKeyframes().get(newFrameIndex);

    for (KeyFrameListener listener : this.listeners) {
      listener.currentFrameChanged(previousFrame, this.currentFrame);
    }

    this.lastFrameUpdate = Game.loop().getTicks();
}
}
```
```java
class de.gurkenlabs.litiengine.graphics.animation.AnimationController {
@Override
  public void update() {
    for (final Animation animation : this.getAll()) {
      animation.update();
    }

    if (this.getCurrent() != null && this.getCurrent().isPaused()) {
      return;
    }

    final boolean playbackFinished = this.getCurrent() != null && !this.getCurrent().isPlaying();
    if (playbackFinished) {
      for (final AnimationListener listener : this.listeners) {
        listener.finished(this.getCurrent());
      }
    }

    if (this.getCurrent() == null || playbackFinished) {
      if (this.getDefault() != null) {
        this.play(this.getDefault().getName());
      } else {
        this.currentAnimation = null;
      }
    }
}
}
```
```java
class de.gurkenlabs.litiengine.graphics.RenderComponent {
private void handleFade() {
    if (this.fadeOutStart != -1) {
      final long timePassed = Game.time().since(this.fadeOutStart);
      this.currentAlpha = MathUtilities.clamp(1 - timePassed / (float) this.fadeOutTime, 0, 1);
      if (this.currentAlpha == 0f) {
        this.fadeOutStart = -1;
        this.fadeOutTime = -1;
      }

      return;
    }

    if (this.fadeInStart != -1) {
      final long timePassed = Game.time().since(this.fadeInStart);
      this.currentAlpha = MathUtilities.clamp(timePassed / (float) this.fadeInTime, 0, 1);
      if (this.currentAlpha == 1f) {
        this.fadeInStart = -1;
        this.fadeInTime = -1;
        this.currentAlpha = Float.NaN;
      }
    }
}public void fadeOut(final int ms) {
    this.fadeInStart = -1;
    this.fadeInTime = -1;
    this.fadeOutStart = Game.time().now();
    this.fadeOutTime = ms;
}public void fadeIn(final int ms) {
    this.fadeOutStart = -1;
    this.fadeOutTime = -1;
    this.fadeInStart = Game.time().now();
    this.fadeInTime = ms;
}
}
```
```java
class de.gurkenlabs.litiengine.entities.Trigger {
private boolean activate(final IEntity activator, final int tar) {
    if (!this.isLoaded()
        || this.isOneTimeTrigger && this.isActivated
        || this.getActivationType() == TriggerActivation.COLLISION
            && activator != null
            && this.collisionActivated.contains(activator)) {
      return false;
    }

    if (this.getCooldown() > 0 && Game.time().since(this.lastActivation) < this.getCooldown()) {
      return false;
    }

    List<Integer> triggerTargets = this.getTargets(tar);

    final TriggerEvent te = new TriggerEvent(this, activator, triggerTargets);

    if (!this.checkActivationPredicates(te)) {
      return false;
    }

    this.isActivated = true;
    if (activator != null) {
      this.collisionActivated.add(activator);
    }

    // if we actually have a trigger target, we send the message to the target
    for (final int target : triggerTargets) {
      final IEntity entity = this.getEnvironment().get(target);
      if (entity == null) {
        log.log(
            Level.WARNING,
            "trigger [{0}] was activated, but the trigger target [{1}] could not be found on the environment",
            new Object[] {this, target});
        continue;
      }

      entity.sendMessage(this, this.message);
    }

    // also send the trigger event to all registered consumers
    for (final TriggerActivatedListener listener : this.activatedListeners) {
      listener.activated(te);
    }

    if (this.isOneTimeTrigger) {
      this.getEnvironment().remove(this);
    }

    this.lastActivation = Game.time().now();
    return true;
}
}
```
```java
class de.gurkenlabs.litiengine.graphics.Camera {
private boolean isShakeEffectActive() {
    return this.getShakeTick() != 0
        && Game.time().since(this.getShakeTick()) < this.getShakeDuration();
}@Override
  public void update() {
    if (Game.world().camera() != null && !Game.world().camera().equals(this)) {
      return;
    }

    if (this.targetZoom > 0) {
      if (Game.time().since(this.zoomTick) >= this.zoomDelay) {
        this.zoom = this.targetZoom;
        this.targetZoom = 0;
        this.zoomDelay = 0;
        this.zoomTick = 0;
        this.zoomStep = 0;
      } else {
        this.zoom += this.zoomStep;
      }

      final ZoomChangedEvent event = new ZoomChangedEvent(this, this.getZoom());
      for (final ZoomChangedListener listener : this.zoomListeners) {
        listener.zoomChanged(event);
      }
    }

    if (this.panTime > 0) {
      if (--this.panTime <= 0) {
        this.setFocus(this.targetFocus);
        this.targetFocus = null;
      } else {
        double diff = this.panTime / (this.panTime + 1.0);
        this.focus =
            new Point2D.Double(
                this.focus.getX() * diff + this.targetFocus.getX() * (1.0 - diff),
                this.focus.getY() * diff + this.targetFocus.getY() * (1.0 - diff));
      }
    }

    if (!this.isShakeEffectActive()) {
      this.shakeOffsetX = 0;
      this.shakeOffsetY = 0;
      return;
    }

    if (Game.time().since(this.lastShake) > this.shakeDelay) {
      this.shakeOffsetX = this.getShakeIntensity() * ThreadLocalRandom.current().nextGaussian();
      this.shakeOffsetY = this.getShakeIntensity() * ThreadLocalRandom.current().nextGaussian();
      this.lastShake = Game.time().now();
    }
}@Override
  public void setZoom(final float targetZoom, final int delay) {
    if (delay == 0) {

      this.zoom = targetZoom;
      this.targetZoom = 0;
      this.zoomDelay = 0;
      this.zoomTick = 0;
      this.zoomStep = 0;

      final ZoomChangedEvent event = new ZoomChangedEvent(this, targetZoom);
      for (final ZoomChangedListener listener : this.zoomListeners) {
        listener.zoomChanged(event);
      }
    } else {
      this.zoomTick = Game.time().now();
      this.targetZoom = targetZoom;
      this.zoomDelay = delay;

      final double tickduration = 1000 / (double) Game.loop().getTickRate();
      final double tickAmount = delay / tickduration;
      final float totalDelta = this.targetZoom - this.zoom;
      this.zoomStep = tickAmount > 0 ? (float) (totalDelta / tickAmount) : totalDelta;
    }
}@Override
  public void shake(final double intensity, final int delay, final int shakeDuration) {
    this.shakeTick = Game.time().now();
    this.shakeDelay = delay;
    this.shakeIntensity = intensity;
    this.shakeDuration = shakeDuration;
}
}
```
```java
class de.gurkenlabs.litiengine.entities.Creature {
public void setSpritesheetName(String spritesheetName) {
    if (this.spritesheetName != null && this.spritesheetName.equals(spritesheetName)) {
      return;
    }

    this.spritesheetName = spritesheetName;
    this.updateAnimationController();
}public boolean isIdle() {
    return Game.time().since(this.lastMoved) > IDLE_DELAY;
}@Override
  public void setLocation(final Point2D position) {
    if (this.isDead() || position == null) {
      return;
    }

    final Point2D oldLocation = this.getLocation();
    super.setLocation(position);

    if (Game.hasStarted() && this.isLoaded()) {
      this.lastMoved = Game.time().now();
      this.fireMovedEvent(
          new EntityMovedEvent(
              this, this.getX() - oldLocation.getX(), this.getY() - oldLocation.getY()));
    }
}
}
```
```java
class de.gurkenlabs.litiengine.gui.screens.ScreenManager {
public void display(final String screenName) {
    if (this.current() != null && this.current().getName().equalsIgnoreCase(screenName)) {
      log.log(
          Level.INFO,
          "Skipping displaying of screen {0} because it is already the current screen.",
          screenName);
      return;
    }

    if (this.screens.stream()
        .noneMatch(element -> element.getName().equalsIgnoreCase(screenName))) {
      log.log(
          Level.WARNING,
          "Could not display the screen {0} because there is no screen with the specified name.",
          screenName);
      return;
    }

    Screen screen = this.get(screenName);
    if (screen == null) {
      return;
    }

    this.display(screen);
}public void add(final Screen screen) {
    screen.setWidth(Game.window().getWidth());
    screen.setHeight(Game.window().getHeight());
    this.screens.add(screen);

    if (this.current() == null) {
      this.display(screen);
    }
}public void remove(Screen screen) {
    this.screens.remove(screen);
    if (this.current() == screen) {
      if (!this.screens.isEmpty()) {
        this.display(this.screens.get(0));
      } else {
        this.display((Screen) null);
      }
    }
}public void display(@Nullable final Screen screen) {
    if (Game.hasStarted() && Game.time().since(this.lastScreenChange) < this.getChangeCooldown()) {
      log.log(
          Level.INFO,
          "Skipping displaying of screen {0} because screen changing is currently on cooldown.",
          screen != null ? screen.getName() : "");
      return;
    }

    final Screen previous = this.current();
    if (previous != null) {
      previous.suspend();
    }

    if (screen != null && !this.screens.contains(screen)) {
      this.screens.add(screen);
    }

    this.currentScreen = screen;
    if (!Game.isInNoGUIMode() && this.current() != null) {
      this.current().prepare();
    }

    this.lastScreenChange = Game.loop().getTicks();

    final ScreenChangedEvent event = new ScreenChangedEvent(this.current(), previous);
    for (final ScreenChangedListener listener : this.screenChangedListeners) {
      listener.changed(event);
    }
}
}
```
```java
class de.gurkenlabs.litiengine.abilities.Ability {
public boolean isOnCooldown() {
    return (this.getCurrentExecution() != null
        && this.getCurrentExecution().getExecutionTicks() > 0
        && Game.time().since(this.getCurrentExecution().getExecutionTicks())
            < this.getAttributes().cooldown().get());
}public boolean isActive() {
    return this.getCurrentExecution() != null
        && Game.time().since(this.getCurrentExecution().getExecutionTicks())
            < this.getAttributes().duration().get();
}@Nullable
  public AbilityExecution cast() {
    if (!this.canCast()) {
      return null;
    }
    this.currentExecution = new AbilityExecution(this);

    for (final AbilityCastListener listener : this.abilityCastListeners) {
      listener.abilityCast(this.currentExecution);
    }

    return this.getCurrentExecution();
}public float getRemainingCooldownInSeconds() {
    if (this.getCurrentExecution() == null
        || this.getExecutor() == null
        || this.getExecutor().isDead()) {
      return 0;
    }

    // calculate cooldown in seconds
    return (float)
        (!this.canCast()
            ? (this.getAttributes().cooldown().get()
                    - Game.time().since(this.getCurrentExecution().getExecutionTicks()))
                * 0.001
            : 0);
}
}
```
```java
class de.gurkenlabs.litiengine.entities.EntityHitEvent {
EntityHitEvent(
      final ICombatEntity hitEntity,
      @Nullable final Ability ability,
      final int damage,
      final boolean kill) {
    super(hitEntity);
    this.executor = ability != null ? ability.getExecutor() : null;
    this.hitEntity = hitEntity;
    this.ability = ability;
    this.damage = damage;
    this.kill = kill;
    this.time = Game.time().now();
}
}
```
```java
class de.gurkenlabs.litiengine.graphics.emitters.Emitter {
public void delete() {
    this.deactivate();
    if (Game.world().environment() != null) {
      Game.world().environment().remove(this);
    }
}public void activate() {
    if (this.activated) {
      return;
    }

    this.activated = true;
    this.activationTick = Game.time().now();
    Game.loop().attach(this);
}@Override
  public void update() {
    if (this.isPaused()) {
      return;
    }

    // clear particles if the effect time to life is reached
    if (this.isFinished()) {
      for (EmitterFinishedListener listener : this.finishedListeners) {
        listener.finished(this);
      }

      this.delete();
      return;
    }

    final float updateRatio = (float) this.data().getUpdateRate() / Game.loop().getTickRate();
    for (final Particle p : this.getParticles().stream().collect(Collectors.toList())) {
      if (this.particleCanBeRemoved(p)) {
        // remove dead particles
        this.particles.remove(p);
        continue;
      }

      p.update(this.getOrigin(), updateRatio);
    }

    this.aliveTime = Game.time().since(this.activationTick);
    if ((this.data().getSpawnRate() == 0
        || Game.time().since(this.lastSpawn) >= this.data().getSpawnRate())) {
      this.lastSpawn = Game.time().now();
      this.spawnParticle();
    }
}
}
```
```java
class de.gurkenlabs.litiengine.GameLoop {
@Override
  public int perform(int delay, Runnable action) {
    final long d = Game.time().toTicks(delay);

    TimedAction a = new TimedAction(this.getTicks() + d, action);
    this.actions.add(a);

    return a.getId();
}
}
```
```java
class de.gurkenlabs.litiengine.environment.EntitySpawner {
protected boolean shouldSpawn() {
    return this.lastSpawnWave == 0
        || Game.time().since(this.lastSpawnWave) >= this.getSpawnInterval();
}@Override
  public void update() {
    if (!this.shouldSpawn()) {
      return;
    }

    this.spawnNewEntities();
    this.lastSpawnWave = Game.time().now();
}
}
```
```java
class de.gurkenlabs.litiengine.graphics.FreeFlightCamera {
@Override
  public void update() {
    this.handleFreeFlightCamera();
}public FreeFlightCamera(double x, double y) {
    this(new Point2D.Double(x, y));
}
}
```
```java
class de.gurkenlabs.litiengine.environment.Environment {
public void unload() {
    if (!this.loaded) {
      return;
    }

    // unregister all updatable entities from the current environment
    for (final IEntity entity : this.allEntities.values()) {
      this.unload(entity);
    }

    this.loaded = false;
    this.fireEvent(l -> l.unloaded(this));
}private static void loadUpdatableOrEmitterEntity(IEntity entity) {
    if (entity instanceof Emitter) {
      final Emitter emitter = (Emitter) entity;
      if (emitter.isActivateOnInit()) {
        emitter.activate();
      }
    } else if (entity instanceof IUpdateable) {
      Game.loop().attach((IUpdateable) entity);
    }
}public void clear() {
    Game.physics().clear();

    this.combatEntities.clear();
    this.mobileEntities.clear();
    this.gravityForces.clear();
    this.layerEntities.clear();
    this.entitiesByTag.clear();
    this.allEntities.clear();

    for (RenderType renderType : RenderType.values()) {
      this.miscEntities.get(renderType).clear();
      this.renderListeners.get(renderType).clear();
      this.renderables.get(renderType).clear();
    }

    dispose(this.allEntities.values());
    dispose(this.triggers);
    this.emitters.clear();
    this.colliders.clear();
    this.props.clear();
    this.creatures.clear();
    this.staticShadows.clear();
    this.combatEntities.clear();
    this.mobileEntities.clear();
    this.lightSources.clear();
    this.spawnPoints.clear();
    this.soundSources.clear();
    this.mapAreas.clear();
    this.triggers.clear();

    this.ambientLight = null;
    this.staticShadowLayer = null;

    for (Map<Integer, IEntity> type : this.miscEntities.values()) {
      type.clear();
    }

    this.initialized = false;

    this.fireEvent(l -> l.cleared(this));
}private void load(final IEntity entity) {
    // an entity can only exist on one environment at a time, so remove it from the current one
    if (entity.getEnvironment() != null) {
      entity.getEnvironment().remove(entity);
    }

    // 1. add to physics engine
    loadPhysicsEntity(entity);

    // 2. register for update or activate
    loadUpdatableOrEmitterEntity(entity);

    // 3. if a gravity is defined, add a gravity force to the entity
    if (entity instanceof IMobileEntity && this.getGravity() != 0) {
      this.addGravityForce((IMobileEntity) entity);
    }

    // 4. attach all controllers
    entity.attachControllers();

    if (this.loaded && (entity instanceof LightSource || entity instanceof StaticShadow)) {
      this.updateLighting(entity);
    }

    entity.loaded(this);
}private void unload(final IEntity entity) {
    // 1. remove from physics engine
    if (entity instanceof ICollisionEntity) {
      Game.physics().remove((ICollisionEntity) entity);
    }

    // 2. unregister from update
    if (entity instanceof IUpdateable) {
      Game.loop().detach((IUpdateable) entity);
    }

    if (entity instanceof IMobileEntity) {
      this.removeGravity((IMobileEntity) entity);
    }

    // 3. detach all controllers
    entity.detachControllers();

    if (entity instanceof Emitter) {
      Emitter em = (Emitter) entity;
      em.deactivate();
    }

    if (this.loaded && (entity instanceof LightSource || entity instanceof StaticShadow)) {
      this.updateLighting(entity);
    }

    entity.removed(this);
}public void remove(final IEntity entity) {
    if (entity == null) {
      return;
    }

    this.allEntities.remove(entity.getMapId());
    Iterator<List<IEntity>> iter = this.layerEntities.values().iterator();
    while (iter.hasNext()) {
      List<IEntity> layer = iter.next();
      if (layer.remove(entity) && layer.isEmpty()) {
        iter.remove();
      }
    }
    if (this.miscEntities.get(entity.getRenderType()) != null) {
      this.miscEntities.get(entity.getRenderType()).values().remove(entity);
    }

    for (String tag : entity.getTags()) {
      if (this.getEntitiesByTag().containsKey(tag)) {
        this.getEntitiesByTag().get(tag).remove(entity);

        if (this.getEntitiesByTag().get(tag).isEmpty()) {
          this.getEntitiesByTag().remove(tag);
        }
      }
    }

    if (entity instanceof Emitter) {
      Emitter emitter = (Emitter) entity;
      this.removeEmitter(emitter);
    }

    if (entity instanceof MapArea) {
      this.mapAreas.remove(entity);
    }

    if (entity instanceof Prop) {
      this.props.remove(entity);
    }

    if (entity instanceof Creature) {
      this.creatures.remove(entity);
    }

    if (entity instanceof CollisionBox) {
      this.colliders.remove(entity);
      this.staticShadows.removeIf(x -> x.getOrigin() != null && x.getOrigin().equals(entity));
    }

    if (entity instanceof LightSource) {
      this.lightSources.remove(entity);
      this.updateLighting(entity);
    }

    if (entity instanceof Trigger) {
      this.triggers.remove(entity);
    }

    if (entity instanceof Spawnpoint) {
      this.spawnPoints.remove(entity);
    }
    if (entity instanceof SoundSource) {
      this.soundSources.remove(entity);
    }

    if (entity instanceof StaticShadow) {
      this.staticShadows.remove(entity);
      this.updateLighting(entity);
    }

    if (entity instanceof IMobileEntity) {
      this.mobileEntities.values().remove(entity);
    }

    if (entity instanceof ICombatEntity) {
      this.combatEntities.values().remove(entity);
    }

    this.unload(entity);

    this.fireEntityEvent(l -> l.entityRemoved(entity));
}
}
```
```java
class de.gurkenlabs.litiengine.physics.MovementController {
@Override
  public void update() {
    this.handleForces();
    this.handleMovement();
}
}
```
```java
class de.gurkenlabs.litiengine.Game {
static synchronized void terminate() {
    if (!initialized) {
      return;
    }

    hasStarted = false;
    initialized = false;

    config().save();
    gameLoop.terminate();
    tweenEngine.terminate();
    soundEngine.terminate();

    world().clear();

    for (final GameListener listener : gameListeners) {
      try {
        listener.terminated();
      } catch (Exception e) {
        log().log(Level.WARNING, "game listener threw an exception during shutdown", e);
      }
    }

    gameLoop = null;
    screenManager = null;
    gameWindow = null;
}public static synchronized void start() {
    if (!initialized) {
      throw new IllegalStateException(
          "The game cannot be started without being first initialized. Call Game.init(...) before Game.start().");
    }

    gameLoop.start();
    tweenEngine.start();
    soundEngine.start();

    for (final GameListener listener : gameListeners) {
      listener.started();
    }

    hasStarted = true;
}public static synchronized void init(String... args) {
    if (initialized) {
      log().log(Level.INFO, "The game has already been initialized.");
      return;
    }

    log.init();
    handleCommandLineArguments(args);

    config().load();
    Locale.setDefault(new Locale(config().client().getCountry(), config().client().getLanguage()));

    gameLoop = new GameLoop("Main Update Loop", config().client().getMaxFps());
    loop().attach(physics());
    loop().attach(world());

    // setup default exception handling for render and update loop
    setUncaughtExceptionHandler(
        new DefaultUncaughtExceptionHandler(config().client().exitOnError()));

    screenManager = new ScreenManager();
    gameWindow = new GameWindow();

    // initialize  the game window
    window().init();
    world.setCamera(new Camera());

    for (GameListener listener : gameListeners) {
      listener.initialized(args);
    }

    if (!isInNoGUIMode()) {
      window().getRenderComponent().onRendered(g -> metrics().render(g));

      graphics()
          .addEntityRenderedListener(
              e -> DebugRenderer.renderEntityDebugInfo(e.getGraphics(), e.getEntity()));

      window().getRenderComponent().onFpsChanged(fps -> metrics().setFramesPerSecond(fps));
      window()
          .setIcons(
              Arrays.asList(
                  Resources.images().get("liti-logo-x16.png"),
                  Resources.images().get("liti-logo-x20.png"),
                  Resources.images().get("liti-logo-x32.png"),
                  Resources.images().get("liti-logo-x48.png")));

      Input.keyboard()
          .onKeyTyped(
              KeyEvent.VK_PRINTSCREEN,
              key -> {
                // don't take a screenshot if a modifier is active
                if (key.getModifiers() != 0) {
                  return;
                }

                window().getRenderComponent().takeScreenshot();
              });
    }

    Runtime.getRuntime().addShutdownHook(new Thread(Game::terminate, "Shutdown"));

    initialized = true;
}
}
```


Response Format:
Provide the answer in **XML format** as follows:

#### If the method **cannot** return `null` at the specific call site:
```xml
<response>
  <reason><![CDATA[EXPLAIN WHY THE INVOCATION Game.loop() RESULT CANNOT BE NULL.]]></reason>
  <value>NO</value>
</response>

#### If the method can return null at the specific call site:
<response>
  <reason><![CDATA[EXPLAIN WHY THE INVOCATION Game.loop() RESULT CAN BE NULL.]]></reason>
  <value>YES</value>
</response>

#### If you are unsure or If there are any methods that directly or indirectly affect the return value and are not fully disclosed, request their declarations first, in the following format:
<response>
  <reason><![CDATA[EXPLAIN WHY THIS METHOD DECLARATION IS NECESSARY AND WHY YOU CANNOT MAKE A CONFIDENT DECISION WITHOUT IT]]></reason>
  <success>false</success>
  <methods>
    <method>methodName</method>
  </methods>
</response>

Additional Notes:
Be precise in your reasoning.
If a method’s return value depends on another method not provided, request its declaration before making a conclusion.
If the method can return null in this case but not in others, explain why it happens specifically for this call.

---ChatGPT.sendRequestToOpenAI---
Retrieving response from cache
---Response.<init>---
Creating Response:
```xml
<response>
  <reason><![CDATA[The method `Game.loop()` returns the static field `gameLoop`, which is initialized in the `Game.init(String... args)` method. In this method, a new `GameLoop` object is instantiated and assigned to `gameLoop`. Since `init()` must be called before `start()`, which is implied by the requirement of initializing the game, the `gameLoop` is guaranteed to be non-null during the lifetime of the game execution where `Game.loop()` is called. The absence of any code that could set `gameLoop` to null after its initialization ensures that `Game.loop()` cannot return null.]]></reason>
  <value>NO</value>
</response>
```
---Response.<init>---
Response created:
Disagreement: The method `Game.loop()` returns the static field `gameLoop`, which is initialized in the `Game.init(String... args)` method. In this method, a new `GameLoop` object is instantiated and assigned to `gameLoop`. Since `init()` must be called before `start()`, which is implied by the requirement of initializing the game, the `gameLoop` is guaranteed to be non-null during the lifetime of the game execution where `Game.loop()` is called. The absence of any code that could set `gameLoop` to null after its initialization ensures that `Game.loop()` cannot return null.
---AdvancedNullAwayCodeFix.resolveMethodDereferenceError---
Method is not returning nullable on call site. Injecting suppression annotation.
---AdvancedNullAwayCodeFix.constructCastToNonnullChange---
Constructing cast to nonnull change for reason: The method `Game.loop()` returns the static field `gameLoop`, which is initialized in the `Game.init(String... args)` method. In this method, a new `GameLoop` object is instantiated and assigned to `gameLoop`. Since `init()` must be called before `start()`, which is implied by the requirement of initializing the game, the `gameLoop` is guaranteed to be non-null during the lifetime of the game execution where `Game.loop()` is called. The absence of any code that could set `gameLoop` to null after its initialization ensures that `Game.loop()` cannot return null.
---ChatGPT.ask---
Asking ChatGPT:
For the reason you mentioned earlier:

"The method `Game.loop()` returns the static field `gameLoop`, which is initialized in the `Game.init(String... args)` method. In this method, a new `GameLoop` object is instantiated and assigned to `gameLoop`. Since `init()` must be called before `start()`, which is implied by the requirement of initializing the game, the `gameLoop` is guaranteed to be non-null during the lifetime of the game execution where `Game.loop()` is called. The absence of any code that could set `gameLoop` to null after its initialization ensures that `Game.loop()` cannot return null."

in the method below, the expression Game.loop() is not nullable at the point it is used.

```java
@Override
  public void loaded(Environment environment) {
    environmentLoaded = Game.loop().getTicks();
}
```
Please Summarize the reason in max 5 words and rewrite the method so that at the line "    environmentLoaded = Game.loop().getTicks();", at the occurrence of: "Game.loop()" is replaced with `NullabilityUtil.castToNonnull(Game.loop(), summary of reason)`
Replace "REASON" with the exact reason summary I provide to you (maximum 5 words), not with a generic explanation like "checked to be nonnull".
see the example below, for expression `foo.getBar()`, to wrap it with `NullabilityUtil.castToNonnull(foo.getBar(), "reason")`.

```java
public t(){
    String l = foo.getBar();
}
```

will be:
```java
public t(){
    String l = NullabilityUtil.castToNonnull(foo.getBar(), "checked to be nonnull");
}
```

### Instructions:

Do not import any additional classes.

Do not add Java comments.

Only modify relevant lines as required.

Return only the modified method wrapped in the XML format shown below.

Place the Java code inside the <code> tag using a CDATA block with ```java formatting.

Just give me the fixed code snippet in XML format in <response> tag like the example below. I will apply the fix to my codebase. Do not import any additional libraries or classes or add java comments. If you can provide the fixed code snippet, please provide it in the following format and place the code snippet in the <code> tag within ```java block.
<response>
  <success>true</success>
  <code><![CDATA[
  ```java
  Your fixed code snippet here
  ```
    ]]>
  </code>
</response>

---ChatGPT.sendRequestToOpenAI---
Retrieving response from cache
---Response.<init>---
Creating Response:
<response>
  <success>true</success>
  <code><![CDATA[
  ```java
@Override
  public void loaded(Environment environment) {
    environmentLoaded = NullabilityUtil.castToNonnull(Game.loop(), "cannot return null").getTicks();
}
  ```
    ]]>
  </code>
</response>
---Response.<init>---
Response created:
@Override
  public void loaded(Environment environment) {
    environmentLoaded = NullabilityUtil.castToNonnull(Game.loop(), "cannot return null").getTicks();
}
---ChatGPT.fixDereferenceByAddingCastToNonnull---
Fixing the error by adding castToNonnull
---AdvancedNullAwayCodeFix.fixTriggeredErrorsForLocation---
Resolving unresolvable error for triggered error: Type='DEREFERENCE_NULLABLE', message='dereferenced expression Game.loop() is @Nullable'
/home/nima/Developer/nullness-benchmarks/litiengine/src/de/gurkenlabs/litiengine/GameWindow.java:379
            Game.loop().setTickRate(ICONIFIED_MAX_FPS);
---AdvancedNullAwayCodeFix.fix---
Fixing error: Type='DEREFERENCE_NULLABLE', message='dereferenced expression Game.loop() is @Nullable'
/home/nima/Developer/nullness-benchmarks/litiengine/src/de/gurkenlabs/litiengine/GameWindow.java:379
            Game.loop().setTickRate(ICONIFIED_MAX_FPS);
---AdvancedNullAwayCodeFix.resolveDereferenceError---
Resolving dereference error: Type='DEREFERENCE_NULLABLE', message='dereferenced expression Game.loop() is @Nullable'
/home/nima/Developer/nullness-benchmarks/litiengine/src/de/gurkenlabs/litiengine/GameWindow.java:379
            Game.loop().setTickRate(ICONIFIED_MAX_FPS);
---AdvancedNullAwayCodeFix.resolveDereferenceError---
Checking nullability possibility at error point
---ChatGPT.checkNullabilityPossibilityAtErrorPoint---
Asking if the expression can be null at error point point
---ChatGPT.ask---
Asking ChatGPT:
In the method below, is there a possibility that the expression "Game.loop()" at line "Game.loop().setTickRate(ICONIFIED_MAX_FPS);" is null?
private static void initializeWindowEventListeners(Window window) {

    window.addWindowStateListener(
        e -> {
          if (e.getNewState() == Frame.ICONIFIED) {
            Game.loop().setTickRate(ICONIFIED_MAX_FPS);
          } else {
            Game.loop().setTickRate(Game.config().client().getMaxFps());
          }
        });

    window.addWindowFocusListener(
        new WindowFocusListener() {
          @Override
          public void windowLostFocus(WindowEvent e) {
            if (Game.config().graphics().reduceFramesWhenNotFocused()) {
              Game.loop().setTickRate(NONE_FOCUS_MAX_FPS);
            }
          }

          @Override
          public void windowGainedFocus(WindowEvent e) {
            Game.loop().setTickRate(Game.config().client().getMaxFps());
          }
        });

    window.addWindowListener(
        new WindowAdapter() {
          @Override
          public void windowClosing(final WindowEvent event) {
            Game.exit();
          }
        });
}
Give a single-word answer in XML format. If it is possible for the expression to be null, respond with:
```xml
<response>
    <reason><![CDATA[YOUR REASON]]></reason>
    <value>YES</value>
</response>
```
If it is not possible for the expression to be null, respond with:
```xml
<response>
    <reason><![CDATA[YOUR REASON]]></reason>
    <value>NO</value>
</response>
```
If you are unsure or need more information, respond with where you can ask for more details or what specific information you need.

If additional information is required, list each request inside a `<request>` tag. If no additional information is needed, omit the `<requests>` section.

Respond with:
```xml
<response>
    <reason><![CDATA[YOUR REASON]]></reason>
    <value>UNKNOWN</value>
    <!-- Include <requests> only if additional information is needed -->
    <requests>
        <request><![CDATA[YOUR REQUEST 1]]></request>
        <request><![CDATA[YOUR REQUEST 2]]></request>
    </requests>
</response>
```
---ChatGPT.sendRequestToOpenAI---
Retrieving response from cache
---Response.<init>---
Creating Response:
```xml
<response>
    <reason><![CDATA[The possibility of Game.loop() being null depends on the implementation of the Game class and how the loop() method is defined. Without information on the initialization and behavior of Game.loop(), it's unclear whether a null value might be returned.]]></reason>
    <value>UNKNOWN</value>
    <requests>
        <request><![CDATA[Provide the implementation of the Game class, especially the loop() method.]]></request>
        <request><![CDATA[Explain the initialization sequence and lifecycle management for the Game.loop() method.]]></request>
    </requests>
</response>
```
---Response.<init>---
Response created:
Unknown: The possibility of Game.loop() being null depends on the implementation of the Game class and how the loop() method is defined. Without information on the initialization and behavior of Game.loop(), it's unclear whether a null value might be returned.
---AdvancedNullAwayCodeFix.resolveMethodDereferenceError---
Resolving method dereference error.
---AdvancedNullAwayCodeFix.resolveMethodDereferenceError---
Method is in annotated package. Checking if the method is returning nullable.
---AdvancedNullAwayCodeFix.investigateMethodReturnNullability---
Checking if the method is returning nullable.
---ChatGPT.checkIfMethodIsReturningNullable---
Asking if the method is returning nullable: loop()
---ChatGPT.ask---
Asking ChatGPT:
In the method below, is there a possibility that the method returns null based only on its body? Consider the following points:

- The method may have multiple return paths; consider all return statements.
- If the method calls another method, do not assume its return value unless its full declaration is provided. Request its declaration if needed.
- The method may throw an exception instead of returning null. An exception path should not be considered a null return.
- Ensure you request the declarations of any methods whose return values directly or indirectly impact this method’s return value before making a conclusion.
- Carefully analyze all conditions and prior operations that may guarantee a non-null return value.

@Nullable public static IGameLoop loop() {
    return gameLoop;
}

Here are the method definitions in addition to the method inquired:

Depth: 0
```java
class de.gurkenlabs.litiengine.Game {
@Nullable public static IGameLoop loop() {
    return gameLoop;
}
}
```


Response Format:
Provide the answer in **XML format** as follows:

#### If the method **cannot** return `null`:
```xml
<response>
  <reason><![CDATA[EXPLAIN WHY THE METHOD CANNOT RETURN NULL]]></reason>
  <value>NO</value>
</response>
```

#### If the method can return null:
```xml
<response>
  <reason><![CDATA[EXPLAIN WHY THE METHOD CAN RETURN NULL]]></reason>
  <value>YES</value>
</response>
```

#### If you are unsure or need more information, respond with where you can ask for more details or what specific information you need.

#### If you are unsure or If there are any methods that directly or indirectly affect the return value and are not fully disclosed, request their declarations first, in the following format:
<response>
  <reason><![CDATA[YOUR REASON]]></reason>
  <value>UNKNOWN</value>
  <methods>
    <method>methodName</method>
  </methods>
</response>

If additional information is required other than method declaration, list each request inside a `<request>` tag. If no additional information is needed, omit the `<requests>` section.

Respond with:
```xml
<response>
    <reason><![CDATA[YOUR REASON]]></reason>
    <value>UNKNOWN</value>
    <!-- Include <requests> only if additional information is needed -->
    <requests>
        <request><![CDATA[YOUR REQUEST 1]]></request>
        <request><![CDATA[YOUR REQUEST 2]]></request>
    </requests>
</response>
```

Additional Notes:
Be precise in your reasoning.
If a method’s return value depends on another method not provided, request its declaration before making a conclusion.
If the method can return null in some cases but not others, explain under what conditions it can happen.

---ChatGPT.sendRequestToOpenAI---
Retrieving response from cache
---Response.<init>---
Creating Response:
```xml
<response>
  <reason><![CDATA[The method `loop` returns the variable `gameLoop`. Without the initialization or assignment details of `gameLoop`, it's unclear whether it can be null. The possibility of `gameLoop` being uninitialized or set to null elsewhere in the program means `loop` could potentially return null. Further information on `gameLoop` is required.]]></reason>
  <value>UNKNOWN</value>
  <requests>
    <request><![CDATA[Please provide the declaration and initialization of the variable `gameLoop` in the class `de.gurkenlabs.litiengine.Game`.]]></request>
  </requests>
</response>
```
---Response.<init>---
Response created:
Unknown: The method `loop` returns the variable `gameLoop`. Without the initialization or assignment details of `gameLoop`, it's unclear whether it can be null. The possibility of `gameLoop` being uninitialized or set to null elsewhere in the program means `loop` could potentially return null. Further information on `gameLoop` is required.
---AdvancedNullAwayCodeFix.investigateMethodReturnNullability---
Could not determine the nullability and model did not ask for any method.
---ChatGPT.checkIfMethodIsReturningNullableOnCallSite---
Asking if the method is returning nullable on the call site: Game.loop()
---ChatGPT.ask---
Asking ChatGPT:
In the method below, is there a possibility that the method returns null at the given call site?

```java
@Nullable public static IGameLoop loop() {
    return gameLoop;
}
```

## Guidelines:
- The method may have multiple return paths; consider all return statements.
- If the method calls another method, do not assume its return value unless its full declaration is provided. Request its declaration if needed.
- The method may throw an exception instead of returning null. An exception path should not be considered a null return.
- Ensure you request the declarations of any methods whose return values directly or indirectly impact this method’s return value before making a conclusion.
- If the method returns a value that is determined by a parameter, evaluate based on the actual argument at the given call site.
- Analyze based only on the specific invocation provided. Do not generalize to all possible inputs.- If the return value is guaranteed to be non-null at the call site, the answer should be a definitive NO.
- Do not generalize based on all possible inputs—your answer must be based only on the given invocation.
- Focus only on the given call site, not all possible invocations.

### call site:
Game.loop()

Here are the method definitions and the call chain for this method, showing the sequence of calls from the method to its callers at each depth level:

Depth: 0
```java
class de.gurkenlabs.litiengine.Game {
@Nullable public static IGameLoop loop() {
    return gameLoop;
}
}
```
Depth: 1
```java
class de.gurkenlabs.litiengine.environment.GameWorld {
public void loadEnvironment(@Nullable final Environment env) {
    Lock lock = Game.loop().getLock();
    lock.lock();
    try {
      unloadEnvironment();
      this.environment = env;
      if (env != null) {
        this.addEnvironment(env);

        if (env.getGravity() == 0 && this.gravity() != 0) {
          env.setGravity(this.gravity());
        }

        env.load();
        for (final EnvironmentLoadedListener listener : this.loadedListeners) {
          listener.loaded(env);
        }

        // call map specific listeners
        String mapName = getMapName(env);
        if (mapName != null && this.environmentLoadedListeners.containsKey(mapName)) {

          // for the default camera we center the camera on the environment
          if (this.camera().getClass().equals(Camera.class)) {
            camera().setFocus(env.getCenter());
          }

          for (EnvironmentLoadedListener listener : this.environmentLoadedListeners.get(mapName)) {
            listener.loaded(env);
          }
        }
      }
    } finally {
      lock.unlock();
    }
}public void setCamera(@Nullable final ICamera cam) {
    if (this.camera() != null) {
      Game.loop().detach(camera);
    }

    camera = cam;

    if (cam != null && !Game.isInNoGUIMode()) {
      Game.loop().attach(cam);
      cam.updateFocus();
    }
}
}
```
```java
class de.gurkenlabs.litiengine.entities.behavior.EntityNavigator {
public EntityNavigator(final IMobileEntity entity, final PathFinder pathFinder) {
    this.cancelNavigationConditions = new CopyOnWriteArrayList<>();
    this.listeners = new CopyOnWriteArrayList<>();
    this.entity = entity;
    this.pathFinder = pathFinder;
    this.setAcceptableError(DEFAULT_ACCEPTABLE_ERROR);
    Game.loop().attach(this);
}
}
```
```java
class de.gurkenlabs.litiengine.GameWindow {
private static void initializeWindowEventListeners(Window window) {

    window.addWindowStateListener(
        e -> {
          if (e.getNewState() == Frame.ICONIFIED) {
            Game.loop().setTickRate(ICONIFIED_MAX_FPS);
          } else {
            Game.loop().setTickRate(Game.config().client().getMaxFps());
          }
        });

    window.addWindowFocusListener(
        new WindowFocusListener() {
          @Override
          public void windowLostFocus(WindowEvent e) {
            if (Game.config().graphics().reduceFramesWhenNotFocused()) {
              Game.loop().setTickRate(NONE_FOCUS_MAX_FPS);
            }
          }

          @Override
          public void windowGainedFocus(WindowEvent e) {
            Game.loop().setTickRate(Game.config().client().getMaxFps());
          }
        });

    window.addWindowListener(
        new WindowAdapter() {
          @Override
          public void windowClosing(final WindowEvent event) {
            Game.exit();
          }
        });
}
}
```
```java
class de.gurkenlabs.litiengine.gui.screens.ScreenManager {
public void display(@Nullable final Screen screen) {
    if (Game.hasStarted() && Game.time().since(this.lastScreenChange) < this.getChangeCooldown()) {
      log.log(
          Level.INFO,
          "Skipping displaying of screen {0} because screen changing is currently on cooldown.",
          screen != null ? screen.getName() : "");
      return;
    }

    final Screen previous = this.current();
    if (previous != null) {
      previous.suspend();
    }

    if (screen != null && !this.screens.contains(screen)) {
      this.screens.add(screen);
    }

    this.currentScreen = screen;
    if (!Game.isInNoGUIMode() && this.current() != null) {
      this.current().prepare();
    }

    this.lastScreenChange = Game.loop().getTicks();

    final ScreenChangedEvent event = new ScreenChangedEvent(this.current(), previous);
    for (final ScreenChangedListener listener : this.screenChangedListeners) {
      listener.changed(event);
    }
}
}
```
```java
class de.gurkenlabs.litiengine.abilities.effects.Effect {
@Override
  public void update() {

    for (final Iterator<EffectApplication> iterator = this.getActiveAppliances().iterator();
        iterator.hasNext(); ) {
      final EffectApplication appliance = iterator.next();
      // if the effect duration is reached
      if (this.hasEnded(appliance)) {

        iterator.remove();
        this.cease(appliance);
      }
    }

    // 4. unregister if all appliances are finished
    if (this.getActiveAppliances().isEmpty()) {
      Game.loop().detach(this);
    }
}public void apply(final Shape impactArea) {
    final List<ICombatEntity> affected = this.lookForAffectedEntities(impactArea);
    for (final ICombatEntity affectedEntity : affected) {
      this.apply(affectedEntity);
    }

    this.appliances.add(new EffectApplication(affected, impactArea));

    // if it is the first appliance -> register for update
    if (this.appliances.size() == 1) {
      Game.loop().attach(this);
    }
}
}
```
```java
class de.gurkenlabs.litiengine.GameTime {
public long toTicks(final int milliseconds) {
    return this.toTicks(milliseconds, Game.loop().getTickRate());
}public long since(final long tick) {
    return toMilliseconds(Game.loop().getTicks() - tick);
}public long now() {
    return Game.loop().getTicks();
}public long sinceGameStart() {
    return this.toMilliseconds(Game.loop().getTicks());
}@Override
  public void loaded(Environment environment) {
    environmentLoaded = Game.loop().getTicks();
}public long toMilliseconds(final long ticks) {
    return this.toMilliseconds(ticks, Game.loop().getTickRate());
}
}
```
```java
class de.gurkenlabs.litiengine.GameMetrics {
@Override
  public void render(final Graphics2D g) {
    this.updateMetrics();

    if (!Game.config().client().showGameMetrics()) {
      return;
    }

    this.currentOffsetY = 0;

    g.setColor(this.renderColor);

    // render client metrics
    this.drawTitle(g, "[client]");
    this.drawMetric(g, "fps       : " + this.getFramesPerSecond());
    this.drawMetric(g, "max fps   : " + this.maxFramesPerSecond);
    this.drawMetric(g, "updatables: " + Game.loop().getUpdatableCount());

    // render jvm metrics if debug is enabled
    if (Game.config().debug().isDebugEnabled()) {
      this.drawTitle(g, "[jvm]");
      this.drawMetric(g, "java      : " + this.javaVersion);
      this.drawMetric(g, "memory    : " + String.format("%-5.5s", this.usedMemory) + " MB");
      this.drawMetric(g, "threads   : " + Thread.activeCount());
    }

    // render rendering metrics
    if (!this.renderMetrics.isEmpty()) {
      this.drawTitle(g, "[update]");

      for (RenderMetrics metric : this.renderMetrics) {
        this.drawMetric(g, metric.toString());
      }

      this.renderMetrics.clear();
    }
}
}
```
```java
class de.gurkenlabs.litiengine.graphics.emitters.Emitter {
public void deactivate() {
    if (!this.activated) {
      return;
    }

    this.activated = false;
    this.getParticles().clear();
    this.aliveTime = 0;
    this.activationTick = 0;
    this.lastSpawn = 0;
    Game.loop().detach(this);
}public void activate() {
    if (this.activated) {
      return;
    }

    this.activated = true;
    this.activationTick = Game.time().now();
    Game.loop().attach(this);
}@Override
  public void update() {
    if (this.isPaused()) {
      return;
    }

    // clear particles if the effect time to life is reached
    if (this.isFinished()) {
      for (EmitterFinishedListener listener : this.finishedListeners) {
        listener.finished(this);
      }

      this.delete();
      return;
    }

    final float updateRatio = (float) this.data().getUpdateRate() / Game.loop().getTickRate();
    for (final Particle p : this.getParticles().stream().collect(Collectors.toList())) {
      if (this.particleCanBeRemoved(p)) {
        // remove dead particles
        this.particles.remove(p);
        continue;
      }

      p.update(this.getOrigin(), updateRatio);
    }

    this.aliveTime = Game.time().since(this.activationTick);
    if ((this.data().getSpawnRate() == 0
        || Game.time().since(this.lastSpawn) >= this.data().getSpawnRate())) {
      this.lastSpawn = Game.time().now();
      this.spawnParticle();
    }
}
}
```
```java
class de.gurkenlabs.litiengine.entities.behavior.IBehaviorController {
public default void attach() {
    Game.loop().attach(this);
}public default void detach() {
    Game.loop().detach(this);
}
}
```
```java
class de.gurkenlabs.litiengine.abilities.AbilityExecution {
AbilityExecution(final Ability ability) {
    this.appliedEffects = new CopyOnWriteArrayList<>();
    this.ability = ability;
    this.executionTicks = Game.time().now();
    this.impactArea = ability.calculateImpactArea();
    this.castLocation = ability.getExecutor().getCenter();
    Game.loop().attach(this);
}@Override
  public void update() {
    // if there a no effects to apply -> unregister this instance and we're done
    if (this.getAbility().getEffects().isEmpty()
        || this.getAbility().getEffects().size() == this.getAppliedEffects().size()) {
      Game.loop().detach(this);
      return;
    }

    // handle all effects from the ability that were not applied yet
    for (final Effect effect : this.getAbility().getEffects()) {
      // if the ability was not executed yet or the delay of the effect is not
      // yet reached
      if (this.getAppliedEffects().contains(effect)
          || Game.time().since(this.getExecutionTicks()) < effect.getDelay()) {
        continue;
      }

      effect.apply(this.getExecutionImpactArea());
      this.getAppliedEffects().add(effect);
    }
}
}
```
```java
class de.gurkenlabs.litiengine.GameWindow$3 {
@Override
          public void windowGainedFocus(WindowEvent e) {
            Game.loop().setTickRate(Game.config().client().getMaxFps());
}@Override
          public void windowLostFocus(WindowEvent e) {
            if (Game.config().graphics().reduceFramesWhenNotFocused()) {
              Game.loop().setTickRate(NONE_FOCUS_MAX_FPS);
            }
}
}
```
```java
class de.gurkenlabs.litiengine.environment.EntitySpawner {
protected void spawnNewEntities() {
    if (this.getSpawnMode() != SpawnMode.CUSTOMSPAWNPOINTS && this.getSpawnPoints().isEmpty()) {
      return;
    }

    switch (this.getSpawnMode()) {
      case ALLSPAWNPOINTS:
        for (int i = 0; i < this.getSpawnPoints().size(); i++) {
          final int index = i;
          Game.loop()
              .perform(
                  this.getSpawnDelay() + this.getSpawnDelay() * i,
                  () -> this.spawn(this.getSpawnPoints().get(index), this.getSpawnAmount()));
        }
        break;
      case ONERANDOMSPAWNPOINT:
        this.spawn(Game.random().choose(this.getSpawnPoints()), this.getSpawnAmount());
        break;
      case RANDOMSPAWNPOINTS:
        for (int i = 0; i < this.getSpawnAmount(); i++) {
          Game.loop()
              .perform(
                  this.getSpawnDelay() + this.getSpawnDelay() * i,
                  () -> this.spawn(Game.random().choose(this.getSpawnPoints()), 1));
        }
        break;
      case CUSTOMSPAWNPOINTS:
        List<Spawnpoint> spawnPoints =
            this.customSpawnpoints != null
                ? this.customSpawnpoints.apply(this)
                : this.getCustomSpawnpoints();

        int index = 0;
        for (Spawnpoint spawn : spawnPoints) {
          Game.loop()
              .perform(
                  this.getSpawnDelay() + this.getSpawnDelay() * index, () -> this.spawn(spawn, 1));
          index++;
        }
        break;
      default:
        break;
    }
}
}
```
```java
class de.gurkenlabs.litiengine.tweening.TweenEngine {
@Override
  public void start() {
    Game.loop().attach(this);
}@Override
  public void terminate() {
    Game.loop().detach(this);
}
}
```
```java
class de.gurkenlabs.litiengine.gui.SpeechBubble {
public void hide() {
    Game.world().environment().removeRenderable(this);
    Game.loop().detach(this);
    if (activeSpeechBubbles.get(this.getEntity()) != null
        && activeSpeechBubbles.remove(this.getEntity()).equals(this)) {
      activeSpeechBubbles.remove(this.getEntity());
    }

    for (SpeechBubbleListener listener : this.listeners) {
      listener.hidden();
    }
}private SpeechBubble(
      final IEntity entity,
      final String text,
      @Nullable SpeechBubbleAppearance appearance,
      @Nullable Font font) {
    if (appearance == null) {
      this.appearance = DEFAULT_APPEARANCE;
    } else {
      this.appearance = appearance;
    }

    final SpeechBubble active = activeSpeechBubbles.get(entity);
    if (active != null) {
      active.hide();
    }
    this.setFont(font);

    this.textBoxWidth = (float) (entity.getWidth() * 4);
    this.entity = entity;

    this.currentText = text;
    this.currentTextDisplayTime = DISPLAYTIME_MIN + text.length() * DISPLAYTIME_PER_LETTER;

    this.lastTextDisplay = Game.time().now();
    this.createBubbleImage();
    entity.getEnvironment().add(this, RenderType.UI);
    Game.loop().attach(this);
    activeSpeechBubbles.put(entity, this);
}
}
```
```java
class de.gurkenlabs.litiengine.entities.Prop {
private void updateAnimationController() {
    IEntityAnimationController<?> controller = this.createAnimationController();
    this.getControllers().addController(controller);
    if (Game.world().environment() != null && Game.world().environment().isLoaded()) {
      Game.loop().attach(controller);
    }
}
}
```
```java
class de.gurkenlabs.litiengine.graphics.FreeFlightCamera {
public FreeFlightCamera(final Point2D focus) {
    this.setFocus(focus);
    this.velocity = DEFAULT_SCROLL_PIXELS_PER_SECOND;
    this.scrollPadding = DEFAULT_SCROLL_PADDING;
    this.setClampToMap(true);

    Game.loop().attach(this);
}private void handleFreeFlightCamera() {
    if (Game.world().environment() == null || Game.world().environment().getMap() == null) {
      return;
    }

    final Point2D mouseLocation = Input.mouse().getLocation();

    final double scrollSpeed =
        this.getVelocity()
            / (double) Game.loop().getTickRate()
            * Game.config().input().getMouseSensitivity();

    double x = this.getFocus().getX();
    double y = this.getFocus().getY();

    double deltaX = 0;
    if (mouseLocation.getX() < this.getScrollPadding()) {
      deltaX -= scrollSpeed;
    } else if (Game.window().getResolution().getWidth() - mouseLocation.getX()
        < this.getScrollPadding()) {
      deltaX += scrollSpeed;
    }

    double deltaY = 0;
    if (mouseLocation.getY() < this.getScrollPadding()) {
      deltaY -= scrollSpeed;
    } else if (Game.window().getResolution().getHeight() - mouseLocation.getY()
        < this.getScrollPadding()) {
      deltaY += scrollSpeed;
    }

    x += deltaX;
    y += deltaY;

    this.setFocus(new Point2D.Double(x, y));
}
}
```
```java
class de.gurkenlabs.litiengine.environment.Environment {
private static void dispose(final Collection<? extends IEntity> entities) {
    for (final IEntity entity : entities) {
      if (entity instanceof IUpdateable) {
        Game.loop().detach((IUpdateable) entity);
      }

      entity.detachControllers();
    }
}private static void loadUpdatableOrEmitterEntity(IEntity entity) {
    if (entity instanceof Emitter) {
      final Emitter emitter = (Emitter) entity;
      if (emitter.isActivateOnInit()) {
        emitter.activate();
      }
    } else if (entity instanceof IUpdateable) {
      Game.loop().attach((IUpdateable) entity);
    }
}private void unload(final IEntity entity) {
    // 1. remove from physics engine
    if (entity instanceof ICollisionEntity) {
      Game.physics().remove((ICollisionEntity) entity);
    }

    // 2. unregister from update
    if (entity instanceof IUpdateable) {
      Game.loop().detach((IUpdateable) entity);
    }

    if (entity instanceof IMobileEntity) {
      this.removeGravity((IMobileEntity) entity);
    }

    // 3. detach all controllers
    entity.detachControllers();

    if (entity instanceof Emitter) {
      Emitter em = (Emitter) entity;
      em.deactivate();
    }

    if (this.loaded && (entity instanceof LightSource || entity instanceof StaticShadow)) {
      this.updateLighting(entity);
    }

    entity.removed(this);
}
}
```
```java
class de.gurkenlabs.litiengine.graphics.animation.Animation {
@Override
  public void update() {
    // do nothing if the animation is not playing or the current keyframe is not finished
    if (!this.isPlaying()
        || Game.time().since(this.lastFrameUpdate) < this.getCurrentKeyFrame().getDuration()) {
      return;
    }

    // if we are not looping and the last keyframe is finished, we terminate the animation
    if (!this.isLooping() && this.isLastKeyFrame()) {
      this.terminate();
      return;
    }

    // make sure, we stay inside the keyframe list
    final int newFrameIndex =
        (this.getKeyframes().indexOf(this.currentFrame) + 1) % this.getKeyframes().size();
    final KeyFrame previousFrame = this.currentFrame;
    this.currentFrame = this.getKeyframes().get(newFrameIndex);

    for (KeyFrameListener listener : this.listeners) {
      listener.currentFrameChanged(previousFrame, this.currentFrame);
    }

    this.lastFrameUpdate = Game.loop().getTicks();
}public void restart() {
    this.currentFrame = this.firstFrame;
    this.lastFrameUpdate = Game.loop().getTicks();
}
}
```
```java
class de.gurkenlabs.litiengine.physics.MovementController {
@Override
  public void attach() {
    Game.loop().attach(this);
}private void handleForces() {
    // clean up forces
    this.activeForces.forEach(
        x -> {
          if (x.hasEnded()) {
            this.activeForces.remove(x);
          }
        });

    if (this.activeForces.isEmpty()) {
      return;
    }

    // disable turn-on-move for force handling
    boolean turn = this.getEntity().turnOnMove();
    this.getEntity().setTurnOnMove(false);
    try {
      double deltaX = 0;
      double deltaY = 0;
      for (final Force force : this.activeForces) {
        if (force.cancelOnReached() && force.hasReached(this.getEntity())) {
          force.end();
          continue;
        }

        final Point2D collisionBoxCenter = this.getEntity().getCollisionBoxCenter();
        final double angle =
            GeometricUtilities.calcRotationAngleInDegrees(collisionBoxCenter, force.getLocation());
        final double strength =
            Game.loop().getDeltaTime() * 0.001f * force.getStrength() * Game.loop().getTimeScale();
        deltaX += GeometricUtilities.getDeltaX(angle, strength);
        deltaY += GeometricUtilities.getDeltaY(angle, strength);
      }

      final Point2D target =
          new Point2D.Double(this.getEntity().getX() + deltaX, this.getEntity().getY() + deltaY);
      final boolean success = Game.physics().move(this.getEntity(), target);
      if (!success) {
        for (final Force force : this.activeForces) {
          if (force.cancelOnCollision()) {
            force.end();
          }
        }
      }
    } finally {
      this.getEntity().setTurnOnMove(turn);
    }
}@Override
  public void detach() {
    Game.loop().detach(this);
}public void handleMovement() {
    if (!this.isMovementAllowed()) {
      this.velocity = 0;
      return;
    }

    // max distance an entity can travel within one tick
    final double maxPixelsPerTick = this.getEntity().getTickVelocity();
    final double deltaTime = Game.loop().getDeltaTime() * Game.loop().getTimeScale();

    final double acceleration =
        this.getEntity().getAcceleration() == 0
            ? maxPixelsPerTick
            : deltaTime / this.getEntity().getAcceleration() * maxPixelsPerTick;
    final double deceleration =
        this.getEntity().getDeceleration() == 0
            ? this.getVelocity()
            : deltaTime / this.getEntity().getDeceleration() * maxPixelsPerTick;

    double dx = this.getDx();
    double dy = this.getDy();
    this.setDx(0);
    this.setDy(0);

    final double deltaVelocity =
        Math.min(Math.sqrt(Math.pow(dx, 2) + Math.pow(dy, 2)), acceleration);
    if (deltaVelocity != 0) {
      double newVelocity = this.getVelocity() + deltaVelocity;
      this.setVelocity(newVelocity);
    } else {
      final double newVelocity = Math.max(0, this.getVelocity() - deceleration);
      this.setVelocity(newVelocity);
      dx = GeometricUtilities.getDeltaX(this.moveAngle);
      dy = GeometricUtilities.getDeltaY(this.moveAngle);
    }

    if (this.getVelocity() == 0) {
      this.moveAngle = 0;
      return;
    }

    // actually move entity
    this.moveEntity(dx, dy);
}
}
```
```java
class de.gurkenlabs.litiengine.graphics.animation.AnimationController {
public void detach() {
    Game.loop().detach(this);
}public void attach() {
    Game.loop().attach(this);
}
}
```
```java
class de.gurkenlabs.litiengine.graphics.Camera {
@Override
  public void setZoom(final float targetZoom, final int delay) {
    if (delay == 0) {

      this.zoom = targetZoom;
      this.targetZoom = 0;
      this.zoomDelay = 0;
      this.zoomTick = 0;
      this.zoomStep = 0;

      final ZoomChangedEvent event = new ZoomChangedEvent(this, targetZoom);
      for (final ZoomChangedListener listener : this.zoomListeners) {
        listener.zoomChanged(event);
      }
    } else {
      this.zoomTick = Game.time().now();
      this.targetZoom = targetZoom;
      this.zoomDelay = delay;

      final double tickduration = 1000 / (double) Game.loop().getTickRate();
      final double tickAmount = delay / tickduration;
      final float totalDelta = this.targetZoom - this.zoom;
      this.zoomStep = tickAmount > 0 ? (float) (totalDelta / tickAmount) : totalDelta;
    }
}
}
```
```java
class de.gurkenlabs.litiengine.Game {
public static synchronized void init(String... args) {
    if (initialized) {
      log().log(Level.INFO, "The game has already been initialized.");
      return;
    }

    log.init();
    handleCommandLineArguments(args);

    config().load();
    Locale.setDefault(new Locale(config().client().getCountry(), config().client().getLanguage()));

    gameLoop = new GameLoop("Main Update Loop", config().client().getMaxFps());
    loop().attach(physics());
    loop().attach(world());

    // setup default exception handling for render and update loop
    setUncaughtExceptionHandler(
        new DefaultUncaughtExceptionHandler(config().client().exitOnError()));

    screenManager = new ScreenManager();
    gameWindow = new GameWindow();

    // initialize  the game window
    window().init();
    world.setCamera(new Camera());

    for (GameListener listener : gameListeners) {
      listener.initialized(args);
    }

    if (!isInNoGUIMode()) {
      window().getRenderComponent().onRendered(g -> metrics().render(g));

      graphics()
          .addEntityRenderedListener(
              e -> DebugRenderer.renderEntityDebugInfo(e.getGraphics(), e.getEntity()));

      window().getRenderComponent().onFpsChanged(fps -> metrics().setFramesPerSecond(fps));
      window()
          .setIcons(
              Arrays.asList(
                  Resources.images().get("liti-logo-x16.png"),
                  Resources.images().get("liti-logo-x20.png"),
                  Resources.images().get("liti-logo-x32.png"),
                  Resources.images().get("liti-logo-x48.png")));

      Input.keyboard()
          .onKeyTyped(
              KeyEvent.VK_PRINTSCREEN,
              key -> {
                // don't take a screenshot if a modifier is active
                if (key.getModifiers() != 0) {
                  return;
                }

                window().getRenderComponent().takeScreenshot();
              });
    }

    Runtime.getRuntime().addShutdownHook(new Thread(Game::terminate, "Shutdown"));

    initialized = true;
}
}
```
```java
class de.gurkenlabs.litiengine.entities.Creature {
protected void updateAnimationController() {
    IEntityAnimationController<?> controller = this.createAnimationController();
    this.getControllers().addController(controller);
    if (Game.world().environment() != null && Game.world().environment().isLoaded()) {
      Game.loop().attach(controller);
    }
}@Override
  public float getTickVelocity() {
    // pixels per ms multiplied by the passed ms
    // ensure that entities don't travel too far in case of lag
    return Math.min(Game.loop().getDeltaTime(), GameLoop.TICK_DELTATIME_LAG)
        * 0.001F
        * this.getVelocity().get()
        * Game.loop().getTimeScale();
}
}
```
Depth: 2
```java
class de.gurkenlabs.litiengine.environment.GameWorld {
public void clear() {
    this.unloadEnvironment();
    this.environments.clear();
    this.setCamera(null);
    Game.physics().clear();

    this.environmentListeners.clear();
    this.environmentLoadedListeners.clear();
    this.environmentUnloadedListeners.clear();

    this.listeners.clear();
    this.loadedListeners.clear();
    this.unloadedListeners.clear();
}@Nullable
  public Environment loadEnvironment(IMap map) {
    Environment env = this.getEnvironment(map);
    this.loadEnvironment(env);
    return env;
}@Nullable
  public Environment loadEnvironment(String mapName) {
    Environment env = this.getEnvironment(mapName);
    this.loadEnvironment(env);
    return env;
}
}
```
```java
class de.gurkenlabs.litiengine.GameWindow {
GameWindow() {
    this.hostControl = new JFrame();

    this.resolutionChangedListeners = new CopyOnWriteArrayList<>();

    this.renderCanvas = new RenderComponent(Game.config().graphics().getResolution());
    this.cursor = new MouseCursor();
    if (!Game.isInNoGUIMode()) {
      this.hostControl.setBackground(Color.BLACK);
      this.hostControl.add(this.renderCanvas);

      this.initializeEventListeners();

      this.hostControl.setTitle(Game.info().getTitle());
      this.hostControl.setDefaultCloseOperation(WindowConstants.DO_NOTHING_ON_CLOSE);
      initializeWindowEventListeners(this.hostControl);
    }
}
}
```
```java
class de.gurkenlabs.litiengine.GameTime {
public long sinceEnvironmentLoad() {
    return this.since(this.environmentLoaded);
}public long since(final long tick) {
    return toMilliseconds(Game.loop().getTicks() - tick);
}public long sinceGameStart() {
    return this.toMilliseconds(Game.loop().getTicks());
}
}
```
```java
class de.gurkenlabs.litiengine.abilities.effects.Effect {
protected void cease(final EffectApplication appliance) {
    // 1. cease the effect for all affected entities
    for (final ICombatEntity entity : appliance.getAffectedEntities()) {
      this.cease(entity);
    }

    // 2. apply follow up effects
    this.getFollowUpEffects().forEach(followUp -> followUp.apply(appliance.getImpactArea()));
}protected boolean hasEnded(final EffectApplication appliance) {
    final long effectDuration = Game.time().since(appliance.getAppliedTicks());
    return effectDuration > this.getDuration();
}
}
```
```java
class de.gurkenlabs.litiengine.abilities.effects.EffectApplication {
protected EffectApplication(final List<ICombatEntity> affectedEntities, final Shape impactArea) {
    this.applied = Game.time().now();
    this.affectedEntities = affectedEntities;
    this.impactArea = impactArea;
}
}
```
```java
class de.gurkenlabs.litiengine.entities.CombatEntity {
@Override
  public boolean wasHit(int timeSpan) {
    return Game.time().since(this.lastHit) < timeSpan;
}@Override
  public void hit(final int damage, @Nullable final Ability ability) {
    if (this.isDead()) {
      return;
    }

    if (!this.isIndestructible()) {
      this.getHitPoints().modifyBaseValue(new AttributeModifier<>(Modification.SUBTRACT, damage));
    }

    final EntityHitEvent event = new EntityHitEvent(this, ability, damage, this.isDead());

    for (final CombatEntityListener listener : this.listeners) {
      listener.hit(event);
    }

    for (final CombatEntityHitListener listener : this.hitListeners) {
      listener.hit(event);
    }

    if (this.isDead()) {
      this.fireDeathEvent();
      this.setCollision(false);
    }

    this.lastHit = Game.time().now();
}
}
```
```java
class de.gurkenlabs.litiengine.graphics.ImageEffect {
protected ImageEffect(final int ttl, final String name) {
    this.ttl = ttl;
    this.name = name;
    this.aliveTick = Game.time().now();
}@Override
  public long getAliveTime() {
    return Game.time().since(this.aliveTick);
}
}
```
```java
class de.gurkenlabs.litiengine.abilities.AbilityExecution {
AbilityExecution(final Ability ability) {
    this.appliedEffects = new CopyOnWriteArrayList<>();
    this.ability = ability;
    this.executionTicks = Game.time().now();
    this.impactArea = ability.calculateImpactArea();
    this.castLocation = ability.getExecutor().getCenter();
    Game.loop().attach(this);
}@Override
  public void update() {
    // if there a no effects to apply -> unregister this instance and we're done
    if (this.getAbility().getEffects().isEmpty()
        || this.getAbility().getEffects().size() == this.getAppliedEffects().size()) {
      Game.loop().detach(this);
      return;
    }

    // handle all effects from the ability that were not applied yet
    for (final Effect effect : this.getAbility().getEffects()) {
      // if the ability was not executed yet or the delay of the effect is not
      // yet reached
      if (this.getAppliedEffects().contains(effect)
          || Game.time().since(this.getExecutionTicks()) < effect.getDelay()) {
        continue;
      }

      effect.apply(this.getExecutionImpactArea());
      this.getAppliedEffects().add(effect);
    }
}
}
```
```java
class de.gurkenlabs.litiengine.tweening.TweenEngine {
@Override
  public void update() {
    for (final Tweenable target : this.getTweens().keySet()) {
      for (final Tween tween : this.getTweens().get(target).values()) {
        if (tween.hasStopped()) {
          continue;
        }
        final long elapsed = Game.time().since(tween.getStartTime());
        if (elapsed >= tween.getDuration()) {
          tween.stop();
          continue;
        }
        final float[] currentValues = new float[tween.getTargetValues().length];
        for (int i = 0; i < tween.getTargetValues().length; i++) {
          currentValues[i] =
              tween.getStartValues()[i]
                  + tween.getEquation().compute(elapsed / (float) tween.getDuration())
                      * (tween.getTargetValues()[i] - tween.getStartValues()[i]);
        }
        tween.getTarget().setTweenValues(tween.getType(), currentValues);
      }
    }
}
}
```
```java
class de.gurkenlabs.litiengine.gui.SpeechBubble {
public static SpeechBubble create(
      final IEntity entity, final String text, SpeechBubbleAppearance appearance, Font font) {
    return new SpeechBubble(entity, text, appearance, font);
}public static SpeechBubble create(final IEntity entity, final Font font, final String text) {
    SpeechBubbleAppearance app =
        new SpeechBubbleAppearance(
            DEFAULT_APPEARANCE.getForeColor(),
            DEFAULT_APPEARANCE.getBackgroundColor1(),
            DEFAULT_APPEARANCE.getBorderColor(),
            DEFAULT_APPEARANCE.getPadding());
    return new SpeechBubble(entity, text, app, font);
}public static SpeechBubble create(final IEntity entity, final String text) {
    return new SpeechBubble(entity, text, null, GuiProperties.getDefaultFont());
}@Override
  public void update() {
    if (this.currentText == null) {
      this.hide();
      return;
    }

    this.entityCenter = Game.world().camera().getViewportLocation(this.getEntity().getCenter());

    // old text was displayed long enough
    if (this.lastTextDisplay != 0
        && Game.time().since(this.lastTextDisplay) > this.currentTextDisplayTime) {
      this.currentText = null;
      this.lastTextDisplay = 0;
      return;
    }

    // display new text
    if (this.textIndex < this.currentText.length()
        && Game.time().since(this.lastCharPoll) > LETTER_WRITE_DELAY) {
      this.textIndex++;
      this.lastCharPoll = Game.time().now();
      if (this.typeSound != null) {
        Game.audio().playSound(this.typeSound, this.getEntity());
      }
    }

    // continue displaying currently displayed text
}private SpeechBubble(
      final IEntity entity,
      final String text,
      final Sound typeSound,
      SpeechBubbleAppearance appearance,
      Font font) {
    this(entity, text, appearance, font);
    this.typeSound = typeSound;
}private SpeechBubble(
      final IEntity entity,
      final String text,
      @Nullable SpeechBubbleAppearance appearance,
      @Nullable Font font) {
    if (appearance == null) {
      this.appearance = DEFAULT_APPEARANCE;
    } else {
      this.appearance = appearance;
    }

    final SpeechBubble active = activeSpeechBubbles.get(entity);
    if (active != null) {
      active.hide();
    }
    this.setFont(font);

    this.textBoxWidth = (float) (entity.getWidth() * 4);
    this.entity = entity;

    this.currentText = text;
    this.currentTextDisplayTime = DISPLAYTIME_MIN + text.length() * DISPLAYTIME_PER_LETTER;

    this.lastTextDisplay = Game.time().now();
    this.createBubbleImage();
    entity.getEnvironment().add(this, RenderType.UI);
    Game.loop().attach(this);
    activeSpeechBubbles.put(entity, this);
}
}
```
```java
class de.gurkenlabs.litiengine.gui.TextFieldComponent {
@Override
  public void render(final Graphics2D g) {
    super.render(g);
    g.setFont(this.getFont());
    final FontMetrics fm = g.getFontMetrics();

    if (this.isSelected() && Game.time().since(this.lastToggled) > this.flickerDelay) {
      this.cursorVisible = !this.cursorVisible;
      this.lastToggled = Game.time().now();
    }
    if (this.isSelected() && this.cursorVisible) {
      final Rectangle2D cursor =
          new Rectangle2D.Double(
              this.getX() + this.getTextX() + fm.stringWidth(this.getTextToRender(g)),
              this.getY() + this.getTextY(),
              this.getFont().getSize2D() * 3 / 5,
              this.getFont().getSize2D() * 1 / 5);
      g.setColor(this.getAppearance().getForeColor());
      g.fill(cursor);
    }
}
}
```
```java
class de.gurkenlabs.litiengine.entities.Prop {
public Prop(
      final Point2D location, @Nullable final String spritesheetName, final Material material) {
    super();
    this.rotation = Rotation.NONE;
    this.spritesheetName = spritesheetName;
    this.material = material;
    this.setLocation(location);
    this.updateAnimationController();
}public void setSpritesheetName(@Nullable final String spriteName) {
    this.spritesheetName = spriteName;
    this.updateAnimationController();
}
}
```
```java
class de.gurkenlabs.litiengine.tweening.Tween {
public Tween begin() {
    this.started = Game.time().now();
    this.stopped = false;
    return this;
}
}
```
```java
class de.gurkenlabs.litiengine.graphics.emitters.particles.Particle {
public void update(final Point2D emitterOrigin, final float updateRatio) {
    if (this.aliveTick == 0) {
      this.aliveTick = Game.time().now();
    }

    this.aliveTime = Game.time().since(this.aliveTick);
    if (this.timeToLiveReached()) {
      return;
    }

    if (this.colliding) {
      return;
    }

    if (this.getDeltaWidth() != 0) {
      this.width += this.getDeltaWidth() * updateRatio;
    }

    if (this.getDeltaHeight() != 0) {
      this.height += this.getDeltaHeight() * updateRatio;
    }

    if (this.getDeltaAngle() != 0) {
      this.angle += this.getDeltaAngle() * updateRatio;
    }

    // test for ray cast collision
    final float targetX = this.x + this.getVelocityX() * updateRatio;
    final float targetY = this.y + this.getVelocityY() * updateRatio;

    if (targetX == this.x && targetY == this.y) {
      return;
    }

    if (this.checkForCollision(emitterOrigin, targetX, targetY)) {
      return;
    }

    if (this.getVelocityX() != 0) {
      this.x = targetX;
    }

    if (this.getVelocityY() != 0) {
      this.y = targetY;
    }

    if (this.getAccelerationX() != 0) {
      this.velocityX += this.getAccelerationX() * updateRatio;
    }

    if (this.getAccelerationY() != 0) {
      this.velocityY += this.getAccelerationY() * updateRatio;
    }
}
}
```
```java
class de.gurkenlabs.litiengine.graphics.animation.Animation {
@Override
  public void start() {
    this.playing = true;
    if (this.getKeyframes().isEmpty()) {
      return;
    }

    this.restart();
}@Override
  public void update() {
    // do nothing if the animation is not playing or the current keyframe is not finished
    if (!this.isPlaying()
        || Game.time().since(this.lastFrameUpdate) < this.getCurrentKeyFrame().getDuration()) {
      return;
    }

    // if we are not looping and the last keyframe is finished, we terminate the animation
    if (!this.isLooping() && this.isLastKeyFrame()) {
      this.terminate();
      return;
    }

    // make sure, we stay inside the keyframe list
    final int newFrameIndex =
        (this.getKeyframes().indexOf(this.currentFrame) + 1) % this.getKeyframes().size();
    final KeyFrame previousFrame = this.currentFrame;
    this.currentFrame = this.getKeyframes().get(newFrameIndex);

    for (KeyFrameListener listener : this.listeners) {
      listener.currentFrameChanged(previousFrame, this.currentFrame);
    }

    this.lastFrameUpdate = Game.loop().getTicks();
}
}
```
```java
class de.gurkenlabs.litiengine.graphics.animation.AnimationController {
@Override
  public void update() {
    for (final Animation animation : this.getAll()) {
      animation.update();
    }

    if (this.getCurrent() != null && this.getCurrent().isPaused()) {
      return;
    }

    final boolean playbackFinished = this.getCurrent() != null && !this.getCurrent().isPlaying();
    if (playbackFinished) {
      for (final AnimationListener listener : this.listeners) {
        listener.finished(this.getCurrent());
      }
    }

    if (this.getCurrent() == null || playbackFinished) {
      if (this.getDefault() != null) {
        this.play(this.getDefault().getName());
      } else {
        this.currentAnimation = null;
      }
    }
}
}
```
```java
class de.gurkenlabs.litiengine.graphics.RenderComponent {
private void handleFade() {
    if (this.fadeOutStart != -1) {
      final long timePassed = Game.time().since(this.fadeOutStart);
      this.currentAlpha = MathUtilities.clamp(1 - timePassed / (float) this.fadeOutTime, 0, 1);
      if (this.currentAlpha == 0f) {
        this.fadeOutStart = -1;
        this.fadeOutTime = -1;
      }

      return;
    }

    if (this.fadeInStart != -1) {
      final long timePassed = Game.time().since(this.fadeInStart);
      this.currentAlpha = MathUtilities.clamp(timePassed / (float) this.fadeInTime, 0, 1);
      if (this.currentAlpha == 1f) {
        this.fadeInStart = -1;
        this.fadeInTime = -1;
        this.currentAlpha = Float.NaN;
      }
    }
}public void fadeOut(final int ms) {
    this.fadeInStart = -1;
    this.fadeInTime = -1;
    this.fadeOutStart = Game.time().now();
    this.fadeOutTime = ms;
}public void fadeIn(final int ms) {
    this.fadeOutStart = -1;
    this.fadeOutTime = -1;
    this.fadeInStart = Game.time().now();
    this.fadeInTime = ms;
}
}
```
```java
class de.gurkenlabs.litiengine.entities.Trigger {
private boolean activate(final IEntity activator, final int tar) {
    if (!this.isLoaded()
        || this.isOneTimeTrigger && this.isActivated
        || this.getActivationType() == TriggerActivation.COLLISION
            && activator != null
            && this.collisionActivated.contains(activator)) {
      return false;
    }

    if (this.getCooldown() > 0 && Game.time().since(this.lastActivation) < this.getCooldown()) {
      return false;
    }

    List<Integer> triggerTargets = this.getTargets(tar);

    final TriggerEvent te = new TriggerEvent(this, activator, triggerTargets);

    if (!this.checkActivationPredicates(te)) {
      return false;
    }

    this.isActivated = true;
    if (activator != null) {
      this.collisionActivated.add(activator);
    }

    // if we actually have a trigger target, we send the message to the target
    for (final int target : triggerTargets) {
      final IEntity entity = this.getEnvironment().get(target);
      if (entity == null) {
        log.log(
            Level.WARNING,
            "trigger [{0}] was activated, but the trigger target [{1}] could not be found on the environment",
            new Object[] {this, target});
        continue;
      }

      entity.sendMessage(this, this.message);
    }

    // also send the trigger event to all registered consumers
    for (final TriggerActivatedListener listener : this.activatedListeners) {
      listener.activated(te);
    }

    if (this.isOneTimeTrigger) {
      this.getEnvironment().remove(this);
    }

    this.lastActivation = Game.time().now();
    return true;
}
}
```
```java
class de.gurkenlabs.litiengine.graphics.Camera {
private boolean isShakeEffectActive() {
    return this.getShakeTick() != 0
        && Game.time().since(this.getShakeTick()) < this.getShakeDuration();
}@Override
  public void update() {
    if (Game.world().camera() != null && !Game.world().camera().equals(this)) {
      return;
    }

    if (this.targetZoom > 0) {
      if (Game.time().since(this.zoomTick) >= this.zoomDelay) {
        this.zoom = this.targetZoom;
        this.targetZoom = 0;
        this.zoomDelay = 0;
        this.zoomTick = 0;
        this.zoomStep = 0;
      } else {
        this.zoom += this.zoomStep;
      }

      final ZoomChangedEvent event = new ZoomChangedEvent(this, this.getZoom());
      for (final ZoomChangedListener listener : this.zoomListeners) {
        listener.zoomChanged(event);
      }
    }

    if (this.panTime > 0) {
      if (--this.panTime <= 0) {
        this.setFocus(this.targetFocus);
        this.targetFocus = null;
      } else {
        double diff = this.panTime / (this.panTime + 1.0);
        this.focus =
            new Point2D.Double(
                this.focus.getX() * diff + this.targetFocus.getX() * (1.0 - diff),
                this.focus.getY() * diff + this.targetFocus.getY() * (1.0 - diff));
      }
    }

    if (!this.isShakeEffectActive()) {
      this.shakeOffsetX = 0;
      this.shakeOffsetY = 0;
      return;
    }

    if (Game.time().since(this.lastShake) > this.shakeDelay) {
      this.shakeOffsetX = this.getShakeIntensity() * ThreadLocalRandom.current().nextGaussian();
      this.shakeOffsetY = this.getShakeIntensity() * ThreadLocalRandom.current().nextGaussian();
      this.lastShake = Game.time().now();
    }
}@Override
  public void setZoom(final float targetZoom, final int delay) {
    if (delay == 0) {

      this.zoom = targetZoom;
      this.targetZoom = 0;
      this.zoomDelay = 0;
      this.zoomTick = 0;
      this.zoomStep = 0;

      final ZoomChangedEvent event = new ZoomChangedEvent(this, targetZoom);
      for (final ZoomChangedListener listener : this.zoomListeners) {
        listener.zoomChanged(event);
      }
    } else {
      this.zoomTick = Game.time().now();
      this.targetZoom = targetZoom;
      this.zoomDelay = delay;

      final double tickduration = 1000 / (double) Game.loop().getTickRate();
      final double tickAmount = delay / tickduration;
      final float totalDelta = this.targetZoom - this.zoom;
      this.zoomStep = tickAmount > 0 ? (float) (totalDelta / tickAmount) : totalDelta;
    }
}@Override
  public void shake(final double intensity, final int delay, final int shakeDuration) {
    this.shakeTick = Game.time().now();
    this.shakeDelay = delay;
    this.shakeIntensity = intensity;
    this.shakeDuration = shakeDuration;
}
}
```
```java
class de.gurkenlabs.litiengine.entities.Creature {
public void setSpritesheetName(String spritesheetName) {
    if (this.spritesheetName != null && this.spritesheetName.equals(spritesheetName)) {
      return;
    }

    this.spritesheetName = spritesheetName;
    this.updateAnimationController();
}public boolean isIdle() {
    return Game.time().since(this.lastMoved) > IDLE_DELAY;
}@Override
  public void setLocation(final Point2D position) {
    if (this.isDead() || position == null) {
      return;
    }

    final Point2D oldLocation = this.getLocation();
    super.setLocation(position);

    if (Game.hasStarted() && this.isLoaded()) {
      this.lastMoved = Game.time().now();
      this.fireMovedEvent(
          new EntityMovedEvent(
              this, this.getX() - oldLocation.getX(), this.getY() - oldLocation.getY()));
    }
}
}
```
```java
class de.gurkenlabs.litiengine.gui.screens.ScreenManager {
public void display(final String screenName) {
    if (this.current() != null && this.current().getName().equalsIgnoreCase(screenName)) {
      log.log(
          Level.INFO,
          "Skipping displaying of screen {0} because it is already the current screen.",
          screenName);
      return;
    }

    if (this.screens.stream()
        .noneMatch(element -> element.getName().equalsIgnoreCase(screenName))) {
      log.log(
          Level.WARNING,
          "Could not display the screen {0} because there is no screen with the specified name.",
          screenName);
      return;
    }

    Screen screen = this.get(screenName);
    if (screen == null) {
      return;
    }

    this.display(screen);
}public void add(final Screen screen) {
    screen.setWidth(Game.window().getWidth());
    screen.setHeight(Game.window().getHeight());
    this.screens.add(screen);

    if (this.current() == null) {
      this.display(screen);
    }
}public void remove(Screen screen) {
    this.screens.remove(screen);
    if (this.current() == screen) {
      if (!this.screens.isEmpty()) {
        this.display(this.screens.get(0));
      } else {
        this.display((Screen) null);
      }
    }
}public void display(@Nullable final Screen screen) {
    if (Game.hasStarted() && Game.time().since(this.lastScreenChange) < this.getChangeCooldown()) {
      log.log(
          Level.INFO,
          "Skipping displaying of screen {0} because screen changing is currently on cooldown.",
          screen != null ? screen.getName() : "");
      return;
    }

    final Screen previous = this.current();
    if (previous != null) {
      previous.suspend();
    }

    if (screen != null && !this.screens.contains(screen)) {
      this.screens.add(screen);
    }

    this.currentScreen = screen;
    if (!Game.isInNoGUIMode() && this.current() != null) {
      this.current().prepare();
    }

    this.lastScreenChange = Game.loop().getTicks();

    final ScreenChangedEvent event = new ScreenChangedEvent(this.current(), previous);
    for (final ScreenChangedListener listener : this.screenChangedListeners) {
      listener.changed(event);
    }
}
}
```
```java
class de.gurkenlabs.litiengine.abilities.Ability {
public boolean isOnCooldown() {
    return (this.getCurrentExecution() != null
        && this.getCurrentExecution().getExecutionTicks() > 0
        && Game.time().since(this.getCurrentExecution().getExecutionTicks())
            < this.getAttributes().cooldown().get());
}public boolean isActive() {
    return this.getCurrentExecution() != null
        && Game.time().since(this.getCurrentExecution().getExecutionTicks())
            < this.getAttributes().duration().get();
}@Nullable
  public AbilityExecution cast() {
    if (!this.canCast()) {
      return null;
    }
    this.currentExecution = new AbilityExecution(this);

    for (final AbilityCastListener listener : this.abilityCastListeners) {
      listener.abilityCast(this.currentExecution);
    }

    return this.getCurrentExecution();
}public float getRemainingCooldownInSeconds() {
    if (this.getCurrentExecution() == null
        || this.getExecutor() == null
        || this.getExecutor().isDead()) {
      return 0;
    }

    // calculate cooldown in seconds
    return (float)
        (!this.canCast()
            ? (this.getAttributes().cooldown().get()
                    - Game.time().since(this.getCurrentExecution().getExecutionTicks()))
                * 0.001
            : 0);
}
}
```
```java
class de.gurkenlabs.litiengine.entities.EntityHitEvent {
EntityHitEvent(
      final ICombatEntity hitEntity,
      @Nullable final Ability ability,
      final int damage,
      final boolean kill) {
    super(hitEntity);
    this.executor = ability != null ? ability.getExecutor() : null;
    this.hitEntity = hitEntity;
    this.ability = ability;
    this.damage = damage;
    this.kill = kill;
    this.time = Game.time().now();
}
}
```
```java
class de.gurkenlabs.litiengine.graphics.emitters.Emitter {
public void delete() {
    this.deactivate();
    if (Game.world().environment() != null) {
      Game.world().environment().remove(this);
    }
}public void activate() {
    if (this.activated) {
      return;
    }

    this.activated = true;
    this.activationTick = Game.time().now();
    Game.loop().attach(this);
}@Override
  public void update() {
    if (this.isPaused()) {
      return;
    }

    // clear particles if the effect time to life is reached
    if (this.isFinished()) {
      for (EmitterFinishedListener listener : this.finishedListeners) {
        listener.finished(this);
      }

      this.delete();
      return;
    }

    final float updateRatio = (float) this.data().getUpdateRate() / Game.loop().getTickRate();
    for (final Particle p : this.getParticles().stream().collect(Collectors.toList())) {
      if (this.particleCanBeRemoved(p)) {
        // remove dead particles
        this.particles.remove(p);
        continue;
      }

      p.update(this.getOrigin(), updateRatio);
    }

    this.aliveTime = Game.time().since(this.activationTick);
    if ((this.data().getSpawnRate() == 0
        || Game.time().since(this.lastSpawn) >= this.data().getSpawnRate())) {
      this.lastSpawn = Game.time().now();
      this.spawnParticle();
    }
}
}
```
```java
class de.gurkenlabs.litiengine.GameLoop {
@Override
  public int perform(int delay, Runnable action) {
    final long d = Game.time().toTicks(delay);

    TimedAction a = new TimedAction(this.getTicks() + d, action);
    this.actions.add(a);

    return a.getId();
}
}
```
```java
class de.gurkenlabs.litiengine.environment.EntitySpawner {
protected boolean shouldSpawn() {
    return this.lastSpawnWave == 0
        || Game.time().since(this.lastSpawnWave) >= this.getSpawnInterval();
}@Override
  public void update() {
    if (!this.shouldSpawn()) {
      return;
    }

    this.spawnNewEntities();
    this.lastSpawnWave = Game.time().now();
}
}
```
```java
class de.gurkenlabs.litiengine.graphics.FreeFlightCamera {
@Override
  public void update() {
    this.handleFreeFlightCamera();
}public FreeFlightCamera(double x, double y) {
    this(new Point2D.Double(x, y));
}
}
```
```java
class de.gurkenlabs.litiengine.environment.Environment {
public void unload() {
    if (!this.loaded) {
      return;
    }

    // unregister all updatable entities from the current environment
    for (final IEntity entity : this.allEntities.values()) {
      this.unload(entity);
    }

    this.loaded = false;
    this.fireEvent(l -> l.unloaded(this));
}private static void loadUpdatableOrEmitterEntity(IEntity entity) {
    if (entity instanceof Emitter) {
      final Emitter emitter = (Emitter) entity;
      if (emitter.isActivateOnInit()) {
        emitter.activate();
      }
    } else if (entity instanceof IUpdateable) {
      Game.loop().attach((IUpdateable) entity);
    }
}public void clear() {
    Game.physics().clear();

    this.combatEntities.clear();
    this.mobileEntities.clear();
    this.gravityForces.clear();
    this.layerEntities.clear();
    this.entitiesByTag.clear();
    this.allEntities.clear();

    for (RenderType renderType : RenderType.values()) {
      this.miscEntities.get(renderType).clear();
      this.renderListeners.get(renderType).clear();
      this.renderables.get(renderType).clear();
    }

    dispose(this.allEntities.values());
    dispose(this.triggers);
    this.emitters.clear();
    this.colliders.clear();
    this.props.clear();
    this.creatures.clear();
    this.staticShadows.clear();
    this.combatEntities.clear();
    this.mobileEntities.clear();
    this.lightSources.clear();
    this.spawnPoints.clear();
    this.soundSources.clear();
    this.mapAreas.clear();
    this.triggers.clear();

    this.ambientLight = null;
    this.staticShadowLayer = null;

    for (Map<Integer, IEntity> type : this.miscEntities.values()) {
      type.clear();
    }

    this.initialized = false;

    this.fireEvent(l -> l.cleared(this));
}private void load(final IEntity entity) {
    // an entity can only exist on one environment at a time, so remove it from the current one
    if (entity.getEnvironment() != null) {
      entity.getEnvironment().remove(entity);
    }

    // 1. add to physics engine
    loadPhysicsEntity(entity);

    // 2. register for update or activate
    loadUpdatableOrEmitterEntity(entity);

    // 3. if a gravity is defined, add a gravity force to the entity
    if (entity instanceof IMobileEntity && this.getGravity() != 0) {
      this.addGravityForce((IMobileEntity) entity);
    }

    // 4. attach all controllers
    entity.attachControllers();

    if (this.loaded && (entity instanceof LightSource || entity instanceof StaticShadow)) {
      this.updateLighting(entity);
    }

    entity.loaded(this);
}private void unload(final IEntity entity) {
    // 1. remove from physics engine
    if (entity instanceof ICollisionEntity) {
      Game.physics().remove((ICollisionEntity) entity);
    }

    // 2. unregister from update
    if (entity instanceof IUpdateable) {
      Game.loop().detach((IUpdateable) entity);
    }

    if (entity instanceof IMobileEntity) {
      this.removeGravity((IMobileEntity) entity);
    }

    // 3. detach all controllers
    entity.detachControllers();

    if (entity instanceof Emitter) {
      Emitter em = (Emitter) entity;
      em.deactivate();
    }

    if (this.loaded && (entity instanceof LightSource || entity instanceof StaticShadow)) {
      this.updateLighting(entity);
    }

    entity.removed(this);
}public void remove(final IEntity entity) {
    if (entity == null) {
      return;
    }

    this.allEntities.remove(entity.getMapId());
    Iterator<List<IEntity>> iter = this.layerEntities.values().iterator();
    while (iter.hasNext()) {
      List<IEntity> layer = iter.next();
      if (layer.remove(entity) && layer.isEmpty()) {
        iter.remove();
      }
    }
    if (this.miscEntities.get(entity.getRenderType()) != null) {
      this.miscEntities.get(entity.getRenderType()).values().remove(entity);
    }

    for (String tag : entity.getTags()) {
      if (this.getEntitiesByTag().containsKey(tag)) {
        this.getEntitiesByTag().get(tag).remove(entity);

        if (this.getEntitiesByTag().get(tag).isEmpty()) {
          this.getEntitiesByTag().remove(tag);
        }
      }
    }

    if (entity instanceof Emitter) {
      Emitter emitter = (Emitter) entity;
      this.removeEmitter(emitter);
    }

    if (entity instanceof MapArea) {
      this.mapAreas.remove(entity);
    }

    if (entity instanceof Prop) {
      this.props.remove(entity);
    }

    if (entity instanceof Creature) {
      this.creatures.remove(entity);
    }

    if (entity instanceof CollisionBox) {
      this.colliders.remove(entity);
      this.staticShadows.removeIf(x -> x.getOrigin() != null && x.getOrigin().equals(entity));
    }

    if (entity instanceof LightSource) {
      this.lightSources.remove(entity);
      this.updateLighting(entity);
    }

    if (entity instanceof Trigger) {
      this.triggers.remove(entity);
    }

    if (entity instanceof Spawnpoint) {
      this.spawnPoints.remove(entity);
    }
    if (entity instanceof SoundSource) {
      this.soundSources.remove(entity);
    }

    if (entity instanceof StaticShadow) {
      this.staticShadows.remove(entity);
      this.updateLighting(entity);
    }

    if (entity instanceof IMobileEntity) {
      this.mobileEntities.values().remove(entity);
    }

    if (entity instanceof ICombatEntity) {
      this.combatEntities.values().remove(entity);
    }

    this.unload(entity);

    this.fireEntityEvent(l -> l.entityRemoved(entity));
}
}
```
```java
class de.gurkenlabs.litiengine.physics.MovementController {
@Override
  public void update() {
    this.handleForces();
    this.handleMovement();
}
}
```
```java
class de.gurkenlabs.litiengine.Game {
static synchronized void terminate() {
    if (!initialized) {
      return;
    }

    hasStarted = false;
    initialized = false;

    config().save();
    gameLoop.terminate();
    tweenEngine.terminate();
    soundEngine.terminate();

    world().clear();

    for (final GameListener listener : gameListeners) {
      try {
        listener.terminated();
      } catch (Exception e) {
        log().log(Level.WARNING, "game listener threw an exception during shutdown", e);
      }
    }

    gameLoop = null;
    screenManager = null;
    gameWindow = null;
}public static synchronized void start() {
    if (!initialized) {
      throw new IllegalStateException(
          "The game cannot be started without being first initialized. Call Game.init(...) before Game.start().");
    }

    gameLoop.start();
    tweenEngine.start();
    soundEngine.start();

    for (final GameListener listener : gameListeners) {
      listener.started();
    }

    hasStarted = true;
}public static synchronized void init(String... args) {
    if (initialized) {
      log().log(Level.INFO, "The game has already been initialized.");
      return;
    }

    log.init();
    handleCommandLineArguments(args);

    config().load();
    Locale.setDefault(new Locale(config().client().getCountry(), config().client().getLanguage()));

    gameLoop = new GameLoop("Main Update Loop", config().client().getMaxFps());
    loop().attach(physics());
    loop().attach(world());

    // setup default exception handling for render and update loop
    setUncaughtExceptionHandler(
        new DefaultUncaughtExceptionHandler(config().client().exitOnError()));

    screenManager = new ScreenManager();
    gameWindow = new GameWindow();

    // initialize  the game window
    window().init();
    world.setCamera(new Camera());

    for (GameListener listener : gameListeners) {
      listener.initialized(args);
    }

    if (!isInNoGUIMode()) {
      window().getRenderComponent().onRendered(g -> metrics().render(g));

      graphics()
          .addEntityRenderedListener(
              e -> DebugRenderer.renderEntityDebugInfo(e.getGraphics(), e.getEntity()));

      window().getRenderComponent().onFpsChanged(fps -> metrics().setFramesPerSecond(fps));
      window()
          .setIcons(
              Arrays.asList(
                  Resources.images().get("liti-logo-x16.png"),
                  Resources.images().get("liti-logo-x20.png"),
                  Resources.images().get("liti-logo-x32.png"),
                  Resources.images().get("liti-logo-x48.png")));

      Input.keyboard()
          .onKeyTyped(
              KeyEvent.VK_PRINTSCREEN,
              key -> {
                // don't take a screenshot if a modifier is active
                if (key.getModifiers() != 0) {
                  return;
                }

                window().getRenderComponent().takeScreenshot();
              });
    }

    Runtime.getRuntime().addShutdownHook(new Thread(Game::terminate, "Shutdown"));

    initialized = true;
}
}
```


Response Format:
Provide the answer in **XML format** as follows:

#### If the method **cannot** return `null` at the specific call site:
```xml
<response>
  <reason><![CDATA[EXPLAIN WHY THE INVOCATION Game.loop() RESULT CANNOT BE NULL.]]></reason>
  <value>NO</value>
</response>

#### If the method can return null at the specific call site:
<response>
  <reason><![CDATA[EXPLAIN WHY THE INVOCATION Game.loop() RESULT CAN BE NULL.]]></reason>
  <value>YES</value>
</response>

#### If you are unsure or If there are any methods that directly or indirectly affect the return value and are not fully disclosed, request their declarations first, in the following format:
<response>
  <reason><![CDATA[EXPLAIN WHY THIS METHOD DECLARATION IS NECESSARY AND WHY YOU CANNOT MAKE A CONFIDENT DECISION WITHOUT IT]]></reason>
  <success>false</success>
  <methods>
    <method>methodName</method>
  </methods>
</response>

Additional Notes:
Be precise in your reasoning.
If a method’s return value depends on another method not provided, request its declaration before making a conclusion.
If the method can return null in this case but not in others, explain why it happens specifically for this call.

---ChatGPT.sendRequestToOpenAI---
Retrieving response from cache
---Response.<init>---
Creating Response:
```xml
<response>
  <reason><![CDATA[The method `Game.loop()` returns the static field `gameLoop`, which is initialized in the `Game.init(String... args)` method. In this method, a new `GameLoop` object is instantiated and assigned to `gameLoop`. Since `init()` must be called before `start()`, which is implied by the requirement of initializing the game, the `gameLoop` is guaranteed to be non-null during the lifetime of the game execution where `Game.loop()` is called. The absence of any code that could set `gameLoop` to null after its initialization ensures that `Game.loop()` cannot return null.]]></reason>
  <value>NO</value>
</response>
```
---Response.<init>---
Response created:
Disagreement: The method `Game.loop()` returns the static field `gameLoop`, which is initialized in the `Game.init(String... args)` method. In this method, a new `GameLoop` object is instantiated and assigned to `gameLoop`. Since `init()` must be called before `start()`, which is implied by the requirement of initializing the game, the `gameLoop` is guaranteed to be non-null during the lifetime of the game execution where `Game.loop()` is called. The absence of any code that could set `gameLoop` to null after its initialization ensures that `Game.loop()` cannot return null.
---AdvancedNullAwayCodeFix.resolveMethodDereferenceError---
Method is not returning nullable on call site. Injecting suppression annotation.
---AdvancedNullAwayCodeFix.constructCastToNonnullChange---
Constructing cast to nonnull change for reason: The method `Game.loop()` returns the static field `gameLoop`, which is initialized in the `Game.init(String... args)` method. In this method, a new `GameLoop` object is instantiated and assigned to `gameLoop`. Since `init()` must be called before `start()`, which is implied by the requirement of initializing the game, the `gameLoop` is guaranteed to be non-null during the lifetime of the game execution where `Game.loop()` is called. The absence of any code that could set `gameLoop` to null after its initialization ensures that `Game.loop()` cannot return null.
---ChatGPT.ask---
Asking ChatGPT:
For the reason you mentioned earlier:

"The method `Game.loop()` returns the static field `gameLoop`, which is initialized in the `Game.init(String... args)` method. In this method, a new `GameLoop` object is instantiated and assigned to `gameLoop`. Since `init()` must be called before `start()`, which is implied by the requirement of initializing the game, the `gameLoop` is guaranteed to be non-null during the lifetime of the game execution where `Game.loop()` is called. The absence of any code that could set `gameLoop` to null after its initialization ensures that `Game.loop()` cannot return null."

in the method below, the expression Game.loop() is not nullable at the point it is used.

```java
private static void initializeWindowEventListeners(Window window) {

    window.addWindowStateListener(
        e -> {
          if (e.getNewState() == Frame.ICONIFIED) {
            Game.loop().setTickRate(ICONIFIED_MAX_FPS);
          } else {
            Game.loop().setTickRate(Game.config().client().getMaxFps());
          }
        });

    window.addWindowFocusListener(
        new WindowFocusListener() {
          @Override
          public void windowLostFocus(WindowEvent e) {
            if (Game.config().graphics().reduceFramesWhenNotFocused()) {
              Game.loop().setTickRate(NONE_FOCUS_MAX_FPS);
            }
          }

          @Override
          public void windowGainedFocus(WindowEvent e) {
            Game.loop().setTickRate(Game.config().client().getMaxFps());
          }
        });

    window.addWindowListener(
        new WindowAdapter() {
          @Override
          public void windowClosing(final WindowEvent event) {
            Game.exit();
          }
        });
}
```
Please Summarize the reason in max 5 words and rewrite the method so that at the line "            Game.loop().setTickRate(ICONIFIED_MAX_FPS);", at the occurrence of: "Game.loop()" is replaced with `NullabilityUtil.castToNonnull(Game.loop(), summary of reason)`
Replace "REASON" with the exact reason summary I provide to you (maximum 5 words), not with a generic explanation like "checked to be nonnull".
see the example below, for expression `foo.getBar()`, to wrap it with `NullabilityUtil.castToNonnull(foo.getBar(), "reason")`.

```java
public t(){
    String l = foo.getBar();
}
```

will be:
```java
public t(){
    String l = NullabilityUtil.castToNonnull(foo.getBar(), "checked to be nonnull");
}
```

### Instructions:

Do not import any additional classes.

Do not add Java comments.

Only modify relevant lines as required.

Return only the modified method wrapped in the XML format shown below.

Place the Java code inside the <code> tag using a CDATA block with ```java formatting.

Just give me the fixed code snippet in XML format in <response> tag like the example below. I will apply the fix to my codebase. Do not import any additional libraries or classes or add java comments. If you can provide the fixed code snippet, please provide it in the following format and place the code snippet in the <code> tag within ```java block.
<response>
  <success>true</success>
  <code><![CDATA[
  ```java
  Your fixed code snippet here
  ```
    ]]>
  </code>
</response>

---ChatGPT.sendRequestToOpenAI---
Retrieving response from cache
---Response.<init>---
Creating Response:
<response>
  <success>true</success>
  <code><![CDATA[
  ```java
  private static void initializeWindowEventListeners(Window window) {

    window.addWindowStateListener(
        e -> {
          if (e.getNewState() == Frame.ICONIFIED) {
            NullabilityUtil.castToNonnull(Game.loop(), "init guarantees non-null").setTickRate(ICONIFIED_MAX_FPS);
          } else {
            Game.loop().setTickRate(Game.config().client().getMaxFps());
          }
        });

    window.addWindowFocusListener(
        new WindowFocusListener() {
          @Override
          public void windowLostFocus(WindowEvent e) {
            if (Game.config().graphics().reduceFramesWhenNotFocused()) {
              Game.loop().setTickRate(NONE_FOCUS_MAX_FPS);
            }
          }

          @Override
          public void windowGainedFocus(WindowEvent e) {
            Game.loop().setTickRate(Game.config().client().getMaxFps());
          }
        });

    window.addWindowListener(
        new WindowAdapter() {
          @Override
          public void windowClosing(final WindowEvent event) {
            Game.exit();
          }
        });
}
  ```
    ]]>
  </code>
</response>
---Response.<init>---
Response created:
private static void initializeWindowEventListeners(Window window) {

    window.addWindowStateListener(
        e -> {
          if (e.getNewState() == Frame.ICONIFIED) {
            NullabilityUtil.castToNonnull(Game.loop(), "init guarantees non-null").setTickRate(ICONIFIED_MAX_FPS);
          } else {
            Game.loop().setTickRate(Game.config().client().getMaxFps());
          }
        });

    window.addWindowFocusListener(
        new WindowFocusListener() {
          @Override
          public void windowLostFocus(WindowEvent e) {
            if (Game.config().graphics().reduceFramesWhenNotFocused()) {
              Game.loop().setTickRate(NONE_FOCUS_MAX_FPS);
            }
          }

          @Override
          public void windowGainedFocus(WindowEvent e) {
            Game.loop().setTickRate(Game.config().client().getMaxFps());
          }
        });

    window.addWindowListener(
        new WindowAdapter() {
          @Override
          public void windowClosing(final WindowEvent event) {
            Game.exit();
          }
        });
}
---ChatGPT.fixDereferenceByAddingCastToNonnull---
Fixing the error by adding castToNonnull
---AdvancedNullAwayCodeFix.fixTriggeredErrorsForLocation---
Resolving unresolvable error for triggered error: Type='DEREFERENCE_NULLABLE', message='dereferenced expression Game.loop() is @Nullable'
/home/nima/Developer/nullness-benchmarks/litiengine/src/de/gurkenlabs/litiengine/environment/GameWorld.java:521
      Game.loop().attach(cam);
---AdvancedNullAwayCodeFix.fix---
Fixing error: Type='DEREFERENCE_NULLABLE', message='dereferenced expression Game.loop() is @Nullable'
/home/nima/Developer/nullness-benchmarks/litiengine/src/de/gurkenlabs/litiengine/environment/GameWorld.java:521
      Game.loop().attach(cam);
---AdvancedNullAwayCodeFix.resolveDereferenceError---
Resolving dereference error: Type='DEREFERENCE_NULLABLE', message='dereferenced expression Game.loop() is @Nullable'
/home/nima/Developer/nullness-benchmarks/litiengine/src/de/gurkenlabs/litiengine/environment/GameWorld.java:521
      Game.loop().attach(cam);
---AdvancedNullAwayCodeFix.resolveDereferenceError---
Checking nullability possibility at error point
---ChatGPT.checkNullabilityPossibilityAtErrorPoint---
Asking if the expression can be null at error point point
---ChatGPT.ask---
Asking ChatGPT:
In the method below, is there a possibility that the expression "Game.loop()" at line "Game.loop().attach(cam);" is null?
public void setCamera(@Nullable final ICamera cam) {
    if (this.camera() != null) {
      Game.loop().detach(camera);
    }

    camera = cam;

    if (cam != null && !Game.isInNoGUIMode()) {
      Game.loop().attach(cam);
      cam.updateFocus();
    }
}
Give a single-word answer in XML format. If it is possible for the expression to be null, respond with:
```xml
<response>
    <reason><![CDATA[YOUR REASON]]></reason>
    <value>YES</value>
</response>
```
If it is not possible for the expression to be null, respond with:
```xml
<response>
    <reason><![CDATA[YOUR REASON]]></reason>
    <value>NO</value>
</response>
```
If you are unsure or need more information, respond with where you can ask for more details or what specific information you need.

If additional information is required, list each request inside a `<request>` tag. If no additional information is needed, omit the `<requests>` section.

Respond with:
```xml
<response>
    <reason><![CDATA[YOUR REASON]]></reason>
    <value>UNKNOWN</value>
    <!-- Include <requests> only if additional information is needed -->
    <requests>
        <request><![CDATA[YOUR REQUEST 1]]></request>
        <request><![CDATA[YOUR REQUEST 2]]></request>
    </requests>
</response>
```
---ChatGPT.sendRequestToOpenAI---
Retrieving response from cache
---Response.<init>---
Creating Response:
```xml
<response>
    <reason><![CDATA[The possibility of Game.loop() returning null depends on how the Game class is implemented, which is not provided. Without more information on the Game class and the loop() method implementation, it cannot be determined if Game.loop() might return null.]]></reason>
    <value>UNKNOWN</value>
    <requests>
        <request><![CDATA[Provide the implementation details of the Game class, specifically the loop() method.]]></request>
        <request><![CDATA[Clarify if there are any conditions under which Game.loop() might return null.]]></request>
    </requests>
</response>
```
---Response.<init>---
Response created:
Unknown: The possibility of Game.loop() returning null depends on how the Game class is implemented, which is not provided. Without more information on the Game class and the loop() method implementation, it cannot be determined if Game.loop() might return null.
---AdvancedNullAwayCodeFix.resolveMethodDereferenceError---
Resolving method dereference error.
---AdvancedNullAwayCodeFix.resolveMethodDereferenceError---
Method is in annotated package. Checking if the method is returning nullable.
---AdvancedNullAwayCodeFix.investigateMethodReturnNullability---
Checking if the method is returning nullable.
---ChatGPT.checkIfMethodIsReturningNullable---
Asking if the method is returning nullable: loop()
---ChatGPT.ask---
Asking ChatGPT:
In the method below, is there a possibility that the method returns null based only on its body? Consider the following points:

- The method may have multiple return paths; consider all return statements.
- If the method calls another method, do not assume its return value unless its full declaration is provided. Request its declaration if needed.
- The method may throw an exception instead of returning null. An exception path should not be considered a null return.
- Ensure you request the declarations of any methods whose return values directly or indirectly impact this method’s return value before making a conclusion.
- Carefully analyze all conditions and prior operations that may guarantee a non-null return value.

@Nullable public static IGameLoop loop() {
    return gameLoop;
}

Here are the method definitions in addition to the method inquired:

Depth: 0
```java
class de.gurkenlabs.litiengine.Game {
@Nullable public static IGameLoop loop() {
    return gameLoop;
}
}
```


Response Format:
Provide the answer in **XML format** as follows:

#### If the method **cannot** return `null`:
```xml
<response>
  <reason><![CDATA[EXPLAIN WHY THE METHOD CANNOT RETURN NULL]]></reason>
  <value>NO</value>
</response>
```

#### If the method can return null:
```xml
<response>
  <reason><![CDATA[EXPLAIN WHY THE METHOD CAN RETURN NULL]]></reason>
  <value>YES</value>
</response>
```

#### If you are unsure or need more information, respond with where you can ask for more details or what specific information you need.

#### If you are unsure or If there are any methods that directly or indirectly affect the return value and are not fully disclosed, request their declarations first, in the following format:
<response>
  <reason><![CDATA[YOUR REASON]]></reason>
  <value>UNKNOWN</value>
  <methods>
    <method>methodName</method>
  </methods>
</response>

If additional information is required other than method declaration, list each request inside a `<request>` tag. If no additional information is needed, omit the `<requests>` section.

Respond with:
```xml
<response>
    <reason><![CDATA[YOUR REASON]]></reason>
    <value>UNKNOWN</value>
    <!-- Include <requests> only if additional information is needed -->
    <requests>
        <request><![CDATA[YOUR REQUEST 1]]></request>
        <request><![CDATA[YOUR REQUEST 2]]></request>
    </requests>
</response>
```

Additional Notes:
Be precise in your reasoning.
If a method’s return value depends on another method not provided, request its declaration before making a conclusion.
If the method can return null in some cases but not others, explain under what conditions it can happen.

---ChatGPT.sendRequestToOpenAI---
Retrieving response from cache
---Response.<init>---
Creating Response:
```xml
<response>
  <reason><![CDATA[The method `loop` returns the variable `gameLoop`. Without the initialization or assignment details of `gameLoop`, it's unclear whether it can be null. The possibility of `gameLoop` being uninitialized or set to null elsewhere in the program means `loop` could potentially return null. Further information on `gameLoop` is required.]]></reason>
  <value>UNKNOWN</value>
  <requests>
    <request><![CDATA[Please provide the declaration and initialization of the variable `gameLoop` in the class `de.gurkenlabs.litiengine.Game`.]]></request>
  </requests>
</response>
```
---Response.<init>---
Response created:
Unknown: The method `loop` returns the variable `gameLoop`. Without the initialization or assignment details of `gameLoop`, it's unclear whether it can be null. The possibility of `gameLoop` being uninitialized or set to null elsewhere in the program means `loop` could potentially return null. Further information on `gameLoop` is required.
---AdvancedNullAwayCodeFix.investigateMethodReturnNullability---
Could not determine the nullability and model did not ask for any method.
---ChatGPT.checkIfMethodIsReturningNullableOnCallSite---
Asking if the method is returning nullable on the call site: Game.loop()
---ChatGPT.ask---
Asking ChatGPT:
In the method below, is there a possibility that the method returns null at the given call site?

```java
@Nullable public static IGameLoop loop() {
    return gameLoop;
}
```

## Guidelines:
- The method may have multiple return paths; consider all return statements.
- If the method calls another method, do not assume its return value unless its full declaration is provided. Request its declaration if needed.
- The method may throw an exception instead of returning null. An exception path should not be considered a null return.
- Ensure you request the declarations of any methods whose return values directly or indirectly impact this method’s return value before making a conclusion.
- If the method returns a value that is determined by a parameter, evaluate based on the actual argument at the given call site.
- Analyze based only on the specific invocation provided. Do not generalize to all possible inputs.- If the return value is guaranteed to be non-null at the call site, the answer should be a definitive NO.
- Do not generalize based on all possible inputs—your answer must be based only on the given invocation.
- Focus only on the given call site, not all possible invocations.

### call site:
Game.loop()

Here are the method definitions and the call chain for this method, showing the sequence of calls from the method to its callers at each depth level:

Depth: 0
```java
class de.gurkenlabs.litiengine.Game {
@Nullable public static IGameLoop loop() {
    return gameLoop;
}
}
```
Depth: 1
```java
class de.gurkenlabs.litiengine.environment.GameWorld {
public void loadEnvironment(@Nullable final Environment env) {
    Lock lock = Game.loop().getLock();
    lock.lock();
    try {
      unloadEnvironment();
      this.environment = env;
      if (env != null) {
        this.addEnvironment(env);

        if (env.getGravity() == 0 && this.gravity() != 0) {
          env.setGravity(this.gravity());
        }

        env.load();
        for (final EnvironmentLoadedListener listener : this.loadedListeners) {
          listener.loaded(env);
        }

        // call map specific listeners
        String mapName = getMapName(env);
        if (mapName != null && this.environmentLoadedListeners.containsKey(mapName)) {

          // for the default camera we center the camera on the environment
          if (this.camera().getClass().equals(Camera.class)) {
            camera().setFocus(env.getCenter());
          }

          for (EnvironmentLoadedListener listener : this.environmentLoadedListeners.get(mapName)) {
            listener.loaded(env);
          }
        }
      }
    } finally {
      lock.unlock();
    }
}public void setCamera(@Nullable final ICamera cam) {
    if (this.camera() != null) {
      Game.loop().detach(camera);
    }

    camera = cam;

    if (cam != null && !Game.isInNoGUIMode()) {
      Game.loop().attach(cam);
      cam.updateFocus();
    }
}
}
```
```java
class de.gurkenlabs.litiengine.entities.behavior.EntityNavigator {
public EntityNavigator(final IMobileEntity entity, final PathFinder pathFinder) {
    this.cancelNavigationConditions = new CopyOnWriteArrayList<>();
    this.listeners = new CopyOnWriteArrayList<>();
    this.entity = entity;
    this.pathFinder = pathFinder;
    this.setAcceptableError(DEFAULT_ACCEPTABLE_ERROR);
    Game.loop().attach(this);
}
}
```
```java
class de.gurkenlabs.litiengine.GameWindow {
private static void initializeWindowEventListeners(Window window) {

    window.addWindowStateListener(
        e -> {
          if (e.getNewState() == Frame.ICONIFIED) {
            Game.loop().setTickRate(ICONIFIED_MAX_FPS);
          } else {
            Game.loop().setTickRate(Game.config().client().getMaxFps());
          }
        });

    window.addWindowFocusListener(
        new WindowFocusListener() {
          @Override
          public void windowLostFocus(WindowEvent e) {
            if (Game.config().graphics().reduceFramesWhenNotFocused()) {
              Game.loop().setTickRate(NONE_FOCUS_MAX_FPS);
            }
          }

          @Override
          public void windowGainedFocus(WindowEvent e) {
            Game.loop().setTickRate(Game.config().client().getMaxFps());
          }
        });

    window.addWindowListener(
        new WindowAdapter() {
          @Override
          public void windowClosing(final WindowEvent event) {
            Game.exit();
          }
        });
}
}
```
```java
class de.gurkenlabs.litiengine.gui.screens.ScreenManager {
public void display(@Nullable final Screen screen) {
    if (Game.hasStarted() && Game.time().since(this.lastScreenChange) < this.getChangeCooldown()) {
      log.log(
          Level.INFO,
          "Skipping displaying of screen {0} because screen changing is currently on cooldown.",
          screen != null ? screen.getName() : "");
      return;
    }

    final Screen previous = this.current();
    if (previous != null) {
      previous.suspend();
    }

    if (screen != null && !this.screens.contains(screen)) {
      this.screens.add(screen);
    }

    this.currentScreen = screen;
    if (!Game.isInNoGUIMode() && this.current() != null) {
      this.current().prepare();
    }

    this.lastScreenChange = Game.loop().getTicks();

    final ScreenChangedEvent event = new ScreenChangedEvent(this.current(), previous);
    for (final ScreenChangedListener listener : this.screenChangedListeners) {
      listener.changed(event);
    }
}
}
```
```java
class de.gurkenlabs.litiengine.abilities.effects.Effect {
@Override
  public void update() {

    for (final Iterator<EffectApplication> iterator = this.getActiveAppliances().iterator();
        iterator.hasNext(); ) {
      final EffectApplication appliance = iterator.next();
      // if the effect duration is reached
      if (this.hasEnded(appliance)) {

        iterator.remove();
        this.cease(appliance);
      }
    }

    // 4. unregister if all appliances are finished
    if (this.getActiveAppliances().isEmpty()) {
      Game.loop().detach(this);
    }
}public void apply(final Shape impactArea) {
    final List<ICombatEntity> affected = this.lookForAffectedEntities(impactArea);
    for (final ICombatEntity affectedEntity : affected) {
      this.apply(affectedEntity);
    }

    this.appliances.add(new EffectApplication(affected, impactArea));

    // if it is the first appliance -> register for update
    if (this.appliances.size() == 1) {
      Game.loop().attach(this);
    }
}
}
```
```java
class de.gurkenlabs.litiengine.GameTime {
public long toTicks(final int milliseconds) {
    return this.toTicks(milliseconds, Game.loop().getTickRate());
}public long since(final long tick) {
    return toMilliseconds(Game.loop().getTicks() - tick);
}public long now() {
    return Game.loop().getTicks();
}public long sinceGameStart() {
    return this.toMilliseconds(Game.loop().getTicks());
}@Override
  public void loaded(Environment environment) {
    environmentLoaded = Game.loop().getTicks();
}public long toMilliseconds(final long ticks) {
    return this.toMilliseconds(ticks, Game.loop().getTickRate());
}
}
```
```java
class de.gurkenlabs.litiengine.GameMetrics {
@Override
  public void render(final Graphics2D g) {
    this.updateMetrics();

    if (!Game.config().client().showGameMetrics()) {
      return;
    }

    this.currentOffsetY = 0;

    g.setColor(this.renderColor);

    // render client metrics
    this.drawTitle(g, "[client]");
    this.drawMetric(g, "fps       : " + this.getFramesPerSecond());
    this.drawMetric(g, "max fps   : " + this.maxFramesPerSecond);
    this.drawMetric(g, "updatables: " + Game.loop().getUpdatableCount());

    // render jvm metrics if debug is enabled
    if (Game.config().debug().isDebugEnabled()) {
      this.drawTitle(g, "[jvm]");
      this.drawMetric(g, "java      : " + this.javaVersion);
      this.drawMetric(g, "memory    : " + String.format("%-5.5s", this.usedMemory) + " MB");
      this.drawMetric(g, "threads   : " + Thread.activeCount());
    }

    // render rendering metrics
    if (!this.renderMetrics.isEmpty()) {
      this.drawTitle(g, "[update]");

      for (RenderMetrics metric : this.renderMetrics) {
        this.drawMetric(g, metric.toString());
      }

      this.renderMetrics.clear();
    }
}
}
```
```java
class de.gurkenlabs.litiengine.graphics.emitters.Emitter {
public void deactivate() {
    if (!this.activated) {
      return;
    }

    this.activated = false;
    this.getParticles().clear();
    this.aliveTime = 0;
    this.activationTick = 0;
    this.lastSpawn = 0;
    Game.loop().detach(this);
}public void activate() {
    if (this.activated) {
      return;
    }

    this.activated = true;
    this.activationTick = Game.time().now();
    Game.loop().attach(this);
}@Override
  public void update() {
    if (this.isPaused()) {
      return;
    }

    // clear particles if the effect time to life is reached
    if (this.isFinished()) {
      for (EmitterFinishedListener listener : this.finishedListeners) {
        listener.finished(this);
      }

      this.delete();
      return;
    }

    final float updateRatio = (float) this.data().getUpdateRate() / Game.loop().getTickRate();
    for (final Particle p : this.getParticles().stream().collect(Collectors.toList())) {
      if (this.particleCanBeRemoved(p)) {
        // remove dead particles
        this.particles.remove(p);
        continue;
      }

      p.update(this.getOrigin(), updateRatio);
    }

    this.aliveTime = Game.time().since(this.activationTick);
    if ((this.data().getSpawnRate() == 0
        || Game.time().since(this.lastSpawn) >= this.data().getSpawnRate())) {
      this.lastSpawn = Game.time().now();
      this.spawnParticle();
    }
}
}
```
```java
class de.gurkenlabs.litiengine.entities.behavior.IBehaviorController {
public default void attach() {
    Game.loop().attach(this);
}public default void detach() {
    Game.loop().detach(this);
}
}
```
```java
class de.gurkenlabs.litiengine.abilities.AbilityExecution {
AbilityExecution(final Ability ability) {
    this.appliedEffects = new CopyOnWriteArrayList<>();
    this.ability = ability;
    this.executionTicks = Game.time().now();
    this.impactArea = ability.calculateImpactArea();
    this.castLocation = ability.getExecutor().getCenter();
    Game.loop().attach(this);
}@Override
  public void update() {
    // if there a no effects to apply -> unregister this instance and we're done
    if (this.getAbility().getEffects().isEmpty()
        || this.getAbility().getEffects().size() == this.getAppliedEffects().size()) {
      Game.loop().detach(this);
      return;
    }

    // handle all effects from the ability that were not applied yet
    for (final Effect effect : this.getAbility().getEffects()) {
      // if the ability was not executed yet or the delay of the effect is not
      // yet reached
      if (this.getAppliedEffects().contains(effect)
          || Game.time().since(this.getExecutionTicks()) < effect.getDelay()) {
        continue;
      }

      effect.apply(this.getExecutionImpactArea());
      this.getAppliedEffects().add(effect);
    }
}
}
```
```java
class de.gurkenlabs.litiengine.GameWindow$3 {
@Override
          public void windowGainedFocus(WindowEvent e) {
            Game.loop().setTickRate(Game.config().client().getMaxFps());
}@Override
          public void windowLostFocus(WindowEvent e) {
            if (Game.config().graphics().reduceFramesWhenNotFocused()) {
              Game.loop().setTickRate(NONE_FOCUS_MAX_FPS);
            }
}
}
```
```java
class de.gurkenlabs.litiengine.environment.EntitySpawner {
protected void spawnNewEntities() {
    if (this.getSpawnMode() != SpawnMode.CUSTOMSPAWNPOINTS && this.getSpawnPoints().isEmpty()) {
      return;
    }

    switch (this.getSpawnMode()) {
      case ALLSPAWNPOINTS:
        for (int i = 0; i < this.getSpawnPoints().size(); i++) {
          final int index = i;
          Game.loop()
              .perform(
                  this.getSpawnDelay() + this.getSpawnDelay() * i,
                  () -> this.spawn(this.getSpawnPoints().get(index), this.getSpawnAmount()));
        }
        break;
      case ONERANDOMSPAWNPOINT:
        this.spawn(Game.random().choose(this.getSpawnPoints()), this.getSpawnAmount());
        break;
      case RANDOMSPAWNPOINTS:
        for (int i = 0; i < this.getSpawnAmount(); i++) {
          Game.loop()
              .perform(
                  this.getSpawnDelay() + this.getSpawnDelay() * i,
                  () -> this.spawn(Game.random().choose(this.getSpawnPoints()), 1));
        }
        break;
      case CUSTOMSPAWNPOINTS:
        List<Spawnpoint> spawnPoints =
            this.customSpawnpoints != null
                ? this.customSpawnpoints.apply(this)
                : this.getCustomSpawnpoints();

        int index = 0;
        for (Spawnpoint spawn : spawnPoints) {
          Game.loop()
              .perform(
                  this.getSpawnDelay() + this.getSpawnDelay() * index, () -> this.spawn(spawn, 1));
          index++;
        }
        break;
      default:
        break;
    }
}
}
```
```java
class de.gurkenlabs.litiengine.tweening.TweenEngine {
@Override
  public void start() {
    Game.loop().attach(this);
}@Override
  public void terminate() {
    Game.loop().detach(this);
}
}
```
```java
class de.gurkenlabs.litiengine.gui.SpeechBubble {
public void hide() {
    Game.world().environment().removeRenderable(this);
    Game.loop().detach(this);
    if (activeSpeechBubbles.get(this.getEntity()) != null
        && activeSpeechBubbles.remove(this.getEntity()).equals(this)) {
      activeSpeechBubbles.remove(this.getEntity());
    }

    for (SpeechBubbleListener listener : this.listeners) {
      listener.hidden();
    }
}private SpeechBubble(
      final IEntity entity,
      final String text,
      @Nullable SpeechBubbleAppearance appearance,
      @Nullable Font font) {
    if (appearance == null) {
      this.appearance = DEFAULT_APPEARANCE;
    } else {
      this.appearance = appearance;
    }

    final SpeechBubble active = activeSpeechBubbles.get(entity);
    if (active != null) {
      active.hide();
    }
    this.setFont(font);

    this.textBoxWidth = (float) (entity.getWidth() * 4);
    this.entity = entity;

    this.currentText = text;
    this.currentTextDisplayTime = DISPLAYTIME_MIN + text.length() * DISPLAYTIME_PER_LETTER;

    this.lastTextDisplay = Game.time().now();
    this.createBubbleImage();
    entity.getEnvironment().add(this, RenderType.UI);
    Game.loop().attach(this);
    activeSpeechBubbles.put(entity, this);
}
}
```
```java
class de.gurkenlabs.litiengine.entities.Prop {
private void updateAnimationController() {
    IEntityAnimationController<?> controller = this.createAnimationController();
    this.getControllers().addController(controller);
    if (Game.world().environment() != null && Game.world().environment().isLoaded()) {
      Game.loop().attach(controller);
    }
}
}
```
```java
class de.gurkenlabs.litiengine.graphics.FreeFlightCamera {
public FreeFlightCamera(final Point2D focus) {
    this.setFocus(focus);
    this.velocity = DEFAULT_SCROLL_PIXELS_PER_SECOND;
    this.scrollPadding = DEFAULT_SCROLL_PADDING;
    this.setClampToMap(true);

    Game.loop().attach(this);
}private void handleFreeFlightCamera() {
    if (Game.world().environment() == null || Game.world().environment().getMap() == null) {
      return;
    }

    final Point2D mouseLocation = Input.mouse().getLocation();

    final double scrollSpeed =
        this.getVelocity()
            / (double) Game.loop().getTickRate()
            * Game.config().input().getMouseSensitivity();

    double x = this.getFocus().getX();
    double y = this.getFocus().getY();

    double deltaX = 0;
    if (mouseLocation.getX() < this.getScrollPadding()) {
      deltaX -= scrollSpeed;
    } else if (Game.window().getResolution().getWidth() - mouseLocation.getX()
        < this.getScrollPadding()) {
      deltaX += scrollSpeed;
    }

    double deltaY = 0;
    if (mouseLocation.getY() < this.getScrollPadding()) {
      deltaY -= scrollSpeed;
    } else if (Game.window().getResolution().getHeight() - mouseLocation.getY()
        < this.getScrollPadding()) {
      deltaY += scrollSpeed;
    }

    x += deltaX;
    y += deltaY;

    this.setFocus(new Point2D.Double(x, y));
}
}
```
```java
class de.gurkenlabs.litiengine.environment.Environment {
private static void dispose(final Collection<? extends IEntity> entities) {
    for (final IEntity entity : entities) {
      if (entity instanceof IUpdateable) {
        Game.loop().detach((IUpdateable) entity);
      }

      entity.detachControllers();
    }
}private static void loadUpdatableOrEmitterEntity(IEntity entity) {
    if (entity instanceof Emitter) {
      final Emitter emitter = (Emitter) entity;
      if (emitter.isActivateOnInit()) {
        emitter.activate();
      }
    } else if (entity instanceof IUpdateable) {
      Game.loop().attach((IUpdateable) entity);
    }
}private void unload(final IEntity entity) {
    // 1. remove from physics engine
    if (entity instanceof ICollisionEntity) {
      Game.physics().remove((ICollisionEntity) entity);
    }

    // 2. unregister from update
    if (entity instanceof IUpdateable) {
      Game.loop().detach((IUpdateable) entity);
    }

    if (entity instanceof IMobileEntity) {
      this.removeGravity((IMobileEntity) entity);
    }

    // 3. detach all controllers
    entity.detachControllers();

    if (entity instanceof Emitter) {
      Emitter em = (Emitter) entity;
      em.deactivate();
    }

    if (this.loaded && (entity instanceof LightSource || entity instanceof StaticShadow)) {
      this.updateLighting(entity);
    }

    entity.removed(this);
}
}
```
```java
class de.gurkenlabs.litiengine.graphics.animation.Animation {
@Override
  public void update() {
    // do nothing if the animation is not playing or the current keyframe is not finished
    if (!this.isPlaying()
        || Game.time().since(this.lastFrameUpdate) < this.getCurrentKeyFrame().getDuration()) {
      return;
    }

    // if we are not looping and the last keyframe is finished, we terminate the animation
    if (!this.isLooping() && this.isLastKeyFrame()) {
      this.terminate();
      return;
    }

    // make sure, we stay inside the keyframe list
    final int newFrameIndex =
        (this.getKeyframes().indexOf(this.currentFrame) + 1) % this.getKeyframes().size();
    final KeyFrame previousFrame = this.currentFrame;
    this.currentFrame = this.getKeyframes().get(newFrameIndex);

    for (KeyFrameListener listener : this.listeners) {
      listener.currentFrameChanged(previousFrame, this.currentFrame);
    }

    this.lastFrameUpdate = Game.loop().getTicks();
}public void restart() {
    this.currentFrame = this.firstFrame;
    this.lastFrameUpdate = Game.loop().getTicks();
}
}
```
```java
class de.gurkenlabs.litiengine.physics.MovementController {
@Override
  public void attach() {
    Game.loop().attach(this);
}private void handleForces() {
    // clean up forces
    this.activeForces.forEach(
        x -> {
          if (x.hasEnded()) {
            this.activeForces.remove(x);
          }
        });

    if (this.activeForces.isEmpty()) {
      return;
    }

    // disable turn-on-move for force handling
    boolean turn = this.getEntity().turnOnMove();
    this.getEntity().setTurnOnMove(false);
    try {
      double deltaX = 0;
      double deltaY = 0;
      for (final Force force : this.activeForces) {
        if (force.cancelOnReached() && force.hasReached(this.getEntity())) {
          force.end();
          continue;
        }

        final Point2D collisionBoxCenter = this.getEntity().getCollisionBoxCenter();
        final double angle =
            GeometricUtilities.calcRotationAngleInDegrees(collisionBoxCenter, force.getLocation());
        final double strength =
            Game.loop().getDeltaTime() * 0.001f * force.getStrength() * Game.loop().getTimeScale();
        deltaX += GeometricUtilities.getDeltaX(angle, strength);
        deltaY += GeometricUtilities.getDeltaY(angle, strength);
      }

      final Point2D target =
          new Point2D.Double(this.getEntity().getX() + deltaX, this.getEntity().getY() + deltaY);
      final boolean success = Game.physics().move(this.getEntity(), target);
      if (!success) {
        for (final Force force : this.activeForces) {
          if (force.cancelOnCollision()) {
            force.end();
          }
        }
      }
    } finally {
      this.getEntity().setTurnOnMove(turn);
    }
}@Override
  public void detach() {
    Game.loop().detach(this);
}public void handleMovement() {
    if (!this.isMovementAllowed()) {
      this.velocity = 0;
      return;
    }

    // max distance an entity can travel within one tick
    final double maxPixelsPerTick = this.getEntity().getTickVelocity();
    final double deltaTime = Game.loop().getDeltaTime() * Game.loop().getTimeScale();

    final double acceleration =
        this.getEntity().getAcceleration() == 0
            ? maxPixelsPerTick
            : deltaTime / this.getEntity().getAcceleration() * maxPixelsPerTick;
    final double deceleration =
        this.getEntity().getDeceleration() == 0
            ? this.getVelocity()
            : deltaTime / this.getEntity().getDeceleration() * maxPixelsPerTick;

    double dx = this.getDx();
    double dy = this.getDy();
    this.setDx(0);
    this.setDy(0);

    final double deltaVelocity =
        Math.min(Math.sqrt(Math.pow(dx, 2) + Math.pow(dy, 2)), acceleration);
    if (deltaVelocity != 0) {
      double newVelocity = this.getVelocity() + deltaVelocity;
      this.setVelocity(newVelocity);
    } else {
      final double newVelocity = Math.max(0, this.getVelocity() - deceleration);
      this.setVelocity(newVelocity);
      dx = GeometricUtilities.getDeltaX(this.moveAngle);
      dy = GeometricUtilities.getDeltaY(this.moveAngle);
    }

    if (this.getVelocity() == 0) {
      this.moveAngle = 0;
      return;
    }

    // actually move entity
    this.moveEntity(dx, dy);
}
}
```
```java
class de.gurkenlabs.litiengine.graphics.animation.AnimationController {
public void detach() {
    Game.loop().detach(this);
}public void attach() {
    Game.loop().attach(this);
}
}
```
```java
class de.gurkenlabs.litiengine.graphics.Camera {
@Override
  public void setZoom(final float targetZoom, final int delay) {
    if (delay == 0) {

      this.zoom = targetZoom;
      this.targetZoom = 0;
      this.zoomDelay = 0;
      this.zoomTick = 0;
      this.zoomStep = 0;

      final ZoomChangedEvent event = new ZoomChangedEvent(this, targetZoom);
      for (final ZoomChangedListener listener : this.zoomListeners) {
        listener.zoomChanged(event);
      }
    } else {
      this.zoomTick = Game.time().now();
      this.targetZoom = targetZoom;
      this.zoomDelay = delay;

      final double tickduration = 1000 / (double) Game.loop().getTickRate();
      final double tickAmount = delay / tickduration;
      final float totalDelta = this.targetZoom - this.zoom;
      this.zoomStep = tickAmount > 0 ? (float) (totalDelta / tickAmount) : totalDelta;
    }
}
}
```
```java
class de.gurkenlabs.litiengine.Game {
public static synchronized void init(String... args) {
    if (initialized) {
      log().log(Level.INFO, "The game has already been initialized.");
      return;
    }

    log.init();
    handleCommandLineArguments(args);

    config().load();
    Locale.setDefault(new Locale(config().client().getCountry(), config().client().getLanguage()));

    gameLoop = new GameLoop("Main Update Loop", config().client().getMaxFps());
    loop().attach(physics());
    loop().attach(world());

    // setup default exception handling for render and update loop
    setUncaughtExceptionHandler(
        new DefaultUncaughtExceptionHandler(config().client().exitOnError()));

    screenManager = new ScreenManager();
    gameWindow = new GameWindow();

    // initialize  the game window
    window().init();
    world.setCamera(new Camera());

    for (GameListener listener : gameListeners) {
      listener.initialized(args);
    }

    if (!isInNoGUIMode()) {
      window().getRenderComponent().onRendered(g -> metrics().render(g));

      graphics()
          .addEntityRenderedListener(
              e -> DebugRenderer.renderEntityDebugInfo(e.getGraphics(), e.getEntity()));

      window().getRenderComponent().onFpsChanged(fps -> metrics().setFramesPerSecond(fps));
      window()
          .setIcons(
              Arrays.asList(
                  Resources.images().get("liti-logo-x16.png"),
                  Resources.images().get("liti-logo-x20.png"),
                  Resources.images().get("liti-logo-x32.png"),
                  Resources.images().get("liti-logo-x48.png")));

      Input.keyboard()
          .onKeyTyped(
              KeyEvent.VK_PRINTSCREEN,
              key -> {
                // don't take a screenshot if a modifier is active
                if (key.getModifiers() != 0) {
                  return;
                }

                window().getRenderComponent().takeScreenshot();
              });
    }

    Runtime.getRuntime().addShutdownHook(new Thread(Game::terminate, "Shutdown"));

    initialized = true;
}
}
```
```java
class de.gurkenlabs.litiengine.entities.Creature {
protected void updateAnimationController() {
    IEntityAnimationController<?> controller = this.createAnimationController();
    this.getControllers().addController(controller);
    if (Game.world().environment() != null && Game.world().environment().isLoaded()) {
      Game.loop().attach(controller);
    }
}@Override
  public float getTickVelocity() {
    // pixels per ms multiplied by the passed ms
    // ensure that entities don't travel too far in case of lag
    return Math.min(Game.loop().getDeltaTime(), GameLoop.TICK_DELTATIME_LAG)
        * 0.001F
        * this.getVelocity().get()
        * Game.loop().getTimeScale();
}
}
```
Depth: 2
```java
class de.gurkenlabs.litiengine.environment.GameWorld {
public void clear() {
    this.unloadEnvironment();
    this.environments.clear();
    this.setCamera(null);
    Game.physics().clear();

    this.environmentListeners.clear();
    this.environmentLoadedListeners.clear();
    this.environmentUnloadedListeners.clear();

    this.listeners.clear();
    this.loadedListeners.clear();
    this.unloadedListeners.clear();
}@Nullable
  public Environment loadEnvironment(IMap map) {
    Environment env = this.getEnvironment(map);
    this.loadEnvironment(env);
    return env;
}@Nullable
  public Environment loadEnvironment(String mapName) {
    Environment env = this.getEnvironment(mapName);
    this.loadEnvironment(env);
    return env;
}
}
```
```java
class de.gurkenlabs.litiengine.GameWindow {
GameWindow() {
    this.hostControl = new JFrame();

    this.resolutionChangedListeners = new CopyOnWriteArrayList<>();

    this.renderCanvas = new RenderComponent(Game.config().graphics().getResolution());
    this.cursor = new MouseCursor();
    if (!Game.isInNoGUIMode()) {
      this.hostControl.setBackground(Color.BLACK);
      this.hostControl.add(this.renderCanvas);

      this.initializeEventListeners();

      this.hostControl.setTitle(Game.info().getTitle());
      this.hostControl.setDefaultCloseOperation(WindowConstants.DO_NOTHING_ON_CLOSE);
      initializeWindowEventListeners(this.hostControl);
    }
}
}
```
```java
class de.gurkenlabs.litiengine.GameTime {
public long sinceEnvironmentLoad() {
    return this.since(this.environmentLoaded);
}public long since(final long tick) {
    return toMilliseconds(Game.loop().getTicks() - tick);
}public long sinceGameStart() {
    return this.toMilliseconds(Game.loop().getTicks());
}
}
```
```java
class de.gurkenlabs.litiengine.abilities.effects.Effect {
protected void cease(final EffectApplication appliance) {
    // 1. cease the effect for all affected entities
    for (final ICombatEntity entity : appliance.getAffectedEntities()) {
      this.cease(entity);
    }

    // 2. apply follow up effects
    this.getFollowUpEffects().forEach(followUp -> followUp.apply(appliance.getImpactArea()));
}protected boolean hasEnded(final EffectApplication appliance) {
    final long effectDuration = Game.time().since(appliance.getAppliedTicks());
    return effectDuration > this.getDuration();
}
}
```
```java
class de.gurkenlabs.litiengine.abilities.effects.EffectApplication {
protected EffectApplication(final List<ICombatEntity> affectedEntities, final Shape impactArea) {
    this.applied = Game.time().now();
    this.affectedEntities = affectedEntities;
    this.impactArea = impactArea;
}
}
```
```java
class de.gurkenlabs.litiengine.entities.CombatEntity {
@Override
  public boolean wasHit(int timeSpan) {
    return Game.time().since(this.lastHit) < timeSpan;
}@Override
  public void hit(final int damage, @Nullable final Ability ability) {
    if (this.isDead()) {
      return;
    }

    if (!this.isIndestructible()) {
      this.getHitPoints().modifyBaseValue(new AttributeModifier<>(Modification.SUBTRACT, damage));
    }

    final EntityHitEvent event = new EntityHitEvent(this, ability, damage, this.isDead());

    for (final CombatEntityListener listener : this.listeners) {
      listener.hit(event);
    }

    for (final CombatEntityHitListener listener : this.hitListeners) {
      listener.hit(event);
    }

    if (this.isDead()) {
      this.fireDeathEvent();
      this.setCollision(false);
    }

    this.lastHit = Game.time().now();
}
}
```
```java
class de.gurkenlabs.litiengine.graphics.ImageEffect {
protected ImageEffect(final int ttl, final String name) {
    this.ttl = ttl;
    this.name = name;
    this.aliveTick = Game.time().now();
}@Override
  public long getAliveTime() {
    return Game.time().since(this.aliveTick);
}
}
```
```java
class de.gurkenlabs.litiengine.abilities.AbilityExecution {
AbilityExecution(final Ability ability) {
    this.appliedEffects = new CopyOnWriteArrayList<>();
    this.ability = ability;
    this.executionTicks = Game.time().now();
    this.impactArea = ability.calculateImpactArea();
    this.castLocation = ability.getExecutor().getCenter();
    Game.loop().attach(this);
}@Override
  public void update() {
    // if there a no effects to apply -> unregister this instance and we're done
    if (this.getAbility().getEffects().isEmpty()
        || this.getAbility().getEffects().size() == this.getAppliedEffects().size()) {
      Game.loop().detach(this);
      return;
    }

    // handle all effects from the ability that were not applied yet
    for (final Effect effect : this.getAbility().getEffects()) {
      // if the ability was not executed yet or the delay of the effect is not
      // yet reached
      if (this.getAppliedEffects().contains(effect)
          || Game.time().since(this.getExecutionTicks()) < effect.getDelay()) {
        continue;
      }

      effect.apply(this.getExecutionImpactArea());
      this.getAppliedEffects().add(effect);
    }
}
}
```
```java
class de.gurkenlabs.litiengine.tweening.TweenEngine {
@Override
  public void update() {
    for (final Tweenable target : this.getTweens().keySet()) {
      for (final Tween tween : this.getTweens().get(target).values()) {
        if (tween.hasStopped()) {
          continue;
        }
        final long elapsed = Game.time().since(tween.getStartTime());
        if (elapsed >= tween.getDuration()) {
          tween.stop();
          continue;
        }
        final float[] currentValues = new float[tween.getTargetValues().length];
        for (int i = 0; i < tween.getTargetValues().length; i++) {
          currentValues[i] =
              tween.getStartValues()[i]
                  + tween.getEquation().compute(elapsed / (float) tween.getDuration())
                      * (tween.getTargetValues()[i] - tween.getStartValues()[i]);
        }
        tween.getTarget().setTweenValues(tween.getType(), currentValues);
      }
    }
}
}
```
```java
class de.gurkenlabs.litiengine.gui.SpeechBubble {
public static SpeechBubble create(
      final IEntity entity, final String text, SpeechBubbleAppearance appearance, Font font) {
    return new SpeechBubble(entity, text, appearance, font);
}public static SpeechBubble create(final IEntity entity, final Font font, final String text) {
    SpeechBubbleAppearance app =
        new SpeechBubbleAppearance(
            DEFAULT_APPEARANCE.getForeColor(),
            DEFAULT_APPEARANCE.getBackgroundColor1(),
            DEFAULT_APPEARANCE.getBorderColor(),
            DEFAULT_APPEARANCE.getPadding());
    return new SpeechBubble(entity, text, app, font);
}public static SpeechBubble create(final IEntity entity, final String text) {
    return new SpeechBubble(entity, text, null, GuiProperties.getDefaultFont());
}@Override
  public void update() {
    if (this.currentText == null) {
      this.hide();
      return;
    }

    this.entityCenter = Game.world().camera().getViewportLocation(this.getEntity().getCenter());

    // old text was displayed long enough
    if (this.lastTextDisplay != 0
        && Game.time().since(this.lastTextDisplay) > this.currentTextDisplayTime) {
      this.currentText = null;
      this.lastTextDisplay = 0;
      return;
    }

    // display new text
    if (this.textIndex < this.currentText.length()
        && Game.time().since(this.lastCharPoll) > LETTER_WRITE_DELAY) {
      this.textIndex++;
      this.lastCharPoll = Game.time().now();
      if (this.typeSound != null) {
        Game.audio().playSound(this.typeSound, this.getEntity());
      }
    }

    // continue displaying currently displayed text
}private SpeechBubble(
      final IEntity entity,
      final String text,
      final Sound typeSound,
      SpeechBubbleAppearance appearance,
      Font font) {
    this(entity, text, appearance, font);
    this.typeSound = typeSound;
}private SpeechBubble(
      final IEntity entity,
      final String text,
      @Nullable SpeechBubbleAppearance appearance,
      @Nullable Font font) {
    if (appearance == null) {
      this.appearance = DEFAULT_APPEARANCE;
    } else {
      this.appearance = appearance;
    }

    final SpeechBubble active = activeSpeechBubbles.get(entity);
    if (active != null) {
      active.hide();
    }
    this.setFont(font);

    this.textBoxWidth = (float) (entity.getWidth() * 4);
    this.entity = entity;

    this.currentText = text;
    this.currentTextDisplayTime = DISPLAYTIME_MIN + text.length() * DISPLAYTIME_PER_LETTER;

    this.lastTextDisplay = Game.time().now();
    this.createBubbleImage();
    entity.getEnvironment().add(this, RenderType.UI);
    Game.loop().attach(this);
    activeSpeechBubbles.put(entity, this);
}
}
```
```java
class de.gurkenlabs.litiengine.gui.TextFieldComponent {
@Override
  public void render(final Graphics2D g) {
    super.render(g);
    g.setFont(this.getFont());
    final FontMetrics fm = g.getFontMetrics();

    if (this.isSelected() && Game.time().since(this.lastToggled) > this.flickerDelay) {
      this.cursorVisible = !this.cursorVisible;
      this.lastToggled = Game.time().now();
    }
    if (this.isSelected() && this.cursorVisible) {
      final Rectangle2D cursor =
          new Rectangle2D.Double(
              this.getX() + this.getTextX() + fm.stringWidth(this.getTextToRender(g)),
              this.getY() + this.getTextY(),
              this.getFont().getSize2D() * 3 / 5,
              this.getFont().getSize2D() * 1 / 5);
      g.setColor(this.getAppearance().getForeColor());
      g.fill(cursor);
    }
}
}
```
```java
class de.gurkenlabs.litiengine.entities.Prop {
public Prop(
      final Point2D location, @Nullable final String spritesheetName, final Material material) {
    super();
    this.rotation = Rotation.NONE;
    this.spritesheetName = spritesheetName;
    this.material = material;
    this.setLocation(location);
    this.updateAnimationController();
}public void setSpritesheetName(@Nullable final String spriteName) {
    this.spritesheetName = spriteName;
    this.updateAnimationController();
}
}
```
```java
class de.gurkenlabs.litiengine.tweening.Tween {
public Tween begin() {
    this.started = Game.time().now();
    this.stopped = false;
    return this;
}
}
```
```java
class de.gurkenlabs.litiengine.graphics.emitters.particles.Particle {
public void update(final Point2D emitterOrigin, final float updateRatio) {
    if (this.aliveTick == 0) {
      this.aliveTick = Game.time().now();
    }

    this.aliveTime = Game.time().since(this.aliveTick);
    if (this.timeToLiveReached()) {
      return;
    }

    if (this.colliding) {
      return;
    }

    if (this.getDeltaWidth() != 0) {
      this.width += this.getDeltaWidth() * updateRatio;
    }

    if (this.getDeltaHeight() != 0) {
      this.height += this.getDeltaHeight() * updateRatio;
    }

    if (this.getDeltaAngle() != 0) {
      this.angle += this.getDeltaAngle() * updateRatio;
    }

    // test for ray cast collision
    final float targetX = this.x + this.getVelocityX() * updateRatio;
    final float targetY = this.y + this.getVelocityY() * updateRatio;

    if (targetX == this.x && targetY == this.y) {
      return;
    }

    if (this.checkForCollision(emitterOrigin, targetX, targetY)) {
      return;
    }

    if (this.getVelocityX() != 0) {
      this.x = targetX;
    }

    if (this.getVelocityY() != 0) {
      this.y = targetY;
    }

    if (this.getAccelerationX() != 0) {
      this.velocityX += this.getAccelerationX() * updateRatio;
    }

    if (this.getAccelerationY() != 0) {
      this.velocityY += this.getAccelerationY() * updateRatio;
    }
}
}
```
```java
class de.gurkenlabs.litiengine.graphics.animation.Animation {
@Override
  public void start() {
    this.playing = true;
    if (this.getKeyframes().isEmpty()) {
      return;
    }

    this.restart();
}@Override
  public void update() {
    // do nothing if the animation is not playing or the current keyframe is not finished
    if (!this.isPlaying()
        || Game.time().since(this.lastFrameUpdate) < this.getCurrentKeyFrame().getDuration()) {
      return;
    }

    // if we are not looping and the last keyframe is finished, we terminate the animation
    if (!this.isLooping() && this.isLastKeyFrame()) {
      this.terminate();
      return;
    }

    // make sure, we stay inside the keyframe list
    final int newFrameIndex =
        (this.getKeyframes().indexOf(this.currentFrame) + 1) % this.getKeyframes().size();
    final KeyFrame previousFrame = this.currentFrame;
    this.currentFrame = this.getKeyframes().get(newFrameIndex);

    for (KeyFrameListener listener : this.listeners) {
      listener.currentFrameChanged(previousFrame, this.currentFrame);
    }

    this.lastFrameUpdate = Game.loop().getTicks();
}
}
```
```java
class de.gurkenlabs.litiengine.graphics.animation.AnimationController {
@Override
  public void update() {
    for (final Animation animation : this.getAll()) {
      animation.update();
    }

    if (this.getCurrent() != null && this.getCurrent().isPaused()) {
      return;
    }

    final boolean playbackFinished = this.getCurrent() != null && !this.getCurrent().isPlaying();
    if (playbackFinished) {
      for (final AnimationListener listener : this.listeners) {
        listener.finished(this.getCurrent());
      }
    }

    if (this.getCurrent() == null || playbackFinished) {
      if (this.getDefault() != null) {
        this.play(this.getDefault().getName());
      } else {
        this.currentAnimation = null;
      }
    }
}
}
```
```java
class de.gurkenlabs.litiengine.graphics.RenderComponent {
private void handleFade() {
    if (this.fadeOutStart != -1) {
      final long timePassed = Game.time().since(this.fadeOutStart);
      this.currentAlpha = MathUtilities.clamp(1 - timePassed / (float) this.fadeOutTime, 0, 1);
      if (this.currentAlpha == 0f) {
        this.fadeOutStart = -1;
        this.fadeOutTime = -1;
      }

      return;
    }

    if (this.fadeInStart != -1) {
      final long timePassed = Game.time().since(this.fadeInStart);
      this.currentAlpha = MathUtilities.clamp(timePassed / (float) this.fadeInTime, 0, 1);
      if (this.currentAlpha == 1f) {
        this.fadeInStart = -1;
        this.fadeInTime = -1;
        this.currentAlpha = Float.NaN;
      }
    }
}public void fadeOut(final int ms) {
    this.fadeInStart = -1;
    this.fadeInTime = -1;
    this.fadeOutStart = Game.time().now();
    this.fadeOutTime = ms;
}public void fadeIn(final int ms) {
    this.fadeOutStart = -1;
    this.fadeOutTime = -1;
    this.fadeInStart = Game.time().now();
    this.fadeInTime = ms;
}
}
```
```java
class de.gurkenlabs.litiengine.entities.Trigger {
private boolean activate(final IEntity activator, final int tar) {
    if (!this.isLoaded()
        || this.isOneTimeTrigger && this.isActivated
        || this.getActivationType() == TriggerActivation.COLLISION
            && activator != null
            && this.collisionActivated.contains(activator)) {
      return false;
    }

    if (this.getCooldown() > 0 && Game.time().since(this.lastActivation) < this.getCooldown()) {
      return false;
    }

    List<Integer> triggerTargets = this.getTargets(tar);

    final TriggerEvent te = new TriggerEvent(this, activator, triggerTargets);

    if (!this.checkActivationPredicates(te)) {
      return false;
    }

    this.isActivated = true;
    if (activator != null) {
      this.collisionActivated.add(activator);
    }

    // if we actually have a trigger target, we send the message to the target
    for (final int target : triggerTargets) {
      final IEntity entity = this.getEnvironment().get(target);
      if (entity == null) {
        log.log(
            Level.WARNING,
            "trigger [{0}] was activated, but the trigger target [{1}] could not be found on the environment",
            new Object[] {this, target});
        continue;
      }

      entity.sendMessage(this, this.message);
    }

    // also send the trigger event to all registered consumers
    for (final TriggerActivatedListener listener : this.activatedListeners) {
      listener.activated(te);
    }

    if (this.isOneTimeTrigger) {
      this.getEnvironment().remove(this);
    }

    this.lastActivation = Game.time().now();
    return true;
}
}
```
```java
class de.gurkenlabs.litiengine.graphics.Camera {
private boolean isShakeEffectActive() {
    return this.getShakeTick() != 0
        && Game.time().since(this.getShakeTick()) < this.getShakeDuration();
}@Override
  public void update() {
    if (Game.world().camera() != null && !Game.world().camera().equals(this)) {
      return;
    }

    if (this.targetZoom > 0) {
      if (Game.time().since(this.zoomTick) >= this.zoomDelay) {
        this.zoom = this.targetZoom;
        this.targetZoom = 0;
        this.zoomDelay = 0;
        this.zoomTick = 0;
        this.zoomStep = 0;
      } else {
        this.zoom += this.zoomStep;
      }

      final ZoomChangedEvent event = new ZoomChangedEvent(this, this.getZoom());
      for (final ZoomChangedListener listener : this.zoomListeners) {
        listener.zoomChanged(event);
      }
    }

    if (this.panTime > 0) {
      if (--this.panTime <= 0) {
        this.setFocus(this.targetFocus);
        this.targetFocus = null;
      } else {
        double diff = this.panTime / (this.panTime + 1.0);
        this.focus =
            new Point2D.Double(
                this.focus.getX() * diff + this.targetFocus.getX() * (1.0 - diff),
                this.focus.getY() * diff + this.targetFocus.getY() * (1.0 - diff));
      }
    }

    if (!this.isShakeEffectActive()) {
      this.shakeOffsetX = 0;
      this.shakeOffsetY = 0;
      return;
    }

    if (Game.time().since(this.lastShake) > this.shakeDelay) {
      this.shakeOffsetX = this.getShakeIntensity() * ThreadLocalRandom.current().nextGaussian();
      this.shakeOffsetY = this.getShakeIntensity() * ThreadLocalRandom.current().nextGaussian();
      this.lastShake = Game.time().now();
    }
}@Override
  public void setZoom(final float targetZoom, final int delay) {
    if (delay == 0) {

      this.zoom = targetZoom;
      this.targetZoom = 0;
      this.zoomDelay = 0;
      this.zoomTick = 0;
      this.zoomStep = 0;

      final ZoomChangedEvent event = new ZoomChangedEvent(this, targetZoom);
      for (final ZoomChangedListener listener : this.zoomListeners) {
        listener.zoomChanged(event);
      }
    } else {
      this.zoomTick = Game.time().now();
      this.targetZoom = targetZoom;
      this.zoomDelay = delay;

      final double tickduration = 1000 / (double) Game.loop().getTickRate();
      final double tickAmount = delay / tickduration;
      final float totalDelta = this.targetZoom - this.zoom;
      this.zoomStep = tickAmount > 0 ? (float) (totalDelta / tickAmount) : totalDelta;
    }
}@Override
  public void shake(final double intensity, final int delay, final int shakeDuration) {
    this.shakeTick = Game.time().now();
    this.shakeDelay = delay;
    this.shakeIntensity = intensity;
    this.shakeDuration = shakeDuration;
}
}
```
```java
class de.gurkenlabs.litiengine.entities.Creature {
public void setSpritesheetName(String spritesheetName) {
    if (this.spritesheetName != null && this.spritesheetName.equals(spritesheetName)) {
      return;
    }

    this.spritesheetName = spritesheetName;
    this.updateAnimationController();
}public boolean isIdle() {
    return Game.time().since(this.lastMoved) > IDLE_DELAY;
}@Override
  public void setLocation(final Point2D position) {
    if (this.isDead() || position == null) {
      return;
    }

    final Point2D oldLocation = this.getLocation();
    super.setLocation(position);

    if (Game.hasStarted() && this.isLoaded()) {
      this.lastMoved = Game.time().now();
      this.fireMovedEvent(
          new EntityMovedEvent(
              this, this.getX() - oldLocation.getX(), this.getY() - oldLocation.getY()));
    }
}
}
```
```java
class de.gurkenlabs.litiengine.gui.screens.ScreenManager {
public void display(final String screenName) {
    if (this.current() != null && this.current().getName().equalsIgnoreCase(screenName)) {
      log.log(
          Level.INFO,
          "Skipping displaying of screen {0} because it is already the current screen.",
          screenName);
      return;
    }

    if (this.screens.stream()
        .noneMatch(element -> element.getName().equalsIgnoreCase(screenName))) {
      log.log(
          Level.WARNING,
          "Could not display the screen {0} because there is no screen with the specified name.",
          screenName);
      return;
    }

    Screen screen = this.get(screenName);
    if (screen == null) {
      return;
    }

    this.display(screen);
}public void add(final Screen screen) {
    screen.setWidth(Game.window().getWidth());
    screen.setHeight(Game.window().getHeight());
    this.screens.add(screen);

    if (this.current() == null) {
      this.display(screen);
    }
}public void remove(Screen screen) {
    this.screens.remove(screen);
    if (this.current() == screen) {
      if (!this.screens.isEmpty()) {
        this.display(this.screens.get(0));
      } else {
        this.display((Screen) null);
      }
    }
}public void display(@Nullable final Screen screen) {
    if (Game.hasStarted() && Game.time().since(this.lastScreenChange) < this.getChangeCooldown()) {
      log.log(
          Level.INFO,
          "Skipping displaying of screen {0} because screen changing is currently on cooldown.",
          screen != null ? screen.getName() : "");
      return;
    }

    final Screen previous = this.current();
    if (previous != null) {
      previous.suspend();
    }

    if (screen != null && !this.screens.contains(screen)) {
      this.screens.add(screen);
    }

    this.currentScreen = screen;
    if (!Game.isInNoGUIMode() && this.current() != null) {
      this.current().prepare();
    }

    this.lastScreenChange = Game.loop().getTicks();

    final ScreenChangedEvent event = new ScreenChangedEvent(this.current(), previous);
    for (final ScreenChangedListener listener : this.screenChangedListeners) {
      listener.changed(event);
    }
}
}
```
```java
class de.gurkenlabs.litiengine.abilities.Ability {
public boolean isOnCooldown() {
    return (this.getCurrentExecution() != null
        && this.getCurrentExecution().getExecutionTicks() > 0
        && Game.time().since(this.getCurrentExecution().getExecutionTicks())
            < this.getAttributes().cooldown().get());
}public boolean isActive() {
    return this.getCurrentExecution() != null
        && Game.time().since(this.getCurrentExecution().getExecutionTicks())
            < this.getAttributes().duration().get();
}@Nullable
  public AbilityExecution cast() {
    if (!this.canCast()) {
      return null;
    }
    this.currentExecution = new AbilityExecution(this);

    for (final AbilityCastListener listener : this.abilityCastListeners) {
      listener.abilityCast(this.currentExecution);
    }

    return this.getCurrentExecution();
}public float getRemainingCooldownInSeconds() {
    if (this.getCurrentExecution() == null
        || this.getExecutor() == null
        || this.getExecutor().isDead()) {
      return 0;
    }

    // calculate cooldown in seconds
    return (float)
        (!this.canCast()
            ? (this.getAttributes().cooldown().get()
                    - Game.time().since(this.getCurrentExecution().getExecutionTicks()))
                * 0.001
            : 0);
}
}
```
```java
class de.gurkenlabs.litiengine.entities.EntityHitEvent {
EntityHitEvent(
      final ICombatEntity hitEntity,
      @Nullable final Ability ability,
      final int damage,
      final boolean kill) {
    super(hitEntity);
    this.executor = ability != null ? ability.getExecutor() : null;
    this.hitEntity = hitEntity;
    this.ability = ability;
    this.damage = damage;
    this.kill = kill;
    this.time = Game.time().now();
}
}
```
```java
class de.gurkenlabs.litiengine.graphics.emitters.Emitter {
public void delete() {
    this.deactivate();
    if (Game.world().environment() != null) {
      Game.world().environment().remove(this);
    }
}public void activate() {
    if (this.activated) {
      return;
    }

    this.activated = true;
    this.activationTick = Game.time().now();
    Game.loop().attach(this);
}@Override
  public void update() {
    if (this.isPaused()) {
      return;
    }

    // clear particles if the effect time to life is reached
    if (this.isFinished()) {
      for (EmitterFinishedListener listener : this.finishedListeners) {
        listener.finished(this);
      }

      this.delete();
      return;
    }

    final float updateRatio = (float) this.data().getUpdateRate() / Game.loop().getTickRate();
    for (final Particle p : this.getParticles().stream().collect(Collectors.toList())) {
      if (this.particleCanBeRemoved(p)) {
        // remove dead particles
        this.particles.remove(p);
        continue;
      }

      p.update(this.getOrigin(), updateRatio);
    }

    this.aliveTime = Game.time().since(this.activationTick);
    if ((this.data().getSpawnRate() == 0
        || Game.time().since(this.lastSpawn) >= this.data().getSpawnRate())) {
      this.lastSpawn = Game.time().now();
      this.spawnParticle();
    }
}
}
```
```java
class de.gurkenlabs.litiengine.GameLoop {
@Override
  public int perform(int delay, Runnable action) {
    final long d = Game.time().toTicks(delay);

    TimedAction a = new TimedAction(this.getTicks() + d, action);
    this.actions.add(a);

    return a.getId();
}
}
```
```java
class de.gurkenlabs.litiengine.environment.EntitySpawner {
protected boolean shouldSpawn() {
    return this.lastSpawnWave == 0
        || Game.time().since(this.lastSpawnWave) >= this.getSpawnInterval();
}@Override
  public void update() {
    if (!this.shouldSpawn()) {
      return;
    }

    this.spawnNewEntities();
    this.lastSpawnWave = Game.time().now();
}
}
```
```java
class de.gurkenlabs.litiengine.graphics.FreeFlightCamera {
@Override
  public void update() {
    this.handleFreeFlightCamera();
}public FreeFlightCamera(double x, double y) {
    this(new Point2D.Double(x, y));
}
}
```
```java
class de.gurkenlabs.litiengine.environment.Environment {
public void unload() {
    if (!this.loaded) {
      return;
    }

    // unregister all updatable entities from the current environment
    for (final IEntity entity : this.allEntities.values()) {
      this.unload(entity);
    }

    this.loaded = false;
    this.fireEvent(l -> l.unloaded(this));
}private static void loadUpdatableOrEmitterEntity(IEntity entity) {
    if (entity instanceof Emitter) {
      final Emitter emitter = (Emitter) entity;
      if (emitter.isActivateOnInit()) {
        emitter.activate();
      }
    } else if (entity instanceof IUpdateable) {
      Game.loop().attach((IUpdateable) entity);
    }
}public void clear() {
    Game.physics().clear();

    this.combatEntities.clear();
    this.mobileEntities.clear();
    this.gravityForces.clear();
    this.layerEntities.clear();
    this.entitiesByTag.clear();
    this.allEntities.clear();

    for (RenderType renderType : RenderType.values()) {
      this.miscEntities.get(renderType).clear();
      this.renderListeners.get(renderType).clear();
      this.renderables.get(renderType).clear();
    }

    dispose(this.allEntities.values());
    dispose(this.triggers);
    this.emitters.clear();
    this.colliders.clear();
    this.props.clear();
    this.creatures.clear();
    this.staticShadows.clear();
    this.combatEntities.clear();
    this.mobileEntities.clear();
    this.lightSources.clear();
    this.spawnPoints.clear();
    this.soundSources.clear();
    this.mapAreas.clear();
    this.triggers.clear();

    this.ambientLight = null;
    this.staticShadowLayer = null;

    for (Map<Integer, IEntity> type : this.miscEntities.values()) {
      type.clear();
    }

    this.initialized = false;

    this.fireEvent(l -> l.cleared(this));
}private void load(final IEntity entity) {
    // an entity can only exist on one environment at a time, so remove it from the current one
    if (entity.getEnvironment() != null) {
      entity.getEnvironment().remove(entity);
    }

    // 1. add to physics engine
    loadPhysicsEntity(entity);

    // 2. register for update or activate
    loadUpdatableOrEmitterEntity(entity);

    // 3. if a gravity is defined, add a gravity force to the entity
    if (entity instanceof IMobileEntity && this.getGravity() != 0) {
      this.addGravityForce((IMobileEntity) entity);
    }

    // 4. attach all controllers
    entity.attachControllers();

    if (this.loaded && (entity instanceof LightSource || entity instanceof StaticShadow)) {
      this.updateLighting(entity);
    }

    entity.loaded(this);
}private void unload(final IEntity entity) {
    // 1. remove from physics engine
    if (entity instanceof ICollisionEntity) {
      Game.physics().remove((ICollisionEntity) entity);
    }

    // 2. unregister from update
    if (entity instanceof IUpdateable) {
      Game.loop().detach((IUpdateable) entity);
    }

    if (entity instanceof IMobileEntity) {
      this.removeGravity((IMobileEntity) entity);
    }

    // 3. detach all controllers
    entity.detachControllers();

    if (entity instanceof Emitter) {
      Emitter em = (Emitter) entity;
      em.deactivate();
    }

    if (this.loaded && (entity instanceof LightSource || entity instanceof StaticShadow)) {
      this.updateLighting(entity);
    }

    entity.removed(this);
}public void remove(final IEntity entity) {
    if (entity == null) {
      return;
    }

    this.allEntities.remove(entity.getMapId());
    Iterator<List<IEntity>> iter = this.layerEntities.values().iterator();
    while (iter.hasNext()) {
      List<IEntity> layer = iter.next();
      if (layer.remove(entity) && layer.isEmpty()) {
        iter.remove();
      }
    }
    if (this.miscEntities.get(entity.getRenderType()) != null) {
      this.miscEntities.get(entity.getRenderType()).values().remove(entity);
    }

    for (String tag : entity.getTags()) {
      if (this.getEntitiesByTag().containsKey(tag)) {
        this.getEntitiesByTag().get(tag).remove(entity);

        if (this.getEntitiesByTag().get(tag).isEmpty()) {
          this.getEntitiesByTag().remove(tag);
        }
      }
    }

    if (entity instanceof Emitter) {
      Emitter emitter = (Emitter) entity;
      this.removeEmitter(emitter);
    }

    if (entity instanceof MapArea) {
      this.mapAreas.remove(entity);
    }

    if (entity instanceof Prop) {
      this.props.remove(entity);
    }

    if (entity instanceof Creature) {
      this.creatures.remove(entity);
    }

    if (entity instanceof CollisionBox) {
      this.colliders.remove(entity);
      this.staticShadows.removeIf(x -> x.getOrigin() != null && x.getOrigin().equals(entity));
    }

    if (entity instanceof LightSource) {
      this.lightSources.remove(entity);
      this.updateLighting(entity);
    }

    if (entity instanceof Trigger) {
      this.triggers.remove(entity);
    }

    if (entity instanceof Spawnpoint) {
      this.spawnPoints.remove(entity);
    }
    if (entity instanceof SoundSource) {
      this.soundSources.remove(entity);
    }

    if (entity instanceof StaticShadow) {
      this.staticShadows.remove(entity);
      this.updateLighting(entity);
    }

    if (entity instanceof IMobileEntity) {
      this.mobileEntities.values().remove(entity);
    }

    if (entity instanceof ICombatEntity) {
      this.combatEntities.values().remove(entity);
    }

    this.unload(entity);

    this.fireEntityEvent(l -> l.entityRemoved(entity));
}
}
```
```java
class de.gurkenlabs.litiengine.physics.MovementController {
@Override
  public void update() {
    this.handleForces();
    this.handleMovement();
}
}
```
```java
class de.gurkenlabs.litiengine.Game {
static synchronized void terminate() {
    if (!initialized) {
      return;
    }

    hasStarted = false;
    initialized = false;

    config().save();
    gameLoop.terminate();
    tweenEngine.terminate();
    soundEngine.terminate();

    world().clear();

    for (final GameListener listener : gameListeners) {
      try {
        listener.terminated();
      } catch (Exception e) {
        log().log(Level.WARNING, "game listener threw an exception during shutdown", e);
      }
    }

    gameLoop = null;
    screenManager = null;
    gameWindow = null;
}public static synchronized void start() {
    if (!initialized) {
      throw new IllegalStateException(
          "The game cannot be started without being first initialized. Call Game.init(...) before Game.start().");
    }

    gameLoop.start();
    tweenEngine.start();
    soundEngine.start();

    for (final GameListener listener : gameListeners) {
      listener.started();
    }

    hasStarted = true;
}public static synchronized void init(String... args) {
    if (initialized) {
      log().log(Level.INFO, "The game has already been initialized.");
      return;
    }

    log.init();
    handleCommandLineArguments(args);

    config().load();
    Locale.setDefault(new Locale(config().client().getCountry(), config().client().getLanguage()));

    gameLoop = new GameLoop("Main Update Loop", config().client().getMaxFps());
    loop().attach(physics());
    loop().attach(world());

    // setup default exception handling for render and update loop
    setUncaughtExceptionHandler(
        new DefaultUncaughtExceptionHandler(config().client().exitOnError()));

    screenManager = new ScreenManager();
    gameWindow = new GameWindow();

    // initialize  the game window
    window().init();
    world.setCamera(new Camera());

    for (GameListener listener : gameListeners) {
      listener.initialized(args);
    }

    if (!isInNoGUIMode()) {
      window().getRenderComponent().onRendered(g -> metrics().render(g));

      graphics()
          .addEntityRenderedListener(
              e -> DebugRenderer.renderEntityDebugInfo(e.getGraphics(), e.getEntity()));

      window().getRenderComponent().onFpsChanged(fps -> metrics().setFramesPerSecond(fps));
      window()
          .setIcons(
              Arrays.asList(
                  Resources.images().get("liti-logo-x16.png"),
                  Resources.images().get("liti-logo-x20.png"),
                  Resources.images().get("liti-logo-x32.png"),
                  Resources.images().get("liti-logo-x48.png")));

      Input.keyboard()
          .onKeyTyped(
              KeyEvent.VK_PRINTSCREEN,
              key -> {
                // don't take a screenshot if a modifier is active
                if (key.getModifiers() != 0) {
                  return;
                }

                window().getRenderComponent().takeScreenshot();
              });
    }

    Runtime.getRuntime().addShutdownHook(new Thread(Game::terminate, "Shutdown"));

    initialized = true;
}
}
```


Response Format:
Provide the answer in **XML format** as follows:

#### If the method **cannot** return `null` at the specific call site:
```xml
<response>
  <reason><![CDATA[EXPLAIN WHY THE INVOCATION Game.loop() RESULT CANNOT BE NULL.]]></reason>
  <value>NO</value>
</response>

#### If the method can return null at the specific call site:
<response>
  <reason><![CDATA[EXPLAIN WHY THE INVOCATION Game.loop() RESULT CAN BE NULL.]]></reason>
  <value>YES</value>
</response>

#### If you are unsure or If there are any methods that directly or indirectly affect the return value and are not fully disclosed, request their declarations first, in the following format:
<response>
  <reason><![CDATA[EXPLAIN WHY THIS METHOD DECLARATION IS NECESSARY AND WHY YOU CANNOT MAKE A CONFIDENT DECISION WITHOUT IT]]></reason>
  <success>false</success>
  <methods>
    <method>methodName</method>
  </methods>
</response>

Additional Notes:
Be precise in your reasoning.
If a method’s return value depends on another method not provided, request its declaration before making a conclusion.
If the method can return null in this case but not in others, explain why it happens specifically for this call.

---ChatGPT.sendRequestToOpenAI---
Retrieving response from cache
---Response.<init>---
Creating Response:
```xml
<response>
  <reason><![CDATA[The method `Game.loop()` returns the static field `gameLoop`, which is initialized in the `Game.init(String... args)` method. In this method, a new `GameLoop` object is instantiated and assigned to `gameLoop`. Since `init()` must be called before `start()`, which is implied by the requirement of initializing the game, the `gameLoop` is guaranteed to be non-null during the lifetime of the game execution where `Game.loop()` is called. The absence of any code that could set `gameLoop` to null after its initialization ensures that `Game.loop()` cannot return null.]]></reason>
  <value>NO</value>
</response>
```
---Response.<init>---
Response created:
Disagreement: The method `Game.loop()` returns the static field `gameLoop`, which is initialized in the `Game.init(String... args)` method. In this method, a new `GameLoop` object is instantiated and assigned to `gameLoop`. Since `init()` must be called before `start()`, which is implied by the requirement of initializing the game, the `gameLoop` is guaranteed to be non-null during the lifetime of the game execution where `Game.loop()` is called. The absence of any code that could set `gameLoop` to null after its initialization ensures that `Game.loop()` cannot return null.
---AdvancedNullAwayCodeFix.resolveMethodDereferenceError---
Method is not returning nullable on call site. Injecting suppression annotation.
---AdvancedNullAwayCodeFix.constructCastToNonnullChange---
Constructing cast to nonnull change for reason: The method `Game.loop()` returns the static field `gameLoop`, which is initialized in the `Game.init(String... args)` method. In this method, a new `GameLoop` object is instantiated and assigned to `gameLoop`. Since `init()` must be called before `start()`, which is implied by the requirement of initializing the game, the `gameLoop` is guaranteed to be non-null during the lifetime of the game execution where `Game.loop()` is called. The absence of any code that could set `gameLoop` to null after its initialization ensures that `Game.loop()` cannot return null.
---ChatGPT.ask---
Asking ChatGPT:
For the reason you mentioned earlier:

"The method `Game.loop()` returns the static field `gameLoop`, which is initialized in the `Game.init(String... args)` method. In this method, a new `GameLoop` object is instantiated and assigned to `gameLoop`. Since `init()` must be called before `start()`, which is implied by the requirement of initializing the game, the `gameLoop` is guaranteed to be non-null during the lifetime of the game execution where `Game.loop()` is called. The absence of any code that could set `gameLoop` to null after its initialization ensures that `Game.loop()` cannot return null."

in the method below, the expression Game.loop() is not nullable at the point it is used.

```java
public void setCamera(@Nullable final ICamera cam) {
    if (this.camera() != null) {
      Game.loop().detach(camera);
    }

    camera = cam;

    if (cam != null && !Game.isInNoGUIMode()) {
      Game.loop().attach(cam);
      cam.updateFocus();
    }
}
```
Please Summarize the reason in max 5 words and rewrite the method so that at the line "      Game.loop().attach(cam);", at the occurrence of: "Game.loop()" is replaced with `NullabilityUtil.castToNonnull(Game.loop(), summary of reason)`
Replace "REASON" with the exact reason summary I provide to you (maximum 5 words), not with a generic explanation like "checked to be nonnull".
see the example below, for expression `foo.getBar()`, to wrap it with `NullabilityUtil.castToNonnull(foo.getBar(), "reason")`.

```java
public t(){
    String l = foo.getBar();
}
```

will be:
```java
public t(){
    String l = NullabilityUtil.castToNonnull(foo.getBar(), "checked to be nonnull");
}
```

### Instructions:

Do not import any additional classes.

Do not add Java comments.

Only modify relevant lines as required.

Return only the modified method wrapped in the XML format shown below.

Place the Java code inside the <code> tag using a CDATA block with ```java formatting.

Just give me the fixed code snippet in XML format in <response> tag like the example below. I will apply the fix to my codebase. Do not import any additional libraries or classes or add java comments. If you can provide the fixed code snippet, please provide it in the following format and place the code snippet in the <code> tag within ```java block.
<response>
  <success>true</success>
  <code><![CDATA[
  ```java
  Your fixed code snippet here
  ```
    ]]>
  </code>
</response>

---ChatGPT.sendRequestToOpenAI---
Retrieving response from cache
---Response.<init>---
Creating Response:
```xml
<response>
  <success>true</success>
  <code><![CDATA[
  ```java
public void setCamera( final ICamera cam) {
    if (this.camera() != null) {
      Game.loop().detach(camera);
    }

    camera = cam;

    if (cam != null && !Game.isInNoGUIMode()) {
      NullabilityUtil.castToNonnull(Game.loop(), "guaranteed non-null post-init").attach(cam);
      cam.updateFocus();
    }
}
  ```
  ]]>
  </code>
</response>
```
---Response.<init>---
Response created:
public void setCamera( final ICamera cam) {
    if (this.camera() != null) {
      Game.loop().detach(camera);
    }

    camera = cam;

    if (cam != null && !Game.isInNoGUIMode()) {
      NullabilityUtil.castToNonnull(Game.loop(), "guaranteed non-null post-init").attach(cam);
      cam.updateFocus();
    }
}
---ChatGPT.fixDereferenceByAddingCastToNonnull---
Fixing the error by adding castToNonnull
---AdvancedNullAwayCodeFix.fixTriggeredErrorsForLocation---
Resolving unresolvable error for triggered error: Type='DEREFERENCE_NULLABLE', message='dereferenced expression Game.loop() is @Nullable'
/home/nima/Developer/nullness-benchmarks/litiengine/src/de/gurkenlabs/litiengine/GameTime.java:32
    return Game.loop().getTicks();
---AdvancedNullAwayCodeFix.fix---
Fixing error: Type='DEREFERENCE_NULLABLE', message='dereferenced expression Game.loop() is @Nullable'
/home/nima/Developer/nullness-benchmarks/litiengine/src/de/gurkenlabs/litiengine/GameTime.java:32
    return Game.loop().getTicks();
---AdvancedNullAwayCodeFix.resolveDereferenceError---
Resolving dereference error: Type='DEREFERENCE_NULLABLE', message='dereferenced expression Game.loop() is @Nullable'
/home/nima/Developer/nullness-benchmarks/litiengine/src/de/gurkenlabs/litiengine/GameTime.java:32
    return Game.loop().getTicks();
---AdvancedNullAwayCodeFix.resolveDereferenceError---
Checking nullability possibility at error point
---ChatGPT.checkNullabilityPossibilityAtErrorPoint---
Asking if the expression can be null at error point point
---ChatGPT.ask---
Asking ChatGPT:
In the method below, is there a possibility that the expression "Game.loop()" at line "return Game.loop().getTicks();" is null?
public long now() {
    return Game.loop().getTicks();
}
Give a single-word answer in XML format. If it is possible for the expression to be null, respond with:
```xml
<response>
    <reason><![CDATA[YOUR REASON]]></reason>
    <value>YES</value>
</response>
```
If it is not possible for the expression to be null, respond with:
```xml
<response>
    <reason><![CDATA[YOUR REASON]]></reason>
    <value>NO</value>
</response>
```
If you are unsure or need more information, respond with where you can ask for more details or what specific information you need.

If additional information is required, list each request inside a `<request>` tag. If no additional information is needed, omit the `<requests>` section.

Respond with:
```xml
<response>
    <reason><![CDATA[YOUR REASON]]></reason>
    <value>UNKNOWN</value>
    <!-- Include <requests> only if additional information is needed -->
    <requests>
        <request><![CDATA[YOUR REQUEST 1]]></request>
        <request><![CDATA[YOUR REQUEST 2]]></request>
    </requests>
</response>
```
---ChatGPT.sendRequestToOpenAI---
Retrieving response from cache
---Response.<init>---
Creating Response:
```xml
<response>
    <reason><![CDATA[The method "Game.loop()" could return null if there is no explicit guarantee or contract in the code that it always returns a non-null value. Without information about its implementation or documentation, it cannot be concluded definitively.]]></reason>
    <value>UNKNOWN</value>
    <requests>
        <request><![CDATA[Provide the implementation of or documentation for the "Game.loop()" method.]]></request>
    </requests>
</response>
```
---Response.<init>---
Response created:
Unknown: The method "Game.loop()" could return null if there is no explicit guarantee or contract in the code that it always returns a non-null value. Without information about its implementation or documentation, it cannot be concluded definitively.
---AdvancedNullAwayCodeFix.resolveMethodDereferenceError---
Resolving method dereference error.
---AdvancedNullAwayCodeFix.resolveMethodDereferenceError---
Method is in annotated package. Checking if the method is returning nullable.
---AdvancedNullAwayCodeFix.investigateMethodReturnNullability---
Checking if the method is returning nullable.
---ChatGPT.checkIfMethodIsReturningNullable---
Asking if the method is returning nullable: loop()
---ChatGPT.ask---
Asking ChatGPT:
In the method below, is there a possibility that the method returns null based only on its body? Consider the following points:

- The method may have multiple return paths; consider all return statements.
- If the method calls another method, do not assume its return value unless its full declaration is provided. Request its declaration if needed.
- The method may throw an exception instead of returning null. An exception path should not be considered a null return.
- Ensure you request the declarations of any methods whose return values directly or indirectly impact this method’s return value before making a conclusion.
- Carefully analyze all conditions and prior operations that may guarantee a non-null return value.

@Nullable public static IGameLoop loop() {
    return gameLoop;
}

Here are the method definitions in addition to the method inquired:

Depth: 0
```java
class de.gurkenlabs.litiengine.Game {
@Nullable public static IGameLoop loop() {
    return gameLoop;
}
}
```


Response Format:
Provide the answer in **XML format** as follows:

#### If the method **cannot** return `null`:
```xml
<response>
  <reason><![CDATA[EXPLAIN WHY THE METHOD CANNOT RETURN NULL]]></reason>
  <value>NO</value>
</response>
```

#### If the method can return null:
```xml
<response>
  <reason><![CDATA[EXPLAIN WHY THE METHOD CAN RETURN NULL]]></reason>
  <value>YES</value>
</response>
```

#### If you are unsure or need more information, respond with where you can ask for more details or what specific information you need.

#### If you are unsure or If there are any methods that directly or indirectly affect the return value and are not fully disclosed, request their declarations first, in the following format:
<response>
  <reason><![CDATA[YOUR REASON]]></reason>
  <value>UNKNOWN</value>
  <methods>
    <method>methodName</method>
  </methods>
</response>

If additional information is required other than method declaration, list each request inside a `<request>` tag. If no additional information is needed, omit the `<requests>` section.

Respond with:
```xml
<response>
    <reason><![CDATA[YOUR REASON]]></reason>
    <value>UNKNOWN</value>
    <!-- Include <requests> only if additional information is needed -->
    <requests>
        <request><![CDATA[YOUR REQUEST 1]]></request>
        <request><![CDATA[YOUR REQUEST 2]]></request>
    </requests>
</response>
```

Additional Notes:
Be precise in your reasoning.
If a method’s return value depends on another method not provided, request its declaration before making a conclusion.
If the method can return null in some cases but not others, explain under what conditions it can happen.

---ChatGPT.sendRequestToOpenAI---
Retrieving response from cache
---Response.<init>---
Creating Response:
```xml
<response>
  <reason><![CDATA[The method `loop` returns the variable `gameLoop`. Without the initialization or assignment details of `gameLoop`, it's unclear whether it can be null. The possibility of `gameLoop` being uninitialized or set to null elsewhere in the program means `loop` could potentially return null. Further information on `gameLoop` is required.]]></reason>
  <value>UNKNOWN</value>
  <requests>
    <request><![CDATA[Please provide the declaration and initialization of the variable `gameLoop` in the class `de.gurkenlabs.litiengine.Game`.]]></request>
  </requests>
</response>
```
---Response.<init>---
Response created:
Unknown: The method `loop` returns the variable `gameLoop`. Without the initialization or assignment details of `gameLoop`, it's unclear whether it can be null. The possibility of `gameLoop` being uninitialized or set to null elsewhere in the program means `loop` could potentially return null. Further information on `gameLoop` is required.
---AdvancedNullAwayCodeFix.investigateMethodReturnNullability---
Could not determine the nullability and model did not ask for any method.
---ChatGPT.checkIfMethodIsReturningNullableOnCallSite---
Asking if the method is returning nullable on the call site: Game.loop()
---ChatGPT.ask---
Asking ChatGPT:
In the method below, is there a possibility that the method returns null at the given call site?

```java
@Nullable public static IGameLoop loop() {
    return gameLoop;
}
```

## Guidelines:
- The method may have multiple return paths; consider all return statements.
- If the method calls another method, do not assume its return value unless its full declaration is provided. Request its declaration if needed.
- The method may throw an exception instead of returning null. An exception path should not be considered a null return.
- Ensure you request the declarations of any methods whose return values directly or indirectly impact this method’s return value before making a conclusion.
- If the method returns a value that is determined by a parameter, evaluate based on the actual argument at the given call site.
- Analyze based only on the specific invocation provided. Do not generalize to all possible inputs.- If the return value is guaranteed to be non-null at the call site, the answer should be a definitive NO.
- Do not generalize based on all possible inputs—your answer must be based only on the given invocation.
- Focus only on the given call site, not all possible invocations.

### call site:
Game.loop()

Here are the method definitions and the call chain for this method, showing the sequence of calls from the method to its callers at each depth level:

Depth: 0
```java
class de.gurkenlabs.litiengine.Game {
@Nullable public static IGameLoop loop() {
    return gameLoop;
}
}
```
Depth: 1
```java
class de.gurkenlabs.litiengine.environment.GameWorld {
public void loadEnvironment(@Nullable final Environment env) {
    Lock lock = Game.loop().getLock();
    lock.lock();
    try {
      unloadEnvironment();
      this.environment = env;
      if (env != null) {
        this.addEnvironment(env);

        if (env.getGravity() == 0 && this.gravity() != 0) {
          env.setGravity(this.gravity());
        }

        env.load();
        for (final EnvironmentLoadedListener listener : this.loadedListeners) {
          listener.loaded(env);
        }

        // call map specific listeners
        String mapName = getMapName(env);
        if (mapName != null && this.environmentLoadedListeners.containsKey(mapName)) {

          // for the default camera we center the camera on the environment
          if (this.camera().getClass().equals(Camera.class)) {
            camera().setFocus(env.getCenter());
          }

          for (EnvironmentLoadedListener listener : this.environmentLoadedListeners.get(mapName)) {
            listener.loaded(env);
          }
        }
      }
    } finally {
      lock.unlock();
    }
}public void setCamera(@Nullable final ICamera cam) {
    if (this.camera() != null) {
      Game.loop().detach(camera);
    }

    camera = cam;

    if (cam != null && !Game.isInNoGUIMode()) {
      Game.loop().attach(cam);
      cam.updateFocus();
    }
}
}
```
```java
class de.gurkenlabs.litiengine.entities.behavior.EntityNavigator {
public EntityNavigator(final IMobileEntity entity, final PathFinder pathFinder) {
    this.cancelNavigationConditions = new CopyOnWriteArrayList<>();
    this.listeners = new CopyOnWriteArrayList<>();
    this.entity = entity;
    this.pathFinder = pathFinder;
    this.setAcceptableError(DEFAULT_ACCEPTABLE_ERROR);
    Game.loop().attach(this);
}
}
```
```java
class de.gurkenlabs.litiengine.GameWindow {
private static void initializeWindowEventListeners(Window window) {

    window.addWindowStateListener(
        e -> {
          if (e.getNewState() == Frame.ICONIFIED) {
            Game.loop().setTickRate(ICONIFIED_MAX_FPS);
          } else {
            Game.loop().setTickRate(Game.config().client().getMaxFps());
          }
        });

    window.addWindowFocusListener(
        new WindowFocusListener() {
          @Override
          public void windowLostFocus(WindowEvent e) {
            if (Game.config().graphics().reduceFramesWhenNotFocused()) {
              Game.loop().setTickRate(NONE_FOCUS_MAX_FPS);
            }
          }

          @Override
          public void windowGainedFocus(WindowEvent e) {
            Game.loop().setTickRate(Game.config().client().getMaxFps());
          }
        });

    window.addWindowListener(
        new WindowAdapter() {
          @Override
          public void windowClosing(final WindowEvent event) {
            Game.exit();
          }
        });
}
}
```
```java
class de.gurkenlabs.litiengine.gui.screens.ScreenManager {
public void display(@Nullable final Screen screen) {
    if (Game.hasStarted() && Game.time().since(this.lastScreenChange) < this.getChangeCooldown()) {
      log.log(
          Level.INFO,
          "Skipping displaying of screen {0} because screen changing is currently on cooldown.",
          screen != null ? screen.getName() : "");
      return;
    }

    final Screen previous = this.current();
    if (previous != null) {
      previous.suspend();
    }

    if (screen != null && !this.screens.contains(screen)) {
      this.screens.add(screen);
    }

    this.currentScreen = screen;
    if (!Game.isInNoGUIMode() && this.current() != null) {
      this.current().prepare();
    }

    this.lastScreenChange = Game.loop().getTicks();

    final ScreenChangedEvent event = new ScreenChangedEvent(this.current(), previous);
    for (final ScreenChangedListener listener : this.screenChangedListeners) {
      listener.changed(event);
    }
}
}
```
```java
class de.gurkenlabs.litiengine.abilities.effects.Effect {
@Override
  public void update() {

    for (final Iterator<EffectApplication> iterator = this.getActiveAppliances().iterator();
        iterator.hasNext(); ) {
      final EffectApplication appliance = iterator.next();
      // if the effect duration is reached
      if (this.hasEnded(appliance)) {

        iterator.remove();
        this.cease(appliance);
      }
    }

    // 4. unregister if all appliances are finished
    if (this.getActiveAppliances().isEmpty()) {
      Game.loop().detach(this);
    }
}public void apply(final Shape impactArea) {
    final List<ICombatEntity> affected = this.lookForAffectedEntities(impactArea);
    for (final ICombatEntity affectedEntity : affected) {
      this.apply(affectedEntity);
    }

    this.appliances.add(new EffectApplication(affected, impactArea));

    // if it is the first appliance -> register for update
    if (this.appliances.size() == 1) {
      Game.loop().attach(this);
    }
}
}
```
```java
class de.gurkenlabs.litiengine.GameTime {
public long toTicks(final int milliseconds) {
    return this.toTicks(milliseconds, Game.loop().getTickRate());
}public long since(final long tick) {
    return toMilliseconds(Game.loop().getTicks() - tick);
}public long now() {
    return Game.loop().getTicks();
}public long sinceGameStart() {
    return this.toMilliseconds(Game.loop().getTicks());
}@Override
  public void loaded(Environment environment) {
    environmentLoaded = Game.loop().getTicks();
}public long toMilliseconds(final long ticks) {
    return this.toMilliseconds(ticks, Game.loop().getTickRate());
}
}
```
```java
class de.gurkenlabs.litiengine.GameMetrics {
@Override
  public void render(final Graphics2D g) {
    this.updateMetrics();

    if (!Game.config().client().showGameMetrics()) {
      return;
    }

    this.currentOffsetY = 0;

    g.setColor(this.renderColor);

    // render client metrics
    this.drawTitle(g, "[client]");
    this.drawMetric(g, "fps       : " + this.getFramesPerSecond());
    this.drawMetric(g, "max fps   : " + this.maxFramesPerSecond);
    this.drawMetric(g, "updatables: " + Game.loop().getUpdatableCount());

    // render jvm metrics if debug is enabled
    if (Game.config().debug().isDebugEnabled()) {
      this.drawTitle(g, "[jvm]");
      this.drawMetric(g, "java      : " + this.javaVersion);
      this.drawMetric(g, "memory    : " + String.format("%-5.5s", this.usedMemory) + " MB");
      this.drawMetric(g, "threads   : " + Thread.activeCount());
    }

    // render rendering metrics
    if (!this.renderMetrics.isEmpty()) {
      this.drawTitle(g, "[update]");

      for (RenderMetrics metric : this.renderMetrics) {
        this.drawMetric(g, metric.toString());
      }

      this.renderMetrics.clear();
    }
}
}
```
```java
class de.gurkenlabs.litiengine.graphics.emitters.Emitter {
public void deactivate() {
    if (!this.activated) {
      return;
    }

    this.activated = false;
    this.getParticles().clear();
    this.aliveTime = 0;
    this.activationTick = 0;
    this.lastSpawn = 0;
    Game.loop().detach(this);
}public void activate() {
    if (this.activated) {
      return;
    }

    this.activated = true;
    this.activationTick = Game.time().now();
    Game.loop().attach(this);
}@Override
  public void update() {
    if (this.isPaused()) {
      return;
    }

    // clear particles if the effect time to life is reached
    if (this.isFinished()) {
      for (EmitterFinishedListener listener : this.finishedListeners) {
        listener.finished(this);
      }

      this.delete();
      return;
    }

    final float updateRatio = (float) this.data().getUpdateRate() / Game.loop().getTickRate();
    for (final Particle p : this.getParticles().stream().collect(Collectors.toList())) {
      if (this.particleCanBeRemoved(p)) {
        // remove dead particles
        this.particles.remove(p);
        continue;
      }

      p.update(this.getOrigin(), updateRatio);
    }

    this.aliveTime = Game.time().since(this.activationTick);
    if ((this.data().getSpawnRate() == 0
        || Game.time().since(this.lastSpawn) >= this.data().getSpawnRate())) {
      this.lastSpawn = Game.time().now();
      this.spawnParticle();
    }
}
}
```
```java
class de.gurkenlabs.litiengine.entities.behavior.IBehaviorController {
public default void attach() {
    Game.loop().attach(this);
}public default void detach() {
    Game.loop().detach(this);
}
}
```
```java
class de.gurkenlabs.litiengine.abilities.AbilityExecution {
AbilityExecution(final Ability ability) {
    this.appliedEffects = new CopyOnWriteArrayList<>();
    this.ability = ability;
    this.executionTicks = Game.time().now();
    this.impactArea = ability.calculateImpactArea();
    this.castLocation = ability.getExecutor().getCenter();
    Game.loop().attach(this);
}@Override
  public void update() {
    // if there a no effects to apply -> unregister this instance and we're done
    if (this.getAbility().getEffects().isEmpty()
        || this.getAbility().getEffects().size() == this.getAppliedEffects().size()) {
      Game.loop().detach(this);
      return;
    }

    // handle all effects from the ability that were not applied yet
    for (final Effect effect : this.getAbility().getEffects()) {
      // if the ability was not executed yet or the delay of the effect is not
      // yet reached
      if (this.getAppliedEffects().contains(effect)
          || Game.time().since(this.getExecutionTicks()) < effect.getDelay()) {
        continue;
      }

      effect.apply(this.getExecutionImpactArea());
      this.getAppliedEffects().add(effect);
    }
}
}
```
```java
class de.gurkenlabs.litiengine.GameWindow$3 {
@Override
          public void windowGainedFocus(WindowEvent e) {
            Game.loop().setTickRate(Game.config().client().getMaxFps());
}@Override
          public void windowLostFocus(WindowEvent e) {
            if (Game.config().graphics().reduceFramesWhenNotFocused()) {
              Game.loop().setTickRate(NONE_FOCUS_MAX_FPS);
            }
}
}
```
```java
class de.gurkenlabs.litiengine.environment.EntitySpawner {
protected void spawnNewEntities() {
    if (this.getSpawnMode() != SpawnMode.CUSTOMSPAWNPOINTS && this.getSpawnPoints().isEmpty()) {
      return;
    }

    switch (this.getSpawnMode()) {
      case ALLSPAWNPOINTS:
        for (int i = 0; i < this.getSpawnPoints().size(); i++) {
          final int index = i;
          Game.loop()
              .perform(
                  this.getSpawnDelay() + this.getSpawnDelay() * i,
                  () -> this.spawn(this.getSpawnPoints().get(index), this.getSpawnAmount()));
        }
        break;
      case ONERANDOMSPAWNPOINT:
        this.spawn(Game.random().choose(this.getSpawnPoints()), this.getSpawnAmount());
        break;
      case RANDOMSPAWNPOINTS:
        for (int i = 0; i < this.getSpawnAmount(); i++) {
          Game.loop()
              .perform(
                  this.getSpawnDelay() + this.getSpawnDelay() * i,
                  () -> this.spawn(Game.random().choose(this.getSpawnPoints()), 1));
        }
        break;
      case CUSTOMSPAWNPOINTS:
        List<Spawnpoint> spawnPoints =
            this.customSpawnpoints != null
                ? this.customSpawnpoints.apply(this)
                : this.getCustomSpawnpoints();

        int index = 0;
        for (Spawnpoint spawn : spawnPoints) {
          Game.loop()
              .perform(
                  this.getSpawnDelay() + this.getSpawnDelay() * index, () -> this.spawn(spawn, 1));
          index++;
        }
        break;
      default:
        break;
    }
}
}
```
```java
class de.gurkenlabs.litiengine.tweening.TweenEngine {
@Override
  public void start() {
    Game.loop().attach(this);
}@Override
  public void terminate() {
    Game.loop().detach(this);
}
}
```
```java
class de.gurkenlabs.litiengine.gui.SpeechBubble {
public void hide() {
    Game.world().environment().removeRenderable(this);
    Game.loop().detach(this);
    if (activeSpeechBubbles.get(this.getEntity()) != null
        && activeSpeechBubbles.remove(this.getEntity()).equals(this)) {
      activeSpeechBubbles.remove(this.getEntity());
    }

    for (SpeechBubbleListener listener : this.listeners) {
      listener.hidden();
    }
}private SpeechBubble(
      final IEntity entity,
      final String text,
      @Nullable SpeechBubbleAppearance appearance,
      @Nullable Font font) {
    if (appearance == null) {
      this.appearance = DEFAULT_APPEARANCE;
    } else {
      this.appearance = appearance;
    }

    final SpeechBubble active = activeSpeechBubbles.get(entity);
    if (active != null) {
      active.hide();
    }
    this.setFont(font);

    this.textBoxWidth = (float) (entity.getWidth() * 4);
    this.entity = entity;

    this.currentText = text;
    this.currentTextDisplayTime = DISPLAYTIME_MIN + text.length() * DISPLAYTIME_PER_LETTER;

    this.lastTextDisplay = Game.time().now();
    this.createBubbleImage();
    entity.getEnvironment().add(this, RenderType.UI);
    Game.loop().attach(this);
    activeSpeechBubbles.put(entity, this);
}
}
```
```java
class de.gurkenlabs.litiengine.entities.Prop {
private void updateAnimationController() {
    IEntityAnimationController<?> controller = this.createAnimationController();
    this.getControllers().addController(controller);
    if (Game.world().environment() != null && Game.world().environment().isLoaded()) {
      Game.loop().attach(controller);
    }
}
}
```
```java
class de.gurkenlabs.litiengine.graphics.FreeFlightCamera {
public FreeFlightCamera(final Point2D focus) {
    this.setFocus(focus);
    this.velocity = DEFAULT_SCROLL_PIXELS_PER_SECOND;
    this.scrollPadding = DEFAULT_SCROLL_PADDING;
    this.setClampToMap(true);

    Game.loop().attach(this);
}private void handleFreeFlightCamera() {
    if (Game.world().environment() == null || Game.world().environment().getMap() == null) {
      return;
    }

    final Point2D mouseLocation = Input.mouse().getLocation();

    final double scrollSpeed =
        this.getVelocity()
            / (double) Game.loop().getTickRate()
            * Game.config().input().getMouseSensitivity();

    double x = this.getFocus().getX();
    double y = this.getFocus().getY();

    double deltaX = 0;
    if (mouseLocation.getX() < this.getScrollPadding()) {
      deltaX -= scrollSpeed;
    } else if (Game.window().getResolution().getWidth() - mouseLocation.getX()
        < this.getScrollPadding()) {
      deltaX += scrollSpeed;
    }

    double deltaY = 0;
    if (mouseLocation.getY() < this.getScrollPadding()) {
      deltaY -= scrollSpeed;
    } else if (Game.window().getResolution().getHeight() - mouseLocation.getY()
        < this.getScrollPadding()) {
      deltaY += scrollSpeed;
    }

    x += deltaX;
    y += deltaY;

    this.setFocus(new Point2D.Double(x, y));
}
}
```
```java
class de.gurkenlabs.litiengine.environment.Environment {
private static void dispose(final Collection<? extends IEntity> entities) {
    for (final IEntity entity : entities) {
      if (entity instanceof IUpdateable) {
        Game.loop().detach((IUpdateable) entity);
      }

      entity.detachControllers();
    }
}private static void loadUpdatableOrEmitterEntity(IEntity entity) {
    if (entity instanceof Emitter) {
      final Emitter emitter = (Emitter) entity;
      if (emitter.isActivateOnInit()) {
        emitter.activate();
      }
    } else if (entity instanceof IUpdateable) {
      Game.loop().attach((IUpdateable) entity);
    }
}private void unload(final IEntity entity) {
    // 1. remove from physics engine
    if (entity instanceof ICollisionEntity) {
      Game.physics().remove((ICollisionEntity) entity);
    }

    // 2. unregister from update
    if (entity instanceof IUpdateable) {
      Game.loop().detach((IUpdateable) entity);
    }

    if (entity instanceof IMobileEntity) {
      this.removeGravity((IMobileEntity) entity);
    }

    // 3. detach all controllers
    entity.detachControllers();

    if (entity instanceof Emitter) {
      Emitter em = (Emitter) entity;
      em.deactivate();
    }

    if (this.loaded && (entity instanceof LightSource || entity instanceof StaticShadow)) {
      this.updateLighting(entity);
    }

    entity.removed(this);
}
}
```
```java
class de.gurkenlabs.litiengine.graphics.animation.Animation {
@Override
  public void update() {
    // do nothing if the animation is not playing or the current keyframe is not finished
    if (!this.isPlaying()
        || Game.time().since(this.lastFrameUpdate) < this.getCurrentKeyFrame().getDuration()) {
      return;
    }

    // if we are not looping and the last keyframe is finished, we terminate the animation
    if (!this.isLooping() && this.isLastKeyFrame()) {
      this.terminate();
      return;
    }

    // make sure, we stay inside the keyframe list
    final int newFrameIndex =
        (this.getKeyframes().indexOf(this.currentFrame) + 1) % this.getKeyframes().size();
    final KeyFrame previousFrame = this.currentFrame;
    this.currentFrame = this.getKeyframes().get(newFrameIndex);

    for (KeyFrameListener listener : this.listeners) {
      listener.currentFrameChanged(previousFrame, this.currentFrame);
    }

    this.lastFrameUpdate = Game.loop().getTicks();
}public void restart() {
    this.currentFrame = this.firstFrame;
    this.lastFrameUpdate = Game.loop().getTicks();
}
}
```
```java
class de.gurkenlabs.litiengine.physics.MovementController {
@Override
  public void attach() {
    Game.loop().attach(this);
}private void handleForces() {
    // clean up forces
    this.activeForces.forEach(
        x -> {
          if (x.hasEnded()) {
            this.activeForces.remove(x);
          }
        });

    if (this.activeForces.isEmpty()) {
      return;
    }

    // disable turn-on-move for force handling
    boolean turn = this.getEntity().turnOnMove();
    this.getEntity().setTurnOnMove(false);
    try {
      double deltaX = 0;
      double deltaY = 0;
      for (final Force force : this.activeForces) {
        if (force.cancelOnReached() && force.hasReached(this.getEntity())) {
          force.end();
          continue;
        }

        final Point2D collisionBoxCenter = this.getEntity().getCollisionBoxCenter();
        final double angle =
            GeometricUtilities.calcRotationAngleInDegrees(collisionBoxCenter, force.getLocation());
        final double strength =
            Game.loop().getDeltaTime() * 0.001f * force.getStrength() * Game.loop().getTimeScale();
        deltaX += GeometricUtilities.getDeltaX(angle, strength);
        deltaY += GeometricUtilities.getDeltaY(angle, strength);
      }

      final Point2D target =
          new Point2D.Double(this.getEntity().getX() + deltaX, this.getEntity().getY() + deltaY);
      final boolean success = Game.physics().move(this.getEntity(), target);
      if (!success) {
        for (final Force force : this.activeForces) {
          if (force.cancelOnCollision()) {
            force.end();
          }
        }
      }
    } finally {
      this.getEntity().setTurnOnMove(turn);
    }
}@Override
  public void detach() {
    Game.loop().detach(this);
}public void handleMovement() {
    if (!this.isMovementAllowed()) {
      this.velocity = 0;
      return;
    }

    // max distance an entity can travel within one tick
    final double maxPixelsPerTick = this.getEntity().getTickVelocity();
    final double deltaTime = Game.loop().getDeltaTime() * Game.loop().getTimeScale();

    final double acceleration =
        this.getEntity().getAcceleration() == 0
            ? maxPixelsPerTick
            : deltaTime / this.getEntity().getAcceleration() * maxPixelsPerTick;
    final double deceleration =
        this.getEntity().getDeceleration() == 0
            ? this.getVelocity()
            : deltaTime / this.getEntity().getDeceleration() * maxPixelsPerTick;

    double dx = this.getDx();
    double dy = this.getDy();
    this.setDx(0);
    this.setDy(0);

    final double deltaVelocity =
        Math.min(Math.sqrt(Math.pow(dx, 2) + Math.pow(dy, 2)), acceleration);
    if (deltaVelocity != 0) {
      double newVelocity = this.getVelocity() + deltaVelocity;
      this.setVelocity(newVelocity);
    } else {
      final double newVelocity = Math.max(0, this.getVelocity() - deceleration);
      this.setVelocity(newVelocity);
      dx = GeometricUtilities.getDeltaX(this.moveAngle);
      dy = GeometricUtilities.getDeltaY(this.moveAngle);
    }

    if (this.getVelocity() == 0) {
      this.moveAngle = 0;
      return;
    }

    // actually move entity
    this.moveEntity(dx, dy);
}
}
```
```java
class de.gurkenlabs.litiengine.graphics.animation.AnimationController {
public void detach() {
    Game.loop().detach(this);
}public void attach() {
    Game.loop().attach(this);
}
}
```
```java
class de.gurkenlabs.litiengine.graphics.Camera {
@Override
  public void setZoom(final float targetZoom, final int delay) {
    if (delay == 0) {

      this.zoom = targetZoom;
      this.targetZoom = 0;
      this.zoomDelay = 0;
      this.zoomTick = 0;
      this.zoomStep = 0;

      final ZoomChangedEvent event = new ZoomChangedEvent(this, targetZoom);
      for (final ZoomChangedListener listener : this.zoomListeners) {
        listener.zoomChanged(event);
      }
    } else {
      this.zoomTick = Game.time().now();
      this.targetZoom = targetZoom;
      this.zoomDelay = delay;

      final double tickduration = 1000 / (double) Game.loop().getTickRate();
      final double tickAmount = delay / tickduration;
      final float totalDelta = this.targetZoom - this.zoom;
      this.zoomStep = tickAmount > 0 ? (float) (totalDelta / tickAmount) : totalDelta;
    }
}
}
```
```java
class de.gurkenlabs.litiengine.Game {
public static synchronized void init(String... args) {
    if (initialized) {
      log().log(Level.INFO, "The game has already been initialized.");
      return;
    }

    log.init();
    handleCommandLineArguments(args);

    config().load();
    Locale.setDefault(new Locale(config().client().getCountry(), config().client().getLanguage()));

    gameLoop = new GameLoop("Main Update Loop", config().client().getMaxFps());
    loop().attach(physics());
    loop().attach(world());

    // setup default exception handling for render and update loop
    setUncaughtExceptionHandler(
        new DefaultUncaughtExceptionHandler(config().client().exitOnError()));

    screenManager = new ScreenManager();
    gameWindow = new GameWindow();

    // initialize  the game window
    window().init();
    world.setCamera(new Camera());

    for (GameListener listener : gameListeners) {
      listener.initialized(args);
    }

    if (!isInNoGUIMode()) {
      window().getRenderComponent().onRendered(g -> metrics().render(g));

      graphics()
          .addEntityRenderedListener(
              e -> DebugRenderer.renderEntityDebugInfo(e.getGraphics(), e.getEntity()));

      window().getRenderComponent().onFpsChanged(fps -> metrics().setFramesPerSecond(fps));
      window()
          .setIcons(
              Arrays.asList(
                  Resources.images().get("liti-logo-x16.png"),
                  Resources.images().get("liti-logo-x20.png"),
                  Resources.images().get("liti-logo-x32.png"),
                  Resources.images().get("liti-logo-x48.png")));

      Input.keyboard()
          .onKeyTyped(
              KeyEvent.VK_PRINTSCREEN,
              key -> {
                // don't take a screenshot if a modifier is active
                if (key.getModifiers() != 0) {
                  return;
                }

                window().getRenderComponent().takeScreenshot();
              });
    }

    Runtime.getRuntime().addShutdownHook(new Thread(Game::terminate, "Shutdown"));

    initialized = true;
}
}
```
```java
class de.gurkenlabs.litiengine.entities.Creature {
protected void updateAnimationController() {
    IEntityAnimationController<?> controller = this.createAnimationController();
    this.getControllers().addController(controller);
    if (Game.world().environment() != null && Game.world().environment().isLoaded()) {
      Game.loop().attach(controller);
    }
}@Override
  public float getTickVelocity() {
    // pixels per ms multiplied by the passed ms
    // ensure that entities don't travel too far in case of lag
    return Math.min(Game.loop().getDeltaTime(), GameLoop.TICK_DELTATIME_LAG)
        * 0.001F
        * this.getVelocity().get()
        * Game.loop().getTimeScale();
}
}
```
Depth: 2
```java
class de.gurkenlabs.litiengine.environment.GameWorld {
public void clear() {
    this.unloadEnvironment();
    this.environments.clear();
    this.setCamera(null);
    Game.physics().clear();

    this.environmentListeners.clear();
    this.environmentLoadedListeners.clear();
    this.environmentUnloadedListeners.clear();

    this.listeners.clear();
    this.loadedListeners.clear();
    this.unloadedListeners.clear();
}@Nullable
  public Environment loadEnvironment(IMap map) {
    Environment env = this.getEnvironment(map);
    this.loadEnvironment(env);
    return env;
}@Nullable
  public Environment loadEnvironment(String mapName) {
    Environment env = this.getEnvironment(mapName);
    this.loadEnvironment(env);
    return env;
}
}
```
```java
class de.gurkenlabs.litiengine.GameWindow {
GameWindow() {
    this.hostControl = new JFrame();

    this.resolutionChangedListeners = new CopyOnWriteArrayList<>();

    this.renderCanvas = new RenderComponent(Game.config().graphics().getResolution());
    this.cursor = new MouseCursor();
    if (!Game.isInNoGUIMode()) {
      this.hostControl.setBackground(Color.BLACK);
      this.hostControl.add(this.renderCanvas);

      this.initializeEventListeners();

      this.hostControl.setTitle(Game.info().getTitle());
      this.hostControl.setDefaultCloseOperation(WindowConstants.DO_NOTHING_ON_CLOSE);
      initializeWindowEventListeners(this.hostControl);
    }
}
}
```
```java
class de.gurkenlabs.litiengine.GameTime {
public long sinceEnvironmentLoad() {
    return this.since(this.environmentLoaded);
}public long since(final long tick) {
    return toMilliseconds(Game.loop().getTicks() - tick);
}public long sinceGameStart() {
    return this.toMilliseconds(Game.loop().getTicks());
}
}
```
```java
class de.gurkenlabs.litiengine.abilities.effects.Effect {
protected void cease(final EffectApplication appliance) {
    // 1. cease the effect for all affected entities
    for (final ICombatEntity entity : appliance.getAffectedEntities()) {
      this.cease(entity);
    }

    // 2. apply follow up effects
    this.getFollowUpEffects().forEach(followUp -> followUp.apply(appliance.getImpactArea()));
}protected boolean hasEnded(final EffectApplication appliance) {
    final long effectDuration = Game.time().since(appliance.getAppliedTicks());
    return effectDuration > this.getDuration();
}
}
```
```java
class de.gurkenlabs.litiengine.abilities.effects.EffectApplication {
protected EffectApplication(final List<ICombatEntity> affectedEntities, final Shape impactArea) {
    this.applied = Game.time().now();
    this.affectedEntities = affectedEntities;
    this.impactArea = impactArea;
}
}
```
```java
class de.gurkenlabs.litiengine.entities.CombatEntity {
@Override
  public boolean wasHit(int timeSpan) {
    return Game.time().since(this.lastHit) < timeSpan;
}@Override
  public void hit(final int damage, @Nullable final Ability ability) {
    if (this.isDead()) {
      return;
    }

    if (!this.isIndestructible()) {
      this.getHitPoints().modifyBaseValue(new AttributeModifier<>(Modification.SUBTRACT, damage));
    }

    final EntityHitEvent event = new EntityHitEvent(this, ability, damage, this.isDead());

    for (final CombatEntityListener listener : this.listeners) {
      listener.hit(event);
    }

    for (final CombatEntityHitListener listener : this.hitListeners) {
      listener.hit(event);
    }

    if (this.isDead()) {
      this.fireDeathEvent();
      this.setCollision(false);
    }

    this.lastHit = Game.time().now();
}
}
```
```java
class de.gurkenlabs.litiengine.graphics.ImageEffect {
protected ImageEffect(final int ttl, final String name) {
    this.ttl = ttl;
    this.name = name;
    this.aliveTick = Game.time().now();
}@Override
  public long getAliveTime() {
    return Game.time().since(this.aliveTick);
}
}
```
```java
class de.gurkenlabs.litiengine.abilities.AbilityExecution {
AbilityExecution(final Ability ability) {
    this.appliedEffects = new CopyOnWriteArrayList<>();
    this.ability = ability;
    this.executionTicks = Game.time().now();
    this.impactArea = ability.calculateImpactArea();
    this.castLocation = ability.getExecutor().getCenter();
    Game.loop().attach(this);
}@Override
  public void update() {
    // if there a no effects to apply -> unregister this instance and we're done
    if (this.getAbility().getEffects().isEmpty()
        || this.getAbility().getEffects().size() == this.getAppliedEffects().size()) {
      Game.loop().detach(this);
      return;
    }

    // handle all effects from the ability that were not applied yet
    for (final Effect effect : this.getAbility().getEffects()) {
      // if the ability was not executed yet or the delay of the effect is not
      // yet reached
      if (this.getAppliedEffects().contains(effect)
          || Game.time().since(this.getExecutionTicks()) < effect.getDelay()) {
        continue;
      }

      effect.apply(this.getExecutionImpactArea());
      this.getAppliedEffects().add(effect);
    }
}
}
```
```java
class de.gurkenlabs.litiengine.tweening.TweenEngine {
@Override
  public void update() {
    for (final Tweenable target : this.getTweens().keySet()) {
      for (final Tween tween : this.getTweens().get(target).values()) {
        if (tween.hasStopped()) {
          continue;
        }
        final long elapsed = Game.time().since(tween.getStartTime());
        if (elapsed >= tween.getDuration()) {
          tween.stop();
          continue;
        }
        final float[] currentValues = new float[tween.getTargetValues().length];
        for (int i = 0; i < tween.getTargetValues().length; i++) {
          currentValues[i] =
              tween.getStartValues()[i]
                  + tween.getEquation().compute(elapsed / (float) tween.getDuration())
                      * (tween.getTargetValues()[i] - tween.getStartValues()[i]);
        }
        tween.getTarget().setTweenValues(tween.getType(), currentValues);
      }
    }
}
}
```
```java
class de.gurkenlabs.litiengine.gui.SpeechBubble {
public static SpeechBubble create(
      final IEntity entity, final String text, SpeechBubbleAppearance appearance, Font font) {
    return new SpeechBubble(entity, text, appearance, font);
}public static SpeechBubble create(final IEntity entity, final Font font, final String text) {
    SpeechBubbleAppearance app =
        new SpeechBubbleAppearance(
            DEFAULT_APPEARANCE.getForeColor(),
            DEFAULT_APPEARANCE.getBackgroundColor1(),
            DEFAULT_APPEARANCE.getBorderColor(),
            DEFAULT_APPEARANCE.getPadding());
    return new SpeechBubble(entity, text, app, font);
}public static SpeechBubble create(final IEntity entity, final String text) {
    return new SpeechBubble(entity, text, null, GuiProperties.getDefaultFont());
}@Override
  public void update() {
    if (this.currentText == null) {
      this.hide();
      return;
    }

    this.entityCenter = Game.world().camera().getViewportLocation(this.getEntity().getCenter());

    // old text was displayed long enough
    if (this.lastTextDisplay != 0
        && Game.time().since(this.lastTextDisplay) > this.currentTextDisplayTime) {
      this.currentText = null;
      this.lastTextDisplay = 0;
      return;
    }

    // display new text
    if (this.textIndex < this.currentText.length()
        && Game.time().since(this.lastCharPoll) > LETTER_WRITE_DELAY) {
      this.textIndex++;
      this.lastCharPoll = Game.time().now();
      if (this.typeSound != null) {
        Game.audio().playSound(this.typeSound, this.getEntity());
      }
    }

    // continue displaying currently displayed text
}private SpeechBubble(
      final IEntity entity,
      final String text,
      final Sound typeSound,
      SpeechBubbleAppearance appearance,
      Font font) {
    this(entity, text, appearance, font);
    this.typeSound = typeSound;
}private SpeechBubble(
      final IEntity entity,
      final String text,
      @Nullable SpeechBubbleAppearance appearance,
      @Nullable Font font) {
    if (appearance == null) {
      this.appearance = DEFAULT_APPEARANCE;
    } else {
      this.appearance = appearance;
    }

    final SpeechBubble active = activeSpeechBubbles.get(entity);
    if (active != null) {
      active.hide();
    }
    this.setFont(font);

    this.textBoxWidth = (float) (entity.getWidth() * 4);
    this.entity = entity;

    this.currentText = text;
    this.currentTextDisplayTime = DISPLAYTIME_MIN + text.length() * DISPLAYTIME_PER_LETTER;

    this.lastTextDisplay = Game.time().now();
    this.createBubbleImage();
    entity.getEnvironment().add(this, RenderType.UI);
    Game.loop().attach(this);
    activeSpeechBubbles.put(entity, this);
}
}
```
```java
class de.gurkenlabs.litiengine.gui.TextFieldComponent {
@Override
  public void render(final Graphics2D g) {
    super.render(g);
    g.setFont(this.getFont());
    final FontMetrics fm = g.getFontMetrics();

    if (this.isSelected() && Game.time().since(this.lastToggled) > this.flickerDelay) {
      this.cursorVisible = !this.cursorVisible;
      this.lastToggled = Game.time().now();
    }
    if (this.isSelected() && this.cursorVisible) {
      final Rectangle2D cursor =
          new Rectangle2D.Double(
              this.getX() + this.getTextX() + fm.stringWidth(this.getTextToRender(g)),
              this.getY() + this.getTextY(),
              this.getFont().getSize2D() * 3 / 5,
              this.getFont().getSize2D() * 1 / 5);
      g.setColor(this.getAppearance().getForeColor());
      g.fill(cursor);
    }
}
}
```
```java
class de.gurkenlabs.litiengine.entities.Prop {
public Prop(
      final Point2D location, @Nullable final String spritesheetName, final Material material) {
    super();
    this.rotation = Rotation.NONE;
    this.spritesheetName = spritesheetName;
    this.material = material;
    this.setLocation(location);
    this.updateAnimationController();
}public void setSpritesheetName(@Nullable final String spriteName) {
    this.spritesheetName = spriteName;
    this.updateAnimationController();
}
}
```
```java
class de.gurkenlabs.litiengine.tweening.Tween {
public Tween begin() {
    this.started = Game.time().now();
    this.stopped = false;
    return this;
}
}
```
```java
class de.gurkenlabs.litiengine.graphics.emitters.particles.Particle {
public void update(final Point2D emitterOrigin, final float updateRatio) {
    if (this.aliveTick == 0) {
      this.aliveTick = Game.time().now();
    }

    this.aliveTime = Game.time().since(this.aliveTick);
    if (this.timeToLiveReached()) {
      return;
    }

    if (this.colliding) {
      return;
    }

    if (this.getDeltaWidth() != 0) {
      this.width += this.getDeltaWidth() * updateRatio;
    }

    if (this.getDeltaHeight() != 0) {
      this.height += this.getDeltaHeight() * updateRatio;
    }

    if (this.getDeltaAngle() != 0) {
      this.angle += this.getDeltaAngle() * updateRatio;
    }

    // test for ray cast collision
    final float targetX = this.x + this.getVelocityX() * updateRatio;
    final float targetY = this.y + this.getVelocityY() * updateRatio;

    if (targetX == this.x && targetY == this.y) {
      return;
    }

    if (this.checkForCollision(emitterOrigin, targetX, targetY)) {
      return;
    }

    if (this.getVelocityX() != 0) {
      this.x = targetX;
    }

    if (this.getVelocityY() != 0) {
      this.y = targetY;
    }

    if (this.getAccelerationX() != 0) {
      this.velocityX += this.getAccelerationX() * updateRatio;
    }

    if (this.getAccelerationY() != 0) {
      this.velocityY += this.getAccelerationY() * updateRatio;
    }
}
}
```
```java
class de.gurkenlabs.litiengine.graphics.animation.Animation {
@Override
  public void start() {
    this.playing = true;
    if (this.getKeyframes().isEmpty()) {
      return;
    }

    this.restart();
}@Override
  public void update() {
    // do nothing if the animation is not playing or the current keyframe is not finished
    if (!this.isPlaying()
        || Game.time().since(this.lastFrameUpdate) < this.getCurrentKeyFrame().getDuration()) {
      return;
    }

    // if we are not looping and the last keyframe is finished, we terminate the animation
    if (!this.isLooping() && this.isLastKeyFrame()) {
      this.terminate();
      return;
    }

    // make sure, we stay inside the keyframe list
    final int newFrameIndex =
        (this.getKeyframes().indexOf(this.currentFrame) + 1) % this.getKeyframes().size();
    final KeyFrame previousFrame = this.currentFrame;
    this.currentFrame = this.getKeyframes().get(newFrameIndex);

    for (KeyFrameListener listener : this.listeners) {
      listener.currentFrameChanged(previousFrame, this.currentFrame);
    }

    this.lastFrameUpdate = Game.loop().getTicks();
}
}
```
```java
class de.gurkenlabs.litiengine.graphics.animation.AnimationController {
@Override
  public void update() {
    for (final Animation animation : this.getAll()) {
      animation.update();
    }

    if (this.getCurrent() != null && this.getCurrent().isPaused()) {
      return;
    }

    final boolean playbackFinished = this.getCurrent() != null && !this.getCurrent().isPlaying();
    if (playbackFinished) {
      for (final AnimationListener listener : this.listeners) {
        listener.finished(this.getCurrent());
      }
    }

    if (this.getCurrent() == null || playbackFinished) {
      if (this.getDefault() != null) {
        this.play(this.getDefault().getName());
      } else {
        this.currentAnimation = null;
      }
    }
}
}
```
```java
class de.gurkenlabs.litiengine.graphics.RenderComponent {
private void handleFade() {
    if (this.fadeOutStart != -1) {
      final long timePassed = Game.time().since(this.fadeOutStart);
      this.currentAlpha = MathUtilities.clamp(1 - timePassed / (float) this.fadeOutTime, 0, 1);
      if (this.currentAlpha == 0f) {
        this.fadeOutStart = -1;
        this.fadeOutTime = -1;
      }

      return;
    }

    if (this.fadeInStart != -1) {
      final long timePassed = Game.time().since(this.fadeInStart);
      this.currentAlpha = MathUtilities.clamp(timePassed / (float) this.fadeInTime, 0, 1);
      if (this.currentAlpha == 1f) {
        this.fadeInStart = -1;
        this.fadeInTime = -1;
        this.currentAlpha = Float.NaN;
      }
    }
}public void fadeOut(final int ms) {
    this.fadeInStart = -1;
    this.fadeInTime = -1;
    this.fadeOutStart = Game.time().now();
    this.fadeOutTime = ms;
}public void fadeIn(final int ms) {
    this.fadeOutStart = -1;
    this.fadeOutTime = -1;
    this.fadeInStart = Game.time().now();
    this.fadeInTime = ms;
}
}
```
```java
class de.gurkenlabs.litiengine.entities.Trigger {
private boolean activate(final IEntity activator, final int tar) {
    if (!this.isLoaded()
        || this.isOneTimeTrigger && this.isActivated
        || this.getActivationType() == TriggerActivation.COLLISION
            && activator != null
            && this.collisionActivated.contains(activator)) {
      return false;
    }

    if (this.getCooldown() > 0 && Game.time().since(this.lastActivation) < this.getCooldown()) {
      return false;
    }

    List<Integer> triggerTargets = this.getTargets(tar);

    final TriggerEvent te = new TriggerEvent(this, activator, triggerTargets);

    if (!this.checkActivationPredicates(te)) {
      return false;
    }

    this.isActivated = true;
    if (activator != null) {
      this.collisionActivated.add(activator);
    }

    // if we actually have a trigger target, we send the message to the target
    for (final int target : triggerTargets) {
      final IEntity entity = this.getEnvironment().get(target);
      if (entity == null) {
        log.log(
            Level.WARNING,
            "trigger [{0}] was activated, but the trigger target [{1}] could not be found on the environment",
            new Object[] {this, target});
        continue;
      }

      entity.sendMessage(this, this.message);
    }

    // also send the trigger event to all registered consumers
    for (final TriggerActivatedListener listener : this.activatedListeners) {
      listener.activated(te);
    }

    if (this.isOneTimeTrigger) {
      this.getEnvironment().remove(this);
    }

    this.lastActivation = Game.time().now();
    return true;
}
}
```
```java
class de.gurkenlabs.litiengine.graphics.Camera {
private boolean isShakeEffectActive() {
    return this.getShakeTick() != 0
        && Game.time().since(this.getShakeTick()) < this.getShakeDuration();
}@Override
  public void update() {
    if (Game.world().camera() != null && !Game.world().camera().equals(this)) {
      return;
    }

    if (this.targetZoom > 0) {
      if (Game.time().since(this.zoomTick) >= this.zoomDelay) {
        this.zoom = this.targetZoom;
        this.targetZoom = 0;
        this.zoomDelay = 0;
        this.zoomTick = 0;
        this.zoomStep = 0;
      } else {
        this.zoom += this.zoomStep;
      }

      final ZoomChangedEvent event = new ZoomChangedEvent(this, this.getZoom());
      for (final ZoomChangedListener listener : this.zoomListeners) {
        listener.zoomChanged(event);
      }
    }

    if (this.panTime > 0) {
      if (--this.panTime <= 0) {
        this.setFocus(this.targetFocus);
        this.targetFocus = null;
      } else {
        double diff = this.panTime / (this.panTime + 1.0);
        this.focus =
            new Point2D.Double(
                this.focus.getX() * diff + this.targetFocus.getX() * (1.0 - diff),
                this.focus.getY() * diff + this.targetFocus.getY() * (1.0 - diff));
      }
    }

    if (!this.isShakeEffectActive()) {
      this.shakeOffsetX = 0;
      this.shakeOffsetY = 0;
      return;
    }

    if (Game.time().since(this.lastShake) > this.shakeDelay) {
      this.shakeOffsetX = this.getShakeIntensity() * ThreadLocalRandom.current().nextGaussian();
      this.shakeOffsetY = this.getShakeIntensity() * ThreadLocalRandom.current().nextGaussian();
      this.lastShake = Game.time().now();
    }
}@Override
  public void setZoom(final float targetZoom, final int delay) {
    if (delay == 0) {

      this.zoom = targetZoom;
      this.targetZoom = 0;
      this.zoomDelay = 0;
      this.zoomTick = 0;
      this.zoomStep = 0;

      final ZoomChangedEvent event = new ZoomChangedEvent(this, targetZoom);
      for (final ZoomChangedListener listener : this.zoomListeners) {
        listener.zoomChanged(event);
      }
    } else {
      this.zoomTick = Game.time().now();
      this.targetZoom = targetZoom;
      this.zoomDelay = delay;

      final double tickduration = 1000 / (double) Game.loop().getTickRate();
      final double tickAmount = delay / tickduration;
      final float totalDelta = this.targetZoom - this.zoom;
      this.zoomStep = tickAmount > 0 ? (float) (totalDelta / tickAmount) : totalDelta;
    }
}@Override
  public void shake(final double intensity, final int delay, final int shakeDuration) {
    this.shakeTick = Game.time().now();
    this.shakeDelay = delay;
    this.shakeIntensity = intensity;
    this.shakeDuration = shakeDuration;
}
}
```
```java
class de.gurkenlabs.litiengine.entities.Creature {
public void setSpritesheetName(String spritesheetName) {
    if (this.spritesheetName != null && this.spritesheetName.equals(spritesheetName)) {
      return;
    }

    this.spritesheetName = spritesheetName;
    this.updateAnimationController();
}public boolean isIdle() {
    return Game.time().since(this.lastMoved) > IDLE_DELAY;
}@Override
  public void setLocation(final Point2D position) {
    if (this.isDead() || position == null) {
      return;
    }

    final Point2D oldLocation = this.getLocation();
    super.setLocation(position);

    if (Game.hasStarted() && this.isLoaded()) {
      this.lastMoved = Game.time().now();
      this.fireMovedEvent(
          new EntityMovedEvent(
              this, this.getX() - oldLocation.getX(), this.getY() - oldLocation.getY()));
    }
}
}
```
```java
class de.gurkenlabs.litiengine.gui.screens.ScreenManager {
public void display(final String screenName) {
    if (this.current() != null && this.current().getName().equalsIgnoreCase(screenName)) {
      log.log(
          Level.INFO,
          "Skipping displaying of screen {0} because it is already the current screen.",
          screenName);
      return;
    }

    if (this.screens.stream()
        .noneMatch(element -> element.getName().equalsIgnoreCase(screenName))) {
      log.log(
          Level.WARNING,
          "Could not display the screen {0} because there is no screen with the specified name.",
          screenName);
      return;
    }

    Screen screen = this.get(screenName);
    if (screen == null) {
      return;
    }

    this.display(screen);
}public void add(final Screen screen) {
    screen.setWidth(Game.window().getWidth());
    screen.setHeight(Game.window().getHeight());
    this.screens.add(screen);

    if (this.current() == null) {
      this.display(screen);
    }
}public void remove(Screen screen) {
    this.screens.remove(screen);
    if (this.current() == screen) {
      if (!this.screens.isEmpty()) {
        this.display(this.screens.get(0));
      } else {
        this.display((Screen) null);
      }
    }
}public void display(@Nullable final Screen screen) {
    if (Game.hasStarted() && Game.time().since(this.lastScreenChange) < this.getChangeCooldown()) {
      log.log(
          Level.INFO,
          "Skipping displaying of screen {0} because screen changing is currently on cooldown.",
          screen != null ? screen.getName() : "");
      return;
    }

    final Screen previous = this.current();
    if (previous != null) {
      previous.suspend();
    }

    if (screen != null && !this.screens.contains(screen)) {
      this.screens.add(screen);
    }

    this.currentScreen = screen;
    if (!Game.isInNoGUIMode() && this.current() != null) {
      this.current().prepare();
    }

    this.lastScreenChange = Game.loop().getTicks();

    final ScreenChangedEvent event = new ScreenChangedEvent(this.current(), previous);
    for (final ScreenChangedListener listener : this.screenChangedListeners) {
      listener.changed(event);
    }
}
}
```
```java
class de.gurkenlabs.litiengine.abilities.Ability {
public boolean isOnCooldown() {
    return (this.getCurrentExecution() != null
        && this.getCurrentExecution().getExecutionTicks() > 0
        && Game.time().since(this.getCurrentExecution().getExecutionTicks())
            < this.getAttributes().cooldown().get());
}public boolean isActive() {
    return this.getCurrentExecution() != null
        && Game.time().since(this.getCurrentExecution().getExecutionTicks())
            < this.getAttributes().duration().get();
}@Nullable
  public AbilityExecution cast() {
    if (!this.canCast()) {
      return null;
    }
    this.currentExecution = new AbilityExecution(this);

    for (final AbilityCastListener listener : this.abilityCastListeners) {
      listener.abilityCast(this.currentExecution);
    }

    return this.getCurrentExecution();
}public float getRemainingCooldownInSeconds() {
    if (this.getCurrentExecution() == null
        || this.getExecutor() == null
        || this.getExecutor().isDead()) {
      return 0;
    }

    // calculate cooldown in seconds
    return (float)
        (!this.canCast()
            ? (this.getAttributes().cooldown().get()
                    - Game.time().since(this.getCurrentExecution().getExecutionTicks()))
                * 0.001
            : 0);
}
}
```
```java
class de.gurkenlabs.litiengine.entities.EntityHitEvent {
EntityHitEvent(
      final ICombatEntity hitEntity,
      @Nullable final Ability ability,
      final int damage,
      final boolean kill) {
    super(hitEntity);
    this.executor = ability != null ? ability.getExecutor() : null;
    this.hitEntity = hitEntity;
    this.ability = ability;
    this.damage = damage;
    this.kill = kill;
    this.time = Game.time().now();
}
}
```
```java
class de.gurkenlabs.litiengine.graphics.emitters.Emitter {
public void delete() {
    this.deactivate();
    if (Game.world().environment() != null) {
      Game.world().environment().remove(this);
    }
}public void activate() {
    if (this.activated) {
      return;
    }

    this.activated = true;
    this.activationTick = Game.time().now();
    Game.loop().attach(this);
}@Override
  public void update() {
    if (this.isPaused()) {
      return;
    }

    // clear particles if the effect time to life is reached
    if (this.isFinished()) {
      for (EmitterFinishedListener listener : this.finishedListeners) {
        listener.finished(this);
      }

      this.delete();
      return;
    }

    final float updateRatio = (float) this.data().getUpdateRate() / Game.loop().getTickRate();
    for (final Particle p : this.getParticles().stream().collect(Collectors.toList())) {
      if (this.particleCanBeRemoved(p)) {
        // remove dead particles
        this.particles.remove(p);
        continue;
      }

      p.update(this.getOrigin(), updateRatio);
    }

    this.aliveTime = Game.time().since(this.activationTick);
    if ((this.data().getSpawnRate() == 0
        || Game.time().since(this.lastSpawn) >= this.data().getSpawnRate())) {
      this.lastSpawn = Game.time().now();
      this.spawnParticle();
    }
}
}
```
```java
class de.gurkenlabs.litiengine.GameLoop {
@Override
  public int perform(int delay, Runnable action) {
    final long d = Game.time().toTicks(delay);

    TimedAction a = new TimedAction(this.getTicks() + d, action);
    this.actions.add(a);

    return a.getId();
}
}
```
```java
class de.gurkenlabs.litiengine.environment.EntitySpawner {
protected boolean shouldSpawn() {
    return this.lastSpawnWave == 0
        || Game.time().since(this.lastSpawnWave) >= this.getSpawnInterval();
}@Override
  public void update() {
    if (!this.shouldSpawn()) {
      return;
    }

    this.spawnNewEntities();
    this.lastSpawnWave = Game.time().now();
}
}
```
```java
class de.gurkenlabs.litiengine.graphics.FreeFlightCamera {
@Override
  public void update() {
    this.handleFreeFlightCamera();
}public FreeFlightCamera(double x, double y) {
    this(new Point2D.Double(x, y));
}
}
```
```java
class de.gurkenlabs.litiengine.environment.Environment {
public void unload() {
    if (!this.loaded) {
      return;
    }

    // unregister all updatable entities from the current environment
    for (final IEntity entity : this.allEntities.values()) {
      this.unload(entity);
    }

    this.loaded = false;
    this.fireEvent(l -> l.unloaded(this));
}private static void loadUpdatableOrEmitterEntity(IEntity entity) {
    if (entity instanceof Emitter) {
      final Emitter emitter = (Emitter) entity;
      if (emitter.isActivateOnInit()) {
        emitter.activate();
      }
    } else if (entity instanceof IUpdateable) {
      Game.loop().attach((IUpdateable) entity);
    }
}public void clear() {
    Game.physics().clear();

    this.combatEntities.clear();
    this.mobileEntities.clear();
    this.gravityForces.clear();
    this.layerEntities.clear();
    this.entitiesByTag.clear();
    this.allEntities.clear();

    for (RenderType renderType : RenderType.values()) {
      this.miscEntities.get(renderType).clear();
      this.renderListeners.get(renderType).clear();
      this.renderables.get(renderType).clear();
    }

    dispose(this.allEntities.values());
    dispose(this.triggers);
    this.emitters.clear();
    this.colliders.clear();
    this.props.clear();
    this.creatures.clear();
    this.staticShadows.clear();
    this.combatEntities.clear();
    this.mobileEntities.clear();
    this.lightSources.clear();
    this.spawnPoints.clear();
    this.soundSources.clear();
    this.mapAreas.clear();
    this.triggers.clear();

    this.ambientLight = null;
    this.staticShadowLayer = null;

    for (Map<Integer, IEntity> type : this.miscEntities.values()) {
      type.clear();
    }

    this.initialized = false;

    this.fireEvent(l -> l.cleared(this));
}private void load(final IEntity entity) {
    // an entity can only exist on one environment at a time, so remove it from the current one
    if (entity.getEnvironment() != null) {
      entity.getEnvironment().remove(entity);
    }

    // 1. add to physics engine
    loadPhysicsEntity(entity);

    // 2. register for update or activate
    loadUpdatableOrEmitterEntity(entity);

    // 3. if a gravity is defined, add a gravity force to the entity
    if (entity instanceof IMobileEntity && this.getGravity() != 0) {
      this.addGravityForce((IMobileEntity) entity);
    }

    // 4. attach all controllers
    entity.attachControllers();

    if (this.loaded && (entity instanceof LightSource || entity instanceof StaticShadow)) {
      this.updateLighting(entity);
    }

    entity.loaded(this);
}private void unload(final IEntity entity) {
    // 1. remove from physics engine
    if (entity instanceof ICollisionEntity) {
      Game.physics().remove((ICollisionEntity) entity);
    }

    // 2. unregister from update
    if (entity instanceof IUpdateable) {
      Game.loop().detach((IUpdateable) entity);
    }

    if (entity instanceof IMobileEntity) {
      this.removeGravity((IMobileEntity) entity);
    }

    // 3. detach all controllers
    entity.detachControllers();

    if (entity instanceof Emitter) {
      Emitter em = (Emitter) entity;
      em.deactivate();
    }

    if (this.loaded && (entity instanceof LightSource || entity instanceof StaticShadow)) {
      this.updateLighting(entity);
    }

    entity.removed(this);
}public void remove(final IEntity entity) {
    if (entity == null) {
      return;
    }

    this.allEntities.remove(entity.getMapId());
    Iterator<List<IEntity>> iter = this.layerEntities.values().iterator();
    while (iter.hasNext()) {
      List<IEntity> layer = iter.next();
      if (layer.remove(entity) && layer.isEmpty()) {
        iter.remove();
      }
    }
    if (this.miscEntities.get(entity.getRenderType()) != null) {
      this.miscEntities.get(entity.getRenderType()).values().remove(entity);
    }

    for (String tag : entity.getTags()) {
      if (this.getEntitiesByTag().containsKey(tag)) {
        this.getEntitiesByTag().get(tag).remove(entity);

        if (this.getEntitiesByTag().get(tag).isEmpty()) {
          this.getEntitiesByTag().remove(tag);
        }
      }
    }

    if (entity instanceof Emitter) {
      Emitter emitter = (Emitter) entity;
      this.removeEmitter(emitter);
    }

    if (entity instanceof MapArea) {
      this.mapAreas.remove(entity);
    }

    if (entity instanceof Prop) {
      this.props.remove(entity);
    }

    if (entity instanceof Creature) {
      this.creatures.remove(entity);
    }

    if (entity instanceof CollisionBox) {
      this.colliders.remove(entity);
      this.staticShadows.removeIf(x -> x.getOrigin() != null && x.getOrigin().equals(entity));
    }

    if (entity instanceof LightSource) {
      this.lightSources.remove(entity);
      this.updateLighting(entity);
    }

    if (entity instanceof Trigger) {
      this.triggers.remove(entity);
    }

    if (entity instanceof Spawnpoint) {
      this.spawnPoints.remove(entity);
    }
    if (entity instanceof SoundSource) {
      this.soundSources.remove(entity);
    }

    if (entity instanceof StaticShadow) {
      this.staticShadows.remove(entity);
      this.updateLighting(entity);
    }

    if (entity instanceof IMobileEntity) {
      this.mobileEntities.values().remove(entity);
    }

    if (entity instanceof ICombatEntity) {
      this.combatEntities.values().remove(entity);
    }

    this.unload(entity);

    this.fireEntityEvent(l -> l.entityRemoved(entity));
}
}
```
```java
class de.gurkenlabs.litiengine.physics.MovementController {
@Override
  public void update() {
    this.handleForces();
    this.handleMovement();
}
}
```
```java
class de.gurkenlabs.litiengine.Game {
static synchronized void terminate() {
    if (!initialized) {
      return;
    }

    hasStarted = false;
    initialized = false;

    config().save();
    gameLoop.terminate();
    tweenEngine.terminate();
    soundEngine.terminate();

    world().clear();

    for (final GameListener listener : gameListeners) {
      try {
        listener.terminated();
      } catch (Exception e) {
        log().log(Level.WARNING, "game listener threw an exception during shutdown", e);
      }
    }

    gameLoop = null;
    screenManager = null;
    gameWindow = null;
}public static synchronized void start() {
    if (!initialized) {
      throw new IllegalStateException(
          "The game cannot be started without being first initialized. Call Game.init(...) before Game.start().");
    }

    gameLoop.start();
    tweenEngine.start();
    soundEngine.start();

    for (final GameListener listener : gameListeners) {
      listener.started();
    }

    hasStarted = true;
}public static synchronized void init(String... args) {
    if (initialized) {
      log().log(Level.INFO, "The game has already been initialized.");
      return;
    }

    log.init();
    handleCommandLineArguments(args);

    config().load();
    Locale.setDefault(new Locale(config().client().getCountry(), config().client().getLanguage()));

    gameLoop = new GameLoop("Main Update Loop", config().client().getMaxFps());
    loop().attach(physics());
    loop().attach(world());

    // setup default exception handling for render and update loop
    setUncaughtExceptionHandler(
        new DefaultUncaughtExceptionHandler(config().client().exitOnError()));

    screenManager = new ScreenManager();
    gameWindow = new GameWindow();

    // initialize  the game window
    window().init();
    world.setCamera(new Camera());

    for (GameListener listener : gameListeners) {
      listener.initialized(args);
    }

    if (!isInNoGUIMode()) {
      window().getRenderComponent().onRendered(g -> metrics().render(g));

      graphics()
          .addEntityRenderedListener(
              e -> DebugRenderer.renderEntityDebugInfo(e.getGraphics(), e.getEntity()));

      window().getRenderComponent().onFpsChanged(fps -> metrics().setFramesPerSecond(fps));
      window()
          .setIcons(
              Arrays.asList(
                  Resources.images().get("liti-logo-x16.png"),
                  Resources.images().get("liti-logo-x20.png"),
                  Resources.images().get("liti-logo-x32.png"),
                  Resources.images().get("liti-logo-x48.png")));

      Input.keyboard()
          .onKeyTyped(
              KeyEvent.VK_PRINTSCREEN,
              key -> {
                // don't take a screenshot if a modifier is active
                if (key.getModifiers() != 0) {
                  return;
                }

                window().getRenderComponent().takeScreenshot();
              });
    }

    Runtime.getRuntime().addShutdownHook(new Thread(Game::terminate, "Shutdown"));

    initialized = true;
}
}
```


Response Format:
Provide the answer in **XML format** as follows:

#### If the method **cannot** return `null` at the specific call site:
```xml
<response>
  <reason><![CDATA[EXPLAIN WHY THE INVOCATION Game.loop() RESULT CANNOT BE NULL.]]></reason>
  <value>NO</value>
</response>

#### If the method can return null at the specific call site:
<response>
  <reason><![CDATA[EXPLAIN WHY THE INVOCATION Game.loop() RESULT CAN BE NULL.]]></reason>
  <value>YES</value>
</response>

#### If you are unsure or If there are any methods that directly or indirectly affect the return value and are not fully disclosed, request their declarations first, in the following format:
<response>
  <reason><![CDATA[EXPLAIN WHY THIS METHOD DECLARATION IS NECESSARY AND WHY YOU CANNOT MAKE A CONFIDENT DECISION WITHOUT IT]]></reason>
  <success>false</success>
  <methods>
    <method>methodName</method>
  </methods>
</response>

Additional Notes:
Be precise in your reasoning.
If a method’s return value depends on another method not provided, request its declaration before making a conclusion.
If the method can return null in this case but not in others, explain why it happens specifically for this call.

---ChatGPT.sendRequestToOpenAI---
Retrieving response from cache
---Response.<init>---
Creating Response:
```xml
<response>
  <reason><![CDATA[The method `Game.loop()` returns the static field `gameLoop`, which is initialized in the `Game.init(String... args)` method. In this method, a new `GameLoop` object is instantiated and assigned to `gameLoop`. Since `init()` must be called before `start()`, which is implied by the requirement of initializing the game, the `gameLoop` is guaranteed to be non-null during the lifetime of the game execution where `Game.loop()` is called. The absence of any code that could set `gameLoop` to null after its initialization ensures that `Game.loop()` cannot return null.]]></reason>
  <value>NO</value>
</response>
```
---Response.<init>---
Response created:
Disagreement: The method `Game.loop()` returns the static field `gameLoop`, which is initialized in the `Game.init(String... args)` method. In this method, a new `GameLoop` object is instantiated and assigned to `gameLoop`. Since `init()` must be called before `start()`, which is implied by the requirement of initializing the game, the `gameLoop` is guaranteed to be non-null during the lifetime of the game execution where `Game.loop()` is called. The absence of any code that could set `gameLoop` to null after its initialization ensures that `Game.loop()` cannot return null.
---AdvancedNullAwayCodeFix.resolveMethodDereferenceError---
Method is not returning nullable on call site. Injecting suppression annotation.
---AdvancedNullAwayCodeFix.constructCastToNonnullChange---
Constructing cast to nonnull change for reason: The method `Game.loop()` returns the static field `gameLoop`, which is initialized in the `Game.init(String... args)` method. In this method, a new `GameLoop` object is instantiated and assigned to `gameLoop`. Since `init()` must be called before `start()`, which is implied by the requirement of initializing the game, the `gameLoop` is guaranteed to be non-null during the lifetime of the game execution where `Game.loop()` is called. The absence of any code that could set `gameLoop` to null after its initialization ensures that `Game.loop()` cannot return null.
---ChatGPT.ask---
Asking ChatGPT:
For the reason you mentioned earlier:

"The method `Game.loop()` returns the static field `gameLoop`, which is initialized in the `Game.init(String... args)` method. In this method, a new `GameLoop` object is instantiated and assigned to `gameLoop`. Since `init()` must be called before `start()`, which is implied by the requirement of initializing the game, the `gameLoop` is guaranteed to be non-null during the lifetime of the game execution where `Game.loop()` is called. The absence of any code that could set `gameLoop` to null after its initialization ensures that `Game.loop()` cannot return null."

in the method below, the expression Game.loop() is not nullable at the point it is used.

```java
public long now() {
    return Game.loop().getTicks();
}
```
Please Summarize the reason in max 5 words and rewrite the method so that at the line "    return Game.loop().getTicks();", at the occurrence of: "Game.loop()" is replaced with `NullabilityUtil.castToNonnull(Game.loop(), summary of reason)`
Replace "REASON" with the exact reason summary I provide to you (maximum 5 words), not with a generic explanation like "checked to be nonnull".
see the example below, for expression `foo.getBar()`, to wrap it with `NullabilityUtil.castToNonnull(foo.getBar(), "reason")`.

```java
public t(){
    String l = foo.getBar();
}
```

will be:
```java
public t(){
    String l = NullabilityUtil.castToNonnull(foo.getBar(), "checked to be nonnull");
}
```

### Instructions:

Do not import any additional classes.

Do not add Java comments.

Only modify relevant lines as required.

Return only the modified method wrapped in the XML format shown below.

Place the Java code inside the <code> tag using a CDATA block with ```java formatting.

Just give me the fixed code snippet in XML format in <response> tag like the example below. I will apply the fix to my codebase. Do not import any additional libraries or classes or add java comments. If you can provide the fixed code snippet, please provide it in the following format and place the code snippet in the <code> tag within ```java block.
<response>
  <success>true</success>
  <code><![CDATA[
  ```java
  Your fixed code snippet here
  ```
    ]]>
  </code>
</response>

---ChatGPT.sendRequestToOpenAI---
Retrieving response from cache
---Response.<init>---
Creating Response:
<response>
  <success>true</success>
  <code><![CDATA[
  ```java
  public long now() {
      return NullabilityUtil.castToNonnull(Game.loop(), "always initialized before use").getTicks();
  }
  ```
    ]]>
  </code>
</response>
---Response.<init>---
Response created:
public long now() {
      return NullabilityUtil.castToNonnull(Game.loop(), "always initialized before use").getTicks();
  }
---ChatGPT.fixDereferenceByAddingCastToNonnull---
Fixing the error by adding castToNonnull
---AdvancedNullAwayCodeFix.fixTriggeredErrorsForLocation---
Resolving unresolvable error for triggered error: Type='DEREFERENCE_NULLABLE', message='dereferenced expression Game.loop() is @Nullable'
/home/nima/Developer/nullness-benchmarks/litiengine/src/de/gurkenlabs/litiengine/entities/behavior/IBehaviorController.java:9
    Game.loop().detach(this);
---AdvancedNullAwayCodeFix.fix---
Fixing error: Type='DEREFERENCE_NULLABLE', message='dereferenced expression Game.loop() is @Nullable'
/home/nima/Developer/nullness-benchmarks/litiengine/src/de/gurkenlabs/litiengine/entities/behavior/IBehaviorController.java:9
    Game.loop().detach(this);
---AdvancedNullAwayCodeFix.resolveDereferenceError---
Resolving dereference error: Type='DEREFERENCE_NULLABLE', message='dereferenced expression Game.loop() is @Nullable'
/home/nima/Developer/nullness-benchmarks/litiengine/src/de/gurkenlabs/litiengine/entities/behavior/IBehaviorController.java:9
    Game.loop().detach(this);
---AdvancedNullAwayCodeFix.resolveDereferenceError---
Checking nullability possibility at error point
---ChatGPT.checkNullabilityPossibilityAtErrorPoint---
Asking if the expression can be null at error point point
---ChatGPT.ask---
Asking ChatGPT:
In the method below, is there a possibility that the expression "Game.loop()" at line "Game.loop().detach(this);" is null?
public default void detach() {
    Game.loop().detach(this);
}
Give a single-word answer in XML format. If it is possible for the expression to be null, respond with:
```xml
<response>
    <reason><![CDATA[YOUR REASON]]></reason>
    <value>YES</value>
</response>
```
If it is not possible for the expression to be null, respond with:
```xml
<response>
    <reason><![CDATA[YOUR REASON]]></reason>
    <value>NO</value>
</response>
```
If you are unsure or need more information, respond with where you can ask for more details or what specific information you need.

If additional information is required, list each request inside a `<request>` tag. If no additional information is needed, omit the `<requests>` section.

Respond with:
```xml
<response>
    <reason><![CDATA[YOUR REASON]]></reason>
    <value>UNKNOWN</value>
    <!-- Include <requests> only if additional information is needed -->
    <requests>
        <request><![CDATA[YOUR REQUEST 1]]></request>
        <request><![CDATA[YOUR REQUEST 2]]></request>
    </requests>
</response>
```
---ChatGPT.sendRequestToOpenAI---
Retrieving response from cache
---Response.<init>---
Creating Response:
```xml
<response>
    <reason><![CDATA[It is unclear from the provided snippet whether Game.loop() can return a null value, as it depends on the implementation details of the Game class and its loop() method, which are not provided.]]></reason>
    <value>UNKNOWN</value>
    <requests>
        <request><![CDATA[Provide the implementation of the Game class, specifically the loop() method.]]></request>
    </requests>
</response>
```
---Response.<init>---
Response created:
Unknown: It is unclear from the provided snippet whether Game.loop() can return a null value, as it depends on the implementation details of the Game class and its loop() method, which are not provided.
---AdvancedNullAwayCodeFix.resolveMethodDereferenceError---
Resolving method dereference error.
---AdvancedNullAwayCodeFix.resolveMethodDereferenceError---
Method is in annotated package. Checking if the method is returning nullable.
---AdvancedNullAwayCodeFix.investigateMethodReturnNullability---
Checking if the method is returning nullable.
---ChatGPT.checkIfMethodIsReturningNullable---
Asking if the method is returning nullable: loop()
---ChatGPT.ask---
Asking ChatGPT:
In the method below, is there a possibility that the method returns null based only on its body? Consider the following points:

- The method may have multiple return paths; consider all return statements.
- If the method calls another method, do not assume its return value unless its full declaration is provided. Request its declaration if needed.
- The method may throw an exception instead of returning null. An exception path should not be considered a null return.
- Ensure you request the declarations of any methods whose return values directly or indirectly impact this method’s return value before making a conclusion.
- Carefully analyze all conditions and prior operations that may guarantee a non-null return value.

@Nullable public static IGameLoop loop() {
    return gameLoop;
}

Here are the method definitions in addition to the method inquired:

Depth: 0
```java
class de.gurkenlabs.litiengine.Game {
@Nullable public static IGameLoop loop() {
    return gameLoop;
}
}
```


Response Format:
Provide the answer in **XML format** as follows:

#### If the method **cannot** return `null`:
```xml
<response>
  <reason><![CDATA[EXPLAIN WHY THE METHOD CANNOT RETURN NULL]]></reason>
  <value>NO</value>
</response>
```

#### If the method can return null:
```xml
<response>
  <reason><![CDATA[EXPLAIN WHY THE METHOD CAN RETURN NULL]]></reason>
  <value>YES</value>
</response>
```

#### If you are unsure or need more information, respond with where you can ask for more details or what specific information you need.

#### If you are unsure or If there are any methods that directly or indirectly affect the return value and are not fully disclosed, request their declarations first, in the following format:
<response>
  <reason><![CDATA[YOUR REASON]]></reason>
  <value>UNKNOWN</value>
  <methods>
    <method>methodName</method>
  </methods>
</response>

If additional information is required other than method declaration, list each request inside a `<request>` tag. If no additional information is needed, omit the `<requests>` section.

Respond with:
```xml
<response>
    <reason><![CDATA[YOUR REASON]]></reason>
    <value>UNKNOWN</value>
    <!-- Include <requests> only if additional information is needed -->
    <requests>
        <request><![CDATA[YOUR REQUEST 1]]></request>
        <request><![CDATA[YOUR REQUEST 2]]></request>
    </requests>
</response>
```

Additional Notes:
Be precise in your reasoning.
If a method’s return value depends on another method not provided, request its declaration before making a conclusion.
If the method can return null in some cases but not others, explain under what conditions it can happen.

---ChatGPT.sendRequestToOpenAI---
Retrieving response from cache
---Response.<init>---
Creating Response:
```xml
<response>
  <reason><![CDATA[The method `loop` returns the variable `gameLoop`. Without the initialization or assignment details of `gameLoop`, it's unclear whether it can be null. The possibility of `gameLoop` being uninitialized or set to null elsewhere in the program means `loop` could potentially return null. Further information on `gameLoop` is required.]]></reason>
  <value>UNKNOWN</value>
  <requests>
    <request><![CDATA[Please provide the declaration and initialization of the variable `gameLoop` in the class `de.gurkenlabs.litiengine.Game`.]]></request>
  </requests>
</response>
```
---Response.<init>---
Response created:
Unknown: The method `loop` returns the variable `gameLoop`. Without the initialization or assignment details of `gameLoop`, it's unclear whether it can be null. The possibility of `gameLoop` being uninitialized or set to null elsewhere in the program means `loop` could potentially return null. Further information on `gameLoop` is required.
---AdvancedNullAwayCodeFix.investigateMethodReturnNullability---
Could not determine the nullability and model did not ask for any method.
---ChatGPT.checkIfMethodIsReturningNullableOnCallSite---
Asking if the method is returning nullable on the call site: Game.loop()
---ChatGPT.ask---
Asking ChatGPT:
In the method below, is there a possibility that the method returns null at the given call site?

```java
@Nullable public static IGameLoop loop() {
    return gameLoop;
}
```

## Guidelines:
- The method may have multiple return paths; consider all return statements.
- If the method calls another method, do not assume its return value unless its full declaration is provided. Request its declaration if needed.
- The method may throw an exception instead of returning null. An exception path should not be considered a null return.
- Ensure you request the declarations of any methods whose return values directly or indirectly impact this method’s return value before making a conclusion.
- If the method returns a value that is determined by a parameter, evaluate based on the actual argument at the given call site.
- Analyze based only on the specific invocation provided. Do not generalize to all possible inputs.- If the return value is guaranteed to be non-null at the call site, the answer should be a definitive NO.
- Do not generalize based on all possible inputs—your answer must be based only on the given invocation.
- Focus only on the given call site, not all possible invocations.

### call site:
Game.loop()

Here are the method definitions and the call chain for this method, showing the sequence of calls from the method to its callers at each depth level:

Depth: 0
```java
class de.gurkenlabs.litiengine.Game {
@Nullable public static IGameLoop loop() {
    return gameLoop;
}
}
```
Depth: 1
```java
class de.gurkenlabs.litiengine.environment.GameWorld {
public void loadEnvironment(@Nullable final Environment env) {
    Lock lock = Game.loop().getLock();
    lock.lock();
    try {
      unloadEnvironment();
      this.environment = env;
      if (env != null) {
        this.addEnvironment(env);

        if (env.getGravity() == 0 && this.gravity() != 0) {
          env.setGravity(this.gravity());
        }

        env.load();
        for (final EnvironmentLoadedListener listener : this.loadedListeners) {
          listener.loaded(env);
        }

        // call map specific listeners
        String mapName = getMapName(env);
        if (mapName != null && this.environmentLoadedListeners.containsKey(mapName)) {

          // for the default camera we center the camera on the environment
          if (this.camera().getClass().equals(Camera.class)) {
            camera().setFocus(env.getCenter());
          }

          for (EnvironmentLoadedListener listener : this.environmentLoadedListeners.get(mapName)) {
            listener.loaded(env);
          }
        }
      }
    } finally {
      lock.unlock();
    }
}public void setCamera(@Nullable final ICamera cam) {
    if (this.camera() != null) {
      Game.loop().detach(camera);
    }

    camera = cam;

    if (cam != null && !Game.isInNoGUIMode()) {
      Game.loop().attach(cam);
      cam.updateFocus();
    }
}
}
```
```java
class de.gurkenlabs.litiengine.entities.behavior.EntityNavigator {
public EntityNavigator(final IMobileEntity entity, final PathFinder pathFinder) {
    this.cancelNavigationConditions = new CopyOnWriteArrayList<>();
    this.listeners = new CopyOnWriteArrayList<>();
    this.entity = entity;
    this.pathFinder = pathFinder;
    this.setAcceptableError(DEFAULT_ACCEPTABLE_ERROR);
    Game.loop().attach(this);
}
}
```
```java
class de.gurkenlabs.litiengine.GameWindow {
private static void initializeWindowEventListeners(Window window) {

    window.addWindowStateListener(
        e -> {
          if (e.getNewState() == Frame.ICONIFIED) {
            Game.loop().setTickRate(ICONIFIED_MAX_FPS);
          } else {
            Game.loop().setTickRate(Game.config().client().getMaxFps());
          }
        });

    window.addWindowFocusListener(
        new WindowFocusListener() {
          @Override
          public void windowLostFocus(WindowEvent e) {
            if (Game.config().graphics().reduceFramesWhenNotFocused()) {
              Game.loop().setTickRate(NONE_FOCUS_MAX_FPS);
            }
          }

          @Override
          public void windowGainedFocus(WindowEvent e) {
            Game.loop().setTickRate(Game.config().client().getMaxFps());
          }
        });

    window.addWindowListener(
        new WindowAdapter() {
          @Override
          public void windowClosing(final WindowEvent event) {
            Game.exit();
          }
        });
}
}
```
```java
class de.gurkenlabs.litiengine.gui.screens.ScreenManager {
public void display(@Nullable final Screen screen) {
    if (Game.hasStarted() && Game.time().since(this.lastScreenChange) < this.getChangeCooldown()) {
      log.log(
          Level.INFO,
          "Skipping displaying of screen {0} because screen changing is currently on cooldown.",
          screen != null ? screen.getName() : "");
      return;
    }

    final Screen previous = this.current();
    if (previous != null) {
      previous.suspend();
    }

    if (screen != null && !this.screens.contains(screen)) {
      this.screens.add(screen);
    }

    this.currentScreen = screen;
    if (!Game.isInNoGUIMode() && this.current() != null) {
      this.current().prepare();
    }

    this.lastScreenChange = Game.loop().getTicks();

    final ScreenChangedEvent event = new ScreenChangedEvent(this.current(), previous);
    for (final ScreenChangedListener listener : this.screenChangedListeners) {
      listener.changed(event);
    }
}
}
```
```java
class de.gurkenlabs.litiengine.abilities.effects.Effect {
@Override
  public void update() {

    for (final Iterator<EffectApplication> iterator = this.getActiveAppliances().iterator();
        iterator.hasNext(); ) {
      final EffectApplication appliance = iterator.next();
      // if the effect duration is reached
      if (this.hasEnded(appliance)) {

        iterator.remove();
        this.cease(appliance);
      }
    }

    // 4. unregister if all appliances are finished
    if (this.getActiveAppliances().isEmpty()) {
      Game.loop().detach(this);
    }
}public void apply(final Shape impactArea) {
    final List<ICombatEntity> affected = this.lookForAffectedEntities(impactArea);
    for (final ICombatEntity affectedEntity : affected) {
      this.apply(affectedEntity);
    }

    this.appliances.add(new EffectApplication(affected, impactArea));

    // if it is the first appliance -> register for update
    if (this.appliances.size() == 1) {
      Game.loop().attach(this);
    }
}
}
```
```java
class de.gurkenlabs.litiengine.GameTime {
public long toTicks(final int milliseconds) {
    return this.toTicks(milliseconds, Game.loop().getTickRate());
}public long since(final long tick) {
    return toMilliseconds(Game.loop().getTicks() - tick);
}public long now() {
    return Game.loop().getTicks();
}public long sinceGameStart() {
    return this.toMilliseconds(Game.loop().getTicks());
}@Override
  public void loaded(Environment environment) {
    environmentLoaded = Game.loop().getTicks();
}public long toMilliseconds(final long ticks) {
    return this.toMilliseconds(ticks, Game.loop().getTickRate());
}
}
```
```java
class de.gurkenlabs.litiengine.GameMetrics {
@Override
  public void render(final Graphics2D g) {
    this.updateMetrics();

    if (!Game.config().client().showGameMetrics()) {
      return;
    }

    this.currentOffsetY = 0;

    g.setColor(this.renderColor);

    // render client metrics
    this.drawTitle(g, "[client]");
    this.drawMetric(g, "fps       : " + this.getFramesPerSecond());
    this.drawMetric(g, "max fps   : " + this.maxFramesPerSecond);
    this.drawMetric(g, "updatables: " + Game.loop().getUpdatableCount());

    // render jvm metrics if debug is enabled
    if (Game.config().debug().isDebugEnabled()) {
      this.drawTitle(g, "[jvm]");
      this.drawMetric(g, "java      : " + this.javaVersion);
      this.drawMetric(g, "memory    : " + String.format("%-5.5s", this.usedMemory) + " MB");
      this.drawMetric(g, "threads   : " + Thread.activeCount());
    }

    // render rendering metrics
    if (!this.renderMetrics.isEmpty()) {
      this.drawTitle(g, "[update]");

      for (RenderMetrics metric : this.renderMetrics) {
        this.drawMetric(g, metric.toString());
      }

      this.renderMetrics.clear();
    }
}
}
```
```java
class de.gurkenlabs.litiengine.graphics.emitters.Emitter {
public void deactivate() {
    if (!this.activated) {
      return;
    }

    this.activated = false;
    this.getParticles().clear();
    this.aliveTime = 0;
    this.activationTick = 0;
    this.lastSpawn = 0;
    Game.loop().detach(this);
}public void activate() {
    if (this.activated) {
      return;
    }

    this.activated = true;
    this.activationTick = Game.time().now();
    Game.loop().attach(this);
}@Override
  public void update() {
    if (this.isPaused()) {
      return;
    }

    // clear particles if the effect time to life is reached
    if (this.isFinished()) {
      for (EmitterFinishedListener listener : this.finishedListeners) {
        listener.finished(this);
      }

      this.delete();
      return;
    }

    final float updateRatio = (float) this.data().getUpdateRate() / Game.loop().getTickRate();
    for (final Particle p : this.getParticles().stream().collect(Collectors.toList())) {
      if (this.particleCanBeRemoved(p)) {
        // remove dead particles
        this.particles.remove(p);
        continue;
      }

      p.update(this.getOrigin(), updateRatio);
    }

    this.aliveTime = Game.time().since(this.activationTick);
    if ((this.data().getSpawnRate() == 0
        || Game.time().since(this.lastSpawn) >= this.data().getSpawnRate())) {
      this.lastSpawn = Game.time().now();
      this.spawnParticle();
    }
}
}
```
```java
class de.gurkenlabs.litiengine.entities.behavior.IBehaviorController {
public default void attach() {
    Game.loop().attach(this);
}public default void detach() {
    Game.loop().detach(this);
}
}
```
```java
class de.gurkenlabs.litiengine.abilities.AbilityExecution {
AbilityExecution(final Ability ability) {
    this.appliedEffects = new CopyOnWriteArrayList<>();
    this.ability = ability;
    this.executionTicks = Game.time().now();
    this.impactArea = ability.calculateImpactArea();
    this.castLocation = ability.getExecutor().getCenter();
    Game.loop().attach(this);
}@Override
  public void update() {
    // if there a no effects to apply -> unregister this instance and we're done
    if (this.getAbility().getEffects().isEmpty()
        || this.getAbility().getEffects().size() == this.getAppliedEffects().size()) {
      Game.loop().detach(this);
      return;
    }

    // handle all effects from the ability that were not applied yet
    for (final Effect effect : this.getAbility().getEffects()) {
      // if the ability was not executed yet or the delay of the effect is not
      // yet reached
      if (this.getAppliedEffects().contains(effect)
          || Game.time().since(this.getExecutionTicks()) < effect.getDelay()) {
        continue;
      }

      effect.apply(this.getExecutionImpactArea());
      this.getAppliedEffects().add(effect);
    }
}
}
```
```java
class de.gurkenlabs.litiengine.GameWindow$3 {
@Override
          public void windowGainedFocus(WindowEvent e) {
            Game.loop().setTickRate(Game.config().client().getMaxFps());
}@Override
          public void windowLostFocus(WindowEvent e) {
            if (Game.config().graphics().reduceFramesWhenNotFocused()) {
              Game.loop().setTickRate(NONE_FOCUS_MAX_FPS);
            }
}
}
```
```java
class de.gurkenlabs.litiengine.environment.EntitySpawner {
protected void spawnNewEntities() {
    if (this.getSpawnMode() != SpawnMode.CUSTOMSPAWNPOINTS && this.getSpawnPoints().isEmpty()) {
      return;
    }

    switch (this.getSpawnMode()) {
      case ALLSPAWNPOINTS:
        for (int i = 0; i < this.getSpawnPoints().size(); i++) {
          final int index = i;
          Game.loop()
              .perform(
                  this.getSpawnDelay() + this.getSpawnDelay() * i,
                  () -> this.spawn(this.getSpawnPoints().get(index), this.getSpawnAmount()));
        }
        break;
      case ONERANDOMSPAWNPOINT:
        this.spawn(Game.random().choose(this.getSpawnPoints()), this.getSpawnAmount());
        break;
      case RANDOMSPAWNPOINTS:
        for (int i = 0; i < this.getSpawnAmount(); i++) {
          Game.loop()
              .perform(
                  this.getSpawnDelay() + this.getSpawnDelay() * i,
                  () -> this.spawn(Game.random().choose(this.getSpawnPoints()), 1));
        }
        break;
      case CUSTOMSPAWNPOINTS:
        List<Spawnpoint> spawnPoints =
            this.customSpawnpoints != null
                ? this.customSpawnpoints.apply(this)
                : this.getCustomSpawnpoints();

        int index = 0;
        for (Spawnpoint spawn : spawnPoints) {
          Game.loop()
              .perform(
                  this.getSpawnDelay() + this.getSpawnDelay() * index, () -> this.spawn(spawn, 1));
          index++;
        }
        break;
      default:
        break;
    }
}
}
```
```java
class de.gurkenlabs.litiengine.tweening.TweenEngine {
@Override
  public void start() {
    Game.loop().attach(this);
}@Override
  public void terminate() {
    Game.loop().detach(this);
}
}
```
```java
class de.gurkenlabs.litiengine.gui.SpeechBubble {
public void hide() {
    Game.world().environment().removeRenderable(this);
    Game.loop().detach(this);
    if (activeSpeechBubbles.get(this.getEntity()) != null
        && activeSpeechBubbles.remove(this.getEntity()).equals(this)) {
      activeSpeechBubbles.remove(this.getEntity());
    }

    for (SpeechBubbleListener listener : this.listeners) {
      listener.hidden();
    }
}private SpeechBubble(
      final IEntity entity,
      final String text,
      @Nullable SpeechBubbleAppearance appearance,
      @Nullable Font font) {
    if (appearance == null) {
      this.appearance = DEFAULT_APPEARANCE;
    } else {
      this.appearance = appearance;
    }

    final SpeechBubble active = activeSpeechBubbles.get(entity);
    if (active != null) {
      active.hide();
    }
    this.setFont(font);

    this.textBoxWidth = (float) (entity.getWidth() * 4);
    this.entity = entity;

    this.currentText = text;
    this.currentTextDisplayTime = DISPLAYTIME_MIN + text.length() * DISPLAYTIME_PER_LETTER;

    this.lastTextDisplay = Game.time().now();
    this.createBubbleImage();
    entity.getEnvironment().add(this, RenderType.UI);
    Game.loop().attach(this);
    activeSpeechBubbles.put(entity, this);
}
}
```
```java
class de.gurkenlabs.litiengine.entities.Prop {
private void updateAnimationController() {
    IEntityAnimationController<?> controller = this.createAnimationController();
    this.getControllers().addController(controller);
    if (Game.world().environment() != null && Game.world().environment().isLoaded()) {
      Game.loop().attach(controller);
    }
}
}
```
```java
class de.gurkenlabs.litiengine.graphics.FreeFlightCamera {
public FreeFlightCamera(final Point2D focus) {
    this.setFocus(focus);
    this.velocity = DEFAULT_SCROLL_PIXELS_PER_SECOND;
    this.scrollPadding = DEFAULT_SCROLL_PADDING;
    this.setClampToMap(true);

    Game.loop().attach(this);
}private void handleFreeFlightCamera() {
    if (Game.world().environment() == null || Game.world().environment().getMap() == null) {
      return;
    }

    final Point2D mouseLocation = Input.mouse().getLocation();

    final double scrollSpeed =
        this.getVelocity()
            / (double) Game.loop().getTickRate()
            * Game.config().input().getMouseSensitivity();

    double x = this.getFocus().getX();
    double y = this.getFocus().getY();

    double deltaX = 0;
    if (mouseLocation.getX() < this.getScrollPadding()) {
      deltaX -= scrollSpeed;
    } else if (Game.window().getResolution().getWidth() - mouseLocation.getX()
        < this.getScrollPadding()) {
      deltaX += scrollSpeed;
    }

    double deltaY = 0;
    if (mouseLocation.getY() < this.getScrollPadding()) {
      deltaY -= scrollSpeed;
    } else if (Game.window().getResolution().getHeight() - mouseLocation.getY()
        < this.getScrollPadding()) {
      deltaY += scrollSpeed;
    }

    x += deltaX;
    y += deltaY;

    this.setFocus(new Point2D.Double(x, y));
}
}
```
```java
class de.gurkenlabs.litiengine.environment.Environment {
private static void dispose(final Collection<? extends IEntity> entities) {
    for (final IEntity entity : entities) {
      if (entity instanceof IUpdateable) {
        Game.loop().detach((IUpdateable) entity);
      }

      entity.detachControllers();
    }
}private static void loadUpdatableOrEmitterEntity(IEntity entity) {
    if (entity instanceof Emitter) {
      final Emitter emitter = (Emitter) entity;
      if (emitter.isActivateOnInit()) {
        emitter.activate();
      }
    } else if (entity instanceof IUpdateable) {
      Game.loop().attach((IUpdateable) entity);
    }
}private void unload(final IEntity entity) {
    // 1. remove from physics engine
    if (entity instanceof ICollisionEntity) {
      Game.physics().remove((ICollisionEntity) entity);
    }

    // 2. unregister from update
    if (entity instanceof IUpdateable) {
      Game.loop().detach((IUpdateable) entity);
    }

    if (entity instanceof IMobileEntity) {
      this.removeGravity((IMobileEntity) entity);
    }

    // 3. detach all controllers
    entity.detachControllers();

    if (entity instanceof Emitter) {
      Emitter em = (Emitter) entity;
      em.deactivate();
    }

    if (this.loaded && (entity instanceof LightSource || entity instanceof StaticShadow)) {
      this.updateLighting(entity);
    }

    entity.removed(this);
}
}
```
```java
class de.gurkenlabs.litiengine.graphics.animation.Animation {
@Override
  public void update() {
    // do nothing if the animation is not playing or the current keyframe is not finished
    if (!this.isPlaying()
        || Game.time().since(this.lastFrameUpdate) < this.getCurrentKeyFrame().getDuration()) {
      return;
    }

    // if we are not looping and the last keyframe is finished, we terminate the animation
    if (!this.isLooping() && this.isLastKeyFrame()) {
      this.terminate();
      return;
    }

    // make sure, we stay inside the keyframe list
    final int newFrameIndex =
        (this.getKeyframes().indexOf(this.currentFrame) + 1) % this.getKeyframes().size();
    final KeyFrame previousFrame = this.currentFrame;
    this.currentFrame = this.getKeyframes().get(newFrameIndex);

    for (KeyFrameListener listener : this.listeners) {
      listener.currentFrameChanged(previousFrame, this.currentFrame);
    }

    this.lastFrameUpdate = Game.loop().getTicks();
}public void restart() {
    this.currentFrame = this.firstFrame;
    this.lastFrameUpdate = Game.loop().getTicks();
}
}
```
```java
class de.gurkenlabs.litiengine.physics.MovementController {
@Override
  public void attach() {
    Game.loop().attach(this);
}private void handleForces() {
    // clean up forces
    this.activeForces.forEach(
        x -> {
          if (x.hasEnded()) {
            this.activeForces.remove(x);
          }
        });

    if (this.activeForces.isEmpty()) {
      return;
    }

    // disable turn-on-move for force handling
    boolean turn = this.getEntity().turnOnMove();
    this.getEntity().setTurnOnMove(false);
    try {
      double deltaX = 0;
      double deltaY = 0;
      for (final Force force : this.activeForces) {
        if (force.cancelOnReached() && force.hasReached(this.getEntity())) {
          force.end();
          continue;
        }

        final Point2D collisionBoxCenter = this.getEntity().getCollisionBoxCenter();
        final double angle =
            GeometricUtilities.calcRotationAngleInDegrees(collisionBoxCenter, force.getLocation());
        final double strength =
            Game.loop().getDeltaTime() * 0.001f * force.getStrength() * Game.loop().getTimeScale();
        deltaX += GeometricUtilities.getDeltaX(angle, strength);
        deltaY += GeometricUtilities.getDeltaY(angle, strength);
      }

      final Point2D target =
          new Point2D.Double(this.getEntity().getX() + deltaX, this.getEntity().getY() + deltaY);
      final boolean success = Game.physics().move(this.getEntity(), target);
      if (!success) {
        for (final Force force : this.activeForces) {
          if (force.cancelOnCollision()) {
            force.end();
          }
        }
      }
    } finally {
      this.getEntity().setTurnOnMove(turn);
    }
}@Override
  public void detach() {
    Game.loop().detach(this);
}public void handleMovement() {
    if (!this.isMovementAllowed()) {
      this.velocity = 0;
      return;
    }

    // max distance an entity can travel within one tick
    final double maxPixelsPerTick = this.getEntity().getTickVelocity();
    final double deltaTime = Game.loop().getDeltaTime() * Game.loop().getTimeScale();

    final double acceleration =
        this.getEntity().getAcceleration() == 0
            ? maxPixelsPerTick
            : deltaTime / this.getEntity().getAcceleration() * maxPixelsPerTick;
    final double deceleration =
        this.getEntity().getDeceleration() == 0
            ? this.getVelocity()
            : deltaTime / this.getEntity().getDeceleration() * maxPixelsPerTick;

    double dx = this.getDx();
    double dy = this.getDy();
    this.setDx(0);
    this.setDy(0);

    final double deltaVelocity =
        Math.min(Math.sqrt(Math.pow(dx, 2) + Math.pow(dy, 2)), acceleration);
    if (deltaVelocity != 0) {
      double newVelocity = this.getVelocity() + deltaVelocity;
      this.setVelocity(newVelocity);
    } else {
      final double newVelocity = Math.max(0, this.getVelocity() - deceleration);
      this.setVelocity(newVelocity);
      dx = GeometricUtilities.getDeltaX(this.moveAngle);
      dy = GeometricUtilities.getDeltaY(this.moveAngle);
    }

    if (this.getVelocity() == 0) {
      this.moveAngle = 0;
      return;
    }

    // actually move entity
    this.moveEntity(dx, dy);
}
}
```
```java
class de.gurkenlabs.litiengine.graphics.animation.AnimationController {
public void detach() {
    Game.loop().detach(this);
}public void attach() {
    Game.loop().attach(this);
}
}
```
```java
class de.gurkenlabs.litiengine.graphics.Camera {
@Override
  public void setZoom(final float targetZoom, final int delay) {
    if (delay == 0) {

      this.zoom = targetZoom;
      this.targetZoom = 0;
      this.zoomDelay = 0;
      this.zoomTick = 0;
      this.zoomStep = 0;

      final ZoomChangedEvent event = new ZoomChangedEvent(this, targetZoom);
      for (final ZoomChangedListener listener : this.zoomListeners) {
        listener.zoomChanged(event);
      }
    } else {
      this.zoomTick = Game.time().now();
      this.targetZoom = targetZoom;
      this.zoomDelay = delay;

      final double tickduration = 1000 / (double) Game.loop().getTickRate();
      final double tickAmount = delay / tickduration;
      final float totalDelta = this.targetZoom - this.zoom;
      this.zoomStep = tickAmount > 0 ? (float) (totalDelta / tickAmount) : totalDelta;
    }
}
}
```
```java
class de.gurkenlabs.litiengine.Game {
public static synchronized void init(String... args) {
    if (initialized) {
      log().log(Level.INFO, "The game has already been initialized.");
      return;
    }

    log.init();
    handleCommandLineArguments(args);

    config().load();
    Locale.setDefault(new Locale(config().client().getCountry(), config().client().getLanguage()));

    gameLoop = new GameLoop("Main Update Loop", config().client().getMaxFps());
    loop().attach(physics());
    loop().attach(world());

    // setup default exception handling for render and update loop
    setUncaughtExceptionHandler(
        new DefaultUncaughtExceptionHandler(config().client().exitOnError()));

    screenManager = new ScreenManager();
    gameWindow = new GameWindow();

    // initialize  the game window
    window().init();
    world.setCamera(new Camera());

    for (GameListener listener : gameListeners) {
      listener.initialized(args);
    }

    if (!isInNoGUIMode()) {
      window().getRenderComponent().onRendered(g -> metrics().render(g));

      graphics()
          .addEntityRenderedListener(
              e -> DebugRenderer.renderEntityDebugInfo(e.getGraphics(), e.getEntity()));

      window().getRenderComponent().onFpsChanged(fps -> metrics().setFramesPerSecond(fps));
      window()
          .setIcons(
              Arrays.asList(
                  Resources.images().get("liti-logo-x16.png"),
                  Resources.images().get("liti-logo-x20.png"),
                  Resources.images().get("liti-logo-x32.png"),
                  Resources.images().get("liti-logo-x48.png")));

      Input.keyboard()
          .onKeyTyped(
              KeyEvent.VK_PRINTSCREEN,
              key -> {
                // don't take a screenshot if a modifier is active
                if (key.getModifiers() != 0) {
                  return;
                }

                window().getRenderComponent().takeScreenshot();
              });
    }

    Runtime.getRuntime().addShutdownHook(new Thread(Game::terminate, "Shutdown"));

    initialized = true;
}
}
```
```java
class de.gurkenlabs.litiengine.entities.Creature {
protected void updateAnimationController() {
    IEntityAnimationController<?> controller = this.createAnimationController();
    this.getControllers().addController(controller);
    if (Game.world().environment() != null && Game.world().environment().isLoaded()) {
      Game.loop().attach(controller);
    }
}@Override
  public float getTickVelocity() {
    // pixels per ms multiplied by the passed ms
    // ensure that entities don't travel too far in case of lag
    return Math.min(Game.loop().getDeltaTime(), GameLoop.TICK_DELTATIME_LAG)
        * 0.001F
        * this.getVelocity().get()
        * Game.loop().getTimeScale();
}
}
```
Depth: 2
```java
class de.gurkenlabs.litiengine.environment.GameWorld {
public void clear() {
    this.unloadEnvironment();
    this.environments.clear();
    this.setCamera(null);
    Game.physics().clear();

    this.environmentListeners.clear();
    this.environmentLoadedListeners.clear();
    this.environmentUnloadedListeners.clear();

    this.listeners.clear();
    this.loadedListeners.clear();
    this.unloadedListeners.clear();
}@Nullable
  public Environment loadEnvironment(IMap map) {
    Environment env = this.getEnvironment(map);
    this.loadEnvironment(env);
    return env;
}@Nullable
  public Environment loadEnvironment(String mapName) {
    Environment env = this.getEnvironment(mapName);
    this.loadEnvironment(env);
    return env;
}
}
```
```java
class de.gurkenlabs.litiengine.GameWindow {
GameWindow() {
    this.hostControl = new JFrame();

    this.resolutionChangedListeners = new CopyOnWriteArrayList<>();

    this.renderCanvas = new RenderComponent(Game.config().graphics().getResolution());
    this.cursor = new MouseCursor();
    if (!Game.isInNoGUIMode()) {
      this.hostControl.setBackground(Color.BLACK);
      this.hostControl.add(this.renderCanvas);

      this.initializeEventListeners();

      this.hostControl.setTitle(Game.info().getTitle());
      this.hostControl.setDefaultCloseOperation(WindowConstants.DO_NOTHING_ON_CLOSE);
      initializeWindowEventListeners(this.hostControl);
    }
}
}
```
```java
class de.gurkenlabs.litiengine.GameTime {
public long sinceEnvironmentLoad() {
    return this.since(this.environmentLoaded);
}public long since(final long tick) {
    return toMilliseconds(Game.loop().getTicks() - tick);
}public long sinceGameStart() {
    return this.toMilliseconds(Game.loop().getTicks());
}
}
```
```java
class de.gurkenlabs.litiengine.abilities.effects.Effect {
protected void cease(final EffectApplication appliance) {
    // 1. cease the effect for all affected entities
    for (final ICombatEntity entity : appliance.getAffectedEntities()) {
      this.cease(entity);
    }

    // 2. apply follow up effects
    this.getFollowUpEffects().forEach(followUp -> followUp.apply(appliance.getImpactArea()));
}protected boolean hasEnded(final EffectApplication appliance) {
    final long effectDuration = Game.time().since(appliance.getAppliedTicks());
    return effectDuration > this.getDuration();
}
}
```
```java
class de.gurkenlabs.litiengine.abilities.effects.EffectApplication {
protected EffectApplication(final List<ICombatEntity> affectedEntities, final Shape impactArea) {
    this.applied = Game.time().now();
    this.affectedEntities = affectedEntities;
    this.impactArea = impactArea;
}
}
```
```java
class de.gurkenlabs.litiengine.entities.CombatEntity {
@Override
  public boolean wasHit(int timeSpan) {
    return Game.time().since(this.lastHit) < timeSpan;
}@Override
  public void hit(final int damage, @Nullable final Ability ability) {
    if (this.isDead()) {
      return;
    }

    if (!this.isIndestructible()) {
      this.getHitPoints().modifyBaseValue(new AttributeModifier<>(Modification.SUBTRACT, damage));
    }

    final EntityHitEvent event = new EntityHitEvent(this, ability, damage, this.isDead());

    for (final CombatEntityListener listener : this.listeners) {
      listener.hit(event);
    }

    for (final CombatEntityHitListener listener : this.hitListeners) {
      listener.hit(event);
    }

    if (this.isDead()) {
      this.fireDeathEvent();
      this.setCollision(false);
    }

    this.lastHit = Game.time().now();
}
}
```
```java
class de.gurkenlabs.litiengine.graphics.ImageEffect {
protected ImageEffect(final int ttl, final String name) {
    this.ttl = ttl;
    this.name = name;
    this.aliveTick = Game.time().now();
}@Override
  public long getAliveTime() {
    return Game.time().since(this.aliveTick);
}
}
```
```java
class de.gurkenlabs.litiengine.abilities.AbilityExecution {
AbilityExecution(final Ability ability) {
    this.appliedEffects = new CopyOnWriteArrayList<>();
    this.ability = ability;
    this.executionTicks = Game.time().now();
    this.impactArea = ability.calculateImpactArea();
    this.castLocation = ability.getExecutor().getCenter();
    Game.loop().attach(this);
}@Override
  public void update() {
    // if there a no effects to apply -> unregister this instance and we're done
    if (this.getAbility().getEffects().isEmpty()
        || this.getAbility().getEffects().size() == this.getAppliedEffects().size()) {
      Game.loop().detach(this);
      return;
    }

    // handle all effects from the ability that were not applied yet
    for (final Effect effect : this.getAbility().getEffects()) {
      // if the ability was not executed yet or the delay of the effect is not
      // yet reached
      if (this.getAppliedEffects().contains(effect)
          || Game.time().since(this.getExecutionTicks()) < effect.getDelay()) {
        continue;
      }

      effect.apply(this.getExecutionImpactArea());
      this.getAppliedEffects().add(effect);
    }
}
}
```
```java
class de.gurkenlabs.litiengine.tweening.TweenEngine {
@Override
  public void update() {
    for (final Tweenable target : this.getTweens().keySet()) {
      for (final Tween tween : this.getTweens().get(target).values()) {
        if (tween.hasStopped()) {
          continue;
        }
        final long elapsed = Game.time().since(tween.getStartTime());
        if (elapsed >= tween.getDuration()) {
          tween.stop();
          continue;
        }
        final float[] currentValues = new float[tween.getTargetValues().length];
        for (int i = 0; i < tween.getTargetValues().length; i++) {
          currentValues[i] =
              tween.getStartValues()[i]
                  + tween.getEquation().compute(elapsed / (float) tween.getDuration())
                      * (tween.getTargetValues()[i] - tween.getStartValues()[i]);
        }
        tween.getTarget().setTweenValues(tween.getType(), currentValues);
      }
    }
}
}
```
```java
class de.gurkenlabs.litiengine.gui.SpeechBubble {
public static SpeechBubble create(
      final IEntity entity, final String text, SpeechBubbleAppearance appearance, Font font) {
    return new SpeechBubble(entity, text, appearance, font);
}public static SpeechBubble create(final IEntity entity, final Font font, final String text) {
    SpeechBubbleAppearance app =
        new SpeechBubbleAppearance(
            DEFAULT_APPEARANCE.getForeColor(),
            DEFAULT_APPEARANCE.getBackgroundColor1(),
            DEFAULT_APPEARANCE.getBorderColor(),
            DEFAULT_APPEARANCE.getPadding());
    return new SpeechBubble(entity, text, app, font);
}public static SpeechBubble create(final IEntity entity, final String text) {
    return new SpeechBubble(entity, text, null, GuiProperties.getDefaultFont());
}@Override
  public void update() {
    if (this.currentText == null) {
      this.hide();
      return;
    }

    this.entityCenter = Game.world().camera().getViewportLocation(this.getEntity().getCenter());

    // old text was displayed long enough
    if (this.lastTextDisplay != 0
        && Game.time().since(this.lastTextDisplay) > this.currentTextDisplayTime) {
      this.currentText = null;
      this.lastTextDisplay = 0;
      return;
    }

    // display new text
    if (this.textIndex < this.currentText.length()
        && Game.time().since(this.lastCharPoll) > LETTER_WRITE_DELAY) {
      this.textIndex++;
      this.lastCharPoll = Game.time().now();
      if (this.typeSound != null) {
        Game.audio().playSound(this.typeSound, this.getEntity());
      }
    }

    // continue displaying currently displayed text
}private SpeechBubble(
      final IEntity entity,
      final String text,
      final Sound typeSound,
      SpeechBubbleAppearance appearance,
      Font font) {
    this(entity, text, appearance, font);
    this.typeSound = typeSound;
}private SpeechBubble(
      final IEntity entity,
      final String text,
      @Nullable SpeechBubbleAppearance appearance,
      @Nullable Font font) {
    if (appearance == null) {
      this.appearance = DEFAULT_APPEARANCE;
    } else {
      this.appearance = appearance;
    }

    final SpeechBubble active = activeSpeechBubbles.get(entity);
    if (active != null) {
      active.hide();
    }
    this.setFont(font);

    this.textBoxWidth = (float) (entity.getWidth() * 4);
    this.entity = entity;

    this.currentText = text;
    this.currentTextDisplayTime = DISPLAYTIME_MIN + text.length() * DISPLAYTIME_PER_LETTER;

    this.lastTextDisplay = Game.time().now();
    this.createBubbleImage();
    entity.getEnvironment().add(this, RenderType.UI);
    Game.loop().attach(this);
    activeSpeechBubbles.put(entity, this);
}
}
```
```java
class de.gurkenlabs.litiengine.gui.TextFieldComponent {
@Override
  public void render(final Graphics2D g) {
    super.render(g);
    g.setFont(this.getFont());
    final FontMetrics fm = g.getFontMetrics();

    if (this.isSelected() && Game.time().since(this.lastToggled) > this.flickerDelay) {
      this.cursorVisible = !this.cursorVisible;
      this.lastToggled = Game.time().now();
    }
    if (this.isSelected() && this.cursorVisible) {
      final Rectangle2D cursor =
          new Rectangle2D.Double(
              this.getX() + this.getTextX() + fm.stringWidth(this.getTextToRender(g)),
              this.getY() + this.getTextY(),
              this.getFont().getSize2D() * 3 / 5,
              this.getFont().getSize2D() * 1 / 5);
      g.setColor(this.getAppearance().getForeColor());
      g.fill(cursor);
    }
}
}
```
```java
class de.gurkenlabs.litiengine.entities.Prop {
public Prop(
      final Point2D location, @Nullable final String spritesheetName, final Material material) {
    super();
    this.rotation = Rotation.NONE;
    this.spritesheetName = spritesheetName;
    this.material = material;
    this.setLocation(location);
    this.updateAnimationController();
}public void setSpritesheetName(@Nullable final String spriteName) {
    this.spritesheetName = spriteName;
    this.updateAnimationController();
}
}
```
```java
class de.gurkenlabs.litiengine.tweening.Tween {
public Tween begin() {
    this.started = Game.time().now();
    this.stopped = false;
    return this;
}
}
```
```java
class de.gurkenlabs.litiengine.graphics.emitters.particles.Particle {
public void update(final Point2D emitterOrigin, final float updateRatio) {
    if (this.aliveTick == 0) {
      this.aliveTick = Game.time().now();
    }

    this.aliveTime = Game.time().since(this.aliveTick);
    if (this.timeToLiveReached()) {
      return;
    }

    if (this.colliding) {
      return;
    }

    if (this.getDeltaWidth() != 0) {
      this.width += this.getDeltaWidth() * updateRatio;
    }

    if (this.getDeltaHeight() != 0) {
      this.height += this.getDeltaHeight() * updateRatio;
    }

    if (this.getDeltaAngle() != 0) {
      this.angle += this.getDeltaAngle() * updateRatio;
    }

    // test for ray cast collision
    final float targetX = this.x + this.getVelocityX() * updateRatio;
    final float targetY = this.y + this.getVelocityY() * updateRatio;

    if (targetX == this.x && targetY == this.y) {
      return;
    }

    if (this.checkForCollision(emitterOrigin, targetX, targetY)) {
      return;
    }

    if (this.getVelocityX() != 0) {
      this.x = targetX;
    }

    if (this.getVelocityY() != 0) {
      this.y = targetY;
    }

    if (this.getAccelerationX() != 0) {
      this.velocityX += this.getAccelerationX() * updateRatio;
    }

    if (this.getAccelerationY() != 0) {
      this.velocityY += this.getAccelerationY() * updateRatio;
    }
}
}
```
```java
class de.gurkenlabs.litiengine.graphics.animation.Animation {
@Override
  public void start() {
    this.playing = true;
    if (this.getKeyframes().isEmpty()) {
      return;
    }

    this.restart();
}@Override
  public void update() {
    // do nothing if the animation is not playing or the current keyframe is not finished
    if (!this.isPlaying()
        || Game.time().since(this.lastFrameUpdate) < this.getCurrentKeyFrame().getDuration()) {
      return;
    }

    // if we are not looping and the last keyframe is finished, we terminate the animation
    if (!this.isLooping() && this.isLastKeyFrame()) {
      this.terminate();
      return;
    }

    // make sure, we stay inside the keyframe list
    final int newFrameIndex =
        (this.getKeyframes().indexOf(this.currentFrame) + 1) % this.getKeyframes().size();
    final KeyFrame previousFrame = this.currentFrame;
    this.currentFrame = this.getKeyframes().get(newFrameIndex);

    for (KeyFrameListener listener : this.listeners) {
      listener.currentFrameChanged(previousFrame, this.currentFrame);
    }

    this.lastFrameUpdate = Game.loop().getTicks();
}
}
```
```java
class de.gurkenlabs.litiengine.graphics.animation.AnimationController {
@Override
  public void update() {
    for (final Animation animation : this.getAll()) {
      animation.update();
    }

    if (this.getCurrent() != null && this.getCurrent().isPaused()) {
      return;
    }

    final boolean playbackFinished = this.getCurrent() != null && !this.getCurrent().isPlaying();
    if (playbackFinished) {
      for (final AnimationListener listener : this.listeners) {
        listener.finished(this.getCurrent());
      }
    }

    if (this.getCurrent() == null || playbackFinished) {
      if (this.getDefault() != null) {
        this.play(this.getDefault().getName());
      } else {
        this.currentAnimation = null;
      }
    }
}
}
```
```java
class de.gurkenlabs.litiengine.graphics.RenderComponent {
private void handleFade() {
    if (this.fadeOutStart != -1) {
      final long timePassed = Game.time().since(this.fadeOutStart);
      this.currentAlpha = MathUtilities.clamp(1 - timePassed / (float) this.fadeOutTime, 0, 1);
      if (this.currentAlpha == 0f) {
        this.fadeOutStart = -1;
        this.fadeOutTime = -1;
      }

      return;
    }

    if (this.fadeInStart != -1) {
      final long timePassed = Game.time().since(this.fadeInStart);
      this.currentAlpha = MathUtilities.clamp(timePassed / (float) this.fadeInTime, 0, 1);
      if (this.currentAlpha == 1f) {
        this.fadeInStart = -1;
        this.fadeInTime = -1;
        this.currentAlpha = Float.NaN;
      }
    }
}public void fadeOut(final int ms) {
    this.fadeInStart = -1;
    this.fadeInTime = -1;
    this.fadeOutStart = Game.time().now();
    this.fadeOutTime = ms;
}public void fadeIn(final int ms) {
    this.fadeOutStart = -1;
    this.fadeOutTime = -1;
    this.fadeInStart = Game.time().now();
    this.fadeInTime = ms;
}
}
```
```java
class de.gurkenlabs.litiengine.entities.Trigger {
private boolean activate(final IEntity activator, final int tar) {
    if (!this.isLoaded()
        || this.isOneTimeTrigger && this.isActivated
        || this.getActivationType() == TriggerActivation.COLLISION
            && activator != null
            && this.collisionActivated.contains(activator)) {
      return false;
    }

    if (this.getCooldown() > 0 && Game.time().since(this.lastActivation) < this.getCooldown()) {
      return false;
    }

    List<Integer> triggerTargets = this.getTargets(tar);

    final TriggerEvent te = new TriggerEvent(this, activator, triggerTargets);

    if (!this.checkActivationPredicates(te)) {
      return false;
    }

    this.isActivated = true;
    if (activator != null) {
      this.collisionActivated.add(activator);
    }

    // if we actually have a trigger target, we send the message to the target
    for (final int target : triggerTargets) {
      final IEntity entity = this.getEnvironment().get(target);
      if (entity == null) {
        log.log(
            Level.WARNING,
            "trigger [{0}] was activated, but the trigger target [{1}] could not be found on the environment",
            new Object[] {this, target});
        continue;
      }

      entity.sendMessage(this, this.message);
    }

    // also send the trigger event to all registered consumers
    for (final TriggerActivatedListener listener : this.activatedListeners) {
      listener.activated(te);
    }

    if (this.isOneTimeTrigger) {
      this.getEnvironment().remove(this);
    }

    this.lastActivation = Game.time().now();
    return true;
}
}
```
```java
class de.gurkenlabs.litiengine.graphics.Camera {
private boolean isShakeEffectActive() {
    return this.getShakeTick() != 0
        && Game.time().since(this.getShakeTick()) < this.getShakeDuration();
}@Override
  public void update() {
    if (Game.world().camera() != null && !Game.world().camera().equals(this)) {
      return;
    }

    if (this.targetZoom > 0) {
      if (Game.time().since(this.zoomTick) >= this.zoomDelay) {
        this.zoom = this.targetZoom;
        this.targetZoom = 0;
        this.zoomDelay = 0;
        this.zoomTick = 0;
        this.zoomStep = 0;
      } else {
        this.zoom += this.zoomStep;
      }

      final ZoomChangedEvent event = new ZoomChangedEvent(this, this.getZoom());
      for (final ZoomChangedListener listener : this.zoomListeners) {
        listener.zoomChanged(event);
      }
    }

    if (this.panTime > 0) {
      if (--this.panTime <= 0) {
        this.setFocus(this.targetFocus);
        this.targetFocus = null;
      } else {
        double diff = this.panTime / (this.panTime + 1.0);
        this.focus =
            new Point2D.Double(
                this.focus.getX() * diff + this.targetFocus.getX() * (1.0 - diff),
                this.focus.getY() * diff + this.targetFocus.getY() * (1.0 - diff));
      }
    }

    if (!this.isShakeEffectActive()) {
      this.shakeOffsetX = 0;
      this.shakeOffsetY = 0;
      return;
    }

    if (Game.time().since(this.lastShake) > this.shakeDelay) {
      this.shakeOffsetX = this.getShakeIntensity() * ThreadLocalRandom.current().nextGaussian();
      this.shakeOffsetY = this.getShakeIntensity() * ThreadLocalRandom.current().nextGaussian();
      this.lastShake = Game.time().now();
    }
}@Override
  public void setZoom(final float targetZoom, final int delay) {
    if (delay == 0) {

      this.zoom = targetZoom;
      this.targetZoom = 0;
      this.zoomDelay = 0;
      this.zoomTick = 0;
      this.zoomStep = 0;

      final ZoomChangedEvent event = new ZoomChangedEvent(this, targetZoom);
      for (final ZoomChangedListener listener : this.zoomListeners) {
        listener.zoomChanged(event);
      }
    } else {
      this.zoomTick = Game.time().now();
      this.targetZoom = targetZoom;
      this.zoomDelay = delay;

      final double tickduration = 1000 / (double) Game.loop().getTickRate();
      final double tickAmount = delay / tickduration;
      final float totalDelta = this.targetZoom - this.zoom;
      this.zoomStep = tickAmount > 0 ? (float) (totalDelta / tickAmount) : totalDelta;
    }
}@Override
  public void shake(final double intensity, final int delay, final int shakeDuration) {
    this.shakeTick = Game.time().now();
    this.shakeDelay = delay;
    this.shakeIntensity = intensity;
    this.shakeDuration = shakeDuration;
}
}
```
```java
class de.gurkenlabs.litiengine.entities.Creature {
public void setSpritesheetName(String spritesheetName) {
    if (this.spritesheetName != null && this.spritesheetName.equals(spritesheetName)) {
      return;
    }

    this.spritesheetName = spritesheetName;
    this.updateAnimationController();
}public boolean isIdle() {
    return Game.time().since(this.lastMoved) > IDLE_DELAY;
}@Override
  public void setLocation(final Point2D position) {
    if (this.isDead() || position == null) {
      return;
    }

    final Point2D oldLocation = this.getLocation();
    super.setLocation(position);

    if (Game.hasStarted() && this.isLoaded()) {
      this.lastMoved = Game.time().now();
      this.fireMovedEvent(
          new EntityMovedEvent(
              this, this.getX() - oldLocation.getX(), this.getY() - oldLocation.getY()));
    }
}
}
```
```java
class de.gurkenlabs.litiengine.gui.screens.ScreenManager {
public void display(final String screenName) {
    if (this.current() != null && this.current().getName().equalsIgnoreCase(screenName)) {
      log.log(
          Level.INFO,
          "Skipping displaying of screen {0} because it is already the current screen.",
          screenName);
      return;
    }

    if (this.screens.stream()
        .noneMatch(element -> element.getName().equalsIgnoreCase(screenName))) {
      log.log(
          Level.WARNING,
          "Could not display the screen {0} because there is no screen with the specified name.",
          screenName);
      return;
    }

    Screen screen = this.get(screenName);
    if (screen == null) {
      return;
    }

    this.display(screen);
}public void add(final Screen screen) {
    screen.setWidth(Game.window().getWidth());
    screen.setHeight(Game.window().getHeight());
    this.screens.add(screen);

    if (this.current() == null) {
      this.display(screen);
    }
}public void remove(Screen screen) {
    this.screens.remove(screen);
    if (this.current() == screen) {
      if (!this.screens.isEmpty()) {
        this.display(this.screens.get(0));
      } else {
        this.display((Screen) null);
      }
    }
}public void display(@Nullable final Screen screen) {
    if (Game.hasStarted() && Game.time().since(this.lastScreenChange) < this.getChangeCooldown()) {
      log.log(
          Level.INFO,
          "Skipping displaying of screen {0} because screen changing is currently on cooldown.",
          screen != null ? screen.getName() : "");
      return;
    }

    final Screen previous = this.current();
    if (previous != null) {
      previous.suspend();
    }

    if (screen != null && !this.screens.contains(screen)) {
      this.screens.add(screen);
    }

    this.currentScreen = screen;
    if (!Game.isInNoGUIMode() && this.current() != null) {
      this.current().prepare();
    }

    this.lastScreenChange = Game.loop().getTicks();

    final ScreenChangedEvent event = new ScreenChangedEvent(this.current(), previous);
    for (final ScreenChangedListener listener : this.screenChangedListeners) {
      listener.changed(event);
    }
}
}
```
```java
class de.gurkenlabs.litiengine.abilities.Ability {
public boolean isOnCooldown() {
    return (this.getCurrentExecution() != null
        && this.getCurrentExecution().getExecutionTicks() > 0
        && Game.time().since(this.getCurrentExecution().getExecutionTicks())
            < this.getAttributes().cooldown().get());
}public boolean isActive() {
    return this.getCurrentExecution() != null
        && Game.time().since(this.getCurrentExecution().getExecutionTicks())
            < this.getAttributes().duration().get();
}@Nullable
  public AbilityExecution cast() {
    if (!this.canCast()) {
      return null;
    }
    this.currentExecution = new AbilityExecution(this);

    for (final AbilityCastListener listener : this.abilityCastListeners) {
      listener.abilityCast(this.currentExecution);
    }

    return this.getCurrentExecution();
}public float getRemainingCooldownInSeconds() {
    if (this.getCurrentExecution() == null
        || this.getExecutor() == null
        || this.getExecutor().isDead()) {
      return 0;
    }

    // calculate cooldown in seconds
    return (float)
        (!this.canCast()
            ? (this.getAttributes().cooldown().get()
                    - Game.time().since(this.getCurrentExecution().getExecutionTicks()))
                * 0.001
            : 0);
}
}
```
```java
class de.gurkenlabs.litiengine.entities.EntityHitEvent {
EntityHitEvent(
      final ICombatEntity hitEntity,
      @Nullable final Ability ability,
      final int damage,
      final boolean kill) {
    super(hitEntity);
    this.executor = ability != null ? ability.getExecutor() : null;
    this.hitEntity = hitEntity;
    this.ability = ability;
    this.damage = damage;
    this.kill = kill;
    this.time = Game.time().now();
}
}
```
```java
class de.gurkenlabs.litiengine.graphics.emitters.Emitter {
public void delete() {
    this.deactivate();
    if (Game.world().environment() != null) {
      Game.world().environment().remove(this);
    }
}public void activate() {
    if (this.activated) {
      return;
    }

    this.activated = true;
    this.activationTick = Game.time().now();
    Game.loop().attach(this);
}@Override
  public void update() {
    if (this.isPaused()) {
      return;
    }

    // clear particles if the effect time to life is reached
    if (this.isFinished()) {
      for (EmitterFinishedListener listener : this.finishedListeners) {
        listener.finished(this);
      }

      this.delete();
      return;
    }

    final float updateRatio = (float) this.data().getUpdateRate() / Game.loop().getTickRate();
    for (final Particle p : this.getParticles().stream().collect(Collectors.toList())) {
      if (this.particleCanBeRemoved(p)) {
        // remove dead particles
        this.particles.remove(p);
        continue;
      }

      p.update(this.getOrigin(), updateRatio);
    }

    this.aliveTime = Game.time().since(this.activationTick);
    if ((this.data().getSpawnRate() == 0
        || Game.time().since(this.lastSpawn) >= this.data().getSpawnRate())) {
      this.lastSpawn = Game.time().now();
      this.spawnParticle();
    }
}
}
```
```java
class de.gurkenlabs.litiengine.GameLoop {
@Override
  public int perform(int delay, Runnable action) {
    final long d = Game.time().toTicks(delay);

    TimedAction a = new TimedAction(this.getTicks() + d, action);
    this.actions.add(a);

    return a.getId();
}
}
```
```java
class de.gurkenlabs.litiengine.environment.EntitySpawner {
protected boolean shouldSpawn() {
    return this.lastSpawnWave == 0
        || Game.time().since(this.lastSpawnWave) >= this.getSpawnInterval();
}@Override
  public void update() {
    if (!this.shouldSpawn()) {
      return;
    }

    this.spawnNewEntities();
    this.lastSpawnWave = Game.time().now();
}
}
```
```java
class de.gurkenlabs.litiengine.graphics.FreeFlightCamera {
@Override
  public void update() {
    this.handleFreeFlightCamera();
}public FreeFlightCamera(double x, double y) {
    this(new Point2D.Double(x, y));
}
}
```
```java
class de.gurkenlabs.litiengine.environment.Environment {
public void unload() {
    if (!this.loaded) {
      return;
    }

    // unregister all updatable entities from the current environment
    for (final IEntity entity : this.allEntities.values()) {
      this.unload(entity);
    }

    this.loaded = false;
    this.fireEvent(l -> l.unloaded(this));
}private static void loadUpdatableOrEmitterEntity(IEntity entity) {
    if (entity instanceof Emitter) {
      final Emitter emitter = (Emitter) entity;
      if (emitter.isActivateOnInit()) {
        emitter.activate();
      }
    } else if (entity instanceof IUpdateable) {
      Game.loop().attach((IUpdateable) entity);
    }
}public void clear() {
    Game.physics().clear();

    this.combatEntities.clear();
    this.mobileEntities.clear();
    this.gravityForces.clear();
    this.layerEntities.clear();
    this.entitiesByTag.clear();
    this.allEntities.clear();

    for (RenderType renderType : RenderType.values()) {
      this.miscEntities.get(renderType).clear();
      this.renderListeners.get(renderType).clear();
      this.renderables.get(renderType).clear();
    }

    dispose(this.allEntities.values());
    dispose(this.triggers);
    this.emitters.clear();
    this.colliders.clear();
    this.props.clear();
    this.creatures.clear();
    this.staticShadows.clear();
    this.combatEntities.clear();
    this.mobileEntities.clear();
    this.lightSources.clear();
    this.spawnPoints.clear();
    this.soundSources.clear();
    this.mapAreas.clear();
    this.triggers.clear();

    this.ambientLight = null;
    this.staticShadowLayer = null;

    for (Map<Integer, IEntity> type : this.miscEntities.values()) {
      type.clear();
    }

    this.initialized = false;

    this.fireEvent(l -> l.cleared(this));
}private void load(final IEntity entity) {
    // an entity can only exist on one environment at a time, so remove it from the current one
    if (entity.getEnvironment() != null) {
      entity.getEnvironment().remove(entity);
    }

    // 1. add to physics engine
    loadPhysicsEntity(entity);

    // 2. register for update or activate
    loadUpdatableOrEmitterEntity(entity);

    // 3. if a gravity is defined, add a gravity force to the entity
    if (entity instanceof IMobileEntity && this.getGravity() != 0) {
      this.addGravityForce((IMobileEntity) entity);
    }

    // 4. attach all controllers
    entity.attachControllers();

    if (this.loaded && (entity instanceof LightSource || entity instanceof StaticShadow)) {
      this.updateLighting(entity);
    }

    entity.loaded(this);
}private void unload(final IEntity entity) {
    // 1. remove from physics engine
    if (entity instanceof ICollisionEntity) {
      Game.physics().remove((ICollisionEntity) entity);
    }

    // 2. unregister from update
    if (entity instanceof IUpdateable) {
      Game.loop().detach((IUpdateable) entity);
    }

    if (entity instanceof IMobileEntity) {
      this.removeGravity((IMobileEntity) entity);
    }

    // 3. detach all controllers
    entity.detachControllers();

    if (entity instanceof Emitter) {
      Emitter em = (Emitter) entity;
      em.deactivate();
    }

    if (this.loaded && (entity instanceof LightSource || entity instanceof StaticShadow)) {
      this.updateLighting(entity);
    }

    entity.removed(this);
}public void remove(final IEntity entity) {
    if (entity == null) {
      return;
    }

    this.allEntities.remove(entity.getMapId());
    Iterator<List<IEntity>> iter = this.layerEntities.values().iterator();
    while (iter.hasNext()) {
      List<IEntity> layer = iter.next();
      if (layer.remove(entity) && layer.isEmpty()) {
        iter.remove();
      }
    }
    if (this.miscEntities.get(entity.getRenderType()) != null) {
      this.miscEntities.get(entity.getRenderType()).values().remove(entity);
    }

    for (String tag : entity.getTags()) {
      if (this.getEntitiesByTag().containsKey(tag)) {
        this.getEntitiesByTag().get(tag).remove(entity);

        if (this.getEntitiesByTag().get(tag).isEmpty()) {
          this.getEntitiesByTag().remove(tag);
        }
      }
    }

    if (entity instanceof Emitter) {
      Emitter emitter = (Emitter) entity;
      this.removeEmitter(emitter);
    }

    if (entity instanceof MapArea) {
      this.mapAreas.remove(entity);
    }

    if (entity instanceof Prop) {
      this.props.remove(entity);
    }

    if (entity instanceof Creature) {
      this.creatures.remove(entity);
    }

    if (entity instanceof CollisionBox) {
      this.colliders.remove(entity);
      this.staticShadows.removeIf(x -> x.getOrigin() != null && x.getOrigin().equals(entity));
    }

    if (entity instanceof LightSource) {
      this.lightSources.remove(entity);
      this.updateLighting(entity);
    }

    if (entity instanceof Trigger) {
      this.triggers.remove(entity);
    }

    if (entity instanceof Spawnpoint) {
      this.spawnPoints.remove(entity);
    }
    if (entity instanceof SoundSource) {
      this.soundSources.remove(entity);
    }

    if (entity instanceof StaticShadow) {
      this.staticShadows.remove(entity);
      this.updateLighting(entity);
    }

    if (entity instanceof IMobileEntity) {
      this.mobileEntities.values().remove(entity);
    }

    if (entity instanceof ICombatEntity) {
      this.combatEntities.values().remove(entity);
    }

    this.unload(entity);

    this.fireEntityEvent(l -> l.entityRemoved(entity));
}
}
```
```java
class de.gurkenlabs.litiengine.physics.MovementController {
@Override
  public void update() {
    this.handleForces();
    this.handleMovement();
}
}
```
```java
class de.gurkenlabs.litiengine.Game {
static synchronized void terminate() {
    if (!initialized) {
      return;
    }

    hasStarted = false;
    initialized = false;

    config().save();
    gameLoop.terminate();
    tweenEngine.terminate();
    soundEngine.terminate();

    world().clear();

    for (final GameListener listener : gameListeners) {
      try {
        listener.terminated();
      } catch (Exception e) {
        log().log(Level.WARNING, "game listener threw an exception during shutdown", e);
      }
    }

    gameLoop = null;
    screenManager = null;
    gameWindow = null;
}public static synchronized void start() {
    if (!initialized) {
      throw new IllegalStateException(
          "The game cannot be started without being first initialized. Call Game.init(...) before Game.start().");
    }

    gameLoop.start();
    tweenEngine.start();
    soundEngine.start();

    for (final GameListener listener : gameListeners) {
      listener.started();
    }

    hasStarted = true;
}public static synchronized void init(String... args) {
    if (initialized) {
      log().log(Level.INFO, "The game has already been initialized.");
      return;
    }

    log.init();
    handleCommandLineArguments(args);

    config().load();
    Locale.setDefault(new Locale(config().client().getCountry(), config().client().getLanguage()));

    gameLoop = new GameLoop("Main Update Loop", config().client().getMaxFps());
    loop().attach(physics());
    loop().attach(world());

    // setup default exception handling for render and update loop
    setUncaughtExceptionHandler(
        new DefaultUncaughtExceptionHandler(config().client().exitOnError()));

    screenManager = new ScreenManager();
    gameWindow = new GameWindow();

    // initialize  the game window
    window().init();
    world.setCamera(new Camera());

    for (GameListener listener : gameListeners) {
      listener.initialized(args);
    }

    if (!isInNoGUIMode()) {
      window().getRenderComponent().onRendered(g -> metrics().render(g));

      graphics()
          .addEntityRenderedListener(
              e -> DebugRenderer.renderEntityDebugInfo(e.getGraphics(), e.getEntity()));

      window().getRenderComponent().onFpsChanged(fps -> metrics().setFramesPerSecond(fps));
      window()
          .setIcons(
              Arrays.asList(
                  Resources.images().get("liti-logo-x16.png"),
                  Resources.images().get("liti-logo-x20.png"),
                  Resources.images().get("liti-logo-x32.png"),
                  Resources.images().get("liti-logo-x48.png")));

      Input.keyboard()
          .onKeyTyped(
              KeyEvent.VK_PRINTSCREEN,
              key -> {
                // don't take a screenshot if a modifier is active
                if (key.getModifiers() != 0) {
                  return;
                }

                window().getRenderComponent().takeScreenshot();
              });
    }

    Runtime.getRuntime().addShutdownHook(new Thread(Game::terminate, "Shutdown"));

    initialized = true;
}
}
```


Response Format:
Provide the answer in **XML format** as follows:

#### If the method **cannot** return `null` at the specific call site:
```xml
<response>
  <reason><![CDATA[EXPLAIN WHY THE INVOCATION Game.loop() RESULT CANNOT BE NULL.]]></reason>
  <value>NO</value>
</response>

#### If the method can return null at the specific call site:
<response>
  <reason><![CDATA[EXPLAIN WHY THE INVOCATION Game.loop() RESULT CAN BE NULL.]]></reason>
  <value>YES</value>
</response>

#### If you are unsure or If there are any methods that directly or indirectly affect the return value and are not fully disclosed, request their declarations first, in the following format:
<response>
  <reason><![CDATA[EXPLAIN WHY THIS METHOD DECLARATION IS NECESSARY AND WHY YOU CANNOT MAKE A CONFIDENT DECISION WITHOUT IT]]></reason>
  <success>false</success>
  <methods>
    <method>methodName</method>
  </methods>
</response>

Additional Notes:
Be precise in your reasoning.
If a method’s return value depends on another method not provided, request its declaration before making a conclusion.
If the method can return null in this case but not in others, explain why it happens specifically for this call.

---ChatGPT.sendRequestToOpenAI---
Retrieving response from cache
---Response.<init>---
Creating Response:
```xml
<response>
  <reason><![CDATA[The method `Game.loop()` returns the static field `gameLoop`, which is initialized in the `Game.init(String... args)` method. In this method, a new `GameLoop` object is instantiated and assigned to `gameLoop`. Since `init()` must be called before `start()`, which is implied by the requirement of initializing the game, the `gameLoop` is guaranteed to be non-null during the lifetime of the game execution where `Game.loop()` is called. The absence of any code that could set `gameLoop` to null after its initialization ensures that `Game.loop()` cannot return null.]]></reason>
  <value>NO</value>
</response>
```
---Response.<init>---
Response created:
Disagreement: The method `Game.loop()` returns the static field `gameLoop`, which is initialized in the `Game.init(String... args)` method. In this method, a new `GameLoop` object is instantiated and assigned to `gameLoop`. Since `init()` must be called before `start()`, which is implied by the requirement of initializing the game, the `gameLoop` is guaranteed to be non-null during the lifetime of the game execution where `Game.loop()` is called. The absence of any code that could set `gameLoop` to null after its initialization ensures that `Game.loop()` cannot return null.
---AdvancedNullAwayCodeFix.resolveMethodDereferenceError---
Method is not returning nullable on call site. Injecting suppression annotation.
---AdvancedNullAwayCodeFix.constructCastToNonnullChange---
Constructing cast to nonnull change for reason: The method `Game.loop()` returns the static field `gameLoop`, which is initialized in the `Game.init(String... args)` method. In this method, a new `GameLoop` object is instantiated and assigned to `gameLoop`. Since `init()` must be called before `start()`, which is implied by the requirement of initializing the game, the `gameLoop` is guaranteed to be non-null during the lifetime of the game execution where `Game.loop()` is called. The absence of any code that could set `gameLoop` to null after its initialization ensures that `Game.loop()` cannot return null.
---ChatGPT.ask---
Asking ChatGPT:
For the reason you mentioned earlier:

"The method `Game.loop()` returns the static field `gameLoop`, which is initialized in the `Game.init(String... args)` method. In this method, a new `GameLoop` object is instantiated and assigned to `gameLoop`. Since `init()` must be called before `start()`, which is implied by the requirement of initializing the game, the `gameLoop` is guaranteed to be non-null during the lifetime of the game execution where `Game.loop()` is called. The absence of any code that could set `gameLoop` to null after its initialization ensures that `Game.loop()` cannot return null."

in the method below, the expression Game.loop() is not nullable at the point it is used.

```java
public default void detach() {
    Game.loop().detach(this);
}
```
Please Summarize the reason in max 5 words and rewrite the method so that at the line "    Game.loop().detach(this);", at the occurrence of: "Game.loop()" is replaced with `NullabilityUtil.castToNonnull(Game.loop(), summary of reason)`
Replace "REASON" with the exact reason summary I provide to you (maximum 5 words), not with a generic explanation like "checked to be nonnull".
see the example below, for expression `foo.getBar()`, to wrap it with `NullabilityUtil.castToNonnull(foo.getBar(), "reason")`.

```java
public t(){
    String l = foo.getBar();
}
```

will be:
```java
public t(){
    String l = NullabilityUtil.castToNonnull(foo.getBar(), "checked to be nonnull");
}
```

### Instructions:

Do not import any additional classes.

Do not add Java comments.

Only modify relevant lines as required.

Return only the modified method wrapped in the XML format shown below.

Place the Java code inside the <code> tag using a CDATA block with ```java formatting.

Just give me the fixed code snippet in XML format in <response> tag like the example below. I will apply the fix to my codebase. Do not import any additional libraries or classes or add java comments. If you can provide the fixed code snippet, please provide it in the following format and place the code snippet in the <code> tag within ```java block.
<response>
  <success>true</success>
  <code><![CDATA[
  ```java
  Your fixed code snippet here
  ```
    ]]>
  </code>
</response>

---ChatGPT.sendRequestToOpenAI---
Retrieving response from cache
---Response.<init>---
Creating Response:
<response>
  <success>true</success>
  <code><![CDATA[
  ```java
  public default void detach() {
      NullabilityUtil.castToNonnull(Game.loop(), "initialized before use").detach(this);
  }
  ```
    ]]>
  </code>
</response>
---Response.<init>---
Response created:
public default void detach() {
      NullabilityUtil.castToNonnull(Game.loop(), "initialized before use").detach(this);
  }
---ChatGPT.fixDereferenceByAddingCastToNonnull---
Fixing the error by adding castToNonnull
---AdvancedNullAwayCodeFix.fixTriggeredErrorsForLocation---
Resolving unresolvable error for triggered error: Type='DEREFERENCE_NULLABLE', message='dereferenced expression Game.loop() is @Nullable'
/home/nima/Developer/nullness-benchmarks/litiengine/src/de/gurkenlabs/litiengine/graphics/animation/AnimationController.java:157
    Game.loop().detach(this);
---AdvancedNullAwayCodeFix.fix---
Fixing error: Type='DEREFERENCE_NULLABLE', message='dereferenced expression Game.loop() is @Nullable'
/home/nima/Developer/nullness-benchmarks/litiengine/src/de/gurkenlabs/litiengine/graphics/animation/AnimationController.java:157
    Game.loop().detach(this);
---AdvancedNullAwayCodeFix.resolveDereferenceError---
Resolving dereference error: Type='DEREFERENCE_NULLABLE', message='dereferenced expression Game.loop() is @Nullable'
/home/nima/Developer/nullness-benchmarks/litiengine/src/de/gurkenlabs/litiengine/graphics/animation/AnimationController.java:157
    Game.loop().detach(this);
---AdvancedNullAwayCodeFix.resolveDereferenceError---
Checking nullability possibility at error point
---ChatGPT.checkNullabilityPossibilityAtErrorPoint---
Asking if the expression can be null at error point point
---ChatGPT.ask---
Asking ChatGPT:
In the method below, is there a possibility that the expression "Game.loop()" at line "Game.loop().detach(this);" is null?
public void detach() {
    Game.loop().detach(this);
}
Give a single-word answer in XML format. If it is possible for the expression to be null, respond with:
```xml
<response>
    <reason><![CDATA[YOUR REASON]]></reason>
    <value>YES</value>
</response>
```
If it is not possible for the expression to be null, respond with:
```xml
<response>
    <reason><![CDATA[YOUR REASON]]></reason>
    <value>NO</value>
</response>
```
If you are unsure or need more information, respond with where you can ask for more details or what specific information you need.

If additional information is required, list each request inside a `<request>` tag. If no additional information is needed, omit the `<requests>` section.

Respond with:
```xml
<response>
    <reason><![CDATA[YOUR REASON]]></reason>
    <value>UNKNOWN</value>
    <!-- Include <requests> only if additional information is needed -->
    <requests>
        <request><![CDATA[YOUR REQUEST 1]]></request>
        <request><![CDATA[YOUR REQUEST 2]]></request>
    </requests>
</response>
```
---ChatGPT.sendRequestToOpenAI---
Retrieving response from cache
---Response.<init>---
Creating Response:
```xml
<response>
    <reason><![CDATA[Without additional details about the implementation of Game.loop(), it cannot be determined if it can return null.]]></reason>
    <value>UNKNOWN</value>
    <requests>
        <request><![CDATA[Does the Game.loop() method guarantee a non-null return value?]]></request>
        <request><![CDATA[What is the implementation detail of the Game.loop() method?]]></request>
    </requests>
</response>
```
---Response.<init>---
Response created:
Unknown: Without additional details about the implementation of Game.loop(), it cannot be determined if it can return null.
---AdvancedNullAwayCodeFix.resolveMethodDereferenceError---
Resolving method dereference error.
---AdvancedNullAwayCodeFix.resolveMethodDereferenceError---
Method is in annotated package. Checking if the method is returning nullable.
---AdvancedNullAwayCodeFix.investigateMethodReturnNullability---
Checking if the method is returning nullable.
---ChatGPT.checkIfMethodIsReturningNullable---
Asking if the method is returning nullable: loop()
---ChatGPT.ask---
Asking ChatGPT:
In the method below, is there a possibility that the method returns null based only on its body? Consider the following points:

- The method may have multiple return paths; consider all return statements.
- If the method calls another method, do not assume its return value unless its full declaration is provided. Request its declaration if needed.
- The method may throw an exception instead of returning null. An exception path should not be considered a null return.
- Ensure you request the declarations of any methods whose return values directly or indirectly impact this method’s return value before making a conclusion.
- Carefully analyze all conditions and prior operations that may guarantee a non-null return value.

@Nullable public static IGameLoop loop() {
    return gameLoop;
}

Here are the method definitions in addition to the method inquired:

Depth: 0
```java
class de.gurkenlabs.litiengine.Game {
@Nullable public static IGameLoop loop() {
    return gameLoop;
}
}
```


Response Format:
Provide the answer in **XML format** as follows:

#### If the method **cannot** return `null`:
```xml
<response>
  <reason><![CDATA[EXPLAIN WHY THE METHOD CANNOT RETURN NULL]]></reason>
  <value>NO</value>
</response>
```

#### If the method can return null:
```xml
<response>
  <reason><![CDATA[EXPLAIN WHY THE METHOD CAN RETURN NULL]]></reason>
  <value>YES</value>
</response>
```

#### If you are unsure or need more information, respond with where you can ask for more details or what specific information you need.

#### If you are unsure or If there are any methods that directly or indirectly affect the return value and are not fully disclosed, request their declarations first, in the following format:
<response>
  <reason><![CDATA[YOUR REASON]]></reason>
  <value>UNKNOWN</value>
  <methods>
    <method>methodName</method>
  </methods>
</response>

If additional information is required other than method declaration, list each request inside a `<request>` tag. If no additional information is needed, omit the `<requests>` section.

Respond with:
```xml
<response>
    <reason><![CDATA[YOUR REASON]]></reason>
    <value>UNKNOWN</value>
    <!-- Include <requests> only if additional information is needed -->
    <requests>
        <request><![CDATA[YOUR REQUEST 1]]></request>
        <request><![CDATA[YOUR REQUEST 2]]></request>
    </requests>
</response>
```

Additional Notes:
Be precise in your reasoning.
If a method’s return value depends on another method not provided, request its declaration before making a conclusion.
If the method can return null in some cases but not others, explain under what conditions it can happen.

---ChatGPT.sendRequestToOpenAI---
Retrieving response from cache
---Response.<init>---
Creating Response:
```xml
<response>
  <reason><![CDATA[The method `loop` returns the variable `gameLoop`. Without the initialization or assignment details of `gameLoop`, it's unclear whether it can be null. The possibility of `gameLoop` being uninitialized or set to null elsewhere in the program means `loop` could potentially return null. Further information on `gameLoop` is required.]]></reason>
  <value>UNKNOWN</value>
  <requests>
    <request><![CDATA[Please provide the declaration and initialization of the variable `gameLoop` in the class `de.gurkenlabs.litiengine.Game`.]]></request>
  </requests>
</response>
```
---Response.<init>---
Response created:
Unknown: The method `loop` returns the variable `gameLoop`. Without the initialization or assignment details of `gameLoop`, it's unclear whether it can be null. The possibility of `gameLoop` being uninitialized or set to null elsewhere in the program means `loop` could potentially return null. Further information on `gameLoop` is required.
---AdvancedNullAwayCodeFix.investigateMethodReturnNullability---
Could not determine the nullability and model did not ask for any method.
---ChatGPT.checkIfMethodIsReturningNullableOnCallSite---
Asking if the method is returning nullable on the call site: Game.loop()
---ChatGPT.ask---
Asking ChatGPT:
In the method below, is there a possibility that the method returns null at the given call site?

```java
@Nullable public static IGameLoop loop() {
    return gameLoop;
}
```

## Guidelines:
- The method may have multiple return paths; consider all return statements.
- If the method calls another method, do not assume its return value unless its full declaration is provided. Request its declaration if needed.
- The method may throw an exception instead of returning null. An exception path should not be considered a null return.
- Ensure you request the declarations of any methods whose return values directly or indirectly impact this method’s return value before making a conclusion.
- If the method returns a value that is determined by a parameter, evaluate based on the actual argument at the given call site.
- Analyze based only on the specific invocation provided. Do not generalize to all possible inputs.- If the return value is guaranteed to be non-null at the call site, the answer should be a definitive NO.
- Do not generalize based on all possible inputs—your answer must be based only on the given invocation.
- Focus only on the given call site, not all possible invocations.

### call site:
Game.loop()

Here are the method definitions and the call chain for this method, showing the sequence of calls from the method to its callers at each depth level:

Depth: 0
```java
class de.gurkenlabs.litiengine.Game {
@Nullable public static IGameLoop loop() {
    return gameLoop;
}
}
```
Depth: 1
```java
class de.gurkenlabs.litiengine.environment.GameWorld {
public void loadEnvironment(@Nullable final Environment env) {
    Lock lock = Game.loop().getLock();
    lock.lock();
    try {
      unloadEnvironment();
      this.environment = env;
      if (env != null) {
        this.addEnvironment(env);

        if (env.getGravity() == 0 && this.gravity() != 0) {
          env.setGravity(this.gravity());
        }

        env.load();
        for (final EnvironmentLoadedListener listener : this.loadedListeners) {
          listener.loaded(env);
        }

        // call map specific listeners
        String mapName = getMapName(env);
        if (mapName != null && this.environmentLoadedListeners.containsKey(mapName)) {

          // for the default camera we center the camera on the environment
          if (this.camera().getClass().equals(Camera.class)) {
            camera().setFocus(env.getCenter());
          }

          for (EnvironmentLoadedListener listener : this.environmentLoadedListeners.get(mapName)) {
            listener.loaded(env);
          }
        }
      }
    } finally {
      lock.unlock();
    }
}public void setCamera(@Nullable final ICamera cam) {
    if (this.camera() != null) {
      Game.loop().detach(camera);
    }

    camera = cam;

    if (cam != null && !Game.isInNoGUIMode()) {
      Game.loop().attach(cam);
      cam.updateFocus();
    }
}
}
```
```java
class de.gurkenlabs.litiengine.entities.behavior.EntityNavigator {
public EntityNavigator(final IMobileEntity entity, final PathFinder pathFinder) {
    this.cancelNavigationConditions = new CopyOnWriteArrayList<>();
    this.listeners = new CopyOnWriteArrayList<>();
    this.entity = entity;
    this.pathFinder = pathFinder;
    this.setAcceptableError(DEFAULT_ACCEPTABLE_ERROR);
    Game.loop().attach(this);
}
}
```
```java
class de.gurkenlabs.litiengine.GameWindow {
private static void initializeWindowEventListeners(Window window) {

    window.addWindowStateListener(
        e -> {
          if (e.getNewState() == Frame.ICONIFIED) {
            Game.loop().setTickRate(ICONIFIED_MAX_FPS);
          } else {
            Game.loop().setTickRate(Game.config().client().getMaxFps());
          }
        });

    window.addWindowFocusListener(
        new WindowFocusListener() {
          @Override
          public void windowLostFocus(WindowEvent e) {
            if (Game.config().graphics().reduceFramesWhenNotFocused()) {
              Game.loop().setTickRate(NONE_FOCUS_MAX_FPS);
            }
          }

          @Override
          public void windowGainedFocus(WindowEvent e) {
            Game.loop().setTickRate(Game.config().client().getMaxFps());
          }
        });

    window.addWindowListener(
        new WindowAdapter() {
          @Override
          public void windowClosing(final WindowEvent event) {
            Game.exit();
          }
        });
}
}
```
```java
class de.gurkenlabs.litiengine.gui.screens.ScreenManager {
public void display(@Nullable final Screen screen) {
    if (Game.hasStarted() && Game.time().since(this.lastScreenChange) < this.getChangeCooldown()) {
      log.log(
          Level.INFO,
          "Skipping displaying of screen {0} because screen changing is currently on cooldown.",
          screen != null ? screen.getName() : "");
      return;
    }

    final Screen previous = this.current();
    if (previous != null) {
      previous.suspend();
    }

    if (screen != null && !this.screens.contains(screen)) {
      this.screens.add(screen);
    }

    this.currentScreen = screen;
    if (!Game.isInNoGUIMode() && this.current() != null) {
      this.current().prepare();
    }

    this.lastScreenChange = Game.loop().getTicks();

    final ScreenChangedEvent event = new ScreenChangedEvent(this.current(), previous);
    for (final ScreenChangedListener listener : this.screenChangedListeners) {
      listener.changed(event);
    }
}
}
```
```java
class de.gurkenlabs.litiengine.abilities.effects.Effect {
@Override
  public void update() {

    for (final Iterator<EffectApplication> iterator = this.getActiveAppliances().iterator();
        iterator.hasNext(); ) {
      final EffectApplication appliance = iterator.next();
      // if the effect duration is reached
      if (this.hasEnded(appliance)) {

        iterator.remove();
        this.cease(appliance);
      }
    }

    // 4. unregister if all appliances are finished
    if (this.getActiveAppliances().isEmpty()) {
      Game.loop().detach(this);
    }
}public void apply(final Shape impactArea) {
    final List<ICombatEntity> affected = this.lookForAffectedEntities(impactArea);
    for (final ICombatEntity affectedEntity : affected) {
      this.apply(affectedEntity);
    }

    this.appliances.add(new EffectApplication(affected, impactArea));

    // if it is the first appliance -> register for update
    if (this.appliances.size() == 1) {
      Game.loop().attach(this);
    }
}
}
```
```java
class de.gurkenlabs.litiengine.GameTime {
public long toTicks(final int milliseconds) {
    return this.toTicks(milliseconds, Game.loop().getTickRate());
}public long since(final long tick) {
    return toMilliseconds(Game.loop().getTicks() - tick);
}public long now() {
    return Game.loop().getTicks();
}public long sinceGameStart() {
    return this.toMilliseconds(Game.loop().getTicks());
}@Override
  public void loaded(Environment environment) {
    environmentLoaded = Game.loop().getTicks();
}public long toMilliseconds(final long ticks) {
    return this.toMilliseconds(ticks, Game.loop().getTickRate());
}
}
```
```java
class de.gurkenlabs.litiengine.GameMetrics {
@Override
  public void render(final Graphics2D g) {
    this.updateMetrics();

    if (!Game.config().client().showGameMetrics()) {
      return;
    }

    this.currentOffsetY = 0;

    g.setColor(this.renderColor);

    // render client metrics
    this.drawTitle(g, "[client]");
    this.drawMetric(g, "fps       : " + this.getFramesPerSecond());
    this.drawMetric(g, "max fps   : " + this.maxFramesPerSecond);
    this.drawMetric(g, "updatables: " + Game.loop().getUpdatableCount());

    // render jvm metrics if debug is enabled
    if (Game.config().debug().isDebugEnabled()) {
      this.drawTitle(g, "[jvm]");
      this.drawMetric(g, "java      : " + this.javaVersion);
      this.drawMetric(g, "memory    : " + String.format("%-5.5s", this.usedMemory) + " MB");
      this.drawMetric(g, "threads   : " + Thread.activeCount());
    }

    // render rendering metrics
    if (!this.renderMetrics.isEmpty()) {
      this.drawTitle(g, "[update]");

      for (RenderMetrics metric : this.renderMetrics) {
        this.drawMetric(g, metric.toString());
      }

      this.renderMetrics.clear();
    }
}
}
```
```java
class de.gurkenlabs.litiengine.graphics.emitters.Emitter {
public void deactivate() {
    if (!this.activated) {
      return;
    }

    this.activated = false;
    this.getParticles().clear();
    this.aliveTime = 0;
    this.activationTick = 0;
    this.lastSpawn = 0;
    Game.loop().detach(this);
}public void activate() {
    if (this.activated) {
      return;
    }

    this.activated = true;
    this.activationTick = Game.time().now();
    Game.loop().attach(this);
}@Override
  public void update() {
    if (this.isPaused()) {
      return;
    }

    // clear particles if the effect time to life is reached
    if (this.isFinished()) {
      for (EmitterFinishedListener listener : this.finishedListeners) {
        listener.finished(this);
      }

      this.delete();
      return;
    }

    final float updateRatio = (float) this.data().getUpdateRate() / Game.loop().getTickRate();
    for (final Particle p : this.getParticles().stream().collect(Collectors.toList())) {
      if (this.particleCanBeRemoved(p)) {
        // remove dead particles
        this.particles.remove(p);
        continue;
      }

      p.update(this.getOrigin(), updateRatio);
    }

    this.aliveTime = Game.time().since(this.activationTick);
    if ((this.data().getSpawnRate() == 0
        || Game.time().since(this.lastSpawn) >= this.data().getSpawnRate())) {
      this.lastSpawn = Game.time().now();
      this.spawnParticle();
    }
}
}
```
```java
class de.gurkenlabs.litiengine.entities.behavior.IBehaviorController {
public default void attach() {
    Game.loop().attach(this);
}public default void detach() {
    Game.loop().detach(this);
}
}
```
```java
class de.gurkenlabs.litiengine.abilities.AbilityExecution {
AbilityExecution(final Ability ability) {
    this.appliedEffects = new CopyOnWriteArrayList<>();
    this.ability = ability;
    this.executionTicks = Game.time().now();
    this.impactArea = ability.calculateImpactArea();
    this.castLocation = ability.getExecutor().getCenter();
    Game.loop().attach(this);
}@Override
  public void update() {
    // if there a no effects to apply -> unregister this instance and we're done
    if (this.getAbility().getEffects().isEmpty()
        || this.getAbility().getEffects().size() == this.getAppliedEffects().size()) {
      Game.loop().detach(this);
      return;
    }

    // handle all effects from the ability that were not applied yet
    for (final Effect effect : this.getAbility().getEffects()) {
      // if the ability was not executed yet or the delay of the effect is not
      // yet reached
      if (this.getAppliedEffects().contains(effect)
          || Game.time().since(this.getExecutionTicks()) < effect.getDelay()) {
        continue;
      }

      effect.apply(this.getExecutionImpactArea());
      this.getAppliedEffects().add(effect);
    }
}
}
```
```java
class de.gurkenlabs.litiengine.GameWindow$3 {
@Override
          public void windowGainedFocus(WindowEvent e) {
            Game.loop().setTickRate(Game.config().client().getMaxFps());
}@Override
          public void windowLostFocus(WindowEvent e) {
            if (Game.config().graphics().reduceFramesWhenNotFocused()) {
              Game.loop().setTickRate(NONE_FOCUS_MAX_FPS);
            }
}
}
```
```java
class de.gurkenlabs.litiengine.environment.EntitySpawner {
protected void spawnNewEntities() {
    if (this.getSpawnMode() != SpawnMode.CUSTOMSPAWNPOINTS && this.getSpawnPoints().isEmpty()) {
      return;
    }

    switch (this.getSpawnMode()) {
      case ALLSPAWNPOINTS:
        for (int i = 0; i < this.getSpawnPoints().size(); i++) {
          final int index = i;
          Game.loop()
              .perform(
                  this.getSpawnDelay() + this.getSpawnDelay() * i,
                  () -> this.spawn(this.getSpawnPoints().get(index), this.getSpawnAmount()));
        }
        break;
      case ONERANDOMSPAWNPOINT:
        this.spawn(Game.random().choose(this.getSpawnPoints()), this.getSpawnAmount());
        break;
      case RANDOMSPAWNPOINTS:
        for (int i = 0; i < this.getSpawnAmount(); i++) {
          Game.loop()
              .perform(
                  this.getSpawnDelay() + this.getSpawnDelay() * i,
                  () -> this.spawn(Game.random().choose(this.getSpawnPoints()), 1));
        }
        break;
      case CUSTOMSPAWNPOINTS:
        List<Spawnpoint> spawnPoints =
            this.customSpawnpoints != null
                ? this.customSpawnpoints.apply(this)
                : this.getCustomSpawnpoints();

        int index = 0;
        for (Spawnpoint spawn : spawnPoints) {
          Game.loop()
              .perform(
                  this.getSpawnDelay() + this.getSpawnDelay() * index, () -> this.spawn(spawn, 1));
          index++;
        }
        break;
      default:
        break;
    }
}
}
```
```java
class de.gurkenlabs.litiengine.tweening.TweenEngine {
@Override
  public void start() {
    Game.loop().attach(this);
}@Override
  public void terminate() {
    Game.loop().detach(this);
}
}
```
```java
class de.gurkenlabs.litiengine.gui.SpeechBubble {
public void hide() {
    Game.world().environment().removeRenderable(this);
    Game.loop().detach(this);
    if (activeSpeechBubbles.get(this.getEntity()) != null
        && activeSpeechBubbles.remove(this.getEntity()).equals(this)) {
      activeSpeechBubbles.remove(this.getEntity());
    }

    for (SpeechBubbleListener listener : this.listeners) {
      listener.hidden();
    }
}private SpeechBubble(
      final IEntity entity,
      final String text,
      @Nullable SpeechBubbleAppearance appearance,
      @Nullable Font font) {
    if (appearance == null) {
      this.appearance = DEFAULT_APPEARANCE;
    } else {
      this.appearance = appearance;
    }

    final SpeechBubble active = activeSpeechBubbles.get(entity);
    if (active != null) {
      active.hide();
    }
    this.setFont(font);

    this.textBoxWidth = (float) (entity.getWidth() * 4);
    this.entity = entity;

    this.currentText = text;
    this.currentTextDisplayTime = DISPLAYTIME_MIN + text.length() * DISPLAYTIME_PER_LETTER;

    this.lastTextDisplay = Game.time().now();
    this.createBubbleImage();
    entity.getEnvironment().add(this, RenderType.UI);
    Game.loop().attach(this);
    activeSpeechBubbles.put(entity, this);
}
}
```
```java
class de.gurkenlabs.litiengine.entities.Prop {
private void updateAnimationController() {
    IEntityAnimationController<?> controller = this.createAnimationController();
    this.getControllers().addController(controller);
    if (Game.world().environment() != null && Game.world().environment().isLoaded()) {
      Game.loop().attach(controller);
    }
}
}
```
```java
class de.gurkenlabs.litiengine.graphics.FreeFlightCamera {
public FreeFlightCamera(final Point2D focus) {
    this.setFocus(focus);
    this.velocity = DEFAULT_SCROLL_PIXELS_PER_SECOND;
    this.scrollPadding = DEFAULT_SCROLL_PADDING;
    this.setClampToMap(true);

    Game.loop().attach(this);
}private void handleFreeFlightCamera() {
    if (Game.world().environment() == null || Game.world().environment().getMap() == null) {
      return;
    }

    final Point2D mouseLocation = Input.mouse().getLocation();

    final double scrollSpeed =
        this.getVelocity()
            / (double) Game.loop().getTickRate()
            * Game.config().input().getMouseSensitivity();

    double x = this.getFocus().getX();
    double y = this.getFocus().getY();

    double deltaX = 0;
    if (mouseLocation.getX() < this.getScrollPadding()) {
      deltaX -= scrollSpeed;
    } else if (Game.window().getResolution().getWidth() - mouseLocation.getX()
        < this.getScrollPadding()) {
      deltaX += scrollSpeed;
    }

    double deltaY = 0;
    if (mouseLocation.getY() < this.getScrollPadding()) {
      deltaY -= scrollSpeed;
    } else if (Game.window().getResolution().getHeight() - mouseLocation.getY()
        < this.getScrollPadding()) {
      deltaY += scrollSpeed;
    }

    x += deltaX;
    y += deltaY;

    this.setFocus(new Point2D.Double(x, y));
}
}
```
```java
class de.gurkenlabs.litiengine.environment.Environment {
private static void dispose(final Collection<? extends IEntity> entities) {
    for (final IEntity entity : entities) {
      if (entity instanceof IUpdateable) {
        Game.loop().detach((IUpdateable) entity);
      }

      entity.detachControllers();
    }
}private static void loadUpdatableOrEmitterEntity(IEntity entity) {
    if (entity instanceof Emitter) {
      final Emitter emitter = (Emitter) entity;
      if (emitter.isActivateOnInit()) {
        emitter.activate();
      }
    } else if (entity instanceof IUpdateable) {
      Game.loop().attach((IUpdateable) entity);
    }
}private void unload(final IEntity entity) {
    // 1. remove from physics engine
    if (entity instanceof ICollisionEntity) {
      Game.physics().remove((ICollisionEntity) entity);
    }

    // 2. unregister from update
    if (entity instanceof IUpdateable) {
      Game.loop().detach((IUpdateable) entity);
    }

    if (entity instanceof IMobileEntity) {
      this.removeGravity((IMobileEntity) entity);
    }

    // 3. detach all controllers
    entity.detachControllers();

    if (entity instanceof Emitter) {
      Emitter em = (Emitter) entity;
      em.deactivate();
    }

    if (this.loaded && (entity instanceof LightSource || entity instanceof StaticShadow)) {
      this.updateLighting(entity);
    }

    entity.removed(this);
}
}
```
```java
class de.gurkenlabs.litiengine.graphics.animation.Animation {
@Override
  public void update() {
    // do nothing if the animation is not playing or the current keyframe is not finished
    if (!this.isPlaying()
        || Game.time().since(this.lastFrameUpdate) < this.getCurrentKeyFrame().getDuration()) {
      return;
    }

    // if we are not looping and the last keyframe is finished, we terminate the animation
    if (!this.isLooping() && this.isLastKeyFrame()) {
      this.terminate();
      return;
    }

    // make sure, we stay inside the keyframe list
    final int newFrameIndex =
        (this.getKeyframes().indexOf(this.currentFrame) + 1) % this.getKeyframes().size();
    final KeyFrame previousFrame = this.currentFrame;
    this.currentFrame = this.getKeyframes().get(newFrameIndex);

    for (KeyFrameListener listener : this.listeners) {
      listener.currentFrameChanged(previousFrame, this.currentFrame);
    }

    this.lastFrameUpdate = Game.loop().getTicks();
}public void restart() {
    this.currentFrame = this.firstFrame;
    this.lastFrameUpdate = Game.loop().getTicks();
}
}
```
```java
class de.gurkenlabs.litiengine.physics.MovementController {
@Override
  public void attach() {
    Game.loop().attach(this);
}private void handleForces() {
    // clean up forces
    this.activeForces.forEach(
        x -> {
          if (x.hasEnded()) {
            this.activeForces.remove(x);
          }
        });

    if (this.activeForces.isEmpty()) {
      return;
    }

    // disable turn-on-move for force handling
    boolean turn = this.getEntity().turnOnMove();
    this.getEntity().setTurnOnMove(false);
    try {
      double deltaX = 0;
      double deltaY = 0;
      for (final Force force : this.activeForces) {
        if (force.cancelOnReached() && force.hasReached(this.getEntity())) {
          force.end();
          continue;
        }

        final Point2D collisionBoxCenter = this.getEntity().getCollisionBoxCenter();
        final double angle =
            GeometricUtilities.calcRotationAngleInDegrees(collisionBoxCenter, force.getLocation());
        final double strength =
            Game.loop().getDeltaTime() * 0.001f * force.getStrength() * Game.loop().getTimeScale();
        deltaX += GeometricUtilities.getDeltaX(angle, strength);
        deltaY += GeometricUtilities.getDeltaY(angle, strength);
      }

      final Point2D target =
          new Point2D.Double(this.getEntity().getX() + deltaX, this.getEntity().getY() + deltaY);
      final boolean success = Game.physics().move(this.getEntity(), target);
      if (!success) {
        for (final Force force : this.activeForces) {
          if (force.cancelOnCollision()) {
            force.end();
          }
        }
      }
    } finally {
      this.getEntity().setTurnOnMove(turn);
    }
}@Override
  public void detach() {
    Game.loop().detach(this);
}public void handleMovement() {
    if (!this.isMovementAllowed()) {
      this.velocity = 0;
      return;
    }

    // max distance an entity can travel within one tick
    final double maxPixelsPerTick = this.getEntity().getTickVelocity();
    final double deltaTime = Game.loop().getDeltaTime() * Game.loop().getTimeScale();

    final double acceleration =
        this.getEntity().getAcceleration() == 0
            ? maxPixelsPerTick
            : deltaTime / this.getEntity().getAcceleration() * maxPixelsPerTick;
    final double deceleration =
        this.getEntity().getDeceleration() == 0
            ? this.getVelocity()
            : deltaTime / this.getEntity().getDeceleration() * maxPixelsPerTick;

    double dx = this.getDx();
    double dy = this.getDy();
    this.setDx(0);
    this.setDy(0);

    final double deltaVelocity =
        Math.min(Math.sqrt(Math.pow(dx, 2) + Math.pow(dy, 2)), acceleration);
    if (deltaVelocity != 0) {
      double newVelocity = this.getVelocity() + deltaVelocity;
      this.setVelocity(newVelocity);
    } else {
      final double newVelocity = Math.max(0, this.getVelocity() - deceleration);
      this.setVelocity(newVelocity);
      dx = GeometricUtilities.getDeltaX(this.moveAngle);
      dy = GeometricUtilities.getDeltaY(this.moveAngle);
    }

    if (this.getVelocity() == 0) {
      this.moveAngle = 0;
      return;
    }

    // actually move entity
    this.moveEntity(dx, dy);
}
}
```
```java
class de.gurkenlabs.litiengine.graphics.animation.AnimationController {
public void detach() {
    Game.loop().detach(this);
}public void attach() {
    Game.loop().attach(this);
}
}
```
```java
class de.gurkenlabs.litiengine.graphics.Camera {
@Override
  public void setZoom(final float targetZoom, final int delay) {
    if (delay == 0) {

      this.zoom = targetZoom;
      this.targetZoom = 0;
      this.zoomDelay = 0;
      this.zoomTick = 0;
      this.zoomStep = 0;

      final ZoomChangedEvent event = new ZoomChangedEvent(this, targetZoom);
      for (final ZoomChangedListener listener : this.zoomListeners) {
        listener.zoomChanged(event);
      }
    } else {
      this.zoomTick = Game.time().now();
      this.targetZoom = targetZoom;
      this.zoomDelay = delay;

      final double tickduration = 1000 / (double) Game.loop().getTickRate();
      final double tickAmount = delay / tickduration;
      final float totalDelta = this.targetZoom - this.zoom;
      this.zoomStep = tickAmount > 0 ? (float) (totalDelta / tickAmount) : totalDelta;
    }
}
}
```
```java
class de.gurkenlabs.litiengine.Game {
public static synchronized void init(String... args) {
    if (initialized) {
      log().log(Level.INFO, "The game has already been initialized.");
      return;
    }

    log.init();
    handleCommandLineArguments(args);

    config().load();
    Locale.setDefault(new Locale(config().client().getCountry(), config().client().getLanguage()));

    gameLoop = new GameLoop("Main Update Loop", config().client().getMaxFps());
    loop().attach(physics());
    loop().attach(world());

    // setup default exception handling for render and update loop
    setUncaughtExceptionHandler(
        new DefaultUncaughtExceptionHandler(config().client().exitOnError()));

    screenManager = new ScreenManager();
    gameWindow = new GameWindow();

    // initialize  the game window
    window().init();
    world.setCamera(new Camera());

    for (GameListener listener : gameListeners) {
      listener.initialized(args);
    }

    if (!isInNoGUIMode()) {
      window().getRenderComponent().onRendered(g -> metrics().render(g));

      graphics()
          .addEntityRenderedListener(
              e -> DebugRenderer.renderEntityDebugInfo(e.getGraphics(), e.getEntity()));

      window().getRenderComponent().onFpsChanged(fps -> metrics().setFramesPerSecond(fps));
      window()
          .setIcons(
              Arrays.asList(
                  Resources.images().get("liti-logo-x16.png"),
                  Resources.images().get("liti-logo-x20.png"),
                  Resources.images().get("liti-logo-x32.png"),
                  Resources.images().get("liti-logo-x48.png")));

      Input.keyboard()
          .onKeyTyped(
              KeyEvent.VK_PRINTSCREEN,
              key -> {
                // don't take a screenshot if a modifier is active
                if (key.getModifiers() != 0) {
                  return;
                }

                window().getRenderComponent().takeScreenshot();
              });
    }

    Runtime.getRuntime().addShutdownHook(new Thread(Game::terminate, "Shutdown"));

    initialized = true;
}
}
```
```java
class de.gurkenlabs.litiengine.entities.Creature {
protected void updateAnimationController() {
    IEntityAnimationController<?> controller = this.createAnimationController();
    this.getControllers().addController(controller);
    if (Game.world().environment() != null && Game.world().environment().isLoaded()) {
      Game.loop().attach(controller);
    }
}@Override
  public float getTickVelocity() {
    // pixels per ms multiplied by the passed ms
    // ensure that entities don't travel too far in case of lag
    return Math.min(Game.loop().getDeltaTime(), GameLoop.TICK_DELTATIME_LAG)
        * 0.001F
        * this.getVelocity().get()
        * Game.loop().getTimeScale();
}
}
```
Depth: 2
```java
class de.gurkenlabs.litiengine.environment.GameWorld {
public void clear() {
    this.unloadEnvironment();
    this.environments.clear();
    this.setCamera(null);
    Game.physics().clear();

    this.environmentListeners.clear();
    this.environmentLoadedListeners.clear();
    this.environmentUnloadedListeners.clear();

    this.listeners.clear();
    this.loadedListeners.clear();
    this.unloadedListeners.clear();
}@Nullable
  public Environment loadEnvironment(IMap map) {
    Environment env = this.getEnvironment(map);
    this.loadEnvironment(env);
    return env;
}@Nullable
  public Environment loadEnvironment(String mapName) {
    Environment env = this.getEnvironment(mapName);
    this.loadEnvironment(env);
    return env;
}
}
```
```java
class de.gurkenlabs.litiengine.GameWindow {
GameWindow() {
    this.hostControl = new JFrame();

    this.resolutionChangedListeners = new CopyOnWriteArrayList<>();

    this.renderCanvas = new RenderComponent(Game.config().graphics().getResolution());
    this.cursor = new MouseCursor();
    if (!Game.isInNoGUIMode()) {
      this.hostControl.setBackground(Color.BLACK);
      this.hostControl.add(this.renderCanvas);

      this.initializeEventListeners();

      this.hostControl.setTitle(Game.info().getTitle());
      this.hostControl.setDefaultCloseOperation(WindowConstants.DO_NOTHING_ON_CLOSE);
      initializeWindowEventListeners(this.hostControl);
    }
}
}
```
```java
class de.gurkenlabs.litiengine.GameTime {
public long sinceEnvironmentLoad() {
    return this.since(this.environmentLoaded);
}public long since(final long tick) {
    return toMilliseconds(Game.loop().getTicks() - tick);
}public long sinceGameStart() {
    return this.toMilliseconds(Game.loop().getTicks());
}
}
```
```java
class de.gurkenlabs.litiengine.abilities.effects.Effect {
protected void cease(final EffectApplication appliance) {
    // 1. cease the effect for all affected entities
    for (final ICombatEntity entity : appliance.getAffectedEntities()) {
      this.cease(entity);
    }

    // 2. apply follow up effects
    this.getFollowUpEffects().forEach(followUp -> followUp.apply(appliance.getImpactArea()));
}protected boolean hasEnded(final EffectApplication appliance) {
    final long effectDuration = Game.time().since(appliance.getAppliedTicks());
    return effectDuration > this.getDuration();
}
}
```
```java
class de.gurkenlabs.litiengine.abilities.effects.EffectApplication {
protected EffectApplication(final List<ICombatEntity> affectedEntities, final Shape impactArea) {
    this.applied = Game.time().now();
    this.affectedEntities = affectedEntities;
    this.impactArea = impactArea;
}
}
```
```java
class de.gurkenlabs.litiengine.entities.CombatEntity {
@Override
  public boolean wasHit(int timeSpan) {
    return Game.time().since(this.lastHit) < timeSpan;
}@Override
  public void hit(final int damage, @Nullable final Ability ability) {
    if (this.isDead()) {
      return;
    }

    if (!this.isIndestructible()) {
      this.getHitPoints().modifyBaseValue(new AttributeModifier<>(Modification.SUBTRACT, damage));
    }

    final EntityHitEvent event = new EntityHitEvent(this, ability, damage, this.isDead());

    for (final CombatEntityListener listener : this.listeners) {
      listener.hit(event);
    }

    for (final CombatEntityHitListener listener : this.hitListeners) {
      listener.hit(event);
    }

    if (this.isDead()) {
      this.fireDeathEvent();
      this.setCollision(false);
    }

    this.lastHit = Game.time().now();
}
}
```
```java
class de.gurkenlabs.litiengine.graphics.ImageEffect {
protected ImageEffect(final int ttl, final String name) {
    this.ttl = ttl;
    this.name = name;
    this.aliveTick = Game.time().now();
}@Override
  public long getAliveTime() {
    return Game.time().since(this.aliveTick);
}
}
```
```java
class de.gurkenlabs.litiengine.abilities.AbilityExecution {
AbilityExecution(final Ability ability) {
    this.appliedEffects = new CopyOnWriteArrayList<>();
    this.ability = ability;
    this.executionTicks = Game.time().now();
    this.impactArea = ability.calculateImpactArea();
    this.castLocation = ability.getExecutor().getCenter();
    Game.loop().attach(this);
}@Override
  public void update() {
    // if there a no effects to apply -> unregister this instance and we're done
    if (this.getAbility().getEffects().isEmpty()
        || this.getAbility().getEffects().size() == this.getAppliedEffects().size()) {
      Game.loop().detach(this);
      return;
    }

    // handle all effects from the ability that were not applied yet
    for (final Effect effect : this.getAbility().getEffects()) {
      // if the ability was not executed yet or the delay of the effect is not
      // yet reached
      if (this.getAppliedEffects().contains(effect)
          || Game.time().since(this.getExecutionTicks()) < effect.getDelay()) {
        continue;
      }

      effect.apply(this.getExecutionImpactArea());
      this.getAppliedEffects().add(effect);
    }
}
}
```
```java
class de.gurkenlabs.litiengine.tweening.TweenEngine {
@Override
  public void update() {
    for (final Tweenable target : this.getTweens().keySet()) {
      for (final Tween tween : this.getTweens().get(target).values()) {
        if (tween.hasStopped()) {
          continue;
        }
        final long elapsed = Game.time().since(tween.getStartTime());
        if (elapsed >= tween.getDuration()) {
          tween.stop();
          continue;
        }
        final float[] currentValues = new float[tween.getTargetValues().length];
        for (int i = 0; i < tween.getTargetValues().length; i++) {
          currentValues[i] =
              tween.getStartValues()[i]
                  + tween.getEquation().compute(elapsed / (float) tween.getDuration())
                      * (tween.getTargetValues()[i] - tween.getStartValues()[i]);
        }
        tween.getTarget().setTweenValues(tween.getType(), currentValues);
      }
    }
}
}
```
```java
class de.gurkenlabs.litiengine.gui.SpeechBubble {
public static SpeechBubble create(
      final IEntity entity, final String text, SpeechBubbleAppearance appearance, Font font) {
    return new SpeechBubble(entity, text, appearance, font);
}public static SpeechBubble create(final IEntity entity, final Font font, final String text) {
    SpeechBubbleAppearance app =
        new SpeechBubbleAppearance(
            DEFAULT_APPEARANCE.getForeColor(),
            DEFAULT_APPEARANCE.getBackgroundColor1(),
            DEFAULT_APPEARANCE.getBorderColor(),
            DEFAULT_APPEARANCE.getPadding());
    return new SpeechBubble(entity, text, app, font);
}public static SpeechBubble create(final IEntity entity, final String text) {
    return new SpeechBubble(entity, text, null, GuiProperties.getDefaultFont());
}@Override
  public void update() {
    if (this.currentText == null) {
      this.hide();
      return;
    }

    this.entityCenter = Game.world().camera().getViewportLocation(this.getEntity().getCenter());

    // old text was displayed long enough
    if (this.lastTextDisplay != 0
        && Game.time().since(this.lastTextDisplay) > this.currentTextDisplayTime) {
      this.currentText = null;
      this.lastTextDisplay = 0;
      return;
    }

    // display new text
    if (this.textIndex < this.currentText.length()
        && Game.time().since(this.lastCharPoll) > LETTER_WRITE_DELAY) {
      this.textIndex++;
      this.lastCharPoll = Game.time().now();
      if (this.typeSound != null) {
        Game.audio().playSound(this.typeSound, this.getEntity());
      }
    }

    // continue displaying currently displayed text
}private SpeechBubble(
      final IEntity entity,
      final String text,
      final Sound typeSound,
      SpeechBubbleAppearance appearance,
      Font font) {
    this(entity, text, appearance, font);
    this.typeSound = typeSound;
}private SpeechBubble(
      final IEntity entity,
      final String text,
      @Nullable SpeechBubbleAppearance appearance,
      @Nullable Font font) {
    if (appearance == null) {
      this.appearance = DEFAULT_APPEARANCE;
    } else {
      this.appearance = appearance;
    }

    final SpeechBubble active = activeSpeechBubbles.get(entity);
    if (active != null) {
      active.hide();
    }
    this.setFont(font);

    this.textBoxWidth = (float) (entity.getWidth() * 4);
    this.entity = entity;

    this.currentText = text;
    this.currentTextDisplayTime = DISPLAYTIME_MIN + text.length() * DISPLAYTIME_PER_LETTER;

    this.lastTextDisplay = Game.time().now();
    this.createBubbleImage();
    entity.getEnvironment().add(this, RenderType.UI);
    Game.loop().attach(this);
    activeSpeechBubbles.put(entity, this);
}
}
```
```java
class de.gurkenlabs.litiengine.gui.TextFieldComponent {
@Override
  public void render(final Graphics2D g) {
    super.render(g);
    g.setFont(this.getFont());
    final FontMetrics fm = g.getFontMetrics();

    if (this.isSelected() && Game.time().since(this.lastToggled) > this.flickerDelay) {
      this.cursorVisible = !this.cursorVisible;
      this.lastToggled = Game.time().now();
    }
    if (this.isSelected() && this.cursorVisible) {
      final Rectangle2D cursor =
          new Rectangle2D.Double(
              this.getX() + this.getTextX() + fm.stringWidth(this.getTextToRender(g)),
              this.getY() + this.getTextY(),
              this.getFont().getSize2D() * 3 / 5,
              this.getFont().getSize2D() * 1 / 5);
      g.setColor(this.getAppearance().getForeColor());
      g.fill(cursor);
    }
}
}
```
```java
class de.gurkenlabs.litiengine.entities.Prop {
public Prop(
      final Point2D location, @Nullable final String spritesheetName, final Material material) {
    super();
    this.rotation = Rotation.NONE;
    this.spritesheetName = spritesheetName;
    this.material = material;
    this.setLocation(location);
    this.updateAnimationController();
}public void setSpritesheetName(@Nullable final String spriteName) {
    this.spritesheetName = spriteName;
    this.updateAnimationController();
}
}
```
```java
class de.gurkenlabs.litiengine.tweening.Tween {
public Tween begin() {
    this.started = Game.time().now();
    this.stopped = false;
    return this;
}
}
```
```java
class de.gurkenlabs.litiengine.graphics.emitters.particles.Particle {
public void update(final Point2D emitterOrigin, final float updateRatio) {
    if (this.aliveTick == 0) {
      this.aliveTick = Game.time().now();
    }

    this.aliveTime = Game.time().since(this.aliveTick);
    if (this.timeToLiveReached()) {
      return;
    }

    if (this.colliding) {
      return;
    }

    if (this.getDeltaWidth() != 0) {
      this.width += this.getDeltaWidth() * updateRatio;
    }

    if (this.getDeltaHeight() != 0) {
      this.height += this.getDeltaHeight() * updateRatio;
    }

    if (this.getDeltaAngle() != 0) {
      this.angle += this.getDeltaAngle() * updateRatio;
    }

    // test for ray cast collision
    final float targetX = this.x + this.getVelocityX() * updateRatio;
    final float targetY = this.y + this.getVelocityY() * updateRatio;

    if (targetX == this.x && targetY == this.y) {
      return;
    }

    if (this.checkForCollision(emitterOrigin, targetX, targetY)) {
      return;
    }

    if (this.getVelocityX() != 0) {
      this.x = targetX;
    }

    if (this.getVelocityY() != 0) {
      this.y = targetY;
    }

    if (this.getAccelerationX() != 0) {
      this.velocityX += this.getAccelerationX() * updateRatio;
    }

    if (this.getAccelerationY() != 0) {
      this.velocityY += this.getAccelerationY() * updateRatio;
    }
}
}
```
```java
class de.gurkenlabs.litiengine.graphics.animation.Animation {
@Override
  public void start() {
    this.playing = true;
    if (this.getKeyframes().isEmpty()) {
      return;
    }

    this.restart();
}@Override
  public void update() {
    // do nothing if the animation is not playing or the current keyframe is not finished
    if (!this.isPlaying()
        || Game.time().since(this.lastFrameUpdate) < this.getCurrentKeyFrame().getDuration()) {
      return;
    }

    // if we are not looping and the last keyframe is finished, we terminate the animation
    if (!this.isLooping() && this.isLastKeyFrame()) {
      this.terminate();
      return;
    }

    // make sure, we stay inside the keyframe list
    final int newFrameIndex =
        (this.getKeyframes().indexOf(this.currentFrame) + 1) % this.getKeyframes().size();
    final KeyFrame previousFrame = this.currentFrame;
    this.currentFrame = this.getKeyframes().get(newFrameIndex);

    for (KeyFrameListener listener : this.listeners) {
      listener.currentFrameChanged(previousFrame, this.currentFrame);
    }

    this.lastFrameUpdate = Game.loop().getTicks();
}
}
```
```java
class de.gurkenlabs.litiengine.graphics.animation.AnimationController {
@Override
  public void update() {
    for (final Animation animation : this.getAll()) {
      animation.update();
    }

    if (this.getCurrent() != null && this.getCurrent().isPaused()) {
      return;
    }

    final boolean playbackFinished = this.getCurrent() != null && !this.getCurrent().isPlaying();
    if (playbackFinished) {
      for (final AnimationListener listener : this.listeners) {
        listener.finished(this.getCurrent());
      }
    }

    if (this.getCurrent() == null || playbackFinished) {
      if (this.getDefault() != null) {
        this.play(this.getDefault().getName());
      } else {
        this.currentAnimation = null;
      }
    }
}
}
```
```java
class de.gurkenlabs.litiengine.graphics.RenderComponent {
private void handleFade() {
    if (this.fadeOutStart != -1) {
      final long timePassed = Game.time().since(this.fadeOutStart);
      this.currentAlpha = MathUtilities.clamp(1 - timePassed / (float) this.fadeOutTime, 0, 1);
      if (this.currentAlpha == 0f) {
        this.fadeOutStart = -1;
        this.fadeOutTime = -1;
      }

      return;
    }

    if (this.fadeInStart != -1) {
      final long timePassed = Game.time().since(this.fadeInStart);
      this.currentAlpha = MathUtilities.clamp(timePassed / (float) this.fadeInTime, 0, 1);
      if (this.currentAlpha == 1f) {
        this.fadeInStart = -1;
        this.fadeInTime = -1;
        this.currentAlpha = Float.NaN;
      }
    }
}public void fadeOut(final int ms) {
    this.fadeInStart = -1;
    this.fadeInTime = -1;
    this.fadeOutStart = Game.time().now();
    this.fadeOutTime = ms;
}public void fadeIn(final int ms) {
    this.fadeOutStart = -1;
    this.fadeOutTime = -1;
    this.fadeInStart = Game.time().now();
    this.fadeInTime = ms;
}
}
```
```java
class de.gurkenlabs.litiengine.entities.Trigger {
private boolean activate(final IEntity activator, final int tar) {
    if (!this.isLoaded()
        || this.isOneTimeTrigger && this.isActivated
        || this.getActivationType() == TriggerActivation.COLLISION
            && activator != null
            && this.collisionActivated.contains(activator)) {
      return false;
    }

    if (this.getCooldown() > 0 && Game.time().since(this.lastActivation) < this.getCooldown()) {
      return false;
    }

    List<Integer> triggerTargets = this.getTargets(tar);

    final TriggerEvent te = new TriggerEvent(this, activator, triggerTargets);

    if (!this.checkActivationPredicates(te)) {
      return false;
    }

    this.isActivated = true;
    if (activator != null) {
      this.collisionActivated.add(activator);
    }

    // if we actually have a trigger target, we send the message to the target
    for (final int target : triggerTargets) {
      final IEntity entity = this.getEnvironment().get(target);
      if (entity == null) {
        log.log(
            Level.WARNING,
            "trigger [{0}] was activated, but the trigger target [{1}] could not be found on the environment",
            new Object[] {this, target});
        continue;
      }

      entity.sendMessage(this, this.message);
    }

    // also send the trigger event to all registered consumers
    for (final TriggerActivatedListener listener : this.activatedListeners) {
      listener.activated(te);
    }

    if (this.isOneTimeTrigger) {
      this.getEnvironment().remove(this);
    }

    this.lastActivation = Game.time().now();
    return true;
}
}
```
```java
class de.gurkenlabs.litiengine.graphics.Camera {
private boolean isShakeEffectActive() {
    return this.getShakeTick() != 0
        && Game.time().since(this.getShakeTick()) < this.getShakeDuration();
}@Override
  public void update() {
    if (Game.world().camera() != null && !Game.world().camera().equals(this)) {
      return;
    }

    if (this.targetZoom > 0) {
      if (Game.time().since(this.zoomTick) >= this.zoomDelay) {
        this.zoom = this.targetZoom;
        this.targetZoom = 0;
        this.zoomDelay = 0;
        this.zoomTick = 0;
        this.zoomStep = 0;
      } else {
        this.zoom += this.zoomStep;
      }

      final ZoomChangedEvent event = new ZoomChangedEvent(this, this.getZoom());
      for (final ZoomChangedListener listener : this.zoomListeners) {
        listener.zoomChanged(event);
      }
    }

    if (this.panTime > 0) {
      if (--this.panTime <= 0) {
        this.setFocus(this.targetFocus);
        this.targetFocus = null;
      } else {
        double diff = this.panTime / (this.panTime + 1.0);
        this.focus =
            new Point2D.Double(
                this.focus.getX() * diff + this.targetFocus.getX() * (1.0 - diff),
                this.focus.getY() * diff + this.targetFocus.getY() * (1.0 - diff));
      }
    }

    if (!this.isShakeEffectActive()) {
      this.shakeOffsetX = 0;
      this.shakeOffsetY = 0;
      return;
    }

    if (Game.time().since(this.lastShake) > this.shakeDelay) {
      this.shakeOffsetX = this.getShakeIntensity() * ThreadLocalRandom.current().nextGaussian();
      this.shakeOffsetY = this.getShakeIntensity() * ThreadLocalRandom.current().nextGaussian();
      this.lastShake = Game.time().now();
    }
}@Override
  public void setZoom(final float targetZoom, final int delay) {
    if (delay == 0) {

      this.zoom = targetZoom;
      this.targetZoom = 0;
      this.zoomDelay = 0;
      this.zoomTick = 0;
      this.zoomStep = 0;

      final ZoomChangedEvent event = new ZoomChangedEvent(this, targetZoom);
      for (final ZoomChangedListener listener : this.zoomListeners) {
        listener.zoomChanged(event);
      }
    } else {
      this.zoomTick = Game.time().now();
      this.targetZoom = targetZoom;
      this.zoomDelay = delay;

      final double tickduration = 1000 / (double) Game.loop().getTickRate();
      final double tickAmount = delay / tickduration;
      final float totalDelta = this.targetZoom - this.zoom;
      this.zoomStep = tickAmount > 0 ? (float) (totalDelta / tickAmount) : totalDelta;
    }
}@Override
  public void shake(final double intensity, final int delay, final int shakeDuration) {
    this.shakeTick = Game.time().now();
    this.shakeDelay = delay;
    this.shakeIntensity = intensity;
    this.shakeDuration = shakeDuration;
}
}
```
```java
class de.gurkenlabs.litiengine.entities.Creature {
public void setSpritesheetName(String spritesheetName) {
    if (this.spritesheetName != null && this.spritesheetName.equals(spritesheetName)) {
      return;
    }

    this.spritesheetName = spritesheetName;
    this.updateAnimationController();
}public boolean isIdle() {
    return Game.time().since(this.lastMoved) > IDLE_DELAY;
}@Override
  public void setLocation(final Point2D position) {
    if (this.isDead() || position == null) {
      return;
    }

    final Point2D oldLocation = this.getLocation();
    super.setLocation(position);

    if (Game.hasStarted() && this.isLoaded()) {
      this.lastMoved = Game.time().now();
      this.fireMovedEvent(
          new EntityMovedEvent(
              this, this.getX() - oldLocation.getX(), this.getY() - oldLocation.getY()));
    }
}
}
```
```java
class de.gurkenlabs.litiengine.gui.screens.ScreenManager {
public void display(final String screenName) {
    if (this.current() != null && this.current().getName().equalsIgnoreCase(screenName)) {
      log.log(
          Level.INFO,
          "Skipping displaying of screen {0} because it is already the current screen.",
          screenName);
      return;
    }

    if (this.screens.stream()
        .noneMatch(element -> element.getName().equalsIgnoreCase(screenName))) {
      log.log(
          Level.WARNING,
          "Could not display the screen {0} because there is no screen with the specified name.",
          screenName);
      return;
    }

    Screen screen = this.get(screenName);
    if (screen == null) {
      return;
    }

    this.display(screen);
}public void add(final Screen screen) {
    screen.setWidth(Game.window().getWidth());
    screen.setHeight(Game.window().getHeight());
    this.screens.add(screen);

    if (this.current() == null) {
      this.display(screen);
    }
}public void remove(Screen screen) {
    this.screens.remove(screen);
    if (this.current() == screen) {
      if (!this.screens.isEmpty()) {
        this.display(this.screens.get(0));
      } else {
        this.display((Screen) null);
      }
    }
}public void display(@Nullable final Screen screen) {
    if (Game.hasStarted() && Game.time().since(this.lastScreenChange) < this.getChangeCooldown()) {
      log.log(
          Level.INFO,
          "Skipping displaying of screen {0} because screen changing is currently on cooldown.",
          screen != null ? screen.getName() : "");
      return;
    }

    final Screen previous = this.current();
    if (previous != null) {
      previous.suspend();
    }

    if (screen != null && !this.screens.contains(screen)) {
      this.screens.add(screen);
    }

    this.currentScreen = screen;
    if (!Game.isInNoGUIMode() && this.current() != null) {
      this.current().prepare();
    }

    this.lastScreenChange = Game.loop().getTicks();

    final ScreenChangedEvent event = new ScreenChangedEvent(this.current(), previous);
    for (final ScreenChangedListener listener : this.screenChangedListeners) {
      listener.changed(event);
    }
}
}
```
```java
class de.gurkenlabs.litiengine.abilities.Ability {
public boolean isOnCooldown() {
    return (this.getCurrentExecution() != null
        && this.getCurrentExecution().getExecutionTicks() > 0
        && Game.time().since(this.getCurrentExecution().getExecutionTicks())
            < this.getAttributes().cooldown().get());
}public boolean isActive() {
    return this.getCurrentExecution() != null
        && Game.time().since(this.getCurrentExecution().getExecutionTicks())
            < this.getAttributes().duration().get();
}@Nullable
  public AbilityExecution cast() {
    if (!this.canCast()) {
      return null;
    }
    this.currentExecution = new AbilityExecution(this);

    for (final AbilityCastListener listener : this.abilityCastListeners) {
      listener.abilityCast(this.currentExecution);
    }

    return this.getCurrentExecution();
}public float getRemainingCooldownInSeconds() {
    if (this.getCurrentExecution() == null
        || this.getExecutor() == null
        || this.getExecutor().isDead()) {
      return 0;
    }

    // calculate cooldown in seconds
    return (float)
        (!this.canCast()
            ? (this.getAttributes().cooldown().get()
                    - Game.time().since(this.getCurrentExecution().getExecutionTicks()))
                * 0.001
            : 0);
}
}
```
```java
class de.gurkenlabs.litiengine.entities.EntityHitEvent {
EntityHitEvent(
      final ICombatEntity hitEntity,
      @Nullable final Ability ability,
      final int damage,
      final boolean kill) {
    super(hitEntity);
    this.executor = ability != null ? ability.getExecutor() : null;
    this.hitEntity = hitEntity;
    this.ability = ability;
    this.damage = damage;
    this.kill = kill;
    this.time = Game.time().now();
}
}
```
```java
class de.gurkenlabs.litiengine.graphics.emitters.Emitter {
public void delete() {
    this.deactivate();
    if (Game.world().environment() != null) {
      Game.world().environment().remove(this);
    }
}public void activate() {
    if (this.activated) {
      return;
    }

    this.activated = true;
    this.activationTick = Game.time().now();
    Game.loop().attach(this);
}@Override
  public void update() {
    if (this.isPaused()) {
      return;
    }

    // clear particles if the effect time to life is reached
    if (this.isFinished()) {
      for (EmitterFinishedListener listener : this.finishedListeners) {
        listener.finished(this);
      }

      this.delete();
      return;
    }

    final float updateRatio = (float) this.data().getUpdateRate() / Game.loop().getTickRate();
    for (final Particle p : this.getParticles().stream().collect(Collectors.toList())) {
      if (this.particleCanBeRemoved(p)) {
        // remove dead particles
        this.particles.remove(p);
        continue;
      }

      p.update(this.getOrigin(), updateRatio);
    }

    this.aliveTime = Game.time().since(this.activationTick);
    if ((this.data().getSpawnRate() == 0
        || Game.time().since(this.lastSpawn) >= this.data().getSpawnRate())) {
      this.lastSpawn = Game.time().now();
      this.spawnParticle();
    }
}
}
```
```java
class de.gurkenlabs.litiengine.GameLoop {
@Override
  public int perform(int delay, Runnable action) {
    final long d = Game.time().toTicks(delay);

    TimedAction a = new TimedAction(this.getTicks() + d, action);
    this.actions.add(a);

    return a.getId();
}
}
```
```java
class de.gurkenlabs.litiengine.environment.EntitySpawner {
protected boolean shouldSpawn() {
    return this.lastSpawnWave == 0
        || Game.time().since(this.lastSpawnWave) >= this.getSpawnInterval();
}@Override
  public void update() {
    if (!this.shouldSpawn()) {
      return;
    }

    this.spawnNewEntities();
    this.lastSpawnWave = Game.time().now();
}
}
```
```java
class de.gurkenlabs.litiengine.graphics.FreeFlightCamera {
@Override
  public void update() {
    this.handleFreeFlightCamera();
}public FreeFlightCamera(double x, double y) {
    this(new Point2D.Double(x, y));
}
}
```
```java
class de.gurkenlabs.litiengine.environment.Environment {
public void unload() {
    if (!this.loaded) {
      return;
    }

    // unregister all updatable entities from the current environment
    for (final IEntity entity : this.allEntities.values()) {
      this.unload(entity);
    }

    this.loaded = false;
    this.fireEvent(l -> l.unloaded(this));
}private static void loadUpdatableOrEmitterEntity(IEntity entity) {
    if (entity instanceof Emitter) {
      final Emitter emitter = (Emitter) entity;
      if (emitter.isActivateOnInit()) {
        emitter.activate();
      }
    } else if (entity instanceof IUpdateable) {
      Game.loop().attach((IUpdateable) entity);
    }
}public void clear() {
    Game.physics().clear();

    this.combatEntities.clear();
    this.mobileEntities.clear();
    this.gravityForces.clear();
    this.layerEntities.clear();
    this.entitiesByTag.clear();
    this.allEntities.clear();

    for (RenderType renderType : RenderType.values()) {
      this.miscEntities.get(renderType).clear();
      this.renderListeners.get(renderType).clear();
      this.renderables.get(renderType).clear();
    }

    dispose(this.allEntities.values());
    dispose(this.triggers);
    this.emitters.clear();
    this.colliders.clear();
    this.props.clear();
    this.creatures.clear();
    this.staticShadows.clear();
    this.combatEntities.clear();
    this.mobileEntities.clear();
    this.lightSources.clear();
    this.spawnPoints.clear();
    this.soundSources.clear();
    this.mapAreas.clear();
    this.triggers.clear();

    this.ambientLight = null;
    this.staticShadowLayer = null;

    for (Map<Integer, IEntity> type : this.miscEntities.values()) {
      type.clear();
    }

    this.initialized = false;

    this.fireEvent(l -> l.cleared(this));
}private void load(final IEntity entity) {
    // an entity can only exist on one environment at a time, so remove it from the current one
    if (entity.getEnvironment() != null) {
      entity.getEnvironment().remove(entity);
    }

    // 1. add to physics engine
    loadPhysicsEntity(entity);

    // 2. register for update or activate
    loadUpdatableOrEmitterEntity(entity);

    // 3. if a gravity is defined, add a gravity force to the entity
    if (entity instanceof IMobileEntity && this.getGravity() != 0) {
      this.addGravityForce((IMobileEntity) entity);
    }

    // 4. attach all controllers
    entity.attachControllers();

    if (this.loaded && (entity instanceof LightSource || entity instanceof StaticShadow)) {
      this.updateLighting(entity);
    }

    entity.loaded(this);
}private void unload(final IEntity entity) {
    // 1. remove from physics engine
    if (entity instanceof ICollisionEntity) {
      Game.physics().remove((ICollisionEntity) entity);
    }

    // 2. unregister from update
    if (entity instanceof IUpdateable) {
      Game.loop().detach((IUpdateable) entity);
    }

    if (entity instanceof IMobileEntity) {
      this.removeGravity((IMobileEntity) entity);
    }

    // 3. detach all controllers
    entity.detachControllers();

    if (entity instanceof Emitter) {
      Emitter em = (Emitter) entity;
      em.deactivate();
    }

    if (this.loaded && (entity instanceof LightSource || entity instanceof StaticShadow)) {
      this.updateLighting(entity);
    }

    entity.removed(this);
}public void remove(final IEntity entity) {
    if (entity == null) {
      return;
    }

    this.allEntities.remove(entity.getMapId());
    Iterator<List<IEntity>> iter = this.layerEntities.values().iterator();
    while (iter.hasNext()) {
      List<IEntity> layer = iter.next();
      if (layer.remove(entity) && layer.isEmpty()) {
        iter.remove();
      }
    }
    if (this.miscEntities.get(entity.getRenderType()) != null) {
      this.miscEntities.get(entity.getRenderType()).values().remove(entity);
    }

    for (String tag : entity.getTags()) {
      if (this.getEntitiesByTag().containsKey(tag)) {
        this.getEntitiesByTag().get(tag).remove(entity);

        if (this.getEntitiesByTag().get(tag).isEmpty()) {
          this.getEntitiesByTag().remove(tag);
        }
      }
    }

    if (entity instanceof Emitter) {
      Emitter emitter = (Emitter) entity;
      this.removeEmitter(emitter);
    }

    if (entity instanceof MapArea) {
      this.mapAreas.remove(entity);
    }

    if (entity instanceof Prop) {
      this.props.remove(entity);
    }

    if (entity instanceof Creature) {
      this.creatures.remove(entity);
    }

    if (entity instanceof CollisionBox) {
      this.colliders.remove(entity);
      this.staticShadows.removeIf(x -> x.getOrigin() != null && x.getOrigin().equals(entity));
    }

    if (entity instanceof LightSource) {
      this.lightSources.remove(entity);
      this.updateLighting(entity);
    }

    if (entity instanceof Trigger) {
      this.triggers.remove(entity);
    }

    if (entity instanceof Spawnpoint) {
      this.spawnPoints.remove(entity);
    }
    if (entity instanceof SoundSource) {
      this.soundSources.remove(entity);
    }

    if (entity instanceof StaticShadow) {
      this.staticShadows.remove(entity);
      this.updateLighting(entity);
    }

    if (entity instanceof IMobileEntity) {
      this.mobileEntities.values().remove(entity);
    }

    if (entity instanceof ICombatEntity) {
      this.combatEntities.values().remove(entity);
    }

    this.unload(entity);

    this.fireEntityEvent(l -> l.entityRemoved(entity));
}
}
```
```java
class de.gurkenlabs.litiengine.physics.MovementController {
@Override
  public void update() {
    this.handleForces();
    this.handleMovement();
}
}
```
```java
class de.gurkenlabs.litiengine.Game {
static synchronized void terminate() {
    if (!initialized) {
      return;
    }

    hasStarted = false;
    initialized = false;

    config().save();
    gameLoop.terminate();
    tweenEngine.terminate();
    soundEngine.terminate();

    world().clear();

    for (final GameListener listener : gameListeners) {
      try {
        listener.terminated();
      } catch (Exception e) {
        log().log(Level.WARNING, "game listener threw an exception during shutdown", e);
      }
    }

    gameLoop = null;
    screenManager = null;
    gameWindow = null;
}public static synchronized void start() {
    if (!initialized) {
      throw new IllegalStateException(
          "The game cannot be started without being first initialized. Call Game.init(...) before Game.start().");
    }

    gameLoop.start();
    tweenEngine.start();
    soundEngine.start();

    for (final GameListener listener : gameListeners) {
      listener.started();
    }

    hasStarted = true;
}public static synchronized void init(String... args) {
    if (initialized) {
      log().log(Level.INFO, "The game has already been initialized.");
      return;
    }

    log.init();
    handleCommandLineArguments(args);

    config().load();
    Locale.setDefault(new Locale(config().client().getCountry(), config().client().getLanguage()));

    gameLoop = new GameLoop("Main Update Loop", config().client().getMaxFps());
    loop().attach(physics());
    loop().attach(world());

    // setup default exception handling for render and update loop
    setUncaughtExceptionHandler(
        new DefaultUncaughtExceptionHandler(config().client().exitOnError()));

    screenManager = new ScreenManager();
    gameWindow = new GameWindow();

    // initialize  the game window
    window().init();
    world.setCamera(new Camera());

    for (GameListener listener : gameListeners) {
      listener.initialized(args);
    }

    if (!isInNoGUIMode()) {
      window().getRenderComponent().onRendered(g -> metrics().render(g));

      graphics()
          .addEntityRenderedListener(
              e -> DebugRenderer.renderEntityDebugInfo(e.getGraphics(), e.getEntity()));

      window().getRenderComponent().onFpsChanged(fps -> metrics().setFramesPerSecond(fps));
      window()
          .setIcons(
              Arrays.asList(
                  Resources.images().get("liti-logo-x16.png"),
                  Resources.images().get("liti-logo-x20.png"),
                  Resources.images().get("liti-logo-x32.png"),
                  Resources.images().get("liti-logo-x48.png")));

      Input.keyboard()
          .onKeyTyped(
              KeyEvent.VK_PRINTSCREEN,
              key -> {
                // don't take a screenshot if a modifier is active
                if (key.getModifiers() != 0) {
                  return;
                }

                window().getRenderComponent().takeScreenshot();
              });
    }

    Runtime.getRuntime().addShutdownHook(new Thread(Game::terminate, "Shutdown"));

    initialized = true;
}
}
```


Response Format:
Provide the answer in **XML format** as follows:

#### If the method **cannot** return `null` at the specific call site:
```xml
<response>
  <reason><![CDATA[EXPLAIN WHY THE INVOCATION Game.loop() RESULT CANNOT BE NULL.]]></reason>
  <value>NO</value>
</response>

#### If the method can return null at the specific call site:
<response>
  <reason><![CDATA[EXPLAIN WHY THE INVOCATION Game.loop() RESULT CAN BE NULL.]]></reason>
  <value>YES</value>
</response>

#### If you are unsure or If there are any methods that directly or indirectly affect the return value and are not fully disclosed, request their declarations first, in the following format:
<response>
  <reason><![CDATA[EXPLAIN WHY THIS METHOD DECLARATION IS NECESSARY AND WHY YOU CANNOT MAKE A CONFIDENT DECISION WITHOUT IT]]></reason>
  <success>false</success>
  <methods>
    <method>methodName</method>
  </methods>
</response>

Additional Notes:
Be precise in your reasoning.
If a method’s return value depends on another method not provided, request its declaration before making a conclusion.
If the method can return null in this case but not in others, explain why it happens specifically for this call.

---ChatGPT.sendRequestToOpenAI---
Retrieving response from cache
---Response.<init>---
Creating Response:
```xml
<response>
  <reason><![CDATA[The method `Game.loop()` returns the static field `gameLoop`, which is initialized in the `Game.init(String... args)` method. In this method, a new `GameLoop` object is instantiated and assigned to `gameLoop`. Since `init()` must be called before `start()`, which is implied by the requirement of initializing the game, the `gameLoop` is guaranteed to be non-null during the lifetime of the game execution where `Game.loop()` is called. The absence of any code that could set `gameLoop` to null after its initialization ensures that `Game.loop()` cannot return null.]]></reason>
  <value>NO</value>
</response>
```
---Response.<init>---
Response created:
Disagreement: The method `Game.loop()` returns the static field `gameLoop`, which is initialized in the `Game.init(String... args)` method. In this method, a new `GameLoop` object is instantiated and assigned to `gameLoop`. Since `init()` must be called before `start()`, which is implied by the requirement of initializing the game, the `gameLoop` is guaranteed to be non-null during the lifetime of the game execution where `Game.loop()` is called. The absence of any code that could set `gameLoop` to null after its initialization ensures that `Game.loop()` cannot return null.
---AdvancedNullAwayCodeFix.resolveMethodDereferenceError---
Method is not returning nullable on call site. Injecting suppression annotation.
---AdvancedNullAwayCodeFix.constructCastToNonnullChange---
Constructing cast to nonnull change for reason: The method `Game.loop()` returns the static field `gameLoop`, which is initialized in the `Game.init(String... args)` method. In this method, a new `GameLoop` object is instantiated and assigned to `gameLoop`. Since `init()` must be called before `start()`, which is implied by the requirement of initializing the game, the `gameLoop` is guaranteed to be non-null during the lifetime of the game execution where `Game.loop()` is called. The absence of any code that could set `gameLoop` to null after its initialization ensures that `Game.loop()` cannot return null.
---ChatGPT.ask---
Asking ChatGPT:
For the reason you mentioned earlier:

"The method `Game.loop()` returns the static field `gameLoop`, which is initialized in the `Game.init(String... args)` method. In this method, a new `GameLoop` object is instantiated and assigned to `gameLoop`. Since `init()` must be called before `start()`, which is implied by the requirement of initializing the game, the `gameLoop` is guaranteed to be non-null during the lifetime of the game execution where `Game.loop()` is called. The absence of any code that could set `gameLoop` to null after its initialization ensures that `Game.loop()` cannot return null."

in the method below, the expression Game.loop() is not nullable at the point it is used.

```java
public void detach() {
    Game.loop().detach(this);
}
```
Please Summarize the reason in max 5 words and rewrite the method so that at the line "    Game.loop().detach(this);", at the occurrence of: "Game.loop()" is replaced with `NullabilityUtil.castToNonnull(Game.loop(), summary of reason)`
Replace "REASON" with the exact reason summary I provide to you (maximum 5 words), not with a generic explanation like "checked to be nonnull".
see the example below, for expression `foo.getBar()`, to wrap it with `NullabilityUtil.castToNonnull(foo.getBar(), "reason")`.

```java
public t(){
    String l = foo.getBar();
}
```

will be:
```java
public t(){
    String l = NullabilityUtil.castToNonnull(foo.getBar(), "checked to be nonnull");
}
```

### Instructions:

Do not import any additional classes.

Do not add Java comments.

Only modify relevant lines as required.

Return only the modified method wrapped in the XML format shown below.

Place the Java code inside the <code> tag using a CDATA block with ```java formatting.

Just give me the fixed code snippet in XML format in <response> tag like the example below. I will apply the fix to my codebase. Do not import any additional libraries or classes or add java comments. If you can provide the fixed code snippet, please provide it in the following format and place the code snippet in the <code> tag within ```java block.
<response>
  <success>true</success>
  <code><![CDATA[
  ```java
  Your fixed code snippet here
  ```
    ]]>
  </code>
</response>

---ChatGPT.sendRequestToOpenAI---
Retrieving response from cache
---Response.<init>---
Creating Response:
<response>
  <success>true</success>
  <code><![CDATA[
  ```java
  public void detach() {
      NullabilityUtil.castToNonnull(Game.loop(), "cannot return null").detach(this);
  }
  ```
    ]]>
  </code>
</response>
---Response.<init>---
Response created:
public void detach() {
      NullabilityUtil.castToNonnull(Game.loop(), "cannot return null").detach(this);
  }
---ChatGPT.fixDereferenceByAddingCastToNonnull---
Fixing the error by adding castToNonnull
---AdvancedNullAwayCodeFix.fixTriggeredErrorsForLocation---
Resolving unresolvable error for triggered error: Type='DEREFERENCE_NULLABLE', message='dereferenced expression Game.loop() is @Nullable'
/home/nima/Developer/nullness-benchmarks/litiengine/src/de/gurkenlabs/litiengine/environment/Environment.java:2426
      Game.loop().detach((IUpdateable) entity);
---AdvancedNullAwayCodeFix.fix---
Fixing error: Type='DEREFERENCE_NULLABLE', message='dereferenced expression Game.loop() is @Nullable'
/home/nima/Developer/nullness-benchmarks/litiengine/src/de/gurkenlabs/litiengine/environment/Environment.java:2426
      Game.loop().detach((IUpdateable) entity);
---AdvancedNullAwayCodeFix.resolveDereferenceError---
Resolving dereference error: Type='DEREFERENCE_NULLABLE', message='dereferenced expression Game.loop() is @Nullable'
/home/nima/Developer/nullness-benchmarks/litiengine/src/de/gurkenlabs/litiengine/environment/Environment.java:2426
      Game.loop().detach((IUpdateable) entity);
---AdvancedNullAwayCodeFix.resolveDereferenceError---
Checking nullability possibility at error point
---ChatGPT.checkNullabilityPossibilityAtErrorPoint---
Asking if the expression can be null at error point point
---ChatGPT.ask---
Asking ChatGPT:
In the method below, is there a possibility that the expression "Game.loop()" at line "Game.loop().detach((IUpdateable) entity);" is null?
private void unload(final IEntity entity) {
    // 1. remove from physics engine
    if (entity instanceof ICollisionEntity) {
      Game.physics().remove((ICollisionEntity) entity);
    }

    // 2. unregister from update
    if (entity instanceof IUpdateable) {
      Game.loop().detach((IUpdateable) entity);
    }

    if (entity instanceof IMobileEntity) {
      this.removeGravity((IMobileEntity) entity);
    }

    // 3. detach all controllers
    entity.detachControllers();

    if (entity instanceof Emitter) {
      Emitter em = (Emitter) entity;
      em.deactivate();
    }

    if (this.loaded && (entity instanceof LightSource || entity instanceof StaticShadow)) {
      this.updateLighting(entity);
    }

    entity.removed(this);
}
Give a single-word answer in XML format. If it is possible for the expression to be null, respond with:
```xml
<response>
    <reason><![CDATA[YOUR REASON]]></reason>
    <value>YES</value>
</response>
```
If it is not possible for the expression to be null, respond with:
```xml
<response>
    <reason><![CDATA[YOUR REASON]]></reason>
    <value>NO</value>
</response>
```
If you are unsure or need more information, respond with where you can ask for more details or what specific information you need.

If additional information is required, list each request inside a `<request>` tag. If no additional information is needed, omit the `<requests>` section.

Respond with:
```xml
<response>
    <reason><![CDATA[YOUR REASON]]></reason>
    <value>UNKNOWN</value>
    <!-- Include <requests> only if additional information is needed -->
    <requests>
        <request><![CDATA[YOUR REQUEST 1]]></request>
        <request><![CDATA[YOUR REQUEST 2]]></request>
    </requests>
</response>
```
---ChatGPT.sendRequestToOpenAI---
Retrieving response from cache
---Response.<init>---
Creating Response:
```xml
<response>
    <reason><![CDATA[The provided code snippet does not include any information on how `Game.loop()` is implemented or initialized. Without knowing how `Game.loop()` is defined or whether it can return null, it's impossible to determine if the expression can be null.]]></reason>
    <value>UNKNOWN</value>
    <requests>
        <request><![CDATA[Please provide the implementation details or documentation of the Game.loop() method.]]></request>
        <request><![CDATA[Please confirm if there are any circumstances under which Game.loop() could return null.]]></request>
    </requests>
</response>
```
---Response.<init>---
Response created:
Unknown: The provided code snippet does not include any information on how `Game.loop()` is implemented or initialized. Without knowing how `Game.loop()` is defined or whether it can return null, it's impossible to determine if the expression can be null.
---AdvancedNullAwayCodeFix.resolveMethodDereferenceError---
Resolving method dereference error.
---AdvancedNullAwayCodeFix.resolveMethodDereferenceError---
Method is in annotated package. Checking if the method is returning nullable.
---AdvancedNullAwayCodeFix.investigateMethodReturnNullability---
Checking if the method is returning nullable.
---ChatGPT.checkIfMethodIsReturningNullable---
Asking if the method is returning nullable: loop()
---ChatGPT.ask---
Asking ChatGPT:
In the method below, is there a possibility that the method returns null based only on its body? Consider the following points:

- The method may have multiple return paths; consider all return statements.
- If the method calls another method, do not assume its return value unless its full declaration is provided. Request its declaration if needed.
- The method may throw an exception instead of returning null. An exception path should not be considered a null return.
- Ensure you request the declarations of any methods whose return values directly or indirectly impact this method’s return value before making a conclusion.
- Carefully analyze all conditions and prior operations that may guarantee a non-null return value.

@Nullable public static IGameLoop loop() {
    return gameLoop;
}

Here are the method definitions in addition to the method inquired:

Depth: 0
```java
class de.gurkenlabs.litiengine.Game {
@Nullable public static IGameLoop loop() {
    return gameLoop;
}
}
```


Response Format:
Provide the answer in **XML format** as follows:

#### If the method **cannot** return `null`:
```xml
<response>
  <reason><![CDATA[EXPLAIN WHY THE METHOD CANNOT RETURN NULL]]></reason>
  <value>NO</value>
</response>
```

#### If the method can return null:
```xml
<response>
  <reason><![CDATA[EXPLAIN WHY THE METHOD CAN RETURN NULL]]></reason>
  <value>YES</value>
</response>
```

#### If you are unsure or need more information, respond with where you can ask for more details or what specific information you need.

#### If you are unsure or If there are any methods that directly or indirectly affect the return value and are not fully disclosed, request their declarations first, in the following format:
<response>
  <reason><![CDATA[YOUR REASON]]></reason>
  <value>UNKNOWN</value>
  <methods>
    <method>methodName</method>
  </methods>
</response>

If additional information is required other than method declaration, list each request inside a `<request>` tag. If no additional information is needed, omit the `<requests>` section.

Respond with:
```xml
<response>
    <reason><![CDATA[YOUR REASON]]></reason>
    <value>UNKNOWN</value>
    <!-- Include <requests> only if additional information is needed -->
    <requests>
        <request><![CDATA[YOUR REQUEST 1]]></request>
        <request><![CDATA[YOUR REQUEST 2]]></request>
    </requests>
</response>
```

Additional Notes:
Be precise in your reasoning.
If a method’s return value depends on another method not provided, request its declaration before making a conclusion.
If the method can return null in some cases but not others, explain under what conditions it can happen.

---ChatGPT.sendRequestToOpenAI---
Retrieving response from cache
---Response.<init>---
Creating Response:
```xml
<response>
  <reason><![CDATA[The method `loop` returns the variable `gameLoop`. Without the initialization or assignment details of `gameLoop`, it's unclear whether it can be null. The possibility of `gameLoop` being uninitialized or set to null elsewhere in the program means `loop` could potentially return null. Further information on `gameLoop` is required.]]></reason>
  <value>UNKNOWN</value>
  <requests>
    <request><![CDATA[Please provide the declaration and initialization of the variable `gameLoop` in the class `de.gurkenlabs.litiengine.Game`.]]></request>
  </requests>
</response>
```
---Response.<init>---
Response created:
Unknown: The method `loop` returns the variable `gameLoop`. Without the initialization or assignment details of `gameLoop`, it's unclear whether it can be null. The possibility of `gameLoop` being uninitialized or set to null elsewhere in the program means `loop` could potentially return null. Further information on `gameLoop` is required.
---AdvancedNullAwayCodeFix.investigateMethodReturnNullability---
Could not determine the nullability and model did not ask for any method.
---ChatGPT.checkIfMethodIsReturningNullableOnCallSite---
Asking if the method is returning nullable on the call site: Game.loop()
---ChatGPT.ask---
Asking ChatGPT:
In the method below, is there a possibility that the method returns null at the given call site?

```java
@Nullable public static IGameLoop loop() {
    return gameLoop;
}
```

## Guidelines:
- The method may have multiple return paths; consider all return statements.
- If the method calls another method, do not assume its return value unless its full declaration is provided. Request its declaration if needed.
- The method may throw an exception instead of returning null. An exception path should not be considered a null return.
- Ensure you request the declarations of any methods whose return values directly or indirectly impact this method’s return value before making a conclusion.
- If the method returns a value that is determined by a parameter, evaluate based on the actual argument at the given call site.
- Analyze based only on the specific invocation provided. Do not generalize to all possible inputs.- If the return value is guaranteed to be non-null at the call site, the answer should be a definitive NO.
- Do not generalize based on all possible inputs—your answer must be based only on the given invocation.
- Focus only on the given call site, not all possible invocations.

### call site:
Game.loop()

Here are the method definitions and the call chain for this method, showing the sequence of calls from the method to its callers at each depth level:

Depth: 0
```java
class de.gurkenlabs.litiengine.Game {
@Nullable public static IGameLoop loop() {
    return gameLoop;
}
}
```
Depth: 1
```java
class de.gurkenlabs.litiengine.environment.GameWorld {
public void loadEnvironment(@Nullable final Environment env) {
    Lock lock = Game.loop().getLock();
    lock.lock();
    try {
      unloadEnvironment();
      this.environment = env;
      if (env != null) {
        this.addEnvironment(env);

        if (env.getGravity() == 0 && this.gravity() != 0) {
          env.setGravity(this.gravity());
        }

        env.load();
        for (final EnvironmentLoadedListener listener : this.loadedListeners) {
          listener.loaded(env);
        }

        // call map specific listeners
        String mapName = getMapName(env);
        if (mapName != null && this.environmentLoadedListeners.containsKey(mapName)) {

          // for the default camera we center the camera on the environment
          if (this.camera().getClass().equals(Camera.class)) {
            camera().setFocus(env.getCenter());
          }

          for (EnvironmentLoadedListener listener : this.environmentLoadedListeners.get(mapName)) {
            listener.loaded(env);
          }
        }
      }
    } finally {
      lock.unlock();
    }
}public void setCamera(@Nullable final ICamera cam) {
    if (this.camera() != null) {
      Game.loop().detach(camera);
    }

    camera = cam;

    if (cam != null && !Game.isInNoGUIMode()) {
      Game.loop().attach(cam);
      cam.updateFocus();
    }
}
}
```
```java
class de.gurkenlabs.litiengine.entities.behavior.EntityNavigator {
public EntityNavigator(final IMobileEntity entity, final PathFinder pathFinder) {
    this.cancelNavigationConditions = new CopyOnWriteArrayList<>();
    this.listeners = new CopyOnWriteArrayList<>();
    this.entity = entity;
    this.pathFinder = pathFinder;
    this.setAcceptableError(DEFAULT_ACCEPTABLE_ERROR);
    Game.loop().attach(this);
}
}
```
```java
class de.gurkenlabs.litiengine.GameWindow {
private static void initializeWindowEventListeners(Window window) {

    window.addWindowStateListener(
        e -> {
          if (e.getNewState() == Frame.ICONIFIED) {
            Game.loop().setTickRate(ICONIFIED_MAX_FPS);
          } else {
            Game.loop().setTickRate(Game.config().client().getMaxFps());
          }
        });

    window.addWindowFocusListener(
        new WindowFocusListener() {
          @Override
          public void windowLostFocus(WindowEvent e) {
            if (Game.config().graphics().reduceFramesWhenNotFocused()) {
              Game.loop().setTickRate(NONE_FOCUS_MAX_FPS);
            }
          }

          @Override
          public void windowGainedFocus(WindowEvent e) {
            Game.loop().setTickRate(Game.config().client().getMaxFps());
          }
        });

    window.addWindowListener(
        new WindowAdapter() {
          @Override
          public void windowClosing(final WindowEvent event) {
            Game.exit();
          }
        });
}
}
```
```java
class de.gurkenlabs.litiengine.gui.screens.ScreenManager {
public void display(@Nullable final Screen screen) {
    if (Game.hasStarted() && Game.time().since(this.lastScreenChange) < this.getChangeCooldown()) {
      log.log(
          Level.INFO,
          "Skipping displaying of screen {0} because screen changing is currently on cooldown.",
          screen != null ? screen.getName() : "");
      return;
    }

    final Screen previous = this.current();
    if (previous != null) {
      previous.suspend();
    }

    if (screen != null && !this.screens.contains(screen)) {
      this.screens.add(screen);
    }

    this.currentScreen = screen;
    if (!Game.isInNoGUIMode() && this.current() != null) {
      this.current().prepare();
    }

    this.lastScreenChange = Game.loop().getTicks();

    final ScreenChangedEvent event = new ScreenChangedEvent(this.current(), previous);
    for (final ScreenChangedListener listener : this.screenChangedListeners) {
      listener.changed(event);
    }
}
}
```
```java
class de.gurkenlabs.litiengine.abilities.effects.Effect {
@Override
  public void update() {

    for (final Iterator<EffectApplication> iterator = this.getActiveAppliances().iterator();
        iterator.hasNext(); ) {
      final EffectApplication appliance = iterator.next();
      // if the effect duration is reached
      if (this.hasEnded(appliance)) {

        iterator.remove();
        this.cease(appliance);
      }
    }

    // 4. unregister if all appliances are finished
    if (this.getActiveAppliances().isEmpty()) {
      Game.loop().detach(this);
    }
}public void apply(final Shape impactArea) {
    final List<ICombatEntity> affected = this.lookForAffectedEntities(impactArea);
    for (final ICombatEntity affectedEntity : affected) {
      this.apply(affectedEntity);
    }

    this.appliances.add(new EffectApplication(affected, impactArea));

    // if it is the first appliance -> register for update
    if (this.appliances.size() == 1) {
      Game.loop().attach(this);
    }
}
}
```
```java
class de.gurkenlabs.litiengine.GameTime {
public long toTicks(final int milliseconds) {
    return this.toTicks(milliseconds, Game.loop().getTickRate());
}public long since(final long tick) {
    return toMilliseconds(Game.loop().getTicks() - tick);
}public long now() {
    return Game.loop().getTicks();
}public long sinceGameStart() {
    return this.toMilliseconds(Game.loop().getTicks());
}@Override
  public void loaded(Environment environment) {
    environmentLoaded = Game.loop().getTicks();
}public long toMilliseconds(final long ticks) {
    return this.toMilliseconds(ticks, Game.loop().getTickRate());
}
}
```
```java
class de.gurkenlabs.litiengine.GameMetrics {
@Override
  public void render(final Graphics2D g) {
    this.updateMetrics();

    if (!Game.config().client().showGameMetrics()) {
      return;
    }

    this.currentOffsetY = 0;

    g.setColor(this.renderColor);

    // render client metrics
    this.drawTitle(g, "[client]");
    this.drawMetric(g, "fps       : " + this.getFramesPerSecond());
    this.drawMetric(g, "max fps   : " + this.maxFramesPerSecond);
    this.drawMetric(g, "updatables: " + Game.loop().getUpdatableCount());

    // render jvm metrics if debug is enabled
    if (Game.config().debug().isDebugEnabled()) {
      this.drawTitle(g, "[jvm]");
      this.drawMetric(g, "java      : " + this.javaVersion);
      this.drawMetric(g, "memory    : " + String.format("%-5.5s", this.usedMemory) + " MB");
      this.drawMetric(g, "threads   : " + Thread.activeCount());
    }

    // render rendering metrics
    if (!this.renderMetrics.isEmpty()) {
      this.drawTitle(g, "[update]");

      for (RenderMetrics metric : this.renderMetrics) {
        this.drawMetric(g, metric.toString());
      }

      this.renderMetrics.clear();
    }
}
}
```
```java
class de.gurkenlabs.litiengine.graphics.emitters.Emitter {
public void deactivate() {
    if (!this.activated) {
      return;
    }

    this.activated = false;
    this.getParticles().clear();
    this.aliveTime = 0;
    this.activationTick = 0;
    this.lastSpawn = 0;
    Game.loop().detach(this);
}public void activate() {
    if (this.activated) {
      return;
    }

    this.activated = true;
    this.activationTick = Game.time().now();
    Game.loop().attach(this);
}@Override
  public void update() {
    if (this.isPaused()) {
      return;
    }

    // clear particles if the effect time to life is reached
    if (this.isFinished()) {
      for (EmitterFinishedListener listener : this.finishedListeners) {
        listener.finished(this);
      }

      this.delete();
      return;
    }

    final float updateRatio = (float) this.data().getUpdateRate() / Game.loop().getTickRate();
    for (final Particle p : this.getParticles().stream().collect(Collectors.toList())) {
      if (this.particleCanBeRemoved(p)) {
        // remove dead particles
        this.particles.remove(p);
        continue;
      }

      p.update(this.getOrigin(), updateRatio);
    }

    this.aliveTime = Game.time().since(this.activationTick);
    if ((this.data().getSpawnRate() == 0
        || Game.time().since(this.lastSpawn) >= this.data().getSpawnRate())) {
      this.lastSpawn = Game.time().now();
      this.spawnParticle();
    }
}
}
```
```java
class de.gurkenlabs.litiengine.entities.behavior.IBehaviorController {
public default void attach() {
    Game.loop().attach(this);
}public default void detach() {
    Game.loop().detach(this);
}
}
```
```java
class de.gurkenlabs.litiengine.abilities.AbilityExecution {
AbilityExecution(final Ability ability) {
    this.appliedEffects = new CopyOnWriteArrayList<>();
    this.ability = ability;
    this.executionTicks = Game.time().now();
    this.impactArea = ability.calculateImpactArea();
    this.castLocation = ability.getExecutor().getCenter();
    Game.loop().attach(this);
}@Override
  public void update() {
    // if there a no effects to apply -> unregister this instance and we're done
    if (this.getAbility().getEffects().isEmpty()
        || this.getAbility().getEffects().size() == this.getAppliedEffects().size()) {
      Game.loop().detach(this);
      return;
    }

    // handle all effects from the ability that were not applied yet
    for (final Effect effect : this.getAbility().getEffects()) {
      // if the ability was not executed yet or the delay of the effect is not
      // yet reached
      if (this.getAppliedEffects().contains(effect)
          || Game.time().since(this.getExecutionTicks()) < effect.getDelay()) {
        continue;
      }

      effect.apply(this.getExecutionImpactArea());
      this.getAppliedEffects().add(effect);
    }
}
}
```
```java
class de.gurkenlabs.litiengine.GameWindow$3 {
@Override
          public void windowGainedFocus(WindowEvent e) {
            Game.loop().setTickRate(Game.config().client().getMaxFps());
}@Override
          public void windowLostFocus(WindowEvent e) {
            if (Game.config().graphics().reduceFramesWhenNotFocused()) {
              Game.loop().setTickRate(NONE_FOCUS_MAX_FPS);
            }
}
}
```
```java
class de.gurkenlabs.litiengine.environment.EntitySpawner {
protected void spawnNewEntities() {
    if (this.getSpawnMode() != SpawnMode.CUSTOMSPAWNPOINTS && this.getSpawnPoints().isEmpty()) {
      return;
    }

    switch (this.getSpawnMode()) {
      case ALLSPAWNPOINTS:
        for (int i = 0; i < this.getSpawnPoints().size(); i++) {
          final int index = i;
          Game.loop()
              .perform(
                  this.getSpawnDelay() + this.getSpawnDelay() * i,
                  () -> this.spawn(this.getSpawnPoints().get(index), this.getSpawnAmount()));
        }
        break;
      case ONERANDOMSPAWNPOINT:
        this.spawn(Game.random().choose(this.getSpawnPoints()), this.getSpawnAmount());
        break;
      case RANDOMSPAWNPOINTS:
        for (int i = 0; i < this.getSpawnAmount(); i++) {
          Game.loop()
              .perform(
                  this.getSpawnDelay() + this.getSpawnDelay() * i,
                  () -> this.spawn(Game.random().choose(this.getSpawnPoints()), 1));
        }
        break;
      case CUSTOMSPAWNPOINTS:
        List<Spawnpoint> spawnPoints =
            this.customSpawnpoints != null
                ? this.customSpawnpoints.apply(this)
                : this.getCustomSpawnpoints();

        int index = 0;
        for (Spawnpoint spawn : spawnPoints) {
          Game.loop()
              .perform(
                  this.getSpawnDelay() + this.getSpawnDelay() * index, () -> this.spawn(spawn, 1));
          index++;
        }
        break;
      default:
        break;
    }
}
}
```
```java
class de.gurkenlabs.litiengine.tweening.TweenEngine {
@Override
  public void start() {
    Game.loop().attach(this);
}@Override
  public void terminate() {
    Game.loop().detach(this);
}
}
```
```java
class de.gurkenlabs.litiengine.gui.SpeechBubble {
public void hide() {
    Game.world().environment().removeRenderable(this);
    Game.loop().detach(this);
    if (activeSpeechBubbles.get(this.getEntity()) != null
        && activeSpeechBubbles.remove(this.getEntity()).equals(this)) {
      activeSpeechBubbles.remove(this.getEntity());
    }

    for (SpeechBubbleListener listener : this.listeners) {
      listener.hidden();
    }
}private SpeechBubble(
      final IEntity entity,
      final String text,
      @Nullable SpeechBubbleAppearance appearance,
      @Nullable Font font) {
    if (appearance == null) {
      this.appearance = DEFAULT_APPEARANCE;
    } else {
      this.appearance = appearance;
    }

    final SpeechBubble active = activeSpeechBubbles.get(entity);
    if (active != null) {
      active.hide();
    }
    this.setFont(font);

    this.textBoxWidth = (float) (entity.getWidth() * 4);
    this.entity = entity;

    this.currentText = text;
    this.currentTextDisplayTime = DISPLAYTIME_MIN + text.length() * DISPLAYTIME_PER_LETTER;

    this.lastTextDisplay = Game.time().now();
    this.createBubbleImage();
    entity.getEnvironment().add(this, RenderType.UI);
    Game.loop().attach(this);
    activeSpeechBubbles.put(entity, this);
}
}
```
```java
class de.gurkenlabs.litiengine.entities.Prop {
private void updateAnimationController() {
    IEntityAnimationController<?> controller = this.createAnimationController();
    this.getControllers().addController(controller);
    if (Game.world().environment() != null && Game.world().environment().isLoaded()) {
      Game.loop().attach(controller);
    }
}
}
```
```java
class de.gurkenlabs.litiengine.graphics.FreeFlightCamera {
public FreeFlightCamera(final Point2D focus) {
    this.setFocus(focus);
    this.velocity = DEFAULT_SCROLL_PIXELS_PER_SECOND;
    this.scrollPadding = DEFAULT_SCROLL_PADDING;
    this.setClampToMap(true);

    Game.loop().attach(this);
}private void handleFreeFlightCamera() {
    if (Game.world().environment() == null || Game.world().environment().getMap() == null) {
      return;
    }

    final Point2D mouseLocation = Input.mouse().getLocation();

    final double scrollSpeed =
        this.getVelocity()
            / (double) Game.loop().getTickRate()
            * Game.config().input().getMouseSensitivity();

    double x = this.getFocus().getX();
    double y = this.getFocus().getY();

    double deltaX = 0;
    if (mouseLocation.getX() < this.getScrollPadding()) {
      deltaX -= scrollSpeed;
    } else if (Game.window().getResolution().getWidth() - mouseLocation.getX()
        < this.getScrollPadding()) {
      deltaX += scrollSpeed;
    }

    double deltaY = 0;
    if (mouseLocation.getY() < this.getScrollPadding()) {
      deltaY -= scrollSpeed;
    } else if (Game.window().getResolution().getHeight() - mouseLocation.getY()
        < this.getScrollPadding()) {
      deltaY += scrollSpeed;
    }

    x += deltaX;
    y += deltaY;

    this.setFocus(new Point2D.Double(x, y));
}
}
```
```java
class de.gurkenlabs.litiengine.environment.Environment {
private static void dispose(final Collection<? extends IEntity> entities) {
    for (final IEntity entity : entities) {
      if (entity instanceof IUpdateable) {
        Game.loop().detach((IUpdateable) entity);
      }

      entity.detachControllers();
    }
}private static void loadUpdatableOrEmitterEntity(IEntity entity) {
    if (entity instanceof Emitter) {
      final Emitter emitter = (Emitter) entity;
      if (emitter.isActivateOnInit()) {
        emitter.activate();
      }
    } else if (entity instanceof IUpdateable) {
      Game.loop().attach((IUpdateable) entity);
    }
}private void unload(final IEntity entity) {
    // 1. remove from physics engine
    if (entity instanceof ICollisionEntity) {
      Game.physics().remove((ICollisionEntity) entity);
    }

    // 2. unregister from update
    if (entity instanceof IUpdateable) {
      Game.loop().detach((IUpdateable) entity);
    }

    if (entity instanceof IMobileEntity) {
      this.removeGravity((IMobileEntity) entity);
    }

    // 3. detach all controllers
    entity.detachControllers();

    if (entity instanceof Emitter) {
      Emitter em = (Emitter) entity;
      em.deactivate();
    }

    if (this.loaded && (entity instanceof LightSource || entity instanceof StaticShadow)) {
      this.updateLighting(entity);
    }

    entity.removed(this);
}
}
```
```java
class de.gurkenlabs.litiengine.graphics.animation.Animation {
@Override
  public void update() {
    // do nothing if the animation is not playing or the current keyframe is not finished
    if (!this.isPlaying()
        || Game.time().since(this.lastFrameUpdate) < this.getCurrentKeyFrame().getDuration()) {
      return;
    }

    // if we are not looping and the last keyframe is finished, we terminate the animation
    if (!this.isLooping() && this.isLastKeyFrame()) {
      this.terminate();
      return;
    }

    // make sure, we stay inside the keyframe list
    final int newFrameIndex =
        (this.getKeyframes().indexOf(this.currentFrame) + 1) % this.getKeyframes().size();
    final KeyFrame previousFrame = this.currentFrame;
    this.currentFrame = this.getKeyframes().get(newFrameIndex);

    for (KeyFrameListener listener : this.listeners) {
      listener.currentFrameChanged(previousFrame, this.currentFrame);
    }

    this.lastFrameUpdate = Game.loop().getTicks();
}public void restart() {
    this.currentFrame = this.firstFrame;
    this.lastFrameUpdate = Game.loop().getTicks();
}
}
```
```java
class de.gurkenlabs.litiengine.physics.MovementController {
@Override
  public void attach() {
    Game.loop().attach(this);
}private void handleForces() {
    // clean up forces
    this.activeForces.forEach(
        x -> {
          if (x.hasEnded()) {
            this.activeForces.remove(x);
          }
        });

    if (this.activeForces.isEmpty()) {
      return;
    }

    // disable turn-on-move for force handling
    boolean turn = this.getEntity().turnOnMove();
    this.getEntity().setTurnOnMove(false);
    try {
      double deltaX = 0;
      double deltaY = 0;
      for (final Force force : this.activeForces) {
        if (force.cancelOnReached() && force.hasReached(this.getEntity())) {
          force.end();
          continue;
        }

        final Point2D collisionBoxCenter = this.getEntity().getCollisionBoxCenter();
        final double angle =
            GeometricUtilities.calcRotationAngleInDegrees(collisionBoxCenter, force.getLocation());
        final double strength =
            Game.loop().getDeltaTime() * 0.001f * force.getStrength() * Game.loop().getTimeScale();
        deltaX += GeometricUtilities.getDeltaX(angle, strength);
        deltaY += GeometricUtilities.getDeltaY(angle, strength);
      }

      final Point2D target =
          new Point2D.Double(this.getEntity().getX() + deltaX, this.getEntity().getY() + deltaY);
      final boolean success = Game.physics().move(this.getEntity(), target);
      if (!success) {
        for (final Force force : this.activeForces) {
          if (force.cancelOnCollision()) {
            force.end();
          }
        }
      }
    } finally {
      this.getEntity().setTurnOnMove(turn);
    }
}@Override
  public void detach() {
    Game.loop().detach(this);
}public void handleMovement() {
    if (!this.isMovementAllowed()) {
      this.velocity = 0;
      return;
    }

    // max distance an entity can travel within one tick
    final double maxPixelsPerTick = this.getEntity().getTickVelocity();
    final double deltaTime = Game.loop().getDeltaTime() * Game.loop().getTimeScale();

    final double acceleration =
        this.getEntity().getAcceleration() == 0
            ? maxPixelsPerTick
            : deltaTime / this.getEntity().getAcceleration() * maxPixelsPerTick;
    final double deceleration =
        this.getEntity().getDeceleration() == 0
            ? this.getVelocity()
            : deltaTime / this.getEntity().getDeceleration() * maxPixelsPerTick;

    double dx = this.getDx();
    double dy = this.getDy();
    this.setDx(0);
    this.setDy(0);

    final double deltaVelocity =
        Math.min(Math.sqrt(Math.pow(dx, 2) + Math.pow(dy, 2)), acceleration);
    if (deltaVelocity != 0) {
      double newVelocity = this.getVelocity() + deltaVelocity;
      this.setVelocity(newVelocity);
    } else {
      final double newVelocity = Math.max(0, this.getVelocity() - deceleration);
      this.setVelocity(newVelocity);
      dx = GeometricUtilities.getDeltaX(this.moveAngle);
      dy = GeometricUtilities.getDeltaY(this.moveAngle);
    }

    if (this.getVelocity() == 0) {
      this.moveAngle = 0;
      return;
    }

    // actually move entity
    this.moveEntity(dx, dy);
}
}
```
```java
class de.gurkenlabs.litiengine.graphics.animation.AnimationController {
public void detach() {
    Game.loop().detach(this);
}public void attach() {
    Game.loop().attach(this);
}
}
```
```java
class de.gurkenlabs.litiengine.graphics.Camera {
@Override
  public void setZoom(final float targetZoom, final int delay) {
    if (delay == 0) {

      this.zoom = targetZoom;
      this.targetZoom = 0;
      this.zoomDelay = 0;
      this.zoomTick = 0;
      this.zoomStep = 0;

      final ZoomChangedEvent event = new ZoomChangedEvent(this, targetZoom);
      for (final ZoomChangedListener listener : this.zoomListeners) {
        listener.zoomChanged(event);
      }
    } else {
      this.zoomTick = Game.time().now();
      this.targetZoom = targetZoom;
      this.zoomDelay = delay;

      final double tickduration = 1000 / (double) Game.loop().getTickRate();
      final double tickAmount = delay / tickduration;
      final float totalDelta = this.targetZoom - this.zoom;
      this.zoomStep = tickAmount > 0 ? (float) (totalDelta / tickAmount) : totalDelta;
    }
}
}
```
```java
class de.gurkenlabs.litiengine.Game {
public static synchronized void init(String... args) {
    if (initialized) {
      log().log(Level.INFO, "The game has already been initialized.");
      return;
    }

    log.init();
    handleCommandLineArguments(args);

    config().load();
    Locale.setDefault(new Locale(config().client().getCountry(), config().client().getLanguage()));

    gameLoop = new GameLoop("Main Update Loop", config().client().getMaxFps());
    loop().attach(physics());
    loop().attach(world());

    // setup default exception handling for render and update loop
    setUncaughtExceptionHandler(
        new DefaultUncaughtExceptionHandler(config().client().exitOnError()));

    screenManager = new ScreenManager();
    gameWindow = new GameWindow();

    // initialize  the game window
    window().init();
    world.setCamera(new Camera());

    for (GameListener listener : gameListeners) {
      listener.initialized(args);
    }

    if (!isInNoGUIMode()) {
      window().getRenderComponent().onRendered(g -> metrics().render(g));

      graphics()
          .addEntityRenderedListener(
              e -> DebugRenderer.renderEntityDebugInfo(e.getGraphics(), e.getEntity()));

      window().getRenderComponent().onFpsChanged(fps -> metrics().setFramesPerSecond(fps));
      window()
          .setIcons(
              Arrays.asList(
                  Resources.images().get("liti-logo-x16.png"),
                  Resources.images().get("liti-logo-x20.png"),
                  Resources.images().get("liti-logo-x32.png"),
                  Resources.images().get("liti-logo-x48.png")));

      Input.keyboard()
          .onKeyTyped(
              KeyEvent.VK_PRINTSCREEN,
              key -> {
                // don't take a screenshot if a modifier is active
                if (key.getModifiers() != 0) {
                  return;
                }

                window().getRenderComponent().takeScreenshot();
              });
    }

    Runtime.getRuntime().addShutdownHook(new Thread(Game::terminate, "Shutdown"));

    initialized = true;
}
}
```
```java
class de.gurkenlabs.litiengine.entities.Creature {
protected void updateAnimationController() {
    IEntityAnimationController<?> controller = this.createAnimationController();
    this.getControllers().addController(controller);
    if (Game.world().environment() != null && Game.world().environment().isLoaded()) {
      Game.loop().attach(controller);
    }
}@Override
  public float getTickVelocity() {
    // pixels per ms multiplied by the passed ms
    // ensure that entities don't travel too far in case of lag
    return Math.min(Game.loop().getDeltaTime(), GameLoop.TICK_DELTATIME_LAG)
        * 0.001F
        * this.getVelocity().get()
        * Game.loop().getTimeScale();
}
}
```
Depth: 2
```java
class de.gurkenlabs.litiengine.environment.GameWorld {
public void clear() {
    this.unloadEnvironment();
    this.environments.clear();
    this.setCamera(null);
    Game.physics().clear();

    this.environmentListeners.clear();
    this.environmentLoadedListeners.clear();
    this.environmentUnloadedListeners.clear();

    this.listeners.clear();
    this.loadedListeners.clear();
    this.unloadedListeners.clear();
}@Nullable
  public Environment loadEnvironment(IMap map) {
    Environment env = this.getEnvironment(map);
    this.loadEnvironment(env);
    return env;
}@Nullable
  public Environment loadEnvironment(String mapName) {
    Environment env = this.getEnvironment(mapName);
    this.loadEnvironment(env);
    return env;
}
}
```
```java
class de.gurkenlabs.litiengine.GameWindow {
GameWindow() {
    this.hostControl = new JFrame();

    this.resolutionChangedListeners = new CopyOnWriteArrayList<>();

    this.renderCanvas = new RenderComponent(Game.config().graphics().getResolution());
    this.cursor = new MouseCursor();
    if (!Game.isInNoGUIMode()) {
      this.hostControl.setBackground(Color.BLACK);
      this.hostControl.add(this.renderCanvas);

      this.initializeEventListeners();

      this.hostControl.setTitle(Game.info().getTitle());
      this.hostControl.setDefaultCloseOperation(WindowConstants.DO_NOTHING_ON_CLOSE);
      initializeWindowEventListeners(this.hostControl);
    }
}
}
```
```java
class de.gurkenlabs.litiengine.GameTime {
public long sinceEnvironmentLoad() {
    return this.since(this.environmentLoaded);
}public long since(final long tick) {
    return toMilliseconds(Game.loop().getTicks() - tick);
}public long sinceGameStart() {
    return this.toMilliseconds(Game.loop().getTicks());
}
}
```
```java
class de.gurkenlabs.litiengine.abilities.effects.Effect {
protected void cease(final EffectApplication appliance) {
    // 1. cease the effect for all affected entities
    for (final ICombatEntity entity : appliance.getAffectedEntities()) {
      this.cease(entity);
    }

    // 2. apply follow up effects
    this.getFollowUpEffects().forEach(followUp -> followUp.apply(appliance.getImpactArea()));
}protected boolean hasEnded(final EffectApplication appliance) {
    final long effectDuration = Game.time().since(appliance.getAppliedTicks());
    return effectDuration > this.getDuration();
}
}
```
```java
class de.gurkenlabs.litiengine.abilities.effects.EffectApplication {
protected EffectApplication(final List<ICombatEntity> affectedEntities, final Shape impactArea) {
    this.applied = Game.time().now();
    this.affectedEntities = affectedEntities;
    this.impactArea = impactArea;
}
}
```
```java
class de.gurkenlabs.litiengine.entities.CombatEntity {
@Override
  public boolean wasHit(int timeSpan) {
    return Game.time().since(this.lastHit) < timeSpan;
}@Override
  public void hit(final int damage, @Nullable final Ability ability) {
    if (this.isDead()) {
      return;
    }

    if (!this.isIndestructible()) {
      this.getHitPoints().modifyBaseValue(new AttributeModifier<>(Modification.SUBTRACT, damage));
    }

    final EntityHitEvent event = new EntityHitEvent(this, ability, damage, this.isDead());

    for (final CombatEntityListener listener : this.listeners) {
      listener.hit(event);
    }

    for (final CombatEntityHitListener listener : this.hitListeners) {
      listener.hit(event);
    }

    if (this.isDead()) {
      this.fireDeathEvent();
      this.setCollision(false);
    }

    this.lastHit = Game.time().now();
}
}
```
```java
class de.gurkenlabs.litiengine.graphics.ImageEffect {
protected ImageEffect(final int ttl, final String name) {
    this.ttl = ttl;
    this.name = name;
    this.aliveTick = Game.time().now();
}@Override
  public long getAliveTime() {
    return Game.time().since(this.aliveTick);
}
}
```
```java
class de.gurkenlabs.litiengine.abilities.AbilityExecution {
AbilityExecution(final Ability ability) {
    this.appliedEffects = new CopyOnWriteArrayList<>();
    this.ability = ability;
    this.executionTicks = Game.time().now();
    this.impactArea = ability.calculateImpactArea();
    this.castLocation = ability.getExecutor().getCenter();
    Game.loop().attach(this);
}@Override
  public void update() {
    // if there a no effects to apply -> unregister this instance and we're done
    if (this.getAbility().getEffects().isEmpty()
        || this.getAbility().getEffects().size() == this.getAppliedEffects().size()) {
      Game.loop().detach(this);
      return;
    }

    // handle all effects from the ability that were not applied yet
    for (final Effect effect : this.getAbility().getEffects()) {
      // if the ability was not executed yet or the delay of the effect is not
      // yet reached
      if (this.getAppliedEffects().contains(effect)
          || Game.time().since(this.getExecutionTicks()) < effect.getDelay()) {
        continue;
      }

      effect.apply(this.getExecutionImpactArea());
      this.getAppliedEffects().add(effect);
    }
}
}
```
```java
class de.gurkenlabs.litiengine.tweening.TweenEngine {
@Override
  public void update() {
    for (final Tweenable target : this.getTweens().keySet()) {
      for (final Tween tween : this.getTweens().get(target).values()) {
        if (tween.hasStopped()) {
          continue;
        }
        final long elapsed = Game.time().since(tween.getStartTime());
        if (elapsed >= tween.getDuration()) {
          tween.stop();
          continue;
        }
        final float[] currentValues = new float[tween.getTargetValues().length];
        for (int i = 0; i < tween.getTargetValues().length; i++) {
          currentValues[i] =
              tween.getStartValues()[i]
                  + tween.getEquation().compute(elapsed / (float) tween.getDuration())
                      * (tween.getTargetValues()[i] - tween.getStartValues()[i]);
        }
        tween.getTarget().setTweenValues(tween.getType(), currentValues);
      }
    }
}
}
```
```java
class de.gurkenlabs.litiengine.gui.SpeechBubble {
public static SpeechBubble create(
      final IEntity entity, final String text, SpeechBubbleAppearance appearance, Font font) {
    return new SpeechBubble(entity, text, appearance, font);
}public static SpeechBubble create(final IEntity entity, final Font font, final String text) {
    SpeechBubbleAppearance app =
        new SpeechBubbleAppearance(
            DEFAULT_APPEARANCE.getForeColor(),
            DEFAULT_APPEARANCE.getBackgroundColor1(),
            DEFAULT_APPEARANCE.getBorderColor(),
            DEFAULT_APPEARANCE.getPadding());
    return new SpeechBubble(entity, text, app, font);
}public static SpeechBubble create(final IEntity entity, final String text) {
    return new SpeechBubble(entity, text, null, GuiProperties.getDefaultFont());
}@Override
  public void update() {
    if (this.currentText == null) {
      this.hide();
      return;
    }

    this.entityCenter = Game.world().camera().getViewportLocation(this.getEntity().getCenter());

    // old text was displayed long enough
    if (this.lastTextDisplay != 0
        && Game.time().since(this.lastTextDisplay) > this.currentTextDisplayTime) {
      this.currentText = null;
      this.lastTextDisplay = 0;
      return;
    }

    // display new text
    if (this.textIndex < this.currentText.length()
        && Game.time().since(this.lastCharPoll) > LETTER_WRITE_DELAY) {
      this.textIndex++;
      this.lastCharPoll = Game.time().now();
      if (this.typeSound != null) {
        Game.audio().playSound(this.typeSound, this.getEntity());
      }
    }

    // continue displaying currently displayed text
}private SpeechBubble(
      final IEntity entity,
      final String text,
      final Sound typeSound,
      SpeechBubbleAppearance appearance,
      Font font) {
    this(entity, text, appearance, font);
    this.typeSound = typeSound;
}private SpeechBubble(
      final IEntity entity,
      final String text,
      @Nullable SpeechBubbleAppearance appearance,
      @Nullable Font font) {
    if (appearance == null) {
      this.appearance = DEFAULT_APPEARANCE;
    } else {
      this.appearance = appearance;
    }

    final SpeechBubble active = activeSpeechBubbles.get(entity);
    if (active != null) {
      active.hide();
    }
    this.setFont(font);

    this.textBoxWidth = (float) (entity.getWidth() * 4);
    this.entity = entity;

    this.currentText = text;
    this.currentTextDisplayTime = DISPLAYTIME_MIN + text.length() * DISPLAYTIME_PER_LETTER;

    this.lastTextDisplay = Game.time().now();
    this.createBubbleImage();
    entity.getEnvironment().add(this, RenderType.UI);
    Game.loop().attach(this);
    activeSpeechBubbles.put(entity, this);
}
}
```
```java
class de.gurkenlabs.litiengine.gui.TextFieldComponent {
@Override
  public void render(final Graphics2D g) {
    super.render(g);
    g.setFont(this.getFont());
    final FontMetrics fm = g.getFontMetrics();

    if (this.isSelected() && Game.time().since(this.lastToggled) > this.flickerDelay) {
      this.cursorVisible = !this.cursorVisible;
      this.lastToggled = Game.time().now();
    }
    if (this.isSelected() && this.cursorVisible) {
      final Rectangle2D cursor =
          new Rectangle2D.Double(
              this.getX() + this.getTextX() + fm.stringWidth(this.getTextToRender(g)),
              this.getY() + this.getTextY(),
              this.getFont().getSize2D() * 3 / 5,
              this.getFont().getSize2D() * 1 / 5);
      g.setColor(this.getAppearance().getForeColor());
      g.fill(cursor);
    }
}
}
```
```java
class de.gurkenlabs.litiengine.entities.Prop {
public Prop(
      final Point2D location, @Nullable final String spritesheetName, final Material material) {
    super();
    this.rotation = Rotation.NONE;
    this.spritesheetName = spritesheetName;
    this.material = material;
    this.setLocation(location);
    this.updateAnimationController();
}public void setSpritesheetName(@Nullable final String spriteName) {
    this.spritesheetName = spriteName;
    this.updateAnimationController();
}
}
```
```java
class de.gurkenlabs.litiengine.tweening.Tween {
public Tween begin() {
    this.started = Game.time().now();
    this.stopped = false;
    return this;
}
}
```
```java
class de.gurkenlabs.litiengine.graphics.emitters.particles.Particle {
public void update(final Point2D emitterOrigin, final float updateRatio) {
    if (this.aliveTick == 0) {
      this.aliveTick = Game.time().now();
    }

    this.aliveTime = Game.time().since(this.aliveTick);
    if (this.timeToLiveReached()) {
      return;
    }

    if (this.colliding) {
      return;
    }

    if (this.getDeltaWidth() != 0) {
      this.width += this.getDeltaWidth() * updateRatio;
    }

    if (this.getDeltaHeight() != 0) {
      this.height += this.getDeltaHeight() * updateRatio;
    }

    if (this.getDeltaAngle() != 0) {
      this.angle += this.getDeltaAngle() * updateRatio;
    }

    // test for ray cast collision
    final float targetX = this.x + this.getVelocityX() * updateRatio;
    final float targetY = this.y + this.getVelocityY() * updateRatio;

    if (targetX == this.x && targetY == this.y) {
      return;
    }

    if (this.checkForCollision(emitterOrigin, targetX, targetY)) {
      return;
    }

    if (this.getVelocityX() != 0) {
      this.x = targetX;
    }

    if (this.getVelocityY() != 0) {
      this.y = targetY;
    }

    if (this.getAccelerationX() != 0) {
      this.velocityX += this.getAccelerationX() * updateRatio;
    }

    if (this.getAccelerationY() != 0) {
      this.velocityY += this.getAccelerationY() * updateRatio;
    }
}
}
```
```java
class de.gurkenlabs.litiengine.graphics.animation.Animation {
@Override
  public void start() {
    this.playing = true;
    if (this.getKeyframes().isEmpty()) {
      return;
    }

    this.restart();
}@Override
  public void update() {
    // do nothing if the animation is not playing or the current keyframe is not finished
    if (!this.isPlaying()
        || Game.time().since(this.lastFrameUpdate) < this.getCurrentKeyFrame().getDuration()) {
      return;
    }

    // if we are not looping and the last keyframe is finished, we terminate the animation
    if (!this.isLooping() && this.isLastKeyFrame()) {
      this.terminate();
      return;
    }

    // make sure, we stay inside the keyframe list
    final int newFrameIndex =
        (this.getKeyframes().indexOf(this.currentFrame) + 1) % this.getKeyframes().size();
    final KeyFrame previousFrame = this.currentFrame;
    this.currentFrame = this.getKeyframes().get(newFrameIndex);

    for (KeyFrameListener listener : this.listeners) {
      listener.currentFrameChanged(previousFrame, this.currentFrame);
    }

    this.lastFrameUpdate = Game.loop().getTicks();
}
}
```
```java
class de.gurkenlabs.litiengine.graphics.animation.AnimationController {
@Override
  public void update() {
    for (final Animation animation : this.getAll()) {
      animation.update();
    }

    if (this.getCurrent() != null && this.getCurrent().isPaused()) {
      return;
    }

    final boolean playbackFinished = this.getCurrent() != null && !this.getCurrent().isPlaying();
    if (playbackFinished) {
      for (final AnimationListener listener : this.listeners) {
        listener.finished(this.getCurrent());
      }
    }

    if (this.getCurrent() == null || playbackFinished) {
      if (this.getDefault() != null) {
        this.play(this.getDefault().getName());
      } else {
        this.currentAnimation = null;
      }
    }
}
}
```
```java
class de.gurkenlabs.litiengine.graphics.RenderComponent {
private void handleFade() {
    if (this.fadeOutStart != -1) {
      final long timePassed = Game.time().since(this.fadeOutStart);
      this.currentAlpha = MathUtilities.clamp(1 - timePassed / (float) this.fadeOutTime, 0, 1);
      if (this.currentAlpha == 0f) {
        this.fadeOutStart = -1;
        this.fadeOutTime = -1;
      }

      return;
    }

    if (this.fadeInStart != -1) {
      final long timePassed = Game.time().since(this.fadeInStart);
      this.currentAlpha = MathUtilities.clamp(timePassed / (float) this.fadeInTime, 0, 1);
      if (this.currentAlpha == 1f) {
        this.fadeInStart = -1;
        this.fadeInTime = -1;
        this.currentAlpha = Float.NaN;
      }
    }
}public void fadeOut(final int ms) {
    this.fadeInStart = -1;
    this.fadeInTime = -1;
    this.fadeOutStart = Game.time().now();
    this.fadeOutTime = ms;
}public void fadeIn(final int ms) {
    this.fadeOutStart = -1;
    this.fadeOutTime = -1;
    this.fadeInStart = Game.time().now();
    this.fadeInTime = ms;
}
}
```
```java
class de.gurkenlabs.litiengine.entities.Trigger {
private boolean activate(final IEntity activator, final int tar) {
    if (!this.isLoaded()
        || this.isOneTimeTrigger && this.isActivated
        || this.getActivationType() == TriggerActivation.COLLISION
            && activator != null
            && this.collisionActivated.contains(activator)) {
      return false;
    }

    if (this.getCooldown() > 0 && Game.time().since(this.lastActivation) < this.getCooldown()) {
      return false;
    }

    List<Integer> triggerTargets = this.getTargets(tar);

    final TriggerEvent te = new TriggerEvent(this, activator, triggerTargets);

    if (!this.checkActivationPredicates(te)) {
      return false;
    }

    this.isActivated = true;
    if (activator != null) {
      this.collisionActivated.add(activator);
    }

    // if we actually have a trigger target, we send the message to the target
    for (final int target : triggerTargets) {
      final IEntity entity = this.getEnvironment().get(target);
      if (entity == null) {
        log.log(
            Level.WARNING,
            "trigger [{0}] was activated, but the trigger target [{1}] could not be found on the environment",
            new Object[] {this, target});
        continue;
      }

      entity.sendMessage(this, this.message);
    }

    // also send the trigger event to all registered consumers
    for (final TriggerActivatedListener listener : this.activatedListeners) {
      listener.activated(te);
    }

    if (this.isOneTimeTrigger) {
      this.getEnvironment().remove(this);
    }

    this.lastActivation = Game.time().now();
    return true;
}
}
```
```java
class de.gurkenlabs.litiengine.graphics.Camera {
private boolean isShakeEffectActive() {
    return this.getShakeTick() != 0
        && Game.time().since(this.getShakeTick()) < this.getShakeDuration();
}@Override
  public void update() {
    if (Game.world().camera() != null && !Game.world().camera().equals(this)) {
      return;
    }

    if (this.targetZoom > 0) {
      if (Game.time().since(this.zoomTick) >= this.zoomDelay) {
        this.zoom = this.targetZoom;
        this.targetZoom = 0;
        this.zoomDelay = 0;
        this.zoomTick = 0;
        this.zoomStep = 0;
      } else {
        this.zoom += this.zoomStep;
      }

      final ZoomChangedEvent event = new ZoomChangedEvent(this, this.getZoom());
      for (final ZoomChangedListener listener : this.zoomListeners) {
        listener.zoomChanged(event);
      }
    }

    if (this.panTime > 0) {
      if (--this.panTime <= 0) {
        this.setFocus(this.targetFocus);
        this.targetFocus = null;
      } else {
        double diff = this.panTime / (this.panTime + 1.0);
        this.focus =
            new Point2D.Double(
                this.focus.getX() * diff + this.targetFocus.getX() * (1.0 - diff),
                this.focus.getY() * diff + this.targetFocus.getY() * (1.0 - diff));
      }
    }

    if (!this.isShakeEffectActive()) {
      this.shakeOffsetX = 0;
      this.shakeOffsetY = 0;
      return;
    }

    if (Game.time().since(this.lastShake) > this.shakeDelay) {
      this.shakeOffsetX = this.getShakeIntensity() * ThreadLocalRandom.current().nextGaussian();
      this.shakeOffsetY = this.getShakeIntensity() * ThreadLocalRandom.current().nextGaussian();
      this.lastShake = Game.time().now();
    }
}@Override
  public void setZoom(final float targetZoom, final int delay) {
    if (delay == 0) {

      this.zoom = targetZoom;
      this.targetZoom = 0;
      this.zoomDelay = 0;
      this.zoomTick = 0;
      this.zoomStep = 0;

      final ZoomChangedEvent event = new ZoomChangedEvent(this, targetZoom);
      for (final ZoomChangedListener listener : this.zoomListeners) {
        listener.zoomChanged(event);
      }
    } else {
      this.zoomTick = Game.time().now();
      this.targetZoom = targetZoom;
      this.zoomDelay = delay;

      final double tickduration = 1000 / (double) Game.loop().getTickRate();
      final double tickAmount = delay / tickduration;
      final float totalDelta = this.targetZoom - this.zoom;
      this.zoomStep = tickAmount > 0 ? (float) (totalDelta / tickAmount) : totalDelta;
    }
}@Override
  public void shake(final double intensity, final int delay, final int shakeDuration) {
    this.shakeTick = Game.time().now();
    this.shakeDelay = delay;
    this.shakeIntensity = intensity;
    this.shakeDuration = shakeDuration;
}
}
```
```java
class de.gurkenlabs.litiengine.entities.Creature {
public void setSpritesheetName(String spritesheetName) {
    if (this.spritesheetName != null && this.spritesheetName.equals(spritesheetName)) {
      return;
    }

    this.spritesheetName = spritesheetName;
    this.updateAnimationController();
}public boolean isIdle() {
    return Game.time().since(this.lastMoved) > IDLE_DELAY;
}@Override
  public void setLocation(final Point2D position) {
    if (this.isDead() || position == null) {
      return;
    }

    final Point2D oldLocation = this.getLocation();
    super.setLocation(position);

    if (Game.hasStarted() && this.isLoaded()) {
      this.lastMoved = Game.time().now();
      this.fireMovedEvent(
          new EntityMovedEvent(
              this, this.getX() - oldLocation.getX(), this.getY() - oldLocation.getY()));
    }
}
}
```
```java
class de.gurkenlabs.litiengine.gui.screens.ScreenManager {
public void display(final String screenName) {
    if (this.current() != null && this.current().getName().equalsIgnoreCase(screenName)) {
      log.log(
          Level.INFO,
          "Skipping displaying of screen {0} because it is already the current screen.",
          screenName);
      return;
    }

    if (this.screens.stream()
        .noneMatch(element -> element.getName().equalsIgnoreCase(screenName))) {
      log.log(
          Level.WARNING,
          "Could not display the screen {0} because there is no screen with the specified name.",
          screenName);
      return;
    }

    Screen screen = this.get(screenName);
    if (screen == null) {
      return;
    }

    this.display(screen);
}public void add(final Screen screen) {
    screen.setWidth(Game.window().getWidth());
    screen.setHeight(Game.window().getHeight());
    this.screens.add(screen);

    if (this.current() == null) {
      this.display(screen);
    }
}public void remove(Screen screen) {
    this.screens.remove(screen);
    if (this.current() == screen) {
      if (!this.screens.isEmpty()) {
        this.display(this.screens.get(0));
      } else {
        this.display((Screen) null);
      }
    }
}public void display(@Nullable final Screen screen) {
    if (Game.hasStarted() && Game.time().since(this.lastScreenChange) < this.getChangeCooldown()) {
      log.log(
          Level.INFO,
          "Skipping displaying of screen {0} because screen changing is currently on cooldown.",
          screen != null ? screen.getName() : "");
      return;
    }

    final Screen previous = this.current();
    if (previous != null) {
      previous.suspend();
    }

    if (screen != null && !this.screens.contains(screen)) {
      this.screens.add(screen);
    }

    this.currentScreen = screen;
    if (!Game.isInNoGUIMode() && this.current() != null) {
      this.current().prepare();
    }

    this.lastScreenChange = Game.loop().getTicks();

    final ScreenChangedEvent event = new ScreenChangedEvent(this.current(), previous);
    for (final ScreenChangedListener listener : this.screenChangedListeners) {
      listener.changed(event);
    }
}
}
```
```java
class de.gurkenlabs.litiengine.abilities.Ability {
public boolean isOnCooldown() {
    return (this.getCurrentExecution() != null
        && this.getCurrentExecution().getExecutionTicks() > 0
        && Game.time().since(this.getCurrentExecution().getExecutionTicks())
            < this.getAttributes().cooldown().get());
}public boolean isActive() {
    return this.getCurrentExecution() != null
        && Game.time().since(this.getCurrentExecution().getExecutionTicks())
            < this.getAttributes().duration().get();
}@Nullable
  public AbilityExecution cast() {
    if (!this.canCast()) {
      return null;
    }
    this.currentExecution = new AbilityExecution(this);

    for (final AbilityCastListener listener : this.abilityCastListeners) {
      listener.abilityCast(this.currentExecution);
    }

    return this.getCurrentExecution();
}public float getRemainingCooldownInSeconds() {
    if (this.getCurrentExecution() == null
        || this.getExecutor() == null
        || this.getExecutor().isDead()) {
      return 0;
    }

    // calculate cooldown in seconds
    return (float)
        (!this.canCast()
            ? (this.getAttributes().cooldown().get()
                    - Game.time().since(this.getCurrentExecution().getExecutionTicks()))
                * 0.001
            : 0);
}
}
```
```java
class de.gurkenlabs.litiengine.entities.EntityHitEvent {
EntityHitEvent(
      final ICombatEntity hitEntity,
      @Nullable final Ability ability,
      final int damage,
      final boolean kill) {
    super(hitEntity);
    this.executor = ability != null ? ability.getExecutor() : null;
    this.hitEntity = hitEntity;
    this.ability = ability;
    this.damage = damage;
    this.kill = kill;
    this.time = Game.time().now();
}
}
```
```java
class de.gurkenlabs.litiengine.graphics.emitters.Emitter {
public void delete() {
    this.deactivate();
    if (Game.world().environment() != null) {
      Game.world().environment().remove(this);
    }
}public void activate() {
    if (this.activated) {
      return;
    }

    this.activated = true;
    this.activationTick = Game.time().now();
    Game.loop().attach(this);
}@Override
  public void update() {
    if (this.isPaused()) {
      return;
    }

    // clear particles if the effect time to life is reached
    if (this.isFinished()) {
      for (EmitterFinishedListener listener : this.finishedListeners) {
        listener.finished(this);
      }

      this.delete();
      return;
    }

    final float updateRatio = (float) this.data().getUpdateRate() / Game.loop().getTickRate();
    for (final Particle p : this.getParticles().stream().collect(Collectors.toList())) {
      if (this.particleCanBeRemoved(p)) {
        // remove dead particles
        this.particles.remove(p);
        continue;
      }

      p.update(this.getOrigin(), updateRatio);
    }

    this.aliveTime = Game.time().since(this.activationTick);
    if ((this.data().getSpawnRate() == 0
        || Game.time().since(this.lastSpawn) >= this.data().getSpawnRate())) {
      this.lastSpawn = Game.time().now();
      this.spawnParticle();
    }
}
}
```
```java
class de.gurkenlabs.litiengine.GameLoop {
@Override
  public int perform(int delay, Runnable action) {
    final long d = Game.time().toTicks(delay);

    TimedAction a = new TimedAction(this.getTicks() + d, action);
    this.actions.add(a);

    return a.getId();
}
}
```
```java
class de.gurkenlabs.litiengine.environment.EntitySpawner {
protected boolean shouldSpawn() {
    return this.lastSpawnWave == 0
        || Game.time().since(this.lastSpawnWave) >= this.getSpawnInterval();
}@Override
  public void update() {
    if (!this.shouldSpawn()) {
      return;
    }

    this.spawnNewEntities();
    this.lastSpawnWave = Game.time().now();
}
}
```
```java
class de.gurkenlabs.litiengine.graphics.FreeFlightCamera {
@Override
  public void update() {
    this.handleFreeFlightCamera();
}public FreeFlightCamera(double x, double y) {
    this(new Point2D.Double(x, y));
}
}
```
```java
class de.gurkenlabs.litiengine.environment.Environment {
public void unload() {
    if (!this.loaded) {
      return;
    }

    // unregister all updatable entities from the current environment
    for (final IEntity entity : this.allEntities.values()) {
      this.unload(entity);
    }

    this.loaded = false;
    this.fireEvent(l -> l.unloaded(this));
}private static void loadUpdatableOrEmitterEntity(IEntity entity) {
    if (entity instanceof Emitter) {
      final Emitter emitter = (Emitter) entity;
      if (emitter.isActivateOnInit()) {
        emitter.activate();
      }
    } else if (entity instanceof IUpdateable) {
      Game.loop().attach((IUpdateable) entity);
    }
}public void clear() {
    Game.physics().clear();

    this.combatEntities.clear();
    this.mobileEntities.clear();
    this.gravityForces.clear();
    this.layerEntities.clear();
    this.entitiesByTag.clear();
    this.allEntities.clear();

    for (RenderType renderType : RenderType.values()) {
      this.miscEntities.get(renderType).clear();
      this.renderListeners.get(renderType).clear();
      this.renderables.get(renderType).clear();
    }

    dispose(this.allEntities.values());
    dispose(this.triggers);
    this.emitters.clear();
    this.colliders.clear();
    this.props.clear();
    this.creatures.clear();
    this.staticShadows.clear();
    this.combatEntities.clear();
    this.mobileEntities.clear();
    this.lightSources.clear();
    this.spawnPoints.clear();
    this.soundSources.clear();
    this.mapAreas.clear();
    this.triggers.clear();

    this.ambientLight = null;
    this.staticShadowLayer = null;

    for (Map<Integer, IEntity> type : this.miscEntities.values()) {
      type.clear();
    }

    this.initialized = false;

    this.fireEvent(l -> l.cleared(this));
}private void load(final IEntity entity) {
    // an entity can only exist on one environment at a time, so remove it from the current one
    if (entity.getEnvironment() != null) {
      entity.getEnvironment().remove(entity);
    }

    // 1. add to physics engine
    loadPhysicsEntity(entity);

    // 2. register for update or activate
    loadUpdatableOrEmitterEntity(entity);

    // 3. if a gravity is defined, add a gravity force to the entity
    if (entity instanceof IMobileEntity && this.getGravity() != 0) {
      this.addGravityForce((IMobileEntity) entity);
    }

    // 4. attach all controllers
    entity.attachControllers();

    if (this.loaded && (entity instanceof LightSource || entity instanceof StaticShadow)) {
      this.updateLighting(entity);
    }

    entity.loaded(this);
}private void unload(final IEntity entity) {
    // 1. remove from physics engine
    if (entity instanceof ICollisionEntity) {
      Game.physics().remove((ICollisionEntity) entity);
    }

    // 2. unregister from update
    if (entity instanceof IUpdateable) {
      Game.loop().detach((IUpdateable) entity);
    }

    if (entity instanceof IMobileEntity) {
      this.removeGravity((IMobileEntity) entity);
    }

    // 3. detach all controllers
    entity.detachControllers();

    if (entity instanceof Emitter) {
      Emitter em = (Emitter) entity;
      em.deactivate();
    }

    if (this.loaded && (entity instanceof LightSource || entity instanceof StaticShadow)) {
      this.updateLighting(entity);
    }

    entity.removed(this);
}public void remove(final IEntity entity) {
    if (entity == null) {
      return;
    }

    this.allEntities.remove(entity.getMapId());
    Iterator<List<IEntity>> iter = this.layerEntities.values().iterator();
    while (iter.hasNext()) {
      List<IEntity> layer = iter.next();
      if (layer.remove(entity) && layer.isEmpty()) {
        iter.remove();
      }
    }
    if (this.miscEntities.get(entity.getRenderType()) != null) {
      this.miscEntities.get(entity.getRenderType()).values().remove(entity);
    }

    for (String tag : entity.getTags()) {
      if (this.getEntitiesByTag().containsKey(tag)) {
        this.getEntitiesByTag().get(tag).remove(entity);

        if (this.getEntitiesByTag().get(tag).isEmpty()) {
          this.getEntitiesByTag().remove(tag);
        }
      }
    }

    if (entity instanceof Emitter) {
      Emitter emitter = (Emitter) entity;
      this.removeEmitter(emitter);
    }

    if (entity instanceof MapArea) {
      this.mapAreas.remove(entity);
    }

    if (entity instanceof Prop) {
      this.props.remove(entity);
    }

    if (entity instanceof Creature) {
      this.creatures.remove(entity);
    }

    if (entity instanceof CollisionBox) {
      this.colliders.remove(entity);
      this.staticShadows.removeIf(x -> x.getOrigin() != null && x.getOrigin().equals(entity));
    }

    if (entity instanceof LightSource) {
      this.lightSources.remove(entity);
      this.updateLighting(entity);
    }

    if (entity instanceof Trigger) {
      this.triggers.remove(entity);
    }

    if (entity instanceof Spawnpoint) {
      this.spawnPoints.remove(entity);
    }
    if (entity instanceof SoundSource) {
      this.soundSources.remove(entity);
    }

    if (entity instanceof StaticShadow) {
      this.staticShadows.remove(entity);
      this.updateLighting(entity);
    }

    if (entity instanceof IMobileEntity) {
      this.mobileEntities.values().remove(entity);
    }

    if (entity instanceof ICombatEntity) {
      this.combatEntities.values().remove(entity);
    }

    this.unload(entity);

    this.fireEntityEvent(l -> l.entityRemoved(entity));
}
}
```
```java
class de.gurkenlabs.litiengine.physics.MovementController {
@Override
  public void update() {
    this.handleForces();
    this.handleMovement();
}
}
```
```java
class de.gurkenlabs.litiengine.Game {
static synchronized void terminate() {
    if (!initialized) {
      return;
    }

    hasStarted = false;
    initialized = false;

    config().save();
    gameLoop.terminate();
    tweenEngine.terminate();
    soundEngine.terminate();

    world().clear();

    for (final GameListener listener : gameListeners) {
      try {
        listener.terminated();
      } catch (Exception e) {
        log().log(Level.WARNING, "game listener threw an exception during shutdown", e);
      }
    }

    gameLoop = null;
    screenManager = null;
    gameWindow = null;
}public static synchronized void start() {
    if (!initialized) {
      throw new IllegalStateException(
          "The game cannot be started without being first initialized. Call Game.init(...) before Game.start().");
    }

    gameLoop.start();
    tweenEngine.start();
    soundEngine.start();

    for (final GameListener listener : gameListeners) {
      listener.started();
    }

    hasStarted = true;
}public static synchronized void init(String... args) {
    if (initialized) {
      log().log(Level.INFO, "The game has already been initialized.");
      return;
    }

    log.init();
    handleCommandLineArguments(args);

    config().load();
    Locale.setDefault(new Locale(config().client().getCountry(), config().client().getLanguage()));

    gameLoop = new GameLoop("Main Update Loop", config().client().getMaxFps());
    loop().attach(physics());
    loop().attach(world());

    // setup default exception handling for render and update loop
    setUncaughtExceptionHandler(
        new DefaultUncaughtExceptionHandler(config().client().exitOnError()));

    screenManager = new ScreenManager();
    gameWindow = new GameWindow();

    // initialize  the game window
    window().init();
    world.setCamera(new Camera());

    for (GameListener listener : gameListeners) {
      listener.initialized(args);
    }

    if (!isInNoGUIMode()) {
      window().getRenderComponent().onRendered(g -> metrics().render(g));

      graphics()
          .addEntityRenderedListener(
              e -> DebugRenderer.renderEntityDebugInfo(e.getGraphics(), e.getEntity()));

      window().getRenderComponent().onFpsChanged(fps -> metrics().setFramesPerSecond(fps));
      window()
          .setIcons(
              Arrays.asList(
                  Resources.images().get("liti-logo-x16.png"),
                  Resources.images().get("liti-logo-x20.png"),
                  Resources.images().get("liti-logo-x32.png"),
                  Resources.images().get("liti-logo-x48.png")));

      Input.keyboard()
          .onKeyTyped(
              KeyEvent.VK_PRINTSCREEN,
              key -> {
                // don't take a screenshot if a modifier is active
                if (key.getModifiers() != 0) {
                  return;
                }

                window().getRenderComponent().takeScreenshot();
              });
    }

    Runtime.getRuntime().addShutdownHook(new Thread(Game::terminate, "Shutdown"));

    initialized = true;
}
}
```


Response Format:
Provide the answer in **XML format** as follows:

#### If the method **cannot** return `null` at the specific call site:
```xml
<response>
  <reason><![CDATA[EXPLAIN WHY THE INVOCATION Game.loop() RESULT CANNOT BE NULL.]]></reason>
  <value>NO</value>
</response>

#### If the method can return null at the specific call site:
<response>
  <reason><![CDATA[EXPLAIN WHY THE INVOCATION Game.loop() RESULT CAN BE NULL.]]></reason>
  <value>YES</value>
</response>

#### If you are unsure or If there are any methods that directly or indirectly affect the return value and are not fully disclosed, request their declarations first, in the following format:
<response>
  <reason><![CDATA[EXPLAIN WHY THIS METHOD DECLARATION IS NECESSARY AND WHY YOU CANNOT MAKE A CONFIDENT DECISION WITHOUT IT]]></reason>
  <success>false</success>
  <methods>
    <method>methodName</method>
  </methods>
</response>

Additional Notes:
Be precise in your reasoning.
If a method’s return value depends on another method not provided, request its declaration before making a conclusion.
If the method can return null in this case but not in others, explain why it happens specifically for this call.

---ChatGPT.sendRequestToOpenAI---
Retrieving response from cache
---Response.<init>---
Creating Response:
```xml
<response>
  <reason><![CDATA[The method `Game.loop()` returns the static field `gameLoop`, which is initialized in the `Game.init(String... args)` method. In this method, a new `GameLoop` object is instantiated and assigned to `gameLoop`. Since `init()` must be called before `start()`, which is implied by the requirement of initializing the game, the `gameLoop` is guaranteed to be non-null during the lifetime of the game execution where `Game.loop()` is called. The absence of any code that could set `gameLoop` to null after its initialization ensures that `Game.loop()` cannot return null.]]></reason>
  <value>NO</value>
</response>
```
---Response.<init>---
Response created:
Disagreement: The method `Game.loop()` returns the static field `gameLoop`, which is initialized in the `Game.init(String... args)` method. In this method, a new `GameLoop` object is instantiated and assigned to `gameLoop`. Since `init()` must be called before `start()`, which is implied by the requirement of initializing the game, the `gameLoop` is guaranteed to be non-null during the lifetime of the game execution where `Game.loop()` is called. The absence of any code that could set `gameLoop` to null after its initialization ensures that `Game.loop()` cannot return null.
---AdvancedNullAwayCodeFix.resolveMethodDereferenceError---
Method is not returning nullable on call site. Injecting suppression annotation.
---AdvancedNullAwayCodeFix.constructCastToNonnullChange---
Constructing cast to nonnull change for reason: The method `Game.loop()` returns the static field `gameLoop`, which is initialized in the `Game.init(String... args)` method. In this method, a new `GameLoop` object is instantiated and assigned to `gameLoop`. Since `init()` must be called before `start()`, which is implied by the requirement of initializing the game, the `gameLoop` is guaranteed to be non-null during the lifetime of the game execution where `Game.loop()` is called. The absence of any code that could set `gameLoop` to null after its initialization ensures that `Game.loop()` cannot return null.
---ChatGPT.ask---
Asking ChatGPT:
For the reason you mentioned earlier:

"The method `Game.loop()` returns the static field `gameLoop`, which is initialized in the `Game.init(String... args)` method. In this method, a new `GameLoop` object is instantiated and assigned to `gameLoop`. Since `init()` must be called before `start()`, which is implied by the requirement of initializing the game, the `gameLoop` is guaranteed to be non-null during the lifetime of the game execution where `Game.loop()` is called. The absence of any code that could set `gameLoop` to null after its initialization ensures that `Game.loop()` cannot return null."

in the method below, the expression Game.loop() is not nullable at the point it is used.

```java
private void unload(final IEntity entity) {
    // 1. remove from physics engine
    if (entity instanceof ICollisionEntity) {
      Game.physics().remove((ICollisionEntity) entity);
    }

    // 2. unregister from update
    if (entity instanceof IUpdateable) {
      Game.loop().detach((IUpdateable) entity);
    }

    if (entity instanceof IMobileEntity) {
      this.removeGravity((IMobileEntity) entity);
    }

    // 3. detach all controllers
    entity.detachControllers();

    if (entity instanceof Emitter) {
      Emitter em = (Emitter) entity;
      em.deactivate();
    }

    if (this.loaded && (entity instanceof LightSource || entity instanceof StaticShadow)) {
      this.updateLighting(entity);
    }

    entity.removed(this);
}
```
Please Summarize the reason in max 5 words and rewrite the method so that at the line "      Game.loop().detach((IUpdateable) entity);", at the occurrence of: "Game.loop()" is replaced with `NullabilityUtil.castToNonnull(Game.loop(), summary of reason)`
Replace "REASON" with the exact reason summary I provide to you (maximum 5 words), not with a generic explanation like "checked to be nonnull".
see the example below, for expression `foo.getBar()`, to wrap it with `NullabilityUtil.castToNonnull(foo.getBar(), "reason")`.

```java
public t(){
    String l = foo.getBar();
}
```

will be:
```java
public t(){
    String l = NullabilityUtil.castToNonnull(foo.getBar(), "checked to be nonnull");
}
```

### Instructions:

Do not import any additional classes.

Do not add Java comments.

Only modify relevant lines as required.

Return only the modified method wrapped in the XML format shown below.

Place the Java code inside the <code> tag using a CDATA block with ```java formatting.

Just give me the fixed code snippet in XML format in <response> tag like the example below. I will apply the fix to my codebase. Do not import any additional libraries or classes or add java comments. If you can provide the fixed code snippet, please provide it in the following format and place the code snippet in the <code> tag within ```java block.
<response>
  <success>true</success>
  <code><![CDATA[
  ```java
  Your fixed code snippet here
  ```
    ]]>
  </code>
</response>

---ChatGPT.sendRequestToOpenAI---
Retrieving response from cache
---Response.<init>---
Creating Response:
```xml
<response>
  <success>true</success>
  <code><![CDATA[
  ```java
private void unload(final IEntity entity) {
    // 1. remove from physics engine
    if (entity instanceof ICollisionEntity) {
      Game.physics().remove((ICollisionEntity) entity);
    }

    // 2. unregister from update
    if (entity instanceof IUpdateable) {
      NullabilityUtil.castToNonnull(Game.loop(), "init guarantees non-null").detach((IUpdateable) entity);
    }

    if (entity instanceof IMobileEntity) {
      this.removeGravity((IMobileEntity) entity);
    }

    // 3. detach all controllers
    entity.detachControllers();

    if (entity instanceof Emitter) {
      Emitter em = (Emitter) entity;
      em.deactivate();
    }

    if (this.loaded && (entity instanceof LightSource || entity instanceof StaticShadow)) {
      this.updateLighting(entity);
    }

    entity.removed(this);
}
  ```
  ]]>
  </code>
</response>
```
---Response.<init>---
Response created:
private void unload(final IEntity entity) {
    // 1. remove from physics engine
    if (entity instanceof ICollisionEntity) {
      Game.physics().remove((ICollisionEntity) entity);
    }

    // 2. unregister from update
    if (entity instanceof IUpdateable) {
      NullabilityUtil.castToNonnull(Game.loop(), "init guarantees non-null").detach((IUpdateable) entity);
    }

    if (entity instanceof IMobileEntity) {
      this.removeGravity((IMobileEntity) entity);
    }

    // 3. detach all controllers
    entity.detachControllers();

    if (entity instanceof Emitter) {
      Emitter em = (Emitter) entity;
      em.deactivate();
    }

    if (this.loaded && (entity instanceof LightSource || entity instanceof StaticShadow)) {
      this.updateLighting(entity);
    }

    entity.removed(this);
}
---ChatGPT.fixDereferenceByAddingCastToNonnull---
Fixing the error by adding castToNonnull
---AdvancedNullAwayCodeFix.fixTriggeredErrorsForLocation---
Resolving unresolvable error for triggered error: Type='DEREFERENCE_NULLABLE', message='dereferenced expression Game.loop() is @Nullable'
/home/nima/Developer/nullness-benchmarks/litiengine/src/de/gurkenlabs/litiengine/GameTime.java:73
    return this.toMilliseconds(ticks, Game.loop().getTickRate());
---AdvancedNullAwayCodeFix.fix---
Fixing error: Type='DEREFERENCE_NULLABLE', message='dereferenced expression Game.loop() is @Nullable'
/home/nima/Developer/nullness-benchmarks/litiengine/src/de/gurkenlabs/litiengine/GameTime.java:73
    return this.toMilliseconds(ticks, Game.loop().getTickRate());
---AdvancedNullAwayCodeFix.resolveDereferenceError---
Resolving dereference error: Type='DEREFERENCE_NULLABLE', message='dereferenced expression Game.loop() is @Nullable'
/home/nima/Developer/nullness-benchmarks/litiengine/src/de/gurkenlabs/litiengine/GameTime.java:73
    return this.toMilliseconds(ticks, Game.loop().getTickRate());
---AdvancedNullAwayCodeFix.resolveDereferenceError---
Checking nullability possibility at error point
---ChatGPT.checkNullabilityPossibilityAtErrorPoint---
Asking if the expression can be null at error point point
---ChatGPT.ask---
Asking ChatGPT:
In the method below, is there a possibility that the expression "Game.loop()" at line "return this.toMilliseconds(ticks, Game.loop().getTickRate());" is null?
public long toMilliseconds(final long ticks) {
    return this.toMilliseconds(ticks, Game.loop().getTickRate());
}
Give a single-word answer in XML format. If it is possible for the expression to be null, respond with:
```xml
<response>
    <reason><![CDATA[YOUR REASON]]></reason>
    <value>YES</value>
</response>
```
If it is not possible for the expression to be null, respond with:
```xml
<response>
    <reason><![CDATA[YOUR REASON]]></reason>
    <value>NO</value>
</response>
```
If you are unsure or need more information, respond with where you can ask for more details or what specific information you need.

If additional information is required, list each request inside a `<request>` tag. If no additional information is needed, omit the `<requests>` section.

Respond with:
```xml
<response>
    <reason><![CDATA[YOUR REASON]]></reason>
    <value>UNKNOWN</value>
    <!-- Include <requests> only if additional information is needed -->
    <requests>
        <request><![CDATA[YOUR REQUEST 1]]></request>
        <request><![CDATA[YOUR REQUEST 2]]></request>
    </requests>
</response>
```
---ChatGPT.sendRequestToOpenAI---
Retrieving response from cache
---Response.<init>---
Creating Response:
```xml
<response>
    <reason><![CDATA[Without information about the implementation details of the Game class and the loop() method, it is not possible to ascertain if Game.loop() can return null.]]></reason>
    <value>UNKNOWN</value>
    <requests>
        <request><![CDATA[Explanation of the Game class implementation, specifically how the loop() method is defined or initialized.]]></request>
        <request><![CDATA[Details on whether the Game.loop() method can return a null or uninitialized object.]]></request>
    </requests>
</response>
```
---Response.<init>---
Response created:
Unknown: Without information about the implementation details of the Game class and the loop() method, it is not possible to ascertain if Game.loop() can return null.
---AdvancedNullAwayCodeFix.resolveMethodDereferenceError---
Resolving method dereference error.
---AdvancedNullAwayCodeFix.resolveMethodDereferenceError---
Method is in annotated package. Checking if the method is returning nullable.
---AdvancedNullAwayCodeFix.investigateMethodReturnNullability---
Checking if the method is returning nullable.
---ChatGPT.checkIfMethodIsReturningNullable---
Asking if the method is returning nullable: loop()
---ChatGPT.ask---
Asking ChatGPT:
In the method below, is there a possibility that the method returns null based only on its body? Consider the following points:

- The method may have multiple return paths; consider all return statements.
- If the method calls another method, do not assume its return value unless its full declaration is provided. Request its declaration if needed.
- The method may throw an exception instead of returning null. An exception path should not be considered a null return.
- Ensure you request the declarations of any methods whose return values directly or indirectly impact this method’s return value before making a conclusion.
- Carefully analyze all conditions and prior operations that may guarantee a non-null return value.

@Nullable public static IGameLoop loop() {
    return gameLoop;
}

Here are the method definitions in addition to the method inquired:

Depth: 0
```java
class de.gurkenlabs.litiengine.Game {
@Nullable public static IGameLoop loop() {
    return gameLoop;
}
}
```


Response Format:
Provide the answer in **XML format** as follows:

#### If the method **cannot** return `null`:
```xml
<response>
  <reason><![CDATA[EXPLAIN WHY THE METHOD CANNOT RETURN NULL]]></reason>
  <value>NO</value>
</response>
```

#### If the method can return null:
```xml
<response>
  <reason><![CDATA[EXPLAIN WHY THE METHOD CAN RETURN NULL]]></reason>
  <value>YES</value>
</response>
```

#### If you are unsure or need more information, respond with where you can ask for more details or what specific information you need.

#### If you are unsure or If there are any methods that directly or indirectly affect the return value and are not fully disclosed, request their declarations first, in the following format:
<response>
  <reason><![CDATA[YOUR REASON]]></reason>
  <value>UNKNOWN</value>
  <methods>
    <method>methodName</method>
  </methods>
</response>

If additional information is required other than method declaration, list each request inside a `<request>` tag. If no additional information is needed, omit the `<requests>` section.

Respond with:
```xml
<response>
    <reason><![CDATA[YOUR REASON]]></reason>
    <value>UNKNOWN</value>
    <!-- Include <requests> only if additional information is needed -->
    <requests>
        <request><![CDATA[YOUR REQUEST 1]]></request>
        <request><![CDATA[YOUR REQUEST 2]]></request>
    </requests>
</response>
```

Additional Notes:
Be precise in your reasoning.
If a method’s return value depends on another method not provided, request its declaration before making a conclusion.
If the method can return null in some cases but not others, explain under what conditions it can happen.

---ChatGPT.sendRequestToOpenAI---
Retrieving response from cache
---Response.<init>---
Creating Response:
```xml
<response>
  <reason><![CDATA[The method `loop` returns the variable `gameLoop`. Without the initialization or assignment details of `gameLoop`, it's unclear whether it can be null. The possibility of `gameLoop` being uninitialized or set to null elsewhere in the program means `loop` could potentially return null. Further information on `gameLoop` is required.]]></reason>
  <value>UNKNOWN</value>
  <requests>
    <request><![CDATA[Please provide the declaration and initialization of the variable `gameLoop` in the class `de.gurkenlabs.litiengine.Game`.]]></request>
  </requests>
</response>
```
---Response.<init>---
Response created:
Unknown: The method `loop` returns the variable `gameLoop`. Without the initialization or assignment details of `gameLoop`, it's unclear whether it can be null. The possibility of `gameLoop` being uninitialized or set to null elsewhere in the program means `loop` could potentially return null. Further information on `gameLoop` is required.
---AdvancedNullAwayCodeFix.investigateMethodReturnNullability---
Could not determine the nullability and model did not ask for any method.
---ChatGPT.checkIfMethodIsReturningNullableOnCallSite---
Asking if the method is returning nullable on the call site: Game.loop()
---ChatGPT.ask---
Asking ChatGPT:
In the method below, is there a possibility that the method returns null at the given call site?

```java
@Nullable public static IGameLoop loop() {
    return gameLoop;
}
```

## Guidelines:
- The method may have multiple return paths; consider all return statements.
- If the method calls another method, do not assume its return value unless its full declaration is provided. Request its declaration if needed.
- The method may throw an exception instead of returning null. An exception path should not be considered a null return.
- Ensure you request the declarations of any methods whose return values directly or indirectly impact this method’s return value before making a conclusion.
- If the method returns a value that is determined by a parameter, evaluate based on the actual argument at the given call site.
- Analyze based only on the specific invocation provided. Do not generalize to all possible inputs.- If the return value is guaranteed to be non-null at the call site, the answer should be a definitive NO.
- Do not generalize based on all possible inputs—your answer must be based only on the given invocation.
- Focus only on the given call site, not all possible invocations.

### call site:
Game.loop()

Here are the method definitions and the call chain for this method, showing the sequence of calls from the method to its callers at each depth level:

Depth: 0
```java
class de.gurkenlabs.litiengine.Game {
@Nullable public static IGameLoop loop() {
    return gameLoop;
}
}
```
Depth: 1
```java
class de.gurkenlabs.litiengine.environment.GameWorld {
public void loadEnvironment(@Nullable final Environment env) {
    Lock lock = Game.loop().getLock();
    lock.lock();
    try {
      unloadEnvironment();
      this.environment = env;
      if (env != null) {
        this.addEnvironment(env);

        if (env.getGravity() == 0 && this.gravity() != 0) {
          env.setGravity(this.gravity());
        }

        env.load();
        for (final EnvironmentLoadedListener listener : this.loadedListeners) {
          listener.loaded(env);
        }

        // call map specific listeners
        String mapName = getMapName(env);
        if (mapName != null && this.environmentLoadedListeners.containsKey(mapName)) {

          // for the default camera we center the camera on the environment
          if (this.camera().getClass().equals(Camera.class)) {
            camera().setFocus(env.getCenter());
          }

          for (EnvironmentLoadedListener listener : this.environmentLoadedListeners.get(mapName)) {
            listener.loaded(env);
          }
        }
      }
    } finally {
      lock.unlock();
    }
}public void setCamera(@Nullable final ICamera cam) {
    if (this.camera() != null) {
      Game.loop().detach(camera);
    }

    camera = cam;

    if (cam != null && !Game.isInNoGUIMode()) {
      Game.loop().attach(cam);
      cam.updateFocus();
    }
}
}
```
```java
class de.gurkenlabs.litiengine.entities.behavior.EntityNavigator {
public EntityNavigator(final IMobileEntity entity, final PathFinder pathFinder) {
    this.cancelNavigationConditions = new CopyOnWriteArrayList<>();
    this.listeners = new CopyOnWriteArrayList<>();
    this.entity = entity;
    this.pathFinder = pathFinder;
    this.setAcceptableError(DEFAULT_ACCEPTABLE_ERROR);
    Game.loop().attach(this);
}
}
```
```java
class de.gurkenlabs.litiengine.GameWindow {
private static void initializeWindowEventListeners(Window window) {

    window.addWindowStateListener(
        e -> {
          if (e.getNewState() == Frame.ICONIFIED) {
            Game.loop().setTickRate(ICONIFIED_MAX_FPS);
          } else {
            Game.loop().setTickRate(Game.config().client().getMaxFps());
          }
        });

    window.addWindowFocusListener(
        new WindowFocusListener() {
          @Override
          public void windowLostFocus(WindowEvent e) {
            if (Game.config().graphics().reduceFramesWhenNotFocused()) {
              Game.loop().setTickRate(NONE_FOCUS_MAX_FPS);
            }
          }

          @Override
          public void windowGainedFocus(WindowEvent e) {
            Game.loop().setTickRate(Game.config().client().getMaxFps());
          }
        });

    window.addWindowListener(
        new WindowAdapter() {
          @Override
          public void windowClosing(final WindowEvent event) {
            Game.exit();
          }
        });
}
}
```
```java
class de.gurkenlabs.litiengine.gui.screens.ScreenManager {
public void display(@Nullable final Screen screen) {
    if (Game.hasStarted() && Game.time().since(this.lastScreenChange) < this.getChangeCooldown()) {
      log.log(
          Level.INFO,
          "Skipping displaying of screen {0} because screen changing is currently on cooldown.",
          screen != null ? screen.getName() : "");
      return;
    }

    final Screen previous = this.current();
    if (previous != null) {
      previous.suspend();
    }

    if (screen != null && !this.screens.contains(screen)) {
      this.screens.add(screen);
    }

    this.currentScreen = screen;
    if (!Game.isInNoGUIMode() && this.current() != null) {
      this.current().prepare();
    }

    this.lastScreenChange = Game.loop().getTicks();

    final ScreenChangedEvent event = new ScreenChangedEvent(this.current(), previous);
    for (final ScreenChangedListener listener : this.screenChangedListeners) {
      listener.changed(event);
    }
}
}
```
```java
class de.gurkenlabs.litiengine.abilities.effects.Effect {
@Override
  public void update() {

    for (final Iterator<EffectApplication> iterator = this.getActiveAppliances().iterator();
        iterator.hasNext(); ) {
      final EffectApplication appliance = iterator.next();
      // if the effect duration is reached
      if (this.hasEnded(appliance)) {

        iterator.remove();
        this.cease(appliance);
      }
    }

    // 4. unregister if all appliances are finished
    if (this.getActiveAppliances().isEmpty()) {
      Game.loop().detach(this);
    }
}public void apply(final Shape impactArea) {
    final List<ICombatEntity> affected = this.lookForAffectedEntities(impactArea);
    for (final ICombatEntity affectedEntity : affected) {
      this.apply(affectedEntity);
    }

    this.appliances.add(new EffectApplication(affected, impactArea));

    // if it is the first appliance -> register for update
    if (this.appliances.size() == 1) {
      Game.loop().attach(this);
    }
}
}
```
```java
class de.gurkenlabs.litiengine.GameTime {
public long toTicks(final int milliseconds) {
    return this.toTicks(milliseconds, Game.loop().getTickRate());
}public long since(final long tick) {
    return toMilliseconds(Game.loop().getTicks() - tick);
}public long now() {
    return Game.loop().getTicks();
}public long sinceGameStart() {
    return this.toMilliseconds(Game.loop().getTicks());
}@Override
  public void loaded(Environment environment) {
    environmentLoaded = Game.loop().getTicks();
}public long toMilliseconds(final long ticks) {
    return this.toMilliseconds(ticks, Game.loop().getTickRate());
}
}
```
```java
class de.gurkenlabs.litiengine.GameMetrics {
@Override
  public void render(final Graphics2D g) {
    this.updateMetrics();

    if (!Game.config().client().showGameMetrics()) {
      return;
    }

    this.currentOffsetY = 0;

    g.setColor(this.renderColor);

    // render client metrics
    this.drawTitle(g, "[client]");
    this.drawMetric(g, "fps       : " + this.getFramesPerSecond());
    this.drawMetric(g, "max fps   : " + this.maxFramesPerSecond);
    this.drawMetric(g, "updatables: " + Game.loop().getUpdatableCount());

    // render jvm metrics if debug is enabled
    if (Game.config().debug().isDebugEnabled()) {
      this.drawTitle(g, "[jvm]");
      this.drawMetric(g, "java      : " + this.javaVersion);
      this.drawMetric(g, "memory    : " + String.format("%-5.5s", this.usedMemory) + " MB");
      this.drawMetric(g, "threads   : " + Thread.activeCount());
    }

    // render rendering metrics
    if (!this.renderMetrics.isEmpty()) {
      this.drawTitle(g, "[update]");

      for (RenderMetrics metric : this.renderMetrics) {
        this.drawMetric(g, metric.toString());
      }

      this.renderMetrics.clear();
    }
}
}
```
```java
class de.gurkenlabs.litiengine.graphics.emitters.Emitter {
public void deactivate() {
    if (!this.activated) {
      return;
    }

    this.activated = false;
    this.getParticles().clear();
    this.aliveTime = 0;
    this.activationTick = 0;
    this.lastSpawn = 0;
    Game.loop().detach(this);
}public void activate() {
    if (this.activated) {
      return;
    }

    this.activated = true;
    this.activationTick = Game.time().now();
    Game.loop().attach(this);
}@Override
  public void update() {
    if (this.isPaused()) {
      return;
    }

    // clear particles if the effect time to life is reached
    if (this.isFinished()) {
      for (EmitterFinishedListener listener : this.finishedListeners) {
        listener.finished(this);
      }

      this.delete();
      return;
    }

    final float updateRatio = (float) this.data().getUpdateRate() / Game.loop().getTickRate();
    for (final Particle p : this.getParticles().stream().collect(Collectors.toList())) {
      if (this.particleCanBeRemoved(p)) {
        // remove dead particles
        this.particles.remove(p);
        continue;
      }

      p.update(this.getOrigin(), updateRatio);
    }

    this.aliveTime = Game.time().since(this.activationTick);
    if ((this.data().getSpawnRate() == 0
        || Game.time().since(this.lastSpawn) >= this.data().getSpawnRate())) {
      this.lastSpawn = Game.time().now();
      this.spawnParticle();
    }
}
}
```
```java
class de.gurkenlabs.litiengine.entities.behavior.IBehaviorController {
public default void attach() {
    Game.loop().attach(this);
}public default void detach() {
    Game.loop().detach(this);
}
}
```
```java
class de.gurkenlabs.litiengine.abilities.AbilityExecution {
AbilityExecution(final Ability ability) {
    this.appliedEffects = new CopyOnWriteArrayList<>();
    this.ability = ability;
    this.executionTicks = Game.time().now();
    this.impactArea = ability.calculateImpactArea();
    this.castLocation = ability.getExecutor().getCenter();
    Game.loop().attach(this);
}@Override
  public void update() {
    // if there a no effects to apply -> unregister this instance and we're done
    if (this.getAbility().getEffects().isEmpty()
        || this.getAbility().getEffects().size() == this.getAppliedEffects().size()) {
      Game.loop().detach(this);
      return;
    }

    // handle all effects from the ability that were not applied yet
    for (final Effect effect : this.getAbility().getEffects()) {
      // if the ability was not executed yet or the delay of the effect is not
      // yet reached
      if (this.getAppliedEffects().contains(effect)
          || Game.time().since(this.getExecutionTicks()) < effect.getDelay()) {
        continue;
      }

      effect.apply(this.getExecutionImpactArea());
      this.getAppliedEffects().add(effect);
    }
}
}
```
```java
class de.gurkenlabs.litiengine.GameWindow$3 {
@Override
          public void windowGainedFocus(WindowEvent e) {
            Game.loop().setTickRate(Game.config().client().getMaxFps());
}@Override
          public void windowLostFocus(WindowEvent e) {
            if (Game.config().graphics().reduceFramesWhenNotFocused()) {
              Game.loop().setTickRate(NONE_FOCUS_MAX_FPS);
            }
}
}
```
```java
class de.gurkenlabs.litiengine.environment.EntitySpawner {
protected void spawnNewEntities() {
    if (this.getSpawnMode() != SpawnMode.CUSTOMSPAWNPOINTS && this.getSpawnPoints().isEmpty()) {
      return;
    }

    switch (this.getSpawnMode()) {
      case ALLSPAWNPOINTS:
        for (int i = 0; i < this.getSpawnPoints().size(); i++) {
          final int index = i;
          Game.loop()
              .perform(
                  this.getSpawnDelay() + this.getSpawnDelay() * i,
                  () -> this.spawn(this.getSpawnPoints().get(index), this.getSpawnAmount()));
        }
        break;
      case ONERANDOMSPAWNPOINT:
        this.spawn(Game.random().choose(this.getSpawnPoints()), this.getSpawnAmount());
        break;
      case RANDOMSPAWNPOINTS:
        for (int i = 0; i < this.getSpawnAmount(); i++) {
          Game.loop()
              .perform(
                  this.getSpawnDelay() + this.getSpawnDelay() * i,
                  () -> this.spawn(Game.random().choose(this.getSpawnPoints()), 1));
        }
        break;
      case CUSTOMSPAWNPOINTS:
        List<Spawnpoint> spawnPoints =
            this.customSpawnpoints != null
                ? this.customSpawnpoints.apply(this)
                : this.getCustomSpawnpoints();

        int index = 0;
        for (Spawnpoint spawn : spawnPoints) {
          Game.loop()
              .perform(
                  this.getSpawnDelay() + this.getSpawnDelay() * index, () -> this.spawn(spawn, 1));
          index++;
        }
        break;
      default:
        break;
    }
}
}
```
```java
class de.gurkenlabs.litiengine.tweening.TweenEngine {
@Override
  public void start() {
    Game.loop().attach(this);
}@Override
  public void terminate() {
    Game.loop().detach(this);
}
}
```
```java
class de.gurkenlabs.litiengine.gui.SpeechBubble {
public void hide() {
    Game.world().environment().removeRenderable(this);
    Game.loop().detach(this);
    if (activeSpeechBubbles.get(this.getEntity()) != null
        && activeSpeechBubbles.remove(this.getEntity()).equals(this)) {
      activeSpeechBubbles.remove(this.getEntity());
    }

    for (SpeechBubbleListener listener : this.listeners) {
      listener.hidden();
    }
}private SpeechBubble(
      final IEntity entity,
      final String text,
      @Nullable SpeechBubbleAppearance appearance,
      @Nullable Font font) {
    if (appearance == null) {
      this.appearance = DEFAULT_APPEARANCE;
    } else {
      this.appearance = appearance;
    }

    final SpeechBubble active = activeSpeechBubbles.get(entity);
    if (active != null) {
      active.hide();
    }
    this.setFont(font);

    this.textBoxWidth = (float) (entity.getWidth() * 4);
    this.entity = entity;

    this.currentText = text;
    this.currentTextDisplayTime = DISPLAYTIME_MIN + text.length() * DISPLAYTIME_PER_LETTER;

    this.lastTextDisplay = Game.time().now();
    this.createBubbleImage();
    entity.getEnvironment().add(this, RenderType.UI);
    Game.loop().attach(this);
    activeSpeechBubbles.put(entity, this);
}
}
```
```java
class de.gurkenlabs.litiengine.entities.Prop {
private void updateAnimationController() {
    IEntityAnimationController<?> controller = this.createAnimationController();
    this.getControllers().addController(controller);
    if (Game.world().environment() != null && Game.world().environment().isLoaded()) {
      Game.loop().attach(controller);
    }
}
}
```
```java
class de.gurkenlabs.litiengine.graphics.FreeFlightCamera {
public FreeFlightCamera(final Point2D focus) {
    this.setFocus(focus);
    this.velocity = DEFAULT_SCROLL_PIXELS_PER_SECOND;
    this.scrollPadding = DEFAULT_SCROLL_PADDING;
    this.setClampToMap(true);

    Game.loop().attach(this);
}private void handleFreeFlightCamera() {
    if (Game.world().environment() == null || Game.world().environment().getMap() == null) {
      return;
    }

    final Point2D mouseLocation = Input.mouse().getLocation();

    final double scrollSpeed =
        this.getVelocity()
            / (double) Game.loop().getTickRate()
            * Game.config().input().getMouseSensitivity();

    double x = this.getFocus().getX();
    double y = this.getFocus().getY();

    double deltaX = 0;
    if (mouseLocation.getX() < this.getScrollPadding()) {
      deltaX -= scrollSpeed;
    } else if (Game.window().getResolution().getWidth() - mouseLocation.getX()
        < this.getScrollPadding()) {
      deltaX += scrollSpeed;
    }

    double deltaY = 0;
    if (mouseLocation.getY() < this.getScrollPadding()) {
      deltaY -= scrollSpeed;
    } else if (Game.window().getResolution().getHeight() - mouseLocation.getY()
        < this.getScrollPadding()) {
      deltaY += scrollSpeed;
    }

    x += deltaX;
    y += deltaY;

    this.setFocus(new Point2D.Double(x, y));
}
}
```
```java
class de.gurkenlabs.litiengine.environment.Environment {
private static void dispose(final Collection<? extends IEntity> entities) {
    for (final IEntity entity : entities) {
      if (entity instanceof IUpdateable) {
        Game.loop().detach((IUpdateable) entity);
      }

      entity.detachControllers();
    }
}private static void loadUpdatableOrEmitterEntity(IEntity entity) {
    if (entity instanceof Emitter) {
      final Emitter emitter = (Emitter) entity;
      if (emitter.isActivateOnInit()) {
        emitter.activate();
      }
    } else if (entity instanceof IUpdateable) {
      Game.loop().attach((IUpdateable) entity);
    }
}private void unload(final IEntity entity) {
    // 1. remove from physics engine
    if (entity instanceof ICollisionEntity) {
      Game.physics().remove((ICollisionEntity) entity);
    }

    // 2. unregister from update
    if (entity instanceof IUpdateable) {
      Game.loop().detach((IUpdateable) entity);
    }

    if (entity instanceof IMobileEntity) {
      this.removeGravity((IMobileEntity) entity);
    }

    // 3. detach all controllers
    entity.detachControllers();

    if (entity instanceof Emitter) {
      Emitter em = (Emitter) entity;
      em.deactivate();
    }

    if (this.loaded && (entity instanceof LightSource || entity instanceof StaticShadow)) {
      this.updateLighting(entity);
    }

    entity.removed(this);
}
}
```
```java
class de.gurkenlabs.litiengine.graphics.animation.Animation {
@Override
  public void update() {
    // do nothing if the animation is not playing or the current keyframe is not finished
    if (!this.isPlaying()
        || Game.time().since(this.lastFrameUpdate) < this.getCurrentKeyFrame().getDuration()) {
      return;
    }

    // if we are not looping and the last keyframe is finished, we terminate the animation
    if (!this.isLooping() && this.isLastKeyFrame()) {
      this.terminate();
      return;
    }

    // make sure, we stay inside the keyframe list
    final int newFrameIndex =
        (this.getKeyframes().indexOf(this.currentFrame) + 1) % this.getKeyframes().size();
    final KeyFrame previousFrame = this.currentFrame;
    this.currentFrame = this.getKeyframes().get(newFrameIndex);

    for (KeyFrameListener listener : this.listeners) {
      listener.currentFrameChanged(previousFrame, this.currentFrame);
    }

    this.lastFrameUpdate = Game.loop().getTicks();
}public void restart() {
    this.currentFrame = this.firstFrame;
    this.lastFrameUpdate = Game.loop().getTicks();
}
}
```
```java
class de.gurkenlabs.litiengine.physics.MovementController {
@Override
  public void attach() {
    Game.loop().attach(this);
}private void handleForces() {
    // clean up forces
    this.activeForces.forEach(
        x -> {
          if (x.hasEnded()) {
            this.activeForces.remove(x);
          }
        });

    if (this.activeForces.isEmpty()) {
      return;
    }

    // disable turn-on-move for force handling
    boolean turn = this.getEntity().turnOnMove();
    this.getEntity().setTurnOnMove(false);
    try {
      double deltaX = 0;
      double deltaY = 0;
      for (final Force force : this.activeForces) {
        if (force.cancelOnReached() && force.hasReached(this.getEntity())) {
          force.end();
          continue;
        }

        final Point2D collisionBoxCenter = this.getEntity().getCollisionBoxCenter();
        final double angle =
            GeometricUtilities.calcRotationAngleInDegrees(collisionBoxCenter, force.getLocation());
        final double strength =
            Game.loop().getDeltaTime() * 0.001f * force.getStrength() * Game.loop().getTimeScale();
        deltaX += GeometricUtilities.getDeltaX(angle, strength);
        deltaY += GeometricUtilities.getDeltaY(angle, strength);
      }

      final Point2D target =
          new Point2D.Double(this.getEntity().getX() + deltaX, this.getEntity().getY() + deltaY);
      final boolean success = Game.physics().move(this.getEntity(), target);
      if (!success) {
        for (final Force force : this.activeForces) {
          if (force.cancelOnCollision()) {
            force.end();
          }
        }
      }
    } finally {
      this.getEntity().setTurnOnMove(turn);
    }
}@Override
  public void detach() {
    Game.loop().detach(this);
}public void handleMovement() {
    if (!this.isMovementAllowed()) {
      this.velocity = 0;
      return;
    }

    // max distance an entity can travel within one tick
    final double maxPixelsPerTick = this.getEntity().getTickVelocity();
    final double deltaTime = Game.loop().getDeltaTime() * Game.loop().getTimeScale();

    final double acceleration =
        this.getEntity().getAcceleration() == 0
            ? maxPixelsPerTick
            : deltaTime / this.getEntity().getAcceleration() * maxPixelsPerTick;
    final double deceleration =
        this.getEntity().getDeceleration() == 0
            ? this.getVelocity()
            : deltaTime / this.getEntity().getDeceleration() * maxPixelsPerTick;

    double dx = this.getDx();
    double dy = this.getDy();
    this.setDx(0);
    this.setDy(0);

    final double deltaVelocity =
        Math.min(Math.sqrt(Math.pow(dx, 2) + Math.pow(dy, 2)), acceleration);
    if (deltaVelocity != 0) {
      double newVelocity = this.getVelocity() + deltaVelocity;
      this.setVelocity(newVelocity);
    } else {
      final double newVelocity = Math.max(0, this.getVelocity() - deceleration);
      this.setVelocity(newVelocity);
      dx = GeometricUtilities.getDeltaX(this.moveAngle);
      dy = GeometricUtilities.getDeltaY(this.moveAngle);
    }

    if (this.getVelocity() == 0) {
      this.moveAngle = 0;
      return;
    }

    // actually move entity
    this.moveEntity(dx, dy);
}
}
```
```java
class de.gurkenlabs.litiengine.graphics.animation.AnimationController {
public void detach() {
    Game.loop().detach(this);
}public void attach() {
    Game.loop().attach(this);
}
}
```
```java
class de.gurkenlabs.litiengine.graphics.Camera {
@Override
  public void setZoom(final float targetZoom, final int delay) {
    if (delay == 0) {

      this.zoom = targetZoom;
      this.targetZoom = 0;
      this.zoomDelay = 0;
      this.zoomTick = 0;
      this.zoomStep = 0;

      final ZoomChangedEvent event = new ZoomChangedEvent(this, targetZoom);
      for (final ZoomChangedListener listener : this.zoomListeners) {
        listener.zoomChanged(event);
      }
    } else {
      this.zoomTick = Game.time().now();
      this.targetZoom = targetZoom;
      this.zoomDelay = delay;

      final double tickduration = 1000 / (double) Game.loop().getTickRate();
      final double tickAmount = delay / tickduration;
      final float totalDelta = this.targetZoom - this.zoom;
      this.zoomStep = tickAmount > 0 ? (float) (totalDelta / tickAmount) : totalDelta;
    }
}
}
```
```java
class de.gurkenlabs.litiengine.Game {
public static synchronized void init(String... args) {
    if (initialized) {
      log().log(Level.INFO, "The game has already been initialized.");
      return;
    }

    log.init();
    handleCommandLineArguments(args);

    config().load();
    Locale.setDefault(new Locale(config().client().getCountry(), config().client().getLanguage()));

    gameLoop = new GameLoop("Main Update Loop", config().client().getMaxFps());
    loop().attach(physics());
    loop().attach(world());

    // setup default exception handling for render and update loop
    setUncaughtExceptionHandler(
        new DefaultUncaughtExceptionHandler(config().client().exitOnError()));

    screenManager = new ScreenManager();
    gameWindow = new GameWindow();

    // initialize  the game window
    window().init();
    world.setCamera(new Camera());

    for (GameListener listener : gameListeners) {
      listener.initialized(args);
    }

    if (!isInNoGUIMode()) {
      window().getRenderComponent().onRendered(g -> metrics().render(g));

      graphics()
          .addEntityRenderedListener(
              e -> DebugRenderer.renderEntityDebugInfo(e.getGraphics(), e.getEntity()));

      window().getRenderComponent().onFpsChanged(fps -> metrics().setFramesPerSecond(fps));
      window()
          .setIcons(
              Arrays.asList(
                  Resources.images().get("liti-logo-x16.png"),
                  Resources.images().get("liti-logo-x20.png"),
                  Resources.images().get("liti-logo-x32.png"),
                  Resources.images().get("liti-logo-x48.png")));

      Input.keyboard()
          .onKeyTyped(
              KeyEvent.VK_PRINTSCREEN,
              key -> {
                // don't take a screenshot if a modifier is active
                if (key.getModifiers() != 0) {
                  return;
                }

                window().getRenderComponent().takeScreenshot();
              });
    }

    Runtime.getRuntime().addShutdownHook(new Thread(Game::terminate, "Shutdown"));

    initialized = true;
}
}
```
```java
class de.gurkenlabs.litiengine.entities.Creature {
protected void updateAnimationController() {
    IEntityAnimationController<?> controller = this.createAnimationController();
    this.getControllers().addController(controller);
    if (Game.world().environment() != null && Game.world().environment().isLoaded()) {
      Game.loop().attach(controller);
    }
}@Override
  public float getTickVelocity() {
    // pixels per ms multiplied by the passed ms
    // ensure that entities don't travel too far in case of lag
    return Math.min(Game.loop().getDeltaTime(), GameLoop.TICK_DELTATIME_LAG)
        * 0.001F
        * this.getVelocity().get()
        * Game.loop().getTimeScale();
}
}
```
Depth: 2
```java
class de.gurkenlabs.litiengine.environment.GameWorld {
public void clear() {
    this.unloadEnvironment();
    this.environments.clear();
    this.setCamera(null);
    Game.physics().clear();

    this.environmentListeners.clear();
    this.environmentLoadedListeners.clear();
    this.environmentUnloadedListeners.clear();

    this.listeners.clear();
    this.loadedListeners.clear();
    this.unloadedListeners.clear();
}@Nullable
  public Environment loadEnvironment(IMap map) {
    Environment env = this.getEnvironment(map);
    this.loadEnvironment(env);
    return env;
}@Nullable
  public Environment loadEnvironment(String mapName) {
    Environment env = this.getEnvironment(mapName);
    this.loadEnvironment(env);
    return env;
}
}
```
```java
class de.gurkenlabs.litiengine.GameWindow {
GameWindow() {
    this.hostControl = new JFrame();

    this.resolutionChangedListeners = new CopyOnWriteArrayList<>();

    this.renderCanvas = new RenderComponent(Game.config().graphics().getResolution());
    this.cursor = new MouseCursor();
    if (!Game.isInNoGUIMode()) {
      this.hostControl.setBackground(Color.BLACK);
      this.hostControl.add(this.renderCanvas);

      this.initializeEventListeners();

      this.hostControl.setTitle(Game.info().getTitle());
      this.hostControl.setDefaultCloseOperation(WindowConstants.DO_NOTHING_ON_CLOSE);
      initializeWindowEventListeners(this.hostControl);
    }
}
}
```
```java
class de.gurkenlabs.litiengine.GameTime {
public long sinceEnvironmentLoad() {
    return this.since(this.environmentLoaded);
}public long since(final long tick) {
    return toMilliseconds(Game.loop().getTicks() - tick);
}public long sinceGameStart() {
    return this.toMilliseconds(Game.loop().getTicks());
}
}
```
```java
class de.gurkenlabs.litiengine.abilities.effects.Effect {
protected void cease(final EffectApplication appliance) {
    // 1. cease the effect for all affected entities
    for (final ICombatEntity entity : appliance.getAffectedEntities()) {
      this.cease(entity);
    }

    // 2. apply follow up effects
    this.getFollowUpEffects().forEach(followUp -> followUp.apply(appliance.getImpactArea()));
}protected boolean hasEnded(final EffectApplication appliance) {
    final long effectDuration = Game.time().since(appliance.getAppliedTicks());
    return effectDuration > this.getDuration();
}
}
```
```java
class de.gurkenlabs.litiengine.abilities.effects.EffectApplication {
protected EffectApplication(final List<ICombatEntity> affectedEntities, final Shape impactArea) {
    this.applied = Game.time().now();
    this.affectedEntities = affectedEntities;
    this.impactArea = impactArea;
}
}
```
```java
class de.gurkenlabs.litiengine.entities.CombatEntity {
@Override
  public boolean wasHit(int timeSpan) {
    return Game.time().since(this.lastHit) < timeSpan;
}@Override
  public void hit(final int damage, @Nullable final Ability ability) {
    if (this.isDead()) {
      return;
    }

    if (!this.isIndestructible()) {
      this.getHitPoints().modifyBaseValue(new AttributeModifier<>(Modification.SUBTRACT, damage));
    }

    final EntityHitEvent event = new EntityHitEvent(this, ability, damage, this.isDead());

    for (final CombatEntityListener listener : this.listeners) {
      listener.hit(event);
    }

    for (final CombatEntityHitListener listener : this.hitListeners) {
      listener.hit(event);
    }

    if (this.isDead()) {
      this.fireDeathEvent();
      this.setCollision(false);
    }

    this.lastHit = Game.time().now();
}
}
```
```java
class de.gurkenlabs.litiengine.graphics.ImageEffect {
protected ImageEffect(final int ttl, final String name) {
    this.ttl = ttl;
    this.name = name;
    this.aliveTick = Game.time().now();
}@Override
  public long getAliveTime() {
    return Game.time().since(this.aliveTick);
}
}
```
```java
class de.gurkenlabs.litiengine.abilities.AbilityExecution {
AbilityExecution(final Ability ability) {
    this.appliedEffects = new CopyOnWriteArrayList<>();
    this.ability = ability;
    this.executionTicks = Game.time().now();
    this.impactArea = ability.calculateImpactArea();
    this.castLocation = ability.getExecutor().getCenter();
    Game.loop().attach(this);
}@Override
  public void update() {
    // if there a no effects to apply -> unregister this instance and we're done
    if (this.getAbility().getEffects().isEmpty()
        || this.getAbility().getEffects().size() == this.getAppliedEffects().size()) {
      Game.loop().detach(this);
      return;
    }

    // handle all effects from the ability that were not applied yet
    for (final Effect effect : this.getAbility().getEffects()) {
      // if the ability was not executed yet or the delay of the effect is not
      // yet reached
      if (this.getAppliedEffects().contains(effect)
          || Game.time().since(this.getExecutionTicks()) < effect.getDelay()) {
        continue;
      }

      effect.apply(this.getExecutionImpactArea());
      this.getAppliedEffects().add(effect);
    }
}
}
```
```java
class de.gurkenlabs.litiengine.tweening.TweenEngine {
@Override
  public void update() {
    for (final Tweenable target : this.getTweens().keySet()) {
      for (final Tween tween : this.getTweens().get(target).values()) {
        if (tween.hasStopped()) {
          continue;
        }
        final long elapsed = Game.time().since(tween.getStartTime());
        if (elapsed >= tween.getDuration()) {
          tween.stop();
          continue;
        }
        final float[] currentValues = new float[tween.getTargetValues().length];
        for (int i = 0; i < tween.getTargetValues().length; i++) {
          currentValues[i] =
              tween.getStartValues()[i]
                  + tween.getEquation().compute(elapsed / (float) tween.getDuration())
                      * (tween.getTargetValues()[i] - tween.getStartValues()[i]);
        }
        tween.getTarget().setTweenValues(tween.getType(), currentValues);
      }
    }
}
}
```
```java
class de.gurkenlabs.litiengine.gui.SpeechBubble {
public static SpeechBubble create(
      final IEntity entity, final String text, SpeechBubbleAppearance appearance, Font font) {
    return new SpeechBubble(entity, text, appearance, font);
}public static SpeechBubble create(final IEntity entity, final Font font, final String text) {
    SpeechBubbleAppearance app =
        new SpeechBubbleAppearance(
            DEFAULT_APPEARANCE.getForeColor(),
            DEFAULT_APPEARANCE.getBackgroundColor1(),
            DEFAULT_APPEARANCE.getBorderColor(),
            DEFAULT_APPEARANCE.getPadding());
    return new SpeechBubble(entity, text, app, font);
}public static SpeechBubble create(final IEntity entity, final String text) {
    return new SpeechBubble(entity, text, null, GuiProperties.getDefaultFont());
}@Override
  public void update() {
    if (this.currentText == null) {
      this.hide();
      return;
    }

    this.entityCenter = Game.world().camera().getViewportLocation(this.getEntity().getCenter());

    // old text was displayed long enough
    if (this.lastTextDisplay != 0
        && Game.time().since(this.lastTextDisplay) > this.currentTextDisplayTime) {
      this.currentText = null;
      this.lastTextDisplay = 0;
      return;
    }

    // display new text
    if (this.textIndex < this.currentText.length()
        && Game.time().since(this.lastCharPoll) > LETTER_WRITE_DELAY) {
      this.textIndex++;
      this.lastCharPoll = Game.time().now();
      if (this.typeSound != null) {
        Game.audio().playSound(this.typeSound, this.getEntity());
      }
    }

    // continue displaying currently displayed text
}private SpeechBubble(
      final IEntity entity,
      final String text,
      final Sound typeSound,
      SpeechBubbleAppearance appearance,
      Font font) {
    this(entity, text, appearance, font);
    this.typeSound = typeSound;
}private SpeechBubble(
      final IEntity entity,
      final String text,
      @Nullable SpeechBubbleAppearance appearance,
      @Nullable Font font) {
    if (appearance == null) {
      this.appearance = DEFAULT_APPEARANCE;
    } else {
      this.appearance = appearance;
    }

    final SpeechBubble active = activeSpeechBubbles.get(entity);
    if (active != null) {
      active.hide();
    }
    this.setFont(font);

    this.textBoxWidth = (float) (entity.getWidth() * 4);
    this.entity = entity;

    this.currentText = text;
    this.currentTextDisplayTime = DISPLAYTIME_MIN + text.length() * DISPLAYTIME_PER_LETTER;

    this.lastTextDisplay = Game.time().now();
    this.createBubbleImage();
    entity.getEnvironment().add(this, RenderType.UI);
    Game.loop().attach(this);
    activeSpeechBubbles.put(entity, this);
}
}
```
```java
class de.gurkenlabs.litiengine.gui.TextFieldComponent {
@Override
  public void render(final Graphics2D g) {
    super.render(g);
    g.setFont(this.getFont());
    final FontMetrics fm = g.getFontMetrics();

    if (this.isSelected() && Game.time().since(this.lastToggled) > this.flickerDelay) {
      this.cursorVisible = !this.cursorVisible;
      this.lastToggled = Game.time().now();
    }
    if (this.isSelected() && this.cursorVisible) {
      final Rectangle2D cursor =
          new Rectangle2D.Double(
              this.getX() + this.getTextX() + fm.stringWidth(this.getTextToRender(g)),
              this.getY() + this.getTextY(),
              this.getFont().getSize2D() * 3 / 5,
              this.getFont().getSize2D() * 1 / 5);
      g.setColor(this.getAppearance().getForeColor());
      g.fill(cursor);
    }
}
}
```
```java
class de.gurkenlabs.litiengine.entities.Prop {
public Prop(
      final Point2D location, @Nullable final String spritesheetName, final Material material) {
    super();
    this.rotation = Rotation.NONE;
    this.spritesheetName = spritesheetName;
    this.material = material;
    this.setLocation(location);
    this.updateAnimationController();
}public void setSpritesheetName(@Nullable final String spriteName) {
    this.spritesheetName = spriteName;
    this.updateAnimationController();
}
}
```
```java
class de.gurkenlabs.litiengine.tweening.Tween {
public Tween begin() {
    this.started = Game.time().now();
    this.stopped = false;
    return this;
}
}
```
```java
class de.gurkenlabs.litiengine.graphics.emitters.particles.Particle {
public void update(final Point2D emitterOrigin, final float updateRatio) {
    if (this.aliveTick == 0) {
      this.aliveTick = Game.time().now();
    }

    this.aliveTime = Game.time().since(this.aliveTick);
    if (this.timeToLiveReached()) {
      return;
    }

    if (this.colliding) {
      return;
    }

    if (this.getDeltaWidth() != 0) {
      this.width += this.getDeltaWidth() * updateRatio;
    }

    if (this.getDeltaHeight() != 0) {
      this.height += this.getDeltaHeight() * updateRatio;
    }

    if (this.getDeltaAngle() != 0) {
      this.angle += this.getDeltaAngle() * updateRatio;
    }

    // test for ray cast collision
    final float targetX = this.x + this.getVelocityX() * updateRatio;
    final float targetY = this.y + this.getVelocityY() * updateRatio;

    if (targetX == this.x && targetY == this.y) {
      return;
    }

    if (this.checkForCollision(emitterOrigin, targetX, targetY)) {
      return;
    }

    if (this.getVelocityX() != 0) {
      this.x = targetX;
    }

    if (this.getVelocityY() != 0) {
      this.y = targetY;
    }

    if (this.getAccelerationX() != 0) {
      this.velocityX += this.getAccelerationX() * updateRatio;
    }

    if (this.getAccelerationY() != 0) {
      this.velocityY += this.getAccelerationY() * updateRatio;
    }
}
}
```
```java
class de.gurkenlabs.litiengine.graphics.animation.Animation {
@Override
  public void start() {
    this.playing = true;
    if (this.getKeyframes().isEmpty()) {
      return;
    }

    this.restart();
}@Override
  public void update() {
    // do nothing if the animation is not playing or the current keyframe is not finished
    if (!this.isPlaying()
        || Game.time().since(this.lastFrameUpdate) < this.getCurrentKeyFrame().getDuration()) {
      return;
    }

    // if we are not looping and the last keyframe is finished, we terminate the animation
    if (!this.isLooping() && this.isLastKeyFrame()) {
      this.terminate();
      return;
    }

    // make sure, we stay inside the keyframe list
    final int newFrameIndex =
        (this.getKeyframes().indexOf(this.currentFrame) + 1) % this.getKeyframes().size();
    final KeyFrame previousFrame = this.currentFrame;
    this.currentFrame = this.getKeyframes().get(newFrameIndex);

    for (KeyFrameListener listener : this.listeners) {
      listener.currentFrameChanged(previousFrame, this.currentFrame);
    }

    this.lastFrameUpdate = Game.loop().getTicks();
}
}
```
```java
class de.gurkenlabs.litiengine.graphics.animation.AnimationController {
@Override
  public void update() {
    for (final Animation animation : this.getAll()) {
      animation.update();
    }

    if (this.getCurrent() != null && this.getCurrent().isPaused()) {
      return;
    }

    final boolean playbackFinished = this.getCurrent() != null && !this.getCurrent().isPlaying();
    if (playbackFinished) {
      for (final AnimationListener listener : this.listeners) {
        listener.finished(this.getCurrent());
      }
    }

    if (this.getCurrent() == null || playbackFinished) {
      if (this.getDefault() != null) {
        this.play(this.getDefault().getName());
      } else {
        this.currentAnimation = null;
      }
    }
}
}
```
```java
class de.gurkenlabs.litiengine.graphics.RenderComponent {
private void handleFade() {
    if (this.fadeOutStart != -1) {
      final long timePassed = Game.time().since(this.fadeOutStart);
      this.currentAlpha = MathUtilities.clamp(1 - timePassed / (float) this.fadeOutTime, 0, 1);
      if (this.currentAlpha == 0f) {
        this.fadeOutStart = -1;
        this.fadeOutTime = -1;
      }

      return;
    }

    if (this.fadeInStart != -1) {
      final long timePassed = Game.time().since(this.fadeInStart);
      this.currentAlpha = MathUtilities.clamp(timePassed / (float) this.fadeInTime, 0, 1);
      if (this.currentAlpha == 1f) {
        this.fadeInStart = -1;
        this.fadeInTime = -1;
        this.currentAlpha = Float.NaN;
      }
    }
}public void fadeOut(final int ms) {
    this.fadeInStart = -1;
    this.fadeInTime = -1;
    this.fadeOutStart = Game.time().now();
    this.fadeOutTime = ms;
}public void fadeIn(final int ms) {
    this.fadeOutStart = -1;
    this.fadeOutTime = -1;
    this.fadeInStart = Game.time().now();
    this.fadeInTime = ms;
}
}
```
```java
class de.gurkenlabs.litiengine.entities.Trigger {
private boolean activate(final IEntity activator, final int tar) {
    if (!this.isLoaded()
        || this.isOneTimeTrigger && this.isActivated
        || this.getActivationType() == TriggerActivation.COLLISION
            && activator != null
            && this.collisionActivated.contains(activator)) {
      return false;
    }

    if (this.getCooldown() > 0 && Game.time().since(this.lastActivation) < this.getCooldown()) {
      return false;
    }

    List<Integer> triggerTargets = this.getTargets(tar);

    final TriggerEvent te = new TriggerEvent(this, activator, triggerTargets);

    if (!this.checkActivationPredicates(te)) {
      return false;
    }

    this.isActivated = true;
    if (activator != null) {
      this.collisionActivated.add(activator);
    }

    // if we actually have a trigger target, we send the message to the target
    for (final int target : triggerTargets) {
      final IEntity entity = this.getEnvironment().get(target);
      if (entity == null) {
        log.log(
            Level.WARNING,
            "trigger [{0}] was activated, but the trigger target [{1}] could not be found on the environment",
            new Object[] {this, target});
        continue;
      }

      entity.sendMessage(this, this.message);
    }

    // also send the trigger event to all registered consumers
    for (final TriggerActivatedListener listener : this.activatedListeners) {
      listener.activated(te);
    }

    if (this.isOneTimeTrigger) {
      this.getEnvironment().remove(this);
    }

    this.lastActivation = Game.time().now();
    return true;
}
}
```
```java
class de.gurkenlabs.litiengine.graphics.Camera {
private boolean isShakeEffectActive() {
    return this.getShakeTick() != 0
        && Game.time().since(this.getShakeTick()) < this.getShakeDuration();
}@Override
  public void update() {
    if (Game.world().camera() != null && !Game.world().camera().equals(this)) {
      return;
    }

    if (this.targetZoom > 0) {
      if (Game.time().since(this.zoomTick) >= this.zoomDelay) {
        this.zoom = this.targetZoom;
        this.targetZoom = 0;
        this.zoomDelay = 0;
        this.zoomTick = 0;
        this.zoomStep = 0;
      } else {
        this.zoom += this.zoomStep;
      }

      final ZoomChangedEvent event = new ZoomChangedEvent(this, this.getZoom());
      for (final ZoomChangedListener listener : this.zoomListeners) {
        listener.zoomChanged(event);
      }
    }

    if (this.panTime > 0) {
      if (--this.panTime <= 0) {
        this.setFocus(this.targetFocus);
        this.targetFocus = null;
      } else {
        double diff = this.panTime / (this.panTime + 1.0);
        this.focus =
            new Point2D.Double(
                this.focus.getX() * diff + this.targetFocus.getX() * (1.0 - diff),
                this.focus.getY() * diff + this.targetFocus.getY() * (1.0 - diff));
      }
    }

    if (!this.isShakeEffectActive()) {
      this.shakeOffsetX = 0;
      this.shakeOffsetY = 0;
      return;
    }

    if (Game.time().since(this.lastShake) > this.shakeDelay) {
      this.shakeOffsetX = this.getShakeIntensity() * ThreadLocalRandom.current().nextGaussian();
      this.shakeOffsetY = this.getShakeIntensity() * ThreadLocalRandom.current().nextGaussian();
      this.lastShake = Game.time().now();
    }
}@Override
  public void setZoom(final float targetZoom, final int delay) {
    if (delay == 0) {

      this.zoom = targetZoom;
      this.targetZoom = 0;
      this.zoomDelay = 0;
      this.zoomTick = 0;
      this.zoomStep = 0;

      final ZoomChangedEvent event = new ZoomChangedEvent(this, targetZoom);
      for (final ZoomChangedListener listener : this.zoomListeners) {
        listener.zoomChanged(event);
      }
    } else {
      this.zoomTick = Game.time().now();
      this.targetZoom = targetZoom;
      this.zoomDelay = delay;

      final double tickduration = 1000 / (double) Game.loop().getTickRate();
      final double tickAmount = delay / tickduration;
      final float totalDelta = this.targetZoom - this.zoom;
      this.zoomStep = tickAmount > 0 ? (float) (totalDelta / tickAmount) : totalDelta;
    }
}@Override
  public void shake(final double intensity, final int delay, final int shakeDuration) {
    this.shakeTick = Game.time().now();
    this.shakeDelay = delay;
    this.shakeIntensity = intensity;
    this.shakeDuration = shakeDuration;
}
}
```
```java
class de.gurkenlabs.litiengine.entities.Creature {
public void setSpritesheetName(String spritesheetName) {
    if (this.spritesheetName != null && this.spritesheetName.equals(spritesheetName)) {
      return;
    }

    this.spritesheetName = spritesheetName;
    this.updateAnimationController();
}public boolean isIdle() {
    return Game.time().since(this.lastMoved) > IDLE_DELAY;
}@Override
  public void setLocation(final Point2D position) {
    if (this.isDead() || position == null) {
      return;
    }

    final Point2D oldLocation = this.getLocation();
    super.setLocation(position);

    if (Game.hasStarted() && this.isLoaded()) {
      this.lastMoved = Game.time().now();
      this.fireMovedEvent(
          new EntityMovedEvent(
              this, this.getX() - oldLocation.getX(), this.getY() - oldLocation.getY()));
    }
}
}
```
```java
class de.gurkenlabs.litiengine.gui.screens.ScreenManager {
public void display(final String screenName) {
    if (this.current() != null && this.current().getName().equalsIgnoreCase(screenName)) {
      log.log(
          Level.INFO,
          "Skipping displaying of screen {0} because it is already the current screen.",
          screenName);
      return;
    }

    if (this.screens.stream()
        .noneMatch(element -> element.getName().equalsIgnoreCase(screenName))) {
      log.log(
          Level.WARNING,
          "Could not display the screen {0} because there is no screen with the specified name.",
          screenName);
      return;
    }

    Screen screen = this.get(screenName);
    if (screen == null) {
      return;
    }

    this.display(screen);
}public void add(final Screen screen) {
    screen.setWidth(Game.window().getWidth());
    screen.setHeight(Game.window().getHeight());
    this.screens.add(screen);

    if (this.current() == null) {
      this.display(screen);
    }
}public void remove(Screen screen) {
    this.screens.remove(screen);
    if (this.current() == screen) {
      if (!this.screens.isEmpty()) {
        this.display(this.screens.get(0));
      } else {
        this.display((Screen) null);
      }
    }
}public void display(@Nullable final Screen screen) {
    if (Game.hasStarted() && Game.time().since(this.lastScreenChange) < this.getChangeCooldown()) {
      log.log(
          Level.INFO,
          "Skipping displaying of screen {0} because screen changing is currently on cooldown.",
          screen != null ? screen.getName() : "");
      return;
    }

    final Screen previous = this.current();
    if (previous != null) {
      previous.suspend();
    }

    if (screen != null && !this.screens.contains(screen)) {
      this.screens.add(screen);
    }

    this.currentScreen = screen;
    if (!Game.isInNoGUIMode() && this.current() != null) {
      this.current().prepare();
    }

    this.lastScreenChange = Game.loop().getTicks();

    final ScreenChangedEvent event = new ScreenChangedEvent(this.current(), previous);
    for (final ScreenChangedListener listener : this.screenChangedListeners) {
      listener.changed(event);
    }
}
}
```
```java
class de.gurkenlabs.litiengine.abilities.Ability {
public boolean isOnCooldown() {
    return (this.getCurrentExecution() != null
        && this.getCurrentExecution().getExecutionTicks() > 0
        && Game.time().since(this.getCurrentExecution().getExecutionTicks())
            < this.getAttributes().cooldown().get());
}public boolean isActive() {
    return this.getCurrentExecution() != null
        && Game.time().since(this.getCurrentExecution().getExecutionTicks())
            < this.getAttributes().duration().get();
}@Nullable
  public AbilityExecution cast() {
    if (!this.canCast()) {
      return null;
    }
    this.currentExecution = new AbilityExecution(this);

    for (final AbilityCastListener listener : this.abilityCastListeners) {
      listener.abilityCast(this.currentExecution);
    }

    return this.getCurrentExecution();
}public float getRemainingCooldownInSeconds() {
    if (this.getCurrentExecution() == null
        || this.getExecutor() == null
        || this.getExecutor().isDead()) {
      return 0;
    }

    // calculate cooldown in seconds
    return (float)
        (!this.canCast()
            ? (this.getAttributes().cooldown().get()
                    - Game.time().since(this.getCurrentExecution().getExecutionTicks()))
                * 0.001
            : 0);
}
}
```
```java
class de.gurkenlabs.litiengine.entities.EntityHitEvent {
EntityHitEvent(
      final ICombatEntity hitEntity,
      @Nullable final Ability ability,
      final int damage,
      final boolean kill) {
    super(hitEntity);
    this.executor = ability != null ? ability.getExecutor() : null;
    this.hitEntity = hitEntity;
    this.ability = ability;
    this.damage = damage;
    this.kill = kill;
    this.time = Game.time().now();
}
}
```
```java
class de.gurkenlabs.litiengine.graphics.emitters.Emitter {
public void delete() {
    this.deactivate();
    if (Game.world().environment() != null) {
      Game.world().environment().remove(this);
    }
}public void activate() {
    if (this.activated) {
      return;
    }

    this.activated = true;
    this.activationTick = Game.time().now();
    Game.loop().attach(this);
}@Override
  public void update() {
    if (this.isPaused()) {
      return;
    }

    // clear particles if the effect time to life is reached
    if (this.isFinished()) {
      for (EmitterFinishedListener listener : this.finishedListeners) {
        listener.finished(this);
      }

      this.delete();
      return;
    }

    final float updateRatio = (float) this.data().getUpdateRate() / Game.loop().getTickRate();
    for (final Particle p : this.getParticles().stream().collect(Collectors.toList())) {
      if (this.particleCanBeRemoved(p)) {
        // remove dead particles
        this.particles.remove(p);
        continue;
      }

      p.update(this.getOrigin(), updateRatio);
    }

    this.aliveTime = Game.time().since(this.activationTick);
    if ((this.data().getSpawnRate() == 0
        || Game.time().since(this.lastSpawn) >= this.data().getSpawnRate())) {
      this.lastSpawn = Game.time().now();
      this.spawnParticle();
    }
}
}
```
```java
class de.gurkenlabs.litiengine.GameLoop {
@Override
  public int perform(int delay, Runnable action) {
    final long d = Game.time().toTicks(delay);

    TimedAction a = new TimedAction(this.getTicks() + d, action);
    this.actions.add(a);

    return a.getId();
}
}
```
```java
class de.gurkenlabs.litiengine.environment.EntitySpawner {
protected boolean shouldSpawn() {
    return this.lastSpawnWave == 0
        || Game.time().since(this.lastSpawnWave) >= this.getSpawnInterval();
}@Override
  public void update() {
    if (!this.shouldSpawn()) {
      return;
    }

    this.spawnNewEntities();
    this.lastSpawnWave = Game.time().now();
}
}
```
```java
class de.gurkenlabs.litiengine.graphics.FreeFlightCamera {
@Override
  public void update() {
    this.handleFreeFlightCamera();
}public FreeFlightCamera(double x, double y) {
    this(new Point2D.Double(x, y));
}
}
```
```java
class de.gurkenlabs.litiengine.environment.Environment {
public void unload() {
    if (!this.loaded) {
      return;
    }

    // unregister all updatable entities from the current environment
    for (final IEntity entity : this.allEntities.values()) {
      this.unload(entity);
    }

    this.loaded = false;
    this.fireEvent(l -> l.unloaded(this));
}private static void loadUpdatableOrEmitterEntity(IEntity entity) {
    if (entity instanceof Emitter) {
      final Emitter emitter = (Emitter) entity;
      if (emitter.isActivateOnInit()) {
        emitter.activate();
      }
    } else if (entity instanceof IUpdateable) {
      Game.loop().attach((IUpdateable) entity);
    }
}public void clear() {
    Game.physics().clear();

    this.combatEntities.clear();
    this.mobileEntities.clear();
    this.gravityForces.clear();
    this.layerEntities.clear();
    this.entitiesByTag.clear();
    this.allEntities.clear();

    for (RenderType renderType : RenderType.values()) {
      this.miscEntities.get(renderType).clear();
      this.renderListeners.get(renderType).clear();
      this.renderables.get(renderType).clear();
    }

    dispose(this.allEntities.values());
    dispose(this.triggers);
    this.emitters.clear();
    this.colliders.clear();
    this.props.clear();
    this.creatures.clear();
    this.staticShadows.clear();
    this.combatEntities.clear();
    this.mobileEntities.clear();
    this.lightSources.clear();
    this.spawnPoints.clear();
    this.soundSources.clear();
    this.mapAreas.clear();
    this.triggers.clear();

    this.ambientLight = null;
    this.staticShadowLayer = null;

    for (Map<Integer, IEntity> type : this.miscEntities.values()) {
      type.clear();
    }

    this.initialized = false;

    this.fireEvent(l -> l.cleared(this));
}private void load(final IEntity entity) {
    // an entity can only exist on one environment at a time, so remove it from the current one
    if (entity.getEnvironment() != null) {
      entity.getEnvironment().remove(entity);
    }

    // 1. add to physics engine
    loadPhysicsEntity(entity);

    // 2. register for update or activate
    loadUpdatableOrEmitterEntity(entity);

    // 3. if a gravity is defined, add a gravity force to the entity
    if (entity instanceof IMobileEntity && this.getGravity() != 0) {
      this.addGravityForce((IMobileEntity) entity);
    }

    // 4. attach all controllers
    entity.attachControllers();

    if (this.loaded && (entity instanceof LightSource || entity instanceof StaticShadow)) {
      this.updateLighting(entity);
    }

    entity.loaded(this);
}private void unload(final IEntity entity) {
    // 1. remove from physics engine
    if (entity instanceof ICollisionEntity) {
      Game.physics().remove((ICollisionEntity) entity);
    }

    // 2. unregister from update
    if (entity instanceof IUpdateable) {
      Game.loop().detach((IUpdateable) entity);
    }

    if (entity instanceof IMobileEntity) {
      this.removeGravity((IMobileEntity) entity);
    }

    // 3. detach all controllers
    entity.detachControllers();

    if (entity instanceof Emitter) {
      Emitter em = (Emitter) entity;
      em.deactivate();
    }

    if (this.loaded && (entity instanceof LightSource || entity instanceof StaticShadow)) {
      this.updateLighting(entity);
    }

    entity.removed(this);
}public void remove(final IEntity entity) {
    if (entity == null) {
      return;
    }

    this.allEntities.remove(entity.getMapId());
    Iterator<List<IEntity>> iter = this.layerEntities.values().iterator();
    while (iter.hasNext()) {
      List<IEntity> layer = iter.next();
      if (layer.remove(entity) && layer.isEmpty()) {
        iter.remove();
      }
    }
    if (this.miscEntities.get(entity.getRenderType()) != null) {
      this.miscEntities.get(entity.getRenderType()).values().remove(entity);
    }

    for (String tag : entity.getTags()) {
      if (this.getEntitiesByTag().containsKey(tag)) {
        this.getEntitiesByTag().get(tag).remove(entity);

        if (this.getEntitiesByTag().get(tag).isEmpty()) {
          this.getEntitiesByTag().remove(tag);
        }
      }
    }

    if (entity instanceof Emitter) {
      Emitter emitter = (Emitter) entity;
      this.removeEmitter(emitter);
    }

    if (entity instanceof MapArea) {
      this.mapAreas.remove(entity);
    }

    if (entity instanceof Prop) {
      this.props.remove(entity);
    }

    if (entity instanceof Creature) {
      this.creatures.remove(entity);
    }

    if (entity instanceof CollisionBox) {
      this.colliders.remove(entity);
      this.staticShadows.removeIf(x -> x.getOrigin() != null && x.getOrigin().equals(entity));
    }

    if (entity instanceof LightSource) {
      this.lightSources.remove(entity);
      this.updateLighting(entity);
    }

    if (entity instanceof Trigger) {
      this.triggers.remove(entity);
    }

    if (entity instanceof Spawnpoint) {
      this.spawnPoints.remove(entity);
    }
    if (entity instanceof SoundSource) {
      this.soundSources.remove(entity);
    }

    if (entity instanceof StaticShadow) {
      this.staticShadows.remove(entity);
      this.updateLighting(entity);
    }

    if (entity instanceof IMobileEntity) {
      this.mobileEntities.values().remove(entity);
    }

    if (entity instanceof ICombatEntity) {
      this.combatEntities.values().remove(entity);
    }

    this.unload(entity);

    this.fireEntityEvent(l -> l.entityRemoved(entity));
}
}
```
```java
class de.gurkenlabs.litiengine.physics.MovementController {
@Override
  public void update() {
    this.handleForces();
    this.handleMovement();
}
}
```
```java
class de.gurkenlabs.litiengine.Game {
static synchronized void terminate() {
    if (!initialized) {
      return;
    }

    hasStarted = false;
    initialized = false;

    config().save();
    gameLoop.terminate();
    tweenEngine.terminate();
    soundEngine.terminate();

    world().clear();

    for (final GameListener listener : gameListeners) {
      try {
        listener.terminated();
      } catch (Exception e) {
        log().log(Level.WARNING, "game listener threw an exception during shutdown", e);
      }
    }

    gameLoop = null;
    screenManager = null;
    gameWindow = null;
}public static synchronized void start() {
    if (!initialized) {
      throw new IllegalStateException(
          "The game cannot be started without being first initialized. Call Game.init(...) before Game.start().");
    }

    gameLoop.start();
    tweenEngine.start();
    soundEngine.start();

    for (final GameListener listener : gameListeners) {
      listener.started();
    }

    hasStarted = true;
}public static synchronized void init(String... args) {
    if (initialized) {
      log().log(Level.INFO, "The game has already been initialized.");
      return;
    }

    log.init();
    handleCommandLineArguments(args);

    config().load();
    Locale.setDefault(new Locale(config().client().getCountry(), config().client().getLanguage()));

    gameLoop = new GameLoop("Main Update Loop", config().client().getMaxFps());
    loop().attach(physics());
    loop().attach(world());

    // setup default exception handling for render and update loop
    setUncaughtExceptionHandler(
        new DefaultUncaughtExceptionHandler(config().client().exitOnError()));

    screenManager = new ScreenManager();
    gameWindow = new GameWindow();

    // initialize  the game window
    window().init();
    world.setCamera(new Camera());

    for (GameListener listener : gameListeners) {
      listener.initialized(args);
    }

    if (!isInNoGUIMode()) {
      window().getRenderComponent().onRendered(g -> metrics().render(g));

      graphics()
          .addEntityRenderedListener(
              e -> DebugRenderer.renderEntityDebugInfo(e.getGraphics(), e.getEntity()));

      window().getRenderComponent().onFpsChanged(fps -> metrics().setFramesPerSecond(fps));
      window()
          .setIcons(
              Arrays.asList(
                  Resources.images().get("liti-logo-x16.png"),
                  Resources.images().get("liti-logo-x20.png"),
                  Resources.images().get("liti-logo-x32.png"),
                  Resources.images().get("liti-logo-x48.png")));

      Input.keyboard()
          .onKeyTyped(
              KeyEvent.VK_PRINTSCREEN,
              key -> {
                // don't take a screenshot if a modifier is active
                if (key.getModifiers() != 0) {
                  return;
                }

                window().getRenderComponent().takeScreenshot();
              });
    }

    Runtime.getRuntime().addShutdownHook(new Thread(Game::terminate, "Shutdown"));

    initialized = true;
}
}
```


Response Format:
Provide the answer in **XML format** as follows:

#### If the method **cannot** return `null` at the specific call site:
```xml
<response>
  <reason><![CDATA[EXPLAIN WHY THE INVOCATION Game.loop() RESULT CANNOT BE NULL.]]></reason>
  <value>NO</value>
</response>

#### If the method can return null at the specific call site:
<response>
  <reason><![CDATA[EXPLAIN WHY THE INVOCATION Game.loop() RESULT CAN BE NULL.]]></reason>
  <value>YES</value>
</response>

#### If you are unsure or If there are any methods that directly or indirectly affect the return value and are not fully disclosed, request their declarations first, in the following format:
<response>
  <reason><![CDATA[EXPLAIN WHY THIS METHOD DECLARATION IS NECESSARY AND WHY YOU CANNOT MAKE A CONFIDENT DECISION WITHOUT IT]]></reason>
  <success>false</success>
  <methods>
    <method>methodName</method>
  </methods>
</response>

Additional Notes:
Be precise in your reasoning.
If a method’s return value depends on another method not provided, request its declaration before making a conclusion.
If the method can return null in this case but not in others, explain why it happens specifically for this call.

---ChatGPT.sendRequestToOpenAI---
Retrieving response from cache
---Response.<init>---
Creating Response:
```xml
<response>
  <reason><![CDATA[The method `Game.loop()` returns the static field `gameLoop`, which is initialized in the `Game.init(String... args)` method. In this method, a new `GameLoop` object is instantiated and assigned to `gameLoop`. Since `init()` must be called before `start()`, which is implied by the requirement of initializing the game, the `gameLoop` is guaranteed to be non-null during the lifetime of the game execution where `Game.loop()` is called. The absence of any code that could set `gameLoop` to null after its initialization ensures that `Game.loop()` cannot return null.]]></reason>
  <value>NO</value>
</response>
```
---Response.<init>---
Response created:
Disagreement: The method `Game.loop()` returns the static field `gameLoop`, which is initialized in the `Game.init(String... args)` method. In this method, a new `GameLoop` object is instantiated and assigned to `gameLoop`. Since `init()` must be called before `start()`, which is implied by the requirement of initializing the game, the `gameLoop` is guaranteed to be non-null during the lifetime of the game execution where `Game.loop()` is called. The absence of any code that could set `gameLoop` to null after its initialization ensures that `Game.loop()` cannot return null.
---AdvancedNullAwayCodeFix.resolveMethodDereferenceError---
Method is not returning nullable on call site. Injecting suppression annotation.
---AdvancedNullAwayCodeFix.constructCastToNonnullChange---
Constructing cast to nonnull change for reason: The method `Game.loop()` returns the static field `gameLoop`, which is initialized in the `Game.init(String... args)` method. In this method, a new `GameLoop` object is instantiated and assigned to `gameLoop`. Since `init()` must be called before `start()`, which is implied by the requirement of initializing the game, the `gameLoop` is guaranteed to be non-null during the lifetime of the game execution where `Game.loop()` is called. The absence of any code that could set `gameLoop` to null after its initialization ensures that `Game.loop()` cannot return null.
---ChatGPT.ask---
Asking ChatGPT:
For the reason you mentioned earlier:

"The method `Game.loop()` returns the static field `gameLoop`, which is initialized in the `Game.init(String... args)` method. In this method, a new `GameLoop` object is instantiated and assigned to `gameLoop`. Since `init()` must be called before `start()`, which is implied by the requirement of initializing the game, the `gameLoop` is guaranteed to be non-null during the lifetime of the game execution where `Game.loop()` is called. The absence of any code that could set `gameLoop` to null after its initialization ensures that `Game.loop()` cannot return null."

in the method below, the expression Game.loop() is not nullable at the point it is used.

```java
public long toMilliseconds(final long ticks) {
    return this.toMilliseconds(ticks, Game.loop().getTickRate());
}
```
Please Summarize the reason in max 5 words and rewrite the method so that at the line "    return this.toMilliseconds(ticks, Game.loop().getTickRate());", at the occurrence of: "Game.loop()" is replaced with `NullabilityUtil.castToNonnull(Game.loop(), summary of reason)`
Replace "REASON" with the exact reason summary I provide to you (maximum 5 words), not with a generic explanation like "checked to be nonnull".
see the example below, for expression `foo.getBar()`, to wrap it with `NullabilityUtil.castToNonnull(foo.getBar(), "reason")`.

```java
public t(){
    String l = foo.getBar();
}
```

will be:
```java
public t(){
    String l = NullabilityUtil.castToNonnull(foo.getBar(), "checked to be nonnull");
}
```

### Instructions:

Do not import any additional classes.

Do not add Java comments.

Only modify relevant lines as required.

Return only the modified method wrapped in the XML format shown below.

Place the Java code inside the <code> tag using a CDATA block with ```java formatting.

Just give me the fixed code snippet in XML format in <response> tag like the example below. I will apply the fix to my codebase. Do not import any additional libraries or classes or add java comments. If you can provide the fixed code snippet, please provide it in the following format and place the code snippet in the <code> tag within ```java block.
<response>
  <success>true</success>
  <code><![CDATA[
  ```java
  Your fixed code snippet here
  ```
    ]]>
  </code>
</response>

---ChatGPT.sendRequestToOpenAI---
Retrieving response from cache
---Response.<init>---
Creating Response:
```xml
<response>
  <success>true</success>
  <code><![CDATA[
  ```java
  public long toMilliseconds(final long ticks) {
      return this.toMilliseconds(ticks, NullabilityUtil.castToNonnull(Game.loop(), "cannot be null").getTickRate());
  }
  ```
    ]]>
  </code>
</response>
```
---Response.<init>---
Response created:
public long toMilliseconds(final long ticks) {
      return this.toMilliseconds(ticks, NullabilityUtil.castToNonnull(Game.loop(), "cannot be null").getTickRate());
  }
---ChatGPT.fixDereferenceByAddingCastToNonnull---
Fixing the error by adding castToNonnull
---AdvancedNullAwayCodeFix.fixTriggeredErrorsForLocation---
Resolving unresolvable error for triggered error: Type='DEREFERENCE_NULLABLE', message='dereferenced expression Game.loop() is @Nullable'
/home/nima/Developer/nullness-benchmarks/litiengine/src/de/gurkenlabs/litiengine/GameWindow.java:390
              Game.loop().setTickRate(NONE_FOCUS_MAX_FPS);
---AdvancedNullAwayCodeFix.fix---
Fixing error: Type='DEREFERENCE_NULLABLE', message='dereferenced expression Game.loop() is @Nullable'
/home/nima/Developer/nullness-benchmarks/litiengine/src/de/gurkenlabs/litiengine/GameWindow.java:390
              Game.loop().setTickRate(NONE_FOCUS_MAX_FPS);
---AdvancedNullAwayCodeFix.resolveDereferenceError---
Resolving dereference error: Type='DEREFERENCE_NULLABLE', message='dereferenced expression Game.loop() is @Nullable'
/home/nima/Developer/nullness-benchmarks/litiengine/src/de/gurkenlabs/litiengine/GameWindow.java:390
              Game.loop().setTickRate(NONE_FOCUS_MAX_FPS);
---AdvancedNullAwayCodeFix.resolveDereferenceError---
Checking nullability possibility at error point
---ChatGPT.checkNullabilityPossibilityAtErrorPoint---
Asking if the expression can be null at error point point
---ChatGPT.ask---
Asking ChatGPT:
In the method below, is there a possibility that the expression "Game.loop()" at line "Game.loop().setTickRate(NONE_FOCUS_MAX_FPS);" is null?
@Override
          public void windowLostFocus(WindowEvent e) {
            if (Game.config().graphics().reduceFramesWhenNotFocused()) {
              Game.loop().setTickRate(NONE_FOCUS_MAX_FPS);
            }
}
Give a single-word answer in XML format. If it is possible for the expression to be null, respond with:
```xml
<response>
    <reason><![CDATA[YOUR REASON]]></reason>
    <value>YES</value>
</response>
```
If it is not possible for the expression to be null, respond with:
```xml
<response>
    <reason><![CDATA[YOUR REASON]]></reason>
    <value>NO</value>
</response>
```
If you are unsure or need more information, respond with where you can ask for more details or what specific information you need.

If additional information is required, list each request inside a `<request>` tag. If no additional information is needed, omit the `<requests>` section.

Respond with:
```xml
<response>
    <reason><![CDATA[YOUR REASON]]></reason>
    <value>UNKNOWN</value>
    <!-- Include <requests> only if additional information is needed -->
    <requests>
        <request><![CDATA[YOUR REQUEST 1]]></request>
        <request><![CDATA[YOUR REQUEST 2]]></request>
    </requests>
</response>
```
---ChatGPT.sendRequestToOpenAI---
Retrieving response from cache
---Response.<init>---
Creating Response:
```xml
<response>
    <reason><![CDATA[Whether `Game.loop()` can be null depends on the implementation details of the `Game` class and its `loop()` method, which are not provided. Without this information, it's uncertain whether `Game.loop()` guarantees a non-null return.]]></reason>
    <value>UNKNOWN</value>
    <requests>
        <request><![CDATA[Provide the implementation details of the `Game` class, specifically the `loop()` method.]]></request>
        <request><![CDATA[Confirm if `Game.loop()` can ever return null under any circumstance.]]></request>
    </requests>
</response>
```
---Response.<init>---
Response created:
Unknown: Whether `Game.loop()` can be null depends on the implementation details of the `Game` class and its `loop()` method, which are not provided. Without this information, it's uncertain whether `Game.loop()` guarantees a non-null return.
---AdvancedNullAwayCodeFix.resolveMethodDereferenceError---
Resolving method dereference error.
---AdvancedNullAwayCodeFix.resolveMethodDereferenceError---
Method is in annotated package. Checking if the method is returning nullable.
---AdvancedNullAwayCodeFix.investigateMethodReturnNullability---
Checking if the method is returning nullable.
---ChatGPT.checkIfMethodIsReturningNullable---
Asking if the method is returning nullable: loop()
---ChatGPT.ask---
Asking ChatGPT:
In the method below, is there a possibility that the method returns null based only on its body? Consider the following points:

- The method may have multiple return paths; consider all return statements.
- If the method calls another method, do not assume its return value unless its full declaration is provided. Request its declaration if needed.
- The method may throw an exception instead of returning null. An exception path should not be considered a null return.
- Ensure you request the declarations of any methods whose return values directly or indirectly impact this method’s return value before making a conclusion.
- Carefully analyze all conditions and prior operations that may guarantee a non-null return value.

@Nullable public static IGameLoop loop() {
    return gameLoop;
}

Here are the method definitions in addition to the method inquired:

Depth: 0
```java
class de.gurkenlabs.litiengine.Game {
@Nullable public static IGameLoop loop() {
    return gameLoop;
}
}
```


Response Format:
Provide the answer in **XML format** as follows:

#### If the method **cannot** return `null`:
```xml
<response>
  <reason><![CDATA[EXPLAIN WHY THE METHOD CANNOT RETURN NULL]]></reason>
  <value>NO</value>
</response>
```

#### If the method can return null:
```xml
<response>
  <reason><![CDATA[EXPLAIN WHY THE METHOD CAN RETURN NULL]]></reason>
  <value>YES</value>
</response>
```

#### If you are unsure or need more information, respond with where you can ask for more details or what specific information you need.

#### If you are unsure or If there are any methods that directly or indirectly affect the return value and are not fully disclosed, request their declarations first, in the following format:
<response>
  <reason><![CDATA[YOUR REASON]]></reason>
  <value>UNKNOWN</value>
  <methods>
    <method>methodName</method>
  </methods>
</response>

If additional information is required other than method declaration, list each request inside a `<request>` tag. If no additional information is needed, omit the `<requests>` section.

Respond with:
```xml
<response>
    <reason><![CDATA[YOUR REASON]]></reason>
    <value>UNKNOWN</value>
    <!-- Include <requests> only if additional information is needed -->
    <requests>
        <request><![CDATA[YOUR REQUEST 1]]></request>
        <request><![CDATA[YOUR REQUEST 2]]></request>
    </requests>
</response>
```

Additional Notes:
Be precise in your reasoning.
If a method’s return value depends on another method not provided, request its declaration before making a conclusion.
If the method can return null in some cases but not others, explain under what conditions it can happen.

---ChatGPT.sendRequestToOpenAI---
Retrieving response from cache
---Response.<init>---
Creating Response:
```xml
<response>
  <reason><![CDATA[The method `loop` returns the variable `gameLoop`. Without the initialization or assignment details of `gameLoop`, it's unclear whether it can be null. The possibility of `gameLoop` being uninitialized or set to null elsewhere in the program means `loop` could potentially return null. Further information on `gameLoop` is required.]]></reason>
  <value>UNKNOWN</value>
  <requests>
    <request><![CDATA[Please provide the declaration and initialization of the variable `gameLoop` in the class `de.gurkenlabs.litiengine.Game`.]]></request>
  </requests>
</response>
```
---Response.<init>---
Response created:
Unknown: The method `loop` returns the variable `gameLoop`. Without the initialization or assignment details of `gameLoop`, it's unclear whether it can be null. The possibility of `gameLoop` being uninitialized or set to null elsewhere in the program means `loop` could potentially return null. Further information on `gameLoop` is required.
---AdvancedNullAwayCodeFix.investigateMethodReturnNullability---
Could not determine the nullability and model did not ask for any method.
---ChatGPT.checkIfMethodIsReturningNullableOnCallSite---
Asking if the method is returning nullable on the call site: Game.loop()
---ChatGPT.ask---
Asking ChatGPT:
In the method below, is there a possibility that the method returns null at the given call site?

```java
@Nullable public static IGameLoop loop() {
    return gameLoop;
}
```

## Guidelines:
- The method may have multiple return paths; consider all return statements.
- If the method calls another method, do not assume its return value unless its full declaration is provided. Request its declaration if needed.
- The method may throw an exception instead of returning null. An exception path should not be considered a null return.
- Ensure you request the declarations of any methods whose return values directly or indirectly impact this method’s return value before making a conclusion.
- If the method returns a value that is determined by a parameter, evaluate based on the actual argument at the given call site.
- Analyze based only on the specific invocation provided. Do not generalize to all possible inputs.- If the return value is guaranteed to be non-null at the call site, the answer should be a definitive NO.
- Do not generalize based on all possible inputs—your answer must be based only on the given invocation.
- Focus only on the given call site, not all possible invocations.

### call site:
Game.loop()

Here are the method definitions and the call chain for this method, showing the sequence of calls from the method to its callers at each depth level:

Depth: 0
```java
class de.gurkenlabs.litiengine.Game {
@Nullable public static IGameLoop loop() {
    return gameLoop;
}
}
```
Depth: 1
```java
class de.gurkenlabs.litiengine.environment.GameWorld {
public void loadEnvironment(@Nullable final Environment env) {
    Lock lock = Game.loop().getLock();
    lock.lock();
    try {
      unloadEnvironment();
      this.environment = env;
      if (env != null) {
        this.addEnvironment(env);

        if (env.getGravity() == 0 && this.gravity() != 0) {
          env.setGravity(this.gravity());
        }

        env.load();
        for (final EnvironmentLoadedListener listener : this.loadedListeners) {
          listener.loaded(env);
        }

        // call map specific listeners
        String mapName = getMapName(env);
        if (mapName != null && this.environmentLoadedListeners.containsKey(mapName)) {

          // for the default camera we center the camera on the environment
          if (this.camera().getClass().equals(Camera.class)) {
            camera().setFocus(env.getCenter());
          }

          for (EnvironmentLoadedListener listener : this.environmentLoadedListeners.get(mapName)) {
            listener.loaded(env);
          }
        }
      }
    } finally {
      lock.unlock();
    }
}public void setCamera(@Nullable final ICamera cam) {
    if (this.camera() != null) {
      Game.loop().detach(camera);
    }

    camera = cam;

    if (cam != null && !Game.isInNoGUIMode()) {
      Game.loop().attach(cam);
      cam.updateFocus();
    }
}
}
```
```java
class de.gurkenlabs.litiengine.entities.behavior.EntityNavigator {
public EntityNavigator(final IMobileEntity entity, final PathFinder pathFinder) {
    this.cancelNavigationConditions = new CopyOnWriteArrayList<>();
    this.listeners = new CopyOnWriteArrayList<>();
    this.entity = entity;
    this.pathFinder = pathFinder;
    this.setAcceptableError(DEFAULT_ACCEPTABLE_ERROR);
    Game.loop().attach(this);
}
}
```
```java
class de.gurkenlabs.litiengine.GameWindow {
private static void initializeWindowEventListeners(Window window) {

    window.addWindowStateListener(
        e -> {
          if (e.getNewState() == Frame.ICONIFIED) {
            Game.loop().setTickRate(ICONIFIED_MAX_FPS);
          } else {
            Game.loop().setTickRate(Game.config().client().getMaxFps());
          }
        });

    window.addWindowFocusListener(
        new WindowFocusListener() {
          @Override
          public void windowLostFocus(WindowEvent e) {
            if (Game.config().graphics().reduceFramesWhenNotFocused()) {
              Game.loop().setTickRate(NONE_FOCUS_MAX_FPS);
            }
          }

          @Override
          public void windowGainedFocus(WindowEvent e) {
            Game.loop().setTickRate(Game.config().client().getMaxFps());
          }
        });

    window.addWindowListener(
        new WindowAdapter() {
          @Override
          public void windowClosing(final WindowEvent event) {
            Game.exit();
          }
        });
}
}
```
```java
class de.gurkenlabs.litiengine.gui.screens.ScreenManager {
public void display(@Nullable final Screen screen) {
    if (Game.hasStarted() && Game.time().since(this.lastScreenChange) < this.getChangeCooldown()) {
      log.log(
          Level.INFO,
          "Skipping displaying of screen {0} because screen changing is currently on cooldown.",
          screen != null ? screen.getName() : "");
      return;
    }

    final Screen previous = this.current();
    if (previous != null) {
      previous.suspend();
    }

    if (screen != null && !this.screens.contains(screen)) {
      this.screens.add(screen);
    }

    this.currentScreen = screen;
    if (!Game.isInNoGUIMode() && this.current() != null) {
      this.current().prepare();
    }

    this.lastScreenChange = Game.loop().getTicks();

    final ScreenChangedEvent event = new ScreenChangedEvent(this.current(), previous);
    for (final ScreenChangedListener listener : this.screenChangedListeners) {
      listener.changed(event);
    }
}
}
```
```java
class de.gurkenlabs.litiengine.abilities.effects.Effect {
@Override
  public void update() {

    for (final Iterator<EffectApplication> iterator = this.getActiveAppliances().iterator();
        iterator.hasNext(); ) {
      final EffectApplication appliance = iterator.next();
      // if the effect duration is reached
      if (this.hasEnded(appliance)) {

        iterator.remove();
        this.cease(appliance);
      }
    }

    // 4. unregister if all appliances are finished
    if (this.getActiveAppliances().isEmpty()) {
      Game.loop().detach(this);
    }
}public void apply(final Shape impactArea) {
    final List<ICombatEntity> affected = this.lookForAffectedEntities(impactArea);
    for (final ICombatEntity affectedEntity : affected) {
      this.apply(affectedEntity);
    }

    this.appliances.add(new EffectApplication(affected, impactArea));

    // if it is the first appliance -> register for update
    if (this.appliances.size() == 1) {
      Game.loop().attach(this);
    }
}
}
```
```java
class de.gurkenlabs.litiengine.GameTime {
public long toTicks(final int milliseconds) {
    return this.toTicks(milliseconds, Game.loop().getTickRate());
}public long since(final long tick) {
    return toMilliseconds(Game.loop().getTicks() - tick);
}public long now() {
    return Game.loop().getTicks();
}public long sinceGameStart() {
    return this.toMilliseconds(Game.loop().getTicks());
}@Override
  public void loaded(Environment environment) {
    environmentLoaded = Game.loop().getTicks();
}public long toMilliseconds(final long ticks) {
    return this.toMilliseconds(ticks, Game.loop().getTickRate());
}
}
```
```java
class de.gurkenlabs.litiengine.GameMetrics {
@Override
  public void render(final Graphics2D g) {
    this.updateMetrics();

    if (!Game.config().client().showGameMetrics()) {
      return;
    }

    this.currentOffsetY = 0;

    g.setColor(this.renderColor);

    // render client metrics
    this.drawTitle(g, "[client]");
    this.drawMetric(g, "fps       : " + this.getFramesPerSecond());
    this.drawMetric(g, "max fps   : " + this.maxFramesPerSecond);
    this.drawMetric(g, "updatables: " + Game.loop().getUpdatableCount());

    // render jvm metrics if debug is enabled
    if (Game.config().debug().isDebugEnabled()) {
      this.drawTitle(g, "[jvm]");
      this.drawMetric(g, "java      : " + this.javaVersion);
      this.drawMetric(g, "memory    : " + String.format("%-5.5s", this.usedMemory) + " MB");
      this.drawMetric(g, "threads   : " + Thread.activeCount());
    }

    // render rendering metrics
    if (!this.renderMetrics.isEmpty()) {
      this.drawTitle(g, "[update]");

      for (RenderMetrics metric : this.renderMetrics) {
        this.drawMetric(g, metric.toString());
      }

      this.renderMetrics.clear();
    }
}
}
```
```java
class de.gurkenlabs.litiengine.graphics.emitters.Emitter {
public void deactivate() {
    if (!this.activated) {
      return;
    }

    this.activated = false;
    this.getParticles().clear();
    this.aliveTime = 0;
    this.activationTick = 0;
    this.lastSpawn = 0;
    Game.loop().detach(this);
}public void activate() {
    if (this.activated) {
      return;
    }

    this.activated = true;
    this.activationTick = Game.time().now();
    Game.loop().attach(this);
}@Override
  public void update() {
    if (this.isPaused()) {
      return;
    }

    // clear particles if the effect time to life is reached
    if (this.isFinished()) {
      for (EmitterFinishedListener listener : this.finishedListeners) {
        listener.finished(this);
      }

      this.delete();
      return;
    }

    final float updateRatio = (float) this.data().getUpdateRate() / Game.loop().getTickRate();
    for (final Particle p : this.getParticles().stream().collect(Collectors.toList())) {
      if (this.particleCanBeRemoved(p)) {
        // remove dead particles
        this.particles.remove(p);
        continue;
      }

      p.update(this.getOrigin(), updateRatio);
    }

    this.aliveTime = Game.time().since(this.activationTick);
    if ((this.data().getSpawnRate() == 0
        || Game.time().since(this.lastSpawn) >= this.data().getSpawnRate())) {
      this.lastSpawn = Game.time().now();
      this.spawnParticle();
    }
}
}
```
```java
class de.gurkenlabs.litiengine.entities.behavior.IBehaviorController {
public default void attach() {
    Game.loop().attach(this);
}public default void detach() {
    Game.loop().detach(this);
}
}
```
```java
class de.gurkenlabs.litiengine.abilities.AbilityExecution {
AbilityExecution(final Ability ability) {
    this.appliedEffects = new CopyOnWriteArrayList<>();
    this.ability = ability;
    this.executionTicks = Game.time().now();
    this.impactArea = ability.calculateImpactArea();
    this.castLocation = ability.getExecutor().getCenter();
    Game.loop().attach(this);
}@Override
  public void update() {
    // if there a no effects to apply -> unregister this instance and we're done
    if (this.getAbility().getEffects().isEmpty()
        || this.getAbility().getEffects().size() == this.getAppliedEffects().size()) {
      Game.loop().detach(this);
      return;
    }

    // handle all effects from the ability that were not applied yet
    for (final Effect effect : this.getAbility().getEffects()) {
      // if the ability was not executed yet or the delay of the effect is not
      // yet reached
      if (this.getAppliedEffects().contains(effect)
          || Game.time().since(this.getExecutionTicks()) < effect.getDelay()) {
        continue;
      }

      effect.apply(this.getExecutionImpactArea());
      this.getAppliedEffects().add(effect);
    }
}
}
```
```java
class de.gurkenlabs.litiengine.GameWindow$3 {
@Override
          public void windowGainedFocus(WindowEvent e) {
            Game.loop().setTickRate(Game.config().client().getMaxFps());
}@Override
          public void windowLostFocus(WindowEvent e) {
            if (Game.config().graphics().reduceFramesWhenNotFocused()) {
              Game.loop().setTickRate(NONE_FOCUS_MAX_FPS);
            }
}
}
```
```java
class de.gurkenlabs.litiengine.environment.EntitySpawner {
protected void spawnNewEntities() {
    if (this.getSpawnMode() != SpawnMode.CUSTOMSPAWNPOINTS && this.getSpawnPoints().isEmpty()) {
      return;
    }

    switch (this.getSpawnMode()) {
      case ALLSPAWNPOINTS:
        for (int i = 0; i < this.getSpawnPoints().size(); i++) {
          final int index = i;
          Game.loop()
              .perform(
                  this.getSpawnDelay() + this.getSpawnDelay() * i,
                  () -> this.spawn(this.getSpawnPoints().get(index), this.getSpawnAmount()));
        }
        break;
      case ONERANDOMSPAWNPOINT:
        this.spawn(Game.random().choose(this.getSpawnPoints()), this.getSpawnAmount());
        break;
      case RANDOMSPAWNPOINTS:
        for (int i = 0; i < this.getSpawnAmount(); i++) {
          Game.loop()
              .perform(
                  this.getSpawnDelay() + this.getSpawnDelay() * i,
                  () -> this.spawn(Game.random().choose(this.getSpawnPoints()), 1));
        }
        break;
      case CUSTOMSPAWNPOINTS:
        List<Spawnpoint> spawnPoints =
            this.customSpawnpoints != null
                ? this.customSpawnpoints.apply(this)
                : this.getCustomSpawnpoints();

        int index = 0;
        for (Spawnpoint spawn : spawnPoints) {
          Game.loop()
              .perform(
                  this.getSpawnDelay() + this.getSpawnDelay() * index, () -> this.spawn(spawn, 1));
          index++;
        }
        break;
      default:
        break;
    }
}
}
```
```java
class de.gurkenlabs.litiengine.tweening.TweenEngine {
@Override
  public void start() {
    Game.loop().attach(this);
}@Override
  public void terminate() {
    Game.loop().detach(this);
}
}
```
```java
class de.gurkenlabs.litiengine.gui.SpeechBubble {
public void hide() {
    Game.world().environment().removeRenderable(this);
    Game.loop().detach(this);
    if (activeSpeechBubbles.get(this.getEntity()) != null
        && activeSpeechBubbles.remove(this.getEntity()).equals(this)) {
      activeSpeechBubbles.remove(this.getEntity());
    }

    for (SpeechBubbleListener listener : this.listeners) {
      listener.hidden();
    }
}private SpeechBubble(
      final IEntity entity,
      final String text,
      @Nullable SpeechBubbleAppearance appearance,
      @Nullable Font font) {
    if (appearance == null) {
      this.appearance = DEFAULT_APPEARANCE;
    } else {
      this.appearance = appearance;
    }

    final SpeechBubble active = activeSpeechBubbles.get(entity);
    if (active != null) {
      active.hide();
    }
    this.setFont(font);

    this.textBoxWidth = (float) (entity.getWidth() * 4);
    this.entity = entity;

    this.currentText = text;
    this.currentTextDisplayTime = DISPLAYTIME_MIN + text.length() * DISPLAYTIME_PER_LETTER;

    this.lastTextDisplay = Game.time().now();
    this.createBubbleImage();
    entity.getEnvironment().add(this, RenderType.UI);
    Game.loop().attach(this);
    activeSpeechBubbles.put(entity, this);
}
}
```
```java
class de.gurkenlabs.litiengine.entities.Prop {
private void updateAnimationController() {
    IEntityAnimationController<?> controller = this.createAnimationController();
    this.getControllers().addController(controller);
    if (Game.world().environment() != null && Game.world().environment().isLoaded()) {
      Game.loop().attach(controller);
    }
}
}
```
```java
class de.gurkenlabs.litiengine.graphics.FreeFlightCamera {
public FreeFlightCamera(final Point2D focus) {
    this.setFocus(focus);
    this.velocity = DEFAULT_SCROLL_PIXELS_PER_SECOND;
    this.scrollPadding = DEFAULT_SCROLL_PADDING;
    this.setClampToMap(true);

    Game.loop().attach(this);
}private void handleFreeFlightCamera() {
    if (Game.world().environment() == null || Game.world().environment().getMap() == null) {
      return;
    }

    final Point2D mouseLocation = Input.mouse().getLocation();

    final double scrollSpeed =
        this.getVelocity()
            / (double) Game.loop().getTickRate()
            * Game.config().input().getMouseSensitivity();

    double x = this.getFocus().getX();
    double y = this.getFocus().getY();

    double deltaX = 0;
    if (mouseLocation.getX() < this.getScrollPadding()) {
      deltaX -= scrollSpeed;
    } else if (Game.window().getResolution().getWidth() - mouseLocation.getX()
        < this.getScrollPadding()) {
      deltaX += scrollSpeed;
    }

    double deltaY = 0;
    if (mouseLocation.getY() < this.getScrollPadding()) {
      deltaY -= scrollSpeed;
    } else if (Game.window().getResolution().getHeight() - mouseLocation.getY()
        < this.getScrollPadding()) {
      deltaY += scrollSpeed;
    }

    x += deltaX;
    y += deltaY;

    this.setFocus(new Point2D.Double(x, y));
}
}
```
```java
class de.gurkenlabs.litiengine.environment.Environment {
private static void dispose(final Collection<? extends IEntity> entities) {
    for (final IEntity entity : entities) {
      if (entity instanceof IUpdateable) {
        Game.loop().detach((IUpdateable) entity);
      }

      entity.detachControllers();
    }
}private static void loadUpdatableOrEmitterEntity(IEntity entity) {
    if (entity instanceof Emitter) {
      final Emitter emitter = (Emitter) entity;
      if (emitter.isActivateOnInit()) {
        emitter.activate();
      }
    } else if (entity instanceof IUpdateable) {
      Game.loop().attach((IUpdateable) entity);
    }
}private void unload(final IEntity entity) {
    // 1. remove from physics engine
    if (entity instanceof ICollisionEntity) {
      Game.physics().remove((ICollisionEntity) entity);
    }

    // 2. unregister from update
    if (entity instanceof IUpdateable) {
      Game.loop().detach((IUpdateable) entity);
    }

    if (entity instanceof IMobileEntity) {
      this.removeGravity((IMobileEntity) entity);
    }

    // 3. detach all controllers
    entity.detachControllers();

    if (entity instanceof Emitter) {
      Emitter em = (Emitter) entity;
      em.deactivate();
    }

    if (this.loaded && (entity instanceof LightSource || entity instanceof StaticShadow)) {
      this.updateLighting(entity);
    }

    entity.removed(this);
}
}
```
```java
class de.gurkenlabs.litiengine.graphics.animation.Animation {
@Override
  public void update() {
    // do nothing if the animation is not playing or the current keyframe is not finished
    if (!this.isPlaying()
        || Game.time().since(this.lastFrameUpdate) < this.getCurrentKeyFrame().getDuration()) {
      return;
    }

    // if we are not looping and the last keyframe is finished, we terminate the animation
    if (!this.isLooping() && this.isLastKeyFrame()) {
      this.terminate();
      return;
    }

    // make sure, we stay inside the keyframe list
    final int newFrameIndex =
        (this.getKeyframes().indexOf(this.currentFrame) + 1) % this.getKeyframes().size();
    final KeyFrame previousFrame = this.currentFrame;
    this.currentFrame = this.getKeyframes().get(newFrameIndex);

    for (KeyFrameListener listener : this.listeners) {
      listener.currentFrameChanged(previousFrame, this.currentFrame);
    }

    this.lastFrameUpdate = Game.loop().getTicks();
}public void restart() {
    this.currentFrame = this.firstFrame;
    this.lastFrameUpdate = Game.loop().getTicks();
}
}
```
```java
class de.gurkenlabs.litiengine.physics.MovementController {
@Override
  public void attach() {
    Game.loop().attach(this);
}private void handleForces() {
    // clean up forces
    this.activeForces.forEach(
        x -> {
          if (x.hasEnded()) {
            this.activeForces.remove(x);
          }
        });

    if (this.activeForces.isEmpty()) {
      return;
    }

    // disable turn-on-move for force handling
    boolean turn = this.getEntity().turnOnMove();
    this.getEntity().setTurnOnMove(false);
    try {
      double deltaX = 0;
      double deltaY = 0;
      for (final Force force : this.activeForces) {
        if (force.cancelOnReached() && force.hasReached(this.getEntity())) {
          force.end();
          continue;
        }

        final Point2D collisionBoxCenter = this.getEntity().getCollisionBoxCenter();
        final double angle =
            GeometricUtilities.calcRotationAngleInDegrees(collisionBoxCenter, force.getLocation());
        final double strength =
            Game.loop().getDeltaTime() * 0.001f * force.getStrength() * Game.loop().getTimeScale();
        deltaX += GeometricUtilities.getDeltaX(angle, strength);
        deltaY += GeometricUtilities.getDeltaY(angle, strength);
      }

      final Point2D target =
          new Point2D.Double(this.getEntity().getX() + deltaX, this.getEntity().getY() + deltaY);
      final boolean success = Game.physics().move(this.getEntity(), target);
      if (!success) {
        for (final Force force : this.activeForces) {
          if (force.cancelOnCollision()) {
            force.end();
          }
        }
      }
    } finally {
      this.getEntity().setTurnOnMove(turn);
    }
}@Override
  public void detach() {
    Game.loop().detach(this);
}public void handleMovement() {
    if (!this.isMovementAllowed()) {
      this.velocity = 0;
      return;
    }

    // max distance an entity can travel within one tick
    final double maxPixelsPerTick = this.getEntity().getTickVelocity();
    final double deltaTime = Game.loop().getDeltaTime() * Game.loop().getTimeScale();

    final double acceleration =
        this.getEntity().getAcceleration() == 0
            ? maxPixelsPerTick
            : deltaTime / this.getEntity().getAcceleration() * maxPixelsPerTick;
    final double deceleration =
        this.getEntity().getDeceleration() == 0
            ? this.getVelocity()
            : deltaTime / this.getEntity().getDeceleration() * maxPixelsPerTick;

    double dx = this.getDx();
    double dy = this.getDy();
    this.setDx(0);
    this.setDy(0);

    final double deltaVelocity =
        Math.min(Math.sqrt(Math.pow(dx, 2) + Math.pow(dy, 2)), acceleration);
    if (deltaVelocity != 0) {
      double newVelocity = this.getVelocity() + deltaVelocity;
      this.setVelocity(newVelocity);
    } else {
      final double newVelocity = Math.max(0, this.getVelocity() - deceleration);
      this.setVelocity(newVelocity);
      dx = GeometricUtilities.getDeltaX(this.moveAngle);
      dy = GeometricUtilities.getDeltaY(this.moveAngle);
    }

    if (this.getVelocity() == 0) {
      this.moveAngle = 0;
      return;
    }

    // actually move entity
    this.moveEntity(dx, dy);
}
}
```
```java
class de.gurkenlabs.litiengine.graphics.animation.AnimationController {
public void detach() {
    Game.loop().detach(this);
}public void attach() {
    Game.loop().attach(this);
}
}
```
```java
class de.gurkenlabs.litiengine.graphics.Camera {
@Override
  public void setZoom(final float targetZoom, final int delay) {
    if (delay == 0) {

      this.zoom = targetZoom;
      this.targetZoom = 0;
      this.zoomDelay = 0;
      this.zoomTick = 0;
      this.zoomStep = 0;

      final ZoomChangedEvent event = new ZoomChangedEvent(this, targetZoom);
      for (final ZoomChangedListener listener : this.zoomListeners) {
        listener.zoomChanged(event);
      }
    } else {
      this.zoomTick = Game.time().now();
      this.targetZoom = targetZoom;
      this.zoomDelay = delay;

      final double tickduration = 1000 / (double) Game.loop().getTickRate();
      final double tickAmount = delay / tickduration;
      final float totalDelta = this.targetZoom - this.zoom;
      this.zoomStep = tickAmount > 0 ? (float) (totalDelta / tickAmount) : totalDelta;
    }
}
}
```
```java
class de.gurkenlabs.litiengine.Game {
public static synchronized void init(String... args) {
    if (initialized) {
      log().log(Level.INFO, "The game has already been initialized.");
      return;
    }

    log.init();
    handleCommandLineArguments(args);

    config().load();
    Locale.setDefault(new Locale(config().client().getCountry(), config().client().getLanguage()));

    gameLoop = new GameLoop("Main Update Loop", config().client().getMaxFps());
    loop().attach(physics());
    loop().attach(world());

    // setup default exception handling for render and update loop
    setUncaughtExceptionHandler(
        new DefaultUncaughtExceptionHandler(config().client().exitOnError()));

    screenManager = new ScreenManager();
    gameWindow = new GameWindow();

    // initialize  the game window
    window().init();
    world.setCamera(new Camera());

    for (GameListener listener : gameListeners) {
      listener.initialized(args);
    }

    if (!isInNoGUIMode()) {
      window().getRenderComponent().onRendered(g -> metrics().render(g));

      graphics()
          .addEntityRenderedListener(
              e -> DebugRenderer.renderEntityDebugInfo(e.getGraphics(), e.getEntity()));

      window().getRenderComponent().onFpsChanged(fps -> metrics().setFramesPerSecond(fps));
      window()
          .setIcons(
              Arrays.asList(
                  Resources.images().get("liti-logo-x16.png"),
                  Resources.images().get("liti-logo-x20.png"),
                  Resources.images().get("liti-logo-x32.png"),
                  Resources.images().get("liti-logo-x48.png")));

      Input.keyboard()
          .onKeyTyped(
              KeyEvent.VK_PRINTSCREEN,
              key -> {
                // don't take a screenshot if a modifier is active
                if (key.getModifiers() != 0) {
                  return;
                }

                window().getRenderComponent().takeScreenshot();
              });
    }

    Runtime.getRuntime().addShutdownHook(new Thread(Game::terminate, "Shutdown"));

    initialized = true;
}
}
```
```java
class de.gurkenlabs.litiengine.entities.Creature {
protected void updateAnimationController() {
    IEntityAnimationController<?> controller = this.createAnimationController();
    this.getControllers().addController(controller);
    if (Game.world().environment() != null && Game.world().environment().isLoaded()) {
      Game.loop().attach(controller);
    }
}@Override
  public float getTickVelocity() {
    // pixels per ms multiplied by the passed ms
    // ensure that entities don't travel too far in case of lag
    return Math.min(Game.loop().getDeltaTime(), GameLoop.TICK_DELTATIME_LAG)
        * 0.001F
        * this.getVelocity().get()
        * Game.loop().getTimeScale();
}
}
```
Depth: 2
```java
class de.gurkenlabs.litiengine.environment.GameWorld {
public void clear() {
    this.unloadEnvironment();
    this.environments.clear();
    this.setCamera(null);
    Game.physics().clear();

    this.environmentListeners.clear();
    this.environmentLoadedListeners.clear();
    this.environmentUnloadedListeners.clear();

    this.listeners.clear();
    this.loadedListeners.clear();
    this.unloadedListeners.clear();
}@Nullable
  public Environment loadEnvironment(IMap map) {
    Environment env = this.getEnvironment(map);
    this.loadEnvironment(env);
    return env;
}@Nullable
  public Environment loadEnvironment(String mapName) {
    Environment env = this.getEnvironment(mapName);
    this.loadEnvironment(env);
    return env;
}
}
```
```java
class de.gurkenlabs.litiengine.GameWindow {
GameWindow() {
    this.hostControl = new JFrame();

    this.resolutionChangedListeners = new CopyOnWriteArrayList<>();

    this.renderCanvas = new RenderComponent(Game.config().graphics().getResolution());
    this.cursor = new MouseCursor();
    if (!Game.isInNoGUIMode()) {
      this.hostControl.setBackground(Color.BLACK);
      this.hostControl.add(this.renderCanvas);

      this.initializeEventListeners();

      this.hostControl.setTitle(Game.info().getTitle());
      this.hostControl.setDefaultCloseOperation(WindowConstants.DO_NOTHING_ON_CLOSE);
      initializeWindowEventListeners(this.hostControl);
    }
}
}
```
```java
class de.gurkenlabs.litiengine.GameTime {
public long sinceEnvironmentLoad() {
    return this.since(this.environmentLoaded);
}public long since(final long tick) {
    return toMilliseconds(Game.loop().getTicks() - tick);
}public long sinceGameStart() {
    return this.toMilliseconds(Game.loop().getTicks());
}
}
```
```java
class de.gurkenlabs.litiengine.abilities.effects.Effect {
protected void cease(final EffectApplication appliance) {
    // 1. cease the effect for all affected entities
    for (final ICombatEntity entity : appliance.getAffectedEntities()) {
      this.cease(entity);
    }

    // 2. apply follow up effects
    this.getFollowUpEffects().forEach(followUp -> followUp.apply(appliance.getImpactArea()));
}protected boolean hasEnded(final EffectApplication appliance) {
    final long effectDuration = Game.time().since(appliance.getAppliedTicks());
    return effectDuration > this.getDuration();
}
}
```
```java
class de.gurkenlabs.litiengine.abilities.effects.EffectApplication {
protected EffectApplication(final List<ICombatEntity> affectedEntities, final Shape impactArea) {
    this.applied = Game.time().now();
    this.affectedEntities = affectedEntities;
    this.impactArea = impactArea;
}
}
```
```java
class de.gurkenlabs.litiengine.entities.CombatEntity {
@Override
  public boolean wasHit(int timeSpan) {
    return Game.time().since(this.lastHit) < timeSpan;
}@Override
  public void hit(final int damage, @Nullable final Ability ability) {
    if (this.isDead()) {
      return;
    }

    if (!this.isIndestructible()) {
      this.getHitPoints().modifyBaseValue(new AttributeModifier<>(Modification.SUBTRACT, damage));
    }

    final EntityHitEvent event = new EntityHitEvent(this, ability, damage, this.isDead());

    for (final CombatEntityListener listener : this.listeners) {
      listener.hit(event);
    }

    for (final CombatEntityHitListener listener : this.hitListeners) {
      listener.hit(event);
    }

    if (this.isDead()) {
      this.fireDeathEvent();
      this.setCollision(false);
    }

    this.lastHit = Game.time().now();
}
}
```
```java
class de.gurkenlabs.litiengine.graphics.ImageEffect {
protected ImageEffect(final int ttl, final String name) {
    this.ttl = ttl;
    this.name = name;
    this.aliveTick = Game.time().now();
}@Override
  public long getAliveTime() {
    return Game.time().since(this.aliveTick);
}
}
```
```java
class de.gurkenlabs.litiengine.abilities.AbilityExecution {
AbilityExecution(final Ability ability) {
    this.appliedEffects = new CopyOnWriteArrayList<>();
    this.ability = ability;
    this.executionTicks = Game.time().now();
    this.impactArea = ability.calculateImpactArea();
    this.castLocation = ability.getExecutor().getCenter();
    Game.loop().attach(this);
}@Override
  public void update() {
    // if there a no effects to apply -> unregister this instance and we're done
    if (this.getAbility().getEffects().isEmpty()
        || this.getAbility().getEffects().size() == this.getAppliedEffects().size()) {
      Game.loop().detach(this);
      return;
    }

    // handle all effects from the ability that were not applied yet
    for (final Effect effect : this.getAbility().getEffects()) {
      // if the ability was not executed yet or the delay of the effect is not
      // yet reached
      if (this.getAppliedEffects().contains(effect)
          || Game.time().since(this.getExecutionTicks()) < effect.getDelay()) {
        continue;
      }

      effect.apply(this.getExecutionImpactArea());
      this.getAppliedEffects().add(effect);
    }
}
}
```
```java
class de.gurkenlabs.litiengine.tweening.TweenEngine {
@Override
  public void update() {
    for (final Tweenable target : this.getTweens().keySet()) {
      for (final Tween tween : this.getTweens().get(target).values()) {
        if (tween.hasStopped()) {
          continue;
        }
        final long elapsed = Game.time().since(tween.getStartTime());
        if (elapsed >= tween.getDuration()) {
          tween.stop();
          continue;
        }
        final float[] currentValues = new float[tween.getTargetValues().length];
        for (int i = 0; i < tween.getTargetValues().length; i++) {
          currentValues[i] =
              tween.getStartValues()[i]
                  + tween.getEquation().compute(elapsed / (float) tween.getDuration())
                      * (tween.getTargetValues()[i] - tween.getStartValues()[i]);
        }
        tween.getTarget().setTweenValues(tween.getType(), currentValues);
      }
    }
}
}
```
```java
class de.gurkenlabs.litiengine.gui.SpeechBubble {
public static SpeechBubble create(
      final IEntity entity, final String text, SpeechBubbleAppearance appearance, Font font) {
    return new SpeechBubble(entity, text, appearance, font);
}public static SpeechBubble create(final IEntity entity, final Font font, final String text) {
    SpeechBubbleAppearance app =
        new SpeechBubbleAppearance(
            DEFAULT_APPEARANCE.getForeColor(),
            DEFAULT_APPEARANCE.getBackgroundColor1(),
            DEFAULT_APPEARANCE.getBorderColor(),
            DEFAULT_APPEARANCE.getPadding());
    return new SpeechBubble(entity, text, app, font);
}public static SpeechBubble create(final IEntity entity, final String text) {
    return new SpeechBubble(entity, text, null, GuiProperties.getDefaultFont());
}@Override
  public void update() {
    if (this.currentText == null) {
      this.hide();
      return;
    }

    this.entityCenter = Game.world().camera().getViewportLocation(this.getEntity().getCenter());

    // old text was displayed long enough
    if (this.lastTextDisplay != 0
        && Game.time().since(this.lastTextDisplay) > this.currentTextDisplayTime) {
      this.currentText = null;
      this.lastTextDisplay = 0;
      return;
    }

    // display new text
    if (this.textIndex < this.currentText.length()
        && Game.time().since(this.lastCharPoll) > LETTER_WRITE_DELAY) {
      this.textIndex++;
      this.lastCharPoll = Game.time().now();
      if (this.typeSound != null) {
        Game.audio().playSound(this.typeSound, this.getEntity());
      }
    }

    // continue displaying currently displayed text
}private SpeechBubble(
      final IEntity entity,
      final String text,
      final Sound typeSound,
      SpeechBubbleAppearance appearance,
      Font font) {
    this(entity, text, appearance, font);
    this.typeSound = typeSound;
}private SpeechBubble(
      final IEntity entity,
      final String text,
      @Nullable SpeechBubbleAppearance appearance,
      @Nullable Font font) {
    if (appearance == null) {
      this.appearance = DEFAULT_APPEARANCE;
    } else {
      this.appearance = appearance;
    }

    final SpeechBubble active = activeSpeechBubbles.get(entity);
    if (active != null) {
      active.hide();
    }
    this.setFont(font);

    this.textBoxWidth = (float) (entity.getWidth() * 4);
    this.entity = entity;

    this.currentText = text;
    this.currentTextDisplayTime = DISPLAYTIME_MIN + text.length() * DISPLAYTIME_PER_LETTER;

    this.lastTextDisplay = Game.time().now();
    this.createBubbleImage();
    entity.getEnvironment().add(this, RenderType.UI);
    Game.loop().attach(this);
    activeSpeechBubbles.put(entity, this);
}
}
```
```java
class de.gurkenlabs.litiengine.gui.TextFieldComponent {
@Override
  public void render(final Graphics2D g) {
    super.render(g);
    g.setFont(this.getFont());
    final FontMetrics fm = g.getFontMetrics();

    if (this.isSelected() && Game.time().since(this.lastToggled) > this.flickerDelay) {
      this.cursorVisible = !this.cursorVisible;
      this.lastToggled = Game.time().now();
    }
    if (this.isSelected() && this.cursorVisible) {
      final Rectangle2D cursor =
          new Rectangle2D.Double(
              this.getX() + this.getTextX() + fm.stringWidth(this.getTextToRender(g)),
              this.getY() + this.getTextY(),
              this.getFont().getSize2D() * 3 / 5,
              this.getFont().getSize2D() * 1 / 5);
      g.setColor(this.getAppearance().getForeColor());
      g.fill(cursor);
    }
}
}
```
```java
class de.gurkenlabs.litiengine.entities.Prop {
public Prop(
      final Point2D location, @Nullable final String spritesheetName, final Material material) {
    super();
    this.rotation = Rotation.NONE;
    this.spritesheetName = spritesheetName;
    this.material = material;
    this.setLocation(location);
    this.updateAnimationController();
}public void setSpritesheetName(@Nullable final String spriteName) {
    this.spritesheetName = spriteName;
    this.updateAnimationController();
}
}
```
```java
class de.gurkenlabs.litiengine.tweening.Tween {
public Tween begin() {
    this.started = Game.time().now();
    this.stopped = false;
    return this;
}
}
```
```java
class de.gurkenlabs.litiengine.graphics.emitters.particles.Particle {
public void update(final Point2D emitterOrigin, final float updateRatio) {
    if (this.aliveTick == 0) {
      this.aliveTick = Game.time().now();
    }

    this.aliveTime = Game.time().since(this.aliveTick);
    if (this.timeToLiveReached()) {
      return;
    }

    if (this.colliding) {
      return;
    }

    if (this.getDeltaWidth() != 0) {
      this.width += this.getDeltaWidth() * updateRatio;
    }

    if (this.getDeltaHeight() != 0) {
      this.height += this.getDeltaHeight() * updateRatio;
    }

    if (this.getDeltaAngle() != 0) {
      this.angle += this.getDeltaAngle() * updateRatio;
    }

    // test for ray cast collision
    final float targetX = this.x + this.getVelocityX() * updateRatio;
    final float targetY = this.y + this.getVelocityY() * updateRatio;

    if (targetX == this.x && targetY == this.y) {
      return;
    }

    if (this.checkForCollision(emitterOrigin, targetX, targetY)) {
      return;
    }

    if (this.getVelocityX() != 0) {
      this.x = targetX;
    }

    if (this.getVelocityY() != 0) {
      this.y = targetY;
    }

    if (this.getAccelerationX() != 0) {
      this.velocityX += this.getAccelerationX() * updateRatio;
    }

    if (this.getAccelerationY() != 0) {
      this.velocityY += this.getAccelerationY() * updateRatio;
    }
}
}
```
```java
class de.gurkenlabs.litiengine.graphics.animation.Animation {
@Override
  public void start() {
    this.playing = true;
    if (this.getKeyframes().isEmpty()) {
      return;
    }

    this.restart();
}@Override
  public void update() {
    // do nothing if the animation is not playing or the current keyframe is not finished
    if (!this.isPlaying()
        || Game.time().since(this.lastFrameUpdate) < this.getCurrentKeyFrame().getDuration()) {
      return;
    }

    // if we are not looping and the last keyframe is finished, we terminate the animation
    if (!this.isLooping() && this.isLastKeyFrame()) {
      this.terminate();
      return;
    }

    // make sure, we stay inside the keyframe list
    final int newFrameIndex =
        (this.getKeyframes().indexOf(this.currentFrame) + 1) % this.getKeyframes().size();
    final KeyFrame previousFrame = this.currentFrame;
    this.currentFrame = this.getKeyframes().get(newFrameIndex);

    for (KeyFrameListener listener : this.listeners) {
      listener.currentFrameChanged(previousFrame, this.currentFrame);
    }

    this.lastFrameUpdate = Game.loop().getTicks();
}
}
```
```java
class de.gurkenlabs.litiengine.graphics.animation.AnimationController {
@Override
  public void update() {
    for (final Animation animation : this.getAll()) {
      animation.update();
    }

    if (this.getCurrent() != null && this.getCurrent().isPaused()) {
      return;
    }

    final boolean playbackFinished = this.getCurrent() != null && !this.getCurrent().isPlaying();
    if (playbackFinished) {
      for (final AnimationListener listener : this.listeners) {
        listener.finished(this.getCurrent());
      }
    }

    if (this.getCurrent() == null || playbackFinished) {
      if (this.getDefault() != null) {
        this.play(this.getDefault().getName());
      } else {
        this.currentAnimation = null;
      }
    }
}
}
```
```java
class de.gurkenlabs.litiengine.graphics.RenderComponent {
private void handleFade() {
    if (this.fadeOutStart != -1) {
      final long timePassed = Game.time().since(this.fadeOutStart);
      this.currentAlpha = MathUtilities.clamp(1 - timePassed / (float) this.fadeOutTime, 0, 1);
      if (this.currentAlpha == 0f) {
        this.fadeOutStart = -1;
        this.fadeOutTime = -1;
      }

      return;
    }

    if (this.fadeInStart != -1) {
      final long timePassed = Game.time().since(this.fadeInStart);
      this.currentAlpha = MathUtilities.clamp(timePassed / (float) this.fadeInTime, 0, 1);
      if (this.currentAlpha == 1f) {
        this.fadeInStart = -1;
        this.fadeInTime = -1;
        this.currentAlpha = Float.NaN;
      }
    }
}public void fadeOut(final int ms) {
    this.fadeInStart = -1;
    this.fadeInTime = -1;
    this.fadeOutStart = Game.time().now();
    this.fadeOutTime = ms;
}public void fadeIn(final int ms) {
    this.fadeOutStart = -1;
    this.fadeOutTime = -1;
    this.fadeInStart = Game.time().now();
    this.fadeInTime = ms;
}
}
```
```java
class de.gurkenlabs.litiengine.entities.Trigger {
private boolean activate(final IEntity activator, final int tar) {
    if (!this.isLoaded()
        || this.isOneTimeTrigger && this.isActivated
        || this.getActivationType() == TriggerActivation.COLLISION
            && activator != null
            && this.collisionActivated.contains(activator)) {
      return false;
    }

    if (this.getCooldown() > 0 && Game.time().since(this.lastActivation) < this.getCooldown()) {
      return false;
    }

    List<Integer> triggerTargets = this.getTargets(tar);

    final TriggerEvent te = new TriggerEvent(this, activator, triggerTargets);

    if (!this.checkActivationPredicates(te)) {
      return false;
    }

    this.isActivated = true;
    if (activator != null) {
      this.collisionActivated.add(activator);
    }

    // if we actually have a trigger target, we send the message to the target
    for (final int target : triggerTargets) {
      final IEntity entity = this.getEnvironment().get(target);
      if (entity == null) {
        log.log(
            Level.WARNING,
            "trigger [{0}] was activated, but the trigger target [{1}] could not be found on the environment",
            new Object[] {this, target});
        continue;
      }

      entity.sendMessage(this, this.message);
    }

    // also send the trigger event to all registered consumers
    for (final TriggerActivatedListener listener : this.activatedListeners) {
      listener.activated(te);
    }

    if (this.isOneTimeTrigger) {
      this.getEnvironment().remove(this);
    }

    this.lastActivation = Game.time().now();
    return true;
}
}
```
```java
class de.gurkenlabs.litiengine.graphics.Camera {
private boolean isShakeEffectActive() {
    return this.getShakeTick() != 0
        && Game.time().since(this.getShakeTick()) < this.getShakeDuration();
}@Override
  public void update() {
    if (Game.world().camera() != null && !Game.world().camera().equals(this)) {
      return;
    }

    if (this.targetZoom > 0) {
      if (Game.time().since(this.zoomTick) >= this.zoomDelay) {
        this.zoom = this.targetZoom;
        this.targetZoom = 0;
        this.zoomDelay = 0;
        this.zoomTick = 0;
        this.zoomStep = 0;
      } else {
        this.zoom += this.zoomStep;
      }

      final ZoomChangedEvent event = new ZoomChangedEvent(this, this.getZoom());
      for (final ZoomChangedListener listener : this.zoomListeners) {
        listener.zoomChanged(event);
      }
    }

    if (this.panTime > 0) {
      if (--this.panTime <= 0) {
        this.setFocus(this.targetFocus);
        this.targetFocus = null;
      } else {
        double diff = this.panTime / (this.panTime + 1.0);
        this.focus =
            new Point2D.Double(
                this.focus.getX() * diff + this.targetFocus.getX() * (1.0 - diff),
                this.focus.getY() * diff + this.targetFocus.getY() * (1.0 - diff));
      }
    }

    if (!this.isShakeEffectActive()) {
      this.shakeOffsetX = 0;
      this.shakeOffsetY = 0;
      return;
    }

    if (Game.time().since(this.lastShake) > this.shakeDelay) {
      this.shakeOffsetX = this.getShakeIntensity() * ThreadLocalRandom.current().nextGaussian();
      this.shakeOffsetY = this.getShakeIntensity() * ThreadLocalRandom.current().nextGaussian();
      this.lastShake = Game.time().now();
    }
}@Override
  public void setZoom(final float targetZoom, final int delay) {
    if (delay == 0) {

      this.zoom = targetZoom;
      this.targetZoom = 0;
      this.zoomDelay = 0;
      this.zoomTick = 0;
      this.zoomStep = 0;

      final ZoomChangedEvent event = new ZoomChangedEvent(this, targetZoom);
      for (final ZoomChangedListener listener : this.zoomListeners) {
        listener.zoomChanged(event);
      }
    } else {
      this.zoomTick = Game.time().now();
      this.targetZoom = targetZoom;
      this.zoomDelay = delay;

      final double tickduration = 1000 / (double) Game.loop().getTickRate();
      final double tickAmount = delay / tickduration;
      final float totalDelta = this.targetZoom - this.zoom;
      this.zoomStep = tickAmount > 0 ? (float) (totalDelta / tickAmount) : totalDelta;
    }
}@Override
  public void shake(final double intensity, final int delay, final int shakeDuration) {
    this.shakeTick = Game.time().now();
    this.shakeDelay = delay;
    this.shakeIntensity = intensity;
    this.shakeDuration = shakeDuration;
}
}
```
```java
class de.gurkenlabs.litiengine.entities.Creature {
public void setSpritesheetName(String spritesheetName) {
    if (this.spritesheetName != null && this.spritesheetName.equals(spritesheetName)) {
      return;
    }

    this.spritesheetName = spritesheetName;
    this.updateAnimationController();
}public boolean isIdle() {
    return Game.time().since(this.lastMoved) > IDLE_DELAY;
}@Override
  public void setLocation(final Point2D position) {
    if (this.isDead() || position == null) {
      return;
    }

    final Point2D oldLocation = this.getLocation();
    super.setLocation(position);

    if (Game.hasStarted() && this.isLoaded()) {
      this.lastMoved = Game.time().now();
      this.fireMovedEvent(
          new EntityMovedEvent(
              this, this.getX() - oldLocation.getX(), this.getY() - oldLocation.getY()));
    }
}
}
```
```java
class de.gurkenlabs.litiengine.gui.screens.ScreenManager {
public void display(final String screenName) {
    if (this.current() != null && this.current().getName().equalsIgnoreCase(screenName)) {
      log.log(
          Level.INFO,
          "Skipping displaying of screen {0} because it is already the current screen.",
          screenName);
      return;
    }

    if (this.screens.stream()
        .noneMatch(element -> element.getName().equalsIgnoreCase(screenName))) {
      log.log(
          Level.WARNING,
          "Could not display the screen {0} because there is no screen with the specified name.",
          screenName);
      return;
    }

    Screen screen = this.get(screenName);
    if (screen == null) {
      return;
    }

    this.display(screen);
}public void add(final Screen screen) {
    screen.setWidth(Game.window().getWidth());
    screen.setHeight(Game.window().getHeight());
    this.screens.add(screen);

    if (this.current() == null) {
      this.display(screen);
    }
}public void remove(Screen screen) {
    this.screens.remove(screen);
    if (this.current() == screen) {
      if (!this.screens.isEmpty()) {
        this.display(this.screens.get(0));
      } else {
        this.display((Screen) null);
      }
    }
}public void display(@Nullable final Screen screen) {
    if (Game.hasStarted() && Game.time().since(this.lastScreenChange) < this.getChangeCooldown()) {
      log.log(
          Level.INFO,
          "Skipping displaying of screen {0} because screen changing is currently on cooldown.",
          screen != null ? screen.getName() : "");
      return;
    }

    final Screen previous = this.current();
    if (previous != null) {
      previous.suspend();
    }

    if (screen != null && !this.screens.contains(screen)) {
      this.screens.add(screen);
    }

    this.currentScreen = screen;
    if (!Game.isInNoGUIMode() && this.current() != null) {
      this.current().prepare();
    }

    this.lastScreenChange = Game.loop().getTicks();

    final ScreenChangedEvent event = new ScreenChangedEvent(this.current(), previous);
    for (final ScreenChangedListener listener : this.screenChangedListeners) {
      listener.changed(event);
    }
}
}
```
```java
class de.gurkenlabs.litiengine.abilities.Ability {
public boolean isOnCooldown() {
    return (this.getCurrentExecution() != null
        && this.getCurrentExecution().getExecutionTicks() > 0
        && Game.time().since(this.getCurrentExecution().getExecutionTicks())
            < this.getAttributes().cooldown().get());
}public boolean isActive() {
    return this.getCurrentExecution() != null
        && Game.time().since(this.getCurrentExecution().getExecutionTicks())
            < this.getAttributes().duration().get();
}@Nullable
  public AbilityExecution cast() {
    if (!this.canCast()) {
      return null;
    }
    this.currentExecution = new AbilityExecution(this);

    for (final AbilityCastListener listener : this.abilityCastListeners) {
      listener.abilityCast(this.currentExecution);
    }

    return this.getCurrentExecution();
}public float getRemainingCooldownInSeconds() {
    if (this.getCurrentExecution() == null
        || this.getExecutor() == null
        || this.getExecutor().isDead()) {
      return 0;
    }

    // calculate cooldown in seconds
    return (float)
        (!this.canCast()
            ? (this.getAttributes().cooldown().get()
                    - Game.time().since(this.getCurrentExecution().getExecutionTicks()))
                * 0.001
            : 0);
}
}
```
```java
class de.gurkenlabs.litiengine.entities.EntityHitEvent {
EntityHitEvent(
      final ICombatEntity hitEntity,
      @Nullable final Ability ability,
      final int damage,
      final boolean kill) {
    super(hitEntity);
    this.executor = ability != null ? ability.getExecutor() : null;
    this.hitEntity = hitEntity;
    this.ability = ability;
    this.damage = damage;
    this.kill = kill;
    this.time = Game.time().now();
}
}
```
```java
class de.gurkenlabs.litiengine.graphics.emitters.Emitter {
public void delete() {
    this.deactivate();
    if (Game.world().environment() != null) {
      Game.world().environment().remove(this);
    }
}public void activate() {
    if (this.activated) {
      return;
    }

    this.activated = true;
    this.activationTick = Game.time().now();
    Game.loop().attach(this);
}@Override
  public void update() {
    if (this.isPaused()) {
      return;
    }

    // clear particles if the effect time to life is reached
    if (this.isFinished()) {
      for (EmitterFinishedListener listener : this.finishedListeners) {
        listener.finished(this);
      }

      this.delete();
      return;
    }

    final float updateRatio = (float) this.data().getUpdateRate() / Game.loop().getTickRate();
    for (final Particle p : this.getParticles().stream().collect(Collectors.toList())) {
      if (this.particleCanBeRemoved(p)) {
        // remove dead particles
        this.particles.remove(p);
        continue;
      }

      p.update(this.getOrigin(), updateRatio);
    }

    this.aliveTime = Game.time().since(this.activationTick);
    if ((this.data().getSpawnRate() == 0
        || Game.time().since(this.lastSpawn) >= this.data().getSpawnRate())) {
      this.lastSpawn = Game.time().now();
      this.spawnParticle();
    }
}
}
```
```java
class de.gurkenlabs.litiengine.GameLoop {
@Override
  public int perform(int delay, Runnable action) {
    final long d = Game.time().toTicks(delay);

    TimedAction a = new TimedAction(this.getTicks() + d, action);
    this.actions.add(a);

    return a.getId();
}
}
```
```java
class de.gurkenlabs.litiengine.environment.EntitySpawner {
protected boolean shouldSpawn() {
    return this.lastSpawnWave == 0
        || Game.time().since(this.lastSpawnWave) >= this.getSpawnInterval();
}@Override
  public void update() {
    if (!this.shouldSpawn()) {
      return;
    }

    this.spawnNewEntities();
    this.lastSpawnWave = Game.time().now();
}
}
```
```java
class de.gurkenlabs.litiengine.graphics.FreeFlightCamera {
@Override
  public void update() {
    this.handleFreeFlightCamera();
}public FreeFlightCamera(double x, double y) {
    this(new Point2D.Double(x, y));
}
}
```
```java
class de.gurkenlabs.litiengine.environment.Environment {
public void unload() {
    if (!this.loaded) {
      return;
    }

    // unregister all updatable entities from the current environment
    for (final IEntity entity : this.allEntities.values()) {
      this.unload(entity);
    }

    this.loaded = false;
    this.fireEvent(l -> l.unloaded(this));
}private static void loadUpdatableOrEmitterEntity(IEntity entity) {
    if (entity instanceof Emitter) {
      final Emitter emitter = (Emitter) entity;
      if (emitter.isActivateOnInit()) {
        emitter.activate();
      }
    } else if (entity instanceof IUpdateable) {
      Game.loop().attach((IUpdateable) entity);
    }
}public void clear() {
    Game.physics().clear();

    this.combatEntities.clear();
    this.mobileEntities.clear();
    this.gravityForces.clear();
    this.layerEntities.clear();
    this.entitiesByTag.clear();
    this.allEntities.clear();

    for (RenderType renderType : RenderType.values()) {
      this.miscEntities.get(renderType).clear();
      this.renderListeners.get(renderType).clear();
      this.renderables.get(renderType).clear();
    }

    dispose(this.allEntities.values());
    dispose(this.triggers);
    this.emitters.clear();
    this.colliders.clear();
    this.props.clear();
    this.creatures.clear();
    this.staticShadows.clear();
    this.combatEntities.clear();
    this.mobileEntities.clear();
    this.lightSources.clear();
    this.spawnPoints.clear();
    this.soundSources.clear();
    this.mapAreas.clear();
    this.triggers.clear();

    this.ambientLight = null;
    this.staticShadowLayer = null;

    for (Map<Integer, IEntity> type : this.miscEntities.values()) {
      type.clear();
    }

    this.initialized = false;

    this.fireEvent(l -> l.cleared(this));
}private void load(final IEntity entity) {
    // an entity can only exist on one environment at a time, so remove it from the current one
    if (entity.getEnvironment() != null) {
      entity.getEnvironment().remove(entity);
    }

    // 1. add to physics engine
    loadPhysicsEntity(entity);

    // 2. register for update or activate
    loadUpdatableOrEmitterEntity(entity);

    // 3. if a gravity is defined, add a gravity force to the entity
    if (entity instanceof IMobileEntity && this.getGravity() != 0) {
      this.addGravityForce((IMobileEntity) entity);
    }

    // 4. attach all controllers
    entity.attachControllers();

    if (this.loaded && (entity instanceof LightSource || entity instanceof StaticShadow)) {
      this.updateLighting(entity);
    }

    entity.loaded(this);
}private void unload(final IEntity entity) {
    // 1. remove from physics engine
    if (entity instanceof ICollisionEntity) {
      Game.physics().remove((ICollisionEntity) entity);
    }

    // 2. unregister from update
    if (entity instanceof IUpdateable) {
      Game.loop().detach((IUpdateable) entity);
    }

    if (entity instanceof IMobileEntity) {
      this.removeGravity((IMobileEntity) entity);
    }

    // 3. detach all controllers
    entity.detachControllers();

    if (entity instanceof Emitter) {
      Emitter em = (Emitter) entity;
      em.deactivate();
    }

    if (this.loaded && (entity instanceof LightSource || entity instanceof StaticShadow)) {
      this.updateLighting(entity);
    }

    entity.removed(this);
}public void remove(final IEntity entity) {
    if (entity == null) {
      return;
    }

    this.allEntities.remove(entity.getMapId());
    Iterator<List<IEntity>> iter = this.layerEntities.values().iterator();
    while (iter.hasNext()) {
      List<IEntity> layer = iter.next();
      if (layer.remove(entity) && layer.isEmpty()) {
        iter.remove();
      }
    }
    if (this.miscEntities.get(entity.getRenderType()) != null) {
      this.miscEntities.get(entity.getRenderType()).values().remove(entity);
    }

    for (String tag : entity.getTags()) {
      if (this.getEntitiesByTag().containsKey(tag)) {
        this.getEntitiesByTag().get(tag).remove(entity);

        if (this.getEntitiesByTag().get(tag).isEmpty()) {
          this.getEntitiesByTag().remove(tag);
        }
      }
    }

    if (entity instanceof Emitter) {
      Emitter emitter = (Emitter) entity;
      this.removeEmitter(emitter);
    }

    if (entity instanceof MapArea) {
      this.mapAreas.remove(entity);
    }

    if (entity instanceof Prop) {
      this.props.remove(entity);
    }

    if (entity instanceof Creature) {
      this.creatures.remove(entity);
    }

    if (entity instanceof CollisionBox) {
      this.colliders.remove(entity);
      this.staticShadows.removeIf(x -> x.getOrigin() != null && x.getOrigin().equals(entity));
    }

    if (entity instanceof LightSource) {
      this.lightSources.remove(entity);
      this.updateLighting(entity);
    }

    if (entity instanceof Trigger) {
      this.triggers.remove(entity);
    }

    if (entity instanceof Spawnpoint) {
      this.spawnPoints.remove(entity);
    }
    if (entity instanceof SoundSource) {
      this.soundSources.remove(entity);
    }

    if (entity instanceof StaticShadow) {
      this.staticShadows.remove(entity);
      this.updateLighting(entity);
    }

    if (entity instanceof IMobileEntity) {
      this.mobileEntities.values().remove(entity);
    }

    if (entity instanceof ICombatEntity) {
      this.combatEntities.values().remove(entity);
    }

    this.unload(entity);

    this.fireEntityEvent(l -> l.entityRemoved(entity));
}
}
```
```java
class de.gurkenlabs.litiengine.physics.MovementController {
@Override
  public void update() {
    this.handleForces();
    this.handleMovement();
}
}
```
```java
class de.gurkenlabs.litiengine.Game {
static synchronized void terminate() {
    if (!initialized) {
      return;
    }

    hasStarted = false;
    initialized = false;

    config().save();
    gameLoop.terminate();
    tweenEngine.terminate();
    soundEngine.terminate();

    world().clear();

    for (final GameListener listener : gameListeners) {
      try {
        listener.terminated();
      } catch (Exception e) {
        log().log(Level.WARNING, "game listener threw an exception during shutdown", e);
      }
    }

    gameLoop = null;
    screenManager = null;
    gameWindow = null;
}public static synchronized void start() {
    if (!initialized) {
      throw new IllegalStateException(
          "The game cannot be started without being first initialized. Call Game.init(...) before Game.start().");
    }

    gameLoop.start();
    tweenEngine.start();
    soundEngine.start();

    for (final GameListener listener : gameListeners) {
      listener.started();
    }

    hasStarted = true;
}public static synchronized void init(String... args) {
    if (initialized) {
      log().log(Level.INFO, "The game has already been initialized.");
      return;
    }

    log.init();
    handleCommandLineArguments(args);

    config().load();
    Locale.setDefault(new Locale(config().client().getCountry(), config().client().getLanguage()));

    gameLoop = new GameLoop("Main Update Loop", config().client().getMaxFps());
    loop().attach(physics());
    loop().attach(world());

    // setup default exception handling for render and update loop
    setUncaughtExceptionHandler(
        new DefaultUncaughtExceptionHandler(config().client().exitOnError()));

    screenManager = new ScreenManager();
    gameWindow = new GameWindow();

    // initialize  the game window
    window().init();
    world.setCamera(new Camera());

    for (GameListener listener : gameListeners) {
      listener.initialized(args);
    }

    if (!isInNoGUIMode()) {
      window().getRenderComponent().onRendered(g -> metrics().render(g));

      graphics()
          .addEntityRenderedListener(
              e -> DebugRenderer.renderEntityDebugInfo(e.getGraphics(), e.getEntity()));

      window().getRenderComponent().onFpsChanged(fps -> metrics().setFramesPerSecond(fps));
      window()
          .setIcons(
              Arrays.asList(
                  Resources.images().get("liti-logo-x16.png"),
                  Resources.images().get("liti-logo-x20.png"),
                  Resources.images().get("liti-logo-x32.png"),
                  Resources.images().get("liti-logo-x48.png")));

      Input.keyboard()
          .onKeyTyped(
              KeyEvent.VK_PRINTSCREEN,
              key -> {
                // don't take a screenshot if a modifier is active
                if (key.getModifiers() != 0) {
                  return;
                }

                window().getRenderComponent().takeScreenshot();
              });
    }

    Runtime.getRuntime().addShutdownHook(new Thread(Game::terminate, "Shutdown"));

    initialized = true;
}
}
```


Response Format:
Provide the answer in **XML format** as follows:

#### If the method **cannot** return `null` at the specific call site:
```xml
<response>
  <reason><![CDATA[EXPLAIN WHY THE INVOCATION Game.loop() RESULT CANNOT BE NULL.]]></reason>
  <value>NO</value>
</response>

#### If the method can return null at the specific call site:
<response>
  <reason><![CDATA[EXPLAIN WHY THE INVOCATION Game.loop() RESULT CAN BE NULL.]]></reason>
  <value>YES</value>
</response>

#### If you are unsure or If there are any methods that directly or indirectly affect the return value and are not fully disclosed, request their declarations first, in the following format:
<response>
  <reason><![CDATA[EXPLAIN WHY THIS METHOD DECLARATION IS NECESSARY AND WHY YOU CANNOT MAKE A CONFIDENT DECISION WITHOUT IT]]></reason>
  <success>false</success>
  <methods>
    <method>methodName</method>
  </methods>
</response>

Additional Notes:
Be precise in your reasoning.
If a method’s return value depends on another method not provided, request its declaration before making a conclusion.
If the method can return null in this case but not in others, explain why it happens specifically for this call.

---ChatGPT.sendRequestToOpenAI---
Retrieving response from cache
---Response.<init>---
Creating Response:
```xml
<response>
  <reason><![CDATA[The method `Game.loop()` returns the static field `gameLoop`, which is initialized in the `Game.init(String... args)` method. In this method, a new `GameLoop` object is instantiated and assigned to `gameLoop`. Since `init()` must be called before `start()`, which is implied by the requirement of initializing the game, the `gameLoop` is guaranteed to be non-null during the lifetime of the game execution where `Game.loop()` is called. The absence of any code that could set `gameLoop` to null after its initialization ensures that `Game.loop()` cannot return null.]]></reason>
  <value>NO</value>
</response>
```
---Response.<init>---
Response created:
Disagreement: The method `Game.loop()` returns the static field `gameLoop`, which is initialized in the `Game.init(String... args)` method. In this method, a new `GameLoop` object is instantiated and assigned to `gameLoop`. Since `init()` must be called before `start()`, which is implied by the requirement of initializing the game, the `gameLoop` is guaranteed to be non-null during the lifetime of the game execution where `Game.loop()` is called. The absence of any code that could set `gameLoop` to null after its initialization ensures that `Game.loop()` cannot return null.
---AdvancedNullAwayCodeFix.resolveMethodDereferenceError---
Method is not returning nullable on call site. Injecting suppression annotation.
---AdvancedNullAwayCodeFix.constructCastToNonnullChange---
Constructing cast to nonnull change for reason: The method `Game.loop()` returns the static field `gameLoop`, which is initialized in the `Game.init(String... args)` method. In this method, a new `GameLoop` object is instantiated and assigned to `gameLoop`. Since `init()` must be called before `start()`, which is implied by the requirement of initializing the game, the `gameLoop` is guaranteed to be non-null during the lifetime of the game execution where `Game.loop()` is called. The absence of any code that could set `gameLoop` to null after its initialization ensures that `Game.loop()` cannot return null.
---ChatGPT.ask---
Asking ChatGPT:
For the reason you mentioned earlier:

"The method `Game.loop()` returns the static field `gameLoop`, which is initialized in the `Game.init(String... args)` method. In this method, a new `GameLoop` object is instantiated and assigned to `gameLoop`. Since `init()` must be called before `start()`, which is implied by the requirement of initializing the game, the `gameLoop` is guaranteed to be non-null during the lifetime of the game execution where `Game.loop()` is called. The absence of any code that could set `gameLoop` to null after its initialization ensures that `Game.loop()` cannot return null."

in the method below, the expression Game.loop() is not nullable at the point it is used.

```java
@Override
          public void windowLostFocus(WindowEvent e) {
            if (Game.config().graphics().reduceFramesWhenNotFocused()) {
              Game.loop().setTickRate(NONE_FOCUS_MAX_FPS);
            }
}
```
Please Summarize the reason in max 5 words and rewrite the method so that at the line "              Game.loop().setTickRate(NONE_FOCUS_MAX_FPS);", at the occurrence of: "Game.loop()" is replaced with `NullabilityUtil.castToNonnull(Game.loop(), summary of reason)`
Replace "REASON" with the exact reason summary I provide to you (maximum 5 words), not with a generic explanation like "checked to be nonnull".
see the example below, for expression `foo.getBar()`, to wrap it with `NullabilityUtil.castToNonnull(foo.getBar(), "reason")`.

```java
public t(){
    String l = foo.getBar();
}
```

will be:
```java
public t(){
    String l = NullabilityUtil.castToNonnull(foo.getBar(), "checked to be nonnull");
}
```

### Instructions:

Do not import any additional classes.

Do not add Java comments.

Only modify relevant lines as required.

Return only the modified method wrapped in the XML format shown below.

Place the Java code inside the <code> tag using a CDATA block with ```java formatting.

Just give me the fixed code snippet in XML format in <response> tag like the example below. I will apply the fix to my codebase. Do not import any additional libraries or classes or add java comments. If you can provide the fixed code snippet, please provide it in the following format and place the code snippet in the <code> tag within ```java block.
<response>
  <success>true</success>
  <code><![CDATA[
  ```java
  Your fixed code snippet here
  ```
    ]]>
  </code>
</response>

---ChatGPT.sendRequestToOpenAI---
Retrieving response from cache
---Response.<init>---
Creating Response:
```xml
<response>
  <success>true</success>
  <code><![CDATA[
  ```java
@Override
          public void windowLostFocus(WindowEvent e) {
            if (Game.config().graphics().reduceFramesWhenNotFocused()) {
              NullabilityUtil.castToNonnull(Game.loop(), "cannot return null").setTickRate(NONE_FOCUS_MAX_FPS);
            }
}
  ```
    ]]>
  </code>
</response>
```
---Response.<init>---
Response created:
@Override
          public void windowLostFocus(WindowEvent e) {
            if (Game.config().graphics().reduceFramesWhenNotFocused()) {
              NullabilityUtil.castToNonnull(Game.loop(), "cannot return null").setTickRate(NONE_FOCUS_MAX_FPS);
            }
}
---ChatGPT.fixDereferenceByAddingCastToNonnull---
Fixing the error by adding castToNonnull
---AdvancedNullAwayCodeFix.fixTriggeredErrorsForLocation---
Resolving unresolvable error for triggered error: Type='DEREFERENCE_NULLABLE', message='dereferenced expression Game.loop() is @Nullable'
/home/nima/Developer/nullness-benchmarks/litiengine/src/de/gurkenlabs/litiengine/environment/Environment.java:2285
        Game.loop().detach((IUpdateable) entity);
---AdvancedNullAwayCodeFix.fix---
Fixing error: Type='DEREFERENCE_NULLABLE', message='dereferenced expression Game.loop() is @Nullable'
/home/nima/Developer/nullness-benchmarks/litiengine/src/de/gurkenlabs/litiengine/environment/Environment.java:2285
        Game.loop().detach((IUpdateable) entity);
---AdvancedNullAwayCodeFix.resolveDereferenceError---
Resolving dereference error: Type='DEREFERENCE_NULLABLE', message='dereferenced expression Game.loop() is @Nullable'
/home/nima/Developer/nullness-benchmarks/litiengine/src/de/gurkenlabs/litiengine/environment/Environment.java:2285
        Game.loop().detach((IUpdateable) entity);
---AdvancedNullAwayCodeFix.resolveDereferenceError---
Checking nullability possibility at error point
---ChatGPT.checkNullabilityPossibilityAtErrorPoint---
Asking if the expression can be null at error point point
---ChatGPT.ask---
Asking ChatGPT:
In the method below, is there a possibility that the expression "Game.loop()" at line "Game.loop().detach((IUpdateable) entity);" is null?
private static void dispose(final Collection<? extends IEntity> entities) {
    for (final IEntity entity : entities) {
      if (entity instanceof IUpdateable) {
        Game.loop().detach((IUpdateable) entity);
      }

      entity.detachControllers();
    }
}
Give a single-word answer in XML format. If it is possible for the expression to be null, respond with:
```xml
<response>
    <reason><![CDATA[YOUR REASON]]></reason>
    <value>YES</value>
</response>
```
If it is not possible for the expression to be null, respond with:
```xml
<response>
    <reason><![CDATA[YOUR REASON]]></reason>
    <value>NO</value>
</response>
```
If you are unsure or need more information, respond with where you can ask for more details or what specific information you need.

If additional information is required, list each request inside a `<request>` tag. If no additional information is needed, omit the `<requests>` section.

Respond with:
```xml
<response>
    <reason><![CDATA[YOUR REASON]]></reason>
    <value>UNKNOWN</value>
    <!-- Include <requests> only if additional information is needed -->
    <requests>
        <request><![CDATA[YOUR REQUEST 1]]></request>
        <request><![CDATA[YOUR REQUEST 2]]></request>
    </requests>
</response>
```
---ChatGPT.sendRequestToOpenAI---
Retrieving response from cache
---Response.<init>---
Creating Response:
```xml
<response>
    <reason><![CDATA[Without further context about the implementation of the static method Game.loop(), it cannot be determined definitively whether it returns an object that is always non-null. This depends on how Game.loop() is implemented and if there are instances where it can return null.]]></reason>
    <value>UNKNOWN</value>
    <requests>
        <request><![CDATA[Please provide the implementation details of the Game.loop() method.]]></request>
        <request><![CDATA[Please provide information about any conditions under which Game.loop() might return null.]]></request>
    </requests>
</response>
```
---Response.<init>---
Response created:
Unknown: Without further context about the implementation of the static method Game.loop(), it cannot be determined definitively whether it returns an object that is always non-null. This depends on how Game.loop() is implemented and if there are instances where it can return null.
---AdvancedNullAwayCodeFix.resolveMethodDereferenceError---
Resolving method dereference error.
---AdvancedNullAwayCodeFix.resolveMethodDereferenceError---
Method is in annotated package. Checking if the method is returning nullable.
---AdvancedNullAwayCodeFix.investigateMethodReturnNullability---
Checking if the method is returning nullable.
---ChatGPT.checkIfMethodIsReturningNullable---
Asking if the method is returning nullable: loop()
---ChatGPT.ask---
Asking ChatGPT:
In the method below, is there a possibility that the method returns null based only on its body? Consider the following points:

- The method may have multiple return paths; consider all return statements.
- If the method calls another method, do not assume its return value unless its full declaration is provided. Request its declaration if needed.
- The method may throw an exception instead of returning null. An exception path should not be considered a null return.
- Ensure you request the declarations of any methods whose return values directly or indirectly impact this method’s return value before making a conclusion.
- Carefully analyze all conditions and prior operations that may guarantee a non-null return value.

@Nullable public static IGameLoop loop() {
    return gameLoop;
}

Here are the method definitions in addition to the method inquired:

Depth: 0
```java
class de.gurkenlabs.litiengine.Game {
@Nullable public static IGameLoop loop() {
    return gameLoop;
}
}
```


Response Format:
Provide the answer in **XML format** as follows:

#### If the method **cannot** return `null`:
```xml
<response>
  <reason><![CDATA[EXPLAIN WHY THE METHOD CANNOT RETURN NULL]]></reason>
  <value>NO</value>
</response>
```

#### If the method can return null:
```xml
<response>
  <reason><![CDATA[EXPLAIN WHY THE METHOD CAN RETURN NULL]]></reason>
  <value>YES</value>
</response>
```

#### If you are unsure or need more information, respond with where you can ask for more details or what specific information you need.

#### If you are unsure or If there are any methods that directly or indirectly affect the return value and are not fully disclosed, request their declarations first, in the following format:
<response>
  <reason><![CDATA[YOUR REASON]]></reason>
  <value>UNKNOWN</value>
  <methods>
    <method>methodName</method>
  </methods>
</response>

If additional information is required other than method declaration, list each request inside a `<request>` tag. If no additional information is needed, omit the `<requests>` section.

Respond with:
```xml
<response>
    <reason><![CDATA[YOUR REASON]]></reason>
    <value>UNKNOWN</value>
    <!-- Include <requests> only if additional information is needed -->
    <requests>
        <request><![CDATA[YOUR REQUEST 1]]></request>
        <request><![CDATA[YOUR REQUEST 2]]></request>
    </requests>
</response>
```

Additional Notes:
Be precise in your reasoning.
If a method’s return value depends on another method not provided, request its declaration before making a conclusion.
If the method can return null in some cases but not others, explain under what conditions it can happen.

---ChatGPT.sendRequestToOpenAI---
Retrieving response from cache
---Response.<init>---
Creating Response:
```xml
<response>
  <reason><![CDATA[The method `loop` returns the variable `gameLoop`. Without the initialization or assignment details of `gameLoop`, it's unclear whether it can be null. The possibility of `gameLoop` being uninitialized or set to null elsewhere in the program means `loop` could potentially return null. Further information on `gameLoop` is required.]]></reason>
  <value>UNKNOWN</value>
  <requests>
    <request><![CDATA[Please provide the declaration and initialization of the variable `gameLoop` in the class `de.gurkenlabs.litiengine.Game`.]]></request>
  </requests>
</response>
```
---Response.<init>---
Response created:
Unknown: The method `loop` returns the variable `gameLoop`. Without the initialization or assignment details of `gameLoop`, it's unclear whether it can be null. The possibility of `gameLoop` being uninitialized or set to null elsewhere in the program means `loop` could potentially return null. Further information on `gameLoop` is required.
---AdvancedNullAwayCodeFix.investigateMethodReturnNullability---
Could not determine the nullability and model did not ask for any method.
---ChatGPT.checkIfMethodIsReturningNullableOnCallSite---
Asking if the method is returning nullable on the call site: Game.loop()
---ChatGPT.ask---
Asking ChatGPT:
In the method below, is there a possibility that the method returns null at the given call site?

```java
@Nullable public static IGameLoop loop() {
    return gameLoop;
}
```

## Guidelines:
- The method may have multiple return paths; consider all return statements.
- If the method calls another method, do not assume its return value unless its full declaration is provided. Request its declaration if needed.
- The method may throw an exception instead of returning null. An exception path should not be considered a null return.
- Ensure you request the declarations of any methods whose return values directly or indirectly impact this method’s return value before making a conclusion.
- If the method returns a value that is determined by a parameter, evaluate based on the actual argument at the given call site.
- Analyze based only on the specific invocation provided. Do not generalize to all possible inputs.- If the return value is guaranteed to be non-null at the call site, the answer should be a definitive NO.
- Do not generalize based on all possible inputs—your answer must be based only on the given invocation.
- Focus only on the given call site, not all possible invocations.

### call site:
Game.loop()

Here are the method definitions and the call chain for this method, showing the sequence of calls from the method to its callers at each depth level:

Depth: 0
```java
class de.gurkenlabs.litiengine.Game {
@Nullable public static IGameLoop loop() {
    return gameLoop;
}
}
```
Depth: 1
```java
class de.gurkenlabs.litiengine.environment.GameWorld {
public void loadEnvironment(@Nullable final Environment env) {
    Lock lock = Game.loop().getLock();
    lock.lock();
    try {
      unloadEnvironment();
      this.environment = env;
      if (env != null) {
        this.addEnvironment(env);

        if (env.getGravity() == 0 && this.gravity() != 0) {
          env.setGravity(this.gravity());
        }

        env.load();
        for (final EnvironmentLoadedListener listener : this.loadedListeners) {
          listener.loaded(env);
        }

        // call map specific listeners
        String mapName = getMapName(env);
        if (mapName != null && this.environmentLoadedListeners.containsKey(mapName)) {

          // for the default camera we center the camera on the environment
          if (this.camera().getClass().equals(Camera.class)) {
            camera().setFocus(env.getCenter());
          }

          for (EnvironmentLoadedListener listener : this.environmentLoadedListeners.get(mapName)) {
            listener.loaded(env);
          }
        }
      }
    } finally {
      lock.unlock();
    }
}public void setCamera(@Nullable final ICamera cam) {
    if (this.camera() != null) {
      Game.loop().detach(camera);
    }

    camera = cam;

    if (cam != null && !Game.isInNoGUIMode()) {
      Game.loop().attach(cam);
      cam.updateFocus();
    }
}
}
```
```java
class de.gurkenlabs.litiengine.entities.behavior.EntityNavigator {
public EntityNavigator(final IMobileEntity entity, final PathFinder pathFinder) {
    this.cancelNavigationConditions = new CopyOnWriteArrayList<>();
    this.listeners = new CopyOnWriteArrayList<>();
    this.entity = entity;
    this.pathFinder = pathFinder;
    this.setAcceptableError(DEFAULT_ACCEPTABLE_ERROR);
    Game.loop().attach(this);
}
}
```
```java
class de.gurkenlabs.litiengine.GameWindow {
private static void initializeWindowEventListeners(Window window) {

    window.addWindowStateListener(
        e -> {
          if (e.getNewState() == Frame.ICONIFIED) {
            Game.loop().setTickRate(ICONIFIED_MAX_FPS);
          } else {
            Game.loop().setTickRate(Game.config().client().getMaxFps());
          }
        });

    window.addWindowFocusListener(
        new WindowFocusListener() {
          @Override
          public void windowLostFocus(WindowEvent e) {
            if (Game.config().graphics().reduceFramesWhenNotFocused()) {
              Game.loop().setTickRate(NONE_FOCUS_MAX_FPS);
            }
          }

          @Override
          public void windowGainedFocus(WindowEvent e) {
            Game.loop().setTickRate(Game.config().client().getMaxFps());
          }
        });

    window.addWindowListener(
        new WindowAdapter() {
          @Override
          public void windowClosing(final WindowEvent event) {
            Game.exit();
          }
        });
}
}
```
```java
class de.gurkenlabs.litiengine.gui.screens.ScreenManager {
public void display(@Nullable final Screen screen) {
    if (Game.hasStarted() && Game.time().since(this.lastScreenChange) < this.getChangeCooldown()) {
      log.log(
          Level.INFO,
          "Skipping displaying of screen {0} because screen changing is currently on cooldown.",
          screen != null ? screen.getName() : "");
      return;
    }

    final Screen previous = this.current();
    if (previous != null) {
      previous.suspend();
    }

    if (screen != null && !this.screens.contains(screen)) {
      this.screens.add(screen);
    }

    this.currentScreen = screen;
    if (!Game.isInNoGUIMode() && this.current() != null) {
      this.current().prepare();
    }

    this.lastScreenChange = Game.loop().getTicks();

    final ScreenChangedEvent event = new ScreenChangedEvent(this.current(), previous);
    for (final ScreenChangedListener listener : this.screenChangedListeners) {
      listener.changed(event);
    }
}
}
```
```java
class de.gurkenlabs.litiengine.abilities.effects.Effect {
@Override
  public void update() {

    for (final Iterator<EffectApplication> iterator = this.getActiveAppliances().iterator();
        iterator.hasNext(); ) {
      final EffectApplication appliance = iterator.next();
      // if the effect duration is reached
      if (this.hasEnded(appliance)) {

        iterator.remove();
        this.cease(appliance);
      }
    }

    // 4. unregister if all appliances are finished
    if (this.getActiveAppliances().isEmpty()) {
      Game.loop().detach(this);
    }
}public void apply(final Shape impactArea) {
    final List<ICombatEntity> affected = this.lookForAffectedEntities(impactArea);
    for (final ICombatEntity affectedEntity : affected) {
      this.apply(affectedEntity);
    }

    this.appliances.add(new EffectApplication(affected, impactArea));

    // if it is the first appliance -> register for update
    if (this.appliances.size() == 1) {
      Game.loop().attach(this);
    }
}
}
```
```java
class de.gurkenlabs.litiengine.GameTime {
public long toTicks(final int milliseconds) {
    return this.toTicks(milliseconds, Game.loop().getTickRate());
}public long since(final long tick) {
    return toMilliseconds(Game.loop().getTicks() - tick);
}public long now() {
    return Game.loop().getTicks();
}public long sinceGameStart() {
    return this.toMilliseconds(Game.loop().getTicks());
}@Override
  public void loaded(Environment environment) {
    environmentLoaded = Game.loop().getTicks();
}public long toMilliseconds(final long ticks) {
    return this.toMilliseconds(ticks, Game.loop().getTickRate());
}
}
```
```java
class de.gurkenlabs.litiengine.GameMetrics {
@Override
  public void render(final Graphics2D g) {
    this.updateMetrics();

    if (!Game.config().client().showGameMetrics()) {
      return;
    }

    this.currentOffsetY = 0;

    g.setColor(this.renderColor);

    // render client metrics
    this.drawTitle(g, "[client]");
    this.drawMetric(g, "fps       : " + this.getFramesPerSecond());
    this.drawMetric(g, "max fps   : " + this.maxFramesPerSecond);
    this.drawMetric(g, "updatables: " + Game.loop().getUpdatableCount());

    // render jvm metrics if debug is enabled
    if (Game.config().debug().isDebugEnabled()) {
      this.drawTitle(g, "[jvm]");
      this.drawMetric(g, "java      : " + this.javaVersion);
      this.drawMetric(g, "memory    : " + String.format("%-5.5s", this.usedMemory) + " MB");
      this.drawMetric(g, "threads   : " + Thread.activeCount());
    }

    // render rendering metrics
    if (!this.renderMetrics.isEmpty()) {
      this.drawTitle(g, "[update]");

      for (RenderMetrics metric : this.renderMetrics) {
        this.drawMetric(g, metric.toString());
      }

      this.renderMetrics.clear();
    }
}
}
```
```java
class de.gurkenlabs.litiengine.graphics.emitters.Emitter {
public void deactivate() {
    if (!this.activated) {
      return;
    }

    this.activated = false;
    this.getParticles().clear();
    this.aliveTime = 0;
    this.activationTick = 0;
    this.lastSpawn = 0;
    Game.loop().detach(this);
}public void activate() {
    if (this.activated) {
      return;
    }

    this.activated = true;
    this.activationTick = Game.time().now();
    Game.loop().attach(this);
}@Override
  public void update() {
    if (this.isPaused()) {
      return;
    }

    // clear particles if the effect time to life is reached
    if (this.isFinished()) {
      for (EmitterFinishedListener listener : this.finishedListeners) {
        listener.finished(this);
      }

      this.delete();
      return;
    }

    final float updateRatio = (float) this.data().getUpdateRate() / Game.loop().getTickRate();
    for (final Particle p : this.getParticles().stream().collect(Collectors.toList())) {
      if (this.particleCanBeRemoved(p)) {
        // remove dead particles
        this.particles.remove(p);
        continue;
      }

      p.update(this.getOrigin(), updateRatio);
    }

    this.aliveTime = Game.time().since(this.activationTick);
    if ((this.data().getSpawnRate() == 0
        || Game.time().since(this.lastSpawn) >= this.data().getSpawnRate())) {
      this.lastSpawn = Game.time().now();
      this.spawnParticle();
    }
}
}
```
```java
class de.gurkenlabs.litiengine.entities.behavior.IBehaviorController {
public default void attach() {
    Game.loop().attach(this);
}public default void detach() {
    Game.loop().detach(this);
}
}
```
```java
class de.gurkenlabs.litiengine.abilities.AbilityExecution {
AbilityExecution(final Ability ability) {
    this.appliedEffects = new CopyOnWriteArrayList<>();
    this.ability = ability;
    this.executionTicks = Game.time().now();
    this.impactArea = ability.calculateImpactArea();
    this.castLocation = ability.getExecutor().getCenter();
    Game.loop().attach(this);
}@Override
  public void update() {
    // if there a no effects to apply -> unregister this instance and we're done
    if (this.getAbility().getEffects().isEmpty()
        || this.getAbility().getEffects().size() == this.getAppliedEffects().size()) {
      Game.loop().detach(this);
      return;
    }

    // handle all effects from the ability that were not applied yet
    for (final Effect effect : this.getAbility().getEffects()) {
      // if the ability was not executed yet or the delay of the effect is not
      // yet reached
      if (this.getAppliedEffects().contains(effect)
          || Game.time().since(this.getExecutionTicks()) < effect.getDelay()) {
        continue;
      }

      effect.apply(this.getExecutionImpactArea());
      this.getAppliedEffects().add(effect);
    }
}
}
```
```java
class de.gurkenlabs.litiengine.GameWindow$3 {
@Override
          public void windowGainedFocus(WindowEvent e) {
            Game.loop().setTickRate(Game.config().client().getMaxFps());
}@Override
          public void windowLostFocus(WindowEvent e) {
            if (Game.config().graphics().reduceFramesWhenNotFocused()) {
              Game.loop().setTickRate(NONE_FOCUS_MAX_FPS);
            }
}
}
```
```java
class de.gurkenlabs.litiengine.environment.EntitySpawner {
protected void spawnNewEntities() {
    if (this.getSpawnMode() != SpawnMode.CUSTOMSPAWNPOINTS && this.getSpawnPoints().isEmpty()) {
      return;
    }

    switch (this.getSpawnMode()) {
      case ALLSPAWNPOINTS:
        for (int i = 0; i < this.getSpawnPoints().size(); i++) {
          final int index = i;
          Game.loop()
              .perform(
                  this.getSpawnDelay() + this.getSpawnDelay() * i,
                  () -> this.spawn(this.getSpawnPoints().get(index), this.getSpawnAmount()));
        }
        break;
      case ONERANDOMSPAWNPOINT:
        this.spawn(Game.random().choose(this.getSpawnPoints()), this.getSpawnAmount());
        break;
      case RANDOMSPAWNPOINTS:
        for (int i = 0; i < this.getSpawnAmount(); i++) {
          Game.loop()
              .perform(
                  this.getSpawnDelay() + this.getSpawnDelay() * i,
                  () -> this.spawn(Game.random().choose(this.getSpawnPoints()), 1));
        }
        break;
      case CUSTOMSPAWNPOINTS:
        List<Spawnpoint> spawnPoints =
            this.customSpawnpoints != null
                ? this.customSpawnpoints.apply(this)
                : this.getCustomSpawnpoints();

        int index = 0;
        for (Spawnpoint spawn : spawnPoints) {
          Game.loop()
              .perform(
                  this.getSpawnDelay() + this.getSpawnDelay() * index, () -> this.spawn(spawn, 1));
          index++;
        }
        break;
      default:
        break;
    }
}
}
```
```java
class de.gurkenlabs.litiengine.tweening.TweenEngine {
@Override
  public void start() {
    Game.loop().attach(this);
}@Override
  public void terminate() {
    Game.loop().detach(this);
}
}
```
```java
class de.gurkenlabs.litiengine.gui.SpeechBubble {
public void hide() {
    Game.world().environment().removeRenderable(this);
    Game.loop().detach(this);
    if (activeSpeechBubbles.get(this.getEntity()) != null
        && activeSpeechBubbles.remove(this.getEntity()).equals(this)) {
      activeSpeechBubbles.remove(this.getEntity());
    }

    for (SpeechBubbleListener listener : this.listeners) {
      listener.hidden();
    }
}private SpeechBubble(
      final IEntity entity,
      final String text,
      @Nullable SpeechBubbleAppearance appearance,
      @Nullable Font font) {
    if (appearance == null) {
      this.appearance = DEFAULT_APPEARANCE;
    } else {
      this.appearance = appearance;
    }

    final SpeechBubble active = activeSpeechBubbles.get(entity);
    if (active != null) {
      active.hide();
    }
    this.setFont(font);

    this.textBoxWidth = (float) (entity.getWidth() * 4);
    this.entity = entity;

    this.currentText = text;
    this.currentTextDisplayTime = DISPLAYTIME_MIN + text.length() * DISPLAYTIME_PER_LETTER;

    this.lastTextDisplay = Game.time().now();
    this.createBubbleImage();
    entity.getEnvironment().add(this, RenderType.UI);
    Game.loop().attach(this);
    activeSpeechBubbles.put(entity, this);
}
}
```
```java
class de.gurkenlabs.litiengine.entities.Prop {
private void updateAnimationController() {
    IEntityAnimationController<?> controller = this.createAnimationController();
    this.getControllers().addController(controller);
    if (Game.world().environment() != null && Game.world().environment().isLoaded()) {
      Game.loop().attach(controller);
    }
}
}
```
```java
class de.gurkenlabs.litiengine.graphics.FreeFlightCamera {
public FreeFlightCamera(final Point2D focus) {
    this.setFocus(focus);
    this.velocity = DEFAULT_SCROLL_PIXELS_PER_SECOND;
    this.scrollPadding = DEFAULT_SCROLL_PADDING;
    this.setClampToMap(true);

    Game.loop().attach(this);
}private void handleFreeFlightCamera() {
    if (Game.world().environment() == null || Game.world().environment().getMap() == null) {
      return;
    }

    final Point2D mouseLocation = Input.mouse().getLocation();

    final double scrollSpeed =
        this.getVelocity()
            / (double) Game.loop().getTickRate()
            * Game.config().input().getMouseSensitivity();

    double x = this.getFocus().getX();
    double y = this.getFocus().getY();

    double deltaX = 0;
    if (mouseLocation.getX() < this.getScrollPadding()) {
      deltaX -= scrollSpeed;
    } else if (Game.window().getResolution().getWidth() - mouseLocation.getX()
        < this.getScrollPadding()) {
      deltaX += scrollSpeed;
    }

    double deltaY = 0;
    if (mouseLocation.getY() < this.getScrollPadding()) {
      deltaY -= scrollSpeed;
    } else if (Game.window().getResolution().getHeight() - mouseLocation.getY()
        < this.getScrollPadding()) {
      deltaY += scrollSpeed;
    }

    x += deltaX;
    y += deltaY;

    this.setFocus(new Point2D.Double(x, y));
}
}
```
```java
class de.gurkenlabs.litiengine.environment.Environment {
private static void dispose(final Collection<? extends IEntity> entities) {
    for (final IEntity entity : entities) {
      if (entity instanceof IUpdateable) {
        Game.loop().detach((IUpdateable) entity);
      }

      entity.detachControllers();
    }
}private static void loadUpdatableOrEmitterEntity(IEntity entity) {
    if (entity instanceof Emitter) {
      final Emitter emitter = (Emitter) entity;
      if (emitter.isActivateOnInit()) {
        emitter.activate();
      }
    } else if (entity instanceof IUpdateable) {
      Game.loop().attach((IUpdateable) entity);
    }
}private void unload(final IEntity entity) {
    // 1. remove from physics engine
    if (entity instanceof ICollisionEntity) {
      Game.physics().remove((ICollisionEntity) entity);
    }

    // 2. unregister from update
    if (entity instanceof IUpdateable) {
      Game.loop().detach((IUpdateable) entity);
    }

    if (entity instanceof IMobileEntity) {
      this.removeGravity((IMobileEntity) entity);
    }

    // 3. detach all controllers
    entity.detachControllers();

    if (entity instanceof Emitter) {
      Emitter em = (Emitter) entity;
      em.deactivate();
    }

    if (this.loaded && (entity instanceof LightSource || entity instanceof StaticShadow)) {
      this.updateLighting(entity);
    }

    entity.removed(this);
}
}
```
```java
class de.gurkenlabs.litiengine.graphics.animation.Animation {
@Override
  public void update() {
    // do nothing if the animation is not playing or the current keyframe is not finished
    if (!this.isPlaying()
        || Game.time().since(this.lastFrameUpdate) < this.getCurrentKeyFrame().getDuration()) {
      return;
    }

    // if we are not looping and the last keyframe is finished, we terminate the animation
    if (!this.isLooping() && this.isLastKeyFrame()) {
      this.terminate();
      return;
    }

    // make sure, we stay inside the keyframe list
    final int newFrameIndex =
        (this.getKeyframes().indexOf(this.currentFrame) + 1) % this.getKeyframes().size();
    final KeyFrame previousFrame = this.currentFrame;
    this.currentFrame = this.getKeyframes().get(newFrameIndex);

    for (KeyFrameListener listener : this.listeners) {
      listener.currentFrameChanged(previousFrame, this.currentFrame);
    }

    this.lastFrameUpdate = Game.loop().getTicks();
}public void restart() {
    this.currentFrame = this.firstFrame;
    this.lastFrameUpdate = Game.loop().getTicks();
}
}
```
```java
class de.gurkenlabs.litiengine.physics.MovementController {
@Override
  public void attach() {
    Game.loop().attach(this);
}private void handleForces() {
    // clean up forces
    this.activeForces.forEach(
        x -> {
          if (x.hasEnded()) {
            this.activeForces.remove(x);
          }
        });

    if (this.activeForces.isEmpty()) {
      return;
    }

    // disable turn-on-move for force handling
    boolean turn = this.getEntity().turnOnMove();
    this.getEntity().setTurnOnMove(false);
    try {
      double deltaX = 0;
      double deltaY = 0;
      for (final Force force : this.activeForces) {
        if (force.cancelOnReached() && force.hasReached(this.getEntity())) {
          force.end();
          continue;
        }

        final Point2D collisionBoxCenter = this.getEntity().getCollisionBoxCenter();
        final double angle =
            GeometricUtilities.calcRotationAngleInDegrees(collisionBoxCenter, force.getLocation());
        final double strength =
            Game.loop().getDeltaTime() * 0.001f * force.getStrength() * Game.loop().getTimeScale();
        deltaX += GeometricUtilities.getDeltaX(angle, strength);
        deltaY += GeometricUtilities.getDeltaY(angle, strength);
      }

      final Point2D target =
          new Point2D.Double(this.getEntity().getX() + deltaX, this.getEntity().getY() + deltaY);
      final boolean success = Game.physics().move(this.getEntity(), target);
      if (!success) {
        for (final Force force : this.activeForces) {
          if (force.cancelOnCollision()) {
            force.end();
          }
        }
      }
    } finally {
      this.getEntity().setTurnOnMove(turn);
    }
}@Override
  public void detach() {
    Game.loop().detach(this);
}public void handleMovement() {
    if (!this.isMovementAllowed()) {
      this.velocity = 0;
      return;
    }

    // max distance an entity can travel within one tick
    final double maxPixelsPerTick = this.getEntity().getTickVelocity();
    final double deltaTime = Game.loop().getDeltaTime() * Game.loop().getTimeScale();

    final double acceleration =
        this.getEntity().getAcceleration() == 0
            ? maxPixelsPerTick
            : deltaTime / this.getEntity().getAcceleration() * maxPixelsPerTick;
    final double deceleration =
        this.getEntity().getDeceleration() == 0
            ? this.getVelocity()
            : deltaTime / this.getEntity().getDeceleration() * maxPixelsPerTick;

    double dx = this.getDx();
    double dy = this.getDy();
    this.setDx(0);
    this.setDy(0);

    final double deltaVelocity =
        Math.min(Math.sqrt(Math.pow(dx, 2) + Math.pow(dy, 2)), acceleration);
    if (deltaVelocity != 0) {
      double newVelocity = this.getVelocity() + deltaVelocity;
      this.setVelocity(newVelocity);
    } else {
      final double newVelocity = Math.max(0, this.getVelocity() - deceleration);
      this.setVelocity(newVelocity);
      dx = GeometricUtilities.getDeltaX(this.moveAngle);
      dy = GeometricUtilities.getDeltaY(this.moveAngle);
    }

    if (this.getVelocity() == 0) {
      this.moveAngle = 0;
      return;
    }

    // actually move entity
    this.moveEntity(dx, dy);
}
}
```
```java
class de.gurkenlabs.litiengine.graphics.animation.AnimationController {
public void detach() {
    Game.loop().detach(this);
}public void attach() {
    Game.loop().attach(this);
}
}
```
```java
class de.gurkenlabs.litiengine.graphics.Camera {
@Override
  public void setZoom(final float targetZoom, final int delay) {
    if (delay == 0) {

      this.zoom = targetZoom;
      this.targetZoom = 0;
      this.zoomDelay = 0;
      this.zoomTick = 0;
      this.zoomStep = 0;

      final ZoomChangedEvent event = new ZoomChangedEvent(this, targetZoom);
      for (final ZoomChangedListener listener : this.zoomListeners) {
        listener.zoomChanged(event);
      }
    } else {
      this.zoomTick = Game.time().now();
      this.targetZoom = targetZoom;
      this.zoomDelay = delay;

      final double tickduration = 1000 / (double) Game.loop().getTickRate();
      final double tickAmount = delay / tickduration;
      final float totalDelta = this.targetZoom - this.zoom;
      this.zoomStep = tickAmount > 0 ? (float) (totalDelta / tickAmount) : totalDelta;
    }
}
}
```
```java
class de.gurkenlabs.litiengine.Game {
public static synchronized void init(String... args) {
    if (initialized) {
      log().log(Level.INFO, "The game has already been initialized.");
      return;
    }

    log.init();
    handleCommandLineArguments(args);

    config().load();
    Locale.setDefault(new Locale(config().client().getCountry(), config().client().getLanguage()));

    gameLoop = new GameLoop("Main Update Loop", config().client().getMaxFps());
    loop().attach(physics());
    loop().attach(world());

    // setup default exception handling for render and update loop
    setUncaughtExceptionHandler(
        new DefaultUncaughtExceptionHandler(config().client().exitOnError()));

    screenManager = new ScreenManager();
    gameWindow = new GameWindow();

    // initialize  the game window
    window().init();
    world.setCamera(new Camera());

    for (GameListener listener : gameListeners) {
      listener.initialized(args);
    }

    if (!isInNoGUIMode()) {
      window().getRenderComponent().onRendered(g -> metrics().render(g));

      graphics()
          .addEntityRenderedListener(
              e -> DebugRenderer.renderEntityDebugInfo(e.getGraphics(), e.getEntity()));

      window().getRenderComponent().onFpsChanged(fps -> metrics().setFramesPerSecond(fps));
      window()
          .setIcons(
              Arrays.asList(
                  Resources.images().get("liti-logo-x16.png"),
                  Resources.images().get("liti-logo-x20.png"),
                  Resources.images().get("liti-logo-x32.png"),
                  Resources.images().get("liti-logo-x48.png")));

      Input.keyboard()
          .onKeyTyped(
              KeyEvent.VK_PRINTSCREEN,
              key -> {
                // don't take a screenshot if a modifier is active
                if (key.getModifiers() != 0) {
                  return;
                }

                window().getRenderComponent().takeScreenshot();
              });
    }

    Runtime.getRuntime().addShutdownHook(new Thread(Game::terminate, "Shutdown"));

    initialized = true;
}
}
```
```java
class de.gurkenlabs.litiengine.entities.Creature {
protected void updateAnimationController() {
    IEntityAnimationController<?> controller = this.createAnimationController();
    this.getControllers().addController(controller);
    if (Game.world().environment() != null && Game.world().environment().isLoaded()) {
      Game.loop().attach(controller);
    }
}@Override
  public float getTickVelocity() {
    // pixels per ms multiplied by the passed ms
    // ensure that entities don't travel too far in case of lag
    return Math.min(Game.loop().getDeltaTime(), GameLoop.TICK_DELTATIME_LAG)
        * 0.001F
        * this.getVelocity().get()
        * Game.loop().getTimeScale();
}
}
```
Depth: 2
```java
class de.gurkenlabs.litiengine.environment.GameWorld {
public void clear() {
    this.unloadEnvironment();
    this.environments.clear();
    this.setCamera(null);
    Game.physics().clear();

    this.environmentListeners.clear();
    this.environmentLoadedListeners.clear();
    this.environmentUnloadedListeners.clear();

    this.listeners.clear();
    this.loadedListeners.clear();
    this.unloadedListeners.clear();
}@Nullable
  public Environment loadEnvironment(IMap map) {
    Environment env = this.getEnvironment(map);
    this.loadEnvironment(env);
    return env;
}@Nullable
  public Environment loadEnvironment(String mapName) {
    Environment env = this.getEnvironment(mapName);
    this.loadEnvironment(env);
    return env;
}
}
```
```java
class de.gurkenlabs.litiengine.GameWindow {
GameWindow() {
    this.hostControl = new JFrame();

    this.resolutionChangedListeners = new CopyOnWriteArrayList<>();

    this.renderCanvas = new RenderComponent(Game.config().graphics().getResolution());
    this.cursor = new MouseCursor();
    if (!Game.isInNoGUIMode()) {
      this.hostControl.setBackground(Color.BLACK);
      this.hostControl.add(this.renderCanvas);

      this.initializeEventListeners();

      this.hostControl.setTitle(Game.info().getTitle());
      this.hostControl.setDefaultCloseOperation(WindowConstants.DO_NOTHING_ON_CLOSE);
      initializeWindowEventListeners(this.hostControl);
    }
}
}
```
```java
class de.gurkenlabs.litiengine.GameTime {
public long sinceEnvironmentLoad() {
    return this.since(this.environmentLoaded);
}public long since(final long tick) {
    return toMilliseconds(Game.loop().getTicks() - tick);
}public long sinceGameStart() {
    return this.toMilliseconds(Game.loop().getTicks());
}
}
```
```java
class de.gurkenlabs.litiengine.abilities.effects.Effect {
protected void cease(final EffectApplication appliance) {
    // 1. cease the effect for all affected entities
    for (final ICombatEntity entity : appliance.getAffectedEntities()) {
      this.cease(entity);
    }

    // 2. apply follow up effects
    this.getFollowUpEffects().forEach(followUp -> followUp.apply(appliance.getImpactArea()));
}protected boolean hasEnded(final EffectApplication appliance) {
    final long effectDuration = Game.time().since(appliance.getAppliedTicks());
    return effectDuration > this.getDuration();
}
}
```
```java
class de.gurkenlabs.litiengine.abilities.effects.EffectApplication {
protected EffectApplication(final List<ICombatEntity> affectedEntities, final Shape impactArea) {
    this.applied = Game.time().now();
    this.affectedEntities = affectedEntities;
    this.impactArea = impactArea;
}
}
```
```java
class de.gurkenlabs.litiengine.entities.CombatEntity {
@Override
  public boolean wasHit(int timeSpan) {
    return Game.time().since(this.lastHit) < timeSpan;
}@Override
  public void hit(final int damage, @Nullable final Ability ability) {
    if (this.isDead()) {
      return;
    }

    if (!this.isIndestructible()) {
      this.getHitPoints().modifyBaseValue(new AttributeModifier<>(Modification.SUBTRACT, damage));
    }

    final EntityHitEvent event = new EntityHitEvent(this, ability, damage, this.isDead());

    for (final CombatEntityListener listener : this.listeners) {
      listener.hit(event);
    }

    for (final CombatEntityHitListener listener : this.hitListeners) {
      listener.hit(event);
    }

    if (this.isDead()) {
      this.fireDeathEvent();
      this.setCollision(false);
    }

    this.lastHit = Game.time().now();
}
}
```
```java
class de.gurkenlabs.litiengine.graphics.ImageEffect {
protected ImageEffect(final int ttl, final String name) {
    this.ttl = ttl;
    this.name = name;
    this.aliveTick = Game.time().now();
}@Override
  public long getAliveTime() {
    return Game.time().since(this.aliveTick);
}
}
```
```java
class de.gurkenlabs.litiengine.abilities.AbilityExecution {
AbilityExecution(final Ability ability) {
    this.appliedEffects = new CopyOnWriteArrayList<>();
    this.ability = ability;
    this.executionTicks = Game.time().now();
    this.impactArea = ability.calculateImpactArea();
    this.castLocation = ability.getExecutor().getCenter();
    Game.loop().attach(this);
}@Override
  public void update() {
    // if there a no effects to apply -> unregister this instance and we're done
    if (this.getAbility().getEffects().isEmpty()
        || this.getAbility().getEffects().size() == this.getAppliedEffects().size()) {
      Game.loop().detach(this);
      return;
    }

    // handle all effects from the ability that were not applied yet
    for (final Effect effect : this.getAbility().getEffects()) {
      // if the ability was not executed yet or the delay of the effect is not
      // yet reached
      if (this.getAppliedEffects().contains(effect)
          || Game.time().since(this.getExecutionTicks()) < effect.getDelay()) {
        continue;
      }

      effect.apply(this.getExecutionImpactArea());
      this.getAppliedEffects().add(effect);
    }
}
}
```
```java
class de.gurkenlabs.litiengine.tweening.TweenEngine {
@Override
  public void update() {
    for (final Tweenable target : this.getTweens().keySet()) {
      for (final Tween tween : this.getTweens().get(target).values()) {
        if (tween.hasStopped()) {
          continue;
        }
        final long elapsed = Game.time().since(tween.getStartTime());
        if (elapsed >= tween.getDuration()) {
          tween.stop();
          continue;
        }
        final float[] currentValues = new float[tween.getTargetValues().length];
        for (int i = 0; i < tween.getTargetValues().length; i++) {
          currentValues[i] =
              tween.getStartValues()[i]
                  + tween.getEquation().compute(elapsed / (float) tween.getDuration())
                      * (tween.getTargetValues()[i] - tween.getStartValues()[i]);
        }
        tween.getTarget().setTweenValues(tween.getType(), currentValues);
      }
    }
}
}
```
```java
class de.gurkenlabs.litiengine.gui.SpeechBubble {
public static SpeechBubble create(
      final IEntity entity, final String text, SpeechBubbleAppearance appearance, Font font) {
    return new SpeechBubble(entity, text, appearance, font);
}public static SpeechBubble create(final IEntity entity, final Font font, final String text) {
    SpeechBubbleAppearance app =
        new SpeechBubbleAppearance(
            DEFAULT_APPEARANCE.getForeColor(),
            DEFAULT_APPEARANCE.getBackgroundColor1(),
            DEFAULT_APPEARANCE.getBorderColor(),
            DEFAULT_APPEARANCE.getPadding());
    return new SpeechBubble(entity, text, app, font);
}public static SpeechBubble create(final IEntity entity, final String text) {
    return new SpeechBubble(entity, text, null, GuiProperties.getDefaultFont());
}@Override
  public void update() {
    if (this.currentText == null) {
      this.hide();
      return;
    }

    this.entityCenter = Game.world().camera().getViewportLocation(this.getEntity().getCenter());

    // old text was displayed long enough
    if (this.lastTextDisplay != 0
        && Game.time().since(this.lastTextDisplay) > this.currentTextDisplayTime) {
      this.currentText = null;
      this.lastTextDisplay = 0;
      return;
    }

    // display new text
    if (this.textIndex < this.currentText.length()
        && Game.time().since(this.lastCharPoll) > LETTER_WRITE_DELAY) {
      this.textIndex++;
      this.lastCharPoll = Game.time().now();
      if (this.typeSound != null) {
        Game.audio().playSound(this.typeSound, this.getEntity());
      }
    }

    // continue displaying currently displayed text
}private SpeechBubble(
      final IEntity entity,
      final String text,
      final Sound typeSound,
      SpeechBubbleAppearance appearance,
      Font font) {
    this(entity, text, appearance, font);
    this.typeSound = typeSound;
}private SpeechBubble(
      final IEntity entity,
      final String text,
      @Nullable SpeechBubbleAppearance appearance,
      @Nullable Font font) {
    if (appearance == null) {
      this.appearance = DEFAULT_APPEARANCE;
    } else {
      this.appearance = appearance;
    }

    final SpeechBubble active = activeSpeechBubbles.get(entity);
    if (active != null) {
      active.hide();
    }
    this.setFont(font);

    this.textBoxWidth = (float) (entity.getWidth() * 4);
    this.entity = entity;

    this.currentText = text;
    this.currentTextDisplayTime = DISPLAYTIME_MIN + text.length() * DISPLAYTIME_PER_LETTER;

    this.lastTextDisplay = Game.time().now();
    this.createBubbleImage();
    entity.getEnvironment().add(this, RenderType.UI);
    Game.loop().attach(this);
    activeSpeechBubbles.put(entity, this);
}
}
```
```java
class de.gurkenlabs.litiengine.gui.TextFieldComponent {
@Override
  public void render(final Graphics2D g) {
    super.render(g);
    g.setFont(this.getFont());
    final FontMetrics fm = g.getFontMetrics();

    if (this.isSelected() && Game.time().since(this.lastToggled) > this.flickerDelay) {
      this.cursorVisible = !this.cursorVisible;
      this.lastToggled = Game.time().now();
    }
    if (this.isSelected() && this.cursorVisible) {
      final Rectangle2D cursor =
          new Rectangle2D.Double(
              this.getX() + this.getTextX() + fm.stringWidth(this.getTextToRender(g)),
              this.getY() + this.getTextY(),
              this.getFont().getSize2D() * 3 / 5,
              this.getFont().getSize2D() * 1 / 5);
      g.setColor(this.getAppearance().getForeColor());
      g.fill(cursor);
    }
}
}
```
```java
class de.gurkenlabs.litiengine.entities.Prop {
public Prop(
      final Point2D location, @Nullable final String spritesheetName, final Material material) {
    super();
    this.rotation = Rotation.NONE;
    this.spritesheetName = spritesheetName;
    this.material = material;
    this.setLocation(location);
    this.updateAnimationController();
}public void setSpritesheetName(@Nullable final String spriteName) {
    this.spritesheetName = spriteName;
    this.updateAnimationController();
}
}
```
```java
class de.gurkenlabs.litiengine.tweening.Tween {
public Tween begin() {
    this.started = Game.time().now();
    this.stopped = false;
    return this;
}
}
```
```java
class de.gurkenlabs.litiengine.graphics.emitters.particles.Particle {
public void update(final Point2D emitterOrigin, final float updateRatio) {
    if (this.aliveTick == 0) {
      this.aliveTick = Game.time().now();
    }

    this.aliveTime = Game.time().since(this.aliveTick);
    if (this.timeToLiveReached()) {
      return;
    }

    if (this.colliding) {
      return;
    }

    if (this.getDeltaWidth() != 0) {
      this.width += this.getDeltaWidth() * updateRatio;
    }

    if (this.getDeltaHeight() != 0) {
      this.height += this.getDeltaHeight() * updateRatio;
    }

    if (this.getDeltaAngle() != 0) {
      this.angle += this.getDeltaAngle() * updateRatio;
    }

    // test for ray cast collision
    final float targetX = this.x + this.getVelocityX() * updateRatio;
    final float targetY = this.y + this.getVelocityY() * updateRatio;

    if (targetX == this.x && targetY == this.y) {
      return;
    }

    if (this.checkForCollision(emitterOrigin, targetX, targetY)) {
      return;
    }

    if (this.getVelocityX() != 0) {
      this.x = targetX;
    }

    if (this.getVelocityY() != 0) {
      this.y = targetY;
    }

    if (this.getAccelerationX() != 0) {
      this.velocityX += this.getAccelerationX() * updateRatio;
    }

    if (this.getAccelerationY() != 0) {
      this.velocityY += this.getAccelerationY() * updateRatio;
    }
}
}
```
```java
class de.gurkenlabs.litiengine.graphics.animation.Animation {
@Override
  public void start() {
    this.playing = true;
    if (this.getKeyframes().isEmpty()) {
      return;
    }

    this.restart();
}@Override
  public void update() {
    // do nothing if the animation is not playing or the current keyframe is not finished
    if (!this.isPlaying()
        || Game.time().since(this.lastFrameUpdate) < this.getCurrentKeyFrame().getDuration()) {
      return;
    }

    // if we are not looping and the last keyframe is finished, we terminate the animation
    if (!this.isLooping() && this.isLastKeyFrame()) {
      this.terminate();
      return;
    }

    // make sure, we stay inside the keyframe list
    final int newFrameIndex =
        (this.getKeyframes().indexOf(this.currentFrame) + 1) % this.getKeyframes().size();
    final KeyFrame previousFrame = this.currentFrame;
    this.currentFrame = this.getKeyframes().get(newFrameIndex);

    for (KeyFrameListener listener : this.listeners) {
      listener.currentFrameChanged(previousFrame, this.currentFrame);
    }

    this.lastFrameUpdate = Game.loop().getTicks();
}
}
```
```java
class de.gurkenlabs.litiengine.graphics.animation.AnimationController {
@Override
  public void update() {
    for (final Animation animation : this.getAll()) {
      animation.update();
    }

    if (this.getCurrent() != null && this.getCurrent().isPaused()) {
      return;
    }

    final boolean playbackFinished = this.getCurrent() != null && !this.getCurrent().isPlaying();
    if (playbackFinished) {
      for (final AnimationListener listener : this.listeners) {
        listener.finished(this.getCurrent());
      }
    }

    if (this.getCurrent() == null || playbackFinished) {
      if (this.getDefault() != null) {
        this.play(this.getDefault().getName());
      } else {
        this.currentAnimation = null;
      }
    }
}
}
```
```java
class de.gurkenlabs.litiengine.graphics.RenderComponent {
private void handleFade() {
    if (this.fadeOutStart != -1) {
      final long timePassed = Game.time().since(this.fadeOutStart);
      this.currentAlpha = MathUtilities.clamp(1 - timePassed / (float) this.fadeOutTime, 0, 1);
      if (this.currentAlpha == 0f) {
        this.fadeOutStart = -1;
        this.fadeOutTime = -1;
      }

      return;
    }

    if (this.fadeInStart != -1) {
      final long timePassed = Game.time().since(this.fadeInStart);
      this.currentAlpha = MathUtilities.clamp(timePassed / (float) this.fadeInTime, 0, 1);
      if (this.currentAlpha == 1f) {
        this.fadeInStart = -1;
        this.fadeInTime = -1;
        this.currentAlpha = Float.NaN;
      }
    }
}public void fadeOut(final int ms) {
    this.fadeInStart = -1;
    this.fadeInTime = -1;
    this.fadeOutStart = Game.time().now();
    this.fadeOutTime = ms;
}public void fadeIn(final int ms) {
    this.fadeOutStart = -1;
    this.fadeOutTime = -1;
    this.fadeInStart = Game.time().now();
    this.fadeInTime = ms;
}
}
```
```java
class de.gurkenlabs.litiengine.entities.Trigger {
private boolean activate(final IEntity activator, final int tar) {
    if (!this.isLoaded()
        || this.isOneTimeTrigger && this.isActivated
        || this.getActivationType() == TriggerActivation.COLLISION
            && activator != null
            && this.collisionActivated.contains(activator)) {
      return false;
    }

    if (this.getCooldown() > 0 && Game.time().since(this.lastActivation) < this.getCooldown()) {
      return false;
    }

    List<Integer> triggerTargets = this.getTargets(tar);

    final TriggerEvent te = new TriggerEvent(this, activator, triggerTargets);

    if (!this.checkActivationPredicates(te)) {
      return false;
    }

    this.isActivated = true;
    if (activator != null) {
      this.collisionActivated.add(activator);
    }

    // if we actually have a trigger target, we send the message to the target
    for (final int target : triggerTargets) {
      final IEntity entity = this.getEnvironment().get(target);
      if (entity == null) {
        log.log(
            Level.WARNING,
            "trigger [{0}] was activated, but the trigger target [{1}] could not be found on the environment",
            new Object[] {this, target});
        continue;
      }

      entity.sendMessage(this, this.message);
    }

    // also send the trigger event to all registered consumers
    for (final TriggerActivatedListener listener : this.activatedListeners) {
      listener.activated(te);
    }

    if (this.isOneTimeTrigger) {
      this.getEnvironment().remove(this);
    }

    this.lastActivation = Game.time().now();
    return true;
}
}
```
```java
class de.gurkenlabs.litiengine.graphics.Camera {
private boolean isShakeEffectActive() {
    return this.getShakeTick() != 0
        && Game.time().since(this.getShakeTick()) < this.getShakeDuration();
}@Override
  public void update() {
    if (Game.world().camera() != null && !Game.world().camera().equals(this)) {
      return;
    }

    if (this.targetZoom > 0) {
      if (Game.time().since(this.zoomTick) >= this.zoomDelay) {
        this.zoom = this.targetZoom;
        this.targetZoom = 0;
        this.zoomDelay = 0;
        this.zoomTick = 0;
        this.zoomStep = 0;
      } else {
        this.zoom += this.zoomStep;
      }

      final ZoomChangedEvent event = new ZoomChangedEvent(this, this.getZoom());
      for (final ZoomChangedListener listener : this.zoomListeners) {
        listener.zoomChanged(event);
      }
    }

    if (this.panTime > 0) {
      if (--this.panTime <= 0) {
        this.setFocus(this.targetFocus);
        this.targetFocus = null;
      } else {
        double diff = this.panTime / (this.panTime + 1.0);
        this.focus =
            new Point2D.Double(
                this.focus.getX() * diff + this.targetFocus.getX() * (1.0 - diff),
                this.focus.getY() * diff + this.targetFocus.getY() * (1.0 - diff));
      }
    }

    if (!this.isShakeEffectActive()) {
      this.shakeOffsetX = 0;
      this.shakeOffsetY = 0;
      return;
    }

    if (Game.time().since(this.lastShake) > this.shakeDelay) {
      this.shakeOffsetX = this.getShakeIntensity() * ThreadLocalRandom.current().nextGaussian();
      this.shakeOffsetY = this.getShakeIntensity() * ThreadLocalRandom.current().nextGaussian();
      this.lastShake = Game.time().now();
    }
}@Override
  public void setZoom(final float targetZoom, final int delay) {
    if (delay == 0) {

      this.zoom = targetZoom;
      this.targetZoom = 0;
      this.zoomDelay = 0;
      this.zoomTick = 0;
      this.zoomStep = 0;

      final ZoomChangedEvent event = new ZoomChangedEvent(this, targetZoom);
      for (final ZoomChangedListener listener : this.zoomListeners) {
        listener.zoomChanged(event);
      }
    } else {
      this.zoomTick = Game.time().now();
      this.targetZoom = targetZoom;
      this.zoomDelay = delay;

      final double tickduration = 1000 / (double) Game.loop().getTickRate();
      final double tickAmount = delay / tickduration;
      final float totalDelta = this.targetZoom - this.zoom;
      this.zoomStep = tickAmount > 0 ? (float) (totalDelta / tickAmount) : totalDelta;
    }
}@Override
  public void shake(final double intensity, final int delay, final int shakeDuration) {
    this.shakeTick = Game.time().now();
    this.shakeDelay = delay;
    this.shakeIntensity = intensity;
    this.shakeDuration = shakeDuration;
}
}
```
```java
class de.gurkenlabs.litiengine.entities.Creature {
public void setSpritesheetName(String spritesheetName) {
    if (this.spritesheetName != null && this.spritesheetName.equals(spritesheetName)) {
      return;
    }

    this.spritesheetName = spritesheetName;
    this.updateAnimationController();
}public boolean isIdle() {
    return Game.time().since(this.lastMoved) > IDLE_DELAY;
}@Override
  public void setLocation(final Point2D position) {
    if (this.isDead() || position == null) {
      return;
    }

    final Point2D oldLocation = this.getLocation();
    super.setLocation(position);

    if (Game.hasStarted() && this.isLoaded()) {
      this.lastMoved = Game.time().now();
      this.fireMovedEvent(
          new EntityMovedEvent(
              this, this.getX() - oldLocation.getX(), this.getY() - oldLocation.getY()));
    }
}
}
```
```java
class de.gurkenlabs.litiengine.gui.screens.ScreenManager {
public void display(final String screenName) {
    if (this.current() != null && this.current().getName().equalsIgnoreCase(screenName)) {
      log.log(
          Level.INFO,
          "Skipping displaying of screen {0} because it is already the current screen.",
          screenName);
      return;
    }

    if (this.screens.stream()
        .noneMatch(element -> element.getName().equalsIgnoreCase(screenName))) {
      log.log(
          Level.WARNING,
          "Could not display the screen {0} because there is no screen with the specified name.",
          screenName);
      return;
    }

    Screen screen = this.get(screenName);
    if (screen == null) {
      return;
    }

    this.display(screen);
}public void add(final Screen screen) {
    screen.setWidth(Game.window().getWidth());
    screen.setHeight(Game.window().getHeight());
    this.screens.add(screen);

    if (this.current() == null) {
      this.display(screen);
    }
}public void remove(Screen screen) {
    this.screens.remove(screen);
    if (this.current() == screen) {
      if (!this.screens.isEmpty()) {
        this.display(this.screens.get(0));
      } else {
        this.display((Screen) null);
      }
    }
}public void display(@Nullable final Screen screen) {
    if (Game.hasStarted() && Game.time().since(this.lastScreenChange) < this.getChangeCooldown()) {
      log.log(
          Level.INFO,
          "Skipping displaying of screen {0} because screen changing is currently on cooldown.",
          screen != null ? screen.getName() : "");
      return;
    }

    final Screen previous = this.current();
    if (previous != null) {
      previous.suspend();
    }

    if (screen != null && !this.screens.contains(screen)) {
      this.screens.add(screen);
    }

    this.currentScreen = screen;
    if (!Game.isInNoGUIMode() && this.current() != null) {
      this.current().prepare();
    }

    this.lastScreenChange = Game.loop().getTicks();

    final ScreenChangedEvent event = new ScreenChangedEvent(this.current(), previous);
    for (final ScreenChangedListener listener : this.screenChangedListeners) {
      listener.changed(event);
    }
}
}
```
```java
class de.gurkenlabs.litiengine.abilities.Ability {
public boolean isOnCooldown() {
    return (this.getCurrentExecution() != null
        && this.getCurrentExecution().getExecutionTicks() > 0
        && Game.time().since(this.getCurrentExecution().getExecutionTicks())
            < this.getAttributes().cooldown().get());
}public boolean isActive() {
    return this.getCurrentExecution() != null
        && Game.time().since(this.getCurrentExecution().getExecutionTicks())
            < this.getAttributes().duration().get();
}@Nullable
  public AbilityExecution cast() {
    if (!this.canCast()) {
      return null;
    }
    this.currentExecution = new AbilityExecution(this);

    for (final AbilityCastListener listener : this.abilityCastListeners) {
      listener.abilityCast(this.currentExecution);
    }

    return this.getCurrentExecution();
}public float getRemainingCooldownInSeconds() {
    if (this.getCurrentExecution() == null
        || this.getExecutor() == null
        || this.getExecutor().isDead()) {
      return 0;
    }

    // calculate cooldown in seconds
    return (float)
        (!this.canCast()
            ? (this.getAttributes().cooldown().get()
                    - Game.time().since(this.getCurrentExecution().getExecutionTicks()))
                * 0.001
            : 0);
}
}
```
```java
class de.gurkenlabs.litiengine.entities.EntityHitEvent {
EntityHitEvent(
      final ICombatEntity hitEntity,
      @Nullable final Ability ability,
      final int damage,
      final boolean kill) {
    super(hitEntity);
    this.executor = ability != null ? ability.getExecutor() : null;
    this.hitEntity = hitEntity;
    this.ability = ability;
    this.damage = damage;
    this.kill = kill;
    this.time = Game.time().now();
}
}
```
```java
class de.gurkenlabs.litiengine.graphics.emitters.Emitter {
public void delete() {
    this.deactivate();
    if (Game.world().environment() != null) {
      Game.world().environment().remove(this);
    }
}public void activate() {
    if (this.activated) {
      return;
    }

    this.activated = true;
    this.activationTick = Game.time().now();
    Game.loop().attach(this);
}@Override
  public void update() {
    if (this.isPaused()) {
      return;
    }

    // clear particles if the effect time to life is reached
    if (this.isFinished()) {
      for (EmitterFinishedListener listener : this.finishedListeners) {
        listener.finished(this);
      }

      this.delete();
      return;
    }

    final float updateRatio = (float) this.data().getUpdateRate() / Game.loop().getTickRate();
    for (final Particle p : this.getParticles().stream().collect(Collectors.toList())) {
      if (this.particleCanBeRemoved(p)) {
        // remove dead particles
        this.particles.remove(p);
        continue;
      }

      p.update(this.getOrigin(), updateRatio);
    }

    this.aliveTime = Game.time().since(this.activationTick);
    if ((this.data().getSpawnRate() == 0
        || Game.time().since(this.lastSpawn) >= this.data().getSpawnRate())) {
      this.lastSpawn = Game.time().now();
      this.spawnParticle();
    }
}
}
```
```java
class de.gurkenlabs.litiengine.GameLoop {
@Override
  public int perform(int delay, Runnable action) {
    final long d = Game.time().toTicks(delay);

    TimedAction a = new TimedAction(this.getTicks() + d, action);
    this.actions.add(a);

    return a.getId();
}
}
```
```java
class de.gurkenlabs.litiengine.environment.EntitySpawner {
protected boolean shouldSpawn() {
    return this.lastSpawnWave == 0
        || Game.time().since(this.lastSpawnWave) >= this.getSpawnInterval();
}@Override
  public void update() {
    if (!this.shouldSpawn()) {
      return;
    }

    this.spawnNewEntities();
    this.lastSpawnWave = Game.time().now();
}
}
```
```java
class de.gurkenlabs.litiengine.graphics.FreeFlightCamera {
@Override
  public void update() {
    this.handleFreeFlightCamera();
}public FreeFlightCamera(double x, double y) {
    this(new Point2D.Double(x, y));
}
}
```
```java
class de.gurkenlabs.litiengine.environment.Environment {
public void unload() {
    if (!this.loaded) {
      return;
    }

    // unregister all updatable entities from the current environment
    for (final IEntity entity : this.allEntities.values()) {
      this.unload(entity);
    }

    this.loaded = false;
    this.fireEvent(l -> l.unloaded(this));
}private static void loadUpdatableOrEmitterEntity(IEntity entity) {
    if (entity instanceof Emitter) {
      final Emitter emitter = (Emitter) entity;
      if (emitter.isActivateOnInit()) {
        emitter.activate();
      }
    } else if (entity instanceof IUpdateable) {
      Game.loop().attach((IUpdateable) entity);
    }
}public void clear() {
    Game.physics().clear();

    this.combatEntities.clear();
    this.mobileEntities.clear();
    this.gravityForces.clear();
    this.layerEntities.clear();
    this.entitiesByTag.clear();
    this.allEntities.clear();

    for (RenderType renderType : RenderType.values()) {
      this.miscEntities.get(renderType).clear();
      this.renderListeners.get(renderType).clear();
      this.renderables.get(renderType).clear();
    }

    dispose(this.allEntities.values());
    dispose(this.triggers);
    this.emitters.clear();
    this.colliders.clear();
    this.props.clear();
    this.creatures.clear();
    this.staticShadows.clear();
    this.combatEntities.clear();
    this.mobileEntities.clear();
    this.lightSources.clear();
    this.spawnPoints.clear();
    this.soundSources.clear();
    this.mapAreas.clear();
    this.triggers.clear();

    this.ambientLight = null;
    this.staticShadowLayer = null;

    for (Map<Integer, IEntity> type : this.miscEntities.values()) {
      type.clear();
    }

    this.initialized = false;

    this.fireEvent(l -> l.cleared(this));
}private void load(final IEntity entity) {
    // an entity can only exist on one environment at a time, so remove it from the current one
    if (entity.getEnvironment() != null) {
      entity.getEnvironment().remove(entity);
    }

    // 1. add to physics engine
    loadPhysicsEntity(entity);

    // 2. register for update or activate
    loadUpdatableOrEmitterEntity(entity);

    // 3. if a gravity is defined, add a gravity force to the entity
    if (entity instanceof IMobileEntity && this.getGravity() != 0) {
      this.addGravityForce((IMobileEntity) entity);
    }

    // 4. attach all controllers
    entity.attachControllers();

    if (this.loaded && (entity instanceof LightSource || entity instanceof StaticShadow)) {
      this.updateLighting(entity);
    }

    entity.loaded(this);
}private void unload(final IEntity entity) {
    // 1. remove from physics engine
    if (entity instanceof ICollisionEntity) {
      Game.physics().remove((ICollisionEntity) entity);
    }

    // 2. unregister from update
    if (entity instanceof IUpdateable) {
      Game.loop().detach((IUpdateable) entity);
    }

    if (entity instanceof IMobileEntity) {
      this.removeGravity((IMobileEntity) entity);
    }

    // 3. detach all controllers
    entity.detachControllers();

    if (entity instanceof Emitter) {
      Emitter em = (Emitter) entity;
      em.deactivate();
    }

    if (this.loaded && (entity instanceof LightSource || entity instanceof StaticShadow)) {
      this.updateLighting(entity);
    }

    entity.removed(this);
}public void remove(final IEntity entity) {
    if (entity == null) {
      return;
    }

    this.allEntities.remove(entity.getMapId());
    Iterator<List<IEntity>> iter = this.layerEntities.values().iterator();
    while (iter.hasNext()) {
      List<IEntity> layer = iter.next();
      if (layer.remove(entity) && layer.isEmpty()) {
        iter.remove();
      }
    }
    if (this.miscEntities.get(entity.getRenderType()) != null) {
      this.miscEntities.get(entity.getRenderType()).values().remove(entity);
    }

    for (String tag : entity.getTags()) {
      if (this.getEntitiesByTag().containsKey(tag)) {
        this.getEntitiesByTag().get(tag).remove(entity);

        if (this.getEntitiesByTag().get(tag).isEmpty()) {
          this.getEntitiesByTag().remove(tag);
        }
      }
    }

    if (entity instanceof Emitter) {
      Emitter emitter = (Emitter) entity;
      this.removeEmitter(emitter);
    }

    if (entity instanceof MapArea) {
      this.mapAreas.remove(entity);
    }

    if (entity instanceof Prop) {
      this.props.remove(entity);
    }

    if (entity instanceof Creature) {
      this.creatures.remove(entity);
    }

    if (entity instanceof CollisionBox) {
      this.colliders.remove(entity);
      this.staticShadows.removeIf(x -> x.getOrigin() != null && x.getOrigin().equals(entity));
    }

    if (entity instanceof LightSource) {
      this.lightSources.remove(entity);
      this.updateLighting(entity);
    }

    if (entity instanceof Trigger) {
      this.triggers.remove(entity);
    }

    if (entity instanceof Spawnpoint) {
      this.spawnPoints.remove(entity);
    }
    if (entity instanceof SoundSource) {
      this.soundSources.remove(entity);
    }

    if (entity instanceof StaticShadow) {
      this.staticShadows.remove(entity);
      this.updateLighting(entity);
    }

    if (entity instanceof IMobileEntity) {
      this.mobileEntities.values().remove(entity);
    }

    if (entity instanceof ICombatEntity) {
      this.combatEntities.values().remove(entity);
    }

    this.unload(entity);

    this.fireEntityEvent(l -> l.entityRemoved(entity));
}
}
```
```java
class de.gurkenlabs.litiengine.physics.MovementController {
@Override
  public void update() {
    this.handleForces();
    this.handleMovement();
}
}
```
```java
class de.gurkenlabs.litiengine.Game {
static synchronized void terminate() {
    if (!initialized) {
      return;
    }

    hasStarted = false;
    initialized = false;

    config().save();
    gameLoop.terminate();
    tweenEngine.terminate();
    soundEngine.terminate();

    world().clear();

    for (final GameListener listener : gameListeners) {
      try {
        listener.terminated();
      } catch (Exception e) {
        log().log(Level.WARNING, "game listener threw an exception during shutdown", e);
      }
    }

    gameLoop = null;
    screenManager = null;
    gameWindow = null;
}public static synchronized void start() {
    if (!initialized) {
      throw new IllegalStateException(
          "The game cannot be started without being first initialized. Call Game.init(...) before Game.start().");
    }

    gameLoop.start();
    tweenEngine.start();
    soundEngine.start();

    for (final GameListener listener : gameListeners) {
      listener.started();
    }

    hasStarted = true;
}public static synchronized void init(String... args) {
    if (initialized) {
      log().log(Level.INFO, "The game has already been initialized.");
      return;
    }

    log.init();
    handleCommandLineArguments(args);

    config().load();
    Locale.setDefault(new Locale(config().client().getCountry(), config().client().getLanguage()));

    gameLoop = new GameLoop("Main Update Loop", config().client().getMaxFps());
    loop().attach(physics());
    loop().attach(world());

    // setup default exception handling for render and update loop
    setUncaughtExceptionHandler(
        new DefaultUncaughtExceptionHandler(config().client().exitOnError()));

    screenManager = new ScreenManager();
    gameWindow = new GameWindow();

    // initialize  the game window
    window().init();
    world.setCamera(new Camera());

    for (GameListener listener : gameListeners) {
      listener.initialized(args);
    }

    if (!isInNoGUIMode()) {
      window().getRenderComponent().onRendered(g -> metrics().render(g));

      graphics()
          .addEntityRenderedListener(
              e -> DebugRenderer.renderEntityDebugInfo(e.getGraphics(), e.getEntity()));

      window().getRenderComponent().onFpsChanged(fps -> metrics().setFramesPerSecond(fps));
      window()
          .setIcons(
              Arrays.asList(
                  Resources.images().get("liti-logo-x16.png"),
                  Resources.images().get("liti-logo-x20.png"),
                  Resources.images().get("liti-logo-x32.png"),
                  Resources.images().get("liti-logo-x48.png")));

      Input.keyboard()
          .onKeyTyped(
              KeyEvent.VK_PRINTSCREEN,
              key -> {
                // don't take a screenshot if a modifier is active
                if (key.getModifiers() != 0) {
                  return;
                }

                window().getRenderComponent().takeScreenshot();
              });
    }

    Runtime.getRuntime().addShutdownHook(new Thread(Game::terminate, "Shutdown"));

    initialized = true;
}
}
```


Response Format:
Provide the answer in **XML format** as follows:

#### If the method **cannot** return `null` at the specific call site:
```xml
<response>
  <reason><![CDATA[EXPLAIN WHY THE INVOCATION Game.loop() RESULT CANNOT BE NULL.]]></reason>
  <value>NO</value>
</response>

#### If the method can return null at the specific call site:
<response>
  <reason><![CDATA[EXPLAIN WHY THE INVOCATION Game.loop() RESULT CAN BE NULL.]]></reason>
  <value>YES</value>
</response>

#### If you are unsure or If there are any methods that directly or indirectly affect the return value and are not fully disclosed, request their declarations first, in the following format:
<response>
  <reason><![CDATA[EXPLAIN WHY THIS METHOD DECLARATION IS NECESSARY AND WHY YOU CANNOT MAKE A CONFIDENT DECISION WITHOUT IT]]></reason>
  <success>false</success>
  <methods>
    <method>methodName</method>
  </methods>
</response>

Additional Notes:
Be precise in your reasoning.
If a method’s return value depends on another method not provided, request its declaration before making a conclusion.
If the method can return null in this case but not in others, explain why it happens specifically for this call.

---ChatGPT.sendRequestToOpenAI---
Retrieving response from cache
---Response.<init>---
Creating Response:
```xml
<response>
  <reason><![CDATA[The method `Game.loop()` returns the static field `gameLoop`, which is initialized in the `Game.init(String... args)` method. In this method, a new `GameLoop` object is instantiated and assigned to `gameLoop`. Since `init()` must be called before `start()`, which is implied by the requirement of initializing the game, the `gameLoop` is guaranteed to be non-null during the lifetime of the game execution where `Game.loop()` is called. The absence of any code that could set `gameLoop` to null after its initialization ensures that `Game.loop()` cannot return null.]]></reason>
  <value>NO</value>
</response>
```
---Response.<init>---
Response created:
Disagreement: The method `Game.loop()` returns the static field `gameLoop`, which is initialized in the `Game.init(String... args)` method. In this method, a new `GameLoop` object is instantiated and assigned to `gameLoop`. Since `init()` must be called before `start()`, which is implied by the requirement of initializing the game, the `gameLoop` is guaranteed to be non-null during the lifetime of the game execution where `Game.loop()` is called. The absence of any code that could set `gameLoop` to null after its initialization ensures that `Game.loop()` cannot return null.
---AdvancedNullAwayCodeFix.resolveMethodDereferenceError---
Method is not returning nullable on call site. Injecting suppression annotation.
---AdvancedNullAwayCodeFix.constructCastToNonnullChange---
Constructing cast to nonnull change for reason: The method `Game.loop()` returns the static field `gameLoop`, which is initialized in the `Game.init(String... args)` method. In this method, a new `GameLoop` object is instantiated and assigned to `gameLoop`. Since `init()` must be called before `start()`, which is implied by the requirement of initializing the game, the `gameLoop` is guaranteed to be non-null during the lifetime of the game execution where `Game.loop()` is called. The absence of any code that could set `gameLoop` to null after its initialization ensures that `Game.loop()` cannot return null.
---ChatGPT.ask---
Asking ChatGPT:
For the reason you mentioned earlier:

"The method `Game.loop()` returns the static field `gameLoop`, which is initialized in the `Game.init(String... args)` method. In this method, a new `GameLoop` object is instantiated and assigned to `gameLoop`. Since `init()` must be called before `start()`, which is implied by the requirement of initializing the game, the `gameLoop` is guaranteed to be non-null during the lifetime of the game execution where `Game.loop()` is called. The absence of any code that could set `gameLoop` to null after its initialization ensures that `Game.loop()` cannot return null."

in the method below, the expression Game.loop() is not nullable at the point it is used.

```java
private static void dispose(final Collection<? extends IEntity> entities) {
    for (final IEntity entity : entities) {
      if (entity instanceof IUpdateable) {
        Game.loop().detach((IUpdateable) entity);
      }

      entity.detachControllers();
    }
}
```
Please Summarize the reason in max 5 words and rewrite the method so that at the line "        Game.loop().detach((IUpdateable) entity);", at the occurrence of: "Game.loop()" is replaced with `NullabilityUtil.castToNonnull(Game.loop(), summary of reason)`
Replace "REASON" with the exact reason summary I provide to you (maximum 5 words), not with a generic explanation like "checked to be nonnull".
see the example below, for expression `foo.getBar()`, to wrap it with `NullabilityUtil.castToNonnull(foo.getBar(), "reason")`.

```java
public t(){
    String l = foo.getBar();
}
```

will be:
```java
public t(){
    String l = NullabilityUtil.castToNonnull(foo.getBar(), "checked to be nonnull");
}
```

### Instructions:

Do not import any additional classes.

Do not add Java comments.

Only modify relevant lines as required.

Return only the modified method wrapped in the XML format shown below.

Place the Java code inside the <code> tag using a CDATA block with ```java formatting.

Just give me the fixed code snippet in XML format in <response> tag like the example below. I will apply the fix to my codebase. Do not import any additional libraries or classes or add java comments. If you can provide the fixed code snippet, please provide it in the following format and place the code snippet in the <code> tag within ```java block.
<response>
  <success>true</success>
  <code><![CDATA[
  ```java
  Your fixed code snippet here
  ```
    ]]>
  </code>
</response>

---ChatGPT.sendRequestToOpenAI---
Retrieving response from cache
---Response.<init>---
Creating Response:
<response>
  <success>true</success>
  <code><![CDATA[
  ```java
  private static void dispose(final Collection<? extends IEntity> entities) {
      for (final IEntity entity : entities) {
        if (entity instanceof IUpdateable) {
          NullabilityUtil.castToNonnull(Game.loop(), "initially non-nullable").detach((IUpdateable) entity);
        }

        entity.detachControllers();
      }
  }
  ```
    ]]>
  </code>
</response>
---Response.<init>---
Response created:
private static void dispose(final Collection<? extends IEntity> entities) {
      for (final IEntity entity : entities) {
        if (entity instanceof IUpdateable) {
          NullabilityUtil.castToNonnull(Game.loop(), "initially non-nullable").detach((IUpdateable) entity);
        }

        entity.detachControllers();
      }
  }
---ChatGPT.fixDereferenceByAddingCastToNonnull---
Fixing the error by adding castToNonnull
---AdvancedNullAwayCodeFix.fixTriggeredErrorsForLocation---
Resolving unresolvable error for triggered error: Type='DEREFERENCE_NULLABLE', message='dereferenced expression Game.loop() is @Nullable'
/home/nima/Developer/nullness-benchmarks/litiengine/src/de/gurkenlabs/litiengine/graphics/Camera.java:185
      final double tickduration = 1000 / (double) Game.loop().getTickRate();
---AdvancedNullAwayCodeFix.fix---
Fixing error: Type='DEREFERENCE_NULLABLE', message='dereferenced expression Game.loop() is @Nullable'
/home/nima/Developer/nullness-benchmarks/litiengine/src/de/gurkenlabs/litiengine/graphics/Camera.java:185
      final double tickduration = 1000 / (double) Game.loop().getTickRate();
---AdvancedNullAwayCodeFix.resolveDereferenceError---
Resolving dereference error: Type='DEREFERENCE_NULLABLE', message='dereferenced expression Game.loop() is @Nullable'
/home/nima/Developer/nullness-benchmarks/litiengine/src/de/gurkenlabs/litiengine/graphics/Camera.java:185
      final double tickduration = 1000 / (double) Game.loop().getTickRate();
---AdvancedNullAwayCodeFix.resolveDereferenceError---
Checking nullability possibility at error point
---ChatGPT.checkNullabilityPossibilityAtErrorPoint---
Asking if the expression can be null at error point point
---ChatGPT.ask---
Asking ChatGPT:
In the method below, is there a possibility that the expression "Game.loop()" at line "final double tickduration = 1000 / (double) Game.loop().getTickRate();" is null?
@Override
  public void setZoom(final float targetZoom, final int delay) {
    if (delay == 0) {

      this.zoom = targetZoom;
      this.targetZoom = 0;
      this.zoomDelay = 0;
      this.zoomTick = 0;
      this.zoomStep = 0;

      final ZoomChangedEvent event = new ZoomChangedEvent(this, targetZoom);
      for (final ZoomChangedListener listener : this.zoomListeners) {
        listener.zoomChanged(event);
      }
    } else {
      this.zoomTick = Game.time().now();
      this.targetZoom = targetZoom;
      this.zoomDelay = delay;

      final double tickduration = 1000 / (double) Game.loop().getTickRate();
      final double tickAmount = delay / tickduration;
      final float totalDelta = this.targetZoom - this.zoom;
      this.zoomStep = tickAmount > 0 ? (float) (totalDelta / tickAmount) : totalDelta;
    }
}
Give a single-word answer in XML format. If it is possible for the expression to be null, respond with:
```xml
<response>
    <reason><![CDATA[YOUR REASON]]></reason>
    <value>YES</value>
</response>
```
If it is not possible for the expression to be null, respond with:
```xml
<response>
    <reason><![CDATA[YOUR REASON]]></reason>
    <value>NO</value>
</response>
```
If you are unsure or need more information, respond with where you can ask for more details or what specific information you need.

If additional information is required, list each request inside a `<request>` tag. If no additional information is needed, omit the `<requests>` section.

Respond with:
```xml
<response>
    <reason><![CDATA[YOUR REASON]]></reason>
    <value>UNKNOWN</value>
    <!-- Include <requests> only if additional information is needed -->
    <requests>
        <request><![CDATA[YOUR REQUEST 1]]></request>
        <request><![CDATA[YOUR REQUEST 2]]></request>
    </requests>
</response>
```
---ChatGPT.sendRequestToOpenAI---
Retrieving response from cache
---Response.<init>---
Creating Response:
```xml
<response>
    <reason><![CDATA[It is unclear from the provided code whether the `Game.loop()` method can return a null value. This depends on the implementation details of the 'Game' class and its 'loop' method, which are not included in the snippet provided.]]></reason>
    <value>UNKNOWN</value>
    <requests>
        <request><![CDATA[Provide the implementation details of the Game.loop() method.]]></request>
        <request><![CDATA[Include information about how the Game class is initialized and how ensure that loop() is always non-null.]]></request>
    </requests>
</response>
```
---Response.<init>---
Response created:
Unknown: It is unclear from the provided code whether the `Game.loop()` method can return a null value. This depends on the implementation details of the 'Game' class and its 'loop' method, which are not included in the snippet provided.
---AdvancedNullAwayCodeFix.resolveMethodDereferenceError---
Resolving method dereference error.
---AdvancedNullAwayCodeFix.resolveMethodDereferenceError---
Method is in annotated package. Checking if the method is returning nullable.
---AdvancedNullAwayCodeFix.investigateMethodReturnNullability---
Checking if the method is returning nullable.
---ChatGPT.checkIfMethodIsReturningNullable---
Asking if the method is returning nullable: loop()
---ChatGPT.ask---
Asking ChatGPT:
In the method below, is there a possibility that the method returns null based only on its body? Consider the following points:

- The method may have multiple return paths; consider all return statements.
- If the method calls another method, do not assume its return value unless its full declaration is provided. Request its declaration if needed.
- The method may throw an exception instead of returning null. An exception path should not be considered a null return.
- Ensure you request the declarations of any methods whose return values directly or indirectly impact this method’s return value before making a conclusion.
- Carefully analyze all conditions and prior operations that may guarantee a non-null return value.

@Nullable public static IGameLoop loop() {
    return gameLoop;
}

Here are the method definitions in addition to the method inquired:

Depth: 0
```java
class de.gurkenlabs.litiengine.Game {
@Nullable public static IGameLoop loop() {
    return gameLoop;
}
}
```


Response Format:
Provide the answer in **XML format** as follows:

#### If the method **cannot** return `null`:
```xml
<response>
  <reason><![CDATA[EXPLAIN WHY THE METHOD CANNOT RETURN NULL]]></reason>
  <value>NO</value>
</response>
```

#### If the method can return null:
```xml
<response>
  <reason><![CDATA[EXPLAIN WHY THE METHOD CAN RETURN NULL]]></reason>
  <value>YES</value>
</response>
```

#### If you are unsure or need more information, respond with where you can ask for more details or what specific information you need.

#### If you are unsure or If there are any methods that directly or indirectly affect the return value and are not fully disclosed, request their declarations first, in the following format:
<response>
  <reason><![CDATA[YOUR REASON]]></reason>
  <value>UNKNOWN</value>
  <methods>
    <method>methodName</method>
  </methods>
</response>

If additional information is required other than method declaration, list each request inside a `<request>` tag. If no additional information is needed, omit the `<requests>` section.

Respond with:
```xml
<response>
    <reason><![CDATA[YOUR REASON]]></reason>
    <value>UNKNOWN</value>
    <!-- Include <requests> only if additional information is needed -->
    <requests>
        <request><![CDATA[YOUR REQUEST 1]]></request>
        <request><![CDATA[YOUR REQUEST 2]]></request>
    </requests>
</response>
```

Additional Notes:
Be precise in your reasoning.
If a method’s return value depends on another method not provided, request its declaration before making a conclusion.
If the method can return null in some cases but not others, explain under what conditions it can happen.

---ChatGPT.sendRequestToOpenAI---
Retrieving response from cache
---Response.<init>---
Creating Response:
```xml
<response>
  <reason><![CDATA[The method `loop` returns the variable `gameLoop`. Without the initialization or assignment details of `gameLoop`, it's unclear whether it can be null. The possibility of `gameLoop` being uninitialized or set to null elsewhere in the program means `loop` could potentially return null. Further information on `gameLoop` is required.]]></reason>
  <value>UNKNOWN</value>
  <requests>
    <request><![CDATA[Please provide the declaration and initialization of the variable `gameLoop` in the class `de.gurkenlabs.litiengine.Game`.]]></request>
  </requests>
</response>
```
---Response.<init>---
Response created:
Unknown: The method `loop` returns the variable `gameLoop`. Without the initialization or assignment details of `gameLoop`, it's unclear whether it can be null. The possibility of `gameLoop` being uninitialized or set to null elsewhere in the program means `loop` could potentially return null. Further information on `gameLoop` is required.
---AdvancedNullAwayCodeFix.investigateMethodReturnNullability---
Could not determine the nullability and model did not ask for any method.
---ChatGPT.checkIfMethodIsReturningNullableOnCallSite---
Asking if the method is returning nullable on the call site: Game.loop()
---ChatGPT.ask---
Asking ChatGPT:
In the method below, is there a possibility that the method returns null at the given call site?

```java
@Nullable public static IGameLoop loop() {
    return gameLoop;
}
```

## Guidelines:
- The method may have multiple return paths; consider all return statements.
- If the method calls another method, do not assume its return value unless its full declaration is provided. Request its declaration if needed.
- The method may throw an exception instead of returning null. An exception path should not be considered a null return.
- Ensure you request the declarations of any methods whose return values directly or indirectly impact this method’s return value before making a conclusion.
- If the method returns a value that is determined by a parameter, evaluate based on the actual argument at the given call site.
- Analyze based only on the specific invocation provided. Do not generalize to all possible inputs.- If the return value is guaranteed to be non-null at the call site, the answer should be a definitive NO.
- Do not generalize based on all possible inputs—your answer must be based only on the given invocation.
- Focus only on the given call site, not all possible invocations.

### call site:
Game.loop()

Here are the method definitions and the call chain for this method, showing the sequence of calls from the method to its callers at each depth level:

Depth: 0
```java
class de.gurkenlabs.litiengine.Game {
@Nullable public static IGameLoop loop() {
    return gameLoop;
}
}
```
Depth: 1
```java
class de.gurkenlabs.litiengine.environment.GameWorld {
public void loadEnvironment(@Nullable final Environment env) {
    Lock lock = Game.loop().getLock();
    lock.lock();
    try {
      unloadEnvironment();
      this.environment = env;
      if (env != null) {
        this.addEnvironment(env);

        if (env.getGravity() == 0 && this.gravity() != 0) {
          env.setGravity(this.gravity());
        }

        env.load();
        for (final EnvironmentLoadedListener listener : this.loadedListeners) {
          listener.loaded(env);
        }

        // call map specific listeners
        String mapName = getMapName(env);
        if (mapName != null && this.environmentLoadedListeners.containsKey(mapName)) {

          // for the default camera we center the camera on the environment
          if (this.camera().getClass().equals(Camera.class)) {
            camera().setFocus(env.getCenter());
          }

          for (EnvironmentLoadedListener listener : this.environmentLoadedListeners.get(mapName)) {
            listener.loaded(env);
          }
        }
      }
    } finally {
      lock.unlock();
    }
}public void setCamera(@Nullable final ICamera cam) {
    if (this.camera() != null) {
      Game.loop().detach(camera);
    }

    camera = cam;

    if (cam != null && !Game.isInNoGUIMode()) {
      Game.loop().attach(cam);
      cam.updateFocus();
    }
}
}
```
```java
class de.gurkenlabs.litiengine.entities.behavior.EntityNavigator {
public EntityNavigator(final IMobileEntity entity, final PathFinder pathFinder) {
    this.cancelNavigationConditions = new CopyOnWriteArrayList<>();
    this.listeners = new CopyOnWriteArrayList<>();
    this.entity = entity;
    this.pathFinder = pathFinder;
    this.setAcceptableError(DEFAULT_ACCEPTABLE_ERROR);
    Game.loop().attach(this);
}
}
```
```java
class de.gurkenlabs.litiengine.GameWindow {
private static void initializeWindowEventListeners(Window window) {

    window.addWindowStateListener(
        e -> {
          if (e.getNewState() == Frame.ICONIFIED) {
            Game.loop().setTickRate(ICONIFIED_MAX_FPS);
          } else {
            Game.loop().setTickRate(Game.config().client().getMaxFps());
          }
        });

    window.addWindowFocusListener(
        new WindowFocusListener() {
          @Override
          public void windowLostFocus(WindowEvent e) {
            if (Game.config().graphics().reduceFramesWhenNotFocused()) {
              Game.loop().setTickRate(NONE_FOCUS_MAX_FPS);
            }
          }

          @Override
          public void windowGainedFocus(WindowEvent e) {
            Game.loop().setTickRate(Game.config().client().getMaxFps());
          }
        });

    window.addWindowListener(
        new WindowAdapter() {
          @Override
          public void windowClosing(final WindowEvent event) {
            Game.exit();
          }
        });
}
}
```
```java
class de.gurkenlabs.litiengine.gui.screens.ScreenManager {
public void display(@Nullable final Screen screen) {
    if (Game.hasStarted() && Game.time().since(this.lastScreenChange) < this.getChangeCooldown()) {
      log.log(
          Level.INFO,
          "Skipping displaying of screen {0} because screen changing is currently on cooldown.",
          screen != null ? screen.getName() : "");
      return;
    }

    final Screen previous = this.current();
    if (previous != null) {
      previous.suspend();
    }

    if (screen != null && !this.screens.contains(screen)) {
      this.screens.add(screen);
    }

    this.currentScreen = screen;
    if (!Game.isInNoGUIMode() && this.current() != null) {
      this.current().prepare();
    }

    this.lastScreenChange = Game.loop().getTicks();

    final ScreenChangedEvent event = new ScreenChangedEvent(this.current(), previous);
    for (final ScreenChangedListener listener : this.screenChangedListeners) {
      listener.changed(event);
    }
}
}
```
```java
class de.gurkenlabs.litiengine.abilities.effects.Effect {
@Override
  public void update() {

    for (final Iterator<EffectApplication> iterator = this.getActiveAppliances().iterator();
        iterator.hasNext(); ) {
      final EffectApplication appliance = iterator.next();
      // if the effect duration is reached
      if (this.hasEnded(appliance)) {

        iterator.remove();
        this.cease(appliance);
      }
    }

    // 4. unregister if all appliances are finished
    if (this.getActiveAppliances().isEmpty()) {
      Game.loop().detach(this);
    }
}public void apply(final Shape impactArea) {
    final List<ICombatEntity> affected = this.lookForAffectedEntities(impactArea);
    for (final ICombatEntity affectedEntity : affected) {
      this.apply(affectedEntity);
    }

    this.appliances.add(new EffectApplication(affected, impactArea));

    // if it is the first appliance -> register for update
    if (this.appliances.size() == 1) {
      Game.loop().attach(this);
    }
}
}
```
```java
class de.gurkenlabs.litiengine.GameTime {
public long toTicks(final int milliseconds) {
    return this.toTicks(milliseconds, Game.loop().getTickRate());
}public long since(final long tick) {
    return toMilliseconds(Game.loop().getTicks() - tick);
}public long now() {
    return Game.loop().getTicks();
}public long sinceGameStart() {
    return this.toMilliseconds(Game.loop().getTicks());
}@Override
  public void loaded(Environment environment) {
    environmentLoaded = Game.loop().getTicks();
}public long toMilliseconds(final long ticks) {
    return this.toMilliseconds(ticks, Game.loop().getTickRate());
}
}
```
```java
class de.gurkenlabs.litiengine.GameMetrics {
@Override
  public void render(final Graphics2D g) {
    this.updateMetrics();

    if (!Game.config().client().showGameMetrics()) {
      return;
    }

    this.currentOffsetY = 0;

    g.setColor(this.renderColor);

    // render client metrics
    this.drawTitle(g, "[client]");
    this.drawMetric(g, "fps       : " + this.getFramesPerSecond());
    this.drawMetric(g, "max fps   : " + this.maxFramesPerSecond);
    this.drawMetric(g, "updatables: " + Game.loop().getUpdatableCount());

    // render jvm metrics if debug is enabled
    if (Game.config().debug().isDebugEnabled()) {
      this.drawTitle(g, "[jvm]");
      this.drawMetric(g, "java      : " + this.javaVersion);
      this.drawMetric(g, "memory    : " + String.format("%-5.5s", this.usedMemory) + " MB");
      this.drawMetric(g, "threads   : " + Thread.activeCount());
    }

    // render rendering metrics
    if (!this.renderMetrics.isEmpty()) {
      this.drawTitle(g, "[update]");

      for (RenderMetrics metric : this.renderMetrics) {
        this.drawMetric(g, metric.toString());
      }

      this.renderMetrics.clear();
    }
}
}
```
```java
class de.gurkenlabs.litiengine.graphics.emitters.Emitter {
public void deactivate() {
    if (!this.activated) {
      return;
    }

    this.activated = false;
    this.getParticles().clear();
    this.aliveTime = 0;
    this.activationTick = 0;
    this.lastSpawn = 0;
    Game.loop().detach(this);
}public void activate() {
    if (this.activated) {
      return;
    }

    this.activated = true;
    this.activationTick = Game.time().now();
    Game.loop().attach(this);
}@Override
  public void update() {
    if (this.isPaused()) {
      return;
    }

    // clear particles if the effect time to life is reached
    if (this.isFinished()) {
      for (EmitterFinishedListener listener : this.finishedListeners) {
        listener.finished(this);
      }

      this.delete();
      return;
    }

    final float updateRatio = (float) this.data().getUpdateRate() / Game.loop().getTickRate();
    for (final Particle p : this.getParticles().stream().collect(Collectors.toList())) {
      if (this.particleCanBeRemoved(p)) {
        // remove dead particles
        this.particles.remove(p);
        continue;
      }

      p.update(this.getOrigin(), updateRatio);
    }

    this.aliveTime = Game.time().since(this.activationTick);
    if ((this.data().getSpawnRate() == 0
        || Game.time().since(this.lastSpawn) >= this.data().getSpawnRate())) {
      this.lastSpawn = Game.time().now();
      this.spawnParticle();
    }
}
}
```
```java
class de.gurkenlabs.litiengine.entities.behavior.IBehaviorController {
public default void attach() {
    Game.loop().attach(this);
}public default void detach() {
    Game.loop().detach(this);
}
}
```
```java
class de.gurkenlabs.litiengine.abilities.AbilityExecution {
AbilityExecution(final Ability ability) {
    this.appliedEffects = new CopyOnWriteArrayList<>();
    this.ability = ability;
    this.executionTicks = Game.time().now();
    this.impactArea = ability.calculateImpactArea();
    this.castLocation = ability.getExecutor().getCenter();
    Game.loop().attach(this);
}@Override
  public void update() {
    // if there a no effects to apply -> unregister this instance and we're done
    if (this.getAbility().getEffects().isEmpty()
        || this.getAbility().getEffects().size() == this.getAppliedEffects().size()) {
      Game.loop().detach(this);
      return;
    }

    // handle all effects from the ability that were not applied yet
    for (final Effect effect : this.getAbility().getEffects()) {
      // if the ability was not executed yet or the delay of the effect is not
      // yet reached
      if (this.getAppliedEffects().contains(effect)
          || Game.time().since(this.getExecutionTicks()) < effect.getDelay()) {
        continue;
      }

      effect.apply(this.getExecutionImpactArea());
      this.getAppliedEffects().add(effect);
    }
}
}
```
```java
class de.gurkenlabs.litiengine.GameWindow$3 {
@Override
          public void windowGainedFocus(WindowEvent e) {
            Game.loop().setTickRate(Game.config().client().getMaxFps());
}@Override
          public void windowLostFocus(WindowEvent e) {
            if (Game.config().graphics().reduceFramesWhenNotFocused()) {
              Game.loop().setTickRate(NONE_FOCUS_MAX_FPS);
            }
}
}
```
```java
class de.gurkenlabs.litiengine.environment.EntitySpawner {
protected void spawnNewEntities() {
    if (this.getSpawnMode() != SpawnMode.CUSTOMSPAWNPOINTS && this.getSpawnPoints().isEmpty()) {
      return;
    }

    switch (this.getSpawnMode()) {
      case ALLSPAWNPOINTS:
        for (int i = 0; i < this.getSpawnPoints().size(); i++) {
          final int index = i;
          Game.loop()
              .perform(
                  this.getSpawnDelay() + this.getSpawnDelay() * i,
                  () -> this.spawn(this.getSpawnPoints().get(index), this.getSpawnAmount()));
        }
        break;
      case ONERANDOMSPAWNPOINT:
        this.spawn(Game.random().choose(this.getSpawnPoints()), this.getSpawnAmount());
        break;
      case RANDOMSPAWNPOINTS:
        for (int i = 0; i < this.getSpawnAmount(); i++) {
          Game.loop()
              .perform(
                  this.getSpawnDelay() + this.getSpawnDelay() * i,
                  () -> this.spawn(Game.random().choose(this.getSpawnPoints()), 1));
        }
        break;
      case CUSTOMSPAWNPOINTS:
        List<Spawnpoint> spawnPoints =
            this.customSpawnpoints != null
                ? this.customSpawnpoints.apply(this)
                : this.getCustomSpawnpoints();

        int index = 0;
        for (Spawnpoint spawn : spawnPoints) {
          Game.loop()
              .perform(
                  this.getSpawnDelay() + this.getSpawnDelay() * index, () -> this.spawn(spawn, 1));
          index++;
        }
        break;
      default:
        break;
    }
}
}
```
```java
class de.gurkenlabs.litiengine.tweening.TweenEngine {
@Override
  public void start() {
    Game.loop().attach(this);
}@Override
  public void terminate() {
    Game.loop().detach(this);
}
}
```
```java
class de.gurkenlabs.litiengine.gui.SpeechBubble {
public void hide() {
    Game.world().environment().removeRenderable(this);
    Game.loop().detach(this);
    if (activeSpeechBubbles.get(this.getEntity()) != null
        && activeSpeechBubbles.remove(this.getEntity()).equals(this)) {
      activeSpeechBubbles.remove(this.getEntity());
    }

    for (SpeechBubbleListener listener : this.listeners) {
      listener.hidden();
    }
}private SpeechBubble(
      final IEntity entity,
      final String text,
      @Nullable SpeechBubbleAppearance appearance,
      @Nullable Font font) {
    if (appearance == null) {
      this.appearance = DEFAULT_APPEARANCE;
    } else {
      this.appearance = appearance;
    }

    final SpeechBubble active = activeSpeechBubbles.get(entity);
    if (active != null) {
      active.hide();
    }
    this.setFont(font);

    this.textBoxWidth = (float) (entity.getWidth() * 4);
    this.entity = entity;

    this.currentText = text;
    this.currentTextDisplayTime = DISPLAYTIME_MIN + text.length() * DISPLAYTIME_PER_LETTER;

    this.lastTextDisplay = Game.time().now();
    this.createBubbleImage();
    entity.getEnvironment().add(this, RenderType.UI);
    Game.loop().attach(this);
    activeSpeechBubbles.put(entity, this);
}
}
```
```java
class de.gurkenlabs.litiengine.entities.Prop {
private void updateAnimationController() {
    IEntityAnimationController<?> controller = this.createAnimationController();
    this.getControllers().addController(controller);
    if (Game.world().environment() != null && Game.world().environment().isLoaded()) {
      Game.loop().attach(controller);
    }
}
}
```
```java
class de.gurkenlabs.litiengine.graphics.FreeFlightCamera {
public FreeFlightCamera(final Point2D focus) {
    this.setFocus(focus);
    this.velocity = DEFAULT_SCROLL_PIXELS_PER_SECOND;
    this.scrollPadding = DEFAULT_SCROLL_PADDING;
    this.setClampToMap(true);

    Game.loop().attach(this);
}private void handleFreeFlightCamera() {
    if (Game.world().environment() == null || Game.world().environment().getMap() == null) {
      return;
    }

    final Point2D mouseLocation = Input.mouse().getLocation();

    final double scrollSpeed =
        this.getVelocity()
            / (double) Game.loop().getTickRate()
            * Game.config().input().getMouseSensitivity();

    double x = this.getFocus().getX();
    double y = this.getFocus().getY();

    double deltaX = 0;
    if (mouseLocation.getX() < this.getScrollPadding()) {
      deltaX -= scrollSpeed;
    } else if (Game.window().getResolution().getWidth() - mouseLocation.getX()
        < this.getScrollPadding()) {
      deltaX += scrollSpeed;
    }

    double deltaY = 0;
    if (mouseLocation.getY() < this.getScrollPadding()) {
      deltaY -= scrollSpeed;
    } else if (Game.window().getResolution().getHeight() - mouseLocation.getY()
        < this.getScrollPadding()) {
      deltaY += scrollSpeed;
    }

    x += deltaX;
    y += deltaY;

    this.setFocus(new Point2D.Double(x, y));
}
}
```
```java
class de.gurkenlabs.litiengine.environment.Environment {
private static void dispose(final Collection<? extends IEntity> entities) {
    for (final IEntity entity : entities) {
      if (entity instanceof IUpdateable) {
        Game.loop().detach((IUpdateable) entity);
      }

      entity.detachControllers();
    }
}private static void loadUpdatableOrEmitterEntity(IEntity entity) {
    if (entity instanceof Emitter) {
      final Emitter emitter = (Emitter) entity;
      if (emitter.isActivateOnInit()) {
        emitter.activate();
      }
    } else if (entity instanceof IUpdateable) {
      Game.loop().attach((IUpdateable) entity);
    }
}private void unload(final IEntity entity) {
    // 1. remove from physics engine
    if (entity instanceof ICollisionEntity) {
      Game.physics().remove((ICollisionEntity) entity);
    }

    // 2. unregister from update
    if (entity instanceof IUpdateable) {
      Game.loop().detach((IUpdateable) entity);
    }

    if (entity instanceof IMobileEntity) {
      this.removeGravity((IMobileEntity) entity);
    }

    // 3. detach all controllers
    entity.detachControllers();

    if (entity instanceof Emitter) {
      Emitter em = (Emitter) entity;
      em.deactivate();
    }

    if (this.loaded && (entity instanceof LightSource || entity instanceof StaticShadow)) {
      this.updateLighting(entity);
    }

    entity.removed(this);
}
}
```
```java
class de.gurkenlabs.litiengine.graphics.animation.Animation {
@Override
  public void update() {
    // do nothing if the animation is not playing or the current keyframe is not finished
    if (!this.isPlaying()
        || Game.time().since(this.lastFrameUpdate) < this.getCurrentKeyFrame().getDuration()) {
      return;
    }

    // if we are not looping and the last keyframe is finished, we terminate the animation
    if (!this.isLooping() && this.isLastKeyFrame()) {
      this.terminate();
      return;
    }

    // make sure, we stay inside the keyframe list
    final int newFrameIndex =
        (this.getKeyframes().indexOf(this.currentFrame) + 1) % this.getKeyframes().size();
    final KeyFrame previousFrame = this.currentFrame;
    this.currentFrame = this.getKeyframes().get(newFrameIndex);

    for (KeyFrameListener listener : this.listeners) {
      listener.currentFrameChanged(previousFrame, this.currentFrame);
    }

    this.lastFrameUpdate = Game.loop().getTicks();
}public void restart() {
    this.currentFrame = this.firstFrame;
    this.lastFrameUpdate = Game.loop().getTicks();
}
}
```
```java
class de.gurkenlabs.litiengine.physics.MovementController {
@Override
  public void attach() {
    Game.loop().attach(this);
}private void handleForces() {
    // clean up forces
    this.activeForces.forEach(
        x -> {
          if (x.hasEnded()) {
            this.activeForces.remove(x);
          }
        });

    if (this.activeForces.isEmpty()) {
      return;
    }

    // disable turn-on-move for force handling
    boolean turn = this.getEntity().turnOnMove();
    this.getEntity().setTurnOnMove(false);
    try {
      double deltaX = 0;
      double deltaY = 0;
      for (final Force force : this.activeForces) {
        if (force.cancelOnReached() && force.hasReached(this.getEntity())) {
          force.end();
          continue;
        }

        final Point2D collisionBoxCenter = this.getEntity().getCollisionBoxCenter();
        final double angle =
            GeometricUtilities.calcRotationAngleInDegrees(collisionBoxCenter, force.getLocation());
        final double strength =
            Game.loop().getDeltaTime() * 0.001f * force.getStrength() * Game.loop().getTimeScale();
        deltaX += GeometricUtilities.getDeltaX(angle, strength);
        deltaY += GeometricUtilities.getDeltaY(angle, strength);
      }

      final Point2D target =
          new Point2D.Double(this.getEntity().getX() + deltaX, this.getEntity().getY() + deltaY);
      final boolean success = Game.physics().move(this.getEntity(), target);
      if (!success) {
        for (final Force force : this.activeForces) {
          if (force.cancelOnCollision()) {
            force.end();
          }
        }
      }
    } finally {
      this.getEntity().setTurnOnMove(turn);
    }
}@Override
  public void detach() {
    Game.loop().detach(this);
}public void handleMovement() {
    if (!this.isMovementAllowed()) {
      this.velocity = 0;
      return;
    }

    // max distance an entity can travel within one tick
    final double maxPixelsPerTick = this.getEntity().getTickVelocity();
    final double deltaTime = Game.loop().getDeltaTime() * Game.loop().getTimeScale();

    final double acceleration =
        this.getEntity().getAcceleration() == 0
            ? maxPixelsPerTick
            : deltaTime / this.getEntity().getAcceleration() * maxPixelsPerTick;
    final double deceleration =
        this.getEntity().getDeceleration() == 0
            ? this.getVelocity()
            : deltaTime / this.getEntity().getDeceleration() * maxPixelsPerTick;

    double dx = this.getDx();
    double dy = this.getDy();
    this.setDx(0);
    this.setDy(0);

    final double deltaVelocity =
        Math.min(Math.sqrt(Math.pow(dx, 2) + Math.pow(dy, 2)), acceleration);
    if (deltaVelocity != 0) {
      double newVelocity = this.getVelocity() + deltaVelocity;
      this.setVelocity(newVelocity);
    } else {
      final double newVelocity = Math.max(0, this.getVelocity() - deceleration);
      this.setVelocity(newVelocity);
      dx = GeometricUtilities.getDeltaX(this.moveAngle);
      dy = GeometricUtilities.getDeltaY(this.moveAngle);
    }

    if (this.getVelocity() == 0) {
      this.moveAngle = 0;
      return;
    }

    // actually move entity
    this.moveEntity(dx, dy);
}
}
```
```java
class de.gurkenlabs.litiengine.graphics.animation.AnimationController {
public void detach() {
    Game.loop().detach(this);
}public void attach() {
    Game.loop().attach(this);
}
}
```
```java
class de.gurkenlabs.litiengine.graphics.Camera {
@Override
  public void setZoom(final float targetZoom, final int delay) {
    if (delay == 0) {

      this.zoom = targetZoom;
      this.targetZoom = 0;
      this.zoomDelay = 0;
      this.zoomTick = 0;
      this.zoomStep = 0;

      final ZoomChangedEvent event = new ZoomChangedEvent(this, targetZoom);
      for (final ZoomChangedListener listener : this.zoomListeners) {
        listener.zoomChanged(event);
      }
    } else {
      this.zoomTick = Game.time().now();
      this.targetZoom = targetZoom;
      this.zoomDelay = delay;

      final double tickduration = 1000 / (double) Game.loop().getTickRate();
      final double tickAmount = delay / tickduration;
      final float totalDelta = this.targetZoom - this.zoom;
      this.zoomStep = tickAmount > 0 ? (float) (totalDelta / tickAmount) : totalDelta;
    }
}
}
```
```java
class de.gurkenlabs.litiengine.Game {
public static synchronized void init(String... args) {
    if (initialized) {
      log().log(Level.INFO, "The game has already been initialized.");
      return;
    }

    log.init();
    handleCommandLineArguments(args);

    config().load();
    Locale.setDefault(new Locale(config().client().getCountry(), config().client().getLanguage()));

    gameLoop = new GameLoop("Main Update Loop", config().client().getMaxFps());
    loop().attach(physics());
    loop().attach(world());

    // setup default exception handling for render and update loop
    setUncaughtExceptionHandler(
        new DefaultUncaughtExceptionHandler(config().client().exitOnError()));

    screenManager = new ScreenManager();
    gameWindow = new GameWindow();

    // initialize  the game window
    window().init();
    world.setCamera(new Camera());

    for (GameListener listener : gameListeners) {
      listener.initialized(args);
    }

    if (!isInNoGUIMode()) {
      window().getRenderComponent().onRendered(g -> metrics().render(g));

      graphics()
          .addEntityRenderedListener(
              e -> DebugRenderer.renderEntityDebugInfo(e.getGraphics(), e.getEntity()));

      window().getRenderComponent().onFpsChanged(fps -> metrics().setFramesPerSecond(fps));
      window()
          .setIcons(
              Arrays.asList(
                  Resources.images().get("liti-logo-x16.png"),
                  Resources.images().get("liti-logo-x20.png"),
                  Resources.images().get("liti-logo-x32.png"),
                  Resources.images().get("liti-logo-x48.png")));

      Input.keyboard()
          .onKeyTyped(
              KeyEvent.VK_PRINTSCREEN,
              key -> {
                // don't take a screenshot if a modifier is active
                if (key.getModifiers() != 0) {
                  return;
                }

                window().getRenderComponent().takeScreenshot();
              });
    }

    Runtime.getRuntime().addShutdownHook(new Thread(Game::terminate, "Shutdown"));

    initialized = true;
}
}
```
```java
class de.gurkenlabs.litiengine.entities.Creature {
protected void updateAnimationController() {
    IEntityAnimationController<?> controller = this.createAnimationController();
    this.getControllers().addController(controller);
    if (Game.world().environment() != null && Game.world().environment().isLoaded()) {
      Game.loop().attach(controller);
    }
}@Override
  public float getTickVelocity() {
    // pixels per ms multiplied by the passed ms
    // ensure that entities don't travel too far in case of lag
    return Math.min(Game.loop().getDeltaTime(), GameLoop.TICK_DELTATIME_LAG)
        * 0.001F
        * this.getVelocity().get()
        * Game.loop().getTimeScale();
}
}
```
Depth: 2
```java
class de.gurkenlabs.litiengine.environment.GameWorld {
public void clear() {
    this.unloadEnvironment();
    this.environments.clear();
    this.setCamera(null);
    Game.physics().clear();

    this.environmentListeners.clear();
    this.environmentLoadedListeners.clear();
    this.environmentUnloadedListeners.clear();

    this.listeners.clear();
    this.loadedListeners.clear();
    this.unloadedListeners.clear();
}@Nullable
  public Environment loadEnvironment(IMap map) {
    Environment env = this.getEnvironment(map);
    this.loadEnvironment(env);
    return env;
}@Nullable
  public Environment loadEnvironment(String mapName) {
    Environment env = this.getEnvironment(mapName);
    this.loadEnvironment(env);
    return env;
}
}
```
```java
class de.gurkenlabs.litiengine.GameWindow {
GameWindow() {
    this.hostControl = new JFrame();

    this.resolutionChangedListeners = new CopyOnWriteArrayList<>();

    this.renderCanvas = new RenderComponent(Game.config().graphics().getResolution());
    this.cursor = new MouseCursor();
    if (!Game.isInNoGUIMode()) {
      this.hostControl.setBackground(Color.BLACK);
      this.hostControl.add(this.renderCanvas);

      this.initializeEventListeners();

      this.hostControl.setTitle(Game.info().getTitle());
      this.hostControl.setDefaultCloseOperation(WindowConstants.DO_NOTHING_ON_CLOSE);
      initializeWindowEventListeners(this.hostControl);
    }
}
}
```
```java
class de.gurkenlabs.litiengine.GameTime {
public long sinceEnvironmentLoad() {
    return this.since(this.environmentLoaded);
}public long since(final long tick) {
    return toMilliseconds(Game.loop().getTicks() - tick);
}public long sinceGameStart() {
    return this.toMilliseconds(Game.loop().getTicks());
}
}
```
```java
class de.gurkenlabs.litiengine.abilities.effects.Effect {
protected void cease(final EffectApplication appliance) {
    // 1. cease the effect for all affected entities
    for (final ICombatEntity entity : appliance.getAffectedEntities()) {
      this.cease(entity);
    }

    // 2. apply follow up effects
    this.getFollowUpEffects().forEach(followUp -> followUp.apply(appliance.getImpactArea()));
}protected boolean hasEnded(final EffectApplication appliance) {
    final long effectDuration = Game.time().since(appliance.getAppliedTicks());
    return effectDuration > this.getDuration();
}
}
```
```java
class de.gurkenlabs.litiengine.abilities.effects.EffectApplication {
protected EffectApplication(final List<ICombatEntity> affectedEntities, final Shape impactArea) {
    this.applied = Game.time().now();
    this.affectedEntities = affectedEntities;
    this.impactArea = impactArea;
}
}
```
```java
class de.gurkenlabs.litiengine.entities.CombatEntity {
@Override
  public boolean wasHit(int timeSpan) {
    return Game.time().since(this.lastHit) < timeSpan;
}@Override
  public void hit(final int damage, @Nullable final Ability ability) {
    if (this.isDead()) {
      return;
    }

    if (!this.isIndestructible()) {
      this.getHitPoints().modifyBaseValue(new AttributeModifier<>(Modification.SUBTRACT, damage));
    }

    final EntityHitEvent event = new EntityHitEvent(this, ability, damage, this.isDead());

    for (final CombatEntityListener listener : this.listeners) {
      listener.hit(event);
    }

    for (final CombatEntityHitListener listener : this.hitListeners) {
      listener.hit(event);
    }

    if (this.isDead()) {
      this.fireDeathEvent();
      this.setCollision(false);
    }

    this.lastHit = Game.time().now();
}
}
```
```java
class de.gurkenlabs.litiengine.graphics.ImageEffect {
protected ImageEffect(final int ttl, final String name) {
    this.ttl = ttl;
    this.name = name;
    this.aliveTick = Game.time().now();
}@Override
  public long getAliveTime() {
    return Game.time().since(this.aliveTick);
}
}
```
```java
class de.gurkenlabs.litiengine.abilities.AbilityExecution {
AbilityExecution(final Ability ability) {
    this.appliedEffects = new CopyOnWriteArrayList<>();
    this.ability = ability;
    this.executionTicks = Game.time().now();
    this.impactArea = ability.calculateImpactArea();
    this.castLocation = ability.getExecutor().getCenter();
    Game.loop().attach(this);
}@Override
  public void update() {
    // if there a no effects to apply -> unregister this instance and we're done
    if (this.getAbility().getEffects().isEmpty()
        || this.getAbility().getEffects().size() == this.getAppliedEffects().size()) {
      Game.loop().detach(this);
      return;
    }

    // handle all effects from the ability that were not applied yet
    for (final Effect effect : this.getAbility().getEffects()) {
      // if the ability was not executed yet or the delay of the effect is not
      // yet reached
      if (this.getAppliedEffects().contains(effect)
          || Game.time().since(this.getExecutionTicks()) < effect.getDelay()) {
        continue;
      }

      effect.apply(this.getExecutionImpactArea());
      this.getAppliedEffects().add(effect);
    }
}
}
```
```java
class de.gurkenlabs.litiengine.tweening.TweenEngine {
@Override
  public void update() {
    for (final Tweenable target : this.getTweens().keySet()) {
      for (final Tween tween : this.getTweens().get(target).values()) {
        if (tween.hasStopped()) {
          continue;
        }
        final long elapsed = Game.time().since(tween.getStartTime());
        if (elapsed >= tween.getDuration()) {
          tween.stop();
          continue;
        }
        final float[] currentValues = new float[tween.getTargetValues().length];
        for (int i = 0; i < tween.getTargetValues().length; i++) {
          currentValues[i] =
              tween.getStartValues()[i]
                  + tween.getEquation().compute(elapsed / (float) tween.getDuration())
                      * (tween.getTargetValues()[i] - tween.getStartValues()[i]);
        }
        tween.getTarget().setTweenValues(tween.getType(), currentValues);
      }
    }
}
}
```
```java
class de.gurkenlabs.litiengine.gui.SpeechBubble {
public static SpeechBubble create(
      final IEntity entity, final String text, SpeechBubbleAppearance appearance, Font font) {
    return new SpeechBubble(entity, text, appearance, font);
}public static SpeechBubble create(final IEntity entity, final Font font, final String text) {
    SpeechBubbleAppearance app =
        new SpeechBubbleAppearance(
            DEFAULT_APPEARANCE.getForeColor(),
            DEFAULT_APPEARANCE.getBackgroundColor1(),
            DEFAULT_APPEARANCE.getBorderColor(),
            DEFAULT_APPEARANCE.getPadding());
    return new SpeechBubble(entity, text, app, font);
}public static SpeechBubble create(final IEntity entity, final String text) {
    return new SpeechBubble(entity, text, null, GuiProperties.getDefaultFont());
}@Override
  public void update() {
    if (this.currentText == null) {
      this.hide();
      return;
    }

    this.entityCenter = Game.world().camera().getViewportLocation(this.getEntity().getCenter());

    // old text was displayed long enough
    if (this.lastTextDisplay != 0
        && Game.time().since(this.lastTextDisplay) > this.currentTextDisplayTime) {
      this.currentText = null;
      this.lastTextDisplay = 0;
      return;
    }

    // display new text
    if (this.textIndex < this.currentText.length()
        && Game.time().since(this.lastCharPoll) > LETTER_WRITE_DELAY) {
      this.textIndex++;
      this.lastCharPoll = Game.time().now();
      if (this.typeSound != null) {
        Game.audio().playSound(this.typeSound, this.getEntity());
      }
    }

    // continue displaying currently displayed text
}private SpeechBubble(
      final IEntity entity,
      final String text,
      final Sound typeSound,
      SpeechBubbleAppearance appearance,
      Font font) {
    this(entity, text, appearance, font);
    this.typeSound = typeSound;
}private SpeechBubble(
      final IEntity entity,
      final String text,
      @Nullable SpeechBubbleAppearance appearance,
      @Nullable Font font) {
    if (appearance == null) {
      this.appearance = DEFAULT_APPEARANCE;
    } else {
      this.appearance = appearance;
    }

    final SpeechBubble active = activeSpeechBubbles.get(entity);
    if (active != null) {
      active.hide();
    }
    this.setFont(font);

    this.textBoxWidth = (float) (entity.getWidth() * 4);
    this.entity = entity;

    this.currentText = text;
    this.currentTextDisplayTime = DISPLAYTIME_MIN + text.length() * DISPLAYTIME_PER_LETTER;

    this.lastTextDisplay = Game.time().now();
    this.createBubbleImage();
    entity.getEnvironment().add(this, RenderType.UI);
    Game.loop().attach(this);
    activeSpeechBubbles.put(entity, this);
}
}
```
```java
class de.gurkenlabs.litiengine.gui.TextFieldComponent {
@Override
  public void render(final Graphics2D g) {
    super.render(g);
    g.setFont(this.getFont());
    final FontMetrics fm = g.getFontMetrics();

    if (this.isSelected() && Game.time().since(this.lastToggled) > this.flickerDelay) {
      this.cursorVisible = !this.cursorVisible;
      this.lastToggled = Game.time().now();
    }
    if (this.isSelected() && this.cursorVisible) {
      final Rectangle2D cursor =
          new Rectangle2D.Double(
              this.getX() + this.getTextX() + fm.stringWidth(this.getTextToRender(g)),
              this.getY() + this.getTextY(),
              this.getFont().getSize2D() * 3 / 5,
              this.getFont().getSize2D() * 1 / 5);
      g.setColor(this.getAppearance().getForeColor());
      g.fill(cursor);
    }
}
}
```
```java
class de.gurkenlabs.litiengine.entities.Prop {
public Prop(
      final Point2D location, @Nullable final String spritesheetName, final Material material) {
    super();
    this.rotation = Rotation.NONE;
    this.spritesheetName = spritesheetName;
    this.material = material;
    this.setLocation(location);
    this.updateAnimationController();
}public void setSpritesheetName(@Nullable final String spriteName) {
    this.spritesheetName = spriteName;
    this.updateAnimationController();
}
}
```
```java
class de.gurkenlabs.litiengine.tweening.Tween {
public Tween begin() {
    this.started = Game.time().now();
    this.stopped = false;
    return this;
}
}
```
```java
class de.gurkenlabs.litiengine.graphics.emitters.particles.Particle {
public void update(final Point2D emitterOrigin, final float updateRatio) {
    if (this.aliveTick == 0) {
      this.aliveTick = Game.time().now();
    }

    this.aliveTime = Game.time().since(this.aliveTick);
    if (this.timeToLiveReached()) {
      return;
    }

    if (this.colliding) {
      return;
    }

    if (this.getDeltaWidth() != 0) {
      this.width += this.getDeltaWidth() * updateRatio;
    }

    if (this.getDeltaHeight() != 0) {
      this.height += this.getDeltaHeight() * updateRatio;
    }

    if (this.getDeltaAngle() != 0) {
      this.angle += this.getDeltaAngle() * updateRatio;
    }

    // test for ray cast collision
    final float targetX = this.x + this.getVelocityX() * updateRatio;
    final float targetY = this.y + this.getVelocityY() * updateRatio;

    if (targetX == this.x && targetY == this.y) {
      return;
    }

    if (this.checkForCollision(emitterOrigin, targetX, targetY)) {
      return;
    }

    if (this.getVelocityX() != 0) {
      this.x = targetX;
    }

    if (this.getVelocityY() != 0) {
      this.y = targetY;
    }

    if (this.getAccelerationX() != 0) {
      this.velocityX += this.getAccelerationX() * updateRatio;
    }

    if (this.getAccelerationY() != 0) {
      this.velocityY += this.getAccelerationY() * updateRatio;
    }
}
}
```
```java
class de.gurkenlabs.litiengine.graphics.animation.Animation {
@Override
  public void start() {
    this.playing = true;
    if (this.getKeyframes().isEmpty()) {
      return;
    }

    this.restart();
}@Override
  public void update() {
    // do nothing if the animation is not playing or the current keyframe is not finished
    if (!this.isPlaying()
        || Game.time().since(this.lastFrameUpdate) < this.getCurrentKeyFrame().getDuration()) {
      return;
    }

    // if we are not looping and the last keyframe is finished, we terminate the animation
    if (!this.isLooping() && this.isLastKeyFrame()) {
      this.terminate();
      return;
    }

    // make sure, we stay inside the keyframe list
    final int newFrameIndex =
        (this.getKeyframes().indexOf(this.currentFrame) + 1) % this.getKeyframes().size();
    final KeyFrame previousFrame = this.currentFrame;
    this.currentFrame = this.getKeyframes().get(newFrameIndex);

    for (KeyFrameListener listener : this.listeners) {
      listener.currentFrameChanged(previousFrame, this.currentFrame);
    }

    this.lastFrameUpdate = Game.loop().getTicks();
}
}
```
```java
class de.gurkenlabs.litiengine.graphics.animation.AnimationController {
@Override
  public void update() {
    for (final Animation animation : this.getAll()) {
      animation.update();
    }

    if (this.getCurrent() != null && this.getCurrent().isPaused()) {
      return;
    }

    final boolean playbackFinished = this.getCurrent() != null && !this.getCurrent().isPlaying();
    if (playbackFinished) {
      for (final AnimationListener listener : this.listeners) {
        listener.finished(this.getCurrent());
      }
    }

    if (this.getCurrent() == null || playbackFinished) {
      if (this.getDefault() != null) {
        this.play(this.getDefault().getName());
      } else {
        this.currentAnimation = null;
      }
    }
}
}
```
```java
class de.gurkenlabs.litiengine.graphics.RenderComponent {
private void handleFade() {
    if (this.fadeOutStart != -1) {
      final long timePassed = Game.time().since(this.fadeOutStart);
      this.currentAlpha = MathUtilities.clamp(1 - timePassed / (float) this.fadeOutTime, 0, 1);
      if (this.currentAlpha == 0f) {
        this.fadeOutStart = -1;
        this.fadeOutTime = -1;
      }

      return;
    }

    if (this.fadeInStart != -1) {
      final long timePassed = Game.time().since(this.fadeInStart);
      this.currentAlpha = MathUtilities.clamp(timePassed / (float) this.fadeInTime, 0, 1);
      if (this.currentAlpha == 1f) {
        this.fadeInStart = -1;
        this.fadeInTime = -1;
        this.currentAlpha = Float.NaN;
      }
    }
}public void fadeOut(final int ms) {
    this.fadeInStart = -1;
    this.fadeInTime = -1;
    this.fadeOutStart = Game.time().now();
    this.fadeOutTime = ms;
}public void fadeIn(final int ms) {
    this.fadeOutStart = -1;
    this.fadeOutTime = -1;
    this.fadeInStart = Game.time().now();
    this.fadeInTime = ms;
}
}
```
```java
class de.gurkenlabs.litiengine.entities.Trigger {
private boolean activate(final IEntity activator, final int tar) {
    if (!this.isLoaded()
        || this.isOneTimeTrigger && this.isActivated
        || this.getActivationType() == TriggerActivation.COLLISION
            && activator != null
            && this.collisionActivated.contains(activator)) {
      return false;
    }

    if (this.getCooldown() > 0 && Game.time().since(this.lastActivation) < this.getCooldown()) {
      return false;
    }

    List<Integer> triggerTargets = this.getTargets(tar);

    final TriggerEvent te = new TriggerEvent(this, activator, triggerTargets);

    if (!this.checkActivationPredicates(te)) {
      return false;
    }

    this.isActivated = true;
    if (activator != null) {
      this.collisionActivated.add(activator);
    }

    // if we actually have a trigger target, we send the message to the target
    for (final int target : triggerTargets) {
      final IEntity entity = this.getEnvironment().get(target);
      if (entity == null) {
        log.log(
            Level.WARNING,
            "trigger [{0}] was activated, but the trigger target [{1}] could not be found on the environment",
            new Object[] {this, target});
        continue;
      }

      entity.sendMessage(this, this.message);
    }

    // also send the trigger event to all registered consumers
    for (final TriggerActivatedListener listener : this.activatedListeners) {
      listener.activated(te);
    }

    if (this.isOneTimeTrigger) {
      this.getEnvironment().remove(this);
    }

    this.lastActivation = Game.time().now();
    return true;
}
}
```
```java
class de.gurkenlabs.litiengine.graphics.Camera {
private boolean isShakeEffectActive() {
    return this.getShakeTick() != 0
        && Game.time().since(this.getShakeTick()) < this.getShakeDuration();
}@Override
  public void update() {
    if (Game.world().camera() != null && !Game.world().camera().equals(this)) {
      return;
    }

    if (this.targetZoom > 0) {
      if (Game.time().since(this.zoomTick) >= this.zoomDelay) {
        this.zoom = this.targetZoom;
        this.targetZoom = 0;
        this.zoomDelay = 0;
        this.zoomTick = 0;
        this.zoomStep = 0;
      } else {
        this.zoom += this.zoomStep;
      }

      final ZoomChangedEvent event = new ZoomChangedEvent(this, this.getZoom());
      for (final ZoomChangedListener listener : this.zoomListeners) {
        listener.zoomChanged(event);
      }
    }

    if (this.panTime > 0) {
      if (--this.panTime <= 0) {
        this.setFocus(this.targetFocus);
        this.targetFocus = null;
      } else {
        double diff = this.panTime / (this.panTime + 1.0);
        this.focus =
            new Point2D.Double(
                this.focus.getX() * diff + this.targetFocus.getX() * (1.0 - diff),
                this.focus.getY() * diff + this.targetFocus.getY() * (1.0 - diff));
      }
    }

    if (!this.isShakeEffectActive()) {
      this.shakeOffsetX = 0;
      this.shakeOffsetY = 0;
      return;
    }

    if (Game.time().since(this.lastShake) > this.shakeDelay) {
      this.shakeOffsetX = this.getShakeIntensity() * ThreadLocalRandom.current().nextGaussian();
      this.shakeOffsetY = this.getShakeIntensity() * ThreadLocalRandom.current().nextGaussian();
      this.lastShake = Game.time().now();
    }
}@Override
  public void setZoom(final float targetZoom, final int delay) {
    if (delay == 0) {

      this.zoom = targetZoom;
      this.targetZoom = 0;
      this.zoomDelay = 0;
      this.zoomTick = 0;
      this.zoomStep = 0;

      final ZoomChangedEvent event = new ZoomChangedEvent(this, targetZoom);
      for (final ZoomChangedListener listener : this.zoomListeners) {
        listener.zoomChanged(event);
      }
    } else {
      this.zoomTick = Game.time().now();
      this.targetZoom = targetZoom;
      this.zoomDelay = delay;

      final double tickduration = 1000 / (double) Game.loop().getTickRate();
      final double tickAmount = delay / tickduration;
      final float totalDelta = this.targetZoom - this.zoom;
      this.zoomStep = tickAmount > 0 ? (float) (totalDelta / tickAmount) : totalDelta;
    }
}@Override
  public void shake(final double intensity, final int delay, final int shakeDuration) {
    this.shakeTick = Game.time().now();
    this.shakeDelay = delay;
    this.shakeIntensity = intensity;
    this.shakeDuration = shakeDuration;
}
}
```
```java
class de.gurkenlabs.litiengine.entities.Creature {
public void setSpritesheetName(String spritesheetName) {
    if (this.spritesheetName != null && this.spritesheetName.equals(spritesheetName)) {
      return;
    }

    this.spritesheetName = spritesheetName;
    this.updateAnimationController();
}public boolean isIdle() {
    return Game.time().since(this.lastMoved) > IDLE_DELAY;
}@Override
  public void setLocation(final Point2D position) {
    if (this.isDead() || position == null) {
      return;
    }

    final Point2D oldLocation = this.getLocation();
    super.setLocation(position);

    if (Game.hasStarted() && this.isLoaded()) {
      this.lastMoved = Game.time().now();
      this.fireMovedEvent(
          new EntityMovedEvent(
              this, this.getX() - oldLocation.getX(), this.getY() - oldLocation.getY()));
    }
}
}
```
```java
class de.gurkenlabs.litiengine.gui.screens.ScreenManager {
public void display(final String screenName) {
    if (this.current() != null && this.current().getName().equalsIgnoreCase(screenName)) {
      log.log(
          Level.INFO,
          "Skipping displaying of screen {0} because it is already the current screen.",
          screenName);
      return;
    }

    if (this.screens.stream()
        .noneMatch(element -> element.getName().equalsIgnoreCase(screenName))) {
      log.log(
          Level.WARNING,
          "Could not display the screen {0} because there is no screen with the specified name.",
          screenName);
      return;
    }

    Screen screen = this.get(screenName);
    if (screen == null) {
      return;
    }

    this.display(screen);
}public void add(final Screen screen) {
    screen.setWidth(Game.window().getWidth());
    screen.setHeight(Game.window().getHeight());
    this.screens.add(screen);

    if (this.current() == null) {
      this.display(screen);
    }
}public void remove(Screen screen) {
    this.screens.remove(screen);
    if (this.current() == screen) {
      if (!this.screens.isEmpty()) {
        this.display(this.screens.get(0));
      } else {
        this.display((Screen) null);
      }
    }
}public void display(@Nullable final Screen screen) {
    if (Game.hasStarted() && Game.time().since(this.lastScreenChange) < this.getChangeCooldown()) {
      log.log(
          Level.INFO,
          "Skipping displaying of screen {0} because screen changing is currently on cooldown.",
          screen != null ? screen.getName() : "");
      return;
    }

    final Screen previous = this.current();
    if (previous != null) {
      previous.suspend();
    }

    if (screen != null && !this.screens.contains(screen)) {
      this.screens.add(screen);
    }

    this.currentScreen = screen;
    if (!Game.isInNoGUIMode() && this.current() != null) {
      this.current().prepare();
    }

    this.lastScreenChange = Game.loop().getTicks();

    final ScreenChangedEvent event = new ScreenChangedEvent(this.current(), previous);
    for (final ScreenChangedListener listener : this.screenChangedListeners) {
      listener.changed(event);
    }
}
}
```
```java
class de.gurkenlabs.litiengine.abilities.Ability {
public boolean isOnCooldown() {
    return (this.getCurrentExecution() != null
        && this.getCurrentExecution().getExecutionTicks() > 0
        && Game.time().since(this.getCurrentExecution().getExecutionTicks())
            < this.getAttributes().cooldown().get());
}public boolean isActive() {
    return this.getCurrentExecution() != null
        && Game.time().since(this.getCurrentExecution().getExecutionTicks())
            < this.getAttributes().duration().get();
}@Nullable
  public AbilityExecution cast() {
    if (!this.canCast()) {
      return null;
    }
    this.currentExecution = new AbilityExecution(this);

    for (final AbilityCastListener listener : this.abilityCastListeners) {
      listener.abilityCast(this.currentExecution);
    }

    return this.getCurrentExecution();
}public float getRemainingCooldownInSeconds() {
    if (this.getCurrentExecution() == null
        || this.getExecutor() == null
        || this.getExecutor().isDead()) {
      return 0;
    }

    // calculate cooldown in seconds
    return (float)
        (!this.canCast()
            ? (this.getAttributes().cooldown().get()
                    - Game.time().since(this.getCurrentExecution().getExecutionTicks()))
                * 0.001
            : 0);
}
}
```
```java
class de.gurkenlabs.litiengine.entities.EntityHitEvent {
EntityHitEvent(
      final ICombatEntity hitEntity,
      @Nullable final Ability ability,
      final int damage,
      final boolean kill) {
    super(hitEntity);
    this.executor = ability != null ? ability.getExecutor() : null;
    this.hitEntity = hitEntity;
    this.ability = ability;
    this.damage = damage;
    this.kill = kill;
    this.time = Game.time().now();
}
}
```
```java
class de.gurkenlabs.litiengine.graphics.emitters.Emitter {
public void delete() {
    this.deactivate();
    if (Game.world().environment() != null) {
      Game.world().environment().remove(this);
    }
}public void activate() {
    if (this.activated) {
      return;
    }

    this.activated = true;
    this.activationTick = Game.time().now();
    Game.loop().attach(this);
}@Override
  public void update() {
    if (this.isPaused()) {
      return;
    }

    // clear particles if the effect time to life is reached
    if (this.isFinished()) {
      for (EmitterFinishedListener listener : this.finishedListeners) {
        listener.finished(this);
      }

      this.delete();
      return;
    }

    final float updateRatio = (float) this.data().getUpdateRate() / Game.loop().getTickRate();
    for (final Particle p : this.getParticles().stream().collect(Collectors.toList())) {
      if (this.particleCanBeRemoved(p)) {
        // remove dead particles
        this.particles.remove(p);
        continue;
      }

      p.update(this.getOrigin(), updateRatio);
    }

    this.aliveTime = Game.time().since(this.activationTick);
    if ((this.data().getSpawnRate() == 0
        || Game.time().since(this.lastSpawn) >= this.data().getSpawnRate())) {
      this.lastSpawn = Game.time().now();
      this.spawnParticle();
    }
}
}
```
```java
class de.gurkenlabs.litiengine.GameLoop {
@Override
  public int perform(int delay, Runnable action) {
    final long d = Game.time().toTicks(delay);

    TimedAction a = new TimedAction(this.getTicks() + d, action);
    this.actions.add(a);

    return a.getId();
}
}
```
```java
class de.gurkenlabs.litiengine.environment.EntitySpawner {
protected boolean shouldSpawn() {
    return this.lastSpawnWave == 0
        || Game.time().since(this.lastSpawnWave) >= this.getSpawnInterval();
}@Override
  public void update() {
    if (!this.shouldSpawn()) {
      return;
    }

    this.spawnNewEntities();
    this.lastSpawnWave = Game.time().now();
}
}
```
```java
class de.gurkenlabs.litiengine.graphics.FreeFlightCamera {
@Override
  public void update() {
    this.handleFreeFlightCamera();
}public FreeFlightCamera(double x, double y) {
    this(new Point2D.Double(x, y));
}
}
```
```java
class de.gurkenlabs.litiengine.environment.Environment {
public void unload() {
    if (!this.loaded) {
      return;
    }

    // unregister all updatable entities from the current environment
    for (final IEntity entity : this.allEntities.values()) {
      this.unload(entity);
    }

    this.loaded = false;
    this.fireEvent(l -> l.unloaded(this));
}private static void loadUpdatableOrEmitterEntity(IEntity entity) {
    if (entity instanceof Emitter) {
      final Emitter emitter = (Emitter) entity;
      if (emitter.isActivateOnInit()) {
        emitter.activate();
      }
    } else if (entity instanceof IUpdateable) {
      Game.loop().attach((IUpdateable) entity);
    }
}public void clear() {
    Game.physics().clear();

    this.combatEntities.clear();
    this.mobileEntities.clear();
    this.gravityForces.clear();
    this.layerEntities.clear();
    this.entitiesByTag.clear();
    this.allEntities.clear();

    for (RenderType renderType : RenderType.values()) {
      this.miscEntities.get(renderType).clear();
      this.renderListeners.get(renderType).clear();
      this.renderables.get(renderType).clear();
    }

    dispose(this.allEntities.values());
    dispose(this.triggers);
    this.emitters.clear();
    this.colliders.clear();
    this.props.clear();
    this.creatures.clear();
    this.staticShadows.clear();
    this.combatEntities.clear();
    this.mobileEntities.clear();
    this.lightSources.clear();
    this.spawnPoints.clear();
    this.soundSources.clear();
    this.mapAreas.clear();
    this.triggers.clear();

    this.ambientLight = null;
    this.staticShadowLayer = null;

    for (Map<Integer, IEntity> type : this.miscEntities.values()) {
      type.clear();
    }

    this.initialized = false;

    this.fireEvent(l -> l.cleared(this));
}private void load(final IEntity entity) {
    // an entity can only exist on one environment at a time, so remove it from the current one
    if (entity.getEnvironment() != null) {
      entity.getEnvironment().remove(entity);
    }

    // 1. add to physics engine
    loadPhysicsEntity(entity);

    // 2. register for update or activate
    loadUpdatableOrEmitterEntity(entity);

    // 3. if a gravity is defined, add a gravity force to the entity
    if (entity instanceof IMobileEntity && this.getGravity() != 0) {
      this.addGravityForce((IMobileEntity) entity);
    }

    // 4. attach all controllers
    entity.attachControllers();

    if (this.loaded && (entity instanceof LightSource || entity instanceof StaticShadow)) {
      this.updateLighting(entity);
    }

    entity.loaded(this);
}private void unload(final IEntity entity) {
    // 1. remove from physics engine
    if (entity instanceof ICollisionEntity) {
      Game.physics().remove((ICollisionEntity) entity);
    }

    // 2. unregister from update
    if (entity instanceof IUpdateable) {
      Game.loop().detach((IUpdateable) entity);
    }

    if (entity instanceof IMobileEntity) {
      this.removeGravity((IMobileEntity) entity);
    }

    // 3. detach all controllers
    entity.detachControllers();

    if (entity instanceof Emitter) {
      Emitter em = (Emitter) entity;
      em.deactivate();
    }

    if (this.loaded && (entity instanceof LightSource || entity instanceof StaticShadow)) {
      this.updateLighting(entity);
    }

    entity.removed(this);
}public void remove(final IEntity entity) {
    if (entity == null) {
      return;
    }

    this.allEntities.remove(entity.getMapId());
    Iterator<List<IEntity>> iter = this.layerEntities.values().iterator();
    while (iter.hasNext()) {
      List<IEntity> layer = iter.next();
      if (layer.remove(entity) && layer.isEmpty()) {
        iter.remove();
      }
    }
    if (this.miscEntities.get(entity.getRenderType()) != null) {
      this.miscEntities.get(entity.getRenderType()).values().remove(entity);
    }

    for (String tag : entity.getTags()) {
      if (this.getEntitiesByTag().containsKey(tag)) {
        this.getEntitiesByTag().get(tag).remove(entity);

        if (this.getEntitiesByTag().get(tag).isEmpty()) {
          this.getEntitiesByTag().remove(tag);
        }
      }
    }

    if (entity instanceof Emitter) {
      Emitter emitter = (Emitter) entity;
      this.removeEmitter(emitter);
    }

    if (entity instanceof MapArea) {
      this.mapAreas.remove(entity);
    }

    if (entity instanceof Prop) {
      this.props.remove(entity);
    }

    if (entity instanceof Creature) {
      this.creatures.remove(entity);
    }

    if (entity instanceof CollisionBox) {
      this.colliders.remove(entity);
      this.staticShadows.removeIf(x -> x.getOrigin() != null && x.getOrigin().equals(entity));
    }

    if (entity instanceof LightSource) {
      this.lightSources.remove(entity);
      this.updateLighting(entity);
    }

    if (entity instanceof Trigger) {
      this.triggers.remove(entity);
    }

    if (entity instanceof Spawnpoint) {
      this.spawnPoints.remove(entity);
    }
    if (entity instanceof SoundSource) {
      this.soundSources.remove(entity);
    }

    if (entity instanceof StaticShadow) {
      this.staticShadows.remove(entity);
      this.updateLighting(entity);
    }

    if (entity instanceof IMobileEntity) {
      this.mobileEntities.values().remove(entity);
    }

    if (entity instanceof ICombatEntity) {
      this.combatEntities.values().remove(entity);
    }

    this.unload(entity);

    this.fireEntityEvent(l -> l.entityRemoved(entity));
}
}
```
```java
class de.gurkenlabs.litiengine.physics.MovementController {
@Override
  public void update() {
    this.handleForces();
    this.handleMovement();
}
}
```
```java
class de.gurkenlabs.litiengine.Game {
static synchronized void terminate() {
    if (!initialized) {
      return;
    }

    hasStarted = false;
    initialized = false;

    config().save();
    gameLoop.terminate();
    tweenEngine.terminate();
    soundEngine.terminate();

    world().clear();

    for (final GameListener listener : gameListeners) {
      try {
        listener.terminated();
      } catch (Exception e) {
        log().log(Level.WARNING, "game listener threw an exception during shutdown", e);
      }
    }

    gameLoop = null;
    screenManager = null;
    gameWindow = null;
}public static synchronized void start() {
    if (!initialized) {
      throw new IllegalStateException(
          "The game cannot be started without being first initialized. Call Game.init(...) before Game.start().");
    }

    gameLoop.start();
    tweenEngine.start();
    soundEngine.start();

    for (final GameListener listener : gameListeners) {
      listener.started();
    }

    hasStarted = true;
}public static synchronized void init(String... args) {
    if (initialized) {
      log().log(Level.INFO, "The game has already been initialized.");
      return;
    }

    log.init();
    handleCommandLineArguments(args);

    config().load();
    Locale.setDefault(new Locale(config().client().getCountry(), config().client().getLanguage()));

    gameLoop = new GameLoop("Main Update Loop", config().client().getMaxFps());
    loop().attach(physics());
    loop().attach(world());

    // setup default exception handling for render and update loop
    setUncaughtExceptionHandler(
        new DefaultUncaughtExceptionHandler(config().client().exitOnError()));

    screenManager = new ScreenManager();
    gameWindow = new GameWindow();

    // initialize  the game window
    window().init();
    world.setCamera(new Camera());

    for (GameListener listener : gameListeners) {
      listener.initialized(args);
    }

    if (!isInNoGUIMode()) {
      window().getRenderComponent().onRendered(g -> metrics().render(g));

      graphics()
          .addEntityRenderedListener(
              e -> DebugRenderer.renderEntityDebugInfo(e.getGraphics(), e.getEntity()));

      window().getRenderComponent().onFpsChanged(fps -> metrics().setFramesPerSecond(fps));
      window()
          .setIcons(
              Arrays.asList(
                  Resources.images().get("liti-logo-x16.png"),
                  Resources.images().get("liti-logo-x20.png"),
                  Resources.images().get("liti-logo-x32.png"),
                  Resources.images().get("liti-logo-x48.png")));

      Input.keyboard()
          .onKeyTyped(
              KeyEvent.VK_PRINTSCREEN,
              key -> {
                // don't take a screenshot if a modifier is active
                if (key.getModifiers() != 0) {
                  return;
                }

                window().getRenderComponent().takeScreenshot();
              });
    }

    Runtime.getRuntime().addShutdownHook(new Thread(Game::terminate, "Shutdown"));

    initialized = true;
}
}
```


Response Format:
Provide the answer in **XML format** as follows:

#### If the method **cannot** return `null` at the specific call site:
```xml
<response>
  <reason><![CDATA[EXPLAIN WHY THE INVOCATION Game.loop() RESULT CANNOT BE NULL.]]></reason>
  <value>NO</value>
</response>

#### If the method can return null at the specific call site:
<response>
  <reason><![CDATA[EXPLAIN WHY THE INVOCATION Game.loop() RESULT CAN BE NULL.]]></reason>
  <value>YES</value>
</response>

#### If you are unsure or If there are any methods that directly or indirectly affect the return value and are not fully disclosed, request their declarations first, in the following format:
<response>
  <reason><![CDATA[EXPLAIN WHY THIS METHOD DECLARATION IS NECESSARY AND WHY YOU CANNOT MAKE A CONFIDENT DECISION WITHOUT IT]]></reason>
  <success>false</success>
  <methods>
    <method>methodName</method>
  </methods>
</response>

Additional Notes:
Be precise in your reasoning.
If a method’s return value depends on another method not provided, request its declaration before making a conclusion.
If the method can return null in this case but not in others, explain why it happens specifically for this call.

---ChatGPT.sendRequestToOpenAI---
Retrieving response from cache
---Response.<init>---
Creating Response:
```xml
<response>
  <reason><![CDATA[The method `Game.loop()` returns the static field `gameLoop`, which is initialized in the `Game.init(String... args)` method. In this method, a new `GameLoop` object is instantiated and assigned to `gameLoop`. Since `init()` must be called before `start()`, which is implied by the requirement of initializing the game, the `gameLoop` is guaranteed to be non-null during the lifetime of the game execution where `Game.loop()` is called. The absence of any code that could set `gameLoop` to null after its initialization ensures that `Game.loop()` cannot return null.]]></reason>
  <value>NO</value>
</response>
```
---Response.<init>---
Response created:
Disagreement: The method `Game.loop()` returns the static field `gameLoop`, which is initialized in the `Game.init(String... args)` method. In this method, a new `GameLoop` object is instantiated and assigned to `gameLoop`. Since `init()` must be called before `start()`, which is implied by the requirement of initializing the game, the `gameLoop` is guaranteed to be non-null during the lifetime of the game execution where `Game.loop()` is called. The absence of any code that could set `gameLoop` to null after its initialization ensures that `Game.loop()` cannot return null.
---AdvancedNullAwayCodeFix.resolveMethodDereferenceError---
Method is not returning nullable on call site. Injecting suppression annotation.
---AdvancedNullAwayCodeFix.constructCastToNonnullChange---
Constructing cast to nonnull change for reason: The method `Game.loop()` returns the static field `gameLoop`, which is initialized in the `Game.init(String... args)` method. In this method, a new `GameLoop` object is instantiated and assigned to `gameLoop`. Since `init()` must be called before `start()`, which is implied by the requirement of initializing the game, the `gameLoop` is guaranteed to be non-null during the lifetime of the game execution where `Game.loop()` is called. The absence of any code that could set `gameLoop` to null after its initialization ensures that `Game.loop()` cannot return null.
---ChatGPT.ask---
Asking ChatGPT:
For the reason you mentioned earlier:

"The method `Game.loop()` returns the static field `gameLoop`, which is initialized in the `Game.init(String... args)` method. In this method, a new `GameLoop` object is instantiated and assigned to `gameLoop`. Since `init()` must be called before `start()`, which is implied by the requirement of initializing the game, the `gameLoop` is guaranteed to be non-null during the lifetime of the game execution where `Game.loop()` is called. The absence of any code that could set `gameLoop` to null after its initialization ensures that `Game.loop()` cannot return null."

in the method below, the expression Game.loop() is not nullable at the point it is used.

```java
@Override
  public void setZoom(final float targetZoom, final int delay) {
    if (delay == 0) {

      this.zoom = targetZoom;
      this.targetZoom = 0;
      this.zoomDelay = 0;
      this.zoomTick = 0;
      this.zoomStep = 0;

      final ZoomChangedEvent event = new ZoomChangedEvent(this, targetZoom);
      for (final ZoomChangedListener listener : this.zoomListeners) {
        listener.zoomChanged(event);
      }
    } else {
      this.zoomTick = Game.time().now();
      this.targetZoom = targetZoom;
      this.zoomDelay = delay;

      final double tickduration = 1000 / (double) Game.loop().getTickRate();
      final double tickAmount = delay / tickduration;
      final float totalDelta = this.targetZoom - this.zoom;
      this.zoomStep = tickAmount > 0 ? (float) (totalDelta / tickAmount) : totalDelta;
    }
}
```
Please Summarize the reason in max 5 words and rewrite the method so that at the line "      final double tickduration = 1000 / (double) Game.loop().getTickRate();", at the occurrence of: "Game.loop()" is replaced with `NullabilityUtil.castToNonnull(Game.loop(), summary of reason)`
Replace "REASON" with the exact reason summary I provide to you (maximum 5 words), not with a generic explanation like "checked to be nonnull".
see the example below, for expression `foo.getBar()`, to wrap it with `NullabilityUtil.castToNonnull(foo.getBar(), "reason")`.

```java
public t(){
    String l = foo.getBar();
}
```

will be:
```java
public t(){
    String l = NullabilityUtil.castToNonnull(foo.getBar(), "checked to be nonnull");
}
```

### Instructions:

Do not import any additional classes.

Do not add Java comments.

Only modify relevant lines as required.

Return only the modified method wrapped in the XML format shown below.

Place the Java code inside the <code> tag using a CDATA block with ```java formatting.

Just give me the fixed code snippet in XML format in <response> tag like the example below. I will apply the fix to my codebase. Do not import any additional libraries or classes or add java comments. If you can provide the fixed code snippet, please provide it in the following format and place the code snippet in the <code> tag within ```java block.
<response>
  <success>true</success>
  <code><![CDATA[
  ```java
  Your fixed code snippet here
  ```
    ]]>
  </code>
</response>

---ChatGPT.sendRequestToOpenAI---
Retrieving response from cache
---Response.<init>---
Creating Response:
<response>
  <success>true</success>
  <code><![CDATA[
  ```java
@Override
  public void setZoom(final float targetZoom, final int delay) {
    if (delay == 0) {

      this.zoom = targetZoom;
      this.targetZoom = 0;
      this.zoomDelay = 0;
      this.zoomTick = 0;
      this.zoomStep = 0;

      final ZoomChangedEvent event = new ZoomChangedEvent(this, targetZoom);
      for (final ZoomChangedListener listener : this.zoomListeners) {
        listener.zoomChanged(event);
      }
    } else {
      this.zoomTick = Game.time().now();
      this.targetZoom = targetZoom;
      this.zoomDelay = delay;

      final double tickduration = 1000 / (double) NullabilityUtil.castToNonnull(Game.loop(), "initialized before use").getTickRate();
      final double tickAmount = delay / tickduration;
      final float totalDelta = this.targetZoom - this.zoom;
      this.zoomStep = tickAmount > 0 ? (float) (totalDelta / tickAmount) : totalDelta;
    }
}
  ```
    ]]>
  </code>
</response>
---Response.<init>---
Response created:
@Override
  public void setZoom(final float targetZoom, final int delay) {
    if (delay == 0) {

      this.zoom = targetZoom;
      this.targetZoom = 0;
      this.zoomDelay = 0;
      this.zoomTick = 0;
      this.zoomStep = 0;

      final ZoomChangedEvent event = new ZoomChangedEvent(this, targetZoom);
      for (final ZoomChangedListener listener : this.zoomListeners) {
        listener.zoomChanged(event);
      }
    } else {
      this.zoomTick = Game.time().now();
      this.targetZoom = targetZoom;
      this.zoomDelay = delay;

      final double tickduration = 1000 / (double) NullabilityUtil.castToNonnull(Game.loop(), "initialized before use").getTickRate();
      final double tickAmount = delay / tickduration;
      final float totalDelta = this.targetZoom - this.zoom;
      this.zoomStep = tickAmount > 0 ? (float) (totalDelta / tickAmount) : totalDelta;
    }
}
---ChatGPT.fixDereferenceByAddingCastToNonnull---
Fixing the error by adding castToNonnull
---AdvancedNullAwayCodeFix.fixTriggeredErrorsForLocation---
Resolving unresolvable error for triggered error: Type='DEREFERENCE_NULLABLE', message='dereferenced expression Game.loop() is @Nullable'
/home/nima/Developer/nullness-benchmarks/litiengine/src/de/gurkenlabs/litiengine/GameWindow.java:396
            Game.loop().setTickRate(Game.config().client().getMaxFps());
---AdvancedNullAwayCodeFix.fix---
Fixing error: Type='DEREFERENCE_NULLABLE', message='dereferenced expression Game.loop() is @Nullable'
/home/nima/Developer/nullness-benchmarks/litiengine/src/de/gurkenlabs/litiengine/GameWindow.java:396
            Game.loop().setTickRate(Game.config().client().getMaxFps());
---AdvancedNullAwayCodeFix.resolveDereferenceError---
Resolving dereference error: Type='DEREFERENCE_NULLABLE', message='dereferenced expression Game.loop() is @Nullable'
/home/nima/Developer/nullness-benchmarks/litiengine/src/de/gurkenlabs/litiengine/GameWindow.java:396
            Game.loop().setTickRate(Game.config().client().getMaxFps());
---AdvancedNullAwayCodeFix.resolveDereferenceError---
Checking nullability possibility at error point
---ChatGPT.checkNullabilityPossibilityAtErrorPoint---
Asking if the expression can be null at error point point
---ChatGPT.ask---
Asking ChatGPT:
In the method below, is there a possibility that the expression "Game.loop()" at line "Game.loop().setTickRate(Game.config().client().getMaxFps());" is null?
@Override
          public void windowGainedFocus(WindowEvent e) {
            Game.loop().setTickRate(Game.config().client().getMaxFps());
}
Give a single-word answer in XML format. If it is possible for the expression to be null, respond with:
```xml
<response>
    <reason><![CDATA[YOUR REASON]]></reason>
    <value>YES</value>
</response>
```
If it is not possible for the expression to be null, respond with:
```xml
<response>
    <reason><![CDATA[YOUR REASON]]></reason>
    <value>NO</value>
</response>
```
If you are unsure or need more information, respond with where you can ask for more details or what specific information you need.

If additional information is required, list each request inside a `<request>` tag. If no additional information is needed, omit the `<requests>` section.

Respond with:
```xml
<response>
    <reason><![CDATA[YOUR REASON]]></reason>
    <value>UNKNOWN</value>
    <!-- Include <requests> only if additional information is needed -->
    <requests>
        <request><![CDATA[YOUR REQUEST 1]]></request>
        <request><![CDATA[YOUR REQUEST 2]]></request>
    </requests>
</response>
```
---ChatGPT.sendRequestToOpenAI---
Retrieving response from cache
---Response.<init>---
Creating Response:
```xml
<response>
    <reason><![CDATA[It is impossible to definitively determine from the provided information alone if Game.loop() can return null. This depends on the implementation details of the Game class, specifically how the loop() method is implemented and under what conditions it might return null.]]></reason>
    <value>UNKNOWN</value>
    <requests>
        <request><![CDATA[Provide the implementation details of the Game.loop() method.]]></request>
        <request><![CDATA[Are there any checks or guarantees within the codebase ensuring that Game.loop() cannot return null?]]></request>
    </requests>
</response>
```
---Response.<init>---
Response created:
Unknown: It is impossible to definitively determine from the provided information alone if Game.loop() can return null. This depends on the implementation details of the Game class, specifically how the loop() method is implemented and under what conditions it might return null.
---AdvancedNullAwayCodeFix.resolveMethodDereferenceError---
Resolving method dereference error.
---AdvancedNullAwayCodeFix.resolveMethodDereferenceError---
Method is in annotated package. Checking if the method is returning nullable.
---AdvancedNullAwayCodeFix.investigateMethodReturnNullability---
Checking if the method is returning nullable.
---ChatGPT.checkIfMethodIsReturningNullable---
Asking if the method is returning nullable: loop()
---ChatGPT.ask---
Asking ChatGPT:
In the method below, is there a possibility that the method returns null based only on its body? Consider the following points:

- The method may have multiple return paths; consider all return statements.
- If the method calls another method, do not assume its return value unless its full declaration is provided. Request its declaration if needed.
- The method may throw an exception instead of returning null. An exception path should not be considered a null return.
- Ensure you request the declarations of any methods whose return values directly or indirectly impact this method’s return value before making a conclusion.
- Carefully analyze all conditions and prior operations that may guarantee a non-null return value.

@Nullable public static IGameLoop loop() {
    return gameLoop;
}

Here are the method definitions in addition to the method inquired:

Depth: 0
```java
class de.gurkenlabs.litiengine.Game {
@Nullable public static IGameLoop loop() {
    return gameLoop;
}
}
```


Response Format:
Provide the answer in **XML format** as follows:

#### If the method **cannot** return `null`:
```xml
<response>
  <reason><![CDATA[EXPLAIN WHY THE METHOD CANNOT RETURN NULL]]></reason>
  <value>NO</value>
</response>
```

#### If the method can return null:
```xml
<response>
  <reason><![CDATA[EXPLAIN WHY THE METHOD CAN RETURN NULL]]></reason>
  <value>YES</value>
</response>
```

#### If you are unsure or need more information, respond with where you can ask for more details or what specific information you need.

#### If you are unsure or If there are any methods that directly or indirectly affect the return value and are not fully disclosed, request their declarations first, in the following format:
<response>
  <reason><![CDATA[YOUR REASON]]></reason>
  <value>UNKNOWN</value>
  <methods>
    <method>methodName</method>
  </methods>
</response>

If additional information is required other than method declaration, list each request inside a `<request>` tag. If no additional information is needed, omit the `<requests>` section.

Respond with:
```xml
<response>
    <reason><![CDATA[YOUR REASON]]></reason>
    <value>UNKNOWN</value>
    <!-- Include <requests> only if additional information is needed -->
    <requests>
        <request><![CDATA[YOUR REQUEST 1]]></request>
        <request><![CDATA[YOUR REQUEST 2]]></request>
    </requests>
</response>
```

Additional Notes:
Be precise in your reasoning.
If a method’s return value depends on another method not provided, request its declaration before making a conclusion.
If the method can return null in some cases but not others, explain under what conditions it can happen.

---ChatGPT.sendRequestToOpenAI---
Retrieving response from cache
---Response.<init>---
Creating Response:
```xml
<response>
  <reason><![CDATA[The method `loop` returns the variable `gameLoop`. Without the initialization or assignment details of `gameLoop`, it's unclear whether it can be null. The possibility of `gameLoop` being uninitialized or set to null elsewhere in the program means `loop` could potentially return null. Further information on `gameLoop` is required.]]></reason>
  <value>UNKNOWN</value>
  <requests>
    <request><![CDATA[Please provide the declaration and initialization of the variable `gameLoop` in the class `de.gurkenlabs.litiengine.Game`.]]></request>
  </requests>
</response>
```
---Response.<init>---
Response created:
Unknown: The method `loop` returns the variable `gameLoop`. Without the initialization or assignment details of `gameLoop`, it's unclear whether it can be null. The possibility of `gameLoop` being uninitialized or set to null elsewhere in the program means `loop` could potentially return null. Further information on `gameLoop` is required.
---AdvancedNullAwayCodeFix.investigateMethodReturnNullability---
Could not determine the nullability and model did not ask for any method.
---ChatGPT.checkIfMethodIsReturningNullableOnCallSite---
Asking if the method is returning nullable on the call site: Game.loop()
---ChatGPT.ask---
Asking ChatGPT:
In the method below, is there a possibility that the method returns null at the given call site?

```java
@Nullable public static IGameLoop loop() {
    return gameLoop;
}
```

## Guidelines:
- The method may have multiple return paths; consider all return statements.
- If the method calls another method, do not assume its return value unless its full declaration is provided. Request its declaration if needed.
- The method may throw an exception instead of returning null. An exception path should not be considered a null return.
- Ensure you request the declarations of any methods whose return values directly or indirectly impact this method’s return value before making a conclusion.
- If the method returns a value that is determined by a parameter, evaluate based on the actual argument at the given call site.
- Analyze based only on the specific invocation provided. Do not generalize to all possible inputs.- If the return value is guaranteed to be non-null at the call site, the answer should be a definitive NO.
- Do not generalize based on all possible inputs—your answer must be based only on the given invocation.
- Focus only on the given call site, not all possible invocations.

### call site:
Game.loop()

Here are the method definitions and the call chain for this method, showing the sequence of calls from the method to its callers at each depth level:

Depth: 0
```java
class de.gurkenlabs.litiengine.Game {
@Nullable public static IGameLoop loop() {
    return gameLoop;
}
}
```
Depth: 1
```java
class de.gurkenlabs.litiengine.environment.GameWorld {
public void loadEnvironment(@Nullable final Environment env) {
    Lock lock = Game.loop().getLock();
    lock.lock();
    try {
      unloadEnvironment();
      this.environment = env;
      if (env != null) {
        this.addEnvironment(env);

        if (env.getGravity() == 0 && this.gravity() != 0) {
          env.setGravity(this.gravity());
        }

        env.load();
        for (final EnvironmentLoadedListener listener : this.loadedListeners) {
          listener.loaded(env);
        }

        // call map specific listeners
        String mapName = getMapName(env);
        if (mapName != null && this.environmentLoadedListeners.containsKey(mapName)) {

          // for the default camera we center the camera on the environment
          if (this.camera().getClass().equals(Camera.class)) {
            camera().setFocus(env.getCenter());
          }

          for (EnvironmentLoadedListener listener : this.environmentLoadedListeners.get(mapName)) {
            listener.loaded(env);
          }
        }
      }
    } finally {
      lock.unlock();
    }
}public void setCamera(@Nullable final ICamera cam) {
    if (this.camera() != null) {
      Game.loop().detach(camera);
    }

    camera = cam;

    if (cam != null && !Game.isInNoGUIMode()) {
      Game.loop().attach(cam);
      cam.updateFocus();
    }
}
}
```
```java
class de.gurkenlabs.litiengine.entities.behavior.EntityNavigator {
public EntityNavigator(final IMobileEntity entity, final PathFinder pathFinder) {
    this.cancelNavigationConditions = new CopyOnWriteArrayList<>();
    this.listeners = new CopyOnWriteArrayList<>();
    this.entity = entity;
    this.pathFinder = pathFinder;
    this.setAcceptableError(DEFAULT_ACCEPTABLE_ERROR);
    Game.loop().attach(this);
}
}
```
```java
class de.gurkenlabs.litiengine.GameWindow {
private static void initializeWindowEventListeners(Window window) {

    window.addWindowStateListener(
        e -> {
          if (e.getNewState() == Frame.ICONIFIED) {
            Game.loop().setTickRate(ICONIFIED_MAX_FPS);
          } else {
            Game.loop().setTickRate(Game.config().client().getMaxFps());
          }
        });

    window.addWindowFocusListener(
        new WindowFocusListener() {
          @Override
          public void windowLostFocus(WindowEvent e) {
            if (Game.config().graphics().reduceFramesWhenNotFocused()) {
              Game.loop().setTickRate(NONE_FOCUS_MAX_FPS);
            }
          }

          @Override
          public void windowGainedFocus(WindowEvent e) {
            Game.loop().setTickRate(Game.config().client().getMaxFps());
          }
        });

    window.addWindowListener(
        new WindowAdapter() {
          @Override
          public void windowClosing(final WindowEvent event) {
            Game.exit();
          }
        });
}
}
```
```java
class de.gurkenlabs.litiengine.gui.screens.ScreenManager {
public void display(@Nullable final Screen screen) {
    if (Game.hasStarted() && Game.time().since(this.lastScreenChange) < this.getChangeCooldown()) {
      log.log(
          Level.INFO,
          "Skipping displaying of screen {0} because screen changing is currently on cooldown.",
          screen != null ? screen.getName() : "");
      return;
    }

    final Screen previous = this.current();
    if (previous != null) {
      previous.suspend();
    }

    if (screen != null && !this.screens.contains(screen)) {
      this.screens.add(screen);
    }

    this.currentScreen = screen;
    if (!Game.isInNoGUIMode() && this.current() != null) {
      this.current().prepare();
    }

    this.lastScreenChange = Game.loop().getTicks();

    final ScreenChangedEvent event = new ScreenChangedEvent(this.current(), previous);
    for (final ScreenChangedListener listener : this.screenChangedListeners) {
      listener.changed(event);
    }
}
}
```
```java
class de.gurkenlabs.litiengine.abilities.effects.Effect {
@Override
  public void update() {

    for (final Iterator<EffectApplication> iterator = this.getActiveAppliances().iterator();
        iterator.hasNext(); ) {
      final EffectApplication appliance = iterator.next();
      // if the effect duration is reached
      if (this.hasEnded(appliance)) {

        iterator.remove();
        this.cease(appliance);
      }
    }

    // 4. unregister if all appliances are finished
    if (this.getActiveAppliances().isEmpty()) {
      Game.loop().detach(this);
    }
}public void apply(final Shape impactArea) {
    final List<ICombatEntity> affected = this.lookForAffectedEntities(impactArea);
    for (final ICombatEntity affectedEntity : affected) {
      this.apply(affectedEntity);
    }

    this.appliances.add(new EffectApplication(affected, impactArea));

    // if it is the first appliance -> register for update
    if (this.appliances.size() == 1) {
      Game.loop().attach(this);
    }
}
}
```
```java
class de.gurkenlabs.litiengine.GameTime {
public long toTicks(final int milliseconds) {
    return this.toTicks(milliseconds, Game.loop().getTickRate());
}public long since(final long tick) {
    return toMilliseconds(Game.loop().getTicks() - tick);
}public long now() {
    return Game.loop().getTicks();
}public long sinceGameStart() {
    return this.toMilliseconds(Game.loop().getTicks());
}@Override
  public void loaded(Environment environment) {
    environmentLoaded = Game.loop().getTicks();
}public long toMilliseconds(final long ticks) {
    return this.toMilliseconds(ticks, Game.loop().getTickRate());
}
}
```
```java
class de.gurkenlabs.litiengine.GameMetrics {
@Override
  public void render(final Graphics2D g) {
    this.updateMetrics();

    if (!Game.config().client().showGameMetrics()) {
      return;
    }

    this.currentOffsetY = 0;

    g.setColor(this.renderColor);

    // render client metrics
    this.drawTitle(g, "[client]");
    this.drawMetric(g, "fps       : " + this.getFramesPerSecond());
    this.drawMetric(g, "max fps   : " + this.maxFramesPerSecond);
    this.drawMetric(g, "updatables: " + Game.loop().getUpdatableCount());

    // render jvm metrics if debug is enabled
    if (Game.config().debug().isDebugEnabled()) {
      this.drawTitle(g, "[jvm]");
      this.drawMetric(g, "java      : " + this.javaVersion);
      this.drawMetric(g, "memory    : " + String.format("%-5.5s", this.usedMemory) + " MB");
      this.drawMetric(g, "threads   : " + Thread.activeCount());
    }

    // render rendering metrics
    if (!this.renderMetrics.isEmpty()) {
      this.drawTitle(g, "[update]");

      for (RenderMetrics metric : this.renderMetrics) {
        this.drawMetric(g, metric.toString());
      }

      this.renderMetrics.clear();
    }
}
}
```
```java
class de.gurkenlabs.litiengine.graphics.emitters.Emitter {
public void deactivate() {
    if (!this.activated) {
      return;
    }

    this.activated = false;
    this.getParticles().clear();
    this.aliveTime = 0;
    this.activationTick = 0;
    this.lastSpawn = 0;
    Game.loop().detach(this);
}public void activate() {
    if (this.activated) {
      return;
    }

    this.activated = true;
    this.activationTick = Game.time().now();
    Game.loop().attach(this);
}@Override
  public void update() {
    if (this.isPaused()) {
      return;
    }

    // clear particles if the effect time to life is reached
    if (this.isFinished()) {
      for (EmitterFinishedListener listener : this.finishedListeners) {
        listener.finished(this);
      }

      this.delete();
      return;
    }

    final float updateRatio = (float) this.data().getUpdateRate() / Game.loop().getTickRate();
    for (final Particle p : this.getParticles().stream().collect(Collectors.toList())) {
      if (this.particleCanBeRemoved(p)) {
        // remove dead particles
        this.particles.remove(p);
        continue;
      }

      p.update(this.getOrigin(), updateRatio);
    }

    this.aliveTime = Game.time().since(this.activationTick);
    if ((this.data().getSpawnRate() == 0
        || Game.time().since(this.lastSpawn) >= this.data().getSpawnRate())) {
      this.lastSpawn = Game.time().now();
      this.spawnParticle();
    }
}
}
```
```java
class de.gurkenlabs.litiengine.entities.behavior.IBehaviorController {
public default void attach() {
    Game.loop().attach(this);
}public default void detach() {
    Game.loop().detach(this);
}
}
```
```java
class de.gurkenlabs.litiengine.abilities.AbilityExecution {
AbilityExecution(final Ability ability) {
    this.appliedEffects = new CopyOnWriteArrayList<>();
    this.ability = ability;
    this.executionTicks = Game.time().now();
    this.impactArea = ability.calculateImpactArea();
    this.castLocation = ability.getExecutor().getCenter();
    Game.loop().attach(this);
}@Override
  public void update() {
    // if there a no effects to apply -> unregister this instance and we're done
    if (this.getAbility().getEffects().isEmpty()
        || this.getAbility().getEffects().size() == this.getAppliedEffects().size()) {
      Game.loop().detach(this);
      return;
    }

    // handle all effects from the ability that were not applied yet
    for (final Effect effect : this.getAbility().getEffects()) {
      // if the ability was not executed yet or the delay of the effect is not
      // yet reached
      if (this.getAppliedEffects().contains(effect)
          || Game.time().since(this.getExecutionTicks()) < effect.getDelay()) {
        continue;
      }

      effect.apply(this.getExecutionImpactArea());
      this.getAppliedEffects().add(effect);
    }
}
}
```
```java
class de.gurkenlabs.litiengine.GameWindow$3 {
@Override
          public void windowGainedFocus(WindowEvent e) {
            Game.loop().setTickRate(Game.config().client().getMaxFps());
}@Override
          public void windowLostFocus(WindowEvent e) {
            if (Game.config().graphics().reduceFramesWhenNotFocused()) {
              Game.loop().setTickRate(NONE_FOCUS_MAX_FPS);
            }
}
}
```
```java
class de.gurkenlabs.litiengine.environment.EntitySpawner {
protected void spawnNewEntities() {
    if (this.getSpawnMode() != SpawnMode.CUSTOMSPAWNPOINTS && this.getSpawnPoints().isEmpty()) {
      return;
    }

    switch (this.getSpawnMode()) {
      case ALLSPAWNPOINTS:
        for (int i = 0; i < this.getSpawnPoints().size(); i++) {
          final int index = i;
          Game.loop()
              .perform(
                  this.getSpawnDelay() + this.getSpawnDelay() * i,
                  () -> this.spawn(this.getSpawnPoints().get(index), this.getSpawnAmount()));
        }
        break;
      case ONERANDOMSPAWNPOINT:
        this.spawn(Game.random().choose(this.getSpawnPoints()), this.getSpawnAmount());
        break;
      case RANDOMSPAWNPOINTS:
        for (int i = 0; i < this.getSpawnAmount(); i++) {
          Game.loop()
              .perform(
                  this.getSpawnDelay() + this.getSpawnDelay() * i,
                  () -> this.spawn(Game.random().choose(this.getSpawnPoints()), 1));
        }
        break;
      case CUSTOMSPAWNPOINTS:
        List<Spawnpoint> spawnPoints =
            this.customSpawnpoints != null
                ? this.customSpawnpoints.apply(this)
                : this.getCustomSpawnpoints();

        int index = 0;
        for (Spawnpoint spawn : spawnPoints) {
          Game.loop()
              .perform(
                  this.getSpawnDelay() + this.getSpawnDelay() * index, () -> this.spawn(spawn, 1));
          index++;
        }
        break;
      default:
        break;
    }
}
}
```
```java
class de.gurkenlabs.litiengine.tweening.TweenEngine {
@Override
  public void start() {
    Game.loop().attach(this);
}@Override
  public void terminate() {
    Game.loop().detach(this);
}
}
```
```java
class de.gurkenlabs.litiengine.gui.SpeechBubble {
public void hide() {
    Game.world().environment().removeRenderable(this);
    Game.loop().detach(this);
    if (activeSpeechBubbles.get(this.getEntity()) != null
        && activeSpeechBubbles.remove(this.getEntity()).equals(this)) {
      activeSpeechBubbles.remove(this.getEntity());
    }

    for (SpeechBubbleListener listener : this.listeners) {
      listener.hidden();
    }
}private SpeechBubble(
      final IEntity entity,
      final String text,
      @Nullable SpeechBubbleAppearance appearance,
      @Nullable Font font) {
    if (appearance == null) {
      this.appearance = DEFAULT_APPEARANCE;
    } else {
      this.appearance = appearance;
    }

    final SpeechBubble active = activeSpeechBubbles.get(entity);
    if (active != null) {
      active.hide();
    }
    this.setFont(font);

    this.textBoxWidth = (float) (entity.getWidth() * 4);
    this.entity = entity;

    this.currentText = text;
    this.currentTextDisplayTime = DISPLAYTIME_MIN + text.length() * DISPLAYTIME_PER_LETTER;

    this.lastTextDisplay = Game.time().now();
    this.createBubbleImage();
    entity.getEnvironment().add(this, RenderType.UI);
    Game.loop().attach(this);
    activeSpeechBubbles.put(entity, this);
}
}
```
```java
class de.gurkenlabs.litiengine.entities.Prop {
private void updateAnimationController() {
    IEntityAnimationController<?> controller = this.createAnimationController();
    this.getControllers().addController(controller);
    if (Game.world().environment() != null && Game.world().environment().isLoaded()) {
      Game.loop().attach(controller);
    }
}
}
```
```java
class de.gurkenlabs.litiengine.graphics.FreeFlightCamera {
public FreeFlightCamera(final Point2D focus) {
    this.setFocus(focus);
    this.velocity = DEFAULT_SCROLL_PIXELS_PER_SECOND;
    this.scrollPadding = DEFAULT_SCROLL_PADDING;
    this.setClampToMap(true);

    Game.loop().attach(this);
}private void handleFreeFlightCamera() {
    if (Game.world().environment() == null || Game.world().environment().getMap() == null) {
      return;
    }

    final Point2D mouseLocation = Input.mouse().getLocation();

    final double scrollSpeed =
        this.getVelocity()
            / (double) Game.loop().getTickRate()
            * Game.config().input().getMouseSensitivity();

    double x = this.getFocus().getX();
    double y = this.getFocus().getY();

    double deltaX = 0;
    if (mouseLocation.getX() < this.getScrollPadding()) {
      deltaX -= scrollSpeed;
    } else if (Game.window().getResolution().getWidth() - mouseLocation.getX()
        < this.getScrollPadding()) {
      deltaX += scrollSpeed;
    }

    double deltaY = 0;
    if (mouseLocation.getY() < this.getScrollPadding()) {
      deltaY -= scrollSpeed;
    } else if (Game.window().getResolution().getHeight() - mouseLocation.getY()
        < this.getScrollPadding()) {
      deltaY += scrollSpeed;
    }

    x += deltaX;
    y += deltaY;

    this.setFocus(new Point2D.Double(x, y));
}
}
```
```java
class de.gurkenlabs.litiengine.environment.Environment {
private static void dispose(final Collection<? extends IEntity> entities) {
    for (final IEntity entity : entities) {
      if (entity instanceof IUpdateable) {
        Game.loop().detach((IUpdateable) entity);
      }

      entity.detachControllers();
    }
}private static void loadUpdatableOrEmitterEntity(IEntity entity) {
    if (entity instanceof Emitter) {
      final Emitter emitter = (Emitter) entity;
      if (emitter.isActivateOnInit()) {
        emitter.activate();
      }
    } else if (entity instanceof IUpdateable) {
      Game.loop().attach((IUpdateable) entity);
    }
}private void unload(final IEntity entity) {
    // 1. remove from physics engine
    if (entity instanceof ICollisionEntity) {
      Game.physics().remove((ICollisionEntity) entity);
    }

    // 2. unregister from update
    if (entity instanceof IUpdateable) {
      Game.loop().detach((IUpdateable) entity);
    }

    if (entity instanceof IMobileEntity) {
      this.removeGravity((IMobileEntity) entity);
    }

    // 3. detach all controllers
    entity.detachControllers();

    if (entity instanceof Emitter) {
      Emitter em = (Emitter) entity;
      em.deactivate();
    }

    if (this.loaded && (entity instanceof LightSource || entity instanceof StaticShadow)) {
      this.updateLighting(entity);
    }

    entity.removed(this);
}
}
```
```java
class de.gurkenlabs.litiengine.graphics.animation.Animation {
@Override
  public void update() {
    // do nothing if the animation is not playing or the current keyframe is not finished
    if (!this.isPlaying()
        || Game.time().since(this.lastFrameUpdate) < this.getCurrentKeyFrame().getDuration()) {
      return;
    }

    // if we are not looping and the last keyframe is finished, we terminate the animation
    if (!this.isLooping() && this.isLastKeyFrame()) {
      this.terminate();
      return;
    }

    // make sure, we stay inside the keyframe list
    final int newFrameIndex =
        (this.getKeyframes().indexOf(this.currentFrame) + 1) % this.getKeyframes().size();
    final KeyFrame previousFrame = this.currentFrame;
    this.currentFrame = this.getKeyframes().get(newFrameIndex);

    for (KeyFrameListener listener : this.listeners) {
      listener.currentFrameChanged(previousFrame, this.currentFrame);
    }

    this.lastFrameUpdate = Game.loop().getTicks();
}public void restart() {
    this.currentFrame = this.firstFrame;
    this.lastFrameUpdate = Game.loop().getTicks();
}
}
```
```java
class de.gurkenlabs.litiengine.physics.MovementController {
@Override
  public void attach() {
    Game.loop().attach(this);
}private void handleForces() {
    // clean up forces
    this.activeForces.forEach(
        x -> {
          if (x.hasEnded()) {
            this.activeForces.remove(x);
          }
        });

    if (this.activeForces.isEmpty()) {
      return;
    }

    // disable turn-on-move for force handling
    boolean turn = this.getEntity().turnOnMove();
    this.getEntity().setTurnOnMove(false);
    try {
      double deltaX = 0;
      double deltaY = 0;
      for (final Force force : this.activeForces) {
        if (force.cancelOnReached() && force.hasReached(this.getEntity())) {
          force.end();
          continue;
        }

        final Point2D collisionBoxCenter = this.getEntity().getCollisionBoxCenter();
        final double angle =
            GeometricUtilities.calcRotationAngleInDegrees(collisionBoxCenter, force.getLocation());
        final double strength =
            Game.loop().getDeltaTime() * 0.001f * force.getStrength() * Game.loop().getTimeScale();
        deltaX += GeometricUtilities.getDeltaX(angle, strength);
        deltaY += GeometricUtilities.getDeltaY(angle, strength);
      }

      final Point2D target =
          new Point2D.Double(this.getEntity().getX() + deltaX, this.getEntity().getY() + deltaY);
      final boolean success = Game.physics().move(this.getEntity(), target);
      if (!success) {
        for (final Force force : this.activeForces) {
          if (force.cancelOnCollision()) {
            force.end();
          }
        }
      }
    } finally {
      this.getEntity().setTurnOnMove(turn);
    }
}@Override
  public void detach() {
    Game.loop().detach(this);
}public void handleMovement() {
    if (!this.isMovementAllowed()) {
      this.velocity = 0;
      return;
    }

    // max distance an entity can travel within one tick
    final double maxPixelsPerTick = this.getEntity().getTickVelocity();
    final double deltaTime = Game.loop().getDeltaTime() * Game.loop().getTimeScale();

    final double acceleration =
        this.getEntity().getAcceleration() == 0
            ? maxPixelsPerTick
            : deltaTime / this.getEntity().getAcceleration() * maxPixelsPerTick;
    final double deceleration =
        this.getEntity().getDeceleration() == 0
            ? this.getVelocity()
            : deltaTime / this.getEntity().getDeceleration() * maxPixelsPerTick;

    double dx = this.getDx();
    double dy = this.getDy();
    this.setDx(0);
    this.setDy(0);

    final double deltaVelocity =
        Math.min(Math.sqrt(Math.pow(dx, 2) + Math.pow(dy, 2)), acceleration);
    if (deltaVelocity != 0) {
      double newVelocity = this.getVelocity() + deltaVelocity;
      this.setVelocity(newVelocity);
    } else {
      final double newVelocity = Math.max(0, this.getVelocity() - deceleration);
      this.setVelocity(newVelocity);
      dx = GeometricUtilities.getDeltaX(this.moveAngle);
      dy = GeometricUtilities.getDeltaY(this.moveAngle);
    }

    if (this.getVelocity() == 0) {
      this.moveAngle = 0;
      return;
    }

    // actually move entity
    this.moveEntity(dx, dy);
}
}
```
```java
class de.gurkenlabs.litiengine.graphics.animation.AnimationController {
public void detach() {
    Game.loop().detach(this);
}public void attach() {
    Game.loop().attach(this);
}
}
```
```java
class de.gurkenlabs.litiengine.graphics.Camera {
@Override
  public void setZoom(final float targetZoom, final int delay) {
    if (delay == 0) {

      this.zoom = targetZoom;
      this.targetZoom = 0;
      this.zoomDelay = 0;
      this.zoomTick = 0;
      this.zoomStep = 0;

      final ZoomChangedEvent event = new ZoomChangedEvent(this, targetZoom);
      for (final ZoomChangedListener listener : this.zoomListeners) {
        listener.zoomChanged(event);
      }
    } else {
      this.zoomTick = Game.time().now();
      this.targetZoom = targetZoom;
      this.zoomDelay = delay;

      final double tickduration = 1000 / (double) Game.loop().getTickRate();
      final double tickAmount = delay / tickduration;
      final float totalDelta = this.targetZoom - this.zoom;
      this.zoomStep = tickAmount > 0 ? (float) (totalDelta / tickAmount) : totalDelta;
    }
}
}
```
```java
class de.gurkenlabs.litiengine.Game {
public static synchronized void init(String... args) {
    if (initialized) {
      log().log(Level.INFO, "The game has already been initialized.");
      return;
    }

    log.init();
    handleCommandLineArguments(args);

    config().load();
    Locale.setDefault(new Locale(config().client().getCountry(), config().client().getLanguage()));

    gameLoop = new GameLoop("Main Update Loop", config().client().getMaxFps());
    loop().attach(physics());
    loop().attach(world());

    // setup default exception handling for render and update loop
    setUncaughtExceptionHandler(
        new DefaultUncaughtExceptionHandler(config().client().exitOnError()));

    screenManager = new ScreenManager();
    gameWindow = new GameWindow();

    // initialize  the game window
    window().init();
    world.setCamera(new Camera());

    for (GameListener listener : gameListeners) {
      listener.initialized(args);
    }

    if (!isInNoGUIMode()) {
      window().getRenderComponent().onRendered(g -> metrics().render(g));

      graphics()
          .addEntityRenderedListener(
              e -> DebugRenderer.renderEntityDebugInfo(e.getGraphics(), e.getEntity()));

      window().getRenderComponent().onFpsChanged(fps -> metrics().setFramesPerSecond(fps));
      window()
          .setIcons(
              Arrays.asList(
                  Resources.images().get("liti-logo-x16.png"),
                  Resources.images().get("liti-logo-x20.png"),
                  Resources.images().get("liti-logo-x32.png"),
                  Resources.images().get("liti-logo-x48.png")));

      Input.keyboard()
          .onKeyTyped(
              KeyEvent.VK_PRINTSCREEN,
              key -> {
                // don't take a screenshot if a modifier is active
                if (key.getModifiers() != 0) {
                  return;
                }

                window().getRenderComponent().takeScreenshot();
              });
    }

    Runtime.getRuntime().addShutdownHook(new Thread(Game::terminate, "Shutdown"));

    initialized = true;
}
}
```
```java
class de.gurkenlabs.litiengine.entities.Creature {
protected void updateAnimationController() {
    IEntityAnimationController<?> controller = this.createAnimationController();
    this.getControllers().addController(controller);
    if (Game.world().environment() != null && Game.world().environment().isLoaded()) {
      Game.loop().attach(controller);
    }
}@Override
  public float getTickVelocity() {
    // pixels per ms multiplied by the passed ms
    // ensure that entities don't travel too far in case of lag
    return Math.min(Game.loop().getDeltaTime(), GameLoop.TICK_DELTATIME_LAG)
        * 0.001F
        * this.getVelocity().get()
        * Game.loop().getTimeScale();
}
}
```
Depth: 2
```java
class de.gurkenlabs.litiengine.environment.GameWorld {
public void clear() {
    this.unloadEnvironment();
    this.environments.clear();
    this.setCamera(null);
    Game.physics().clear();

    this.environmentListeners.clear();
    this.environmentLoadedListeners.clear();
    this.environmentUnloadedListeners.clear();

    this.listeners.clear();
    this.loadedListeners.clear();
    this.unloadedListeners.clear();
}@Nullable
  public Environment loadEnvironment(IMap map) {
    Environment env = this.getEnvironment(map);
    this.loadEnvironment(env);
    return env;
}@Nullable
  public Environment loadEnvironment(String mapName) {
    Environment env = this.getEnvironment(mapName);
    this.loadEnvironment(env);
    return env;
}
}
```
```java
class de.gurkenlabs.litiengine.GameWindow {
GameWindow() {
    this.hostControl = new JFrame();

    this.resolutionChangedListeners = new CopyOnWriteArrayList<>();

    this.renderCanvas = new RenderComponent(Game.config().graphics().getResolution());
    this.cursor = new MouseCursor();
    if (!Game.isInNoGUIMode()) {
      this.hostControl.setBackground(Color.BLACK);
      this.hostControl.add(this.renderCanvas);

      this.initializeEventListeners();

      this.hostControl.setTitle(Game.info().getTitle());
      this.hostControl.setDefaultCloseOperation(WindowConstants.DO_NOTHING_ON_CLOSE);
      initializeWindowEventListeners(this.hostControl);
    }
}
}
```
```java
class de.gurkenlabs.litiengine.GameTime {
public long sinceEnvironmentLoad() {
    return this.since(this.environmentLoaded);
}public long since(final long tick) {
    return toMilliseconds(Game.loop().getTicks() - tick);
}public long sinceGameStart() {
    return this.toMilliseconds(Game.loop().getTicks());
}
}
```
```java
class de.gurkenlabs.litiengine.abilities.effects.Effect {
protected void cease(final EffectApplication appliance) {
    // 1. cease the effect for all affected entities
    for (final ICombatEntity entity : appliance.getAffectedEntities()) {
      this.cease(entity);
    }

    // 2. apply follow up effects
    this.getFollowUpEffects().forEach(followUp -> followUp.apply(appliance.getImpactArea()));
}protected boolean hasEnded(final EffectApplication appliance) {
    final long effectDuration = Game.time().since(appliance.getAppliedTicks());
    return effectDuration > this.getDuration();
}
}
```
```java
class de.gurkenlabs.litiengine.abilities.effects.EffectApplication {
protected EffectApplication(final List<ICombatEntity> affectedEntities, final Shape impactArea) {
    this.applied = Game.time().now();
    this.affectedEntities = affectedEntities;
    this.impactArea = impactArea;
}
}
```
```java
class de.gurkenlabs.litiengine.entities.CombatEntity {
@Override
  public boolean wasHit(int timeSpan) {
    return Game.time().since(this.lastHit) < timeSpan;
}@Override
  public void hit(final int damage, @Nullable final Ability ability) {
    if (this.isDead()) {
      return;
    }

    if (!this.isIndestructible()) {
      this.getHitPoints().modifyBaseValue(new AttributeModifier<>(Modification.SUBTRACT, damage));
    }

    final EntityHitEvent event = new EntityHitEvent(this, ability, damage, this.isDead());

    for (final CombatEntityListener listener : this.listeners) {
      listener.hit(event);
    }

    for (final CombatEntityHitListener listener : this.hitListeners) {
      listener.hit(event);
    }

    if (this.isDead()) {
      this.fireDeathEvent();
      this.setCollision(false);
    }

    this.lastHit = Game.time().now();
}
}
```
```java
class de.gurkenlabs.litiengine.graphics.ImageEffect {
protected ImageEffect(final int ttl, final String name) {
    this.ttl = ttl;
    this.name = name;
    this.aliveTick = Game.time().now();
}@Override
  public long getAliveTime() {
    return Game.time().since(this.aliveTick);
}
}
```
```java
class de.gurkenlabs.litiengine.abilities.AbilityExecution {
AbilityExecution(final Ability ability) {
    this.appliedEffects = new CopyOnWriteArrayList<>();
    this.ability = ability;
    this.executionTicks = Game.time().now();
    this.impactArea = ability.calculateImpactArea();
    this.castLocation = ability.getExecutor().getCenter();
    Game.loop().attach(this);
}@Override
  public void update() {
    // if there a no effects to apply -> unregister this instance and we're done
    if (this.getAbility().getEffects().isEmpty()
        || this.getAbility().getEffects().size() == this.getAppliedEffects().size()) {
      Game.loop().detach(this);
      return;
    }

    // handle all effects from the ability that were not applied yet
    for (final Effect effect : this.getAbility().getEffects()) {
      // if the ability was not executed yet or the delay of the effect is not
      // yet reached
      if (this.getAppliedEffects().contains(effect)
          || Game.time().since(this.getExecutionTicks()) < effect.getDelay()) {
        continue;
      }

      effect.apply(this.getExecutionImpactArea());
      this.getAppliedEffects().add(effect);
    }
}
}
```
```java
class de.gurkenlabs.litiengine.tweening.TweenEngine {
@Override
  public void update() {
    for (final Tweenable target : this.getTweens().keySet()) {
      for (final Tween tween : this.getTweens().get(target).values()) {
        if (tween.hasStopped()) {
          continue;
        }
        final long elapsed = Game.time().since(tween.getStartTime());
        if (elapsed >= tween.getDuration()) {
          tween.stop();
          continue;
        }
        final float[] currentValues = new float[tween.getTargetValues().length];
        for (int i = 0; i < tween.getTargetValues().length; i++) {
          currentValues[i] =
              tween.getStartValues()[i]
                  + tween.getEquation().compute(elapsed / (float) tween.getDuration())
                      * (tween.getTargetValues()[i] - tween.getStartValues()[i]);
        }
        tween.getTarget().setTweenValues(tween.getType(), currentValues);
      }
    }
}
}
```
```java
class de.gurkenlabs.litiengine.gui.SpeechBubble {
public static SpeechBubble create(
      final IEntity entity, final String text, SpeechBubbleAppearance appearance, Font font) {
    return new SpeechBubble(entity, text, appearance, font);
}public static SpeechBubble create(final IEntity entity, final Font font, final String text) {
    SpeechBubbleAppearance app =
        new SpeechBubbleAppearance(
            DEFAULT_APPEARANCE.getForeColor(),
            DEFAULT_APPEARANCE.getBackgroundColor1(),
            DEFAULT_APPEARANCE.getBorderColor(),
            DEFAULT_APPEARANCE.getPadding());
    return new SpeechBubble(entity, text, app, font);
}public static SpeechBubble create(final IEntity entity, final String text) {
    return new SpeechBubble(entity, text, null, GuiProperties.getDefaultFont());
}@Override
  public void update() {
    if (this.currentText == null) {
      this.hide();
      return;
    }

    this.entityCenter = Game.world().camera().getViewportLocation(this.getEntity().getCenter());

    // old text was displayed long enough
    if (this.lastTextDisplay != 0
        && Game.time().since(this.lastTextDisplay) > this.currentTextDisplayTime) {
      this.currentText = null;
      this.lastTextDisplay = 0;
      return;
    }

    // display new text
    if (this.textIndex < this.currentText.length()
        && Game.time().since(this.lastCharPoll) > LETTER_WRITE_DELAY) {
      this.textIndex++;
      this.lastCharPoll = Game.time().now();
      if (this.typeSound != null) {
        Game.audio().playSound(this.typeSound, this.getEntity());
      }
    }

    // continue displaying currently displayed text
}private SpeechBubble(
      final IEntity entity,
      final String text,
      final Sound typeSound,
      SpeechBubbleAppearance appearance,
      Font font) {
    this(entity, text, appearance, font);
    this.typeSound = typeSound;
}private SpeechBubble(
      final IEntity entity,
      final String text,
      @Nullable SpeechBubbleAppearance appearance,
      @Nullable Font font) {
    if (appearance == null) {
      this.appearance = DEFAULT_APPEARANCE;
    } else {
      this.appearance = appearance;
    }

    final SpeechBubble active = activeSpeechBubbles.get(entity);
    if (active != null) {
      active.hide();
    }
    this.setFont(font);

    this.textBoxWidth = (float) (entity.getWidth() * 4);
    this.entity = entity;

    this.currentText = text;
    this.currentTextDisplayTime = DISPLAYTIME_MIN + text.length() * DISPLAYTIME_PER_LETTER;

    this.lastTextDisplay = Game.time().now();
    this.createBubbleImage();
    entity.getEnvironment().add(this, RenderType.UI);
    Game.loop().attach(this);
    activeSpeechBubbles.put(entity, this);
}
}
```
```java
class de.gurkenlabs.litiengine.gui.TextFieldComponent {
@Override
  public void render(final Graphics2D g) {
    super.render(g);
    g.setFont(this.getFont());
    final FontMetrics fm = g.getFontMetrics();

    if (this.isSelected() && Game.time().since(this.lastToggled) > this.flickerDelay) {
      this.cursorVisible = !this.cursorVisible;
      this.lastToggled = Game.time().now();
    }
    if (this.isSelected() && this.cursorVisible) {
      final Rectangle2D cursor =
          new Rectangle2D.Double(
              this.getX() + this.getTextX() + fm.stringWidth(this.getTextToRender(g)),
              this.getY() + this.getTextY(),
              this.getFont().getSize2D() * 3 / 5,
              this.getFont().getSize2D() * 1 / 5);
      g.setColor(this.getAppearance().getForeColor());
      g.fill(cursor);
    }
}
}
```
```java
class de.gurkenlabs.litiengine.entities.Prop {
public Prop(
      final Point2D location, @Nullable final String spritesheetName, final Material material) {
    super();
    this.rotation = Rotation.NONE;
    this.spritesheetName = spritesheetName;
    this.material = material;
    this.setLocation(location);
    this.updateAnimationController();
}public void setSpritesheetName(@Nullable final String spriteName) {
    this.spritesheetName = spriteName;
    this.updateAnimationController();
}
}
```
```java
class de.gurkenlabs.litiengine.tweening.Tween {
public Tween begin() {
    this.started = Game.time().now();
    this.stopped = false;
    return this;
}
}
```
```java
class de.gurkenlabs.litiengine.graphics.emitters.particles.Particle {
public void update(final Point2D emitterOrigin, final float updateRatio) {
    if (this.aliveTick == 0) {
      this.aliveTick = Game.time().now();
    }

    this.aliveTime = Game.time().since(this.aliveTick);
    if (this.timeToLiveReached()) {
      return;
    }

    if (this.colliding) {
      return;
    }

    if (this.getDeltaWidth() != 0) {
      this.width += this.getDeltaWidth() * updateRatio;
    }

    if (this.getDeltaHeight() != 0) {
      this.height += this.getDeltaHeight() * updateRatio;
    }

    if (this.getDeltaAngle() != 0) {
      this.angle += this.getDeltaAngle() * updateRatio;
    }

    // test for ray cast collision
    final float targetX = this.x + this.getVelocityX() * updateRatio;
    final float targetY = this.y + this.getVelocityY() * updateRatio;

    if (targetX == this.x && targetY == this.y) {
      return;
    }

    if (this.checkForCollision(emitterOrigin, targetX, targetY)) {
      return;
    }

    if (this.getVelocityX() != 0) {
      this.x = targetX;
    }

    if (this.getVelocityY() != 0) {
      this.y = targetY;
    }

    if (this.getAccelerationX() != 0) {
      this.velocityX += this.getAccelerationX() * updateRatio;
    }

    if (this.getAccelerationY() != 0) {
      this.velocityY += this.getAccelerationY() * updateRatio;
    }
}
}
```
```java
class de.gurkenlabs.litiengine.graphics.animation.Animation {
@Override
  public void start() {
    this.playing = true;
    if (this.getKeyframes().isEmpty()) {
      return;
    }

    this.restart();
}@Override
  public void update() {
    // do nothing if the animation is not playing or the current keyframe is not finished
    if (!this.isPlaying()
        || Game.time().since(this.lastFrameUpdate) < this.getCurrentKeyFrame().getDuration()) {
      return;
    }

    // if we are not looping and the last keyframe is finished, we terminate the animation
    if (!this.isLooping() && this.isLastKeyFrame()) {
      this.terminate();
      return;
    }

    // make sure, we stay inside the keyframe list
    final int newFrameIndex =
        (this.getKeyframes().indexOf(this.currentFrame) + 1) % this.getKeyframes().size();
    final KeyFrame previousFrame = this.currentFrame;
    this.currentFrame = this.getKeyframes().get(newFrameIndex);

    for (KeyFrameListener listener : this.listeners) {
      listener.currentFrameChanged(previousFrame, this.currentFrame);
    }

    this.lastFrameUpdate = Game.loop().getTicks();
}
}
```
```java
class de.gurkenlabs.litiengine.graphics.animation.AnimationController {
@Override
  public void update() {
    for (final Animation animation : this.getAll()) {
      animation.update();
    }

    if (this.getCurrent() != null && this.getCurrent().isPaused()) {
      return;
    }

    final boolean playbackFinished = this.getCurrent() != null && !this.getCurrent().isPlaying();
    if (playbackFinished) {
      for (final AnimationListener listener : this.listeners) {
        listener.finished(this.getCurrent());
      }
    }

    if (this.getCurrent() == null || playbackFinished) {
      if (this.getDefault() != null) {
        this.play(this.getDefault().getName());
      } else {
        this.currentAnimation = null;
      }
    }
}
}
```
```java
class de.gurkenlabs.litiengine.graphics.RenderComponent {
private void handleFade() {
    if (this.fadeOutStart != -1) {
      final long timePassed = Game.time().since(this.fadeOutStart);
      this.currentAlpha = MathUtilities.clamp(1 - timePassed / (float) this.fadeOutTime, 0, 1);
      if (this.currentAlpha == 0f) {
        this.fadeOutStart = -1;
        this.fadeOutTime = -1;
      }

      return;
    }

    if (this.fadeInStart != -1) {
      final long timePassed = Game.time().since(this.fadeInStart);
      this.currentAlpha = MathUtilities.clamp(timePassed / (float) this.fadeInTime, 0, 1);
      if (this.currentAlpha == 1f) {
        this.fadeInStart = -1;
        this.fadeInTime = -1;
        this.currentAlpha = Float.NaN;
      }
    }
}public void fadeOut(final int ms) {
    this.fadeInStart = -1;
    this.fadeInTime = -1;
    this.fadeOutStart = Game.time().now();
    this.fadeOutTime = ms;
}public void fadeIn(final int ms) {
    this.fadeOutStart = -1;
    this.fadeOutTime = -1;
    this.fadeInStart = Game.time().now();
    this.fadeInTime = ms;
}
}
```
```java
class de.gurkenlabs.litiengine.entities.Trigger {
private boolean activate(final IEntity activator, final int tar) {
    if (!this.isLoaded()
        || this.isOneTimeTrigger && this.isActivated
        || this.getActivationType() == TriggerActivation.COLLISION
            && activator != null
            && this.collisionActivated.contains(activator)) {
      return false;
    }

    if (this.getCooldown() > 0 && Game.time().since(this.lastActivation) < this.getCooldown()) {
      return false;
    }

    List<Integer> triggerTargets = this.getTargets(tar);

    final TriggerEvent te = new TriggerEvent(this, activator, triggerTargets);

    if (!this.checkActivationPredicates(te)) {
      return false;
    }

    this.isActivated = true;
    if (activator != null) {
      this.collisionActivated.add(activator);
    }

    // if we actually have a trigger target, we send the message to the target
    for (final int target : triggerTargets) {
      final IEntity entity = this.getEnvironment().get(target);
      if (entity == null) {
        log.log(
            Level.WARNING,
            "trigger [{0}] was activated, but the trigger target [{1}] could not be found on the environment",
            new Object[] {this, target});
        continue;
      }

      entity.sendMessage(this, this.message);
    }

    // also send the trigger event to all registered consumers
    for (final TriggerActivatedListener listener : this.activatedListeners) {
      listener.activated(te);
    }

    if (this.isOneTimeTrigger) {
      this.getEnvironment().remove(this);
    }

    this.lastActivation = Game.time().now();
    return true;
}
}
```
```java
class de.gurkenlabs.litiengine.graphics.Camera {
private boolean isShakeEffectActive() {
    return this.getShakeTick() != 0
        && Game.time().since(this.getShakeTick()) < this.getShakeDuration();
}@Override
  public void update() {
    if (Game.world().camera() != null && !Game.world().camera().equals(this)) {
      return;
    }

    if (this.targetZoom > 0) {
      if (Game.time().since(this.zoomTick) >= this.zoomDelay) {
        this.zoom = this.targetZoom;
        this.targetZoom = 0;
        this.zoomDelay = 0;
        this.zoomTick = 0;
        this.zoomStep = 0;
      } else {
        this.zoom += this.zoomStep;
      }

      final ZoomChangedEvent event = new ZoomChangedEvent(this, this.getZoom());
      for (final ZoomChangedListener listener : this.zoomListeners) {
        listener.zoomChanged(event);
      }
    }

    if (this.panTime > 0) {
      if (--this.panTime <= 0) {
        this.setFocus(this.targetFocus);
        this.targetFocus = null;
      } else {
        double diff = this.panTime / (this.panTime + 1.0);
        this.focus =
            new Point2D.Double(
                this.focus.getX() * diff + this.targetFocus.getX() * (1.0 - diff),
                this.focus.getY() * diff + this.targetFocus.getY() * (1.0 - diff));
      }
    }

    if (!this.isShakeEffectActive()) {
      this.shakeOffsetX = 0;
      this.shakeOffsetY = 0;
      return;
    }

    if (Game.time().since(this.lastShake) > this.shakeDelay) {
      this.shakeOffsetX = this.getShakeIntensity() * ThreadLocalRandom.current().nextGaussian();
      this.shakeOffsetY = this.getShakeIntensity() * ThreadLocalRandom.current().nextGaussian();
      this.lastShake = Game.time().now();
    }
}@Override
  public void setZoom(final float targetZoom, final int delay) {
    if (delay == 0) {

      this.zoom = targetZoom;
      this.targetZoom = 0;
      this.zoomDelay = 0;
      this.zoomTick = 0;
      this.zoomStep = 0;

      final ZoomChangedEvent event = new ZoomChangedEvent(this, targetZoom);
      for (final ZoomChangedListener listener : this.zoomListeners) {
        listener.zoomChanged(event);
      }
    } else {
      this.zoomTick = Game.time().now();
      this.targetZoom = targetZoom;
      this.zoomDelay = delay;

      final double tickduration = 1000 / (double) Game.loop().getTickRate();
      final double tickAmount = delay / tickduration;
      final float totalDelta = this.targetZoom - this.zoom;
      this.zoomStep = tickAmount > 0 ? (float) (totalDelta / tickAmount) : totalDelta;
    }
}@Override
  public void shake(final double intensity, final int delay, final int shakeDuration) {
    this.shakeTick = Game.time().now();
    this.shakeDelay = delay;
    this.shakeIntensity = intensity;
    this.shakeDuration = shakeDuration;
}
}
```
```java
class de.gurkenlabs.litiengine.entities.Creature {
public void setSpritesheetName(String spritesheetName) {
    if (this.spritesheetName != null && this.spritesheetName.equals(spritesheetName)) {
      return;
    }

    this.spritesheetName = spritesheetName;
    this.updateAnimationController();
}public boolean isIdle() {
    return Game.time().since(this.lastMoved) > IDLE_DELAY;
}@Override
  public void setLocation(final Point2D position) {
    if (this.isDead() || position == null) {
      return;
    }

    final Point2D oldLocation = this.getLocation();
    super.setLocation(position);

    if (Game.hasStarted() && this.isLoaded()) {
      this.lastMoved = Game.time().now();
      this.fireMovedEvent(
          new EntityMovedEvent(
              this, this.getX() - oldLocation.getX(), this.getY() - oldLocation.getY()));
    }
}
}
```
```java
class de.gurkenlabs.litiengine.gui.screens.ScreenManager {
public void display(final String screenName) {
    if (this.current() != null && this.current().getName().equalsIgnoreCase(screenName)) {
      log.log(
          Level.INFO,
          "Skipping displaying of screen {0} because it is already the current screen.",
          screenName);
      return;
    }

    if (this.screens.stream()
        .noneMatch(element -> element.getName().equalsIgnoreCase(screenName))) {
      log.log(
          Level.WARNING,
          "Could not display the screen {0} because there is no screen with the specified name.",
          screenName);
      return;
    }

    Screen screen = this.get(screenName);
    if (screen == null) {
      return;
    }

    this.display(screen);
}public void add(final Screen screen) {
    screen.setWidth(Game.window().getWidth());
    screen.setHeight(Game.window().getHeight());
    this.screens.add(screen);

    if (this.current() == null) {
      this.display(screen);
    }
}public void remove(Screen screen) {
    this.screens.remove(screen);
    if (this.current() == screen) {
      if (!this.screens.isEmpty()) {
        this.display(this.screens.get(0));
      } else {
        this.display((Screen) null);
      }
    }
}public void display(@Nullable final Screen screen) {
    if (Game.hasStarted() && Game.time().since(this.lastScreenChange) < this.getChangeCooldown()) {
      log.log(
          Level.INFO,
          "Skipping displaying of screen {0} because screen changing is currently on cooldown.",
          screen != null ? screen.getName() : "");
      return;
    }

    final Screen previous = this.current();
    if (previous != null) {
      previous.suspend();
    }

    if (screen != null && !this.screens.contains(screen)) {
      this.screens.add(screen);
    }

    this.currentScreen = screen;
    if (!Game.isInNoGUIMode() && this.current() != null) {
      this.current().prepare();
    }

    this.lastScreenChange = Game.loop().getTicks();

    final ScreenChangedEvent event = new ScreenChangedEvent(this.current(), previous);
    for (final ScreenChangedListener listener : this.screenChangedListeners) {
      listener.changed(event);
    }
}
}
```
```java
class de.gurkenlabs.litiengine.abilities.Ability {
public boolean isOnCooldown() {
    return (this.getCurrentExecution() != null
        && this.getCurrentExecution().getExecutionTicks() > 0
        && Game.time().since(this.getCurrentExecution().getExecutionTicks())
            < this.getAttributes().cooldown().get());
}public boolean isActive() {
    return this.getCurrentExecution() != null
        && Game.time().since(this.getCurrentExecution().getExecutionTicks())
            < this.getAttributes().duration().get();
}@Nullable
  public AbilityExecution cast() {
    if (!this.canCast()) {
      return null;
    }
    this.currentExecution = new AbilityExecution(this);

    for (final AbilityCastListener listener : this.abilityCastListeners) {
      listener.abilityCast(this.currentExecution);
    }

    return this.getCurrentExecution();
}public float getRemainingCooldownInSeconds() {
    if (this.getCurrentExecution() == null
        || this.getExecutor() == null
        || this.getExecutor().isDead()) {
      return 0;
    }

    // calculate cooldown in seconds
    return (float)
        (!this.canCast()
            ? (this.getAttributes().cooldown().get()
                    - Game.time().since(this.getCurrentExecution().getExecutionTicks()))
                * 0.001
            : 0);
}
}
```
```java
class de.gurkenlabs.litiengine.entities.EntityHitEvent {
EntityHitEvent(
      final ICombatEntity hitEntity,
      @Nullable final Ability ability,
      final int damage,
      final boolean kill) {
    super(hitEntity);
    this.executor = ability != null ? ability.getExecutor() : null;
    this.hitEntity = hitEntity;
    this.ability = ability;
    this.damage = damage;
    this.kill = kill;
    this.time = Game.time().now();
}
}
```
```java
class de.gurkenlabs.litiengine.graphics.emitters.Emitter {
public void delete() {
    this.deactivate();
    if (Game.world().environment() != null) {
      Game.world().environment().remove(this);
    }
}public void activate() {
    if (this.activated) {
      return;
    }

    this.activated = true;
    this.activationTick = Game.time().now();
    Game.loop().attach(this);
}@Override
  public void update() {
    if (this.isPaused()) {
      return;
    }

    // clear particles if the effect time to life is reached
    if (this.isFinished()) {
      for (EmitterFinishedListener listener : this.finishedListeners) {
        listener.finished(this);
      }

      this.delete();
      return;
    }

    final float updateRatio = (float) this.data().getUpdateRate() / Game.loop().getTickRate();
    for (final Particle p : this.getParticles().stream().collect(Collectors.toList())) {
      if (this.particleCanBeRemoved(p)) {
        // remove dead particles
        this.particles.remove(p);
        continue;
      }

      p.update(this.getOrigin(), updateRatio);
    }

    this.aliveTime = Game.time().since(this.activationTick);
    if ((this.data().getSpawnRate() == 0
        || Game.time().since(this.lastSpawn) >= this.data().getSpawnRate())) {
      this.lastSpawn = Game.time().now();
      this.spawnParticle();
    }
}
}
```
```java
class de.gurkenlabs.litiengine.GameLoop {
@Override
  public int perform(int delay, Runnable action) {
    final long d = Game.time().toTicks(delay);

    TimedAction a = new TimedAction(this.getTicks() + d, action);
    this.actions.add(a);

    return a.getId();
}
}
```
```java
class de.gurkenlabs.litiengine.environment.EntitySpawner {
protected boolean shouldSpawn() {
    return this.lastSpawnWave == 0
        || Game.time().since(this.lastSpawnWave) >= this.getSpawnInterval();
}@Override
  public void update() {
    if (!this.shouldSpawn()) {
      return;
    }

    this.spawnNewEntities();
    this.lastSpawnWave = Game.time().now();
}
}
```
```java
class de.gurkenlabs.litiengine.graphics.FreeFlightCamera {
@Override
  public void update() {
    this.handleFreeFlightCamera();
}public FreeFlightCamera(double x, double y) {
    this(new Point2D.Double(x, y));
}
}
```
```java
class de.gurkenlabs.litiengine.environment.Environment {
public void unload() {
    if (!this.loaded) {
      return;
    }

    // unregister all updatable entities from the current environment
    for (final IEntity entity : this.allEntities.values()) {
      this.unload(entity);
    }

    this.loaded = false;
    this.fireEvent(l -> l.unloaded(this));
}private static void loadUpdatableOrEmitterEntity(IEntity entity) {
    if (entity instanceof Emitter) {
      final Emitter emitter = (Emitter) entity;
      if (emitter.isActivateOnInit()) {
        emitter.activate();
      }
    } else if (entity instanceof IUpdateable) {
      Game.loop().attach((IUpdateable) entity);
    }
}public void clear() {
    Game.physics().clear();

    this.combatEntities.clear();
    this.mobileEntities.clear();
    this.gravityForces.clear();
    this.layerEntities.clear();
    this.entitiesByTag.clear();
    this.allEntities.clear();

    for (RenderType renderType : RenderType.values()) {
      this.miscEntities.get(renderType).clear();
      this.renderListeners.get(renderType).clear();
      this.renderables.get(renderType).clear();
    }

    dispose(this.allEntities.values());
    dispose(this.triggers);
    this.emitters.clear();
    this.colliders.clear();
    this.props.clear();
    this.creatures.clear();
    this.staticShadows.clear();
    this.combatEntities.clear();
    this.mobileEntities.clear();
    this.lightSources.clear();
    this.spawnPoints.clear();
    this.soundSources.clear();
    this.mapAreas.clear();
    this.triggers.clear();

    this.ambientLight = null;
    this.staticShadowLayer = null;

    for (Map<Integer, IEntity> type : this.miscEntities.values()) {
      type.clear();
    }

    this.initialized = false;

    this.fireEvent(l -> l.cleared(this));
}private void load(final IEntity entity) {
    // an entity can only exist on one environment at a time, so remove it from the current one
    if (entity.getEnvironment() != null) {
      entity.getEnvironment().remove(entity);
    }

    // 1. add to physics engine
    loadPhysicsEntity(entity);

    // 2. register for update or activate
    loadUpdatableOrEmitterEntity(entity);

    // 3. if a gravity is defined, add a gravity force to the entity
    if (entity instanceof IMobileEntity && this.getGravity() != 0) {
      this.addGravityForce((IMobileEntity) entity);
    }

    // 4. attach all controllers
    entity.attachControllers();

    if (this.loaded && (entity instanceof LightSource || entity instanceof StaticShadow)) {
      this.updateLighting(entity);
    }

    entity.loaded(this);
}private void unload(final IEntity entity) {
    // 1. remove from physics engine
    if (entity instanceof ICollisionEntity) {
      Game.physics().remove((ICollisionEntity) entity);
    }

    // 2. unregister from update
    if (entity instanceof IUpdateable) {
      Game.loop().detach((IUpdateable) entity);
    }

    if (entity instanceof IMobileEntity) {
      this.removeGravity((IMobileEntity) entity);
    }

    // 3. detach all controllers
    entity.detachControllers();

    if (entity instanceof Emitter) {
      Emitter em = (Emitter) entity;
      em.deactivate();
    }

    if (this.loaded && (entity instanceof LightSource || entity instanceof StaticShadow)) {
      this.updateLighting(entity);
    }

    entity.removed(this);
}public void remove(final IEntity entity) {
    if (entity == null) {
      return;
    }

    this.allEntities.remove(entity.getMapId());
    Iterator<List<IEntity>> iter = this.layerEntities.values().iterator();
    while (iter.hasNext()) {
      List<IEntity> layer = iter.next();
      if (layer.remove(entity) && layer.isEmpty()) {
        iter.remove();
      }
    }
    if (this.miscEntities.get(entity.getRenderType()) != null) {
      this.miscEntities.get(entity.getRenderType()).values().remove(entity);
    }

    for (String tag : entity.getTags()) {
      if (this.getEntitiesByTag().containsKey(tag)) {
        this.getEntitiesByTag().get(tag).remove(entity);

        if (this.getEntitiesByTag().get(tag).isEmpty()) {
          this.getEntitiesByTag().remove(tag);
        }
      }
    }

    if (entity instanceof Emitter) {
      Emitter emitter = (Emitter) entity;
      this.removeEmitter(emitter);
    }

    if (entity instanceof MapArea) {
      this.mapAreas.remove(entity);
    }

    if (entity instanceof Prop) {
      this.props.remove(entity);
    }

    if (entity instanceof Creature) {
      this.creatures.remove(entity);
    }

    if (entity instanceof CollisionBox) {
      this.colliders.remove(entity);
      this.staticShadows.removeIf(x -> x.getOrigin() != null && x.getOrigin().equals(entity));
    }

    if (entity instanceof LightSource) {
      this.lightSources.remove(entity);
      this.updateLighting(entity);
    }

    if (entity instanceof Trigger) {
      this.triggers.remove(entity);
    }

    if (entity instanceof Spawnpoint) {
      this.spawnPoints.remove(entity);
    }
    if (entity instanceof SoundSource) {
      this.soundSources.remove(entity);
    }

    if (entity instanceof StaticShadow) {
      this.staticShadows.remove(entity);
      this.updateLighting(entity);
    }

    if (entity instanceof IMobileEntity) {
      this.mobileEntities.values().remove(entity);
    }

    if (entity instanceof ICombatEntity) {
      this.combatEntities.values().remove(entity);
    }

    this.unload(entity);

    this.fireEntityEvent(l -> l.entityRemoved(entity));
}
}
```
```java
class de.gurkenlabs.litiengine.physics.MovementController {
@Override
  public void update() {
    this.handleForces();
    this.handleMovement();
}
}
```
```java
class de.gurkenlabs.litiengine.Game {
static synchronized void terminate() {
    if (!initialized) {
      return;
    }

    hasStarted = false;
    initialized = false;

    config().save();
    gameLoop.terminate();
    tweenEngine.terminate();
    soundEngine.terminate();

    world().clear();

    for (final GameListener listener : gameListeners) {
      try {
        listener.terminated();
      } catch (Exception e) {
        log().log(Level.WARNING, "game listener threw an exception during shutdown", e);
      }
    }

    gameLoop = null;
    screenManager = null;
    gameWindow = null;
}public static synchronized void start() {
    if (!initialized) {
      throw new IllegalStateException(
          "The game cannot be started without being first initialized. Call Game.init(...) before Game.start().");
    }

    gameLoop.start();
    tweenEngine.start();
    soundEngine.start();

    for (final GameListener listener : gameListeners) {
      listener.started();
    }

    hasStarted = true;
}public static synchronized void init(String... args) {
    if (initialized) {
      log().log(Level.INFO, "The game has already been initialized.");
      return;
    }

    log.init();
    handleCommandLineArguments(args);

    config().load();
    Locale.setDefault(new Locale(config().client().getCountry(), config().client().getLanguage()));

    gameLoop = new GameLoop("Main Update Loop", config().client().getMaxFps());
    loop().attach(physics());
    loop().attach(world());

    // setup default exception handling for render and update loop
    setUncaughtExceptionHandler(
        new DefaultUncaughtExceptionHandler(config().client().exitOnError()));

    screenManager = new ScreenManager();
    gameWindow = new GameWindow();

    // initialize  the game window
    window().init();
    world.setCamera(new Camera());

    for (GameListener listener : gameListeners) {
      listener.initialized(args);
    }

    if (!isInNoGUIMode()) {
      window().getRenderComponent().onRendered(g -> metrics().render(g));

      graphics()
          .addEntityRenderedListener(
              e -> DebugRenderer.renderEntityDebugInfo(e.getGraphics(), e.getEntity()));

      window().getRenderComponent().onFpsChanged(fps -> metrics().setFramesPerSecond(fps));
      window()
          .setIcons(
              Arrays.asList(
                  Resources.images().get("liti-logo-x16.png"),
                  Resources.images().get("liti-logo-x20.png"),
                  Resources.images().get("liti-logo-x32.png"),
                  Resources.images().get("liti-logo-x48.png")));

      Input.keyboard()
          .onKeyTyped(
              KeyEvent.VK_PRINTSCREEN,
              key -> {
                // don't take a screenshot if a modifier is active
                if (key.getModifiers() != 0) {
                  return;
                }

                window().getRenderComponent().takeScreenshot();
              });
    }

    Runtime.getRuntime().addShutdownHook(new Thread(Game::terminate, "Shutdown"));

    initialized = true;
}
}
```


Response Format:
Provide the answer in **XML format** as follows:

#### If the method **cannot** return `null` at the specific call site:
```xml
<response>
  <reason><![CDATA[EXPLAIN WHY THE INVOCATION Game.loop() RESULT CANNOT BE NULL.]]></reason>
  <value>NO</value>
</response>

#### If the method can return null at the specific call site:
<response>
  <reason><![CDATA[EXPLAIN WHY THE INVOCATION Game.loop() RESULT CAN BE NULL.]]></reason>
  <value>YES</value>
</response>

#### If you are unsure or If there are any methods that directly or indirectly affect the return value and are not fully disclosed, request their declarations first, in the following format:
<response>
  <reason><![CDATA[EXPLAIN WHY THIS METHOD DECLARATION IS NECESSARY AND WHY YOU CANNOT MAKE A CONFIDENT DECISION WITHOUT IT]]></reason>
  <success>false</success>
  <methods>
    <method>methodName</method>
  </methods>
</response>

Additional Notes:
Be precise in your reasoning.
If a method’s return value depends on another method not provided, request its declaration before making a conclusion.
If the method can return null in this case but not in others, explain why it happens specifically for this call.

---ChatGPT.sendRequestToOpenAI---
Retrieving response from cache
---Response.<init>---
Creating Response:
```xml
<response>
  <reason><![CDATA[The method `Game.loop()` returns the static field `gameLoop`, which is initialized in the `Game.init(String... args)` method. In this method, a new `GameLoop` object is instantiated and assigned to `gameLoop`. Since `init()` must be called before `start()`, which is implied by the requirement of initializing the game, the `gameLoop` is guaranteed to be non-null during the lifetime of the game execution where `Game.loop()` is called. The absence of any code that could set `gameLoop` to null after its initialization ensures that `Game.loop()` cannot return null.]]></reason>
  <value>NO</value>
</response>
```
---Response.<init>---
Response created:
Disagreement: The method `Game.loop()` returns the static field `gameLoop`, which is initialized in the `Game.init(String... args)` method. In this method, a new `GameLoop` object is instantiated and assigned to `gameLoop`. Since `init()` must be called before `start()`, which is implied by the requirement of initializing the game, the `gameLoop` is guaranteed to be non-null during the lifetime of the game execution where `Game.loop()` is called. The absence of any code that could set `gameLoop` to null after its initialization ensures that `Game.loop()` cannot return null.
---AdvancedNullAwayCodeFix.resolveMethodDereferenceError---
Method is not returning nullable on call site. Injecting suppression annotation.
---AdvancedNullAwayCodeFix.constructCastToNonnullChange---
Constructing cast to nonnull change for reason: The method `Game.loop()` returns the static field `gameLoop`, which is initialized in the `Game.init(String... args)` method. In this method, a new `GameLoop` object is instantiated and assigned to `gameLoop`. Since `init()` must be called before `start()`, which is implied by the requirement of initializing the game, the `gameLoop` is guaranteed to be non-null during the lifetime of the game execution where `Game.loop()` is called. The absence of any code that could set `gameLoop` to null after its initialization ensures that `Game.loop()` cannot return null.
---ChatGPT.ask---
Asking ChatGPT:
For the reason you mentioned earlier:

"The method `Game.loop()` returns the static field `gameLoop`, which is initialized in the `Game.init(String... args)` method. In this method, a new `GameLoop` object is instantiated and assigned to `gameLoop`. Since `init()` must be called before `start()`, which is implied by the requirement of initializing the game, the `gameLoop` is guaranteed to be non-null during the lifetime of the game execution where `Game.loop()` is called. The absence of any code that could set `gameLoop` to null after its initialization ensures that `Game.loop()` cannot return null."

in the method below, the expression Game.loop() is not nullable at the point it is used.

```java
@Override
          public void windowGainedFocus(WindowEvent e) {
            Game.loop().setTickRate(Game.config().client().getMaxFps());
}
```
Please Summarize the reason in max 5 words and rewrite the method so that at the line "            Game.loop().setTickRate(Game.config().client().getMaxFps());", at the occurrence of: "Game.loop()" is replaced with `NullabilityUtil.castToNonnull(Game.loop(), summary of reason)`
Replace "REASON" with the exact reason summary I provide to you (maximum 5 words), not with a generic explanation like "checked to be nonnull".
see the example below, for expression `foo.getBar()`, to wrap it with `NullabilityUtil.castToNonnull(foo.getBar(), "reason")`.

```java
public t(){
    String l = foo.getBar();
}
```

will be:
```java
public t(){
    String l = NullabilityUtil.castToNonnull(foo.getBar(), "checked to be nonnull");
}
```

### Instructions:

Do not import any additional classes.

Do not add Java comments.

Only modify relevant lines as required.

Return only the modified method wrapped in the XML format shown below.

Place the Java code inside the <code> tag using a CDATA block with ```java formatting.

Just give me the fixed code snippet in XML format in <response> tag like the example below. I will apply the fix to my codebase. Do not import any additional libraries or classes or add java comments. If you can provide the fixed code snippet, please provide it in the following format and place the code snippet in the <code> tag within ```java block.
<response>
  <success>true</success>
  <code><![CDATA[
  ```java
  Your fixed code snippet here
  ```
    ]]>
  </code>
</response>

---ChatGPT.sendRequestToOpenAI---
Retrieving response from cache
---Response.<init>---
Creating Response:
```xml
<response>
  <success>true</success>
  <code><![CDATA[
  ```java
  @Override
  public void windowGainedFocus(WindowEvent e) {
    NullabilityUtil.castToNonnull(Game.loop(), "guaranteed not null").setTickRate(Game.config().client().getMaxFps());
  }
  ```
  ]]>
  </code>
</response>
```
---Response.<init>---
Response created:
@Override
  public void windowGainedFocus(WindowEvent e) {
    NullabilityUtil.castToNonnull(Game.loop(), "guaranteed not null").setTickRate(Game.config().client().getMaxFps());
  }
---ChatGPT.fixDereferenceByAddingCastToNonnull---
Fixing the error by adding castToNonnull
---AdvancedNullAwayCodeFix.fixTriggeredErrorsForLocation---
Resolving unresolvable error for triggered error: Type='DEREFERENCE_NULLABLE', message='dereferenced expression Game.loop() is @Nullable'
/home/nima/Developer/nullness-benchmarks/litiengine/src/de/gurkenlabs/litiengine/environment/EntitySpawner.java:187
          Game.loop()
---AdvancedNullAwayCodeFix.fix---
Fixing error: Type='DEREFERENCE_NULLABLE', message='dereferenced expression Game.loop() is @Nullable'
/home/nima/Developer/nullness-benchmarks/litiengine/src/de/gurkenlabs/litiengine/environment/EntitySpawner.java:187
          Game.loop()
---AdvancedNullAwayCodeFix.resolveDereferenceError---
Resolving dereference error: Type='DEREFERENCE_NULLABLE', message='dereferenced expression Game.loop() is @Nullable'
/home/nima/Developer/nullness-benchmarks/litiengine/src/de/gurkenlabs/litiengine/environment/EntitySpawner.java:187
          Game.loop()
---AdvancedNullAwayCodeFix.resolveDereferenceError---
Checking nullability possibility at error point
---ChatGPT.checkNullabilityPossibilityAtErrorPoint---
Asking if the expression can be null at error point point
---ChatGPT.ask---
Asking ChatGPT:
In the method below, is there a possibility that the expression "Game.loop()" at line "Game.loop()" is null?
protected void spawnNewEntities() {
    if (this.getSpawnMode() != SpawnMode.CUSTOMSPAWNPOINTS && this.getSpawnPoints().isEmpty()) {
      return;
    }

    switch (this.getSpawnMode()) {
      case ALLSPAWNPOINTS:
        for (int i = 0; i < this.getSpawnPoints().size(); i++) {
          final int index = i;
          Game.loop()
              .perform(
                  this.getSpawnDelay() + this.getSpawnDelay() * i,
                  () -> this.spawn(this.getSpawnPoints().get(index), this.getSpawnAmount()));
        }
        break;
      case ONERANDOMSPAWNPOINT:
        this.spawn(Game.random().choose(this.getSpawnPoints()), this.getSpawnAmount());
        break;
      case RANDOMSPAWNPOINTS:
        for (int i = 0; i < this.getSpawnAmount(); i++) {
          Game.loop()
              .perform(
                  this.getSpawnDelay() + this.getSpawnDelay() * i,
                  () -> this.spawn(Game.random().choose(this.getSpawnPoints()), 1));
        }
        break;
      case CUSTOMSPAWNPOINTS:
        List<Spawnpoint> spawnPoints =
            this.customSpawnpoints != null
                ? this.customSpawnpoints.apply(this)
                : this.getCustomSpawnpoints();

        int index = 0;
        for (Spawnpoint spawn : spawnPoints) {
          Game.loop()
              .perform(
                  this.getSpawnDelay() + this.getSpawnDelay() * index, () -> this.spawn(spawn, 1));
          index++;
        }
        break;
      default:
        break;
    }
}
Give a single-word answer in XML format. If it is possible for the expression to be null, respond with:
```xml
<response>
    <reason><![CDATA[YOUR REASON]]></reason>
    <value>YES</value>
</response>
```
If it is not possible for the expression to be null, respond with:
```xml
<response>
    <reason><![CDATA[YOUR REASON]]></reason>
    <value>NO</value>
</response>
```
If you are unsure or need more information, respond with where you can ask for more details or what specific information you need.

If additional information is required, list each request inside a `<request>` tag. If no additional information is needed, omit the `<requests>` section.

Respond with:
```xml
<response>
    <reason><![CDATA[YOUR REASON]]></reason>
    <value>UNKNOWN</value>
    <!-- Include <requests> only if additional information is needed -->
    <requests>
        <request><![CDATA[YOUR REQUEST 1]]></request>
        <request><![CDATA[YOUR REQUEST 2]]></request>
    </requests>
</response>
```
---ChatGPT.sendRequestToOpenAI---
Retrieving response from cache
---Response.<init>---
Creating Response:
```xml
<response>
    <reason><![CDATA[The possibility of "Game.loop()" being null depends on how it is implemented and initialized elsewhere in the code. Without access to the implementation details or specifications of the Game class, it is uncertain if "Game.loop()" could be null.]]></reason>
    <value>UNKNOWN</value>
    <requests>
        <request><![CDATA[Provide the implementation or initialization details of the "Game.loop()" method.]]></request>
        <request><![CDATA[Clarify if there are any guarantees or constraints regarding the non-null status of "Game.loop()".]]></request>
    </requests>
</response>
```
---Response.<init>---
Response created:
Unknown: The possibility of "Game.loop()" being null depends on how it is implemented and initialized elsewhere in the code. Without access to the implementation details or specifications of the Game class, it is uncertain if "Game.loop()" could be null.
---AdvancedNullAwayCodeFix.resolveMethodDereferenceError---
Resolving method dereference error.
---AdvancedNullAwayCodeFix.resolveMethodDereferenceError---
Method is in annotated package. Checking if the method is returning nullable.
---AdvancedNullAwayCodeFix.investigateMethodReturnNullability---
Checking if the method is returning nullable.
---ChatGPT.checkIfMethodIsReturningNullable---
Asking if the method is returning nullable: loop()
---ChatGPT.ask---
Asking ChatGPT:
In the method below, is there a possibility that the method returns null based only on its body? Consider the following points:

- The method may have multiple return paths; consider all return statements.
- If the method calls another method, do not assume its return value unless its full declaration is provided. Request its declaration if needed.
- The method may throw an exception instead of returning null. An exception path should not be considered a null return.
- Ensure you request the declarations of any methods whose return values directly or indirectly impact this method’s return value before making a conclusion.
- Carefully analyze all conditions and prior operations that may guarantee a non-null return value.

@Nullable public static IGameLoop loop() {
    return gameLoop;
}

Here are the method definitions in addition to the method inquired:

Depth: 0
```java
class de.gurkenlabs.litiengine.Game {
@Nullable public static IGameLoop loop() {
    return gameLoop;
}
}
```


Response Format:
Provide the answer in **XML format** as follows:

#### If the method **cannot** return `null`:
```xml
<response>
  <reason><![CDATA[EXPLAIN WHY THE METHOD CANNOT RETURN NULL]]></reason>
  <value>NO</value>
</response>
```

#### If the method can return null:
```xml
<response>
  <reason><![CDATA[EXPLAIN WHY THE METHOD CAN RETURN NULL]]></reason>
  <value>YES</value>
</response>
```

#### If you are unsure or need more information, respond with where you can ask for more details or what specific information you need.

#### If you are unsure or If there are any methods that directly or indirectly affect the return value and are not fully disclosed, request their declarations first, in the following format:
<response>
  <reason><![CDATA[YOUR REASON]]></reason>
  <value>UNKNOWN</value>
  <methods>
    <method>methodName</method>
  </methods>
</response>

If additional information is required other than method declaration, list each request inside a `<request>` tag. If no additional information is needed, omit the `<requests>` section.

Respond with:
```xml
<response>
    <reason><![CDATA[YOUR REASON]]></reason>
    <value>UNKNOWN</value>
    <!-- Include <requests> only if additional information is needed -->
    <requests>
        <request><![CDATA[YOUR REQUEST 1]]></request>
        <request><![CDATA[YOUR REQUEST 2]]></request>
    </requests>
</response>
```

Additional Notes:
Be precise in your reasoning.
If a method’s return value depends on another method not provided, request its declaration before making a conclusion.
If the method can return null in some cases but not others, explain under what conditions it can happen.

---ChatGPT.sendRequestToOpenAI---
Retrieving response from cache
---Response.<init>---
Creating Response:
```xml
<response>
  <reason><![CDATA[The method `loop` returns the variable `gameLoop`. Without the initialization or assignment details of `gameLoop`, it's unclear whether it can be null. The possibility of `gameLoop` being uninitialized or set to null elsewhere in the program means `loop` could potentially return null. Further information on `gameLoop` is required.]]></reason>
  <value>UNKNOWN</value>
  <requests>
    <request><![CDATA[Please provide the declaration and initialization of the variable `gameLoop` in the class `de.gurkenlabs.litiengine.Game`.]]></request>
  </requests>
</response>
```
---Response.<init>---
Response created:
Unknown: The method `loop` returns the variable `gameLoop`. Without the initialization or assignment details of `gameLoop`, it's unclear whether it can be null. The possibility of `gameLoop` being uninitialized or set to null elsewhere in the program means `loop` could potentially return null. Further information on `gameLoop` is required.
---AdvancedNullAwayCodeFix.investigateMethodReturnNullability---
Could not determine the nullability and model did not ask for any method.
---ChatGPT.checkIfMethodIsReturningNullableOnCallSite---
Asking if the method is returning nullable on the call site: Game.loop()
---ChatGPT.ask---
Asking ChatGPT:
In the method below, is there a possibility that the method returns null at the given call site?

```java
@Nullable public static IGameLoop loop() {
    return gameLoop;
}
```

## Guidelines:
- The method may have multiple return paths; consider all return statements.
- If the method calls another method, do not assume its return value unless its full declaration is provided. Request its declaration if needed.
- The method may throw an exception instead of returning null. An exception path should not be considered a null return.
- Ensure you request the declarations of any methods whose return values directly or indirectly impact this method’s return value before making a conclusion.
- If the method returns a value that is determined by a parameter, evaluate based on the actual argument at the given call site.
- Analyze based only on the specific invocation provided. Do not generalize to all possible inputs.- If the return value is guaranteed to be non-null at the call site, the answer should be a definitive NO.
- Do not generalize based on all possible inputs—your answer must be based only on the given invocation.
- Focus only on the given call site, not all possible invocations.

### call site:
Game.loop()

Here are the method definitions and the call chain for this method, showing the sequence of calls from the method to its callers at each depth level:

Depth: 0
```java
class de.gurkenlabs.litiengine.Game {
@Nullable public static IGameLoop loop() {
    return gameLoop;
}
}
```
Depth: 1
```java
class de.gurkenlabs.litiengine.environment.GameWorld {
public void loadEnvironment(@Nullable final Environment env) {
    Lock lock = Game.loop().getLock();
    lock.lock();
    try {
      unloadEnvironment();
      this.environment = env;
      if (env != null) {
        this.addEnvironment(env);

        if (env.getGravity() == 0 && this.gravity() != 0) {
          env.setGravity(this.gravity());
        }

        env.load();
        for (final EnvironmentLoadedListener listener : this.loadedListeners) {
          listener.loaded(env);
        }

        // call map specific listeners
        String mapName = getMapName(env);
        if (mapName != null && this.environmentLoadedListeners.containsKey(mapName)) {

          // for the default camera we center the camera on the environment
          if (this.camera().getClass().equals(Camera.class)) {
            camera().setFocus(env.getCenter());
          }

          for (EnvironmentLoadedListener listener : this.environmentLoadedListeners.get(mapName)) {
            listener.loaded(env);
          }
        }
      }
    } finally {
      lock.unlock();
    }
}public void setCamera(@Nullable final ICamera cam) {
    if (this.camera() != null) {
      Game.loop().detach(camera);
    }

    camera = cam;

    if (cam != null && !Game.isInNoGUIMode()) {
      Game.loop().attach(cam);
      cam.updateFocus();
    }
}
}
```
```java
class de.gurkenlabs.litiengine.entities.behavior.EntityNavigator {
public EntityNavigator(final IMobileEntity entity, final PathFinder pathFinder) {
    this.cancelNavigationConditions = new CopyOnWriteArrayList<>();
    this.listeners = new CopyOnWriteArrayList<>();
    this.entity = entity;
    this.pathFinder = pathFinder;
    this.setAcceptableError(DEFAULT_ACCEPTABLE_ERROR);
    Game.loop().attach(this);
}
}
```
```java
class de.gurkenlabs.litiengine.GameWindow {
private static void initializeWindowEventListeners(Window window) {

    window.addWindowStateListener(
        e -> {
          if (e.getNewState() == Frame.ICONIFIED) {
            Game.loop().setTickRate(ICONIFIED_MAX_FPS);
          } else {
            Game.loop().setTickRate(Game.config().client().getMaxFps());
          }
        });

    window.addWindowFocusListener(
        new WindowFocusListener() {
          @Override
          public void windowLostFocus(WindowEvent e) {
            if (Game.config().graphics().reduceFramesWhenNotFocused()) {
              Game.loop().setTickRate(NONE_FOCUS_MAX_FPS);
            }
          }

          @Override
          public void windowGainedFocus(WindowEvent e) {
            Game.loop().setTickRate(Game.config().client().getMaxFps());
          }
        });

    window.addWindowListener(
        new WindowAdapter() {
          @Override
          public void windowClosing(final WindowEvent event) {
            Game.exit();
          }
        });
}
}
```
```java
class de.gurkenlabs.litiengine.gui.screens.ScreenManager {
public void display(@Nullable final Screen screen) {
    if (Game.hasStarted() && Game.time().since(this.lastScreenChange) < this.getChangeCooldown()) {
      log.log(
          Level.INFO,
          "Skipping displaying of screen {0} because screen changing is currently on cooldown.",
          screen != null ? screen.getName() : "");
      return;
    }

    final Screen previous = this.current();
    if (previous != null) {
      previous.suspend();
    }

    if (screen != null && !this.screens.contains(screen)) {
      this.screens.add(screen);
    }

    this.currentScreen = screen;
    if (!Game.isInNoGUIMode() && this.current() != null) {
      this.current().prepare();
    }

    this.lastScreenChange = Game.loop().getTicks();

    final ScreenChangedEvent event = new ScreenChangedEvent(this.current(), previous);
    for (final ScreenChangedListener listener : this.screenChangedListeners) {
      listener.changed(event);
    }
}
}
```
```java
class de.gurkenlabs.litiengine.abilities.effects.Effect {
@Override
  public void update() {

    for (final Iterator<EffectApplication> iterator = this.getActiveAppliances().iterator();
        iterator.hasNext(); ) {
      final EffectApplication appliance = iterator.next();
      // if the effect duration is reached
      if (this.hasEnded(appliance)) {

        iterator.remove();
        this.cease(appliance);
      }
    }

    // 4. unregister if all appliances are finished
    if (this.getActiveAppliances().isEmpty()) {
      Game.loop().detach(this);
    }
}public void apply(final Shape impactArea) {
    final List<ICombatEntity> affected = this.lookForAffectedEntities(impactArea);
    for (final ICombatEntity affectedEntity : affected) {
      this.apply(affectedEntity);
    }

    this.appliances.add(new EffectApplication(affected, impactArea));

    // if it is the first appliance -> register for update
    if (this.appliances.size() == 1) {
      Game.loop().attach(this);
    }
}
}
```
```java
class de.gurkenlabs.litiengine.GameTime {
public long toTicks(final int milliseconds) {
    return this.toTicks(milliseconds, Game.loop().getTickRate());
}public long since(final long tick) {
    return toMilliseconds(Game.loop().getTicks() - tick);
}public long now() {
    return Game.loop().getTicks();
}public long sinceGameStart() {
    return this.toMilliseconds(Game.loop().getTicks());
}@Override
  public void loaded(Environment environment) {
    environmentLoaded = Game.loop().getTicks();
}public long toMilliseconds(final long ticks) {
    return this.toMilliseconds(ticks, Game.loop().getTickRate());
}
}
```
```java
class de.gurkenlabs.litiengine.GameMetrics {
@Override
  public void render(final Graphics2D g) {
    this.updateMetrics();

    if (!Game.config().client().showGameMetrics()) {
      return;
    }

    this.currentOffsetY = 0;

    g.setColor(this.renderColor);

    // render client metrics
    this.drawTitle(g, "[client]");
    this.drawMetric(g, "fps       : " + this.getFramesPerSecond());
    this.drawMetric(g, "max fps   : " + this.maxFramesPerSecond);
    this.drawMetric(g, "updatables: " + Game.loop().getUpdatableCount());

    // render jvm metrics if debug is enabled
    if (Game.config().debug().isDebugEnabled()) {
      this.drawTitle(g, "[jvm]");
      this.drawMetric(g, "java      : " + this.javaVersion);
      this.drawMetric(g, "memory    : " + String.format("%-5.5s", this.usedMemory) + " MB");
      this.drawMetric(g, "threads   : " + Thread.activeCount());
    }

    // render rendering metrics
    if (!this.renderMetrics.isEmpty()) {
      this.drawTitle(g, "[update]");

      for (RenderMetrics metric : this.renderMetrics) {
        this.drawMetric(g, metric.toString());
      }

      this.renderMetrics.clear();
    }
}
}
```
```java
class de.gurkenlabs.litiengine.graphics.emitters.Emitter {
public void deactivate() {
    if (!this.activated) {
      return;
    }

    this.activated = false;
    this.getParticles().clear();
    this.aliveTime = 0;
    this.activationTick = 0;
    this.lastSpawn = 0;
    Game.loop().detach(this);
}public void activate() {
    if (this.activated) {
      return;
    }

    this.activated = true;
    this.activationTick = Game.time().now();
    Game.loop().attach(this);
}@Override
  public void update() {
    if (this.isPaused()) {
      return;
    }

    // clear particles if the effect time to life is reached
    if (this.isFinished()) {
      for (EmitterFinishedListener listener : this.finishedListeners) {
        listener.finished(this);
      }

      this.delete();
      return;
    }

    final float updateRatio = (float) this.data().getUpdateRate() / Game.loop().getTickRate();
    for (final Particle p : this.getParticles().stream().collect(Collectors.toList())) {
      if (this.particleCanBeRemoved(p)) {
        // remove dead particles
        this.particles.remove(p);
        continue;
      }

      p.update(this.getOrigin(), updateRatio);
    }

    this.aliveTime = Game.time().since(this.activationTick);
    if ((this.data().getSpawnRate() == 0
        || Game.time().since(this.lastSpawn) >= this.data().getSpawnRate())) {
      this.lastSpawn = Game.time().now();
      this.spawnParticle();
    }
}
}
```
```java
class de.gurkenlabs.litiengine.entities.behavior.IBehaviorController {
public default void attach() {
    Game.loop().attach(this);
}public default void detach() {
    Game.loop().detach(this);
}
}
```
```java
class de.gurkenlabs.litiengine.abilities.AbilityExecution {
AbilityExecution(final Ability ability) {
    this.appliedEffects = new CopyOnWriteArrayList<>();
    this.ability = ability;
    this.executionTicks = Game.time().now();
    this.impactArea = ability.calculateImpactArea();
    this.castLocation = ability.getExecutor().getCenter();
    Game.loop().attach(this);
}@Override
  public void update() {
    // if there a no effects to apply -> unregister this instance and we're done
    if (this.getAbility().getEffects().isEmpty()
        || this.getAbility().getEffects().size() == this.getAppliedEffects().size()) {
      Game.loop().detach(this);
      return;
    }

    // handle all effects from the ability that were not applied yet
    for (final Effect effect : this.getAbility().getEffects()) {
      // if the ability was not executed yet or the delay of the effect is not
      // yet reached
      if (this.getAppliedEffects().contains(effect)
          || Game.time().since(this.getExecutionTicks()) < effect.getDelay()) {
        continue;
      }

      effect.apply(this.getExecutionImpactArea());
      this.getAppliedEffects().add(effect);
    }
}
}
```
```java
class de.gurkenlabs.litiengine.GameWindow$3 {
@Override
          public void windowGainedFocus(WindowEvent e) {
            Game.loop().setTickRate(Game.config().client().getMaxFps());
}@Override
          public void windowLostFocus(WindowEvent e) {
            if (Game.config().graphics().reduceFramesWhenNotFocused()) {
              Game.loop().setTickRate(NONE_FOCUS_MAX_FPS);
            }
}
}
```
```java
class de.gurkenlabs.litiengine.environment.EntitySpawner {
protected void spawnNewEntities() {
    if (this.getSpawnMode() != SpawnMode.CUSTOMSPAWNPOINTS && this.getSpawnPoints().isEmpty()) {
      return;
    }

    switch (this.getSpawnMode()) {
      case ALLSPAWNPOINTS:
        for (int i = 0; i < this.getSpawnPoints().size(); i++) {
          final int index = i;
          Game.loop()
              .perform(
                  this.getSpawnDelay() + this.getSpawnDelay() * i,
                  () -> this.spawn(this.getSpawnPoints().get(index), this.getSpawnAmount()));
        }
        break;
      case ONERANDOMSPAWNPOINT:
        this.spawn(Game.random().choose(this.getSpawnPoints()), this.getSpawnAmount());
        break;
      case RANDOMSPAWNPOINTS:
        for (int i = 0; i < this.getSpawnAmount(); i++) {
          Game.loop()
              .perform(
                  this.getSpawnDelay() + this.getSpawnDelay() * i,
                  () -> this.spawn(Game.random().choose(this.getSpawnPoints()), 1));
        }
        break;
      case CUSTOMSPAWNPOINTS:
        List<Spawnpoint> spawnPoints =
            this.customSpawnpoints != null
                ? this.customSpawnpoints.apply(this)
                : this.getCustomSpawnpoints();

        int index = 0;
        for (Spawnpoint spawn : spawnPoints) {
          Game.loop()
              .perform(
                  this.getSpawnDelay() + this.getSpawnDelay() * index, () -> this.spawn(spawn, 1));
          index++;
        }
        break;
      default:
        break;
    }
}
}
```
```java
class de.gurkenlabs.litiengine.tweening.TweenEngine {
@Override
  public void start() {
    Game.loop().attach(this);
}@Override
  public void terminate() {
    Game.loop().detach(this);
}
}
```
```java
class de.gurkenlabs.litiengine.gui.SpeechBubble {
public void hide() {
    Game.world().environment().removeRenderable(this);
    Game.loop().detach(this);
    if (activeSpeechBubbles.get(this.getEntity()) != null
        && activeSpeechBubbles.remove(this.getEntity()).equals(this)) {
      activeSpeechBubbles.remove(this.getEntity());
    }

    for (SpeechBubbleListener listener : this.listeners) {
      listener.hidden();
    }
}private SpeechBubble(
      final IEntity entity,
      final String text,
      @Nullable SpeechBubbleAppearance appearance,
      @Nullable Font font) {
    if (appearance == null) {
      this.appearance = DEFAULT_APPEARANCE;
    } else {
      this.appearance = appearance;
    }

    final SpeechBubble active = activeSpeechBubbles.get(entity);
    if (active != null) {
      active.hide();
    }
    this.setFont(font);

    this.textBoxWidth = (float) (entity.getWidth() * 4);
    this.entity = entity;

    this.currentText = text;
    this.currentTextDisplayTime = DISPLAYTIME_MIN + text.length() * DISPLAYTIME_PER_LETTER;

    this.lastTextDisplay = Game.time().now();
    this.createBubbleImage();
    entity.getEnvironment().add(this, RenderType.UI);
    Game.loop().attach(this);
    activeSpeechBubbles.put(entity, this);
}
}
```
```java
class de.gurkenlabs.litiengine.entities.Prop {
private void updateAnimationController() {
    IEntityAnimationController<?> controller = this.createAnimationController();
    this.getControllers().addController(controller);
    if (Game.world().environment() != null && Game.world().environment().isLoaded()) {
      Game.loop().attach(controller);
    }
}
}
```
```java
class de.gurkenlabs.litiengine.graphics.FreeFlightCamera {
public FreeFlightCamera(final Point2D focus) {
    this.setFocus(focus);
    this.velocity = DEFAULT_SCROLL_PIXELS_PER_SECOND;
    this.scrollPadding = DEFAULT_SCROLL_PADDING;
    this.setClampToMap(true);

    Game.loop().attach(this);
}private void handleFreeFlightCamera() {
    if (Game.world().environment() == null || Game.world().environment().getMap() == null) {
      return;
    }

    final Point2D mouseLocation = Input.mouse().getLocation();

    final double scrollSpeed =
        this.getVelocity()
            / (double) Game.loop().getTickRate()
            * Game.config().input().getMouseSensitivity();

    double x = this.getFocus().getX();
    double y = this.getFocus().getY();

    double deltaX = 0;
    if (mouseLocation.getX() < this.getScrollPadding()) {
      deltaX -= scrollSpeed;
    } else if (Game.window().getResolution().getWidth() - mouseLocation.getX()
        < this.getScrollPadding()) {
      deltaX += scrollSpeed;
    }

    double deltaY = 0;
    if (mouseLocation.getY() < this.getScrollPadding()) {
      deltaY -= scrollSpeed;
    } else if (Game.window().getResolution().getHeight() - mouseLocation.getY()
        < this.getScrollPadding()) {
      deltaY += scrollSpeed;
    }

    x += deltaX;
    y += deltaY;

    this.setFocus(new Point2D.Double(x, y));
}
}
```
```java
class de.gurkenlabs.litiengine.environment.Environment {
private static void dispose(final Collection<? extends IEntity> entities) {
    for (final IEntity entity : entities) {
      if (entity instanceof IUpdateable) {
        Game.loop().detach((IUpdateable) entity);
      }

      entity.detachControllers();
    }
}private static void loadUpdatableOrEmitterEntity(IEntity entity) {
    if (entity instanceof Emitter) {
      final Emitter emitter = (Emitter) entity;
      if (emitter.isActivateOnInit()) {
        emitter.activate();
      }
    } else if (entity instanceof IUpdateable) {
      Game.loop().attach((IUpdateable) entity);
    }
}private void unload(final IEntity entity) {
    // 1. remove from physics engine
    if (entity instanceof ICollisionEntity) {
      Game.physics().remove((ICollisionEntity) entity);
    }

    // 2. unregister from update
    if (entity instanceof IUpdateable) {
      Game.loop().detach((IUpdateable) entity);
    }

    if (entity instanceof IMobileEntity) {
      this.removeGravity((IMobileEntity) entity);
    }

    // 3. detach all controllers
    entity.detachControllers();

    if (entity instanceof Emitter) {
      Emitter em = (Emitter) entity;
      em.deactivate();
    }

    if (this.loaded && (entity instanceof LightSource || entity instanceof StaticShadow)) {
      this.updateLighting(entity);
    }

    entity.removed(this);
}
}
```
```java
class de.gurkenlabs.litiengine.graphics.animation.Animation {
@Override
  public void update() {
    // do nothing if the animation is not playing or the current keyframe is not finished
    if (!this.isPlaying()
        || Game.time().since(this.lastFrameUpdate) < this.getCurrentKeyFrame().getDuration()) {
      return;
    }

    // if we are not looping and the last keyframe is finished, we terminate the animation
    if (!this.isLooping() && this.isLastKeyFrame()) {
      this.terminate();
      return;
    }

    // make sure, we stay inside the keyframe list
    final int newFrameIndex =
        (this.getKeyframes().indexOf(this.currentFrame) + 1) % this.getKeyframes().size();
    final KeyFrame previousFrame = this.currentFrame;
    this.currentFrame = this.getKeyframes().get(newFrameIndex);

    for (KeyFrameListener listener : this.listeners) {
      listener.currentFrameChanged(previousFrame, this.currentFrame);
    }

    this.lastFrameUpdate = Game.loop().getTicks();
}public void restart() {
    this.currentFrame = this.firstFrame;
    this.lastFrameUpdate = Game.loop().getTicks();
}
}
```
```java
class de.gurkenlabs.litiengine.physics.MovementController {
@Override
  public void attach() {
    Game.loop().attach(this);
}private void handleForces() {
    // clean up forces
    this.activeForces.forEach(
        x -> {
          if (x.hasEnded()) {
            this.activeForces.remove(x);
          }
        });

    if (this.activeForces.isEmpty()) {
      return;
    }

    // disable turn-on-move for force handling
    boolean turn = this.getEntity().turnOnMove();
    this.getEntity().setTurnOnMove(false);
    try {
      double deltaX = 0;
      double deltaY = 0;
      for (final Force force : this.activeForces) {
        if (force.cancelOnReached() && force.hasReached(this.getEntity())) {
          force.end();
          continue;
        }

        final Point2D collisionBoxCenter = this.getEntity().getCollisionBoxCenter();
        final double angle =
            GeometricUtilities.calcRotationAngleInDegrees(collisionBoxCenter, force.getLocation());
        final double strength =
            Game.loop().getDeltaTime() * 0.001f * force.getStrength() * Game.loop().getTimeScale();
        deltaX += GeometricUtilities.getDeltaX(angle, strength);
        deltaY += GeometricUtilities.getDeltaY(angle, strength);
      }

      final Point2D target =
          new Point2D.Double(this.getEntity().getX() + deltaX, this.getEntity().getY() + deltaY);
      final boolean success = Game.physics().move(this.getEntity(), target);
      if (!success) {
        for (final Force force : this.activeForces) {
          if (force.cancelOnCollision()) {
            force.end();
          }
        }
      }
    } finally {
      this.getEntity().setTurnOnMove(turn);
    }
}@Override
  public void detach() {
    Game.loop().detach(this);
}public void handleMovement() {
    if (!this.isMovementAllowed()) {
      this.velocity = 0;
      return;
    }

    // max distance an entity can travel within one tick
    final double maxPixelsPerTick = this.getEntity().getTickVelocity();
    final double deltaTime = Game.loop().getDeltaTime() * Game.loop().getTimeScale();

    final double acceleration =
        this.getEntity().getAcceleration() == 0
            ? maxPixelsPerTick
            : deltaTime / this.getEntity().getAcceleration() * maxPixelsPerTick;
    final double deceleration =
        this.getEntity().getDeceleration() == 0
            ? this.getVelocity()
            : deltaTime / this.getEntity().getDeceleration() * maxPixelsPerTick;

    double dx = this.getDx();
    double dy = this.getDy();
    this.setDx(0);
    this.setDy(0);

    final double deltaVelocity =
        Math.min(Math.sqrt(Math.pow(dx, 2) + Math.pow(dy, 2)), acceleration);
    if (deltaVelocity != 0) {
      double newVelocity = this.getVelocity() + deltaVelocity;
      this.setVelocity(newVelocity);
    } else {
      final double newVelocity = Math.max(0, this.getVelocity() - deceleration);
      this.setVelocity(newVelocity);
      dx = GeometricUtilities.getDeltaX(this.moveAngle);
      dy = GeometricUtilities.getDeltaY(this.moveAngle);
    }

    if (this.getVelocity() == 0) {
      this.moveAngle = 0;
      return;
    }

    // actually move entity
    this.moveEntity(dx, dy);
}
}
```
```java
class de.gurkenlabs.litiengine.graphics.animation.AnimationController {
public void detach() {
    Game.loop().detach(this);
}public void attach() {
    Game.loop().attach(this);
}
}
```
```java
class de.gurkenlabs.litiengine.graphics.Camera {
@Override
  public void setZoom(final float targetZoom, final int delay) {
    if (delay == 0) {

      this.zoom = targetZoom;
      this.targetZoom = 0;
      this.zoomDelay = 0;
      this.zoomTick = 0;
      this.zoomStep = 0;

      final ZoomChangedEvent event = new ZoomChangedEvent(this, targetZoom);
      for (final ZoomChangedListener listener : this.zoomListeners) {
        listener.zoomChanged(event);
      }
    } else {
      this.zoomTick = Game.time().now();
      this.targetZoom = targetZoom;
      this.zoomDelay = delay;

      final double tickduration = 1000 / (double) Game.loop().getTickRate();
      final double tickAmount = delay / tickduration;
      final float totalDelta = this.targetZoom - this.zoom;
      this.zoomStep = tickAmount > 0 ? (float) (totalDelta / tickAmount) : totalDelta;
    }
}
}
```
```java
class de.gurkenlabs.litiengine.Game {
public static synchronized void init(String... args) {
    if (initialized) {
      log().log(Level.INFO, "The game has already been initialized.");
      return;
    }

    log.init();
    handleCommandLineArguments(args);

    config().load();
    Locale.setDefault(new Locale(config().client().getCountry(), config().client().getLanguage()));

    gameLoop = new GameLoop("Main Update Loop", config().client().getMaxFps());
    loop().attach(physics());
    loop().attach(world());

    // setup default exception handling for render and update loop
    setUncaughtExceptionHandler(
        new DefaultUncaughtExceptionHandler(config().client().exitOnError()));

    screenManager = new ScreenManager();
    gameWindow = new GameWindow();

    // initialize  the game window
    window().init();
    world.setCamera(new Camera());

    for (GameListener listener : gameListeners) {
      listener.initialized(args);
    }

    if (!isInNoGUIMode()) {
      window().getRenderComponent().onRendered(g -> metrics().render(g));

      graphics()
          .addEntityRenderedListener(
              e -> DebugRenderer.renderEntityDebugInfo(e.getGraphics(), e.getEntity()));

      window().getRenderComponent().onFpsChanged(fps -> metrics().setFramesPerSecond(fps));
      window()
          .setIcons(
              Arrays.asList(
                  Resources.images().get("liti-logo-x16.png"),
                  Resources.images().get("liti-logo-x20.png"),
                  Resources.images().get("liti-logo-x32.png"),
                  Resources.images().get("liti-logo-x48.png")));

      Input.keyboard()
          .onKeyTyped(
              KeyEvent.VK_PRINTSCREEN,
              key -> {
                // don't take a screenshot if a modifier is active
                if (key.getModifiers() != 0) {
                  return;
                }

                window().getRenderComponent().takeScreenshot();
              });
    }

    Runtime.getRuntime().addShutdownHook(new Thread(Game::terminate, "Shutdown"));

    initialized = true;
}
}
```
```java
class de.gurkenlabs.litiengine.entities.Creature {
protected void updateAnimationController() {
    IEntityAnimationController<?> controller = this.createAnimationController();
    this.getControllers().addController(controller);
    if (Game.world().environment() != null && Game.world().environment().isLoaded()) {
      Game.loop().attach(controller);
    }
}@Override
  public float getTickVelocity() {
    // pixels per ms multiplied by the passed ms
    // ensure that entities don't travel too far in case of lag
    return Math.min(Game.loop().getDeltaTime(), GameLoop.TICK_DELTATIME_LAG)
        * 0.001F
        * this.getVelocity().get()
        * Game.loop().getTimeScale();
}
}
```
Depth: 2
```java
class de.gurkenlabs.litiengine.environment.GameWorld {
public void clear() {
    this.unloadEnvironment();
    this.environments.clear();
    this.setCamera(null);
    Game.physics().clear();

    this.environmentListeners.clear();
    this.environmentLoadedListeners.clear();
    this.environmentUnloadedListeners.clear();

    this.listeners.clear();
    this.loadedListeners.clear();
    this.unloadedListeners.clear();
}@Nullable
  public Environment loadEnvironment(IMap map) {
    Environment env = this.getEnvironment(map);
    this.loadEnvironment(env);
    return env;
}@Nullable
  public Environment loadEnvironment(String mapName) {
    Environment env = this.getEnvironment(mapName);
    this.loadEnvironment(env);
    return env;
}
}
```
```java
class de.gurkenlabs.litiengine.GameWindow {
GameWindow() {
    this.hostControl = new JFrame();

    this.resolutionChangedListeners = new CopyOnWriteArrayList<>();

    this.renderCanvas = new RenderComponent(Game.config().graphics().getResolution());
    this.cursor = new MouseCursor();
    if (!Game.isInNoGUIMode()) {
      this.hostControl.setBackground(Color.BLACK);
      this.hostControl.add(this.renderCanvas);

      this.initializeEventListeners();

      this.hostControl.setTitle(Game.info().getTitle());
      this.hostControl.setDefaultCloseOperation(WindowConstants.DO_NOTHING_ON_CLOSE);
      initializeWindowEventListeners(this.hostControl);
    }
}
}
```
```java
class de.gurkenlabs.litiengine.GameTime {
public long sinceEnvironmentLoad() {
    return this.since(this.environmentLoaded);
}public long since(final long tick) {
    return toMilliseconds(Game.loop().getTicks() - tick);
}public long sinceGameStart() {
    return this.toMilliseconds(Game.loop().getTicks());
}
}
```
```java
class de.gurkenlabs.litiengine.abilities.effects.Effect {
protected void cease(final EffectApplication appliance) {
    // 1. cease the effect for all affected entities
    for (final ICombatEntity entity : appliance.getAffectedEntities()) {
      this.cease(entity);
    }

    // 2. apply follow up effects
    this.getFollowUpEffects().forEach(followUp -> followUp.apply(appliance.getImpactArea()));
}protected boolean hasEnded(final EffectApplication appliance) {
    final long effectDuration = Game.time().since(appliance.getAppliedTicks());
    return effectDuration > this.getDuration();
}
}
```
```java
class de.gurkenlabs.litiengine.abilities.effects.EffectApplication {
protected EffectApplication(final List<ICombatEntity> affectedEntities, final Shape impactArea) {
    this.applied = Game.time().now();
    this.affectedEntities = affectedEntities;
    this.impactArea = impactArea;
}
}
```
```java
class de.gurkenlabs.litiengine.entities.CombatEntity {
@Override
  public boolean wasHit(int timeSpan) {
    return Game.time().since(this.lastHit) < timeSpan;
}@Override
  public void hit(final int damage, @Nullable final Ability ability) {
    if (this.isDead()) {
      return;
    }

    if (!this.isIndestructible()) {
      this.getHitPoints().modifyBaseValue(new AttributeModifier<>(Modification.SUBTRACT, damage));
    }

    final EntityHitEvent event = new EntityHitEvent(this, ability, damage, this.isDead());

    for (final CombatEntityListener listener : this.listeners) {
      listener.hit(event);
    }

    for (final CombatEntityHitListener listener : this.hitListeners) {
      listener.hit(event);
    }

    if (this.isDead()) {
      this.fireDeathEvent();
      this.setCollision(false);
    }

    this.lastHit = Game.time().now();
}
}
```
```java
class de.gurkenlabs.litiengine.graphics.ImageEffect {
protected ImageEffect(final int ttl, final String name) {
    this.ttl = ttl;
    this.name = name;
    this.aliveTick = Game.time().now();
}@Override
  public long getAliveTime() {
    return Game.time().since(this.aliveTick);
}
}
```
```java
class de.gurkenlabs.litiengine.abilities.AbilityExecution {
AbilityExecution(final Ability ability) {
    this.appliedEffects = new CopyOnWriteArrayList<>();
    this.ability = ability;
    this.executionTicks = Game.time().now();
    this.impactArea = ability.calculateImpactArea();
    this.castLocation = ability.getExecutor().getCenter();
    Game.loop().attach(this);
}@Override
  public void update() {
    // if there a no effects to apply -> unregister this instance and we're done
    if (this.getAbility().getEffects().isEmpty()
        || this.getAbility().getEffects().size() == this.getAppliedEffects().size()) {
      Game.loop().detach(this);
      return;
    }

    // handle all effects from the ability that were not applied yet
    for (final Effect effect : this.getAbility().getEffects()) {
      // if the ability was not executed yet or the delay of the effect is not
      // yet reached
      if (this.getAppliedEffects().contains(effect)
          || Game.time().since(this.getExecutionTicks()) < effect.getDelay()) {
        continue;
      }

      effect.apply(this.getExecutionImpactArea());
      this.getAppliedEffects().add(effect);
    }
}
}
```
```java
class de.gurkenlabs.litiengine.tweening.TweenEngine {
@Override
  public void update() {
    for (final Tweenable target : this.getTweens().keySet()) {
      for (final Tween tween : this.getTweens().get(target).values()) {
        if (tween.hasStopped()) {
          continue;
        }
        final long elapsed = Game.time().since(tween.getStartTime());
        if (elapsed >= tween.getDuration()) {
          tween.stop();
          continue;
        }
        final float[] currentValues = new float[tween.getTargetValues().length];
        for (int i = 0; i < tween.getTargetValues().length; i++) {
          currentValues[i] =
              tween.getStartValues()[i]
                  + tween.getEquation().compute(elapsed / (float) tween.getDuration())
                      * (tween.getTargetValues()[i] - tween.getStartValues()[i]);
        }
        tween.getTarget().setTweenValues(tween.getType(), currentValues);
      }
    }
}
}
```
```java
class de.gurkenlabs.litiengine.gui.SpeechBubble {
public static SpeechBubble create(
      final IEntity entity, final String text, SpeechBubbleAppearance appearance, Font font) {
    return new SpeechBubble(entity, text, appearance, font);
}public static SpeechBubble create(final IEntity entity, final Font font, final String text) {
    SpeechBubbleAppearance app =
        new SpeechBubbleAppearance(
            DEFAULT_APPEARANCE.getForeColor(),
            DEFAULT_APPEARANCE.getBackgroundColor1(),
            DEFAULT_APPEARANCE.getBorderColor(),
            DEFAULT_APPEARANCE.getPadding());
    return new SpeechBubble(entity, text, app, font);
}public static SpeechBubble create(final IEntity entity, final String text) {
    return new SpeechBubble(entity, text, null, GuiProperties.getDefaultFont());
}@Override
  public void update() {
    if (this.currentText == null) {
      this.hide();
      return;
    }

    this.entityCenter = Game.world().camera().getViewportLocation(this.getEntity().getCenter());

    // old text was displayed long enough
    if (this.lastTextDisplay != 0
        && Game.time().since(this.lastTextDisplay) > this.currentTextDisplayTime) {
      this.currentText = null;
      this.lastTextDisplay = 0;
      return;
    }

    // display new text
    if (this.textIndex < this.currentText.length()
        && Game.time().since(this.lastCharPoll) > LETTER_WRITE_DELAY) {
      this.textIndex++;
      this.lastCharPoll = Game.time().now();
      if (this.typeSound != null) {
        Game.audio().playSound(this.typeSound, this.getEntity());
      }
    }

    // continue displaying currently displayed text
}private SpeechBubble(
      final IEntity entity,
      final String text,
      final Sound typeSound,
      SpeechBubbleAppearance appearance,
      Font font) {
    this(entity, text, appearance, font);
    this.typeSound = typeSound;
}private SpeechBubble(
      final IEntity entity,
      final String text,
      @Nullable SpeechBubbleAppearance appearance,
      @Nullable Font font) {
    if (appearance == null) {
      this.appearance = DEFAULT_APPEARANCE;
    } else {
      this.appearance = appearance;
    }

    final SpeechBubble active = activeSpeechBubbles.get(entity);
    if (active != null) {
      active.hide();
    }
    this.setFont(font);

    this.textBoxWidth = (float) (entity.getWidth() * 4);
    this.entity = entity;

    this.currentText = text;
    this.currentTextDisplayTime = DISPLAYTIME_MIN + text.length() * DISPLAYTIME_PER_LETTER;

    this.lastTextDisplay = Game.time().now();
    this.createBubbleImage();
    entity.getEnvironment().add(this, RenderType.UI);
    Game.loop().attach(this);
    activeSpeechBubbles.put(entity, this);
}
}
```
```java
class de.gurkenlabs.litiengine.gui.TextFieldComponent {
@Override
  public void render(final Graphics2D g) {
    super.render(g);
    g.setFont(this.getFont());
    final FontMetrics fm = g.getFontMetrics();

    if (this.isSelected() && Game.time().since(this.lastToggled) > this.flickerDelay) {
      this.cursorVisible = !this.cursorVisible;
      this.lastToggled = Game.time().now();
    }
    if (this.isSelected() && this.cursorVisible) {
      final Rectangle2D cursor =
          new Rectangle2D.Double(
              this.getX() + this.getTextX() + fm.stringWidth(this.getTextToRender(g)),
              this.getY() + this.getTextY(),
              this.getFont().getSize2D() * 3 / 5,
              this.getFont().getSize2D() * 1 / 5);
      g.setColor(this.getAppearance().getForeColor());
      g.fill(cursor);
    }
}
}
```
```java
class de.gurkenlabs.litiengine.entities.Prop {
public Prop(
      final Point2D location, @Nullable final String spritesheetName, final Material material) {
    super();
    this.rotation = Rotation.NONE;
    this.spritesheetName = spritesheetName;
    this.material = material;
    this.setLocation(location);
    this.updateAnimationController();
}public void setSpritesheetName(@Nullable final String spriteName) {
    this.spritesheetName = spriteName;
    this.updateAnimationController();
}
}
```
```java
class de.gurkenlabs.litiengine.tweening.Tween {
public Tween begin() {
    this.started = Game.time().now();
    this.stopped = false;
    return this;
}
}
```
```java
class de.gurkenlabs.litiengine.graphics.emitters.particles.Particle {
public void update(final Point2D emitterOrigin, final float updateRatio) {
    if (this.aliveTick == 0) {
      this.aliveTick = Game.time().now();
    }

    this.aliveTime = Game.time().since(this.aliveTick);
    if (this.timeToLiveReached()) {
      return;
    }

    if (this.colliding) {
      return;
    }

    if (this.getDeltaWidth() != 0) {
      this.width += this.getDeltaWidth() * updateRatio;
    }

    if (this.getDeltaHeight() != 0) {
      this.height += this.getDeltaHeight() * updateRatio;
    }

    if (this.getDeltaAngle() != 0) {
      this.angle += this.getDeltaAngle() * updateRatio;
    }

    // test for ray cast collision
    final float targetX = this.x + this.getVelocityX() * updateRatio;
    final float targetY = this.y + this.getVelocityY() * updateRatio;

    if (targetX == this.x && targetY == this.y) {
      return;
    }

    if (this.checkForCollision(emitterOrigin, targetX, targetY)) {
      return;
    }

    if (this.getVelocityX() != 0) {
      this.x = targetX;
    }

    if (this.getVelocityY() != 0) {
      this.y = targetY;
    }

    if (this.getAccelerationX() != 0) {
      this.velocityX += this.getAccelerationX() * updateRatio;
    }

    if (this.getAccelerationY() != 0) {
      this.velocityY += this.getAccelerationY() * updateRatio;
    }
}
}
```
```java
class de.gurkenlabs.litiengine.graphics.animation.Animation {
@Override
  public void start() {
    this.playing = true;
    if (this.getKeyframes().isEmpty()) {
      return;
    }

    this.restart();
}@Override
  public void update() {
    // do nothing if the animation is not playing or the current keyframe is not finished
    if (!this.isPlaying()
        || Game.time().since(this.lastFrameUpdate) < this.getCurrentKeyFrame().getDuration()) {
      return;
    }

    // if we are not looping and the last keyframe is finished, we terminate the animation
    if (!this.isLooping() && this.isLastKeyFrame()) {
      this.terminate();
      return;
    }

    // make sure, we stay inside the keyframe list
    final int newFrameIndex =
        (this.getKeyframes().indexOf(this.currentFrame) + 1) % this.getKeyframes().size();
    final KeyFrame previousFrame = this.currentFrame;
    this.currentFrame = this.getKeyframes().get(newFrameIndex);

    for (KeyFrameListener listener : this.listeners) {
      listener.currentFrameChanged(previousFrame, this.currentFrame);
    }

    this.lastFrameUpdate = Game.loop().getTicks();
}
}
```
```java
class de.gurkenlabs.litiengine.graphics.animation.AnimationController {
@Override
  public void update() {
    for (final Animation animation : this.getAll()) {
      animation.update();
    }

    if (this.getCurrent() != null && this.getCurrent().isPaused()) {
      return;
    }

    final boolean playbackFinished = this.getCurrent() != null && !this.getCurrent().isPlaying();
    if (playbackFinished) {
      for (final AnimationListener listener : this.listeners) {
        listener.finished(this.getCurrent());
      }
    }

    if (this.getCurrent() == null || playbackFinished) {
      if (this.getDefault() != null) {
        this.play(this.getDefault().getName());
      } else {
        this.currentAnimation = null;
      }
    }
}
}
```
```java
class de.gurkenlabs.litiengine.graphics.RenderComponent {
private void handleFade() {
    if (this.fadeOutStart != -1) {
      final long timePassed = Game.time().since(this.fadeOutStart);
      this.currentAlpha = MathUtilities.clamp(1 - timePassed / (float) this.fadeOutTime, 0, 1);
      if (this.currentAlpha == 0f) {
        this.fadeOutStart = -1;
        this.fadeOutTime = -1;
      }

      return;
    }

    if (this.fadeInStart != -1) {
      final long timePassed = Game.time().since(this.fadeInStart);
      this.currentAlpha = MathUtilities.clamp(timePassed / (float) this.fadeInTime, 0, 1);
      if (this.currentAlpha == 1f) {
        this.fadeInStart = -1;
        this.fadeInTime = -1;
        this.currentAlpha = Float.NaN;
      }
    }
}public void fadeOut(final int ms) {
    this.fadeInStart = -1;
    this.fadeInTime = -1;
    this.fadeOutStart = Game.time().now();
    this.fadeOutTime = ms;
}public void fadeIn(final int ms) {
    this.fadeOutStart = -1;
    this.fadeOutTime = -1;
    this.fadeInStart = Game.time().now();
    this.fadeInTime = ms;
}
}
```
```java
class de.gurkenlabs.litiengine.entities.Trigger {
private boolean activate(final IEntity activator, final int tar) {
    if (!this.isLoaded()
        || this.isOneTimeTrigger && this.isActivated
        || this.getActivationType() == TriggerActivation.COLLISION
            && activator != null
            && this.collisionActivated.contains(activator)) {
      return false;
    }

    if (this.getCooldown() > 0 && Game.time().since(this.lastActivation) < this.getCooldown()) {
      return false;
    }

    List<Integer> triggerTargets = this.getTargets(tar);

    final TriggerEvent te = new TriggerEvent(this, activator, triggerTargets);

    if (!this.checkActivationPredicates(te)) {
      return false;
    }

    this.isActivated = true;
    if (activator != null) {
      this.collisionActivated.add(activator);
    }

    // if we actually have a trigger target, we send the message to the target
    for (final int target : triggerTargets) {
      final IEntity entity = this.getEnvironment().get(target);
      if (entity == null) {
        log.log(
            Level.WARNING,
            "trigger [{0}] was activated, but the trigger target [{1}] could not be found on the environment",
            new Object[] {this, target});
        continue;
      }

      entity.sendMessage(this, this.message);
    }

    // also send the trigger event to all registered consumers
    for (final TriggerActivatedListener listener : this.activatedListeners) {
      listener.activated(te);
    }

    if (this.isOneTimeTrigger) {
      this.getEnvironment().remove(this);
    }

    this.lastActivation = Game.time().now();
    return true;
}
}
```
```java
class de.gurkenlabs.litiengine.graphics.Camera {
private boolean isShakeEffectActive() {
    return this.getShakeTick() != 0
        && Game.time().since(this.getShakeTick()) < this.getShakeDuration();
}@Override
  public void update() {
    if (Game.world().camera() != null && !Game.world().camera().equals(this)) {
      return;
    }

    if (this.targetZoom > 0) {
      if (Game.time().since(this.zoomTick) >= this.zoomDelay) {
        this.zoom = this.targetZoom;
        this.targetZoom = 0;
        this.zoomDelay = 0;
        this.zoomTick = 0;
        this.zoomStep = 0;
      } else {
        this.zoom += this.zoomStep;
      }

      final ZoomChangedEvent event = new ZoomChangedEvent(this, this.getZoom());
      for (final ZoomChangedListener listener : this.zoomListeners) {
        listener.zoomChanged(event);
      }
    }

    if (this.panTime > 0) {
      if (--this.panTime <= 0) {
        this.setFocus(this.targetFocus);
        this.targetFocus = null;
      } else {
        double diff = this.panTime / (this.panTime + 1.0);
        this.focus =
            new Point2D.Double(
                this.focus.getX() * diff + this.targetFocus.getX() * (1.0 - diff),
                this.focus.getY() * diff + this.targetFocus.getY() * (1.0 - diff));
      }
    }

    if (!this.isShakeEffectActive()) {
      this.shakeOffsetX = 0;
      this.shakeOffsetY = 0;
      return;
    }

    if (Game.time().since(this.lastShake) > this.shakeDelay) {
      this.shakeOffsetX = this.getShakeIntensity() * ThreadLocalRandom.current().nextGaussian();
      this.shakeOffsetY = this.getShakeIntensity() * ThreadLocalRandom.current().nextGaussian();
      this.lastShake = Game.time().now();
    }
}@Override
  public void setZoom(final float targetZoom, final int delay) {
    if (delay == 0) {

      this.zoom = targetZoom;
      this.targetZoom = 0;
      this.zoomDelay = 0;
      this.zoomTick = 0;
      this.zoomStep = 0;

      final ZoomChangedEvent event = new ZoomChangedEvent(this, targetZoom);
      for (final ZoomChangedListener listener : this.zoomListeners) {
        listener.zoomChanged(event);
      }
    } else {
      this.zoomTick = Game.time().now();
      this.targetZoom = targetZoom;
      this.zoomDelay = delay;

      final double tickduration = 1000 / (double) Game.loop().getTickRate();
      final double tickAmount = delay / tickduration;
      final float totalDelta = this.targetZoom - this.zoom;
      this.zoomStep = tickAmount > 0 ? (float) (totalDelta / tickAmount) : totalDelta;
    }
}@Override
  public void shake(final double intensity, final int delay, final int shakeDuration) {
    this.shakeTick = Game.time().now();
    this.shakeDelay = delay;
    this.shakeIntensity = intensity;
    this.shakeDuration = shakeDuration;
}
}
```
```java
class de.gurkenlabs.litiengine.entities.Creature {
public void setSpritesheetName(String spritesheetName) {
    if (this.spritesheetName != null && this.spritesheetName.equals(spritesheetName)) {
      return;
    }

    this.spritesheetName = spritesheetName;
    this.updateAnimationController();
}public boolean isIdle() {
    return Game.time().since(this.lastMoved) > IDLE_DELAY;
}@Override
  public void setLocation(final Point2D position) {
    if (this.isDead() || position == null) {
      return;
    }

    final Point2D oldLocation = this.getLocation();
    super.setLocation(position);

    if (Game.hasStarted() && this.isLoaded()) {
      this.lastMoved = Game.time().now();
      this.fireMovedEvent(
          new EntityMovedEvent(
              this, this.getX() - oldLocation.getX(), this.getY() - oldLocation.getY()));
    }
}
}
```
```java
class de.gurkenlabs.litiengine.gui.screens.ScreenManager {
public void display(final String screenName) {
    if (this.current() != null && this.current().getName().equalsIgnoreCase(screenName)) {
      log.log(
          Level.INFO,
          "Skipping displaying of screen {0} because it is already the current screen.",
          screenName);
      return;
    }

    if (this.screens.stream()
        .noneMatch(element -> element.getName().equalsIgnoreCase(screenName))) {
      log.log(
          Level.WARNING,
          "Could not display the screen {0} because there is no screen with the specified name.",
          screenName);
      return;
    }

    Screen screen = this.get(screenName);
    if (screen == null) {
      return;
    }

    this.display(screen);
}public void add(final Screen screen) {
    screen.setWidth(Game.window().getWidth());
    screen.setHeight(Game.window().getHeight());
    this.screens.add(screen);

    if (this.current() == null) {
      this.display(screen);
    }
}public void remove(Screen screen) {
    this.screens.remove(screen);
    if (this.current() == screen) {
      if (!this.screens.isEmpty()) {
        this.display(this.screens.get(0));
      } else {
        this.display((Screen) null);
      }
    }
}public void display(@Nullable final Screen screen) {
    if (Game.hasStarted() && Game.time().since(this.lastScreenChange) < this.getChangeCooldown()) {
      log.log(
          Level.INFO,
          "Skipping displaying of screen {0} because screen changing is currently on cooldown.",
          screen != null ? screen.getName() : "");
      return;
    }

    final Screen previous = this.current();
    if (previous != null) {
      previous.suspend();
    }

    if (screen != null && !this.screens.contains(screen)) {
      this.screens.add(screen);
    }

    this.currentScreen = screen;
    if (!Game.isInNoGUIMode() && this.current() != null) {
      this.current().prepare();
    }

    this.lastScreenChange = Game.loop().getTicks();

    final ScreenChangedEvent event = new ScreenChangedEvent(this.current(), previous);
    for (final ScreenChangedListener listener : this.screenChangedListeners) {
      listener.changed(event);
    }
}
}
```
```java
class de.gurkenlabs.litiengine.abilities.Ability {
public boolean isOnCooldown() {
    return (this.getCurrentExecution() != null
        && this.getCurrentExecution().getExecutionTicks() > 0
        && Game.time().since(this.getCurrentExecution().getExecutionTicks())
            < this.getAttributes().cooldown().get());
}public boolean isActive() {
    return this.getCurrentExecution() != null
        && Game.time().since(this.getCurrentExecution().getExecutionTicks())
            < this.getAttributes().duration().get();
}@Nullable
  public AbilityExecution cast() {
    if (!this.canCast()) {
      return null;
    }
    this.currentExecution = new AbilityExecution(this);

    for (final AbilityCastListener listener : this.abilityCastListeners) {
      listener.abilityCast(this.currentExecution);
    }

    return this.getCurrentExecution();
}public float getRemainingCooldownInSeconds() {
    if (this.getCurrentExecution() == null
        || this.getExecutor() == null
        || this.getExecutor().isDead()) {
      return 0;
    }

    // calculate cooldown in seconds
    return (float)
        (!this.canCast()
            ? (this.getAttributes().cooldown().get()
                    - Game.time().since(this.getCurrentExecution().getExecutionTicks()))
                * 0.001
            : 0);
}
}
```
```java
class de.gurkenlabs.litiengine.entities.EntityHitEvent {
EntityHitEvent(
      final ICombatEntity hitEntity,
      @Nullable final Ability ability,
      final int damage,
      final boolean kill) {
    super(hitEntity);
    this.executor = ability != null ? ability.getExecutor() : null;
    this.hitEntity = hitEntity;
    this.ability = ability;
    this.damage = damage;
    this.kill = kill;
    this.time = Game.time().now();
}
}
```
```java
class de.gurkenlabs.litiengine.graphics.emitters.Emitter {
public void delete() {
    this.deactivate();
    if (Game.world().environment() != null) {
      Game.world().environment().remove(this);
    }
}public void activate() {
    if (this.activated) {
      return;
    }

    this.activated = true;
    this.activationTick = Game.time().now();
    Game.loop().attach(this);
}@Override
  public void update() {
    if (this.isPaused()) {
      return;
    }

    // clear particles if the effect time to life is reached
    if (this.isFinished()) {
      for (EmitterFinishedListener listener : this.finishedListeners) {
        listener.finished(this);
      }

      this.delete();
      return;
    }

    final float updateRatio = (float) this.data().getUpdateRate() / Game.loop().getTickRate();
    for (final Particle p : this.getParticles().stream().collect(Collectors.toList())) {
      if (this.particleCanBeRemoved(p)) {
        // remove dead particles
        this.particles.remove(p);
        continue;
      }

      p.update(this.getOrigin(), updateRatio);
    }

    this.aliveTime = Game.time().since(this.activationTick);
    if ((this.data().getSpawnRate() == 0
        || Game.time().since(this.lastSpawn) >= this.data().getSpawnRate())) {
      this.lastSpawn = Game.time().now();
      this.spawnParticle();
    }
}
}
```
```java
class de.gurkenlabs.litiengine.GameLoop {
@Override
  public int perform(int delay, Runnable action) {
    final long d = Game.time().toTicks(delay);

    TimedAction a = new TimedAction(this.getTicks() + d, action);
    this.actions.add(a);

    return a.getId();
}
}
```
```java
class de.gurkenlabs.litiengine.environment.EntitySpawner {
protected boolean shouldSpawn() {
    return this.lastSpawnWave == 0
        || Game.time().since(this.lastSpawnWave) >= this.getSpawnInterval();
}@Override
  public void update() {
    if (!this.shouldSpawn()) {
      return;
    }

    this.spawnNewEntities();
    this.lastSpawnWave = Game.time().now();
}
}
```
```java
class de.gurkenlabs.litiengine.graphics.FreeFlightCamera {
@Override
  public void update() {
    this.handleFreeFlightCamera();
}public FreeFlightCamera(double x, double y) {
    this(new Point2D.Double(x, y));
}
}
```
```java
class de.gurkenlabs.litiengine.environment.Environment {
public void unload() {
    if (!this.loaded) {
      return;
    }

    // unregister all updatable entities from the current environment
    for (final IEntity entity : this.allEntities.values()) {
      this.unload(entity);
    }

    this.loaded = false;
    this.fireEvent(l -> l.unloaded(this));
}private static void loadUpdatableOrEmitterEntity(IEntity entity) {
    if (entity instanceof Emitter) {
      final Emitter emitter = (Emitter) entity;
      if (emitter.isActivateOnInit()) {
        emitter.activate();
      }
    } else if (entity instanceof IUpdateable) {
      Game.loop().attach((IUpdateable) entity);
    }
}public void clear() {
    Game.physics().clear();

    this.combatEntities.clear();
    this.mobileEntities.clear();
    this.gravityForces.clear();
    this.layerEntities.clear();
    this.entitiesByTag.clear();
    this.allEntities.clear();

    for (RenderType renderType : RenderType.values()) {
      this.miscEntities.get(renderType).clear();
      this.renderListeners.get(renderType).clear();
      this.renderables.get(renderType).clear();
    }

    dispose(this.allEntities.values());
    dispose(this.triggers);
    this.emitters.clear();
    this.colliders.clear();
    this.props.clear();
    this.creatures.clear();
    this.staticShadows.clear();
    this.combatEntities.clear();
    this.mobileEntities.clear();
    this.lightSources.clear();
    this.spawnPoints.clear();
    this.soundSources.clear();
    this.mapAreas.clear();
    this.triggers.clear();

    this.ambientLight = null;
    this.staticShadowLayer = null;

    for (Map<Integer, IEntity> type : this.miscEntities.values()) {
      type.clear();
    }

    this.initialized = false;

    this.fireEvent(l -> l.cleared(this));
}private void load(final IEntity entity) {
    // an entity can only exist on one environment at a time, so remove it from the current one
    if (entity.getEnvironment() != null) {
      entity.getEnvironment().remove(entity);
    }

    // 1. add to physics engine
    loadPhysicsEntity(entity);

    // 2. register for update or activate
    loadUpdatableOrEmitterEntity(entity);

    // 3. if a gravity is defined, add a gravity force to the entity
    if (entity instanceof IMobileEntity && this.getGravity() != 0) {
      this.addGravityForce((IMobileEntity) entity);
    }

    // 4. attach all controllers
    entity.attachControllers();

    if (this.loaded && (entity instanceof LightSource || entity instanceof StaticShadow)) {
      this.updateLighting(entity);
    }

    entity.loaded(this);
}private void unload(final IEntity entity) {
    // 1. remove from physics engine
    if (entity instanceof ICollisionEntity) {
      Game.physics().remove((ICollisionEntity) entity);
    }

    // 2. unregister from update
    if (entity instanceof IUpdateable) {
      Game.loop().detach((IUpdateable) entity);
    }

    if (entity instanceof IMobileEntity) {
      this.removeGravity((IMobileEntity) entity);
    }

    // 3. detach all controllers
    entity.detachControllers();

    if (entity instanceof Emitter) {
      Emitter em = (Emitter) entity;
      em.deactivate();
    }

    if (this.loaded && (entity instanceof LightSource || entity instanceof StaticShadow)) {
      this.updateLighting(entity);
    }

    entity.removed(this);
}public void remove(final IEntity entity) {
    if (entity == null) {
      return;
    }

    this.allEntities.remove(entity.getMapId());
    Iterator<List<IEntity>> iter = this.layerEntities.values().iterator();
    while (iter.hasNext()) {
      List<IEntity> layer = iter.next();
      if (layer.remove(entity) && layer.isEmpty()) {
        iter.remove();
      }
    }
    if (this.miscEntities.get(entity.getRenderType()) != null) {
      this.miscEntities.get(entity.getRenderType()).values().remove(entity);
    }

    for (String tag : entity.getTags()) {
      if (this.getEntitiesByTag().containsKey(tag)) {
        this.getEntitiesByTag().get(tag).remove(entity);

        if (this.getEntitiesByTag().get(tag).isEmpty()) {
          this.getEntitiesByTag().remove(tag);
        }
      }
    }

    if (entity instanceof Emitter) {
      Emitter emitter = (Emitter) entity;
      this.removeEmitter(emitter);
    }

    if (entity instanceof MapArea) {
      this.mapAreas.remove(entity);
    }

    if (entity instanceof Prop) {
      this.props.remove(entity);
    }

    if (entity instanceof Creature) {
      this.creatures.remove(entity);
    }

    if (entity instanceof CollisionBox) {
      this.colliders.remove(entity);
      this.staticShadows.removeIf(x -> x.getOrigin() != null && x.getOrigin().equals(entity));
    }

    if (entity instanceof LightSource) {
      this.lightSources.remove(entity);
      this.updateLighting(entity);
    }

    if (entity instanceof Trigger) {
      this.triggers.remove(entity);
    }

    if (entity instanceof Spawnpoint) {
      this.spawnPoints.remove(entity);
    }
    if (entity instanceof SoundSource) {
      this.soundSources.remove(entity);
    }

    if (entity instanceof StaticShadow) {
      this.staticShadows.remove(entity);
      this.updateLighting(entity);
    }

    if (entity instanceof IMobileEntity) {
      this.mobileEntities.values().remove(entity);
    }

    if (entity instanceof ICombatEntity) {
      this.combatEntities.values().remove(entity);
    }

    this.unload(entity);

    this.fireEntityEvent(l -> l.entityRemoved(entity));
}
}
```
```java
class de.gurkenlabs.litiengine.physics.MovementController {
@Override
  public void update() {
    this.handleForces();
    this.handleMovement();
}
}
```
```java
class de.gurkenlabs.litiengine.Game {
static synchronized void terminate() {
    if (!initialized) {
      return;
    }

    hasStarted = false;
    initialized = false;

    config().save();
    gameLoop.terminate();
    tweenEngine.terminate();
    soundEngine.terminate();

    world().clear();

    for (final GameListener listener : gameListeners) {
      try {
        listener.terminated();
      } catch (Exception e) {
        log().log(Level.WARNING, "game listener threw an exception during shutdown", e);
      }
    }

    gameLoop = null;
    screenManager = null;
    gameWindow = null;
}public static synchronized void start() {
    if (!initialized) {
      throw new IllegalStateException(
          "The game cannot be started without being first initialized. Call Game.init(...) before Game.start().");
    }

    gameLoop.start();
    tweenEngine.start();
    soundEngine.start();

    for (final GameListener listener : gameListeners) {
      listener.started();
    }

    hasStarted = true;
}public static synchronized void init(String... args) {
    if (initialized) {
      log().log(Level.INFO, "The game has already been initialized.");
      return;
    }

    log.init();
    handleCommandLineArguments(args);

    config().load();
    Locale.setDefault(new Locale(config().client().getCountry(), config().client().getLanguage()));

    gameLoop = new GameLoop("Main Update Loop", config().client().getMaxFps());
    loop().attach(physics());
    loop().attach(world());

    // setup default exception handling for render and update loop
    setUncaughtExceptionHandler(
        new DefaultUncaughtExceptionHandler(config().client().exitOnError()));

    screenManager = new ScreenManager();
    gameWindow = new GameWindow();

    // initialize  the game window
    window().init();
    world.setCamera(new Camera());

    for (GameListener listener : gameListeners) {
      listener.initialized(args);
    }

    if (!isInNoGUIMode()) {
      window().getRenderComponent().onRendered(g -> metrics().render(g));

      graphics()
          .addEntityRenderedListener(
              e -> DebugRenderer.renderEntityDebugInfo(e.getGraphics(), e.getEntity()));

      window().getRenderComponent().onFpsChanged(fps -> metrics().setFramesPerSecond(fps));
      window()
          .setIcons(
              Arrays.asList(
                  Resources.images().get("liti-logo-x16.png"),
                  Resources.images().get("liti-logo-x20.png"),
                  Resources.images().get("liti-logo-x32.png"),
                  Resources.images().get("liti-logo-x48.png")));

      Input.keyboard()
          .onKeyTyped(
              KeyEvent.VK_PRINTSCREEN,
              key -> {
                // don't take a screenshot if a modifier is active
                if (key.getModifiers() != 0) {
                  return;
                }

                window().getRenderComponent().takeScreenshot();
              });
    }

    Runtime.getRuntime().addShutdownHook(new Thread(Game::terminate, "Shutdown"));

    initialized = true;
}
}
```


Response Format:
Provide the answer in **XML format** as follows:

#### If the method **cannot** return `null` at the specific call site:
```xml
<response>
  <reason><![CDATA[EXPLAIN WHY THE INVOCATION Game.loop() RESULT CANNOT BE NULL.]]></reason>
  <value>NO</value>
</response>

#### If the method can return null at the specific call site:
<response>
  <reason><![CDATA[EXPLAIN WHY THE INVOCATION Game.loop() RESULT CAN BE NULL.]]></reason>
  <value>YES</value>
</response>

#### If you are unsure or If there are any methods that directly or indirectly affect the return value and are not fully disclosed, request their declarations first, in the following format:
<response>
  <reason><![CDATA[EXPLAIN WHY THIS METHOD DECLARATION IS NECESSARY AND WHY YOU CANNOT MAKE A CONFIDENT DECISION WITHOUT IT]]></reason>
  <success>false</success>
  <methods>
    <method>methodName</method>
  </methods>
</response>

Additional Notes:
Be precise in your reasoning.
If a method’s return value depends on another method not provided, request its declaration before making a conclusion.
If the method can return null in this case but not in others, explain why it happens specifically for this call.

---ChatGPT.sendRequestToOpenAI---
Retrieving response from cache
---Response.<init>---
Creating Response:
```xml
<response>
  <reason><![CDATA[The method `Game.loop()` returns the static field `gameLoop`, which is initialized in the `Game.init(String... args)` method. In this method, a new `GameLoop` object is instantiated and assigned to `gameLoop`. Since `init()` must be called before `start()`, which is implied by the requirement of initializing the game, the `gameLoop` is guaranteed to be non-null during the lifetime of the game execution where `Game.loop()` is called. The absence of any code that could set `gameLoop` to null after its initialization ensures that `Game.loop()` cannot return null.]]></reason>
  <value>NO</value>
</response>
```
---Response.<init>---
Response created:
Disagreement: The method `Game.loop()` returns the static field `gameLoop`, which is initialized in the `Game.init(String... args)` method. In this method, a new `GameLoop` object is instantiated and assigned to `gameLoop`. Since `init()` must be called before `start()`, which is implied by the requirement of initializing the game, the `gameLoop` is guaranteed to be non-null during the lifetime of the game execution where `Game.loop()` is called. The absence of any code that could set `gameLoop` to null after its initialization ensures that `Game.loop()` cannot return null.
---AdvancedNullAwayCodeFix.resolveMethodDereferenceError---
Method is not returning nullable on call site. Injecting suppression annotation.
---AdvancedNullAwayCodeFix.constructCastToNonnullChange---
Constructing cast to nonnull change for reason: The method `Game.loop()` returns the static field `gameLoop`, which is initialized in the `Game.init(String... args)` method. In this method, a new `GameLoop` object is instantiated and assigned to `gameLoop`. Since `init()` must be called before `start()`, which is implied by the requirement of initializing the game, the `gameLoop` is guaranteed to be non-null during the lifetime of the game execution where `Game.loop()` is called. The absence of any code that could set `gameLoop` to null after its initialization ensures that `Game.loop()` cannot return null.
---ChatGPT.ask---
Asking ChatGPT:
For the reason you mentioned earlier:

"The method `Game.loop()` returns the static field `gameLoop`, which is initialized in the `Game.init(String... args)` method. In this method, a new `GameLoop` object is instantiated and assigned to `gameLoop`. Since `init()` must be called before `start()`, which is implied by the requirement of initializing the game, the `gameLoop` is guaranteed to be non-null during the lifetime of the game execution where `Game.loop()` is called. The absence of any code that could set `gameLoop` to null after its initialization ensures that `Game.loop()` cannot return null."

in the method below, the expression Game.loop() is not nullable at the point it is used.

```java
protected void spawnNewEntities() {
    if (this.getSpawnMode() != SpawnMode.CUSTOMSPAWNPOINTS && this.getSpawnPoints().isEmpty()) {
      return;
    }

    switch (this.getSpawnMode()) {
      case ALLSPAWNPOINTS:
        for (int i = 0; i < this.getSpawnPoints().size(); i++) {
          final int index = i;
          Game.loop()
              .perform(
                  this.getSpawnDelay() + this.getSpawnDelay() * i,
                  () -> this.spawn(this.getSpawnPoints().get(index), this.getSpawnAmount()));
        }
        break;
      case ONERANDOMSPAWNPOINT:
        this.spawn(Game.random().choose(this.getSpawnPoints()), this.getSpawnAmount());
        break;
      case RANDOMSPAWNPOINTS:
        for (int i = 0; i < this.getSpawnAmount(); i++) {
          Game.loop()
              .perform(
                  this.getSpawnDelay() + this.getSpawnDelay() * i,
                  () -> this.spawn(Game.random().choose(this.getSpawnPoints()), 1));
        }
        break;
      case CUSTOMSPAWNPOINTS:
        List<Spawnpoint> spawnPoints =
            this.customSpawnpoints != null
                ? this.customSpawnpoints.apply(this)
                : this.getCustomSpawnpoints();

        int index = 0;
        for (Spawnpoint spawn : spawnPoints) {
          Game.loop()
              .perform(
                  this.getSpawnDelay() + this.getSpawnDelay() * index, () -> this.spawn(spawn, 1));
          index++;
        }
        break;
      default:
        break;
    }
}
```
Please Summarize the reason in max 5 words and rewrite the method so that at the line "          Game.loop()", at the occurrence of: "Game.loop()" is replaced with `NullabilityUtil.castToNonnull(Game.loop(), summary of reason)`
Replace "REASON" with the exact reason summary I provide to you (maximum 5 words), not with a generic explanation like "checked to be nonnull".
see the example below, for expression `foo.getBar()`, to wrap it with `NullabilityUtil.castToNonnull(foo.getBar(), "reason")`.

```java
public t(){
    String l = foo.getBar();
}
```

will be:
```java
public t(){
    String l = NullabilityUtil.castToNonnull(foo.getBar(), "checked to be nonnull");
}
```

### Instructions:

Do not import any additional classes.

Do not add Java comments.

Only modify relevant lines as required.

Return only the modified method wrapped in the XML format shown below.

Place the Java code inside the <code> tag using a CDATA block with ```java formatting.

Just give me the fixed code snippet in XML format in <response> tag like the example below. I will apply the fix to my codebase. Do not import any additional libraries or classes or add java comments. If you can provide the fixed code snippet, please provide it in the following format and place the code snippet in the <code> tag within ```java block.
<response>
  <success>true</success>
  <code><![CDATA[
  ```java
  Your fixed code snippet here
  ```
    ]]>
  </code>
</response>

---ChatGPT.sendRequestToOpenAI---
Retrieving response from cache
---Response.<init>---
Creating Response:
<response>
  <success>true</success>
  <code><![CDATA[
  ```java
  protected void spawnNewEntities() {
      if (this.getSpawnMode() != SpawnMode.CUSTOMSPAWNPOINTS && this.getSpawnPoints().isEmpty()) {
        return;
      }
  
      switch (this.getSpawnMode()) {
        case ALLSPAWNPOINTS:
          for (int i = 0; i < this.getSpawnPoints().size(); i++) {
            final int index = i;
            NullabilityUtil.castToNonnull(Game.loop(), "guaranteed to be non-null")
                .perform(
                    this.getSpawnDelay() + this.getSpawnDelay() * i,
                    () -> this.spawn(this.getSpawnPoints().get(index), this.getSpawnAmount()));
          }
          break;
        case ONERANDOMSPAWNPOINT:
          this.spawn(Game.random().choose(this.getSpawnPoints()), this.getSpawnAmount());
          break;
        case RANDOMSPAWNPOINTS:
          for (int i = 0; i < this.getSpawnAmount(); i++) {
            NullabilityUtil.castToNonnull(Game.loop(), "guaranteed to be non-null")
                .perform(
                    this.getSpawnDelay() + this.getSpawnDelay() * i,
                    () -> this.spawn(Game.random().choose(this.getSpawnPoints()), 1));
          }
          break;
        case CUSTOMSPAWNPOINTS:
          List<Spawnpoint> spawnPoints =
              this.customSpawnpoints != null
                  ? this.customSpawnpoints.apply(this)
                  : this.getCustomSpawnpoints();
  
          int index = 0;
          for (Spawnpoint spawn : spawnPoints) {
            NullabilityUtil.castToNonnull(Game.loop(), "guaranteed to be non-null")
                .perform(
                    this.getSpawnDelay() + this.getSpawnDelay() * index, () -> this.spawn(spawn, 1));
            index++;
          }
          break;
        default:
          break;
      }
  }
  ```
    ]]>
  </code>
</response>
---Response.<init>---
Response created:
protected void spawnNewEntities() {
      if (this.getSpawnMode() != SpawnMode.CUSTOMSPAWNPOINTS && this.getSpawnPoints().isEmpty()) {
        return;
      }
  
      switch (this.getSpawnMode()) {
        case ALLSPAWNPOINTS:
          for (int i = 0; i < this.getSpawnPoints().size(); i++) {
            final int index = i;
            NullabilityUtil.castToNonnull(Game.loop(), "guaranteed to be non-null")
                .perform(
                    this.getSpawnDelay() + this.getSpawnDelay() * i,
                    () -> this.spawn(this.getSpawnPoints().get(index), this.getSpawnAmount()));
          }
          break;
        case ONERANDOMSPAWNPOINT:
          this.spawn(Game.random().choose(this.getSpawnPoints()), this.getSpawnAmount());
          break;
        case RANDOMSPAWNPOINTS:
          for (int i = 0; i < this.getSpawnAmount(); i++) {
            NullabilityUtil.castToNonnull(Game.loop(), "guaranteed to be non-null")
                .perform(
                    this.getSpawnDelay() + this.getSpawnDelay() * i,
                    () -> this.spawn(Game.random().choose(this.getSpawnPoints()), 1));
          }
          break;
        case CUSTOMSPAWNPOINTS:
          List<Spawnpoint> spawnPoints =
              this.customSpawnpoints != null
                  ? this.customSpawnpoints.apply(this)
                  : this.getCustomSpawnpoints();
  
          int index = 0;
          for (Spawnpoint spawn : spawnPoints) {
            NullabilityUtil.castToNonnull(Game.loop(), "guaranteed to be non-null")
                .perform(
                    this.getSpawnDelay() + this.getSpawnDelay() * index, () -> this.spawn(spawn, 1));
            index++;
          }
          break;
        default:
          break;
      }
  }
---ChatGPT.fixDereferenceByAddingCastToNonnull---
Fixing the error by adding castToNonnull
---AdvancedNullAwayCodeFix.fixTriggeredErrorsForLocation---
Resolving unresolvable error for triggered error: Type='DEREFERENCE_NULLABLE', message='dereferenced expression Game.loop() is @Nullable'
/home/nima/Developer/nullness-benchmarks/litiengine/src/de/gurkenlabs/litiengine/tweening/TweenEngine.java:149
    Game.loop().detach(this);
---AdvancedNullAwayCodeFix.fix---
Fixing error: Type='DEREFERENCE_NULLABLE', message='dereferenced expression Game.loop() is @Nullable'
/home/nima/Developer/nullness-benchmarks/litiengine/src/de/gurkenlabs/litiengine/tweening/TweenEngine.java:149
    Game.loop().detach(this);
---AdvancedNullAwayCodeFix.resolveDereferenceError---
Resolving dereference error: Type='DEREFERENCE_NULLABLE', message='dereferenced expression Game.loop() is @Nullable'
/home/nima/Developer/nullness-benchmarks/litiengine/src/de/gurkenlabs/litiengine/tweening/TweenEngine.java:149
    Game.loop().detach(this);
---AdvancedNullAwayCodeFix.resolveDereferenceError---
Checking nullability possibility at error point
---ChatGPT.checkNullabilityPossibilityAtErrorPoint---
Asking if the expression can be null at error point point
---ChatGPT.ask---
Asking ChatGPT:
In the method below, is there a possibility that the expression "Game.loop()" at line "Game.loop().detach(this);" is null?
@Override
  public void terminate() {
    Game.loop().detach(this);
}
Give a single-word answer in XML format. If it is possible for the expression to be null, respond with:
```xml
<response>
    <reason><![CDATA[YOUR REASON]]></reason>
    <value>YES</value>
</response>
```
If it is not possible for the expression to be null, respond with:
```xml
<response>
    <reason><![CDATA[YOUR REASON]]></reason>
    <value>NO</value>
</response>
```
If you are unsure or need more information, respond with where you can ask for more details or what specific information you need.

If additional information is required, list each request inside a `<request>` tag. If no additional information is needed, omit the `<requests>` section.

Respond with:
```xml
<response>
    <reason><![CDATA[YOUR REASON]]></reason>
    <value>UNKNOWN</value>
    <!-- Include <requests> only if additional information is needed -->
    <requests>
        <request><![CDATA[YOUR REQUEST 1]]></request>
        <request><![CDATA[YOUR REQUEST 2]]></request>
    </requests>
</response>
```
---ChatGPT.sendRequestToOpenAI---
Sending request to OpenAI...
---ChatGPT.sendRequestToOpenAI---
Response received from OpenAI.
---Response.<init>---
Creating Response:
```xml
<response>
    <reason><![CDATA[Without the implementation details of Game.loop(), it's unclear whether it can return null.]]></reason>
    <value>UNKNOWN</value>
    <requests>
        <request><![CDATA[Provide implementation details of Game.loop().]]></request>
        <request><![CDATA[Provide information on how Game.loop() is supposed to be initialized or managed in the codebase.]]></request>
    </requests>
</response>
```
---Response.<init>---
Response created:
Unknown: Without the implementation details of Game.loop(), it's unclear whether it can return null.
---AdvancedNullAwayCodeFix.resolveMethodDereferenceError---
Resolving method dereference error.
---AdvancedNullAwayCodeFix.resolveMethodDereferenceError---
Method is in annotated package. Checking if the method is returning nullable.
---AdvancedNullAwayCodeFix.investigateMethodReturnNullability---
Checking if the method is returning nullable.
---ChatGPT.checkIfMethodIsReturningNullable---
Asking if the method is returning nullable: loop()
---ChatGPT.ask---
Asking ChatGPT:
In the method below, is there a possibility that the method returns null based only on its body? Consider the following points:

- The method may have multiple return paths; consider all return statements.
- If the method calls another method, do not assume its return value unless its full declaration is provided. Request its declaration if needed.
- The method may throw an exception instead of returning null. An exception path should not be considered a null return.
- Ensure you request the declarations of any methods whose return values directly or indirectly impact this method’s return value before making a conclusion.
- Carefully analyze all conditions and prior operations that may guarantee a non-null return value.

@Nullable public static IGameLoop loop() {
    return gameLoop;
}

Here are the method definitions in addition to the method inquired:

Depth: 0
```java
class de.gurkenlabs.litiengine.Game {
@Nullable public static IGameLoop loop() {
    return gameLoop;
}
}
```


Response Format:
Provide the answer in **XML format** as follows:

#### If the method **cannot** return `null`:
```xml
<response>
  <reason><![CDATA[EXPLAIN WHY THE METHOD CANNOT RETURN NULL]]></reason>
  <value>NO</value>
</response>
```

#### If the method can return null:
```xml
<response>
  <reason><![CDATA[EXPLAIN WHY THE METHOD CAN RETURN NULL]]></reason>
  <value>YES</value>
</response>
```

#### If you are unsure or need more information, respond with where you can ask for more details or what specific information you need.

#### If you are unsure or If there are any methods that directly or indirectly affect the return value and are not fully disclosed, request their declarations first, in the following format:
<response>
  <reason><![CDATA[YOUR REASON]]></reason>
  <value>UNKNOWN</value>
  <methods>
    <method>methodName</method>
  </methods>
</response>

If additional information is required other than method declaration, list each request inside a `<request>` tag. If no additional information is needed, omit the `<requests>` section.

Respond with:
```xml
<response>
    <reason><![CDATA[YOUR REASON]]></reason>
    <value>UNKNOWN</value>
    <!-- Include <requests> only if additional information is needed -->
    <requests>
        <request><![CDATA[YOUR REQUEST 1]]></request>
        <request><![CDATA[YOUR REQUEST 2]]></request>
    </requests>
</response>
```

Additional Notes:
Be precise in your reasoning.
If a method’s return value depends on another method not provided, request its declaration before making a conclusion.
If the method can return null in some cases but not others, explain under what conditions it can happen.

---ChatGPT.sendRequestToOpenAI---
Retrieving response from cache
---Response.<init>---
Creating Response:
```xml
<response>
  <reason><![CDATA[The method `loop` returns the variable `gameLoop`. Without the initialization or assignment details of `gameLoop`, it's unclear whether it can be null. The possibility of `gameLoop` being uninitialized or set to null elsewhere in the program means `loop` could potentially return null. Further information on `gameLoop` is required.]]></reason>
  <value>UNKNOWN</value>
  <requests>
    <request><![CDATA[Please provide the declaration and initialization of the variable `gameLoop` in the class `de.gurkenlabs.litiengine.Game`.]]></request>
  </requests>
</response>
```
---Response.<init>---
Response created:
Unknown: The method `loop` returns the variable `gameLoop`. Without the initialization or assignment details of `gameLoop`, it's unclear whether it can be null. The possibility of `gameLoop` being uninitialized or set to null elsewhere in the program means `loop` could potentially return null. Further information on `gameLoop` is required.
---AdvancedNullAwayCodeFix.investigateMethodReturnNullability---
Could not determine the nullability and model did not ask for any method.
---ChatGPT.checkIfMethodIsReturningNullableOnCallSite---
Asking if the method is returning nullable on the call site: Game.loop()
---ChatGPT.ask---
Asking ChatGPT:
In the method below, is there a possibility that the method returns null at the given call site?

```java
@Nullable public static IGameLoop loop() {
    return gameLoop;
}
```

## Guidelines:
- The method may have multiple return paths; consider all return statements.
- If the method calls another method, do not assume its return value unless its full declaration is provided. Request its declaration if needed.
- The method may throw an exception instead of returning null. An exception path should not be considered a null return.
- Ensure you request the declarations of any methods whose return values directly or indirectly impact this method’s return value before making a conclusion.
- If the method returns a value that is determined by a parameter, evaluate based on the actual argument at the given call site.
- Analyze based only on the specific invocation provided. Do not generalize to all possible inputs.- If the return value is guaranteed to be non-null at the call site, the answer should be a definitive NO.
- Do not generalize based on all possible inputs—your answer must be based only on the given invocation.
- Focus only on the given call site, not all possible invocations.

### call site:
Game.loop()

Here are the method definitions and the call chain for this method, showing the sequence of calls from the method to its callers at each depth level:

Depth: 0
```java
class de.gurkenlabs.litiengine.Game {
@Nullable public static IGameLoop loop() {
    return gameLoop;
}
}
```
Depth: 1
```java
class de.gurkenlabs.litiengine.environment.GameWorld {
public void loadEnvironment(@Nullable final Environment env) {
    Lock lock = Game.loop().getLock();
    lock.lock();
    try {
      unloadEnvironment();
      this.environment = env;
      if (env != null) {
        this.addEnvironment(env);

        if (env.getGravity() == 0 && this.gravity() != 0) {
          env.setGravity(this.gravity());
        }

        env.load();
        for (final EnvironmentLoadedListener listener : this.loadedListeners) {
          listener.loaded(env);
        }

        // call map specific listeners
        String mapName = getMapName(env);
        if (mapName != null && this.environmentLoadedListeners.containsKey(mapName)) {

          // for the default camera we center the camera on the environment
          if (this.camera().getClass().equals(Camera.class)) {
            camera().setFocus(env.getCenter());
          }

          for (EnvironmentLoadedListener listener : this.environmentLoadedListeners.get(mapName)) {
            listener.loaded(env);
          }
        }
      }
    } finally {
      lock.unlock();
    }
}public void setCamera(@Nullable final ICamera cam) {
    if (this.camera() != null) {
      Game.loop().detach(camera);
    }

    camera = cam;

    if (cam != null && !Game.isInNoGUIMode()) {
      Game.loop().attach(cam);
      cam.updateFocus();
    }
}
}
```
```java
class de.gurkenlabs.litiengine.entities.behavior.EntityNavigator {
public EntityNavigator(final IMobileEntity entity, final PathFinder pathFinder) {
    this.cancelNavigationConditions = new CopyOnWriteArrayList<>();
    this.listeners = new CopyOnWriteArrayList<>();
    this.entity = entity;
    this.pathFinder = pathFinder;
    this.setAcceptableError(DEFAULT_ACCEPTABLE_ERROR);
    Game.loop().attach(this);
}
}
```
```java
class de.gurkenlabs.litiengine.GameWindow {
private static void initializeWindowEventListeners(Window window) {

    window.addWindowStateListener(
        e -> {
          if (e.getNewState() == Frame.ICONIFIED) {
            Game.loop().setTickRate(ICONIFIED_MAX_FPS);
          } else {
            Game.loop().setTickRate(Game.config().client().getMaxFps());
          }
        });

    window.addWindowFocusListener(
        new WindowFocusListener() {
          @Override
          public void windowLostFocus(WindowEvent e) {
            if (Game.config().graphics().reduceFramesWhenNotFocused()) {
              Game.loop().setTickRate(NONE_FOCUS_MAX_FPS);
            }
          }

          @Override
          public void windowGainedFocus(WindowEvent e) {
            Game.loop().setTickRate(Game.config().client().getMaxFps());
          }
        });

    window.addWindowListener(
        new WindowAdapter() {
          @Override
          public void windowClosing(final WindowEvent event) {
            Game.exit();
          }
        });
}
}
```
```java
class de.gurkenlabs.litiengine.gui.screens.ScreenManager {
public void display(@Nullable final Screen screen) {
    if (Game.hasStarted() && Game.time().since(this.lastScreenChange) < this.getChangeCooldown()) {
      log.log(
          Level.INFO,
          "Skipping displaying of screen {0} because screen changing is currently on cooldown.",
          screen != null ? screen.getName() : "");
      return;
    }

    final Screen previous = this.current();
    if (previous != null) {
      previous.suspend();
    }

    if (screen != null && !this.screens.contains(screen)) {
      this.screens.add(screen);
    }

    this.currentScreen = screen;
    if (!Game.isInNoGUIMode() && this.current() != null) {
      this.current().prepare();
    }

    this.lastScreenChange = Game.loop().getTicks();

    final ScreenChangedEvent event = new ScreenChangedEvent(this.current(), previous);
    for (final ScreenChangedListener listener : this.screenChangedListeners) {
      listener.changed(event);
    }
}
}
```
```java
class de.gurkenlabs.litiengine.abilities.effects.Effect {
@Override
  public void update() {

    for (final Iterator<EffectApplication> iterator = this.getActiveAppliances().iterator();
        iterator.hasNext(); ) {
      final EffectApplication appliance = iterator.next();
      // if the effect duration is reached
      if (this.hasEnded(appliance)) {

        iterator.remove();
        this.cease(appliance);
      }
    }

    // 4. unregister if all appliances are finished
    if (this.getActiveAppliances().isEmpty()) {
      Game.loop().detach(this);
    }
}public void apply(final Shape impactArea) {
    final List<ICombatEntity> affected = this.lookForAffectedEntities(impactArea);
    for (final ICombatEntity affectedEntity : affected) {
      this.apply(affectedEntity);
    }

    this.appliances.add(new EffectApplication(affected, impactArea));

    // if it is the first appliance -> register for update
    if (this.appliances.size() == 1) {
      Game.loop().attach(this);
    }
}
}
```
```java
class de.gurkenlabs.litiengine.GameTime {
public long toTicks(final int milliseconds) {
    return this.toTicks(milliseconds, Game.loop().getTickRate());
}public long since(final long tick) {
    return toMilliseconds(Game.loop().getTicks() - tick);
}public long now() {
    return Game.loop().getTicks();
}public long sinceGameStart() {
    return this.toMilliseconds(Game.loop().getTicks());
}@Override
  public void loaded(Environment environment) {
    environmentLoaded = Game.loop().getTicks();
}public long toMilliseconds(final long ticks) {
    return this.toMilliseconds(ticks, Game.loop().getTickRate());
}
}
```
```java
class de.gurkenlabs.litiengine.GameMetrics {
@Override
  public void render(final Graphics2D g) {
    this.updateMetrics();

    if (!Game.config().client().showGameMetrics()) {
      return;
    }

    this.currentOffsetY = 0;

    g.setColor(this.renderColor);

    // render client metrics
    this.drawTitle(g, "[client]");
    this.drawMetric(g, "fps       : " + this.getFramesPerSecond());
    this.drawMetric(g, "max fps   : " + this.maxFramesPerSecond);
    this.drawMetric(g, "updatables: " + Game.loop().getUpdatableCount());

    // render jvm metrics if debug is enabled
    if (Game.config().debug().isDebugEnabled()) {
      this.drawTitle(g, "[jvm]");
      this.drawMetric(g, "java      : " + this.javaVersion);
      this.drawMetric(g, "memory    : " + String.format("%-5.5s", this.usedMemory) + " MB");
      this.drawMetric(g, "threads   : " + Thread.activeCount());
    }

    // render rendering metrics
    if (!this.renderMetrics.isEmpty()) {
      this.drawTitle(g, "[update]");

      for (RenderMetrics metric : this.renderMetrics) {
        this.drawMetric(g, metric.toString());
      }

      this.renderMetrics.clear();
    }
}
}
```
```java
class de.gurkenlabs.litiengine.graphics.emitters.Emitter {
public void deactivate() {
    if (!this.activated) {
      return;
    }

    this.activated = false;
    this.getParticles().clear();
    this.aliveTime = 0;
    this.activationTick = 0;
    this.lastSpawn = 0;
    Game.loop().detach(this);
}public void activate() {
    if (this.activated) {
      return;
    }

    this.activated = true;
    this.activationTick = Game.time().now();
    Game.loop().attach(this);
}@Override
  public void update() {
    if (this.isPaused()) {
      return;
    }

    // clear particles if the effect time to life is reached
    if (this.isFinished()) {
      for (EmitterFinishedListener listener : this.finishedListeners) {
        listener.finished(this);
      }

      this.delete();
      return;
    }

    final float updateRatio = (float) this.data().getUpdateRate() / Game.loop().getTickRate();
    for (final Particle p : this.getParticles().stream().collect(Collectors.toList())) {
      if (this.particleCanBeRemoved(p)) {
        // remove dead particles
        this.particles.remove(p);
        continue;
      }

      p.update(this.getOrigin(), updateRatio);
    }

    this.aliveTime = Game.time().since(this.activationTick);
    if ((this.data().getSpawnRate() == 0
        || Game.time().since(this.lastSpawn) >= this.data().getSpawnRate())) {
      this.lastSpawn = Game.time().now();
      this.spawnParticle();
    }
}
}
```
```java
class de.gurkenlabs.litiengine.entities.behavior.IBehaviorController {
public default void attach() {
    Game.loop().attach(this);
}public default void detach() {
    Game.loop().detach(this);
}
}
```
```java
class de.gurkenlabs.litiengine.abilities.AbilityExecution {
AbilityExecution(final Ability ability) {
    this.appliedEffects = new CopyOnWriteArrayList<>();
    this.ability = ability;
    this.executionTicks = Game.time().now();
    this.impactArea = ability.calculateImpactArea();
    this.castLocation = ability.getExecutor().getCenter();
    Game.loop().attach(this);
}@Override
  public void update() {
    // if there a no effects to apply -> unregister this instance and we're done
    if (this.getAbility().getEffects().isEmpty()
        || this.getAbility().getEffects().size() == this.getAppliedEffects().size()) {
      Game.loop().detach(this);
      return;
    }

    // handle all effects from the ability that were not applied yet
    for (final Effect effect : this.getAbility().getEffects()) {
      // if the ability was not executed yet or the delay of the effect is not
      // yet reached
      if (this.getAppliedEffects().contains(effect)
          || Game.time().since(this.getExecutionTicks()) < effect.getDelay()) {
        continue;
      }

      effect.apply(this.getExecutionImpactArea());
      this.getAppliedEffects().add(effect);
    }
}
}
```
```java
class de.gurkenlabs.litiengine.GameWindow$3 {
@Override
          public void windowGainedFocus(WindowEvent e) {
            Game.loop().setTickRate(Game.config().client().getMaxFps());
}@Override
          public void windowLostFocus(WindowEvent e) {
            if (Game.config().graphics().reduceFramesWhenNotFocused()) {
              Game.loop().setTickRate(NONE_FOCUS_MAX_FPS);
            }
}
}
```
```java
class de.gurkenlabs.litiengine.environment.EntitySpawner {
protected void spawnNewEntities() {
    if (this.getSpawnMode() != SpawnMode.CUSTOMSPAWNPOINTS && this.getSpawnPoints().isEmpty()) {
      return;
    }

    switch (this.getSpawnMode()) {
      case ALLSPAWNPOINTS:
        for (int i = 0; i < this.getSpawnPoints().size(); i++) {
          final int index = i;
          Game.loop()
              .perform(
                  this.getSpawnDelay() + this.getSpawnDelay() * i,
                  () -> this.spawn(this.getSpawnPoints().get(index), this.getSpawnAmount()));
        }
        break;
      case ONERANDOMSPAWNPOINT:
        this.spawn(Game.random().choose(this.getSpawnPoints()), this.getSpawnAmount());
        break;
      case RANDOMSPAWNPOINTS:
        for (int i = 0; i < this.getSpawnAmount(); i++) {
          Game.loop()
              .perform(
                  this.getSpawnDelay() + this.getSpawnDelay() * i,
                  () -> this.spawn(Game.random().choose(this.getSpawnPoints()), 1));
        }
        break;
      case CUSTOMSPAWNPOINTS:
        List<Spawnpoint> spawnPoints =
            this.customSpawnpoints != null
                ? this.customSpawnpoints.apply(this)
                : this.getCustomSpawnpoints();

        int index = 0;
        for (Spawnpoint spawn : spawnPoints) {
          Game.loop()
              .perform(
                  this.getSpawnDelay() + this.getSpawnDelay() * index, () -> this.spawn(spawn, 1));
          index++;
        }
        break;
      default:
        break;
    }
}
}
```
```java
class de.gurkenlabs.litiengine.tweening.TweenEngine {
@Override
  public void start() {
    Game.loop().attach(this);
}@Override
  public void terminate() {
    Game.loop().detach(this);
}
}
```
```java
class de.gurkenlabs.litiengine.gui.SpeechBubble {
public void hide() {
    Game.world().environment().removeRenderable(this);
    Game.loop().detach(this);
    if (activeSpeechBubbles.get(this.getEntity()) != null
        && activeSpeechBubbles.remove(this.getEntity()).equals(this)) {
      activeSpeechBubbles.remove(this.getEntity());
    }

    for (SpeechBubbleListener listener : this.listeners) {
      listener.hidden();
    }
}private SpeechBubble(
      final IEntity entity,
      final String text,
      @Nullable SpeechBubbleAppearance appearance,
      @Nullable Font font) {
    if (appearance == null) {
      this.appearance = DEFAULT_APPEARANCE;
    } else {
      this.appearance = appearance;
    }

    final SpeechBubble active = activeSpeechBubbles.get(entity);
    if (active != null) {
      active.hide();
    }
    this.setFont(font);

    this.textBoxWidth = (float) (entity.getWidth() * 4);
    this.entity = entity;

    this.currentText = text;
    this.currentTextDisplayTime = DISPLAYTIME_MIN + text.length() * DISPLAYTIME_PER_LETTER;

    this.lastTextDisplay = Game.time().now();
    this.createBubbleImage();
    entity.getEnvironment().add(this, RenderType.UI);
    Game.loop().attach(this);
    activeSpeechBubbles.put(entity, this);
}
}
```
```java
class de.gurkenlabs.litiengine.entities.Prop {
private void updateAnimationController() {
    IEntityAnimationController<?> controller = this.createAnimationController();
    this.getControllers().addController(controller);
    if (Game.world().environment() != null && Game.world().environment().isLoaded()) {
      Game.loop().attach(controller);
    }
}
}
```
```java
class de.gurkenlabs.litiengine.graphics.FreeFlightCamera {
public FreeFlightCamera(final Point2D focus) {
    this.setFocus(focus);
    this.velocity = DEFAULT_SCROLL_PIXELS_PER_SECOND;
    this.scrollPadding = DEFAULT_SCROLL_PADDING;
    this.setClampToMap(true);

    Game.loop().attach(this);
}private void handleFreeFlightCamera() {
    if (Game.world().environment() == null || Game.world().environment().getMap() == null) {
      return;
    }

    final Point2D mouseLocation = Input.mouse().getLocation();

    final double scrollSpeed =
        this.getVelocity()
            / (double) Game.loop().getTickRate()
            * Game.config().input().getMouseSensitivity();

    double x = this.getFocus().getX();
    double y = this.getFocus().getY();

    double deltaX = 0;
    if (mouseLocation.getX() < this.getScrollPadding()) {
      deltaX -= scrollSpeed;
    } else if (Game.window().getResolution().getWidth() - mouseLocation.getX()
        < this.getScrollPadding()) {
      deltaX += scrollSpeed;
    }

    double deltaY = 0;
    if (mouseLocation.getY() < this.getScrollPadding()) {
      deltaY -= scrollSpeed;
    } else if (Game.window().getResolution().getHeight() - mouseLocation.getY()
        < this.getScrollPadding()) {
      deltaY += scrollSpeed;
    }

    x += deltaX;
    y += deltaY;

    this.setFocus(new Point2D.Double(x, y));
}
}
```
```java
class de.gurkenlabs.litiengine.environment.Environment {
private static void dispose(final Collection<? extends IEntity> entities) {
    for (final IEntity entity : entities) {
      if (entity instanceof IUpdateable) {
        Game.loop().detach((IUpdateable) entity);
      }

      entity.detachControllers();
    }
}private static void loadUpdatableOrEmitterEntity(IEntity entity) {
    if (entity instanceof Emitter) {
      final Emitter emitter = (Emitter) entity;
      if (emitter.isActivateOnInit()) {
        emitter.activate();
      }
    } else if (entity instanceof IUpdateable) {
      Game.loop().attach((IUpdateable) entity);
    }
}private void unload(final IEntity entity) {
    // 1. remove from physics engine
    if (entity instanceof ICollisionEntity) {
      Game.physics().remove((ICollisionEntity) entity);
    }

    // 2. unregister from update
    if (entity instanceof IUpdateable) {
      Game.loop().detach((IUpdateable) entity);
    }

    if (entity instanceof IMobileEntity) {
      this.removeGravity((IMobileEntity) entity);
    }

    // 3. detach all controllers
    entity.detachControllers();

    if (entity instanceof Emitter) {
      Emitter em = (Emitter) entity;
      em.deactivate();
    }

    if (this.loaded && (entity instanceof LightSource || entity instanceof StaticShadow)) {
      this.updateLighting(entity);
    }

    entity.removed(this);
}
}
```
```java
class de.gurkenlabs.litiengine.graphics.animation.Animation {
@Override
  public void update() {
    // do nothing if the animation is not playing or the current keyframe is not finished
    if (!this.isPlaying()
        || Game.time().since(this.lastFrameUpdate) < this.getCurrentKeyFrame().getDuration()) {
      return;
    }

    // if we are not looping and the last keyframe is finished, we terminate the animation
    if (!this.isLooping() && this.isLastKeyFrame()) {
      this.terminate();
      return;
    }

    // make sure, we stay inside the keyframe list
    final int newFrameIndex =
        (this.getKeyframes().indexOf(this.currentFrame) + 1) % this.getKeyframes().size();
    final KeyFrame previousFrame = this.currentFrame;
    this.currentFrame = this.getKeyframes().get(newFrameIndex);

    for (KeyFrameListener listener : this.listeners) {
      listener.currentFrameChanged(previousFrame, this.currentFrame);
    }

    this.lastFrameUpdate = Game.loop().getTicks();
}public void restart() {
    this.currentFrame = this.firstFrame;
    this.lastFrameUpdate = Game.loop().getTicks();
}
}
```
```java
class de.gurkenlabs.litiengine.physics.MovementController {
@Override
  public void attach() {
    Game.loop().attach(this);
}private void handleForces() {
    // clean up forces
    this.activeForces.forEach(
        x -> {
          if (x.hasEnded()) {
            this.activeForces.remove(x);
          }
        });

    if (this.activeForces.isEmpty()) {
      return;
    }

    // disable turn-on-move for force handling
    boolean turn = this.getEntity().turnOnMove();
    this.getEntity().setTurnOnMove(false);
    try {
      double deltaX = 0;
      double deltaY = 0;
      for (final Force force : this.activeForces) {
        if (force.cancelOnReached() && force.hasReached(this.getEntity())) {
          force.end();
          continue;
        }

        final Point2D collisionBoxCenter = this.getEntity().getCollisionBoxCenter();
        final double angle =
            GeometricUtilities.calcRotationAngleInDegrees(collisionBoxCenter, force.getLocation());
        final double strength =
            Game.loop().getDeltaTime() * 0.001f * force.getStrength() * Game.loop().getTimeScale();
        deltaX += GeometricUtilities.getDeltaX(angle, strength);
        deltaY += GeometricUtilities.getDeltaY(angle, strength);
      }

      final Point2D target =
          new Point2D.Double(this.getEntity().getX() + deltaX, this.getEntity().getY() + deltaY);
      final boolean success = Game.physics().move(this.getEntity(), target);
      if (!success) {
        for (final Force force : this.activeForces) {
          if (force.cancelOnCollision()) {
            force.end();
          }
        }
      }
    } finally {
      this.getEntity().setTurnOnMove(turn);
    }
}@Override
  public void detach() {
    Game.loop().detach(this);
}public void handleMovement() {
    if (!this.isMovementAllowed()) {
      this.velocity = 0;
      return;
    }

    // max distance an entity can travel within one tick
    final double maxPixelsPerTick = this.getEntity().getTickVelocity();
    final double deltaTime = Game.loop().getDeltaTime() * Game.loop().getTimeScale();

    final double acceleration =
        this.getEntity().getAcceleration() == 0
            ? maxPixelsPerTick
            : deltaTime / this.getEntity().getAcceleration() * maxPixelsPerTick;
    final double deceleration =
        this.getEntity().getDeceleration() == 0
            ? this.getVelocity()
            : deltaTime / this.getEntity().getDeceleration() * maxPixelsPerTick;

    double dx = this.getDx();
    double dy = this.getDy();
    this.setDx(0);
    this.setDy(0);

    final double deltaVelocity =
        Math.min(Math.sqrt(Math.pow(dx, 2) + Math.pow(dy, 2)), acceleration);
    if (deltaVelocity != 0) {
      double newVelocity = this.getVelocity() + deltaVelocity;
      this.setVelocity(newVelocity);
    } else {
      final double newVelocity = Math.max(0, this.getVelocity() - deceleration);
      this.setVelocity(newVelocity);
      dx = GeometricUtilities.getDeltaX(this.moveAngle);
      dy = GeometricUtilities.getDeltaY(this.moveAngle);
    }

    if (this.getVelocity() == 0) {
      this.moveAngle = 0;
      return;
    }

    // actually move entity
    this.moveEntity(dx, dy);
}
}
```
```java
class de.gurkenlabs.litiengine.graphics.animation.AnimationController {
public void detach() {
    Game.loop().detach(this);
}public void attach() {
    Game.loop().attach(this);
}
}
```
```java
class de.gurkenlabs.litiengine.graphics.Camera {
@Override
  public void setZoom(final float targetZoom, final int delay) {
    if (delay == 0) {

      this.zoom = targetZoom;
      this.targetZoom = 0;
      this.zoomDelay = 0;
      this.zoomTick = 0;
      this.zoomStep = 0;

      final ZoomChangedEvent event = new ZoomChangedEvent(this, targetZoom);
      for (final ZoomChangedListener listener : this.zoomListeners) {
        listener.zoomChanged(event);
      }
    } else {
      this.zoomTick = Game.time().now();
      this.targetZoom = targetZoom;
      this.zoomDelay = delay;

      final double tickduration = 1000 / (double) Game.loop().getTickRate();
      final double tickAmount = delay / tickduration;
      final float totalDelta = this.targetZoom - this.zoom;
      this.zoomStep = tickAmount > 0 ? (float) (totalDelta / tickAmount) : totalDelta;
    }
}
}
```
```java
class de.gurkenlabs.litiengine.Game {
public static synchronized void init(String... args) {
    if (initialized) {
      log().log(Level.INFO, "The game has already been initialized.");
      return;
    }

    log.init();
    handleCommandLineArguments(args);

    config().load();
    Locale.setDefault(new Locale(config().client().getCountry(), config().client().getLanguage()));

    gameLoop = new GameLoop("Main Update Loop", config().client().getMaxFps());
    loop().attach(physics());
    loop().attach(world());

    // setup default exception handling for render and update loop
    setUncaughtExceptionHandler(
        new DefaultUncaughtExceptionHandler(config().client().exitOnError()));

    screenManager = new ScreenManager();
    gameWindow = new GameWindow();

    // initialize  the game window
    window().init();
    world.setCamera(new Camera());

    for (GameListener listener : gameListeners) {
      listener.initialized(args);
    }

    if (!isInNoGUIMode()) {
      window().getRenderComponent().onRendered(g -> metrics().render(g));

      graphics()
          .addEntityRenderedListener(
              e -> DebugRenderer.renderEntityDebugInfo(e.getGraphics(), e.getEntity()));

      window().getRenderComponent().onFpsChanged(fps -> metrics().setFramesPerSecond(fps));
      window()
          .setIcons(
              Arrays.asList(
                  Resources.images().get("liti-logo-x16.png"),
                  Resources.images().get("liti-logo-x20.png"),
                  Resources.images().get("liti-logo-x32.png"),
                  Resources.images().get("liti-logo-x48.png")));

      Input.keyboard()
          .onKeyTyped(
              KeyEvent.VK_PRINTSCREEN,
              key -> {
                // don't take a screenshot if a modifier is active
                if (key.getModifiers() != 0) {
                  return;
                }

                window().getRenderComponent().takeScreenshot();
              });
    }

    Runtime.getRuntime().addShutdownHook(new Thread(Game::terminate, "Shutdown"));

    initialized = true;
}
}
```
```java
class de.gurkenlabs.litiengine.entities.Creature {
protected void updateAnimationController() {
    IEntityAnimationController<?> controller = this.createAnimationController();
    this.getControllers().addController(controller);
    if (Game.world().environment() != null && Game.world().environment().isLoaded()) {
      Game.loop().attach(controller);
    }
}@Override
  public float getTickVelocity() {
    // pixels per ms multiplied by the passed ms
    // ensure that entities don't travel too far in case of lag
    return Math.min(Game.loop().getDeltaTime(), GameLoop.TICK_DELTATIME_LAG)
        * 0.001F
        * this.getVelocity().get()
        * Game.loop().getTimeScale();
}
}
```
Depth: 2
```java
class de.gurkenlabs.litiengine.environment.GameWorld {
public void clear() {
    this.unloadEnvironment();
    this.environments.clear();
    this.setCamera(null);
    Game.physics().clear();

    this.environmentListeners.clear();
    this.environmentLoadedListeners.clear();
    this.environmentUnloadedListeners.clear();

    this.listeners.clear();
    this.loadedListeners.clear();
    this.unloadedListeners.clear();
}@Nullable
  public Environment loadEnvironment(IMap map) {
    Environment env = this.getEnvironment(map);
    this.loadEnvironment(env);
    return env;
}@Nullable
  public Environment loadEnvironment(String mapName) {
    Environment env = this.getEnvironment(mapName);
    this.loadEnvironment(env);
    return env;
}
}
```
```java
class de.gurkenlabs.litiengine.GameWindow {
GameWindow() {
    this.hostControl = new JFrame();

    this.resolutionChangedListeners = new CopyOnWriteArrayList<>();

    this.renderCanvas = new RenderComponent(Game.config().graphics().getResolution());
    this.cursor = new MouseCursor();
    if (!Game.isInNoGUIMode()) {
      this.hostControl.setBackground(Color.BLACK);
      this.hostControl.add(this.renderCanvas);

      this.initializeEventListeners();

      this.hostControl.setTitle(Game.info().getTitle());
      this.hostControl.setDefaultCloseOperation(WindowConstants.DO_NOTHING_ON_CLOSE);
      initializeWindowEventListeners(this.hostControl);
    }
}
}
```
```java
class de.gurkenlabs.litiengine.GameTime {
public long sinceEnvironmentLoad() {
    return this.since(this.environmentLoaded);
}public long since(final long tick) {
    return toMilliseconds(Game.loop().getTicks() - tick);
}public long sinceGameStart() {
    return this.toMilliseconds(Game.loop().getTicks());
}
}
```
```java
class de.gurkenlabs.litiengine.abilities.effects.Effect {
protected void cease(final EffectApplication appliance) {
    // 1. cease the effect for all affected entities
    for (final ICombatEntity entity : appliance.getAffectedEntities()) {
      this.cease(entity);
    }

    // 2. apply follow up effects
    this.getFollowUpEffects().forEach(followUp -> followUp.apply(appliance.getImpactArea()));
}protected boolean hasEnded(final EffectApplication appliance) {
    final long effectDuration = Game.time().since(appliance.getAppliedTicks());
    return effectDuration > this.getDuration();
}
}
```
```java
class de.gurkenlabs.litiengine.abilities.effects.EffectApplication {
protected EffectApplication(final List<ICombatEntity> affectedEntities, final Shape impactArea) {
    this.applied = Game.time().now();
    this.affectedEntities = affectedEntities;
    this.impactArea = impactArea;
}
}
```
```java
class de.gurkenlabs.litiengine.entities.CombatEntity {
@Override
  public boolean wasHit(int timeSpan) {
    return Game.time().since(this.lastHit) < timeSpan;
}@Override
  public void hit(final int damage, @Nullable final Ability ability) {
    if (this.isDead()) {
      return;
    }

    if (!this.isIndestructible()) {
      this.getHitPoints().modifyBaseValue(new AttributeModifier<>(Modification.SUBTRACT, damage));
    }

    final EntityHitEvent event = new EntityHitEvent(this, ability, damage, this.isDead());

    for (final CombatEntityListener listener : this.listeners) {
      listener.hit(event);
    }

    for (final CombatEntityHitListener listener : this.hitListeners) {
      listener.hit(event);
    }

    if (this.isDead()) {
      this.fireDeathEvent();
      this.setCollision(false);
    }

    this.lastHit = Game.time().now();
}
}
```
```java
class de.gurkenlabs.litiengine.graphics.ImageEffect {
protected ImageEffect(final int ttl, final String name) {
    this.ttl = ttl;
    this.name = name;
    this.aliveTick = Game.time().now();
}@Override
  public long getAliveTime() {
    return Game.time().since(this.aliveTick);
}
}
```
```java
class de.gurkenlabs.litiengine.abilities.AbilityExecution {
AbilityExecution(final Ability ability) {
    this.appliedEffects = new CopyOnWriteArrayList<>();
    this.ability = ability;
    this.executionTicks = Game.time().now();
    this.impactArea = ability.calculateImpactArea();
    this.castLocation = ability.getExecutor().getCenter();
    Game.loop().attach(this);
}@Override
  public void update() {
    // if there a no effects to apply -> unregister this instance and we're done
    if (this.getAbility().getEffects().isEmpty()
        || this.getAbility().getEffects().size() == this.getAppliedEffects().size()) {
      Game.loop().detach(this);
      return;
    }

    // handle all effects from the ability that were not applied yet
    for (final Effect effect : this.getAbility().getEffects()) {
      // if the ability was not executed yet or the delay of the effect is not
      // yet reached
      if (this.getAppliedEffects().contains(effect)
          || Game.time().since(this.getExecutionTicks()) < effect.getDelay()) {
        continue;
      }

      effect.apply(this.getExecutionImpactArea());
      this.getAppliedEffects().add(effect);
    }
}
}
```
```java
class de.gurkenlabs.litiengine.tweening.TweenEngine {
@Override
  public void update() {
    for (final Tweenable target : this.getTweens().keySet()) {
      for (final Tween tween : this.getTweens().get(target).values()) {
        if (tween.hasStopped()) {
          continue;
        }
        final long elapsed = Game.time().since(tween.getStartTime());
        if (elapsed >= tween.getDuration()) {
          tween.stop();
          continue;
        }
        final float[] currentValues = new float[tween.getTargetValues().length];
        for (int i = 0; i < tween.getTargetValues().length; i++) {
          currentValues[i] =
              tween.getStartValues()[i]
                  + tween.getEquation().compute(elapsed / (float) tween.getDuration())
                      * (tween.getTargetValues()[i] - tween.getStartValues()[i]);
        }
        tween.getTarget().setTweenValues(tween.getType(), currentValues);
      }
    }
}
}
```
```java
class de.gurkenlabs.litiengine.gui.SpeechBubble {
public static SpeechBubble create(
      final IEntity entity, final String text, SpeechBubbleAppearance appearance, Font font) {
    return new SpeechBubble(entity, text, appearance, font);
}public static SpeechBubble create(final IEntity entity, final Font font, final String text) {
    SpeechBubbleAppearance app =
        new SpeechBubbleAppearance(
            DEFAULT_APPEARANCE.getForeColor(),
            DEFAULT_APPEARANCE.getBackgroundColor1(),
            DEFAULT_APPEARANCE.getBorderColor(),
            DEFAULT_APPEARANCE.getPadding());
    return new SpeechBubble(entity, text, app, font);
}public static SpeechBubble create(final IEntity entity, final String text) {
    return new SpeechBubble(entity, text, null, GuiProperties.getDefaultFont());
}@Override
  public void update() {
    if (this.currentText == null) {
      this.hide();
      return;
    }

    this.entityCenter = Game.world().camera().getViewportLocation(this.getEntity().getCenter());

    // old text was displayed long enough
    if (this.lastTextDisplay != 0
        && Game.time().since(this.lastTextDisplay) > this.currentTextDisplayTime) {
      this.currentText = null;
      this.lastTextDisplay = 0;
      return;
    }

    // display new text
    if (this.textIndex < this.currentText.length()
        && Game.time().since(this.lastCharPoll) > LETTER_WRITE_DELAY) {
      this.textIndex++;
      this.lastCharPoll = Game.time().now();
      if (this.typeSound != null) {
        Game.audio().playSound(this.typeSound, this.getEntity());
      }
    }

    // continue displaying currently displayed text
}private SpeechBubble(
      final IEntity entity,
      final String text,
      final Sound typeSound,
      SpeechBubbleAppearance appearance,
      Font font) {
    this(entity, text, appearance, font);
    this.typeSound = typeSound;
}private SpeechBubble(
      final IEntity entity,
      final String text,
      @Nullable SpeechBubbleAppearance appearance,
      @Nullable Font font) {
    if (appearance == null) {
      this.appearance = DEFAULT_APPEARANCE;
    } else {
      this.appearance = appearance;
    }

    final SpeechBubble active = activeSpeechBubbles.get(entity);
    if (active != null) {
      active.hide();
    }
    this.setFont(font);

    this.textBoxWidth = (float) (entity.getWidth() * 4);
    this.entity = entity;

    this.currentText = text;
    this.currentTextDisplayTime = DISPLAYTIME_MIN + text.length() * DISPLAYTIME_PER_LETTER;

    this.lastTextDisplay = Game.time().now();
    this.createBubbleImage();
    entity.getEnvironment().add(this, RenderType.UI);
    Game.loop().attach(this);
    activeSpeechBubbles.put(entity, this);
}
}
```
```java
class de.gurkenlabs.litiengine.gui.TextFieldComponent {
@Override
  public void render(final Graphics2D g) {
    super.render(g);
    g.setFont(this.getFont());
    final FontMetrics fm = g.getFontMetrics();

    if (this.isSelected() && Game.time().since(this.lastToggled) > this.flickerDelay) {
      this.cursorVisible = !this.cursorVisible;
      this.lastToggled = Game.time().now();
    }
    if (this.isSelected() && this.cursorVisible) {
      final Rectangle2D cursor =
          new Rectangle2D.Double(
              this.getX() + this.getTextX() + fm.stringWidth(this.getTextToRender(g)),
              this.getY() + this.getTextY(),
              this.getFont().getSize2D() * 3 / 5,
              this.getFont().getSize2D() * 1 / 5);
      g.setColor(this.getAppearance().getForeColor());
      g.fill(cursor);
    }
}
}
```
```java
class de.gurkenlabs.litiengine.entities.Prop {
public Prop(
      final Point2D location, @Nullable final String spritesheetName, final Material material) {
    super();
    this.rotation = Rotation.NONE;
    this.spritesheetName = spritesheetName;
    this.material = material;
    this.setLocation(location);
    this.updateAnimationController();
}public void setSpritesheetName(@Nullable final String spriteName) {
    this.spritesheetName = spriteName;
    this.updateAnimationController();
}
}
```
```java
class de.gurkenlabs.litiengine.tweening.Tween {
public Tween begin() {
    this.started = Game.time().now();
    this.stopped = false;
    return this;
}
}
```
```java
class de.gurkenlabs.litiengine.graphics.emitters.particles.Particle {
public void update(final Point2D emitterOrigin, final float updateRatio) {
    if (this.aliveTick == 0) {
      this.aliveTick = Game.time().now();
    }

    this.aliveTime = Game.time().since(this.aliveTick);
    if (this.timeToLiveReached()) {
      return;
    }

    if (this.colliding) {
      return;
    }

    if (this.getDeltaWidth() != 0) {
      this.width += this.getDeltaWidth() * updateRatio;
    }

    if (this.getDeltaHeight() != 0) {
      this.height += this.getDeltaHeight() * updateRatio;
    }

    if (this.getDeltaAngle() != 0) {
      this.angle += this.getDeltaAngle() * updateRatio;
    }

    // test for ray cast collision
    final float targetX = this.x + this.getVelocityX() * updateRatio;
    final float targetY = this.y + this.getVelocityY() * updateRatio;

    if (targetX == this.x && targetY == this.y) {
      return;
    }

    if (this.checkForCollision(emitterOrigin, targetX, targetY)) {
      return;
    }

    if (this.getVelocityX() != 0) {
      this.x = targetX;
    }

    if (this.getVelocityY() != 0) {
      this.y = targetY;
    }

    if (this.getAccelerationX() != 0) {
      this.velocityX += this.getAccelerationX() * updateRatio;
    }

    if (this.getAccelerationY() != 0) {
      this.velocityY += this.getAccelerationY() * updateRatio;
    }
}
}
```
```java
class de.gurkenlabs.litiengine.graphics.animation.Animation {
@Override
  public void start() {
    this.playing = true;
    if (this.getKeyframes().isEmpty()) {
      return;
    }

    this.restart();
}@Override
  public void update() {
    // do nothing if the animation is not playing or the current keyframe is not finished
    if (!this.isPlaying()
        || Game.time().since(this.lastFrameUpdate) < this.getCurrentKeyFrame().getDuration()) {
      return;
    }

    // if we are not looping and the last keyframe is finished, we terminate the animation
    if (!this.isLooping() && this.isLastKeyFrame()) {
      this.terminate();
      return;
    }

    // make sure, we stay inside the keyframe list
    final int newFrameIndex =
        (this.getKeyframes().indexOf(this.currentFrame) + 1) % this.getKeyframes().size();
    final KeyFrame previousFrame = this.currentFrame;
    this.currentFrame = this.getKeyframes().get(newFrameIndex);

    for (KeyFrameListener listener : this.listeners) {
      listener.currentFrameChanged(previousFrame, this.currentFrame);
    }

    this.lastFrameUpdate = Game.loop().getTicks();
}
}
```
```java
class de.gurkenlabs.litiengine.graphics.animation.AnimationController {
@Override
  public void update() {
    for (final Animation animation : this.getAll()) {
      animation.update();
    }

    if (this.getCurrent() != null && this.getCurrent().isPaused()) {
      return;
    }

    final boolean playbackFinished = this.getCurrent() != null && !this.getCurrent().isPlaying();
    if (playbackFinished) {
      for (final AnimationListener listener : this.listeners) {
        listener.finished(this.getCurrent());
      }
    }

    if (this.getCurrent() == null || playbackFinished) {
      if (this.getDefault() != null) {
        this.play(this.getDefault().getName());
      } else {
        this.currentAnimation = null;
      }
    }
}
}
```
```java
class de.gurkenlabs.litiengine.graphics.RenderComponent {
private void handleFade() {
    if (this.fadeOutStart != -1) {
      final long timePassed = Game.time().since(this.fadeOutStart);
      this.currentAlpha = MathUtilities.clamp(1 - timePassed / (float) this.fadeOutTime, 0, 1);
      if (this.currentAlpha == 0f) {
        this.fadeOutStart = -1;
        this.fadeOutTime = -1;
      }

      return;
    }

    if (this.fadeInStart != -1) {
      final long timePassed = Game.time().since(this.fadeInStart);
      this.currentAlpha = MathUtilities.clamp(timePassed / (float) this.fadeInTime, 0, 1);
      if (this.currentAlpha == 1f) {
        this.fadeInStart = -1;
        this.fadeInTime = -1;
        this.currentAlpha = Float.NaN;
      }
    }
}public void fadeOut(final int ms) {
    this.fadeInStart = -1;
    this.fadeInTime = -1;
    this.fadeOutStart = Game.time().now();
    this.fadeOutTime = ms;
}public void fadeIn(final int ms) {
    this.fadeOutStart = -1;
    this.fadeOutTime = -1;
    this.fadeInStart = Game.time().now();
    this.fadeInTime = ms;
}
}
```
```java
class de.gurkenlabs.litiengine.entities.Trigger {
private boolean activate(final IEntity activator, final int tar) {
    if (!this.isLoaded()
        || this.isOneTimeTrigger && this.isActivated
        || this.getActivationType() == TriggerActivation.COLLISION
            && activator != null
            && this.collisionActivated.contains(activator)) {
      return false;
    }

    if (this.getCooldown() > 0 && Game.time().since(this.lastActivation) < this.getCooldown()) {
      return false;
    }

    List<Integer> triggerTargets = this.getTargets(tar);

    final TriggerEvent te = new TriggerEvent(this, activator, triggerTargets);

    if (!this.checkActivationPredicates(te)) {
      return false;
    }

    this.isActivated = true;
    if (activator != null) {
      this.collisionActivated.add(activator);
    }

    // if we actually have a trigger target, we send the message to the target
    for (final int target : triggerTargets) {
      final IEntity entity = this.getEnvironment().get(target);
      if (entity == null) {
        log.log(
            Level.WARNING,
            "trigger [{0}] was activated, but the trigger target [{1}] could not be found on the environment",
            new Object[] {this, target});
        continue;
      }

      entity.sendMessage(this, this.message);
    }

    // also send the trigger event to all registered consumers
    for (final TriggerActivatedListener listener : this.activatedListeners) {
      listener.activated(te);
    }

    if (this.isOneTimeTrigger) {
      this.getEnvironment().remove(this);
    }

    this.lastActivation = Game.time().now();
    return true;
}
}
```
```java
class de.gurkenlabs.litiengine.graphics.Camera {
private boolean isShakeEffectActive() {
    return this.getShakeTick() != 0
        && Game.time().since(this.getShakeTick()) < this.getShakeDuration();
}@Override
  public void update() {
    if (Game.world().camera() != null && !Game.world().camera().equals(this)) {
      return;
    }

    if (this.targetZoom > 0) {
      if (Game.time().since(this.zoomTick) >= this.zoomDelay) {
        this.zoom = this.targetZoom;
        this.targetZoom = 0;
        this.zoomDelay = 0;
        this.zoomTick = 0;
        this.zoomStep = 0;
      } else {
        this.zoom += this.zoomStep;
      }

      final ZoomChangedEvent event = new ZoomChangedEvent(this, this.getZoom());
      for (final ZoomChangedListener listener : this.zoomListeners) {
        listener.zoomChanged(event);
      }
    }

    if (this.panTime > 0) {
      if (--this.panTime <= 0) {
        this.setFocus(this.targetFocus);
        this.targetFocus = null;
      } else {
        double diff = this.panTime / (this.panTime + 1.0);
        this.focus =
            new Point2D.Double(
                this.focus.getX() * diff + this.targetFocus.getX() * (1.0 - diff),
                this.focus.getY() * diff + this.targetFocus.getY() * (1.0 - diff));
      }
    }

    if (!this.isShakeEffectActive()) {
      this.shakeOffsetX = 0;
      this.shakeOffsetY = 0;
      return;
    }

    if (Game.time().since(this.lastShake) > this.shakeDelay) {
      this.shakeOffsetX = this.getShakeIntensity() * ThreadLocalRandom.current().nextGaussian();
      this.shakeOffsetY = this.getShakeIntensity() * ThreadLocalRandom.current().nextGaussian();
      this.lastShake = Game.time().now();
    }
}@Override
  public void setZoom(final float targetZoom, final int delay) {
    if (delay == 0) {

      this.zoom = targetZoom;
      this.targetZoom = 0;
      this.zoomDelay = 0;
      this.zoomTick = 0;
      this.zoomStep = 0;

      final ZoomChangedEvent event = new ZoomChangedEvent(this, targetZoom);
      for (final ZoomChangedListener listener : this.zoomListeners) {
        listener.zoomChanged(event);
      }
    } else {
      this.zoomTick = Game.time().now();
      this.targetZoom = targetZoom;
      this.zoomDelay = delay;

      final double tickduration = 1000 / (double) Game.loop().getTickRate();
      final double tickAmount = delay / tickduration;
      final float totalDelta = this.targetZoom - this.zoom;
      this.zoomStep = tickAmount > 0 ? (float) (totalDelta / tickAmount) : totalDelta;
    }
}@Override
  public void shake(final double intensity, final int delay, final int shakeDuration) {
    this.shakeTick = Game.time().now();
    this.shakeDelay = delay;
    this.shakeIntensity = intensity;
    this.shakeDuration = shakeDuration;
}
}
```
```java
class de.gurkenlabs.litiengine.entities.Creature {
public void setSpritesheetName(String spritesheetName) {
    if (this.spritesheetName != null && this.spritesheetName.equals(spritesheetName)) {
      return;
    }

    this.spritesheetName = spritesheetName;
    this.updateAnimationController();
}public boolean isIdle() {
    return Game.time().since(this.lastMoved) > IDLE_DELAY;
}@Override
  public void setLocation(final Point2D position) {
    if (this.isDead() || position == null) {
      return;
    }

    final Point2D oldLocation = this.getLocation();
    super.setLocation(position);

    if (Game.hasStarted() && this.isLoaded()) {
      this.lastMoved = Game.time().now();
      this.fireMovedEvent(
          new EntityMovedEvent(
              this, this.getX() - oldLocation.getX(), this.getY() - oldLocation.getY()));
    }
}
}
```
```java
class de.gurkenlabs.litiengine.gui.screens.ScreenManager {
public void display(final String screenName) {
    if (this.current() != null && this.current().getName().equalsIgnoreCase(screenName)) {
      log.log(
          Level.INFO,
          "Skipping displaying of screen {0} because it is already the current screen.",
          screenName);
      return;
    }

    if (this.screens.stream()
        .noneMatch(element -> element.getName().equalsIgnoreCase(screenName))) {
      log.log(
          Level.WARNING,
          "Could not display the screen {0} because there is no screen with the specified name.",
          screenName);
      return;
    }

    Screen screen = this.get(screenName);
    if (screen == null) {
      return;
    }

    this.display(screen);
}public void add(final Screen screen) {
    screen.setWidth(Game.window().getWidth());
    screen.setHeight(Game.window().getHeight());
    this.screens.add(screen);

    if (this.current() == null) {
      this.display(screen);
    }
}public void remove(Screen screen) {
    this.screens.remove(screen);
    if (this.current() == screen) {
      if (!this.screens.isEmpty()) {
        this.display(this.screens.get(0));
      } else {
        this.display((Screen) null);
      }
    }
}public void display(@Nullable final Screen screen) {
    if (Game.hasStarted() && Game.time().since(this.lastScreenChange) < this.getChangeCooldown()) {
      log.log(
          Level.INFO,
          "Skipping displaying of screen {0} because screen changing is currently on cooldown.",
          screen != null ? screen.getName() : "");
      return;
    }

    final Screen previous = this.current();
    if (previous != null) {
      previous.suspend();
    }

    if (screen != null && !this.screens.contains(screen)) {
      this.screens.add(screen);
    }

    this.currentScreen = screen;
    if (!Game.isInNoGUIMode() && this.current() != null) {
      this.current().prepare();
    }

    this.lastScreenChange = Game.loop().getTicks();

    final ScreenChangedEvent event = new ScreenChangedEvent(this.current(), previous);
    for (final ScreenChangedListener listener : this.screenChangedListeners) {
      listener.changed(event);
    }
}
}
```
```java
class de.gurkenlabs.litiengine.abilities.Ability {
public boolean isOnCooldown() {
    return (this.getCurrentExecution() != null
        && this.getCurrentExecution().getExecutionTicks() > 0
        && Game.time().since(this.getCurrentExecution().getExecutionTicks())
            < this.getAttributes().cooldown().get());
}public boolean isActive() {
    return this.getCurrentExecution() != null
        && Game.time().since(this.getCurrentExecution().getExecutionTicks())
            < this.getAttributes().duration().get();
}@Nullable
  public AbilityExecution cast() {
    if (!this.canCast()) {
      return null;
    }
    this.currentExecution = new AbilityExecution(this);

    for (final AbilityCastListener listener : this.abilityCastListeners) {
      listener.abilityCast(this.currentExecution);
    }

    return this.getCurrentExecution();
}public float getRemainingCooldownInSeconds() {
    if (this.getCurrentExecution() == null
        || this.getExecutor() == null
        || this.getExecutor().isDead()) {
      return 0;
    }

    // calculate cooldown in seconds
    return (float)
        (!this.canCast()
            ? (this.getAttributes().cooldown().get()
                    - Game.time().since(this.getCurrentExecution().getExecutionTicks()))
                * 0.001
            : 0);
}
}
```
```java
class de.gurkenlabs.litiengine.entities.EntityHitEvent {
EntityHitEvent(
      final ICombatEntity hitEntity,
      @Nullable final Ability ability,
      final int damage,
      final boolean kill) {
    super(hitEntity);
    this.executor = ability != null ? ability.getExecutor() : null;
    this.hitEntity = hitEntity;
    this.ability = ability;
    this.damage = damage;
    this.kill = kill;
    this.time = Game.time().now();
}
}
```
```java
class de.gurkenlabs.litiengine.graphics.emitters.Emitter {
public void delete() {
    this.deactivate();
    if (Game.world().environment() != null) {
      Game.world().environment().remove(this);
    }
}public void activate() {
    if (this.activated) {
      return;
    }

    this.activated = true;
    this.activationTick = Game.time().now();
    Game.loop().attach(this);
}@Override
  public void update() {
    if (this.isPaused()) {
      return;
    }

    // clear particles if the effect time to life is reached
    if (this.isFinished()) {
      for (EmitterFinishedListener listener : this.finishedListeners) {
        listener.finished(this);
      }

      this.delete();
      return;
    }

    final float updateRatio = (float) this.data().getUpdateRate() / Game.loop().getTickRate();
    for (final Particle p : this.getParticles().stream().collect(Collectors.toList())) {
      if (this.particleCanBeRemoved(p)) {
        // remove dead particles
        this.particles.remove(p);
        continue;
      }

      p.update(this.getOrigin(), updateRatio);
    }

    this.aliveTime = Game.time().since(this.activationTick);
    if ((this.data().getSpawnRate() == 0
        || Game.time().since(this.lastSpawn) >= this.data().getSpawnRate())) {
      this.lastSpawn = Game.time().now();
      this.spawnParticle();
    }
}
}
```
```java
class de.gurkenlabs.litiengine.GameLoop {
@Override
  public int perform(int delay, Runnable action) {
    final long d = Game.time().toTicks(delay);

    TimedAction a = new TimedAction(this.getTicks() + d, action);
    this.actions.add(a);

    return a.getId();
}
}
```
```java
class de.gurkenlabs.litiengine.environment.EntitySpawner {
protected boolean shouldSpawn() {
    return this.lastSpawnWave == 0
        || Game.time().since(this.lastSpawnWave) >= this.getSpawnInterval();
}@Override
  public void update() {
    if (!this.shouldSpawn()) {
      return;
    }

    this.spawnNewEntities();
    this.lastSpawnWave = Game.time().now();
}
}
```
```java
class de.gurkenlabs.litiengine.graphics.FreeFlightCamera {
@Override
  public void update() {
    this.handleFreeFlightCamera();
}public FreeFlightCamera(double x, double y) {
    this(new Point2D.Double(x, y));
}
}
```
```java
class de.gurkenlabs.litiengine.environment.Environment {
public void unload() {
    if (!this.loaded) {
      return;
    }

    // unregister all updatable entities from the current environment
    for (final IEntity entity : this.allEntities.values()) {
      this.unload(entity);
    }

    this.loaded = false;
    this.fireEvent(l -> l.unloaded(this));
}private static void loadUpdatableOrEmitterEntity(IEntity entity) {
    if (entity instanceof Emitter) {
      final Emitter emitter = (Emitter) entity;
      if (emitter.isActivateOnInit()) {
        emitter.activate();
      }
    } else if (entity instanceof IUpdateable) {
      Game.loop().attach((IUpdateable) entity);
    }
}public void clear() {
    Game.physics().clear();

    this.combatEntities.clear();
    this.mobileEntities.clear();
    this.gravityForces.clear();
    this.layerEntities.clear();
    this.entitiesByTag.clear();
    this.allEntities.clear();

    for (RenderType renderType : RenderType.values()) {
      this.miscEntities.get(renderType).clear();
      this.renderListeners.get(renderType).clear();
      this.renderables.get(renderType).clear();
    }

    dispose(this.allEntities.values());
    dispose(this.triggers);
    this.emitters.clear();
    this.colliders.clear();
    this.props.clear();
    this.creatures.clear();
    this.staticShadows.clear();
    this.combatEntities.clear();
    this.mobileEntities.clear();
    this.lightSources.clear();
    this.spawnPoints.clear();
    this.soundSources.clear();
    this.mapAreas.clear();
    this.triggers.clear();

    this.ambientLight = null;
    this.staticShadowLayer = null;

    for (Map<Integer, IEntity> type : this.miscEntities.values()) {
      type.clear();
    }

    this.initialized = false;

    this.fireEvent(l -> l.cleared(this));
}private void load(final IEntity entity) {
    // an entity can only exist on one environment at a time, so remove it from the current one
    if (entity.getEnvironment() != null) {
      entity.getEnvironment().remove(entity);
    }

    // 1. add to physics engine
    loadPhysicsEntity(entity);

    // 2. register for update or activate
    loadUpdatableOrEmitterEntity(entity);

    // 3. if a gravity is defined, add a gravity force to the entity
    if (entity instanceof IMobileEntity && this.getGravity() != 0) {
      this.addGravityForce((IMobileEntity) entity);
    }

    // 4. attach all controllers
    entity.attachControllers();

    if (this.loaded && (entity instanceof LightSource || entity instanceof StaticShadow)) {
      this.updateLighting(entity);
    }

    entity.loaded(this);
}private void unload(final IEntity entity) {
    // 1. remove from physics engine
    if (entity instanceof ICollisionEntity) {
      Game.physics().remove((ICollisionEntity) entity);
    }

    // 2. unregister from update
    if (entity instanceof IUpdateable) {
      Game.loop().detach((IUpdateable) entity);
    }

    if (entity instanceof IMobileEntity) {
      this.removeGravity((IMobileEntity) entity);
    }

    // 3. detach all controllers
    entity.detachControllers();

    if (entity instanceof Emitter) {
      Emitter em = (Emitter) entity;
      em.deactivate();
    }

    if (this.loaded && (entity instanceof LightSource || entity instanceof StaticShadow)) {
      this.updateLighting(entity);
    }

    entity.removed(this);
}public void remove(final IEntity entity) {
    if (entity == null) {
      return;
    }

    this.allEntities.remove(entity.getMapId());
    Iterator<List<IEntity>> iter = this.layerEntities.values().iterator();
    while (iter.hasNext()) {
      List<IEntity> layer = iter.next();
      if (layer.remove(entity) && layer.isEmpty()) {
        iter.remove();
      }
    }
    if (this.miscEntities.get(entity.getRenderType()) != null) {
      this.miscEntities.get(entity.getRenderType()).values().remove(entity);
    }

    for (String tag : entity.getTags()) {
      if (this.getEntitiesByTag().containsKey(tag)) {
        this.getEntitiesByTag().get(tag).remove(entity);

        if (this.getEntitiesByTag().get(tag).isEmpty()) {
          this.getEntitiesByTag().remove(tag);
        }
      }
    }

    if (entity instanceof Emitter) {
      Emitter emitter = (Emitter) entity;
      this.removeEmitter(emitter);
    }

    if (entity instanceof MapArea) {
      this.mapAreas.remove(entity);
    }

    if (entity instanceof Prop) {
      this.props.remove(entity);
    }

    if (entity instanceof Creature) {
      this.creatures.remove(entity);
    }

    if (entity instanceof CollisionBox) {
      this.colliders.remove(entity);
      this.staticShadows.removeIf(x -> x.getOrigin() != null && x.getOrigin().equals(entity));
    }

    if (entity instanceof LightSource) {
      this.lightSources.remove(entity);
      this.updateLighting(entity);
    }

    if (entity instanceof Trigger) {
      this.triggers.remove(entity);
    }

    if (entity instanceof Spawnpoint) {
      this.spawnPoints.remove(entity);
    }
    if (entity instanceof SoundSource) {
      this.soundSources.remove(entity);
    }

    if (entity instanceof StaticShadow) {
      this.staticShadows.remove(entity);
      this.updateLighting(entity);
    }

    if (entity instanceof IMobileEntity) {
      this.mobileEntities.values().remove(entity);
    }

    if (entity instanceof ICombatEntity) {
      this.combatEntities.values().remove(entity);
    }

    this.unload(entity);

    this.fireEntityEvent(l -> l.entityRemoved(entity));
}
}
```
```java
class de.gurkenlabs.litiengine.physics.MovementController {
@Override
  public void update() {
    this.handleForces();
    this.handleMovement();
}
}
```
```java
class de.gurkenlabs.litiengine.Game {
static synchronized void terminate() {
    if (!initialized) {
      return;
    }

    hasStarted = false;
    initialized = false;

    config().save();
    gameLoop.terminate();
    tweenEngine.terminate();
    soundEngine.terminate();

    world().clear();

    for (final GameListener listener : gameListeners) {
      try {
        listener.terminated();
      } catch (Exception e) {
        log().log(Level.WARNING, "game listener threw an exception during shutdown", e);
      }
    }

    gameLoop = null;
    screenManager = null;
    gameWindow = null;
}public static synchronized void start() {
    if (!initialized) {
      throw new IllegalStateException(
          "The game cannot be started without being first initialized. Call Game.init(...) before Game.start().");
    }

    gameLoop.start();
    tweenEngine.start();
    soundEngine.start();

    for (final GameListener listener : gameListeners) {
      listener.started();
    }

    hasStarted = true;
}public static synchronized void init(String... args) {
    if (initialized) {
      log().log(Level.INFO, "The game has already been initialized.");
      return;
    }

    log.init();
    handleCommandLineArguments(args);

    config().load();
    Locale.setDefault(new Locale(config().client().getCountry(), config().client().getLanguage()));

    gameLoop = new GameLoop("Main Update Loop", config().client().getMaxFps());
    loop().attach(physics());
    loop().attach(world());

    // setup default exception handling for render and update loop
    setUncaughtExceptionHandler(
        new DefaultUncaughtExceptionHandler(config().client().exitOnError()));

    screenManager = new ScreenManager();
    gameWindow = new GameWindow();

    // initialize  the game window
    window().init();
    world.setCamera(new Camera());

    for (GameListener listener : gameListeners) {
      listener.initialized(args);
    }

    if (!isInNoGUIMode()) {
      window().getRenderComponent().onRendered(g -> metrics().render(g));

      graphics()
          .addEntityRenderedListener(
              e -> DebugRenderer.renderEntityDebugInfo(e.getGraphics(), e.getEntity()));

      window().getRenderComponent().onFpsChanged(fps -> metrics().setFramesPerSecond(fps));
      window()
          .setIcons(
              Arrays.asList(
                  Resources.images().get("liti-logo-x16.png"),
                  Resources.images().get("liti-logo-x20.png"),
                  Resources.images().get("liti-logo-x32.png"),
                  Resources.images().get("liti-logo-x48.png")));

      Input.keyboard()
          .onKeyTyped(
              KeyEvent.VK_PRINTSCREEN,
              key -> {
                // don't take a screenshot if a modifier is active
                if (key.getModifiers() != 0) {
                  return;
                }

                window().getRenderComponent().takeScreenshot();
              });
    }

    Runtime.getRuntime().addShutdownHook(new Thread(Game::terminate, "Shutdown"));

    initialized = true;
}
}
```


Response Format:
Provide the answer in **XML format** as follows:

#### If the method **cannot** return `null` at the specific call site:
```xml
<response>
  <reason><![CDATA[EXPLAIN WHY THE INVOCATION Game.loop() RESULT CANNOT BE NULL.]]></reason>
  <value>NO</value>
</response>

#### If the method can return null at the specific call site:
<response>
  <reason><![CDATA[EXPLAIN WHY THE INVOCATION Game.loop() RESULT CAN BE NULL.]]></reason>
  <value>YES</value>
</response>

#### If you are unsure or If there are any methods that directly or indirectly affect the return value and are not fully disclosed, request their declarations first, in the following format:
<response>
  <reason><![CDATA[EXPLAIN WHY THIS METHOD DECLARATION IS NECESSARY AND WHY YOU CANNOT MAKE A CONFIDENT DECISION WITHOUT IT]]></reason>
  <success>false</success>
  <methods>
    <method>methodName</method>
  </methods>
</response>

Additional Notes:
Be precise in your reasoning.
If a method’s return value depends on another method not provided, request its declaration before making a conclusion.
If the method can return null in this case but not in others, explain why it happens specifically for this call.

---ChatGPT.sendRequestToOpenAI---
Retrieving response from cache
---Response.<init>---
Creating Response:
```xml
<response>
  <reason><![CDATA[The method `Game.loop()` returns the static field `gameLoop`, which is initialized in the `Game.init(String... args)` method. In this method, a new `GameLoop` object is instantiated and assigned to `gameLoop`. Since `init()` must be called before `start()`, which is implied by the requirement of initializing the game, the `gameLoop` is guaranteed to be non-null during the lifetime of the game execution where `Game.loop()` is called. The absence of any code that could set `gameLoop` to null after its initialization ensures that `Game.loop()` cannot return null.]]></reason>
  <value>NO</value>
</response>
```
---Response.<init>---
Response created:
Disagreement: The method `Game.loop()` returns the static field `gameLoop`, which is initialized in the `Game.init(String... args)` method. In this method, a new `GameLoop` object is instantiated and assigned to `gameLoop`. Since `init()` must be called before `start()`, which is implied by the requirement of initializing the game, the `gameLoop` is guaranteed to be non-null during the lifetime of the game execution where `Game.loop()` is called. The absence of any code that could set `gameLoop` to null after its initialization ensures that `Game.loop()` cannot return null.
---AdvancedNullAwayCodeFix.resolveMethodDereferenceError---
Method is not returning nullable on call site. Injecting suppression annotation.
---AdvancedNullAwayCodeFix.constructCastToNonnullChange---
Constructing cast to nonnull change for reason: The method `Game.loop()` returns the static field `gameLoop`, which is initialized in the `Game.init(String... args)` method. In this method, a new `GameLoop` object is instantiated and assigned to `gameLoop`. Since `init()` must be called before `start()`, which is implied by the requirement of initializing the game, the `gameLoop` is guaranteed to be non-null during the lifetime of the game execution where `Game.loop()` is called. The absence of any code that could set `gameLoop` to null after its initialization ensures that `Game.loop()` cannot return null.
---ChatGPT.ask---
Asking ChatGPT:
For the reason you mentioned earlier:

"The method `Game.loop()` returns the static field `gameLoop`, which is initialized in the `Game.init(String... args)` method. In this method, a new `GameLoop` object is instantiated and assigned to `gameLoop`. Since `init()` must be called before `start()`, which is implied by the requirement of initializing the game, the `gameLoop` is guaranteed to be non-null during the lifetime of the game execution where `Game.loop()` is called. The absence of any code that could set `gameLoop` to null after its initialization ensures that `Game.loop()` cannot return null."

in the method below, the expression Game.loop() is not nullable at the point it is used.

```java
@Override
  public void terminate() {
    Game.loop().detach(this);
}
```
Please Summarize the reason in max 5 words and rewrite the method so that at the line "    Game.loop().detach(this);", at the occurrence of: "Game.loop()" is replaced with `NullabilityUtil.castToNonnull(Game.loop(), summary of reason)`
Replace "REASON" with the exact reason summary I provide to you (maximum 5 words), not with a generic explanation like "checked to be nonnull".
see the example below, for expression `foo.getBar()`, to wrap it with `NullabilityUtil.castToNonnull(foo.getBar(), "reason")`.

```java
public t(){
    String l = foo.getBar();
}
```

will be:
```java
public t(){
    String l = NullabilityUtil.castToNonnull(foo.getBar(), "checked to be nonnull");
}
```

### Instructions:

Do not import any additional classes.

Do not add Java comments.

Only modify relevant lines as required.

Return only the modified method wrapped in the XML format shown below.

Place the Java code inside the <code> tag using a CDATA block with ```java formatting.

Just give me the fixed code snippet in XML format in <response> tag like the example below. I will apply the fix to my codebase. Do not import any additional libraries or classes or add java comments. If you can provide the fixed code snippet, please provide it in the following format and place the code snippet in the <code> tag within ```java block.
<response>
  <success>true</success>
  <code><![CDATA[
  ```java
  Your fixed code snippet here
  ```
    ]]>
  </code>
</response>

---ChatGPT.sendRequestToOpenAI---
Sending request to OpenAI...
---ChatGPT.sendRequestToOpenAI---
Response received from OpenAI.
---Response.<init>---
Creating Response:
<response>
  <success>true</success>
  <code><![CDATA[
  ```java
@Override
  public void terminate() {
    NullabilityUtil.castToNonnull(Game.loop(), "initialized before use").detach(this);
}
  ```
    ]]>
  </code>
</response>
---Response.<init>---
Response created:
@Override
  public void terminate() {
    NullabilityUtil.castToNonnull(Game.loop(), "initialized before use").detach(this);
}
---ChatGPT.fixDereferenceByAddingCastToNonnull---
Fixing the error by adding castToNonnull
---AdvancedNullAwayCodeFix.fixTriggeredErrorsForLocation---
Resolving unresolvable error for triggered error: Type='DEREFERENCE_NULLABLE', message='dereferenced expression Game.loop() is @Nullable'
/home/nima/Developer/nullness-benchmarks/litiengine/src/de/gurkenlabs/litiengine/physics/MovementController.java:36
    Game.loop().detach(this);
---AdvancedNullAwayCodeFix.fix---
Fixing error: Type='DEREFERENCE_NULLABLE', message='dereferenced expression Game.loop() is @Nullable'
/home/nima/Developer/nullness-benchmarks/litiengine/src/de/gurkenlabs/litiengine/physics/MovementController.java:36
    Game.loop().detach(this);
---AdvancedNullAwayCodeFix.resolveDereferenceError---
Resolving dereference error: Type='DEREFERENCE_NULLABLE', message='dereferenced expression Game.loop() is @Nullable'
/home/nima/Developer/nullness-benchmarks/litiengine/src/de/gurkenlabs/litiengine/physics/MovementController.java:36
    Game.loop().detach(this);
---AdvancedNullAwayCodeFix.resolveDereferenceError---
Checking nullability possibility at error point
---ChatGPT.checkNullabilityPossibilityAtErrorPoint---
Asking if the expression can be null at error point point
---ChatGPT.ask---
Asking ChatGPT:
In the method below, is there a possibility that the expression "Game.loop()" at line "Game.loop().detach(this);" is null?
@Override
  public void detach() {
    Game.loop().detach(this);
}
Give a single-word answer in XML format. If it is possible for the expression to be null, respond with:
```xml
<response>
    <reason><![CDATA[YOUR REASON]]></reason>
    <value>YES</value>
</response>
```
If it is not possible for the expression to be null, respond with:
```xml
<response>
    <reason><![CDATA[YOUR REASON]]></reason>
    <value>NO</value>
</response>
```
If you are unsure or need more information, respond with where you can ask for more details or what specific information you need.

If additional information is required, list each request inside a `<request>` tag. If no additional information is needed, omit the `<requests>` section.

Respond with:
```xml
<response>
    <reason><![CDATA[YOUR REASON]]></reason>
    <value>UNKNOWN</value>
    <!-- Include <requests> only if additional information is needed -->
    <requests>
        <request><![CDATA[YOUR REQUEST 1]]></request>
        <request><![CDATA[YOUR REQUEST 2]]></request>
    </requests>
</response>
```
---ChatGPT.sendRequestToOpenAI---
Sending request to OpenAI...
---ChatGPT.sendRequestToOpenAI---
Response received from OpenAI.
---Response.<init>---
Creating Response:
```xml
<response>
    <reason><![CDATA[Without knowing the implementation details of the Game.loop() method, it is unclear whether it can return null.]]></reason>
    <value>UNKNOWN</value>
    <requests>
        <request><![CDATA[Provide the implementation or contract of the Game.loop() method.]]></request>
    </requests>
</response>
```
---Response.<init>---
Response created:
Unknown: Without knowing the implementation details of the Game.loop() method, it is unclear whether it can return null.
---AdvancedNullAwayCodeFix.resolveMethodDereferenceError---
Resolving method dereference error.
---AdvancedNullAwayCodeFix.resolveMethodDereferenceError---
Method is in annotated package. Checking if the method is returning nullable.
---AdvancedNullAwayCodeFix.investigateMethodReturnNullability---
Checking if the method is returning nullable.
---ChatGPT.checkIfMethodIsReturningNullable---
Asking if the method is returning nullable: loop()
---ChatGPT.ask---
Asking ChatGPT:
In the method below, is there a possibility that the method returns null based only on its body? Consider the following points:

- The method may have multiple return paths; consider all return statements.
- If the method calls another method, do not assume its return value unless its full declaration is provided. Request its declaration if needed.
- The method may throw an exception instead of returning null. An exception path should not be considered a null return.
- Ensure you request the declarations of any methods whose return values directly or indirectly impact this method’s return value before making a conclusion.
- Carefully analyze all conditions and prior operations that may guarantee a non-null return value.

@Nullable public static IGameLoop loop() {
    return gameLoop;
}

Here are the method definitions in addition to the method inquired:

Depth: 0
```java
class de.gurkenlabs.litiengine.Game {
@Nullable public static IGameLoop loop() {
    return gameLoop;
}
}
```


Response Format:
Provide the answer in **XML format** as follows:

#### If the method **cannot** return `null`:
```xml
<response>
  <reason><![CDATA[EXPLAIN WHY THE METHOD CANNOT RETURN NULL]]></reason>
  <value>NO</value>
</response>
```

#### If the method can return null:
```xml
<response>
  <reason><![CDATA[EXPLAIN WHY THE METHOD CAN RETURN NULL]]></reason>
  <value>YES</value>
</response>
```

#### If you are unsure or need more information, respond with where you can ask for more details or what specific information you need.

#### If you are unsure or If there are any methods that directly or indirectly affect the return value and are not fully disclosed, request their declarations first, in the following format:
<response>
  <reason><![CDATA[YOUR REASON]]></reason>
  <value>UNKNOWN</value>
  <methods>
    <method>methodName</method>
  </methods>
</response>

If additional information is required other than method declaration, list each request inside a `<request>` tag. If no additional information is needed, omit the `<requests>` section.

Respond with:
```xml
<response>
    <reason><![CDATA[YOUR REASON]]></reason>
    <value>UNKNOWN</value>
    <!-- Include <requests> only if additional information is needed -->
    <requests>
        <request><![CDATA[YOUR REQUEST 1]]></request>
        <request><![CDATA[YOUR REQUEST 2]]></request>
    </requests>
</response>
```

Additional Notes:
Be precise in your reasoning.
If a method’s return value depends on another method not provided, request its declaration before making a conclusion.
If the method can return null in some cases but not others, explain under what conditions it can happen.

---ChatGPT.sendRequestToOpenAI---
Retrieving response from cache
---Response.<init>---
Creating Response:
```xml
<response>
  <reason><![CDATA[The method `loop` returns the variable `gameLoop`. Without the initialization or assignment details of `gameLoop`, it's unclear whether it can be null. The possibility of `gameLoop` being uninitialized or set to null elsewhere in the program means `loop` could potentially return null. Further information on `gameLoop` is required.]]></reason>
  <value>UNKNOWN</value>
  <requests>
    <request><![CDATA[Please provide the declaration and initialization of the variable `gameLoop` in the class `de.gurkenlabs.litiengine.Game`.]]></request>
  </requests>
</response>
```
---Response.<init>---
Response created:
Unknown: The method `loop` returns the variable `gameLoop`. Without the initialization or assignment details of `gameLoop`, it's unclear whether it can be null. The possibility of `gameLoop` being uninitialized or set to null elsewhere in the program means `loop` could potentially return null. Further information on `gameLoop` is required.
---AdvancedNullAwayCodeFix.investigateMethodReturnNullability---
Could not determine the nullability and model did not ask for any method.
---ChatGPT.checkIfMethodIsReturningNullableOnCallSite---
Asking if the method is returning nullable on the call site: Game.loop()
---ChatGPT.ask---
Asking ChatGPT:
In the method below, is there a possibility that the method returns null at the given call site?

```java
@Nullable public static IGameLoop loop() {
    return gameLoop;
}
```

## Guidelines:
- The method may have multiple return paths; consider all return statements.
- If the method calls another method, do not assume its return value unless its full declaration is provided. Request its declaration if needed.
- The method may throw an exception instead of returning null. An exception path should not be considered a null return.
- Ensure you request the declarations of any methods whose return values directly or indirectly impact this method’s return value before making a conclusion.
- If the method returns a value that is determined by a parameter, evaluate based on the actual argument at the given call site.
- Analyze based only on the specific invocation provided. Do not generalize to all possible inputs.- If the return value is guaranteed to be non-null at the call site, the answer should be a definitive NO.
- Do not generalize based on all possible inputs—your answer must be based only on the given invocation.
- Focus only on the given call site, not all possible invocations.

### call site:
Game.loop()

Here are the method definitions and the call chain for this method, showing the sequence of calls from the method to its callers at each depth level:

Depth: 0
```java
class de.gurkenlabs.litiengine.Game {
@Nullable public static IGameLoop loop() {
    return gameLoop;
}
}
```
Depth: 1
```java
class de.gurkenlabs.litiengine.environment.GameWorld {
public void loadEnvironment(@Nullable final Environment env) {
    Lock lock = Game.loop().getLock();
    lock.lock();
    try {
      unloadEnvironment();
      this.environment = env;
      if (env != null) {
        this.addEnvironment(env);

        if (env.getGravity() == 0 && this.gravity() != 0) {
          env.setGravity(this.gravity());
        }

        env.load();
        for (final EnvironmentLoadedListener listener : this.loadedListeners) {
          listener.loaded(env);
        }

        // call map specific listeners
        String mapName = getMapName(env);
        if (mapName != null && this.environmentLoadedListeners.containsKey(mapName)) {

          // for the default camera we center the camera on the environment
          if (this.camera().getClass().equals(Camera.class)) {
            camera().setFocus(env.getCenter());
          }

          for (EnvironmentLoadedListener listener : this.environmentLoadedListeners.get(mapName)) {
            listener.loaded(env);
          }
        }
      }
    } finally {
      lock.unlock();
    }
}public void setCamera(@Nullable final ICamera cam) {
    if (this.camera() != null) {
      Game.loop().detach(camera);
    }

    camera = cam;

    if (cam != null && !Game.isInNoGUIMode()) {
      Game.loop().attach(cam);
      cam.updateFocus();
    }
}
}
```
```java
class de.gurkenlabs.litiengine.entities.behavior.EntityNavigator {
public EntityNavigator(final IMobileEntity entity, final PathFinder pathFinder) {
    this.cancelNavigationConditions = new CopyOnWriteArrayList<>();
    this.listeners = new CopyOnWriteArrayList<>();
    this.entity = entity;
    this.pathFinder = pathFinder;
    this.setAcceptableError(DEFAULT_ACCEPTABLE_ERROR);
    Game.loop().attach(this);
}
}
```
```java
class de.gurkenlabs.litiengine.GameWindow {
private static void initializeWindowEventListeners(Window window) {

    window.addWindowStateListener(
        e -> {
          if (e.getNewState() == Frame.ICONIFIED) {
            Game.loop().setTickRate(ICONIFIED_MAX_FPS);
          } else {
            Game.loop().setTickRate(Game.config().client().getMaxFps());
          }
        });

    window.addWindowFocusListener(
        new WindowFocusListener() {
          @Override
          public void windowLostFocus(WindowEvent e) {
            if (Game.config().graphics().reduceFramesWhenNotFocused()) {
              Game.loop().setTickRate(NONE_FOCUS_MAX_FPS);
            }
          }

          @Override
          public void windowGainedFocus(WindowEvent e) {
            Game.loop().setTickRate(Game.config().client().getMaxFps());
          }
        });

    window.addWindowListener(
        new WindowAdapter() {
          @Override
          public void windowClosing(final WindowEvent event) {
            Game.exit();
          }
        });
}
}
```
```java
class de.gurkenlabs.litiengine.gui.screens.ScreenManager {
public void display(@Nullable final Screen screen) {
    if (Game.hasStarted() && Game.time().since(this.lastScreenChange) < this.getChangeCooldown()) {
      log.log(
          Level.INFO,
          "Skipping displaying of screen {0} because screen changing is currently on cooldown.",
          screen != null ? screen.getName() : "");
      return;
    }

    final Screen previous = this.current();
    if (previous != null) {
      previous.suspend();
    }

    if (screen != null && !this.screens.contains(screen)) {
      this.screens.add(screen);
    }

    this.currentScreen = screen;
    if (!Game.isInNoGUIMode() && this.current() != null) {
      this.current().prepare();
    }

    this.lastScreenChange = Game.loop().getTicks();

    final ScreenChangedEvent event = new ScreenChangedEvent(this.current(), previous);
    for (final ScreenChangedListener listener : this.screenChangedListeners) {
      listener.changed(event);
    }
}
}
```
```java
class de.gurkenlabs.litiengine.abilities.effects.Effect {
@Override
  public void update() {

    for (final Iterator<EffectApplication> iterator = this.getActiveAppliances().iterator();
        iterator.hasNext(); ) {
      final EffectApplication appliance = iterator.next();
      // if the effect duration is reached
      if (this.hasEnded(appliance)) {

        iterator.remove();
        this.cease(appliance);
      }
    }

    // 4. unregister if all appliances are finished
    if (this.getActiveAppliances().isEmpty()) {
      Game.loop().detach(this);
    }
}public void apply(final Shape impactArea) {
    final List<ICombatEntity> affected = this.lookForAffectedEntities(impactArea);
    for (final ICombatEntity affectedEntity : affected) {
      this.apply(affectedEntity);
    }

    this.appliances.add(new EffectApplication(affected, impactArea));

    // if it is the first appliance -> register for update
    if (this.appliances.size() == 1) {
      Game.loop().attach(this);
    }
}
}
```
```java
class de.gurkenlabs.litiengine.GameTime {
public long toTicks(final int milliseconds) {
    return this.toTicks(milliseconds, Game.loop().getTickRate());
}public long since(final long tick) {
    return toMilliseconds(Game.loop().getTicks() - tick);
}public long now() {
    return Game.loop().getTicks();
}public long sinceGameStart() {
    return this.toMilliseconds(Game.loop().getTicks());
}@Override
  public void loaded(Environment environment) {
    environmentLoaded = Game.loop().getTicks();
}public long toMilliseconds(final long ticks) {
    return this.toMilliseconds(ticks, Game.loop().getTickRate());
}
}
```
```java
class de.gurkenlabs.litiengine.GameMetrics {
@Override
  public void render(final Graphics2D g) {
    this.updateMetrics();

    if (!Game.config().client().showGameMetrics()) {
      return;
    }

    this.currentOffsetY = 0;

    g.setColor(this.renderColor);

    // render client metrics
    this.drawTitle(g, "[client]");
    this.drawMetric(g, "fps       : " + this.getFramesPerSecond());
    this.drawMetric(g, "max fps   : " + this.maxFramesPerSecond);
    this.drawMetric(g, "updatables: " + Game.loop().getUpdatableCount());

    // render jvm metrics if debug is enabled
    if (Game.config().debug().isDebugEnabled()) {
      this.drawTitle(g, "[jvm]");
      this.drawMetric(g, "java      : " + this.javaVersion);
      this.drawMetric(g, "memory    : " + String.format("%-5.5s", this.usedMemory) + " MB");
      this.drawMetric(g, "threads   : " + Thread.activeCount());
    }

    // render rendering metrics
    if (!this.renderMetrics.isEmpty()) {
      this.drawTitle(g, "[update]");

      for (RenderMetrics metric : this.renderMetrics) {
        this.drawMetric(g, metric.toString());
      }

      this.renderMetrics.clear();
    }
}
}
```
```java
class de.gurkenlabs.litiengine.graphics.emitters.Emitter {
public void deactivate() {
    if (!this.activated) {
      return;
    }

    this.activated = false;
    this.getParticles().clear();
    this.aliveTime = 0;
    this.activationTick = 0;
    this.lastSpawn = 0;
    Game.loop().detach(this);
}public void activate() {
    if (this.activated) {
      return;
    }

    this.activated = true;
    this.activationTick = Game.time().now();
    Game.loop().attach(this);
}@Override
  public void update() {
    if (this.isPaused()) {
      return;
    }

    // clear particles if the effect time to life is reached
    if (this.isFinished()) {
      for (EmitterFinishedListener listener : this.finishedListeners) {
        listener.finished(this);
      }

      this.delete();
      return;
    }

    final float updateRatio = (float) this.data().getUpdateRate() / Game.loop().getTickRate();
    for (final Particle p : this.getParticles().stream().collect(Collectors.toList())) {
      if (this.particleCanBeRemoved(p)) {
        // remove dead particles
        this.particles.remove(p);
        continue;
      }

      p.update(this.getOrigin(), updateRatio);
    }

    this.aliveTime = Game.time().since(this.activationTick);
    if ((this.data().getSpawnRate() == 0
        || Game.time().since(this.lastSpawn) >= this.data().getSpawnRate())) {
      this.lastSpawn = Game.time().now();
      this.spawnParticle();
    }
}
}
```
```java
class de.gurkenlabs.litiengine.entities.behavior.IBehaviorController {
public default void attach() {
    Game.loop().attach(this);
}public default void detach() {
    Game.loop().detach(this);
}
}
```
```java
class de.gurkenlabs.litiengine.abilities.AbilityExecution {
AbilityExecution(final Ability ability) {
    this.appliedEffects = new CopyOnWriteArrayList<>();
    this.ability = ability;
    this.executionTicks = Game.time().now();
    this.impactArea = ability.calculateImpactArea();
    this.castLocation = ability.getExecutor().getCenter();
    Game.loop().attach(this);
}@Override
  public void update() {
    // if there a no effects to apply -> unregister this instance and we're done
    if (this.getAbility().getEffects().isEmpty()
        || this.getAbility().getEffects().size() == this.getAppliedEffects().size()) {
      Game.loop().detach(this);
      return;
    }

    // handle all effects from the ability that were not applied yet
    for (final Effect effect : this.getAbility().getEffects()) {
      // if the ability was not executed yet or the delay of the effect is not
      // yet reached
      if (this.getAppliedEffects().contains(effect)
          || Game.time().since(this.getExecutionTicks()) < effect.getDelay()) {
        continue;
      }

      effect.apply(this.getExecutionImpactArea());
      this.getAppliedEffects().add(effect);
    }
}
}
```
```java
class de.gurkenlabs.litiengine.GameWindow$3 {
@Override
          public void windowGainedFocus(WindowEvent e) {
            Game.loop().setTickRate(Game.config().client().getMaxFps());
}@Override
          public void windowLostFocus(WindowEvent e) {
            if (Game.config().graphics().reduceFramesWhenNotFocused()) {
              Game.loop().setTickRate(NONE_FOCUS_MAX_FPS);
            }
}
}
```
```java
class de.gurkenlabs.litiengine.environment.EntitySpawner {
protected void spawnNewEntities() {
    if (this.getSpawnMode() != SpawnMode.CUSTOMSPAWNPOINTS && this.getSpawnPoints().isEmpty()) {
      return;
    }

    switch (this.getSpawnMode()) {
      case ALLSPAWNPOINTS:
        for (int i = 0; i < this.getSpawnPoints().size(); i++) {
          final int index = i;
          Game.loop()
              .perform(
                  this.getSpawnDelay() + this.getSpawnDelay() * i,
                  () -> this.spawn(this.getSpawnPoints().get(index), this.getSpawnAmount()));
        }
        break;
      case ONERANDOMSPAWNPOINT:
        this.spawn(Game.random().choose(this.getSpawnPoints()), this.getSpawnAmount());
        break;
      case RANDOMSPAWNPOINTS:
        for (int i = 0; i < this.getSpawnAmount(); i++) {
          Game.loop()
              .perform(
                  this.getSpawnDelay() + this.getSpawnDelay() * i,
                  () -> this.spawn(Game.random().choose(this.getSpawnPoints()), 1));
        }
        break;
      case CUSTOMSPAWNPOINTS:
        List<Spawnpoint> spawnPoints =
            this.customSpawnpoints != null
                ? this.customSpawnpoints.apply(this)
                : this.getCustomSpawnpoints();

        int index = 0;
        for (Spawnpoint spawn : spawnPoints) {
          Game.loop()
              .perform(
                  this.getSpawnDelay() + this.getSpawnDelay() * index, () -> this.spawn(spawn, 1));
          index++;
        }
        break;
      default:
        break;
    }
}
}
```
```java
class de.gurkenlabs.litiengine.tweening.TweenEngine {
@Override
  public void start() {
    Game.loop().attach(this);
}@Override
  public void terminate() {
    Game.loop().detach(this);
}
}
```
```java
class de.gurkenlabs.litiengine.gui.SpeechBubble {
public void hide() {
    Game.world().environment().removeRenderable(this);
    Game.loop().detach(this);
    if (activeSpeechBubbles.get(this.getEntity()) != null
        && activeSpeechBubbles.remove(this.getEntity()).equals(this)) {
      activeSpeechBubbles.remove(this.getEntity());
    }

    for (SpeechBubbleListener listener : this.listeners) {
      listener.hidden();
    }
}private SpeechBubble(
      final IEntity entity,
      final String text,
      @Nullable SpeechBubbleAppearance appearance,
      @Nullable Font font) {
    if (appearance == null) {
      this.appearance = DEFAULT_APPEARANCE;
    } else {
      this.appearance = appearance;
    }

    final SpeechBubble active = activeSpeechBubbles.get(entity);
    if (active != null) {
      active.hide();
    }
    this.setFont(font);

    this.textBoxWidth = (float) (entity.getWidth() * 4);
    this.entity = entity;

    this.currentText = text;
    this.currentTextDisplayTime = DISPLAYTIME_MIN + text.length() * DISPLAYTIME_PER_LETTER;

    this.lastTextDisplay = Game.time().now();
    this.createBubbleImage();
    entity.getEnvironment().add(this, RenderType.UI);
    Game.loop().attach(this);
    activeSpeechBubbles.put(entity, this);
}
}
```
```java
class de.gurkenlabs.litiengine.entities.Prop {
private void updateAnimationController() {
    IEntityAnimationController<?> controller = this.createAnimationController();
    this.getControllers().addController(controller);
    if (Game.world().environment() != null && Game.world().environment().isLoaded()) {
      Game.loop().attach(controller);
    }
}
}
```
```java
class de.gurkenlabs.litiengine.graphics.FreeFlightCamera {
public FreeFlightCamera(final Point2D focus) {
    this.setFocus(focus);
    this.velocity = DEFAULT_SCROLL_PIXELS_PER_SECOND;
    this.scrollPadding = DEFAULT_SCROLL_PADDING;
    this.setClampToMap(true);

    Game.loop().attach(this);
}private void handleFreeFlightCamera() {
    if (Game.world().environment() == null || Game.world().environment().getMap() == null) {
      return;
    }

    final Point2D mouseLocation = Input.mouse().getLocation();

    final double scrollSpeed =
        this.getVelocity()
            / (double) Game.loop().getTickRate()
            * Game.config().input().getMouseSensitivity();

    double x = this.getFocus().getX();
    double y = this.getFocus().getY();

    double deltaX = 0;
    if (mouseLocation.getX() < this.getScrollPadding()) {
      deltaX -= scrollSpeed;
    } else if (Game.window().getResolution().getWidth() - mouseLocation.getX()
        < this.getScrollPadding()) {
      deltaX += scrollSpeed;
    }

    double deltaY = 0;
    if (mouseLocation.getY() < this.getScrollPadding()) {
      deltaY -= scrollSpeed;
    } else if (Game.window().getResolution().getHeight() - mouseLocation.getY()
        < this.getScrollPadding()) {
      deltaY += scrollSpeed;
    }

    x += deltaX;
    y += deltaY;

    this.setFocus(new Point2D.Double(x, y));
}
}
```
```java
class de.gurkenlabs.litiengine.environment.Environment {
private static void dispose(final Collection<? extends IEntity> entities) {
    for (final IEntity entity : entities) {
      if (entity instanceof IUpdateable) {
        Game.loop().detach((IUpdateable) entity);
      }

      entity.detachControllers();
    }
}private static void loadUpdatableOrEmitterEntity(IEntity entity) {
    if (entity instanceof Emitter) {
      final Emitter emitter = (Emitter) entity;
      if (emitter.isActivateOnInit()) {
        emitter.activate();
      }
    } else if (entity instanceof IUpdateable) {
      Game.loop().attach((IUpdateable) entity);
    }
}private void unload(final IEntity entity) {
    // 1. remove from physics engine
    if (entity instanceof ICollisionEntity) {
      Game.physics().remove((ICollisionEntity) entity);
    }

    // 2. unregister from update
    if (entity instanceof IUpdateable) {
      Game.loop().detach((IUpdateable) entity);
    }

    if (entity instanceof IMobileEntity) {
      this.removeGravity((IMobileEntity) entity);
    }

    // 3. detach all controllers
    entity.detachControllers();

    if (entity instanceof Emitter) {
      Emitter em = (Emitter) entity;
      em.deactivate();
    }

    if (this.loaded && (entity instanceof LightSource || entity instanceof StaticShadow)) {
      this.updateLighting(entity);
    }

    entity.removed(this);
}
}
```
```java
class de.gurkenlabs.litiengine.graphics.animation.Animation {
@Override
  public void update() {
    // do nothing if the animation is not playing or the current keyframe is not finished
    if (!this.isPlaying()
        || Game.time().since(this.lastFrameUpdate) < this.getCurrentKeyFrame().getDuration()) {
      return;
    }

    // if we are not looping and the last keyframe is finished, we terminate the animation
    if (!this.isLooping() && this.isLastKeyFrame()) {
      this.terminate();
      return;
    }

    // make sure, we stay inside the keyframe list
    final int newFrameIndex =
        (this.getKeyframes().indexOf(this.currentFrame) + 1) % this.getKeyframes().size();
    final KeyFrame previousFrame = this.currentFrame;
    this.currentFrame = this.getKeyframes().get(newFrameIndex);

    for (KeyFrameListener listener : this.listeners) {
      listener.currentFrameChanged(previousFrame, this.currentFrame);
    }

    this.lastFrameUpdate = Game.loop().getTicks();
}public void restart() {
    this.currentFrame = this.firstFrame;
    this.lastFrameUpdate = Game.loop().getTicks();
}
}
```
```java
class de.gurkenlabs.litiengine.physics.MovementController {
@Override
  public void attach() {
    Game.loop().attach(this);
}private void handleForces() {
    // clean up forces
    this.activeForces.forEach(
        x -> {
          if (x.hasEnded()) {
            this.activeForces.remove(x);
          }
        });

    if (this.activeForces.isEmpty()) {
      return;
    }

    // disable turn-on-move for force handling
    boolean turn = this.getEntity().turnOnMove();
    this.getEntity().setTurnOnMove(false);
    try {
      double deltaX = 0;
      double deltaY = 0;
      for (final Force force : this.activeForces) {
        if (force.cancelOnReached() && force.hasReached(this.getEntity())) {
          force.end();
          continue;
        }

        final Point2D collisionBoxCenter = this.getEntity().getCollisionBoxCenter();
        final double angle =
            GeometricUtilities.calcRotationAngleInDegrees(collisionBoxCenter, force.getLocation());
        final double strength =
            Game.loop().getDeltaTime() * 0.001f * force.getStrength() * Game.loop().getTimeScale();
        deltaX += GeometricUtilities.getDeltaX(angle, strength);
        deltaY += GeometricUtilities.getDeltaY(angle, strength);
      }

      final Point2D target =
          new Point2D.Double(this.getEntity().getX() + deltaX, this.getEntity().getY() + deltaY);
      final boolean success = Game.physics().move(this.getEntity(), target);
      if (!success) {
        for (final Force force : this.activeForces) {
          if (force.cancelOnCollision()) {
            force.end();
          }
        }
      }
    } finally {
      this.getEntity().setTurnOnMove(turn);
    }
}@Override
  public void detach() {
    Game.loop().detach(this);
}public void handleMovement() {
    if (!this.isMovementAllowed()) {
      this.velocity = 0;
      return;
    }

    // max distance an entity can travel within one tick
    final double maxPixelsPerTick = this.getEntity().getTickVelocity();
    final double deltaTime = Game.loop().getDeltaTime() * Game.loop().getTimeScale();

    final double acceleration =
        this.getEntity().getAcceleration() == 0
            ? maxPixelsPerTick
            : deltaTime / this.getEntity().getAcceleration() * maxPixelsPerTick;
    final double deceleration =
        this.getEntity().getDeceleration() == 0
            ? this.getVelocity()
            : deltaTime / this.getEntity().getDeceleration() * maxPixelsPerTick;

    double dx = this.getDx();
    double dy = this.getDy();
    this.setDx(0);
    this.setDy(0);

    final double deltaVelocity =
        Math.min(Math.sqrt(Math.pow(dx, 2) + Math.pow(dy, 2)), acceleration);
    if (deltaVelocity != 0) {
      double newVelocity = this.getVelocity() + deltaVelocity;
      this.setVelocity(newVelocity);
    } else {
      final double newVelocity = Math.max(0, this.getVelocity() - deceleration);
      this.setVelocity(newVelocity);
      dx = GeometricUtilities.getDeltaX(this.moveAngle);
      dy = GeometricUtilities.getDeltaY(this.moveAngle);
    }

    if (this.getVelocity() == 0) {
      this.moveAngle = 0;
      return;
    }

    // actually move entity
    this.moveEntity(dx, dy);
}
}
```
```java
class de.gurkenlabs.litiengine.graphics.animation.AnimationController {
public void detach() {
    Game.loop().detach(this);
}public void attach() {
    Game.loop().attach(this);
}
}
```
```java
class de.gurkenlabs.litiengine.graphics.Camera {
@Override
  public void setZoom(final float targetZoom, final int delay) {
    if (delay == 0) {

      this.zoom = targetZoom;
      this.targetZoom = 0;
      this.zoomDelay = 0;
      this.zoomTick = 0;
      this.zoomStep = 0;

      final ZoomChangedEvent event = new ZoomChangedEvent(this, targetZoom);
      for (final ZoomChangedListener listener : this.zoomListeners) {
        listener.zoomChanged(event);
      }
    } else {
      this.zoomTick = Game.time().now();
      this.targetZoom = targetZoom;
      this.zoomDelay = delay;

      final double tickduration = 1000 / (double) Game.loop().getTickRate();
      final double tickAmount = delay / tickduration;
      final float totalDelta = this.targetZoom - this.zoom;
      this.zoomStep = tickAmount > 0 ? (float) (totalDelta / tickAmount) : totalDelta;
    }
}
}
```
```java
class de.gurkenlabs.litiengine.Game {
public static synchronized void init(String... args) {
    if (initialized) {
      log().log(Level.INFO, "The game has already been initialized.");
      return;
    }

    log.init();
    handleCommandLineArguments(args);

    config().load();
    Locale.setDefault(new Locale(config().client().getCountry(), config().client().getLanguage()));

    gameLoop = new GameLoop("Main Update Loop", config().client().getMaxFps());
    loop().attach(physics());
    loop().attach(world());

    // setup default exception handling for render and update loop
    setUncaughtExceptionHandler(
        new DefaultUncaughtExceptionHandler(config().client().exitOnError()));

    screenManager = new ScreenManager();
    gameWindow = new GameWindow();

    // initialize  the game window
    window().init();
    world.setCamera(new Camera());

    for (GameListener listener : gameListeners) {
      listener.initialized(args);
    }

    if (!isInNoGUIMode()) {
      window().getRenderComponent().onRendered(g -> metrics().render(g));

      graphics()
          .addEntityRenderedListener(
              e -> DebugRenderer.renderEntityDebugInfo(e.getGraphics(), e.getEntity()));

      window().getRenderComponent().onFpsChanged(fps -> metrics().setFramesPerSecond(fps));
      window()
          .setIcons(
              Arrays.asList(
                  Resources.images().get("liti-logo-x16.png"),
                  Resources.images().get("liti-logo-x20.png"),
                  Resources.images().get("liti-logo-x32.png"),
                  Resources.images().get("liti-logo-x48.png")));

      Input.keyboard()
          .onKeyTyped(
              KeyEvent.VK_PRINTSCREEN,
              key -> {
                // don't take a screenshot if a modifier is active
                if (key.getModifiers() != 0) {
                  return;
                }

                window().getRenderComponent().takeScreenshot();
              });
    }

    Runtime.getRuntime().addShutdownHook(new Thread(Game::terminate, "Shutdown"));

    initialized = true;
}
}
```
```java
class de.gurkenlabs.litiengine.entities.Creature {
protected void updateAnimationController() {
    IEntityAnimationController<?> controller = this.createAnimationController();
    this.getControllers().addController(controller);
    if (Game.world().environment() != null && Game.world().environment().isLoaded()) {
      Game.loop().attach(controller);
    }
}@Override
  public float getTickVelocity() {
    // pixels per ms multiplied by the passed ms
    // ensure that entities don't travel too far in case of lag
    return Math.min(Game.loop().getDeltaTime(), GameLoop.TICK_DELTATIME_LAG)
        * 0.001F
        * this.getVelocity().get()
        * Game.loop().getTimeScale();
}
}
```
Depth: 2
```java
class de.gurkenlabs.litiengine.environment.GameWorld {
public void clear() {
    this.unloadEnvironment();
    this.environments.clear();
    this.setCamera(null);
    Game.physics().clear();

    this.environmentListeners.clear();
    this.environmentLoadedListeners.clear();
    this.environmentUnloadedListeners.clear();

    this.listeners.clear();
    this.loadedListeners.clear();
    this.unloadedListeners.clear();
}@Nullable
  public Environment loadEnvironment(IMap map) {
    Environment env = this.getEnvironment(map);
    this.loadEnvironment(env);
    return env;
}@Nullable
  public Environment loadEnvironment(String mapName) {
    Environment env = this.getEnvironment(mapName);
    this.loadEnvironment(env);
    return env;
}
}
```
```java
class de.gurkenlabs.litiengine.GameWindow {
GameWindow() {
    this.hostControl = new JFrame();

    this.resolutionChangedListeners = new CopyOnWriteArrayList<>();

    this.renderCanvas = new RenderComponent(Game.config().graphics().getResolution());
    this.cursor = new MouseCursor();
    if (!Game.isInNoGUIMode()) {
      this.hostControl.setBackground(Color.BLACK);
      this.hostControl.add(this.renderCanvas);

      this.initializeEventListeners();

      this.hostControl.setTitle(Game.info().getTitle());
      this.hostControl.setDefaultCloseOperation(WindowConstants.DO_NOTHING_ON_CLOSE);
      initializeWindowEventListeners(this.hostControl);
    }
}
}
```
```java
class de.gurkenlabs.litiengine.GameTime {
public long sinceEnvironmentLoad() {
    return this.since(this.environmentLoaded);
}public long since(final long tick) {
    return toMilliseconds(Game.loop().getTicks() - tick);
}public long sinceGameStart() {
    return this.toMilliseconds(Game.loop().getTicks());
}
}
```
```java
class de.gurkenlabs.litiengine.abilities.effects.Effect {
protected void cease(final EffectApplication appliance) {
    // 1. cease the effect for all affected entities
    for (final ICombatEntity entity : appliance.getAffectedEntities()) {
      this.cease(entity);
    }

    // 2. apply follow up effects
    this.getFollowUpEffects().forEach(followUp -> followUp.apply(appliance.getImpactArea()));
}protected boolean hasEnded(final EffectApplication appliance) {
    final long effectDuration = Game.time().since(appliance.getAppliedTicks());
    return effectDuration > this.getDuration();
}
}
```
```java
class de.gurkenlabs.litiengine.abilities.effects.EffectApplication {
protected EffectApplication(final List<ICombatEntity> affectedEntities, final Shape impactArea) {
    this.applied = Game.time().now();
    this.affectedEntities = affectedEntities;
    this.impactArea = impactArea;
}
}
```
```java
class de.gurkenlabs.litiengine.entities.CombatEntity {
@Override
  public boolean wasHit(int timeSpan) {
    return Game.time().since(this.lastHit) < timeSpan;
}@Override
  public void hit(final int damage, @Nullable final Ability ability) {
    if (this.isDead()) {
      return;
    }

    if (!this.isIndestructible()) {
      this.getHitPoints().modifyBaseValue(new AttributeModifier<>(Modification.SUBTRACT, damage));
    }

    final EntityHitEvent event = new EntityHitEvent(this, ability, damage, this.isDead());

    for (final CombatEntityListener listener : this.listeners) {
      listener.hit(event);
    }

    for (final CombatEntityHitListener listener : this.hitListeners) {
      listener.hit(event);
    }

    if (this.isDead()) {
      this.fireDeathEvent();
      this.setCollision(false);
    }

    this.lastHit = Game.time().now();
}
}
```
```java
class de.gurkenlabs.litiengine.graphics.ImageEffect {
protected ImageEffect(final int ttl, final String name) {
    this.ttl = ttl;
    this.name = name;
    this.aliveTick = Game.time().now();
}@Override
  public long getAliveTime() {
    return Game.time().since(this.aliveTick);
}
}
```
```java
class de.gurkenlabs.litiengine.abilities.AbilityExecution {
AbilityExecution(final Ability ability) {
    this.appliedEffects = new CopyOnWriteArrayList<>();
    this.ability = ability;
    this.executionTicks = Game.time().now();
    this.impactArea = ability.calculateImpactArea();
    this.castLocation = ability.getExecutor().getCenter();
    Game.loop().attach(this);
}@Override
  public void update() {
    // if there a no effects to apply -> unregister this instance and we're done
    if (this.getAbility().getEffects().isEmpty()
        || this.getAbility().getEffects().size() == this.getAppliedEffects().size()) {
      Game.loop().detach(this);
      return;
    }

    // handle all effects from the ability that were not applied yet
    for (final Effect effect : this.getAbility().getEffects()) {
      // if the ability was not executed yet or the delay of the effect is not
      // yet reached
      if (this.getAppliedEffects().contains(effect)
          || Game.time().since(this.getExecutionTicks()) < effect.getDelay()) {
        continue;
      }

      effect.apply(this.getExecutionImpactArea());
      this.getAppliedEffects().add(effect);
    }
}
}
```
```java
class de.gurkenlabs.litiengine.tweening.TweenEngine {
@Override
  public void update() {
    for (final Tweenable target : this.getTweens().keySet()) {
      for (final Tween tween : this.getTweens().get(target).values()) {
        if (tween.hasStopped()) {
          continue;
        }
        final long elapsed = Game.time().since(tween.getStartTime());
        if (elapsed >= tween.getDuration()) {
          tween.stop();
          continue;
        }
        final float[] currentValues = new float[tween.getTargetValues().length];
        for (int i = 0; i < tween.getTargetValues().length; i++) {
          currentValues[i] =
              tween.getStartValues()[i]
                  + tween.getEquation().compute(elapsed / (float) tween.getDuration())
                      * (tween.getTargetValues()[i] - tween.getStartValues()[i]);
        }
        tween.getTarget().setTweenValues(tween.getType(), currentValues);
      }
    }
}
}
```
```java
class de.gurkenlabs.litiengine.gui.SpeechBubble {
public static SpeechBubble create(
      final IEntity entity, final String text, SpeechBubbleAppearance appearance, Font font) {
    return new SpeechBubble(entity, text, appearance, font);
}public static SpeechBubble create(final IEntity entity, final Font font, final String text) {
    SpeechBubbleAppearance app =
        new SpeechBubbleAppearance(
            DEFAULT_APPEARANCE.getForeColor(),
            DEFAULT_APPEARANCE.getBackgroundColor1(),
            DEFAULT_APPEARANCE.getBorderColor(),
            DEFAULT_APPEARANCE.getPadding());
    return new SpeechBubble(entity, text, app, font);
}public static SpeechBubble create(final IEntity entity, final String text) {
    return new SpeechBubble(entity, text, null, GuiProperties.getDefaultFont());
}@Override
  public void update() {
    if (this.currentText == null) {
      this.hide();
      return;
    }

    this.entityCenter = Game.world().camera().getViewportLocation(this.getEntity().getCenter());

    // old text was displayed long enough
    if (this.lastTextDisplay != 0
        && Game.time().since(this.lastTextDisplay) > this.currentTextDisplayTime) {
      this.currentText = null;
      this.lastTextDisplay = 0;
      return;
    }

    // display new text
    if (this.textIndex < this.currentText.length()
        && Game.time().since(this.lastCharPoll) > LETTER_WRITE_DELAY) {
      this.textIndex++;
      this.lastCharPoll = Game.time().now();
      if (this.typeSound != null) {
        Game.audio().playSound(this.typeSound, this.getEntity());
      }
    }

    // continue displaying currently displayed text
}private SpeechBubble(
      final IEntity entity,
      final String text,
      final Sound typeSound,
      SpeechBubbleAppearance appearance,
      Font font) {
    this(entity, text, appearance, font);
    this.typeSound = typeSound;
}private SpeechBubble(
      final IEntity entity,
      final String text,
      @Nullable SpeechBubbleAppearance appearance,
      @Nullable Font font) {
    if (appearance == null) {
      this.appearance = DEFAULT_APPEARANCE;
    } else {
      this.appearance = appearance;
    }

    final SpeechBubble active = activeSpeechBubbles.get(entity);
    if (active != null) {
      active.hide();
    }
    this.setFont(font);

    this.textBoxWidth = (float) (entity.getWidth() * 4);
    this.entity = entity;

    this.currentText = text;
    this.currentTextDisplayTime = DISPLAYTIME_MIN + text.length() * DISPLAYTIME_PER_LETTER;

    this.lastTextDisplay = Game.time().now();
    this.createBubbleImage();
    entity.getEnvironment().add(this, RenderType.UI);
    Game.loop().attach(this);
    activeSpeechBubbles.put(entity, this);
}
}
```
```java
class de.gurkenlabs.litiengine.gui.TextFieldComponent {
@Override
  public void render(final Graphics2D g) {
    super.render(g);
    g.setFont(this.getFont());
    final FontMetrics fm = g.getFontMetrics();

    if (this.isSelected() && Game.time().since(this.lastToggled) > this.flickerDelay) {
      this.cursorVisible = !this.cursorVisible;
      this.lastToggled = Game.time().now();
    }
    if (this.isSelected() && this.cursorVisible) {
      final Rectangle2D cursor =
          new Rectangle2D.Double(
              this.getX() + this.getTextX() + fm.stringWidth(this.getTextToRender(g)),
              this.getY() + this.getTextY(),
              this.getFont().getSize2D() * 3 / 5,
              this.getFont().getSize2D() * 1 / 5);
      g.setColor(this.getAppearance().getForeColor());
      g.fill(cursor);
    }
}
}
```
```java
class de.gurkenlabs.litiengine.entities.Prop {
public Prop(
      final Point2D location, @Nullable final String spritesheetName, final Material material) {
    super();
    this.rotation = Rotation.NONE;
    this.spritesheetName = spritesheetName;
    this.material = material;
    this.setLocation(location);
    this.updateAnimationController();
}public void setSpritesheetName(@Nullable final String spriteName) {
    this.spritesheetName = spriteName;
    this.updateAnimationController();
}
}
```
```java
class de.gurkenlabs.litiengine.tweening.Tween {
public Tween begin() {
    this.started = Game.time().now();
    this.stopped = false;
    return this;
}
}
```
```java
class de.gurkenlabs.litiengine.graphics.emitters.particles.Particle {
public void update(final Point2D emitterOrigin, final float updateRatio) {
    if (this.aliveTick == 0) {
      this.aliveTick = Game.time().now();
    }

    this.aliveTime = Game.time().since(this.aliveTick);
    if (this.timeToLiveReached()) {
      return;
    }

    if (this.colliding) {
      return;
    }

    if (this.getDeltaWidth() != 0) {
      this.width += this.getDeltaWidth() * updateRatio;
    }

    if (this.getDeltaHeight() != 0) {
      this.height += this.getDeltaHeight() * updateRatio;
    }

    if (this.getDeltaAngle() != 0) {
      this.angle += this.getDeltaAngle() * updateRatio;
    }

    // test for ray cast collision
    final float targetX = this.x + this.getVelocityX() * updateRatio;
    final float targetY = this.y + this.getVelocityY() * updateRatio;

    if (targetX == this.x && targetY == this.y) {
      return;
    }

    if (this.checkForCollision(emitterOrigin, targetX, targetY)) {
      return;
    }

    if (this.getVelocityX() != 0) {
      this.x = targetX;
    }

    if (this.getVelocityY() != 0) {
      this.y = targetY;
    }

    if (this.getAccelerationX() != 0) {
      this.velocityX += this.getAccelerationX() * updateRatio;
    }

    if (this.getAccelerationY() != 0) {
      this.velocityY += this.getAccelerationY() * updateRatio;
    }
}
}
```
```java
class de.gurkenlabs.litiengine.graphics.animation.Animation {
@Override
  public void start() {
    this.playing = true;
    if (this.getKeyframes().isEmpty()) {
      return;
    }

    this.restart();
}@Override
  public void update() {
    // do nothing if the animation is not playing or the current keyframe is not finished
    if (!this.isPlaying()
        || Game.time().since(this.lastFrameUpdate) < this.getCurrentKeyFrame().getDuration()) {
      return;
    }

    // if we are not looping and the last keyframe is finished, we terminate the animation
    if (!this.isLooping() && this.isLastKeyFrame()) {
      this.terminate();
      return;
    }

    // make sure, we stay inside the keyframe list
    final int newFrameIndex =
        (this.getKeyframes().indexOf(this.currentFrame) + 1) % this.getKeyframes().size();
    final KeyFrame previousFrame = this.currentFrame;
    this.currentFrame = this.getKeyframes().get(newFrameIndex);

    for (KeyFrameListener listener : this.listeners) {
      listener.currentFrameChanged(previousFrame, this.currentFrame);
    }

    this.lastFrameUpdate = Game.loop().getTicks();
}
}
```
```java
class de.gurkenlabs.litiengine.graphics.animation.AnimationController {
@Override
  public void update() {
    for (final Animation animation : this.getAll()) {
      animation.update();
    }

    if (this.getCurrent() != null && this.getCurrent().isPaused()) {
      return;
    }

    final boolean playbackFinished = this.getCurrent() != null && !this.getCurrent().isPlaying();
    if (playbackFinished) {
      for (final AnimationListener listener : this.listeners) {
        listener.finished(this.getCurrent());
      }
    }

    if (this.getCurrent() == null || playbackFinished) {
      if (this.getDefault() != null) {
        this.play(this.getDefault().getName());
      } else {
        this.currentAnimation = null;
      }
    }
}
}
```
```java
class de.gurkenlabs.litiengine.graphics.RenderComponent {
private void handleFade() {
    if (this.fadeOutStart != -1) {
      final long timePassed = Game.time().since(this.fadeOutStart);
      this.currentAlpha = MathUtilities.clamp(1 - timePassed / (float) this.fadeOutTime, 0, 1);
      if (this.currentAlpha == 0f) {
        this.fadeOutStart = -1;
        this.fadeOutTime = -1;
      }

      return;
    }

    if (this.fadeInStart != -1) {
      final long timePassed = Game.time().since(this.fadeInStart);
      this.currentAlpha = MathUtilities.clamp(timePassed / (float) this.fadeInTime, 0, 1);
      if (this.currentAlpha == 1f) {
        this.fadeInStart = -1;
        this.fadeInTime = -1;
        this.currentAlpha = Float.NaN;
      }
    }
}public void fadeOut(final int ms) {
    this.fadeInStart = -1;
    this.fadeInTime = -1;
    this.fadeOutStart = Game.time().now();
    this.fadeOutTime = ms;
}public void fadeIn(final int ms) {
    this.fadeOutStart = -1;
    this.fadeOutTime = -1;
    this.fadeInStart = Game.time().now();
    this.fadeInTime = ms;
}
}
```
```java
class de.gurkenlabs.litiengine.entities.Trigger {
private boolean activate(final IEntity activator, final int tar) {
    if (!this.isLoaded()
        || this.isOneTimeTrigger && this.isActivated
        || this.getActivationType() == TriggerActivation.COLLISION
            && activator != null
            && this.collisionActivated.contains(activator)) {
      return false;
    }

    if (this.getCooldown() > 0 && Game.time().since(this.lastActivation) < this.getCooldown()) {
      return false;
    }

    List<Integer> triggerTargets = this.getTargets(tar);

    final TriggerEvent te = new TriggerEvent(this, activator, triggerTargets);

    if (!this.checkActivationPredicates(te)) {
      return false;
    }

    this.isActivated = true;
    if (activator != null) {
      this.collisionActivated.add(activator);
    }

    // if we actually have a trigger target, we send the message to the target
    for (final int target : triggerTargets) {
      final IEntity entity = this.getEnvironment().get(target);
      if (entity == null) {
        log.log(
            Level.WARNING,
            "trigger [{0}] was activated, but the trigger target [{1}] could not be found on the environment",
            new Object[] {this, target});
        continue;
      }

      entity.sendMessage(this, this.message);
    }

    // also send the trigger event to all registered consumers
    for (final TriggerActivatedListener listener : this.activatedListeners) {
      listener.activated(te);
    }

    if (this.isOneTimeTrigger) {
      this.getEnvironment().remove(this);
    }

    this.lastActivation = Game.time().now();
    return true;
}
}
```
```java
class de.gurkenlabs.litiengine.graphics.Camera {
private boolean isShakeEffectActive() {
    return this.getShakeTick() != 0
        && Game.time().since(this.getShakeTick()) < this.getShakeDuration();
}@Override
  public void update() {
    if (Game.world().camera() != null && !Game.world().camera().equals(this)) {
      return;
    }

    if (this.targetZoom > 0) {
      if (Game.time().since(this.zoomTick) >= this.zoomDelay) {
        this.zoom = this.targetZoom;
        this.targetZoom = 0;
        this.zoomDelay = 0;
        this.zoomTick = 0;
        this.zoomStep = 0;
      } else {
        this.zoom += this.zoomStep;
      }

      final ZoomChangedEvent event = new ZoomChangedEvent(this, this.getZoom());
      for (final ZoomChangedListener listener : this.zoomListeners) {
        listener.zoomChanged(event);
      }
    }

    if (this.panTime > 0) {
      if (--this.panTime <= 0) {
        this.setFocus(this.targetFocus);
        this.targetFocus = null;
      } else {
        double diff = this.panTime / (this.panTime + 1.0);
        this.focus =
            new Point2D.Double(
                this.focus.getX() * diff + this.targetFocus.getX() * (1.0 - diff),
                this.focus.getY() * diff + this.targetFocus.getY() * (1.0 - diff));
      }
    }

    if (!this.isShakeEffectActive()) {
      this.shakeOffsetX = 0;
      this.shakeOffsetY = 0;
      return;
    }

    if (Game.time().since(this.lastShake) > this.shakeDelay) {
      this.shakeOffsetX = this.getShakeIntensity() * ThreadLocalRandom.current().nextGaussian();
      this.shakeOffsetY = this.getShakeIntensity() * ThreadLocalRandom.current().nextGaussian();
      this.lastShake = Game.time().now();
    }
}@Override
  public void setZoom(final float targetZoom, final int delay) {
    if (delay == 0) {

      this.zoom = targetZoom;
      this.targetZoom = 0;
      this.zoomDelay = 0;
      this.zoomTick = 0;
      this.zoomStep = 0;

      final ZoomChangedEvent event = new ZoomChangedEvent(this, targetZoom);
      for (final ZoomChangedListener listener : this.zoomListeners) {
        listener.zoomChanged(event);
      }
    } else {
      this.zoomTick = Game.time().now();
      this.targetZoom = targetZoom;
      this.zoomDelay = delay;

      final double tickduration = 1000 / (double) Game.loop().getTickRate();
      final double tickAmount = delay / tickduration;
      final float totalDelta = this.targetZoom - this.zoom;
      this.zoomStep = tickAmount > 0 ? (float) (totalDelta / tickAmount) : totalDelta;
    }
}@Override
  public void shake(final double intensity, final int delay, final int shakeDuration) {
    this.shakeTick = Game.time().now();
    this.shakeDelay = delay;
    this.shakeIntensity = intensity;
    this.shakeDuration = shakeDuration;
}
}
```
```java
class de.gurkenlabs.litiengine.entities.Creature {
public void setSpritesheetName(String spritesheetName) {
    if (this.spritesheetName != null && this.spritesheetName.equals(spritesheetName)) {
      return;
    }

    this.spritesheetName = spritesheetName;
    this.updateAnimationController();
}public boolean isIdle() {
    return Game.time().since(this.lastMoved) > IDLE_DELAY;
}@Override
  public void setLocation(final Point2D position) {
    if (this.isDead() || position == null) {
      return;
    }

    final Point2D oldLocation = this.getLocation();
    super.setLocation(position);

    if (Game.hasStarted() && this.isLoaded()) {
      this.lastMoved = Game.time().now();
      this.fireMovedEvent(
          new EntityMovedEvent(
              this, this.getX() - oldLocation.getX(), this.getY() - oldLocation.getY()));
    }
}
}
```
```java
class de.gurkenlabs.litiengine.gui.screens.ScreenManager {
public void display(final String screenName) {
    if (this.current() != null && this.current().getName().equalsIgnoreCase(screenName)) {
      log.log(
          Level.INFO,
          "Skipping displaying of screen {0} because it is already the current screen.",
          screenName);
      return;
    }

    if (this.screens.stream()
        .noneMatch(element -> element.getName().equalsIgnoreCase(screenName))) {
      log.log(
          Level.WARNING,
          "Could not display the screen {0} because there is no screen with the specified name.",
          screenName);
      return;
    }

    Screen screen = this.get(screenName);
    if (screen == null) {
      return;
    }

    this.display(screen);
}public void add(final Screen screen) {
    screen.setWidth(Game.window().getWidth());
    screen.setHeight(Game.window().getHeight());
    this.screens.add(screen);

    if (this.current() == null) {
      this.display(screen);
    }
}public void remove(Screen screen) {
    this.screens.remove(screen);
    if (this.current() == screen) {
      if (!this.screens.isEmpty()) {
        this.display(this.screens.get(0));
      } else {
        this.display((Screen) null);
      }
    }
}public void display(@Nullable final Screen screen) {
    if (Game.hasStarted() && Game.time().since(this.lastScreenChange) < this.getChangeCooldown()) {
      log.log(
          Level.INFO,
          "Skipping displaying of screen {0} because screen changing is currently on cooldown.",
          screen != null ? screen.getName() : "");
      return;
    }

    final Screen previous = this.current();
    if (previous != null) {
      previous.suspend();
    }

    if (screen != null && !this.screens.contains(screen)) {
      this.screens.add(screen);
    }

    this.currentScreen = screen;
    if (!Game.isInNoGUIMode() && this.current() != null) {
      this.current().prepare();
    }

    this.lastScreenChange = Game.loop().getTicks();

    final ScreenChangedEvent event = new ScreenChangedEvent(this.current(), previous);
    for (final ScreenChangedListener listener : this.screenChangedListeners) {
      listener.changed(event);
    }
}
}
```
```java
class de.gurkenlabs.litiengine.abilities.Ability {
public boolean isOnCooldown() {
    return (this.getCurrentExecution() != null
        && this.getCurrentExecution().getExecutionTicks() > 0
        && Game.time().since(this.getCurrentExecution().getExecutionTicks())
            < this.getAttributes().cooldown().get());
}public boolean isActive() {
    return this.getCurrentExecution() != null
        && Game.time().since(this.getCurrentExecution().getExecutionTicks())
            < this.getAttributes().duration().get();
}@Nullable
  public AbilityExecution cast() {
    if (!this.canCast()) {
      return null;
    }
    this.currentExecution = new AbilityExecution(this);

    for (final AbilityCastListener listener : this.abilityCastListeners) {
      listener.abilityCast(this.currentExecution);
    }

    return this.getCurrentExecution();
}public float getRemainingCooldownInSeconds() {
    if (this.getCurrentExecution() == null
        || this.getExecutor() == null
        || this.getExecutor().isDead()) {
      return 0;
    }

    // calculate cooldown in seconds
    return (float)
        (!this.canCast()
            ? (this.getAttributes().cooldown().get()
                    - Game.time().since(this.getCurrentExecution().getExecutionTicks()))
                * 0.001
            : 0);
}
}
```
```java
class de.gurkenlabs.litiengine.entities.EntityHitEvent {
EntityHitEvent(
      final ICombatEntity hitEntity,
      @Nullable final Ability ability,
      final int damage,
      final boolean kill) {
    super(hitEntity);
    this.executor = ability != null ? ability.getExecutor() : null;
    this.hitEntity = hitEntity;
    this.ability = ability;
    this.damage = damage;
    this.kill = kill;
    this.time = Game.time().now();
}
}
```
```java
class de.gurkenlabs.litiengine.graphics.emitters.Emitter {
public void delete() {
    this.deactivate();
    if (Game.world().environment() != null) {
      Game.world().environment().remove(this);
    }
}public void activate() {
    if (this.activated) {
      return;
    }

    this.activated = true;
    this.activationTick = Game.time().now();
    Game.loop().attach(this);
}@Override
  public void update() {
    if (this.isPaused()) {
      return;
    }

    // clear particles if the effect time to life is reached
    if (this.isFinished()) {
      for (EmitterFinishedListener listener : this.finishedListeners) {
        listener.finished(this);
      }

      this.delete();
      return;
    }

    final float updateRatio = (float) this.data().getUpdateRate() / Game.loop().getTickRate();
    for (final Particle p : this.getParticles().stream().collect(Collectors.toList())) {
      if (this.particleCanBeRemoved(p)) {
        // remove dead particles
        this.particles.remove(p);
        continue;
      }

      p.update(this.getOrigin(), updateRatio);
    }

    this.aliveTime = Game.time().since(this.activationTick);
    if ((this.data().getSpawnRate() == 0
        || Game.time().since(this.lastSpawn) >= this.data().getSpawnRate())) {
      this.lastSpawn = Game.time().now();
      this.spawnParticle();
    }
}
}
```
```java
class de.gurkenlabs.litiengine.GameLoop {
@Override
  public int perform(int delay, Runnable action) {
    final long d = Game.time().toTicks(delay);

    TimedAction a = new TimedAction(this.getTicks() + d, action);
    this.actions.add(a);

    return a.getId();
}
}
```
```java
class de.gurkenlabs.litiengine.environment.EntitySpawner {
protected boolean shouldSpawn() {
    return this.lastSpawnWave == 0
        || Game.time().since(this.lastSpawnWave) >= this.getSpawnInterval();
}@Override
  public void update() {
    if (!this.shouldSpawn()) {
      return;
    }

    this.spawnNewEntities();
    this.lastSpawnWave = Game.time().now();
}
}
```
```java
class de.gurkenlabs.litiengine.graphics.FreeFlightCamera {
@Override
  public void update() {
    this.handleFreeFlightCamera();
}public FreeFlightCamera(double x, double y) {
    this(new Point2D.Double(x, y));
}
}
```
```java
class de.gurkenlabs.litiengine.environment.Environment {
public void unload() {
    if (!this.loaded) {
      return;
    }

    // unregister all updatable entities from the current environment
    for (final IEntity entity : this.allEntities.values()) {
      this.unload(entity);
    }

    this.loaded = false;
    this.fireEvent(l -> l.unloaded(this));
}private static void loadUpdatableOrEmitterEntity(IEntity entity) {
    if (entity instanceof Emitter) {
      final Emitter emitter = (Emitter) entity;
      if (emitter.isActivateOnInit()) {
        emitter.activate();
      }
    } else if (entity instanceof IUpdateable) {
      Game.loop().attach((IUpdateable) entity);
    }
}public void clear() {
    Game.physics().clear();

    this.combatEntities.clear();
    this.mobileEntities.clear();
    this.gravityForces.clear();
    this.layerEntities.clear();
    this.entitiesByTag.clear();
    this.allEntities.clear();

    for (RenderType renderType : RenderType.values()) {
      this.miscEntities.get(renderType).clear();
      this.renderListeners.get(renderType).clear();
      this.renderables.get(renderType).clear();
    }

    dispose(this.allEntities.values());
    dispose(this.triggers);
    this.emitters.clear();
    this.colliders.clear();
    this.props.clear();
    this.creatures.clear();
    this.staticShadows.clear();
    this.combatEntities.clear();
    this.mobileEntities.clear();
    this.lightSources.clear();
    this.spawnPoints.clear();
    this.soundSources.clear();
    this.mapAreas.clear();
    this.triggers.clear();

    this.ambientLight = null;
    this.staticShadowLayer = null;

    for (Map<Integer, IEntity> type : this.miscEntities.values()) {
      type.clear();
    }

    this.initialized = false;

    this.fireEvent(l -> l.cleared(this));
}private void load(final IEntity entity) {
    // an entity can only exist on one environment at a time, so remove it from the current one
    if (entity.getEnvironment() != null) {
      entity.getEnvironment().remove(entity);
    }

    // 1. add to physics engine
    loadPhysicsEntity(entity);

    // 2. register for update or activate
    loadUpdatableOrEmitterEntity(entity);

    // 3. if a gravity is defined, add a gravity force to the entity
    if (entity instanceof IMobileEntity && this.getGravity() != 0) {
      this.addGravityForce((IMobileEntity) entity);
    }

    // 4. attach all controllers
    entity.attachControllers();

    if (this.loaded && (entity instanceof LightSource || entity instanceof StaticShadow)) {
      this.updateLighting(entity);
    }

    entity.loaded(this);
}private void unload(final IEntity entity) {
    // 1. remove from physics engine
    if (entity instanceof ICollisionEntity) {
      Game.physics().remove((ICollisionEntity) entity);
    }

    // 2. unregister from update
    if (entity instanceof IUpdateable) {
      Game.loop().detach((IUpdateable) entity);
    }

    if (entity instanceof IMobileEntity) {
      this.removeGravity((IMobileEntity) entity);
    }

    // 3. detach all controllers
    entity.detachControllers();

    if (entity instanceof Emitter) {
      Emitter em = (Emitter) entity;
      em.deactivate();
    }

    if (this.loaded && (entity instanceof LightSource || entity instanceof StaticShadow)) {
      this.updateLighting(entity);
    }

    entity.removed(this);
}public void remove(final IEntity entity) {
    if (entity == null) {
      return;
    }

    this.allEntities.remove(entity.getMapId());
    Iterator<List<IEntity>> iter = this.layerEntities.values().iterator();
    while (iter.hasNext()) {
      List<IEntity> layer = iter.next();
      if (layer.remove(entity) && layer.isEmpty()) {
        iter.remove();
      }
    }
    if (this.miscEntities.get(entity.getRenderType()) != null) {
      this.miscEntities.get(entity.getRenderType()).values().remove(entity);
    }

    for (String tag : entity.getTags()) {
      if (this.getEntitiesByTag().containsKey(tag)) {
        this.getEntitiesByTag().get(tag).remove(entity);

        if (this.getEntitiesByTag().get(tag).isEmpty()) {
          this.getEntitiesByTag().remove(tag);
        }
      }
    }

    if (entity instanceof Emitter) {
      Emitter emitter = (Emitter) entity;
      this.removeEmitter(emitter);
    }

    if (entity instanceof MapArea) {
      this.mapAreas.remove(entity);
    }

    if (entity instanceof Prop) {
      this.props.remove(entity);
    }

    if (entity instanceof Creature) {
      this.creatures.remove(entity);
    }

    if (entity instanceof CollisionBox) {
      this.colliders.remove(entity);
      this.staticShadows.removeIf(x -> x.getOrigin() != null && x.getOrigin().equals(entity));
    }

    if (entity instanceof LightSource) {
      this.lightSources.remove(entity);
      this.updateLighting(entity);
    }

    if (entity instanceof Trigger) {
      this.triggers.remove(entity);
    }

    if (entity instanceof Spawnpoint) {
      this.spawnPoints.remove(entity);
    }
    if (entity instanceof SoundSource) {
      this.soundSources.remove(entity);
    }

    if (entity instanceof StaticShadow) {
      this.staticShadows.remove(entity);
      this.updateLighting(entity);
    }

    if (entity instanceof IMobileEntity) {
      this.mobileEntities.values().remove(entity);
    }

    if (entity instanceof ICombatEntity) {
      this.combatEntities.values().remove(entity);
    }

    this.unload(entity);

    this.fireEntityEvent(l -> l.entityRemoved(entity));
}
}
```
```java
class de.gurkenlabs.litiengine.physics.MovementController {
@Override
  public void update() {
    this.handleForces();
    this.handleMovement();
}
}
```
```java
class de.gurkenlabs.litiengine.Game {
static synchronized void terminate() {
    if (!initialized) {
      return;
    }

    hasStarted = false;
    initialized = false;

    config().save();
    gameLoop.terminate();
    tweenEngine.terminate();
    soundEngine.terminate();

    world().clear();

    for (final GameListener listener : gameListeners) {
      try {
        listener.terminated();
      } catch (Exception e) {
        log().log(Level.WARNING, "game listener threw an exception during shutdown", e);
      }
    }

    gameLoop = null;
    screenManager = null;
    gameWindow = null;
}public static synchronized void start() {
    if (!initialized) {
      throw new IllegalStateException(
          "The game cannot be started without being first initialized. Call Game.init(...) before Game.start().");
    }

    gameLoop.start();
    tweenEngine.start();
    soundEngine.start();

    for (final GameListener listener : gameListeners) {
      listener.started();
    }

    hasStarted = true;
}public static synchronized void init(String... args) {
    if (initialized) {
      log().log(Level.INFO, "The game has already been initialized.");
      return;
    }

    log.init();
    handleCommandLineArguments(args);

    config().load();
    Locale.setDefault(new Locale(config().client().getCountry(), config().client().getLanguage()));

    gameLoop = new GameLoop("Main Update Loop", config().client().getMaxFps());
    loop().attach(physics());
    loop().attach(world());

    // setup default exception handling for render and update loop
    setUncaughtExceptionHandler(
        new DefaultUncaughtExceptionHandler(config().client().exitOnError()));

    screenManager = new ScreenManager();
    gameWindow = new GameWindow();

    // initialize  the game window
    window().init();
    world.setCamera(new Camera());

    for (GameListener listener : gameListeners) {
      listener.initialized(args);
    }

    if (!isInNoGUIMode()) {
      window().getRenderComponent().onRendered(g -> metrics().render(g));

      graphics()
          .addEntityRenderedListener(
              e -> DebugRenderer.renderEntityDebugInfo(e.getGraphics(), e.getEntity()));

      window().getRenderComponent().onFpsChanged(fps -> metrics().setFramesPerSecond(fps));
      window()
          .setIcons(
              Arrays.asList(
                  Resources.images().get("liti-logo-x16.png"),
                  Resources.images().get("liti-logo-x20.png"),
                  Resources.images().get("liti-logo-x32.png"),
                  Resources.images().get("liti-logo-x48.png")));

      Input.keyboard()
          .onKeyTyped(
              KeyEvent.VK_PRINTSCREEN,
              key -> {
                // don't take a screenshot if a modifier is active
                if (key.getModifiers() != 0) {
                  return;
                }

                window().getRenderComponent().takeScreenshot();
              });
    }

    Runtime.getRuntime().addShutdownHook(new Thread(Game::terminate, "Shutdown"));

    initialized = true;
}
}
```


Response Format:
Provide the answer in **XML format** as follows:

#### If the method **cannot** return `null` at the specific call site:
```xml
<response>
  <reason><![CDATA[EXPLAIN WHY THE INVOCATION Game.loop() RESULT CANNOT BE NULL.]]></reason>
  <value>NO</value>
</response>

#### If the method can return null at the specific call site:
<response>
  <reason><![CDATA[EXPLAIN WHY THE INVOCATION Game.loop() RESULT CAN BE NULL.]]></reason>
  <value>YES</value>
</response>

#### If you are unsure or If there are any methods that directly or indirectly affect the return value and are not fully disclosed, request their declarations first, in the following format:
<response>
  <reason><![CDATA[EXPLAIN WHY THIS METHOD DECLARATION IS NECESSARY AND WHY YOU CANNOT MAKE A CONFIDENT DECISION WITHOUT IT]]></reason>
  <success>false</success>
  <methods>
    <method>methodName</method>
  </methods>
</response>

Additional Notes:
Be precise in your reasoning.
If a method’s return value depends on another method not provided, request its declaration before making a conclusion.
If the method can return null in this case but not in others, explain why it happens specifically for this call.

---ChatGPT.sendRequestToOpenAI---
Retrieving response from cache
---Response.<init>---
Creating Response:
```xml
<response>
  <reason><![CDATA[The method `Game.loop()` returns the static field `gameLoop`, which is initialized in the `Game.init(String... args)` method. In this method, a new `GameLoop` object is instantiated and assigned to `gameLoop`. Since `init()` must be called before `start()`, which is implied by the requirement of initializing the game, the `gameLoop` is guaranteed to be non-null during the lifetime of the game execution where `Game.loop()` is called. The absence of any code that could set `gameLoop` to null after its initialization ensures that `Game.loop()` cannot return null.]]></reason>
  <value>NO</value>
</response>
```
---Response.<init>---
Response created:
Disagreement: The method `Game.loop()` returns the static field `gameLoop`, which is initialized in the `Game.init(String... args)` method. In this method, a new `GameLoop` object is instantiated and assigned to `gameLoop`. Since `init()` must be called before `start()`, which is implied by the requirement of initializing the game, the `gameLoop` is guaranteed to be non-null during the lifetime of the game execution where `Game.loop()` is called. The absence of any code that could set `gameLoop` to null after its initialization ensures that `Game.loop()` cannot return null.
---AdvancedNullAwayCodeFix.resolveMethodDereferenceError---
Method is not returning nullable on call site. Injecting suppression annotation.
---AdvancedNullAwayCodeFix.constructCastToNonnullChange---
Constructing cast to nonnull change for reason: The method `Game.loop()` returns the static field `gameLoop`, which is initialized in the `Game.init(String... args)` method. In this method, a new `GameLoop` object is instantiated and assigned to `gameLoop`. Since `init()` must be called before `start()`, which is implied by the requirement of initializing the game, the `gameLoop` is guaranteed to be non-null during the lifetime of the game execution where `Game.loop()` is called. The absence of any code that could set `gameLoop` to null after its initialization ensures that `Game.loop()` cannot return null.
---ChatGPT.ask---
Asking ChatGPT:
For the reason you mentioned earlier:

"The method `Game.loop()` returns the static field `gameLoop`, which is initialized in the `Game.init(String... args)` method. In this method, a new `GameLoop` object is instantiated and assigned to `gameLoop`. Since `init()` must be called before `start()`, which is implied by the requirement of initializing the game, the `gameLoop` is guaranteed to be non-null during the lifetime of the game execution where `Game.loop()` is called. The absence of any code that could set `gameLoop` to null after its initialization ensures that `Game.loop()` cannot return null."

in the method below, the expression Game.loop() is not nullable at the point it is used.

```java
@Override
  public void detach() {
    Game.loop().detach(this);
}
```
Please Summarize the reason in max 5 words and rewrite the method so that at the line "    Game.loop().detach(this);", at the occurrence of: "Game.loop()" is replaced with `NullabilityUtil.castToNonnull(Game.loop(), summary of reason)`
Replace "REASON" with the exact reason summary I provide to you (maximum 5 words), not with a generic explanation like "checked to be nonnull".
see the example below, for expression `foo.getBar()`, to wrap it with `NullabilityUtil.castToNonnull(foo.getBar(), "reason")`.

```java
public t(){
    String l = foo.getBar();
}
```

will be:
```java
public t(){
    String l = NullabilityUtil.castToNonnull(foo.getBar(), "checked to be nonnull");
}
```

### Instructions:

Do not import any additional classes.

Do not add Java comments.

Only modify relevant lines as required.

Return only the modified method wrapped in the XML format shown below.

Place the Java code inside the <code> tag using a CDATA block with ```java formatting.

Just give me the fixed code snippet in XML format in <response> tag like the example below. I will apply the fix to my codebase. Do not import any additional libraries or classes or add java comments. If you can provide the fixed code snippet, please provide it in the following format and place the code snippet in the <code> tag within ```java block.
<response>
  <success>true</success>
  <code><![CDATA[
  ```java
  Your fixed code snippet here
  ```
    ]]>
  </code>
</response>

---ChatGPT.sendRequestToOpenAI---
Sending request to OpenAI...
---ChatGPT.sendRequestToOpenAI---
Response received from OpenAI.
---Response.<init>---
Creating Response:
<response>
  <success>true</success>
  <code><![CDATA[
  ```java
  @Override
  public void detach() {
    NullabilityUtil.castToNonnull(Game.loop(), "guaranteed to be non-null").detach(this);
  }
  ```
    ]]>
  </code>
</response>
---Response.<init>---
Response created:
@Override
  public void detach() {
    NullabilityUtil.castToNonnull(Game.loop(), "guaranteed to be non-null").detach(this);
  }
---ChatGPT.fixDereferenceByAddingCastToNonnull---
Fixing the error by adding castToNonnull
---AdvancedNullAwayCodeFix.fixTriggeredErrorsForLocation---
Resolving unresolvable error for triggered error: Type='DEREFERENCE_NULLABLE', message='dereferenced expression Game.loop() is @Nullable'
/home/nima/Developer/nullness-benchmarks/litiengine/src/de/gurkenlabs/litiengine/graphics/animation/Animation.java:302
    this.lastFrameUpdate = Game.loop().getTicks();
---AdvancedNullAwayCodeFix.fix---
Fixing error: Type='DEREFERENCE_NULLABLE', message='dereferenced expression Game.loop() is @Nullable'
/home/nima/Developer/nullness-benchmarks/litiengine/src/de/gurkenlabs/litiengine/graphics/animation/Animation.java:302
    this.lastFrameUpdate = Game.loop().getTicks();
---AdvancedNullAwayCodeFix.resolveDereferenceError---
Resolving dereference error: Type='DEREFERENCE_NULLABLE', message='dereferenced expression Game.loop() is @Nullable'
/home/nima/Developer/nullness-benchmarks/litiengine/src/de/gurkenlabs/litiengine/graphics/animation/Animation.java:302
    this.lastFrameUpdate = Game.loop().getTicks();
---AdvancedNullAwayCodeFix.resolveDereferenceError---
Checking nullability possibility at error point
---ChatGPT.checkNullabilityPossibilityAtErrorPoint---
Asking if the expression can be null at error point point
---ChatGPT.ask---
Asking ChatGPT:
In the method below, is there a possibility that the expression "Game.loop()" at line "this.lastFrameUpdate = Game.loop().getTicks();" is null?
public void restart() {
    this.currentFrame = this.firstFrame;
    this.lastFrameUpdate = Game.loop().getTicks();
}
Give a single-word answer in XML format. If it is possible for the expression to be null, respond with:
```xml
<response>
    <reason><![CDATA[YOUR REASON]]></reason>
    <value>YES</value>
</response>
```
If it is not possible for the expression to be null, respond with:
```xml
<response>
    <reason><![CDATA[YOUR REASON]]></reason>
    <value>NO</value>
</response>
```
If you are unsure or need more information, respond with where you can ask for more details or what specific information you need.

If additional information is required, list each request inside a `<request>` tag. If no additional information is needed, omit the `<requests>` section.

Respond with:
```xml
<response>
    <reason><![CDATA[YOUR REASON]]></reason>
    <value>UNKNOWN</value>
    <!-- Include <requests> only if additional information is needed -->
    <requests>
        <request><![CDATA[YOUR REQUEST 1]]></request>
        <request><![CDATA[YOUR REQUEST 2]]></request>
    </requests>
</response>
```
---ChatGPT.sendRequestToOpenAI---
Sending request to OpenAI...
---ChatGPT.sendRequestToOpenAI---
Response received from OpenAI.
---Response.<init>---
Creating Response:
```xml
<response>
    <reason><![CDATA[Without additional context on how Game.loop() is implemented, it's not possible to determine if it can be null.]]></reason>
    <value>UNKNOWN</value>
    <requests>
        <request><![CDATA[Details on the implementation of Game.loop(), including if it can return null.]]></request>
        <request><![CDATA[Information on any conditions or states that might affect Game.loop().]]></request>
    </requests>
</response>
```
---Response.<init>---
Response created:
Unknown: Without additional context on how Game.loop() is implemented, it's not possible to determine if it can be null.
---AdvancedNullAwayCodeFix.resolveMethodDereferenceError---
Resolving method dereference error.
---AdvancedNullAwayCodeFix.resolveMethodDereferenceError---
Method is in annotated package. Checking if the method is returning nullable.
---AdvancedNullAwayCodeFix.investigateMethodReturnNullability---
Checking if the method is returning nullable.
---ChatGPT.checkIfMethodIsReturningNullable---
Asking if the method is returning nullable: loop()
---ChatGPT.ask---
Asking ChatGPT:
In the method below, is there a possibility that the method returns null based only on its body? Consider the following points:

- The method may have multiple return paths; consider all return statements.
- If the method calls another method, do not assume its return value unless its full declaration is provided. Request its declaration if needed.
- The method may throw an exception instead of returning null. An exception path should not be considered a null return.
- Ensure you request the declarations of any methods whose return values directly or indirectly impact this method’s return value before making a conclusion.
- Carefully analyze all conditions and prior operations that may guarantee a non-null return value.

@Nullable public static IGameLoop loop() {
    return gameLoop;
}

Here are the method definitions in addition to the method inquired:

Depth: 0
```java
class de.gurkenlabs.litiengine.Game {
@Nullable public static IGameLoop loop() {
    return gameLoop;
}
}
```


Response Format:
Provide the answer in **XML format** as follows:

#### If the method **cannot** return `null`:
```xml
<response>
  <reason><![CDATA[EXPLAIN WHY THE METHOD CANNOT RETURN NULL]]></reason>
  <value>NO</value>
</response>
```

#### If the method can return null:
```xml
<response>
  <reason><![CDATA[EXPLAIN WHY THE METHOD CAN RETURN NULL]]></reason>
  <value>YES</value>
</response>
```

#### If you are unsure or need more information, respond with where you can ask for more details or what specific information you need.

#### If you are unsure or If there are any methods that directly or indirectly affect the return value and are not fully disclosed, request their declarations first, in the following format:
<response>
  <reason><![CDATA[YOUR REASON]]></reason>
  <value>UNKNOWN</value>
  <methods>
    <method>methodName</method>
  </methods>
</response>

If additional information is required other than method declaration, list each request inside a `<request>` tag. If no additional information is needed, omit the `<requests>` section.

Respond with:
```xml
<response>
    <reason><![CDATA[YOUR REASON]]></reason>
    <value>UNKNOWN</value>
    <!-- Include <requests> only if additional information is needed -->
    <requests>
        <request><![CDATA[YOUR REQUEST 1]]></request>
        <request><![CDATA[YOUR REQUEST 2]]></request>
    </requests>
</response>
```

Additional Notes:
Be precise in your reasoning.
If a method’s return value depends on another method not provided, request its declaration before making a conclusion.
If the method can return null in some cases but not others, explain under what conditions it can happen.

---ChatGPT.sendRequestToOpenAI---
Retrieving response from cache
---Response.<init>---
Creating Response:
```xml
<response>
  <reason><![CDATA[The method `loop` returns the variable `gameLoop`. Without the initialization or assignment details of `gameLoop`, it's unclear whether it can be null. The possibility of `gameLoop` being uninitialized or set to null elsewhere in the program means `loop` could potentially return null. Further information on `gameLoop` is required.]]></reason>
  <value>UNKNOWN</value>
  <requests>
    <request><![CDATA[Please provide the declaration and initialization of the variable `gameLoop` in the class `de.gurkenlabs.litiengine.Game`.]]></request>
  </requests>
</response>
```
---Response.<init>---
Response created:
Unknown: The method `loop` returns the variable `gameLoop`. Without the initialization or assignment details of `gameLoop`, it's unclear whether it can be null. The possibility of `gameLoop` being uninitialized or set to null elsewhere in the program means `loop` could potentially return null. Further information on `gameLoop` is required.
---AdvancedNullAwayCodeFix.investigateMethodReturnNullability---
Could not determine the nullability and model did not ask for any method.
---ChatGPT.checkIfMethodIsReturningNullableOnCallSite---
Asking if the method is returning nullable on the call site: Game.loop()
---ChatGPT.ask---
Asking ChatGPT:
In the method below, is there a possibility that the method returns null at the given call site?

```java
@Nullable public static IGameLoop loop() {
    return gameLoop;
}
```

## Guidelines:
- The method may have multiple return paths; consider all return statements.
- If the method calls another method, do not assume its return value unless its full declaration is provided. Request its declaration if needed.
- The method may throw an exception instead of returning null. An exception path should not be considered a null return.
- Ensure you request the declarations of any methods whose return values directly or indirectly impact this method’s return value before making a conclusion.
- If the method returns a value that is determined by a parameter, evaluate based on the actual argument at the given call site.
- Analyze based only on the specific invocation provided. Do not generalize to all possible inputs.- If the return value is guaranteed to be non-null at the call site, the answer should be a definitive NO.
- Do not generalize based on all possible inputs—your answer must be based only on the given invocation.
- Focus only on the given call site, not all possible invocations.

### call site:
Game.loop()

Here are the method definitions and the call chain for this method, showing the sequence of calls from the method to its callers at each depth level:

Depth: 0
```java
class de.gurkenlabs.litiengine.Game {
@Nullable public static IGameLoop loop() {
    return gameLoop;
}
}
```
Depth: 1
```java
class de.gurkenlabs.litiengine.environment.GameWorld {
public void loadEnvironment(@Nullable final Environment env) {
    Lock lock = Game.loop().getLock();
    lock.lock();
    try {
      unloadEnvironment();
      this.environment = env;
      if (env != null) {
        this.addEnvironment(env);

        if (env.getGravity() == 0 && this.gravity() != 0) {
          env.setGravity(this.gravity());
        }

        env.load();
        for (final EnvironmentLoadedListener listener : this.loadedListeners) {
          listener.loaded(env);
        }

        // call map specific listeners
        String mapName = getMapName(env);
        if (mapName != null && this.environmentLoadedListeners.containsKey(mapName)) {

          // for the default camera we center the camera on the environment
          if (this.camera().getClass().equals(Camera.class)) {
            camera().setFocus(env.getCenter());
          }

          for (EnvironmentLoadedListener listener : this.environmentLoadedListeners.get(mapName)) {
            listener.loaded(env);
          }
        }
      }
    } finally {
      lock.unlock();
    }
}public void setCamera(@Nullable final ICamera cam) {
    if (this.camera() != null) {
      Game.loop().detach(camera);
    }

    camera = cam;

    if (cam != null && !Game.isInNoGUIMode()) {
      Game.loop().attach(cam);
      cam.updateFocus();
    }
}
}
```
```java
class de.gurkenlabs.litiengine.entities.behavior.EntityNavigator {
public EntityNavigator(final IMobileEntity entity, final PathFinder pathFinder) {
    this.cancelNavigationConditions = new CopyOnWriteArrayList<>();
    this.listeners = new CopyOnWriteArrayList<>();
    this.entity = entity;
    this.pathFinder = pathFinder;
    this.setAcceptableError(DEFAULT_ACCEPTABLE_ERROR);
    Game.loop().attach(this);
}
}
```
```java
class de.gurkenlabs.litiengine.GameWindow {
private static void initializeWindowEventListeners(Window window) {

    window.addWindowStateListener(
        e -> {
          if (e.getNewState() == Frame.ICONIFIED) {
            Game.loop().setTickRate(ICONIFIED_MAX_FPS);
          } else {
            Game.loop().setTickRate(Game.config().client().getMaxFps());
          }
        });

    window.addWindowFocusListener(
        new WindowFocusListener() {
          @Override
          public void windowLostFocus(WindowEvent e) {
            if (Game.config().graphics().reduceFramesWhenNotFocused()) {
              Game.loop().setTickRate(NONE_FOCUS_MAX_FPS);
            }
          }

          @Override
          public void windowGainedFocus(WindowEvent e) {
            Game.loop().setTickRate(Game.config().client().getMaxFps());
          }
        });

    window.addWindowListener(
        new WindowAdapter() {
          @Override
          public void windowClosing(final WindowEvent event) {
            Game.exit();
          }
        });
}
}
```
```java
class de.gurkenlabs.litiengine.gui.screens.ScreenManager {
public void display(@Nullable final Screen screen) {
    if (Game.hasStarted() && Game.time().since(this.lastScreenChange) < this.getChangeCooldown()) {
      log.log(
          Level.INFO,
          "Skipping displaying of screen {0} because screen changing is currently on cooldown.",
          screen != null ? screen.getName() : "");
      return;
    }

    final Screen previous = this.current();
    if (previous != null) {
      previous.suspend();
    }

    if (screen != null && !this.screens.contains(screen)) {
      this.screens.add(screen);
    }

    this.currentScreen = screen;
    if (!Game.isInNoGUIMode() && this.current() != null) {
      this.current().prepare();
    }

    this.lastScreenChange = Game.loop().getTicks();

    final ScreenChangedEvent event = new ScreenChangedEvent(this.current(), previous);
    for (final ScreenChangedListener listener : this.screenChangedListeners) {
      listener.changed(event);
    }
}
}
```
```java
class de.gurkenlabs.litiengine.abilities.effects.Effect {
@Override
  public void update() {

    for (final Iterator<EffectApplication> iterator = this.getActiveAppliances().iterator();
        iterator.hasNext(); ) {
      final EffectApplication appliance = iterator.next();
      // if the effect duration is reached
      if (this.hasEnded(appliance)) {

        iterator.remove();
        this.cease(appliance);
      }
    }

    // 4. unregister if all appliances are finished
    if (this.getActiveAppliances().isEmpty()) {
      Game.loop().detach(this);
    }
}public void apply(final Shape impactArea) {
    final List<ICombatEntity> affected = this.lookForAffectedEntities(impactArea);
    for (final ICombatEntity affectedEntity : affected) {
      this.apply(affectedEntity);
    }

    this.appliances.add(new EffectApplication(affected, impactArea));

    // if it is the first appliance -> register for update
    if (this.appliances.size() == 1) {
      Game.loop().attach(this);
    }
}
}
```
```java
class de.gurkenlabs.litiengine.GameTime {
public long toTicks(final int milliseconds) {
    return this.toTicks(milliseconds, Game.loop().getTickRate());
}public long since(final long tick) {
    return toMilliseconds(Game.loop().getTicks() - tick);
}public long now() {
    return Game.loop().getTicks();
}public long sinceGameStart() {
    return this.toMilliseconds(Game.loop().getTicks());
}@Override
  public void loaded(Environment environment) {
    environmentLoaded = Game.loop().getTicks();
}public long toMilliseconds(final long ticks) {
    return this.toMilliseconds(ticks, Game.loop().getTickRate());
}
}
```
```java
class de.gurkenlabs.litiengine.GameMetrics {
@Override
  public void render(final Graphics2D g) {
    this.updateMetrics();

    if (!Game.config().client().showGameMetrics()) {
      return;
    }

    this.currentOffsetY = 0;

    g.setColor(this.renderColor);

    // render client metrics
    this.drawTitle(g, "[client]");
    this.drawMetric(g, "fps       : " + this.getFramesPerSecond());
    this.drawMetric(g, "max fps   : " + this.maxFramesPerSecond);
    this.drawMetric(g, "updatables: " + Game.loop().getUpdatableCount());

    // render jvm metrics if debug is enabled
    if (Game.config().debug().isDebugEnabled()) {
      this.drawTitle(g, "[jvm]");
      this.drawMetric(g, "java      : " + this.javaVersion);
      this.drawMetric(g, "memory    : " + String.format("%-5.5s", this.usedMemory) + " MB");
      this.drawMetric(g, "threads   : " + Thread.activeCount());
    }

    // render rendering metrics
    if (!this.renderMetrics.isEmpty()) {
      this.drawTitle(g, "[update]");

      for (RenderMetrics metric : this.renderMetrics) {
        this.drawMetric(g, metric.toString());
      }

      this.renderMetrics.clear();
    }
}
}
```
```java
class de.gurkenlabs.litiengine.graphics.emitters.Emitter {
public void deactivate() {
    if (!this.activated) {
      return;
    }

    this.activated = false;
    this.getParticles().clear();
    this.aliveTime = 0;
    this.activationTick = 0;
    this.lastSpawn = 0;
    Game.loop().detach(this);
}public void activate() {
    if (this.activated) {
      return;
    }

    this.activated = true;
    this.activationTick = Game.time().now();
    Game.loop().attach(this);
}@Override
  public void update() {
    if (this.isPaused()) {
      return;
    }

    // clear particles if the effect time to life is reached
    if (this.isFinished()) {
      for (EmitterFinishedListener listener : this.finishedListeners) {
        listener.finished(this);
      }

      this.delete();
      return;
    }

    final float updateRatio = (float) this.data().getUpdateRate() / Game.loop().getTickRate();
    for (final Particle p : this.getParticles().stream().collect(Collectors.toList())) {
      if (this.particleCanBeRemoved(p)) {
        // remove dead particles
        this.particles.remove(p);
        continue;
      }

      p.update(this.getOrigin(), updateRatio);
    }

    this.aliveTime = Game.time().since(this.activationTick);
    if ((this.data().getSpawnRate() == 0
        || Game.time().since(this.lastSpawn) >= this.data().getSpawnRate())) {
      this.lastSpawn = Game.time().now();
      this.spawnParticle();
    }
}
}
```
```java
class de.gurkenlabs.litiengine.entities.behavior.IBehaviorController {
public default void attach() {
    Game.loop().attach(this);
}public default void detach() {
    Game.loop().detach(this);
}
}
```
```java
class de.gurkenlabs.litiengine.abilities.AbilityExecution {
AbilityExecution(final Ability ability) {
    this.appliedEffects = new CopyOnWriteArrayList<>();
    this.ability = ability;
    this.executionTicks = Game.time().now();
    this.impactArea = ability.calculateImpactArea();
    this.castLocation = ability.getExecutor().getCenter();
    Game.loop().attach(this);
}@Override
  public void update() {
    // if there a no effects to apply -> unregister this instance and we're done
    if (this.getAbility().getEffects().isEmpty()
        || this.getAbility().getEffects().size() == this.getAppliedEffects().size()) {
      Game.loop().detach(this);
      return;
    }

    // handle all effects from the ability that were not applied yet
    for (final Effect effect : this.getAbility().getEffects()) {
      // if the ability was not executed yet or the delay of the effect is not
      // yet reached
      if (this.getAppliedEffects().contains(effect)
          || Game.time().since(this.getExecutionTicks()) < effect.getDelay()) {
        continue;
      }

      effect.apply(this.getExecutionImpactArea());
      this.getAppliedEffects().add(effect);
    }
}
}
```
```java
class de.gurkenlabs.litiengine.GameWindow$3 {
@Override
          public void windowGainedFocus(WindowEvent e) {
            Game.loop().setTickRate(Game.config().client().getMaxFps());
}@Override
          public void windowLostFocus(WindowEvent e) {
            if (Game.config().graphics().reduceFramesWhenNotFocused()) {
              Game.loop().setTickRate(NONE_FOCUS_MAX_FPS);
            }
}
}
```
```java
class de.gurkenlabs.litiengine.environment.EntitySpawner {
protected void spawnNewEntities() {
    if (this.getSpawnMode() != SpawnMode.CUSTOMSPAWNPOINTS && this.getSpawnPoints().isEmpty()) {
      return;
    }

    switch (this.getSpawnMode()) {
      case ALLSPAWNPOINTS:
        for (int i = 0; i < this.getSpawnPoints().size(); i++) {
          final int index = i;
          Game.loop()
              .perform(
                  this.getSpawnDelay() + this.getSpawnDelay() * i,
                  () -> this.spawn(this.getSpawnPoints().get(index), this.getSpawnAmount()));
        }
        break;
      case ONERANDOMSPAWNPOINT:
        this.spawn(Game.random().choose(this.getSpawnPoints()), this.getSpawnAmount());
        break;
      case RANDOMSPAWNPOINTS:
        for (int i = 0; i < this.getSpawnAmount(); i++) {
          Game.loop()
              .perform(
                  this.getSpawnDelay() + this.getSpawnDelay() * i,
                  () -> this.spawn(Game.random().choose(this.getSpawnPoints()), 1));
        }
        break;
      case CUSTOMSPAWNPOINTS:
        List<Spawnpoint> spawnPoints =
            this.customSpawnpoints != null
                ? this.customSpawnpoints.apply(this)
                : this.getCustomSpawnpoints();

        int index = 0;
        for (Spawnpoint spawn : spawnPoints) {
          Game.loop()
              .perform(
                  this.getSpawnDelay() + this.getSpawnDelay() * index, () -> this.spawn(spawn, 1));
          index++;
        }
        break;
      default:
        break;
    }
}
}
```
```java
class de.gurkenlabs.litiengine.tweening.TweenEngine {
@Override
  public void start() {
    Game.loop().attach(this);
}@Override
  public void terminate() {
    Game.loop().detach(this);
}
}
```
```java
class de.gurkenlabs.litiengine.gui.SpeechBubble {
public void hide() {
    Game.world().environment().removeRenderable(this);
    Game.loop().detach(this);
    if (activeSpeechBubbles.get(this.getEntity()) != null
        && activeSpeechBubbles.remove(this.getEntity()).equals(this)) {
      activeSpeechBubbles.remove(this.getEntity());
    }

    for (SpeechBubbleListener listener : this.listeners) {
      listener.hidden();
    }
}private SpeechBubble(
      final IEntity entity,
      final String text,
      @Nullable SpeechBubbleAppearance appearance,
      @Nullable Font font) {
    if (appearance == null) {
      this.appearance = DEFAULT_APPEARANCE;
    } else {
      this.appearance = appearance;
    }

    final SpeechBubble active = activeSpeechBubbles.get(entity);
    if (active != null) {
      active.hide();
    }
    this.setFont(font);

    this.textBoxWidth = (float) (entity.getWidth() * 4);
    this.entity = entity;

    this.currentText = text;
    this.currentTextDisplayTime = DISPLAYTIME_MIN + text.length() * DISPLAYTIME_PER_LETTER;

    this.lastTextDisplay = Game.time().now();
    this.createBubbleImage();
    entity.getEnvironment().add(this, RenderType.UI);
    Game.loop().attach(this);
    activeSpeechBubbles.put(entity, this);
}
}
```
```java
class de.gurkenlabs.litiengine.entities.Prop {
private void updateAnimationController() {
    IEntityAnimationController<?> controller = this.createAnimationController();
    this.getControllers().addController(controller);
    if (Game.world().environment() != null && Game.world().environment().isLoaded()) {
      Game.loop().attach(controller);
    }
}
}
```
```java
class de.gurkenlabs.litiengine.graphics.FreeFlightCamera {
public FreeFlightCamera(final Point2D focus) {
    this.setFocus(focus);
    this.velocity = DEFAULT_SCROLL_PIXELS_PER_SECOND;
    this.scrollPadding = DEFAULT_SCROLL_PADDING;
    this.setClampToMap(true);

    Game.loop().attach(this);
}private void handleFreeFlightCamera() {
    if (Game.world().environment() == null || Game.world().environment().getMap() == null) {
      return;
    }

    final Point2D mouseLocation = Input.mouse().getLocation();

    final double scrollSpeed =
        this.getVelocity()
            / (double) Game.loop().getTickRate()
            * Game.config().input().getMouseSensitivity();

    double x = this.getFocus().getX();
    double y = this.getFocus().getY();

    double deltaX = 0;
    if (mouseLocation.getX() < this.getScrollPadding()) {
      deltaX -= scrollSpeed;
    } else if (Game.window().getResolution().getWidth() - mouseLocation.getX()
        < this.getScrollPadding()) {
      deltaX += scrollSpeed;
    }

    double deltaY = 0;
    if (mouseLocation.getY() < this.getScrollPadding()) {
      deltaY -= scrollSpeed;
    } else if (Game.window().getResolution().getHeight() - mouseLocation.getY()
        < this.getScrollPadding()) {
      deltaY += scrollSpeed;
    }

    x += deltaX;
    y += deltaY;

    this.setFocus(new Point2D.Double(x, y));
}
}
```
```java
class de.gurkenlabs.litiengine.environment.Environment {
private static void dispose(final Collection<? extends IEntity> entities) {
    for (final IEntity entity : entities) {
      if (entity instanceof IUpdateable) {
        Game.loop().detach((IUpdateable) entity);
      }

      entity.detachControllers();
    }
}private static void loadUpdatableOrEmitterEntity(IEntity entity) {
    if (entity instanceof Emitter) {
      final Emitter emitter = (Emitter) entity;
      if (emitter.isActivateOnInit()) {
        emitter.activate();
      }
    } else if (entity instanceof IUpdateable) {
      Game.loop().attach((IUpdateable) entity);
    }
}private void unload(final IEntity entity) {
    // 1. remove from physics engine
    if (entity instanceof ICollisionEntity) {
      Game.physics().remove((ICollisionEntity) entity);
    }

    // 2. unregister from update
    if (entity instanceof IUpdateable) {
      Game.loop().detach((IUpdateable) entity);
    }

    if (entity instanceof IMobileEntity) {
      this.removeGravity((IMobileEntity) entity);
    }

    // 3. detach all controllers
    entity.detachControllers();

    if (entity instanceof Emitter) {
      Emitter em = (Emitter) entity;
      em.deactivate();
    }

    if (this.loaded && (entity instanceof LightSource || entity instanceof StaticShadow)) {
      this.updateLighting(entity);
    }

    entity.removed(this);
}
}
```
```java
class de.gurkenlabs.litiengine.graphics.animation.Animation {
@Override
  public void update() {
    // do nothing if the animation is not playing or the current keyframe is not finished
    if (!this.isPlaying()
        || Game.time().since(this.lastFrameUpdate) < this.getCurrentKeyFrame().getDuration()) {
      return;
    }

    // if we are not looping and the last keyframe is finished, we terminate the animation
    if (!this.isLooping() && this.isLastKeyFrame()) {
      this.terminate();
      return;
    }

    // make sure, we stay inside the keyframe list
    final int newFrameIndex =
        (this.getKeyframes().indexOf(this.currentFrame) + 1) % this.getKeyframes().size();
    final KeyFrame previousFrame = this.currentFrame;
    this.currentFrame = this.getKeyframes().get(newFrameIndex);

    for (KeyFrameListener listener : this.listeners) {
      listener.currentFrameChanged(previousFrame, this.currentFrame);
    }

    this.lastFrameUpdate = Game.loop().getTicks();
}public void restart() {
    this.currentFrame = this.firstFrame;
    this.lastFrameUpdate = Game.loop().getTicks();
}
}
```
```java
class de.gurkenlabs.litiengine.physics.MovementController {
@Override
  public void attach() {
    Game.loop().attach(this);
}private void handleForces() {
    // clean up forces
    this.activeForces.forEach(
        x -> {
          if (x.hasEnded()) {
            this.activeForces.remove(x);
          }
        });

    if (this.activeForces.isEmpty()) {
      return;
    }

    // disable turn-on-move for force handling
    boolean turn = this.getEntity().turnOnMove();
    this.getEntity().setTurnOnMove(false);
    try {
      double deltaX = 0;
      double deltaY = 0;
      for (final Force force : this.activeForces) {
        if (force.cancelOnReached() && force.hasReached(this.getEntity())) {
          force.end();
          continue;
        }

        final Point2D collisionBoxCenter = this.getEntity().getCollisionBoxCenter();
        final double angle =
            GeometricUtilities.calcRotationAngleInDegrees(collisionBoxCenter, force.getLocation());
        final double strength =
            Game.loop().getDeltaTime() * 0.001f * force.getStrength() * Game.loop().getTimeScale();
        deltaX += GeometricUtilities.getDeltaX(angle, strength);
        deltaY += GeometricUtilities.getDeltaY(angle, strength);
      }

      final Point2D target =
          new Point2D.Double(this.getEntity().getX() + deltaX, this.getEntity().getY() + deltaY);
      final boolean success = Game.physics().move(this.getEntity(), target);
      if (!success) {
        for (final Force force : this.activeForces) {
          if (force.cancelOnCollision()) {
            force.end();
          }
        }
      }
    } finally {
      this.getEntity().setTurnOnMove(turn);
    }
}@Override
  public void detach() {
    Game.loop().detach(this);
}public void handleMovement() {
    if (!this.isMovementAllowed()) {
      this.velocity = 0;
      return;
    }

    // max distance an entity can travel within one tick
    final double maxPixelsPerTick = this.getEntity().getTickVelocity();
    final double deltaTime = Game.loop().getDeltaTime() * Game.loop().getTimeScale();

    final double acceleration =
        this.getEntity().getAcceleration() == 0
            ? maxPixelsPerTick
            : deltaTime / this.getEntity().getAcceleration() * maxPixelsPerTick;
    final double deceleration =
        this.getEntity().getDeceleration() == 0
            ? this.getVelocity()
            : deltaTime / this.getEntity().getDeceleration() * maxPixelsPerTick;

    double dx = this.getDx();
    double dy = this.getDy();
    this.setDx(0);
    this.setDy(0);

    final double deltaVelocity =
        Math.min(Math.sqrt(Math.pow(dx, 2) + Math.pow(dy, 2)), acceleration);
    if (deltaVelocity != 0) {
      double newVelocity = this.getVelocity() + deltaVelocity;
      this.setVelocity(newVelocity);
    } else {
      final double newVelocity = Math.max(0, this.getVelocity() - deceleration);
      this.setVelocity(newVelocity);
      dx = GeometricUtilities.getDeltaX(this.moveAngle);
      dy = GeometricUtilities.getDeltaY(this.moveAngle);
    }

    if (this.getVelocity() == 0) {
      this.moveAngle = 0;
      return;
    }

    // actually move entity
    this.moveEntity(dx, dy);
}
}
```
```java
class de.gurkenlabs.litiengine.graphics.animation.AnimationController {
public void detach() {
    Game.loop().detach(this);
}public void attach() {
    Game.loop().attach(this);
}
}
```
```java
class de.gurkenlabs.litiengine.graphics.Camera {
@Override
  public void setZoom(final float targetZoom, final int delay) {
    if (delay == 0) {

      this.zoom = targetZoom;
      this.targetZoom = 0;
      this.zoomDelay = 0;
      this.zoomTick = 0;
      this.zoomStep = 0;

      final ZoomChangedEvent event = new ZoomChangedEvent(this, targetZoom);
      for (final ZoomChangedListener listener : this.zoomListeners) {
        listener.zoomChanged(event);
      }
    } else {
      this.zoomTick = Game.time().now();
      this.targetZoom = targetZoom;
      this.zoomDelay = delay;

      final double tickduration = 1000 / (double) Game.loop().getTickRate();
      final double tickAmount = delay / tickduration;
      final float totalDelta = this.targetZoom - this.zoom;
      this.zoomStep = tickAmount > 0 ? (float) (totalDelta / tickAmount) : totalDelta;
    }
}
}
```
```java
class de.gurkenlabs.litiengine.Game {
public static synchronized void init(String... args) {
    if (initialized) {
      log().log(Level.INFO, "The game has already been initialized.");
      return;
    }

    log.init();
    handleCommandLineArguments(args);

    config().load();
    Locale.setDefault(new Locale(config().client().getCountry(), config().client().getLanguage()));

    gameLoop = new GameLoop("Main Update Loop", config().client().getMaxFps());
    loop().attach(physics());
    loop().attach(world());

    // setup default exception handling for render and update loop
    setUncaughtExceptionHandler(
        new DefaultUncaughtExceptionHandler(config().client().exitOnError()));

    screenManager = new ScreenManager();
    gameWindow = new GameWindow();

    // initialize  the game window
    window().init();
    world.setCamera(new Camera());

    for (GameListener listener : gameListeners) {
      listener.initialized(args);
    }

    if (!isInNoGUIMode()) {
      window().getRenderComponent().onRendered(g -> metrics().render(g));

      graphics()
          .addEntityRenderedListener(
              e -> DebugRenderer.renderEntityDebugInfo(e.getGraphics(), e.getEntity()));

      window().getRenderComponent().onFpsChanged(fps -> metrics().setFramesPerSecond(fps));
      window()
          .setIcons(
              Arrays.asList(
                  Resources.images().get("liti-logo-x16.png"),
                  Resources.images().get("liti-logo-x20.png"),
                  Resources.images().get("liti-logo-x32.png"),
                  Resources.images().get("liti-logo-x48.png")));

      Input.keyboard()
          .onKeyTyped(
              KeyEvent.VK_PRINTSCREEN,
              key -> {
                // don't take a screenshot if a modifier is active
                if (key.getModifiers() != 0) {
                  return;
                }

                window().getRenderComponent().takeScreenshot();
              });
    }

    Runtime.getRuntime().addShutdownHook(new Thread(Game::terminate, "Shutdown"));

    initialized = true;
}
}
```
```java
class de.gurkenlabs.litiengine.entities.Creature {
protected void updateAnimationController() {
    IEntityAnimationController<?> controller = this.createAnimationController();
    this.getControllers().addController(controller);
    if (Game.world().environment() != null && Game.world().environment().isLoaded()) {
      Game.loop().attach(controller);
    }
}@Override
  public float getTickVelocity() {
    // pixels per ms multiplied by the passed ms
    // ensure that entities don't travel too far in case of lag
    return Math.min(Game.loop().getDeltaTime(), GameLoop.TICK_DELTATIME_LAG)
        * 0.001F
        * this.getVelocity().get()
        * Game.loop().getTimeScale();
}
}
```
Depth: 2
```java
class de.gurkenlabs.litiengine.environment.GameWorld {
public void clear() {
    this.unloadEnvironment();
    this.environments.clear();
    this.setCamera(null);
    Game.physics().clear();

    this.environmentListeners.clear();
    this.environmentLoadedListeners.clear();
    this.environmentUnloadedListeners.clear();

    this.listeners.clear();
    this.loadedListeners.clear();
    this.unloadedListeners.clear();
}@Nullable
  public Environment loadEnvironment(IMap map) {
    Environment env = this.getEnvironment(map);
    this.loadEnvironment(env);
    return env;
}@Nullable
  public Environment loadEnvironment(String mapName) {
    Environment env = this.getEnvironment(mapName);
    this.loadEnvironment(env);
    return env;
}
}
```
```java
class de.gurkenlabs.litiengine.GameWindow {
GameWindow() {
    this.hostControl = new JFrame();

    this.resolutionChangedListeners = new CopyOnWriteArrayList<>();

    this.renderCanvas = new RenderComponent(Game.config().graphics().getResolution());
    this.cursor = new MouseCursor();
    if (!Game.isInNoGUIMode()) {
      this.hostControl.setBackground(Color.BLACK);
      this.hostControl.add(this.renderCanvas);

      this.initializeEventListeners();

      this.hostControl.setTitle(Game.info().getTitle());
      this.hostControl.setDefaultCloseOperation(WindowConstants.DO_NOTHING_ON_CLOSE);
      initializeWindowEventListeners(this.hostControl);
    }
}
}
```
```java
class de.gurkenlabs.litiengine.GameTime {
public long sinceEnvironmentLoad() {
    return this.since(this.environmentLoaded);
}public long since(final long tick) {
    return toMilliseconds(Game.loop().getTicks() - tick);
}public long sinceGameStart() {
    return this.toMilliseconds(Game.loop().getTicks());
}
}
```
```java
class de.gurkenlabs.litiengine.abilities.effects.Effect {
protected void cease(final EffectApplication appliance) {
    // 1. cease the effect for all affected entities
    for (final ICombatEntity entity : appliance.getAffectedEntities()) {
      this.cease(entity);
    }

    // 2. apply follow up effects
    this.getFollowUpEffects().forEach(followUp -> followUp.apply(appliance.getImpactArea()));
}protected boolean hasEnded(final EffectApplication appliance) {
    final long effectDuration = Game.time().since(appliance.getAppliedTicks());
    return effectDuration > this.getDuration();
}
}
```
```java
class de.gurkenlabs.litiengine.abilities.effects.EffectApplication {
protected EffectApplication(final List<ICombatEntity> affectedEntities, final Shape impactArea) {
    this.applied = Game.time().now();
    this.affectedEntities = affectedEntities;
    this.impactArea = impactArea;
}
}
```
```java
class de.gurkenlabs.litiengine.entities.CombatEntity {
@Override
  public boolean wasHit(int timeSpan) {
    return Game.time().since(this.lastHit) < timeSpan;
}@Override
  public void hit(final int damage, @Nullable final Ability ability) {
    if (this.isDead()) {
      return;
    }

    if (!this.isIndestructible()) {
      this.getHitPoints().modifyBaseValue(new AttributeModifier<>(Modification.SUBTRACT, damage));
    }

    final EntityHitEvent event = new EntityHitEvent(this, ability, damage, this.isDead());

    for (final CombatEntityListener listener : this.listeners) {
      listener.hit(event);
    }

    for (final CombatEntityHitListener listener : this.hitListeners) {
      listener.hit(event);
    }

    if (this.isDead()) {
      this.fireDeathEvent();
      this.setCollision(false);
    }

    this.lastHit = Game.time().now();
}
}
```
```java
class de.gurkenlabs.litiengine.graphics.ImageEffect {
protected ImageEffect(final int ttl, final String name) {
    this.ttl = ttl;
    this.name = name;
    this.aliveTick = Game.time().now();
}@Override
  public long getAliveTime() {
    return Game.time().since(this.aliveTick);
}
}
```
```java
class de.gurkenlabs.litiengine.abilities.AbilityExecution {
AbilityExecution(final Ability ability) {
    this.appliedEffects = new CopyOnWriteArrayList<>();
    this.ability = ability;
    this.executionTicks = Game.time().now();
    this.impactArea = ability.calculateImpactArea();
    this.castLocation = ability.getExecutor().getCenter();
    Game.loop().attach(this);
}@Override
  public void update() {
    // if there a no effects to apply -> unregister this instance and we're done
    if (this.getAbility().getEffects().isEmpty()
        || this.getAbility().getEffects().size() == this.getAppliedEffects().size()) {
      Game.loop().detach(this);
      return;
    }

    // handle all effects from the ability that were not applied yet
    for (final Effect effect : this.getAbility().getEffects()) {
      // if the ability was not executed yet or the delay of the effect is not
      // yet reached
      if (this.getAppliedEffects().contains(effect)
          || Game.time().since(this.getExecutionTicks()) < effect.getDelay()) {
        continue;
      }

      effect.apply(this.getExecutionImpactArea());
      this.getAppliedEffects().add(effect);
    }
}
}
```
```java
class de.gurkenlabs.litiengine.tweening.TweenEngine {
@Override
  public void update() {
    for (final Tweenable target : this.getTweens().keySet()) {
      for (final Tween tween : this.getTweens().get(target).values()) {
        if (tween.hasStopped()) {
          continue;
        }
        final long elapsed = Game.time().since(tween.getStartTime());
        if (elapsed >= tween.getDuration()) {
          tween.stop();
          continue;
        }
        final float[] currentValues = new float[tween.getTargetValues().length];
        for (int i = 0; i < tween.getTargetValues().length; i++) {
          currentValues[i] =
              tween.getStartValues()[i]
                  + tween.getEquation().compute(elapsed / (float) tween.getDuration())
                      * (tween.getTargetValues()[i] - tween.getStartValues()[i]);
        }
        tween.getTarget().setTweenValues(tween.getType(), currentValues);
      }
    }
}
}
```
```java
class de.gurkenlabs.litiengine.gui.SpeechBubble {
public static SpeechBubble create(
      final IEntity entity, final String text, SpeechBubbleAppearance appearance, Font font) {
    return new SpeechBubble(entity, text, appearance, font);
}public static SpeechBubble create(final IEntity entity, final Font font, final String text) {
    SpeechBubbleAppearance app =
        new SpeechBubbleAppearance(
            DEFAULT_APPEARANCE.getForeColor(),
            DEFAULT_APPEARANCE.getBackgroundColor1(),
            DEFAULT_APPEARANCE.getBorderColor(),
            DEFAULT_APPEARANCE.getPadding());
    return new SpeechBubble(entity, text, app, font);
}public static SpeechBubble create(final IEntity entity, final String text) {
    return new SpeechBubble(entity, text, null, GuiProperties.getDefaultFont());
}@Override
  public void update() {
    if (this.currentText == null) {
      this.hide();
      return;
    }

    this.entityCenter = Game.world().camera().getViewportLocation(this.getEntity().getCenter());

    // old text was displayed long enough
    if (this.lastTextDisplay != 0
        && Game.time().since(this.lastTextDisplay) > this.currentTextDisplayTime) {
      this.currentText = null;
      this.lastTextDisplay = 0;
      return;
    }

    // display new text
    if (this.textIndex < this.currentText.length()
        && Game.time().since(this.lastCharPoll) > LETTER_WRITE_DELAY) {
      this.textIndex++;
      this.lastCharPoll = Game.time().now();
      if (this.typeSound != null) {
        Game.audio().playSound(this.typeSound, this.getEntity());
      }
    }

    // continue displaying currently displayed text
}private SpeechBubble(
      final IEntity entity,
      final String text,
      final Sound typeSound,
      SpeechBubbleAppearance appearance,
      Font font) {
    this(entity, text, appearance, font);
    this.typeSound = typeSound;
}private SpeechBubble(
      final IEntity entity,
      final String text,
      @Nullable SpeechBubbleAppearance appearance,
      @Nullable Font font) {
    if (appearance == null) {
      this.appearance = DEFAULT_APPEARANCE;
    } else {
      this.appearance = appearance;
    }

    final SpeechBubble active = activeSpeechBubbles.get(entity);
    if (active != null) {
      active.hide();
    }
    this.setFont(font);

    this.textBoxWidth = (float) (entity.getWidth() * 4);
    this.entity = entity;

    this.currentText = text;
    this.currentTextDisplayTime = DISPLAYTIME_MIN + text.length() * DISPLAYTIME_PER_LETTER;

    this.lastTextDisplay = Game.time().now();
    this.createBubbleImage();
    entity.getEnvironment().add(this, RenderType.UI);
    Game.loop().attach(this);
    activeSpeechBubbles.put(entity, this);
}
}
```
```java
class de.gurkenlabs.litiengine.gui.TextFieldComponent {
@Override
  public void render(final Graphics2D g) {
    super.render(g);
    g.setFont(this.getFont());
    final FontMetrics fm = g.getFontMetrics();

    if (this.isSelected() && Game.time().since(this.lastToggled) > this.flickerDelay) {
      this.cursorVisible = !this.cursorVisible;
      this.lastToggled = Game.time().now();
    }
    if (this.isSelected() && this.cursorVisible) {
      final Rectangle2D cursor =
          new Rectangle2D.Double(
              this.getX() + this.getTextX() + fm.stringWidth(this.getTextToRender(g)),
              this.getY() + this.getTextY(),
              this.getFont().getSize2D() * 3 / 5,
              this.getFont().getSize2D() * 1 / 5);
      g.setColor(this.getAppearance().getForeColor());
      g.fill(cursor);
    }
}
}
```
```java
class de.gurkenlabs.litiengine.entities.Prop {
public Prop(
      final Point2D location, @Nullable final String spritesheetName, final Material material) {
    super();
    this.rotation = Rotation.NONE;
    this.spritesheetName = spritesheetName;
    this.material = material;
    this.setLocation(location);
    this.updateAnimationController();
}public void setSpritesheetName(@Nullable final String spriteName) {
    this.spritesheetName = spriteName;
    this.updateAnimationController();
}
}
```
```java
class de.gurkenlabs.litiengine.tweening.Tween {
public Tween begin() {
    this.started = Game.time().now();
    this.stopped = false;
    return this;
}
}
```
```java
class de.gurkenlabs.litiengine.graphics.emitters.particles.Particle {
public void update(final Point2D emitterOrigin, final float updateRatio) {
    if (this.aliveTick == 0) {
      this.aliveTick = Game.time().now();
    }

    this.aliveTime = Game.time().since(this.aliveTick);
    if (this.timeToLiveReached()) {
      return;
    }

    if (this.colliding) {
      return;
    }

    if (this.getDeltaWidth() != 0) {
      this.width += this.getDeltaWidth() * updateRatio;
    }

    if (this.getDeltaHeight() != 0) {
      this.height += this.getDeltaHeight() * updateRatio;
    }

    if (this.getDeltaAngle() != 0) {
      this.angle += this.getDeltaAngle() * updateRatio;
    }

    // test for ray cast collision
    final float targetX = this.x + this.getVelocityX() * updateRatio;
    final float targetY = this.y + this.getVelocityY() * updateRatio;

    if (targetX == this.x && targetY == this.y) {
      return;
    }

    if (this.checkForCollision(emitterOrigin, targetX, targetY)) {
      return;
    }

    if (this.getVelocityX() != 0) {
      this.x = targetX;
    }

    if (this.getVelocityY() != 0) {
      this.y = targetY;
    }

    if (this.getAccelerationX() != 0) {
      this.velocityX += this.getAccelerationX() * updateRatio;
    }

    if (this.getAccelerationY() != 0) {
      this.velocityY += this.getAccelerationY() * updateRatio;
    }
}
}
```
```java
class de.gurkenlabs.litiengine.graphics.animation.Animation {
@Override
  public void start() {
    this.playing = true;
    if (this.getKeyframes().isEmpty()) {
      return;
    }

    this.restart();
}@Override
  public void update() {
    // do nothing if the animation is not playing or the current keyframe is not finished
    if (!this.isPlaying()
        || Game.time().since(this.lastFrameUpdate) < this.getCurrentKeyFrame().getDuration()) {
      return;
    }

    // if we are not looping and the last keyframe is finished, we terminate the animation
    if (!this.isLooping() && this.isLastKeyFrame()) {
      this.terminate();
      return;
    }

    // make sure, we stay inside the keyframe list
    final int newFrameIndex =
        (this.getKeyframes().indexOf(this.currentFrame) + 1) % this.getKeyframes().size();
    final KeyFrame previousFrame = this.currentFrame;
    this.currentFrame = this.getKeyframes().get(newFrameIndex);

    for (KeyFrameListener listener : this.listeners) {
      listener.currentFrameChanged(previousFrame, this.currentFrame);
    }

    this.lastFrameUpdate = Game.loop().getTicks();
}
}
```
```java
class de.gurkenlabs.litiengine.graphics.animation.AnimationController {
@Override
  public void update() {
    for (final Animation animation : this.getAll()) {
      animation.update();
    }

    if (this.getCurrent() != null && this.getCurrent().isPaused()) {
      return;
    }

    final boolean playbackFinished = this.getCurrent() != null && !this.getCurrent().isPlaying();
    if (playbackFinished) {
      for (final AnimationListener listener : this.listeners) {
        listener.finished(this.getCurrent());
      }
    }

    if (this.getCurrent() == null || playbackFinished) {
      if (this.getDefault() != null) {
        this.play(this.getDefault().getName());
      } else {
        this.currentAnimation = null;
      }
    }
}
}
```
```java
class de.gurkenlabs.litiengine.graphics.RenderComponent {
private void handleFade() {
    if (this.fadeOutStart != -1) {
      final long timePassed = Game.time().since(this.fadeOutStart);
      this.currentAlpha = MathUtilities.clamp(1 - timePassed / (float) this.fadeOutTime, 0, 1);
      if (this.currentAlpha == 0f) {
        this.fadeOutStart = -1;
        this.fadeOutTime = -1;
      }

      return;
    }

    if (this.fadeInStart != -1) {
      final long timePassed = Game.time().since(this.fadeInStart);
      this.currentAlpha = MathUtilities.clamp(timePassed / (float) this.fadeInTime, 0, 1);
      if (this.currentAlpha == 1f) {
        this.fadeInStart = -1;
        this.fadeInTime = -1;
        this.currentAlpha = Float.NaN;
      }
    }
}public void fadeOut(final int ms) {
    this.fadeInStart = -1;
    this.fadeInTime = -1;
    this.fadeOutStart = Game.time().now();
    this.fadeOutTime = ms;
}public void fadeIn(final int ms) {
    this.fadeOutStart = -1;
    this.fadeOutTime = -1;
    this.fadeInStart = Game.time().now();
    this.fadeInTime = ms;
}
}
```
```java
class de.gurkenlabs.litiengine.entities.Trigger {
private boolean activate(final IEntity activator, final int tar) {
    if (!this.isLoaded()
        || this.isOneTimeTrigger && this.isActivated
        || this.getActivationType() == TriggerActivation.COLLISION
            && activator != null
            && this.collisionActivated.contains(activator)) {
      return false;
    }

    if (this.getCooldown() > 0 && Game.time().since(this.lastActivation) < this.getCooldown()) {
      return false;
    }

    List<Integer> triggerTargets = this.getTargets(tar);

    final TriggerEvent te = new TriggerEvent(this, activator, triggerTargets);

    if (!this.checkActivationPredicates(te)) {
      return false;
    }

    this.isActivated = true;
    if (activator != null) {
      this.collisionActivated.add(activator);
    }

    // if we actually have a trigger target, we send the message to the target
    for (final int target : triggerTargets) {
      final IEntity entity = this.getEnvironment().get(target);
      if (entity == null) {
        log.log(
            Level.WARNING,
            "trigger [{0}] was activated, but the trigger target [{1}] could not be found on the environment",
            new Object[] {this, target});
        continue;
      }

      entity.sendMessage(this, this.message);
    }

    // also send the trigger event to all registered consumers
    for (final TriggerActivatedListener listener : this.activatedListeners) {
      listener.activated(te);
    }

    if (this.isOneTimeTrigger) {
      this.getEnvironment().remove(this);
    }

    this.lastActivation = Game.time().now();
    return true;
}
}
```
```java
class de.gurkenlabs.litiengine.graphics.Camera {
private boolean isShakeEffectActive() {
    return this.getShakeTick() != 0
        && Game.time().since(this.getShakeTick()) < this.getShakeDuration();
}@Override
  public void update() {
    if (Game.world().camera() != null && !Game.world().camera().equals(this)) {
      return;
    }

    if (this.targetZoom > 0) {
      if (Game.time().since(this.zoomTick) >= this.zoomDelay) {
        this.zoom = this.targetZoom;
        this.targetZoom = 0;
        this.zoomDelay = 0;
        this.zoomTick = 0;
        this.zoomStep = 0;
      } else {
        this.zoom += this.zoomStep;
      }

      final ZoomChangedEvent event = new ZoomChangedEvent(this, this.getZoom());
      for (final ZoomChangedListener listener : this.zoomListeners) {
        listener.zoomChanged(event);
      }
    }

    if (this.panTime > 0) {
      if (--this.panTime <= 0) {
        this.setFocus(this.targetFocus);
        this.targetFocus = null;
      } else {
        double diff = this.panTime / (this.panTime + 1.0);
        this.focus =
            new Point2D.Double(
                this.focus.getX() * diff + this.targetFocus.getX() * (1.0 - diff),
                this.focus.getY() * diff + this.targetFocus.getY() * (1.0 - diff));
      }
    }

    if (!this.isShakeEffectActive()) {
      this.shakeOffsetX = 0;
      this.shakeOffsetY = 0;
      return;
    }

    if (Game.time().since(this.lastShake) > this.shakeDelay) {
      this.shakeOffsetX = this.getShakeIntensity() * ThreadLocalRandom.current().nextGaussian();
      this.shakeOffsetY = this.getShakeIntensity() * ThreadLocalRandom.current().nextGaussian();
      this.lastShake = Game.time().now();
    }
}@Override
  public void setZoom(final float targetZoom, final int delay) {
    if (delay == 0) {

      this.zoom = targetZoom;
      this.targetZoom = 0;
      this.zoomDelay = 0;
      this.zoomTick = 0;
      this.zoomStep = 0;

      final ZoomChangedEvent event = new ZoomChangedEvent(this, targetZoom);
      for (final ZoomChangedListener listener : this.zoomListeners) {
        listener.zoomChanged(event);
      }
    } else {
      this.zoomTick = Game.time().now();
      this.targetZoom = targetZoom;
      this.zoomDelay = delay;

      final double tickduration = 1000 / (double) Game.loop().getTickRate();
      final double tickAmount = delay / tickduration;
      final float totalDelta = this.targetZoom - this.zoom;
      this.zoomStep = tickAmount > 0 ? (float) (totalDelta / tickAmount) : totalDelta;
    }
}@Override
  public void shake(final double intensity, final int delay, final int shakeDuration) {
    this.shakeTick = Game.time().now();
    this.shakeDelay = delay;
    this.shakeIntensity = intensity;
    this.shakeDuration = shakeDuration;
}
}
```
```java
class de.gurkenlabs.litiengine.entities.Creature {
public void setSpritesheetName(String spritesheetName) {
    if (this.spritesheetName != null && this.spritesheetName.equals(spritesheetName)) {
      return;
    }

    this.spritesheetName = spritesheetName;
    this.updateAnimationController();
}public boolean isIdle() {
    return Game.time().since(this.lastMoved) > IDLE_DELAY;
}@Override
  public void setLocation(final Point2D position) {
    if (this.isDead() || position == null) {
      return;
    }

    final Point2D oldLocation = this.getLocation();
    super.setLocation(position);

    if (Game.hasStarted() && this.isLoaded()) {
      this.lastMoved = Game.time().now();
      this.fireMovedEvent(
          new EntityMovedEvent(
              this, this.getX() - oldLocation.getX(), this.getY() - oldLocation.getY()));
    }
}
}
```
```java
class de.gurkenlabs.litiengine.gui.screens.ScreenManager {
public void display(final String screenName) {
    if (this.current() != null && this.current().getName().equalsIgnoreCase(screenName)) {
      log.log(
          Level.INFO,
          "Skipping displaying of screen {0} because it is already the current screen.",
          screenName);
      return;
    }

    if (this.screens.stream()
        .noneMatch(element -> element.getName().equalsIgnoreCase(screenName))) {
      log.log(
          Level.WARNING,
          "Could not display the screen {0} because there is no screen with the specified name.",
          screenName);
      return;
    }

    Screen screen = this.get(screenName);
    if (screen == null) {
      return;
    }

    this.display(screen);
}public void add(final Screen screen) {
    screen.setWidth(Game.window().getWidth());
    screen.setHeight(Game.window().getHeight());
    this.screens.add(screen);

    if (this.current() == null) {
      this.display(screen);
    }
}public void remove(Screen screen) {
    this.screens.remove(screen);
    if (this.current() == screen) {
      if (!this.screens.isEmpty()) {
        this.display(this.screens.get(0));
      } else {
        this.display((Screen) null);
      }
    }
}public void display(@Nullable final Screen screen) {
    if (Game.hasStarted() && Game.time().since(this.lastScreenChange) < this.getChangeCooldown()) {
      log.log(
          Level.INFO,
          "Skipping displaying of screen {0} because screen changing is currently on cooldown.",
          screen != null ? screen.getName() : "");
      return;
    }

    final Screen previous = this.current();
    if (previous != null) {
      previous.suspend();
    }

    if (screen != null && !this.screens.contains(screen)) {
      this.screens.add(screen);
    }

    this.currentScreen = screen;
    if (!Game.isInNoGUIMode() && this.current() != null) {
      this.current().prepare();
    }

    this.lastScreenChange = Game.loop().getTicks();

    final ScreenChangedEvent event = new ScreenChangedEvent(this.current(), previous);
    for (final ScreenChangedListener listener : this.screenChangedListeners) {
      listener.changed(event);
    }
}
}
```
```java
class de.gurkenlabs.litiengine.abilities.Ability {
public boolean isOnCooldown() {
    return (this.getCurrentExecution() != null
        && this.getCurrentExecution().getExecutionTicks() > 0
        && Game.time().since(this.getCurrentExecution().getExecutionTicks())
            < this.getAttributes().cooldown().get());
}public boolean isActive() {
    return this.getCurrentExecution() != null
        && Game.time().since(this.getCurrentExecution().getExecutionTicks())
            < this.getAttributes().duration().get();
}@Nullable
  public AbilityExecution cast() {
    if (!this.canCast()) {
      return null;
    }
    this.currentExecution = new AbilityExecution(this);

    for (final AbilityCastListener listener : this.abilityCastListeners) {
      listener.abilityCast(this.currentExecution);
    }

    return this.getCurrentExecution();
}public float getRemainingCooldownInSeconds() {
    if (this.getCurrentExecution() == null
        || this.getExecutor() == null
        || this.getExecutor().isDead()) {
      return 0;
    }

    // calculate cooldown in seconds
    return (float)
        (!this.canCast()
            ? (this.getAttributes().cooldown().get()
                    - Game.time().since(this.getCurrentExecution().getExecutionTicks()))
                * 0.001
            : 0);
}
}
```
```java
class de.gurkenlabs.litiengine.entities.EntityHitEvent {
EntityHitEvent(
      final ICombatEntity hitEntity,
      @Nullable final Ability ability,
      final int damage,
      final boolean kill) {
    super(hitEntity);
    this.executor = ability != null ? ability.getExecutor() : null;
    this.hitEntity = hitEntity;
    this.ability = ability;
    this.damage = damage;
    this.kill = kill;
    this.time = Game.time().now();
}
}
```
```java
class de.gurkenlabs.litiengine.graphics.emitters.Emitter {
public void delete() {
    this.deactivate();
    if (Game.world().environment() != null) {
      Game.world().environment().remove(this);
    }
}public void activate() {
    if (this.activated) {
      return;
    }

    this.activated = true;
    this.activationTick = Game.time().now();
    Game.loop().attach(this);
}@Override
  public void update() {
    if (this.isPaused()) {
      return;
    }

    // clear particles if the effect time to life is reached
    if (this.isFinished()) {
      for (EmitterFinishedListener listener : this.finishedListeners) {
        listener.finished(this);
      }

      this.delete();
      return;
    }

    final float updateRatio = (float) this.data().getUpdateRate() / Game.loop().getTickRate();
    for (final Particle p : this.getParticles().stream().collect(Collectors.toList())) {
      if (this.particleCanBeRemoved(p)) {
        // remove dead particles
        this.particles.remove(p);
        continue;
      }

      p.update(this.getOrigin(), updateRatio);
    }

    this.aliveTime = Game.time().since(this.activationTick);
    if ((this.data().getSpawnRate() == 0
        || Game.time().since(this.lastSpawn) >= this.data().getSpawnRate())) {
      this.lastSpawn = Game.time().now();
      this.spawnParticle();
    }
}
}
```
```java
class de.gurkenlabs.litiengine.GameLoop {
@Override
  public int perform(int delay, Runnable action) {
    final long d = Game.time().toTicks(delay);

    TimedAction a = new TimedAction(this.getTicks() + d, action);
    this.actions.add(a);

    return a.getId();
}
}
```
```java
class de.gurkenlabs.litiengine.environment.EntitySpawner {
protected boolean shouldSpawn() {
    return this.lastSpawnWave == 0
        || Game.time().since(this.lastSpawnWave) >= this.getSpawnInterval();
}@Override
  public void update() {
    if (!this.shouldSpawn()) {
      return;
    }

    this.spawnNewEntities();
    this.lastSpawnWave = Game.time().now();
}
}
```
```java
class de.gurkenlabs.litiengine.graphics.FreeFlightCamera {
@Override
  public void update() {
    this.handleFreeFlightCamera();
}public FreeFlightCamera(double x, double y) {
    this(new Point2D.Double(x, y));
}
}
```
```java
class de.gurkenlabs.litiengine.environment.Environment {
public void unload() {
    if (!this.loaded) {
      return;
    }

    // unregister all updatable entities from the current environment
    for (final IEntity entity : this.allEntities.values()) {
      this.unload(entity);
    }

    this.loaded = false;
    this.fireEvent(l -> l.unloaded(this));
}private static void loadUpdatableOrEmitterEntity(IEntity entity) {
    if (entity instanceof Emitter) {
      final Emitter emitter = (Emitter) entity;
      if (emitter.isActivateOnInit()) {
        emitter.activate();
      }
    } else if (entity instanceof IUpdateable) {
      Game.loop().attach((IUpdateable) entity);
    }
}public void clear() {
    Game.physics().clear();

    this.combatEntities.clear();
    this.mobileEntities.clear();
    this.gravityForces.clear();
    this.layerEntities.clear();
    this.entitiesByTag.clear();
    this.allEntities.clear();

    for (RenderType renderType : RenderType.values()) {
      this.miscEntities.get(renderType).clear();
      this.renderListeners.get(renderType).clear();
      this.renderables.get(renderType).clear();
    }

    dispose(this.allEntities.values());
    dispose(this.triggers);
    this.emitters.clear();
    this.colliders.clear();
    this.props.clear();
    this.creatures.clear();
    this.staticShadows.clear();
    this.combatEntities.clear();
    this.mobileEntities.clear();
    this.lightSources.clear();
    this.spawnPoints.clear();
    this.soundSources.clear();
    this.mapAreas.clear();
    this.triggers.clear();

    this.ambientLight = null;
    this.staticShadowLayer = null;

    for (Map<Integer, IEntity> type : this.miscEntities.values()) {
      type.clear();
    }

    this.initialized = false;

    this.fireEvent(l -> l.cleared(this));
}private void load(final IEntity entity) {
    // an entity can only exist on one environment at a time, so remove it from the current one
    if (entity.getEnvironment() != null) {
      entity.getEnvironment().remove(entity);
    }

    // 1. add to physics engine
    loadPhysicsEntity(entity);

    // 2. register for update or activate
    loadUpdatableOrEmitterEntity(entity);

    // 3. if a gravity is defined, add a gravity force to the entity
    if (entity instanceof IMobileEntity && this.getGravity() != 0) {
      this.addGravityForce((IMobileEntity) entity);
    }

    // 4. attach all controllers
    entity.attachControllers();

    if (this.loaded && (entity instanceof LightSource || entity instanceof StaticShadow)) {
      this.updateLighting(entity);
    }

    entity.loaded(this);
}private void unload(final IEntity entity) {
    // 1. remove from physics engine
    if (entity instanceof ICollisionEntity) {
      Game.physics().remove((ICollisionEntity) entity);
    }

    // 2. unregister from update
    if (entity instanceof IUpdateable) {
      Game.loop().detach((IUpdateable) entity);
    }

    if (entity instanceof IMobileEntity) {
      this.removeGravity((IMobileEntity) entity);
    }

    // 3. detach all controllers
    entity.detachControllers();

    if (entity instanceof Emitter) {
      Emitter em = (Emitter) entity;
      em.deactivate();
    }

    if (this.loaded && (entity instanceof LightSource || entity instanceof StaticShadow)) {
      this.updateLighting(entity);
    }

    entity.removed(this);
}public void remove(final IEntity entity) {
    if (entity == null) {
      return;
    }

    this.allEntities.remove(entity.getMapId());
    Iterator<List<IEntity>> iter = this.layerEntities.values().iterator();
    while (iter.hasNext()) {
      List<IEntity> layer = iter.next();
      if (layer.remove(entity) && layer.isEmpty()) {
        iter.remove();
      }
    }
    if (this.miscEntities.get(entity.getRenderType()) != null) {
      this.miscEntities.get(entity.getRenderType()).values().remove(entity);
    }

    for (String tag : entity.getTags()) {
      if (this.getEntitiesByTag().containsKey(tag)) {
        this.getEntitiesByTag().get(tag).remove(entity);

        if (this.getEntitiesByTag().get(tag).isEmpty()) {
          this.getEntitiesByTag().remove(tag);
        }
      }
    }

    if (entity instanceof Emitter) {
      Emitter emitter = (Emitter) entity;
      this.removeEmitter(emitter);
    }

    if (entity instanceof MapArea) {
      this.mapAreas.remove(entity);
    }

    if (entity instanceof Prop) {
      this.props.remove(entity);
    }

    if (entity instanceof Creature) {
      this.creatures.remove(entity);
    }

    if (entity instanceof CollisionBox) {
      this.colliders.remove(entity);
      this.staticShadows.removeIf(x -> x.getOrigin() != null && x.getOrigin().equals(entity));
    }

    if (entity instanceof LightSource) {
      this.lightSources.remove(entity);
      this.updateLighting(entity);
    }

    if (entity instanceof Trigger) {
      this.triggers.remove(entity);
    }

    if (entity instanceof Spawnpoint) {
      this.spawnPoints.remove(entity);
    }
    if (entity instanceof SoundSource) {
      this.soundSources.remove(entity);
    }

    if (entity instanceof StaticShadow) {
      this.staticShadows.remove(entity);
      this.updateLighting(entity);
    }

    if (entity instanceof IMobileEntity) {
      this.mobileEntities.values().remove(entity);
    }

    if (entity instanceof ICombatEntity) {
      this.combatEntities.values().remove(entity);
    }

    this.unload(entity);

    this.fireEntityEvent(l -> l.entityRemoved(entity));
}
}
```
```java
class de.gurkenlabs.litiengine.physics.MovementController {
@Override
  public void update() {
    this.handleForces();
    this.handleMovement();
}
}
```
```java
class de.gurkenlabs.litiengine.Game {
static synchronized void terminate() {
    if (!initialized) {
      return;
    }

    hasStarted = false;
    initialized = false;

    config().save();
    gameLoop.terminate();
    tweenEngine.terminate();
    soundEngine.terminate();

    world().clear();

    for (final GameListener listener : gameListeners) {
      try {
        listener.terminated();
      } catch (Exception e) {
        log().log(Level.WARNING, "game listener threw an exception during shutdown", e);
      }
    }

    gameLoop = null;
    screenManager = null;
    gameWindow = null;
}public static synchronized void start() {
    if (!initialized) {
      throw new IllegalStateException(
          "The game cannot be started without being first initialized. Call Game.init(...) before Game.start().");
    }

    gameLoop.start();
    tweenEngine.start();
    soundEngine.start();

    for (final GameListener listener : gameListeners) {
      listener.started();
    }

    hasStarted = true;
}public static synchronized void init(String... args) {
    if (initialized) {
      log().log(Level.INFO, "The game has already been initialized.");
      return;
    }

    log.init();
    handleCommandLineArguments(args);

    config().load();
    Locale.setDefault(new Locale(config().client().getCountry(), config().client().getLanguage()));

    gameLoop = new GameLoop("Main Update Loop", config().client().getMaxFps());
    loop().attach(physics());
    loop().attach(world());

    // setup default exception handling for render and update loop
    setUncaughtExceptionHandler(
        new DefaultUncaughtExceptionHandler(config().client().exitOnError()));

    screenManager = new ScreenManager();
    gameWindow = new GameWindow();

    // initialize  the game window
    window().init();
    world.setCamera(new Camera());

    for (GameListener listener : gameListeners) {
      listener.initialized(args);
    }

    if (!isInNoGUIMode()) {
      window().getRenderComponent().onRendered(g -> metrics().render(g));

      graphics()
          .addEntityRenderedListener(
              e -> DebugRenderer.renderEntityDebugInfo(e.getGraphics(), e.getEntity()));

      window().getRenderComponent().onFpsChanged(fps -> metrics().setFramesPerSecond(fps));
      window()
          .setIcons(
              Arrays.asList(
                  Resources.images().get("liti-logo-x16.png"),
                  Resources.images().get("liti-logo-x20.png"),
                  Resources.images().get("liti-logo-x32.png"),
                  Resources.images().get("liti-logo-x48.png")));

      Input.keyboard()
          .onKeyTyped(
              KeyEvent.VK_PRINTSCREEN,
              key -> {
                // don't take a screenshot if a modifier is active
                if (key.getModifiers() != 0) {
                  return;
                }

                window().getRenderComponent().takeScreenshot();
              });
    }

    Runtime.getRuntime().addShutdownHook(new Thread(Game::terminate, "Shutdown"));

    initialized = true;
}
}
```


Response Format:
Provide the answer in **XML format** as follows:

#### If the method **cannot** return `null` at the specific call site:
```xml
<response>
  <reason><![CDATA[EXPLAIN WHY THE INVOCATION Game.loop() RESULT CANNOT BE NULL.]]></reason>
  <value>NO</value>
</response>

#### If the method can return null at the specific call site:
<response>
  <reason><![CDATA[EXPLAIN WHY THE INVOCATION Game.loop() RESULT CAN BE NULL.]]></reason>
  <value>YES</value>
</response>

#### If you are unsure or If there are any methods that directly or indirectly affect the return value and are not fully disclosed, request their declarations first, in the following format:
<response>
  <reason><![CDATA[EXPLAIN WHY THIS METHOD DECLARATION IS NECESSARY AND WHY YOU CANNOT MAKE A CONFIDENT DECISION WITHOUT IT]]></reason>
  <success>false</success>
  <methods>
    <method>methodName</method>
  </methods>
</response>

Additional Notes:
Be precise in your reasoning.
If a method’s return value depends on another method not provided, request its declaration before making a conclusion.
If the method can return null in this case but not in others, explain why it happens specifically for this call.

---ChatGPT.sendRequestToOpenAI---
Retrieving response from cache
---Response.<init>---
Creating Response:
```xml
<response>
  <reason><![CDATA[The method `Game.loop()` returns the static field `gameLoop`, which is initialized in the `Game.init(String... args)` method. In this method, a new `GameLoop` object is instantiated and assigned to `gameLoop`. Since `init()` must be called before `start()`, which is implied by the requirement of initializing the game, the `gameLoop` is guaranteed to be non-null during the lifetime of the game execution where `Game.loop()` is called. The absence of any code that could set `gameLoop` to null after its initialization ensures that `Game.loop()` cannot return null.]]></reason>
  <value>NO</value>
</response>
```
---Response.<init>---
Response created:
Disagreement: The method `Game.loop()` returns the static field `gameLoop`, which is initialized in the `Game.init(String... args)` method. In this method, a new `GameLoop` object is instantiated and assigned to `gameLoop`. Since `init()` must be called before `start()`, which is implied by the requirement of initializing the game, the `gameLoop` is guaranteed to be non-null during the lifetime of the game execution where `Game.loop()` is called. The absence of any code that could set `gameLoop` to null after its initialization ensures that `Game.loop()` cannot return null.
---AdvancedNullAwayCodeFix.resolveMethodDereferenceError---
Method is not returning nullable on call site. Injecting suppression annotation.
---AdvancedNullAwayCodeFix.constructCastToNonnullChange---
Constructing cast to nonnull change for reason: The method `Game.loop()` returns the static field `gameLoop`, which is initialized in the `Game.init(String... args)` method. In this method, a new `GameLoop` object is instantiated and assigned to `gameLoop`. Since `init()` must be called before `start()`, which is implied by the requirement of initializing the game, the `gameLoop` is guaranteed to be non-null during the lifetime of the game execution where `Game.loop()` is called. The absence of any code that could set `gameLoop` to null after its initialization ensures that `Game.loop()` cannot return null.
---ChatGPT.ask---
Asking ChatGPT:
For the reason you mentioned earlier:

"The method `Game.loop()` returns the static field `gameLoop`, which is initialized in the `Game.init(String... args)` method. In this method, a new `GameLoop` object is instantiated and assigned to `gameLoop`. Since `init()` must be called before `start()`, which is implied by the requirement of initializing the game, the `gameLoop` is guaranteed to be non-null during the lifetime of the game execution where `Game.loop()` is called. The absence of any code that could set `gameLoop` to null after its initialization ensures that `Game.loop()` cannot return null."

in the method below, the expression Game.loop() is not nullable at the point it is used.

```java
public void restart() {
    this.currentFrame = this.firstFrame;
    this.lastFrameUpdate = Game.loop().getTicks();
}
```
Please Summarize the reason in max 5 words and rewrite the method so that at the line "    this.lastFrameUpdate = Game.loop().getTicks();", at the occurrence of: "Game.loop()" is replaced with `NullabilityUtil.castToNonnull(Game.loop(), summary of reason)`
Replace "REASON" with the exact reason summary I provide to you (maximum 5 words), not with a generic explanation like "checked to be nonnull".
see the example below, for expression `foo.getBar()`, to wrap it with `NullabilityUtil.castToNonnull(foo.getBar(), "reason")`.

```java
public t(){
    String l = foo.getBar();
}
```

will be:
```java
public t(){
    String l = NullabilityUtil.castToNonnull(foo.getBar(), "checked to be nonnull");
}
```

### Instructions:

Do not import any additional classes.

Do not add Java comments.

Only modify relevant lines as required.

Return only the modified method wrapped in the XML format shown below.

Place the Java code inside the <code> tag using a CDATA block with ```java formatting.

Just give me the fixed code snippet in XML format in <response> tag like the example below. I will apply the fix to my codebase. Do not import any additional libraries or classes or add java comments. If you can provide the fixed code snippet, please provide it in the following format and place the code snippet in the <code> tag within ```java block.
<response>
  <success>true</success>
  <code><![CDATA[
  ```java
  Your fixed code snippet here
  ```
    ]]>
  </code>
</response>

---ChatGPT.sendRequestToOpenAI---
Sending request to OpenAI...
---ChatGPT.sendRequestToOpenAI---
Response received from OpenAI.
---Response.<init>---
Creating Response:
<response>
  <success>true</success>
  <code><![CDATA[
  ```java
public void restart() {
    this.currentFrame = this.firstFrame;
    this.lastFrameUpdate = NullabilityUtil.castToNonnull(Game.loop(), "non-null initialization").getTicks();
}
  ```
  ]]>
  </code>
</response>
---Response.<init>---
Response created:
public void restart() {
    this.currentFrame = this.firstFrame;
    this.lastFrameUpdate = NullabilityUtil.castToNonnull(Game.loop(), "non-null initialization").getTicks();
}
---ChatGPT.fixDereferenceByAddingCastToNonnull---
Fixing the error by adding castToNonnull
---AdvancedNullAwayCodeFix.fixTriggeredErrorsForLocation---
Resolving unresolvable error for triggered error: Type='DEREFERENCE_NULLABLE', message='dereferenced expression Game.loop() is @Nullable'
/home/nima/Developer/nullness-benchmarks/litiengine/src/de/gurkenlabs/litiengine/physics/MovementController.java:207
            Game.loop().getDeltaTime() * 0.001f * force.getStrength() * Game.loop().getTimeScale();
---AdvancedNullAwayCodeFix.fix---
Fixing error: Type='DEREFERENCE_NULLABLE', message='dereferenced expression Game.loop() is @Nullable'
/home/nima/Developer/nullness-benchmarks/litiengine/src/de/gurkenlabs/litiengine/physics/MovementController.java:207
            Game.loop().getDeltaTime() * 0.001f * force.getStrength() * Game.loop().getTimeScale();
---AdvancedNullAwayCodeFix.resolveDereferenceError---
Resolving dereference error: Type='DEREFERENCE_NULLABLE', message='dereferenced expression Game.loop() is @Nullable'
/home/nima/Developer/nullness-benchmarks/litiengine/src/de/gurkenlabs/litiengine/physics/MovementController.java:207
            Game.loop().getDeltaTime() * 0.001f * force.getStrength() * Game.loop().getTimeScale();
---AdvancedNullAwayCodeFix.resolveDereferenceError---
Checking nullability possibility at error point
---ChatGPT.checkNullabilityPossibilityAtErrorPoint---
Asking if the expression can be null at error point point
---ChatGPT.ask---
Asking ChatGPT:
In the method below, is there a possibility that the expression "Game.loop()" at line "Game.loop().getDeltaTime() * 0.001f * force.getStrength() * Game.loop().getTimeScale();" is null?
private void handleForces() {
    // clean up forces
    this.activeForces.forEach(
        x -> {
          if (x.hasEnded()) {
            this.activeForces.remove(x);
          }
        });

    if (this.activeForces.isEmpty()) {
      return;
    }

    // disable turn-on-move for force handling
    boolean turn = this.getEntity().turnOnMove();
    this.getEntity().setTurnOnMove(false);
    try {
      double deltaX = 0;
      double deltaY = 0;
      for (final Force force : this.activeForces) {
        if (force.cancelOnReached() && force.hasReached(this.getEntity())) {
          force.end();
          continue;
        }

        final Point2D collisionBoxCenter = this.getEntity().getCollisionBoxCenter();
        final double angle =
            GeometricUtilities.calcRotationAngleInDegrees(collisionBoxCenter, force.getLocation());
        final double strength =
            Game.loop().getDeltaTime() * 0.001f * force.getStrength() * Game.loop().getTimeScale();
        deltaX += GeometricUtilities.getDeltaX(angle, strength);
        deltaY += GeometricUtilities.getDeltaY(angle, strength);
      }

      final Point2D target =
          new Point2D.Double(this.getEntity().getX() + deltaX, this.getEntity().getY() + deltaY);
      final boolean success = Game.physics().move(this.getEntity(), target);
      if (!success) {
        for (final Force force : this.activeForces) {
          if (force.cancelOnCollision()) {
            force.end();
          }
        }
      }
    } finally {
      this.getEntity().setTurnOnMove(turn);
    }
}
Give a single-word answer in XML format. If it is possible for the expression to be null, respond with:
```xml
<response>
    <reason><![CDATA[YOUR REASON]]></reason>
    <value>YES</value>
</response>
```
If it is not possible for the expression to be null, respond with:
```xml
<response>
    <reason><![CDATA[YOUR REASON]]></reason>
    <value>NO</value>
</response>
```
If you are unsure or need more information, respond with where you can ask for more details or what specific information you need.

If additional information is required, list each request inside a `<request>` tag. If no additional information is needed, omit the `<requests>` section.

Respond with:
```xml
<response>
    <reason><![CDATA[YOUR REASON]]></reason>
    <value>UNKNOWN</value>
    <!-- Include <requests> only if additional information is needed -->
    <requests>
        <request><![CDATA[YOUR REQUEST 1]]></request>
        <request><![CDATA[YOUR REQUEST 2]]></request>
    </requests>
</response>
```
---ChatGPT.sendRequestToOpenAI---
Sending request to OpenAI...
---ChatGPT.sendRequestToOpenAI---
Response received from OpenAI.
---Response.<init>---
Creating Response:
```xml
<response>
    <reason><![CDATA[The possibility of `Game.loop()` being null depends on how the `Game` class and its`loop()` method are implemented. If `loop()` returns a non-null object consistently, then it can't be null. However, without details about the `Game` class, it's unclear.]]></reason>
    <value>UNKNOWN</value>
    <requests>
        <request><![CDATA[Details about the implementation of the `Game.loop()` method.]]></request>
        <request><![CDATA[Documentation or guarantees regarding `Game.loop()` returning a non-null object.]]></request>
    </requests>
</response>
```
---Response.<init>---
Response created:
Unknown: The possibility of `Game.loop()` being null depends on how the `Game` class and its`loop()` method are implemented. If `loop()` returns a non-null object consistently, then it can't be null. However, without details about the `Game` class, it's unclear.
---AdvancedNullAwayCodeFix.resolveMethodDereferenceError---
Resolving method dereference error.
---AdvancedNullAwayCodeFix.resolveMethodDereferenceError---
Method is in annotated package. Checking if the method is returning nullable.
---AdvancedNullAwayCodeFix.investigateMethodReturnNullability---
Checking if the method is returning nullable.
---ChatGPT.checkIfMethodIsReturningNullable---
Asking if the method is returning nullable: loop()
---ChatGPT.ask---
Asking ChatGPT:
In the method below, is there a possibility that the method returns null based only on its body? Consider the following points:

- The method may have multiple return paths; consider all return statements.
- If the method calls another method, do not assume its return value unless its full declaration is provided. Request its declaration if needed.
- The method may throw an exception instead of returning null. An exception path should not be considered a null return.
- Ensure you request the declarations of any methods whose return values directly or indirectly impact this method’s return value before making a conclusion.
- Carefully analyze all conditions and prior operations that may guarantee a non-null return value.

@Nullable public static IGameLoop loop() {
    return gameLoop;
}

Here are the method definitions in addition to the method inquired:

Depth: 0
```java
class de.gurkenlabs.litiengine.Game {
@Nullable public static IGameLoop loop() {
    return gameLoop;
}
}
```


Response Format:
Provide the answer in **XML format** as follows:

#### If the method **cannot** return `null`:
```xml
<response>
  <reason><![CDATA[EXPLAIN WHY THE METHOD CANNOT RETURN NULL]]></reason>
  <value>NO</value>
</response>
```

#### If the method can return null:
```xml
<response>
  <reason><![CDATA[EXPLAIN WHY THE METHOD CAN RETURN NULL]]></reason>
  <value>YES</value>
</response>
```

#### If you are unsure or need more information, respond with where you can ask for more details or what specific information you need.

#### If you are unsure or If there are any methods that directly or indirectly affect the return value and are not fully disclosed, request their declarations first, in the following format:
<response>
  <reason><![CDATA[YOUR REASON]]></reason>
  <value>UNKNOWN</value>
  <methods>
    <method>methodName</method>
  </methods>
</response>

If additional information is required other than method declaration, list each request inside a `<request>` tag. If no additional information is needed, omit the `<requests>` section.

Respond with:
```xml
<response>
    <reason><![CDATA[YOUR REASON]]></reason>
    <value>UNKNOWN</value>
    <!-- Include <requests> only if additional information is needed -->
    <requests>
        <request><![CDATA[YOUR REQUEST 1]]></request>
        <request><![CDATA[YOUR REQUEST 2]]></request>
    </requests>
</response>
```

Additional Notes:
Be precise in your reasoning.
If a method’s return value depends on another method not provided, request its declaration before making a conclusion.
If the method can return null in some cases but not others, explain under what conditions it can happen.

---ChatGPT.sendRequestToOpenAI---
Retrieving response from cache
---Response.<init>---
Creating Response:
```xml
<response>
  <reason><![CDATA[The method `loop` returns the variable `gameLoop`. Without the initialization or assignment details of `gameLoop`, it's unclear whether it can be null. The possibility of `gameLoop` being uninitialized or set to null elsewhere in the program means `loop` could potentially return null. Further information on `gameLoop` is required.]]></reason>
  <value>UNKNOWN</value>
  <requests>
    <request><![CDATA[Please provide the declaration and initialization of the variable `gameLoop` in the class `de.gurkenlabs.litiengine.Game`.]]></request>
  </requests>
</response>
```
---Response.<init>---
Response created:
Unknown: The method `loop` returns the variable `gameLoop`. Without the initialization or assignment details of `gameLoop`, it's unclear whether it can be null. The possibility of `gameLoop` being uninitialized or set to null elsewhere in the program means `loop` could potentially return null. Further information on `gameLoop` is required.
---AdvancedNullAwayCodeFix.investigateMethodReturnNullability---
Could not determine the nullability and model did not ask for any method.
---ChatGPT.checkIfMethodIsReturningNullableOnCallSite---
Asking if the method is returning nullable on the call site: Game.loop()
---ChatGPT.ask---
Asking ChatGPT:
In the method below, is there a possibility that the method returns null at the given call site?

```java
@Nullable public static IGameLoop loop() {
    return gameLoop;
}
```

## Guidelines:
- The method may have multiple return paths; consider all return statements.
- If the method calls another method, do not assume its return value unless its full declaration is provided. Request its declaration if needed.
- The method may throw an exception instead of returning null. An exception path should not be considered a null return.
- Ensure you request the declarations of any methods whose return values directly or indirectly impact this method’s return value before making a conclusion.
- If the method returns a value that is determined by a parameter, evaluate based on the actual argument at the given call site.
- Analyze based only on the specific invocation provided. Do not generalize to all possible inputs.- If the return value is guaranteed to be non-null at the call site, the answer should be a definitive NO.
- Do not generalize based on all possible inputs—your answer must be based only on the given invocation.
- Focus only on the given call site, not all possible invocations.

### call site:
Game.loop()

Here are the method definitions and the call chain for this method, showing the sequence of calls from the method to its callers at each depth level:

Depth: 0
```java
class de.gurkenlabs.litiengine.Game {
@Nullable public static IGameLoop loop() {
    return gameLoop;
}
}
```
Depth: 1
```java
class de.gurkenlabs.litiengine.environment.GameWorld {
public void loadEnvironment(@Nullable final Environment env) {
    Lock lock = Game.loop().getLock();
    lock.lock();
    try {
      unloadEnvironment();
      this.environment = env;
      if (env != null) {
        this.addEnvironment(env);

        if (env.getGravity() == 0 && this.gravity() != 0) {
          env.setGravity(this.gravity());
        }

        env.load();
        for (final EnvironmentLoadedListener listener : this.loadedListeners) {
          listener.loaded(env);
        }

        // call map specific listeners
        String mapName = getMapName(env);
        if (mapName != null && this.environmentLoadedListeners.containsKey(mapName)) {

          // for the default camera we center the camera on the environment
          if (this.camera().getClass().equals(Camera.class)) {
            camera().setFocus(env.getCenter());
          }

          for (EnvironmentLoadedListener listener : this.environmentLoadedListeners.get(mapName)) {
            listener.loaded(env);
          }
        }
      }
    } finally {
      lock.unlock();
    }
}public void setCamera(@Nullable final ICamera cam) {
    if (this.camera() != null) {
      Game.loop().detach(camera);
    }

    camera = cam;

    if (cam != null && !Game.isInNoGUIMode()) {
      Game.loop().attach(cam);
      cam.updateFocus();
    }
}
}
```
```java
class de.gurkenlabs.litiengine.entities.behavior.EntityNavigator {
public EntityNavigator(final IMobileEntity entity, final PathFinder pathFinder) {
    this.cancelNavigationConditions = new CopyOnWriteArrayList<>();
    this.listeners = new CopyOnWriteArrayList<>();
    this.entity = entity;
    this.pathFinder = pathFinder;
    this.setAcceptableError(DEFAULT_ACCEPTABLE_ERROR);
    Game.loop().attach(this);
}
}
```
```java
class de.gurkenlabs.litiengine.GameWindow {
private static void initializeWindowEventListeners(Window window) {

    window.addWindowStateListener(
        e -> {
          if (e.getNewState() == Frame.ICONIFIED) {
            Game.loop().setTickRate(ICONIFIED_MAX_FPS);
          } else {
            Game.loop().setTickRate(Game.config().client().getMaxFps());
          }
        });

    window.addWindowFocusListener(
        new WindowFocusListener() {
          @Override
          public void windowLostFocus(WindowEvent e) {
            if (Game.config().graphics().reduceFramesWhenNotFocused()) {
              Game.loop().setTickRate(NONE_FOCUS_MAX_FPS);
            }
          }

          @Override
          public void windowGainedFocus(WindowEvent e) {
            Game.loop().setTickRate(Game.config().client().getMaxFps());
          }
        });

    window.addWindowListener(
        new WindowAdapter() {
          @Override
          public void windowClosing(final WindowEvent event) {
            Game.exit();
          }
        });
}
}
```
```java
class de.gurkenlabs.litiengine.gui.screens.ScreenManager {
public void display(@Nullable final Screen screen) {
    if (Game.hasStarted() && Game.time().since(this.lastScreenChange) < this.getChangeCooldown()) {
      log.log(
          Level.INFO,
          "Skipping displaying of screen {0} because screen changing is currently on cooldown.",
          screen != null ? screen.getName() : "");
      return;
    }

    final Screen previous = this.current();
    if (previous != null) {
      previous.suspend();
    }

    if (screen != null && !this.screens.contains(screen)) {
      this.screens.add(screen);
    }

    this.currentScreen = screen;
    if (!Game.isInNoGUIMode() && this.current() != null) {
      this.current().prepare();
    }

    this.lastScreenChange = Game.loop().getTicks();

    final ScreenChangedEvent event = new ScreenChangedEvent(this.current(), previous);
    for (final ScreenChangedListener listener : this.screenChangedListeners) {
      listener.changed(event);
    }
}
}
```
```java
class de.gurkenlabs.litiengine.abilities.effects.Effect {
@Override
  public void update() {

    for (final Iterator<EffectApplication> iterator = this.getActiveAppliances().iterator();
        iterator.hasNext(); ) {
      final EffectApplication appliance = iterator.next();
      // if the effect duration is reached
      if (this.hasEnded(appliance)) {

        iterator.remove();
        this.cease(appliance);
      }
    }

    // 4. unregister if all appliances are finished
    if (this.getActiveAppliances().isEmpty()) {
      Game.loop().detach(this);
    }
}public void apply(final Shape impactArea) {
    final List<ICombatEntity> affected = this.lookForAffectedEntities(impactArea);
    for (final ICombatEntity affectedEntity : affected) {
      this.apply(affectedEntity);
    }

    this.appliances.add(new EffectApplication(affected, impactArea));

    // if it is the first appliance -> register for update
    if (this.appliances.size() == 1) {
      Game.loop().attach(this);
    }
}
}
```
```java
class de.gurkenlabs.litiengine.GameTime {
public long toTicks(final int milliseconds) {
    return this.toTicks(milliseconds, Game.loop().getTickRate());
}public long since(final long tick) {
    return toMilliseconds(Game.loop().getTicks() - tick);
}public long now() {
    return Game.loop().getTicks();
}public long sinceGameStart() {
    return this.toMilliseconds(Game.loop().getTicks());
}@Override
  public void loaded(Environment environment) {
    environmentLoaded = Game.loop().getTicks();
}public long toMilliseconds(final long ticks) {
    return this.toMilliseconds(ticks, Game.loop().getTickRate());
}
}
```
```java
class de.gurkenlabs.litiengine.GameMetrics {
@Override
  public void render(final Graphics2D g) {
    this.updateMetrics();

    if (!Game.config().client().showGameMetrics()) {
      return;
    }

    this.currentOffsetY = 0;

    g.setColor(this.renderColor);

    // render client metrics
    this.drawTitle(g, "[client]");
    this.drawMetric(g, "fps       : " + this.getFramesPerSecond());
    this.drawMetric(g, "max fps   : " + this.maxFramesPerSecond);
    this.drawMetric(g, "updatables: " + Game.loop().getUpdatableCount());

    // render jvm metrics if debug is enabled
    if (Game.config().debug().isDebugEnabled()) {
      this.drawTitle(g, "[jvm]");
      this.drawMetric(g, "java      : " + this.javaVersion);
      this.drawMetric(g, "memory    : " + String.format("%-5.5s", this.usedMemory) + " MB");
      this.drawMetric(g, "threads   : " + Thread.activeCount());
    }

    // render rendering metrics
    if (!this.renderMetrics.isEmpty()) {
      this.drawTitle(g, "[update]");

      for (RenderMetrics metric : this.renderMetrics) {
        this.drawMetric(g, metric.toString());
      }

      this.renderMetrics.clear();
    }
}
}
```
```java
class de.gurkenlabs.litiengine.graphics.emitters.Emitter {
public void deactivate() {
    if (!this.activated) {
      return;
    }

    this.activated = false;
    this.getParticles().clear();
    this.aliveTime = 0;
    this.activationTick = 0;
    this.lastSpawn = 0;
    Game.loop().detach(this);
}public void activate() {
    if (this.activated) {
      return;
    }

    this.activated = true;
    this.activationTick = Game.time().now();
    Game.loop().attach(this);
}@Override
  public void update() {
    if (this.isPaused()) {
      return;
    }

    // clear particles if the effect time to life is reached
    if (this.isFinished()) {
      for (EmitterFinishedListener listener : this.finishedListeners) {
        listener.finished(this);
      }

      this.delete();
      return;
    }

    final float updateRatio = (float) this.data().getUpdateRate() / Game.loop().getTickRate();
    for (final Particle p : this.getParticles().stream().collect(Collectors.toList())) {
      if (this.particleCanBeRemoved(p)) {
        // remove dead particles
        this.particles.remove(p);
        continue;
      }

      p.update(this.getOrigin(), updateRatio);
    }

    this.aliveTime = Game.time().since(this.activationTick);
    if ((this.data().getSpawnRate() == 0
        || Game.time().since(this.lastSpawn) >= this.data().getSpawnRate())) {
      this.lastSpawn = Game.time().now();
      this.spawnParticle();
    }
}
}
```
```java
class de.gurkenlabs.litiengine.entities.behavior.IBehaviorController {
public default void attach() {
    Game.loop().attach(this);
}public default void detach() {
    Game.loop().detach(this);
}
}
```
```java
class de.gurkenlabs.litiengine.abilities.AbilityExecution {
AbilityExecution(final Ability ability) {
    this.appliedEffects = new CopyOnWriteArrayList<>();
    this.ability = ability;
    this.executionTicks = Game.time().now();
    this.impactArea = ability.calculateImpactArea();
    this.castLocation = ability.getExecutor().getCenter();
    Game.loop().attach(this);
}@Override
  public void update() {
    // if there a no effects to apply -> unregister this instance and we're done
    if (this.getAbility().getEffects().isEmpty()
        || this.getAbility().getEffects().size() == this.getAppliedEffects().size()) {
      Game.loop().detach(this);
      return;
    }

    // handle all effects from the ability that were not applied yet
    for (final Effect effect : this.getAbility().getEffects()) {
      // if the ability was not executed yet or the delay of the effect is not
      // yet reached
      if (this.getAppliedEffects().contains(effect)
          || Game.time().since(this.getExecutionTicks()) < effect.getDelay()) {
        continue;
      }

      effect.apply(this.getExecutionImpactArea());
      this.getAppliedEffects().add(effect);
    }
}
}
```
```java
class de.gurkenlabs.litiengine.GameWindow$3 {
@Override
          public void windowGainedFocus(WindowEvent e) {
            Game.loop().setTickRate(Game.config().client().getMaxFps());
}@Override
          public void windowLostFocus(WindowEvent e) {
            if (Game.config().graphics().reduceFramesWhenNotFocused()) {
              Game.loop().setTickRate(NONE_FOCUS_MAX_FPS);
            }
}
}
```
```java
class de.gurkenlabs.litiengine.environment.EntitySpawner {
protected void spawnNewEntities() {
    if (this.getSpawnMode() != SpawnMode.CUSTOMSPAWNPOINTS && this.getSpawnPoints().isEmpty()) {
      return;
    }

    switch (this.getSpawnMode()) {
      case ALLSPAWNPOINTS:
        for (int i = 0; i < this.getSpawnPoints().size(); i++) {
          final int index = i;
          Game.loop()
              .perform(
                  this.getSpawnDelay() + this.getSpawnDelay() * i,
                  () -> this.spawn(this.getSpawnPoints().get(index), this.getSpawnAmount()));
        }
        break;
      case ONERANDOMSPAWNPOINT:
        this.spawn(Game.random().choose(this.getSpawnPoints()), this.getSpawnAmount());
        break;
      case RANDOMSPAWNPOINTS:
        for (int i = 0; i < this.getSpawnAmount(); i++) {
          Game.loop()
              .perform(
                  this.getSpawnDelay() + this.getSpawnDelay() * i,
                  () -> this.spawn(Game.random().choose(this.getSpawnPoints()), 1));
        }
        break;
      case CUSTOMSPAWNPOINTS:
        List<Spawnpoint> spawnPoints =
            this.customSpawnpoints != null
                ? this.customSpawnpoints.apply(this)
                : this.getCustomSpawnpoints();

        int index = 0;
        for (Spawnpoint spawn : spawnPoints) {
          Game.loop()
              .perform(
                  this.getSpawnDelay() + this.getSpawnDelay() * index, () -> this.spawn(spawn, 1));
          index++;
        }
        break;
      default:
        break;
    }
}
}
```
```java
class de.gurkenlabs.litiengine.tweening.TweenEngine {
@Override
  public void start() {
    Game.loop().attach(this);
}@Override
  public void terminate() {
    Game.loop().detach(this);
}
}
```
```java
class de.gurkenlabs.litiengine.gui.SpeechBubble {
public void hide() {
    Game.world().environment().removeRenderable(this);
    Game.loop().detach(this);
    if (activeSpeechBubbles.get(this.getEntity()) != null
        && activeSpeechBubbles.remove(this.getEntity()).equals(this)) {
      activeSpeechBubbles.remove(this.getEntity());
    }

    for (SpeechBubbleListener listener : this.listeners) {
      listener.hidden();
    }
}private SpeechBubble(
      final IEntity entity,
      final String text,
      @Nullable SpeechBubbleAppearance appearance,
      @Nullable Font font) {
    if (appearance == null) {
      this.appearance = DEFAULT_APPEARANCE;
    } else {
      this.appearance = appearance;
    }

    final SpeechBubble active = activeSpeechBubbles.get(entity);
    if (active != null) {
      active.hide();
    }
    this.setFont(font);

    this.textBoxWidth = (float) (entity.getWidth() * 4);
    this.entity = entity;

    this.currentText = text;
    this.currentTextDisplayTime = DISPLAYTIME_MIN + text.length() * DISPLAYTIME_PER_LETTER;

    this.lastTextDisplay = Game.time().now();
    this.createBubbleImage();
    entity.getEnvironment().add(this, RenderType.UI);
    Game.loop().attach(this);
    activeSpeechBubbles.put(entity, this);
}
}
```
```java
class de.gurkenlabs.litiengine.entities.Prop {
private void updateAnimationController() {
    IEntityAnimationController<?> controller = this.createAnimationController();
    this.getControllers().addController(controller);
    if (Game.world().environment() != null && Game.world().environment().isLoaded()) {
      Game.loop().attach(controller);
    }
}
}
```
```java
class de.gurkenlabs.litiengine.graphics.FreeFlightCamera {
public FreeFlightCamera(final Point2D focus) {
    this.setFocus(focus);
    this.velocity = DEFAULT_SCROLL_PIXELS_PER_SECOND;
    this.scrollPadding = DEFAULT_SCROLL_PADDING;
    this.setClampToMap(true);

    Game.loop().attach(this);
}private void handleFreeFlightCamera() {
    if (Game.world().environment() == null || Game.world().environment().getMap() == null) {
      return;
    }

    final Point2D mouseLocation = Input.mouse().getLocation();

    final double scrollSpeed =
        this.getVelocity()
            / (double) Game.loop().getTickRate()
            * Game.config().input().getMouseSensitivity();

    double x = this.getFocus().getX();
    double y = this.getFocus().getY();

    double deltaX = 0;
    if (mouseLocation.getX() < this.getScrollPadding()) {
      deltaX -= scrollSpeed;
    } else if (Game.window().getResolution().getWidth() - mouseLocation.getX()
        < this.getScrollPadding()) {
      deltaX += scrollSpeed;
    }

    double deltaY = 0;
    if (mouseLocation.getY() < this.getScrollPadding()) {
      deltaY -= scrollSpeed;
    } else if (Game.window().getResolution().getHeight() - mouseLocation.getY()
        < this.getScrollPadding()) {
      deltaY += scrollSpeed;
    }

    x += deltaX;
    y += deltaY;

    this.setFocus(new Point2D.Double(x, y));
}
}
```
```java
class de.gurkenlabs.litiengine.environment.Environment {
private static void dispose(final Collection<? extends IEntity> entities) {
    for (final IEntity entity : entities) {
      if (entity instanceof IUpdateable) {
        Game.loop().detach((IUpdateable) entity);
      }

      entity.detachControllers();
    }
}private static void loadUpdatableOrEmitterEntity(IEntity entity) {
    if (entity instanceof Emitter) {
      final Emitter emitter = (Emitter) entity;
      if (emitter.isActivateOnInit()) {
        emitter.activate();
      }
    } else if (entity instanceof IUpdateable) {
      Game.loop().attach((IUpdateable) entity);
    }
}private void unload(final IEntity entity) {
    // 1. remove from physics engine
    if (entity instanceof ICollisionEntity) {
      Game.physics().remove((ICollisionEntity) entity);
    }

    // 2. unregister from update
    if (entity instanceof IUpdateable) {
      Game.loop().detach((IUpdateable) entity);
    }

    if (entity instanceof IMobileEntity) {
      this.removeGravity((IMobileEntity) entity);
    }

    // 3. detach all controllers
    entity.detachControllers();

    if (entity instanceof Emitter) {
      Emitter em = (Emitter) entity;
      em.deactivate();
    }

    if (this.loaded && (entity instanceof LightSource || entity instanceof StaticShadow)) {
      this.updateLighting(entity);
    }

    entity.removed(this);
}
}
```
```java
class de.gurkenlabs.litiengine.graphics.animation.Animation {
@Override
  public void update() {
    // do nothing if the animation is not playing or the current keyframe is not finished
    if (!this.isPlaying()
        || Game.time().since(this.lastFrameUpdate) < this.getCurrentKeyFrame().getDuration()) {
      return;
    }

    // if we are not looping and the last keyframe is finished, we terminate the animation
    if (!this.isLooping() && this.isLastKeyFrame()) {
      this.terminate();
      return;
    }

    // make sure, we stay inside the keyframe list
    final int newFrameIndex =
        (this.getKeyframes().indexOf(this.currentFrame) + 1) % this.getKeyframes().size();
    final KeyFrame previousFrame = this.currentFrame;
    this.currentFrame = this.getKeyframes().get(newFrameIndex);

    for (KeyFrameListener listener : this.listeners) {
      listener.currentFrameChanged(previousFrame, this.currentFrame);
    }

    this.lastFrameUpdate = Game.loop().getTicks();
}public void restart() {
    this.currentFrame = this.firstFrame;
    this.lastFrameUpdate = Game.loop().getTicks();
}
}
```
```java
class de.gurkenlabs.litiengine.physics.MovementController {
@Override
  public void attach() {
    Game.loop().attach(this);
}private void handleForces() {
    // clean up forces
    this.activeForces.forEach(
        x -> {
          if (x.hasEnded()) {
            this.activeForces.remove(x);
          }
        });

    if (this.activeForces.isEmpty()) {
      return;
    }

    // disable turn-on-move for force handling
    boolean turn = this.getEntity().turnOnMove();
    this.getEntity().setTurnOnMove(false);
    try {
      double deltaX = 0;
      double deltaY = 0;
      for (final Force force : this.activeForces) {
        if (force.cancelOnReached() && force.hasReached(this.getEntity())) {
          force.end();
          continue;
        }

        final Point2D collisionBoxCenter = this.getEntity().getCollisionBoxCenter();
        final double angle =
            GeometricUtilities.calcRotationAngleInDegrees(collisionBoxCenter, force.getLocation());
        final double strength =
            Game.loop().getDeltaTime() * 0.001f * force.getStrength() * Game.loop().getTimeScale();
        deltaX += GeometricUtilities.getDeltaX(angle, strength);
        deltaY += GeometricUtilities.getDeltaY(angle, strength);
      }

      final Point2D target =
          new Point2D.Double(this.getEntity().getX() + deltaX, this.getEntity().getY() + deltaY);
      final boolean success = Game.physics().move(this.getEntity(), target);
      if (!success) {
        for (final Force force : this.activeForces) {
          if (force.cancelOnCollision()) {
            force.end();
          }
        }
      }
    } finally {
      this.getEntity().setTurnOnMove(turn);
    }
}@Override
  public void detach() {
    Game.loop().detach(this);
}public void handleMovement() {
    if (!this.isMovementAllowed()) {
      this.velocity = 0;
      return;
    }

    // max distance an entity can travel within one tick
    final double maxPixelsPerTick = this.getEntity().getTickVelocity();
    final double deltaTime = Game.loop().getDeltaTime() * Game.loop().getTimeScale();

    final double acceleration =
        this.getEntity().getAcceleration() == 0
            ? maxPixelsPerTick
            : deltaTime / this.getEntity().getAcceleration() * maxPixelsPerTick;
    final double deceleration =
        this.getEntity().getDeceleration() == 0
            ? this.getVelocity()
            : deltaTime / this.getEntity().getDeceleration() * maxPixelsPerTick;

    double dx = this.getDx();
    double dy = this.getDy();
    this.setDx(0);
    this.setDy(0);

    final double deltaVelocity =
        Math.min(Math.sqrt(Math.pow(dx, 2) + Math.pow(dy, 2)), acceleration);
    if (deltaVelocity != 0) {
      double newVelocity = this.getVelocity() + deltaVelocity;
      this.setVelocity(newVelocity);
    } else {
      final double newVelocity = Math.max(0, this.getVelocity() - deceleration);
      this.setVelocity(newVelocity);
      dx = GeometricUtilities.getDeltaX(this.moveAngle);
      dy = GeometricUtilities.getDeltaY(this.moveAngle);
    }

    if (this.getVelocity() == 0) {
      this.moveAngle = 0;
      return;
    }

    // actually move entity
    this.moveEntity(dx, dy);
}
}
```
```java
class de.gurkenlabs.litiengine.graphics.animation.AnimationController {
public void detach() {
    Game.loop().detach(this);
}public void attach() {
    Game.loop().attach(this);
}
}
```
```java
class de.gurkenlabs.litiengine.graphics.Camera {
@Override
  public void setZoom(final float targetZoom, final int delay) {
    if (delay == 0) {

      this.zoom = targetZoom;
      this.targetZoom = 0;
      this.zoomDelay = 0;
      this.zoomTick = 0;
      this.zoomStep = 0;

      final ZoomChangedEvent event = new ZoomChangedEvent(this, targetZoom);
      for (final ZoomChangedListener listener : this.zoomListeners) {
        listener.zoomChanged(event);
      }
    } else {
      this.zoomTick = Game.time().now();
      this.targetZoom = targetZoom;
      this.zoomDelay = delay;

      final double tickduration = 1000 / (double) Game.loop().getTickRate();
      final double tickAmount = delay / tickduration;
      final float totalDelta = this.targetZoom - this.zoom;
      this.zoomStep = tickAmount > 0 ? (float) (totalDelta / tickAmount) : totalDelta;
    }
}
}
```
```java
class de.gurkenlabs.litiengine.Game {
public static synchronized void init(String... args) {
    if (initialized) {
      log().log(Level.INFO, "The game has already been initialized.");
      return;
    }

    log.init();
    handleCommandLineArguments(args);

    config().load();
    Locale.setDefault(new Locale(config().client().getCountry(), config().client().getLanguage()));

    gameLoop = new GameLoop("Main Update Loop", config().client().getMaxFps());
    loop().attach(physics());
    loop().attach(world());

    // setup default exception handling for render and update loop
    setUncaughtExceptionHandler(
        new DefaultUncaughtExceptionHandler(config().client().exitOnError()));

    screenManager = new ScreenManager();
    gameWindow = new GameWindow();

    // initialize  the game window
    window().init();
    world.setCamera(new Camera());

    for (GameListener listener : gameListeners) {
      listener.initialized(args);
    }

    if (!isInNoGUIMode()) {
      window().getRenderComponent().onRendered(g -> metrics().render(g));

      graphics()
          .addEntityRenderedListener(
              e -> DebugRenderer.renderEntityDebugInfo(e.getGraphics(), e.getEntity()));

      window().getRenderComponent().onFpsChanged(fps -> metrics().setFramesPerSecond(fps));
      window()
          .setIcons(
              Arrays.asList(
                  Resources.images().get("liti-logo-x16.png"),
                  Resources.images().get("liti-logo-x20.png"),
                  Resources.images().get("liti-logo-x32.png"),
                  Resources.images().get("liti-logo-x48.png")));

      Input.keyboard()
          .onKeyTyped(
              KeyEvent.VK_PRINTSCREEN,
              key -> {
                // don't take a screenshot if a modifier is active
                if (key.getModifiers() != 0) {
                  return;
                }

                window().getRenderComponent().takeScreenshot();
              });
    }

    Runtime.getRuntime().addShutdownHook(new Thread(Game::terminate, "Shutdown"));

    initialized = true;
}
}
```
```java
class de.gurkenlabs.litiengine.entities.Creature {
protected void updateAnimationController() {
    IEntityAnimationController<?> controller = this.createAnimationController();
    this.getControllers().addController(controller);
    if (Game.world().environment() != null && Game.world().environment().isLoaded()) {
      Game.loop().attach(controller);
    }
}@Override
  public float getTickVelocity() {
    // pixels per ms multiplied by the passed ms
    // ensure that entities don't travel too far in case of lag
    return Math.min(Game.loop().getDeltaTime(), GameLoop.TICK_DELTATIME_LAG)
        * 0.001F
        * this.getVelocity().get()
        * Game.loop().getTimeScale();
}
}
```
Depth: 2
```java
class de.gurkenlabs.litiengine.environment.GameWorld {
public void clear() {
    this.unloadEnvironment();
    this.environments.clear();
    this.setCamera(null);
    Game.physics().clear();

    this.environmentListeners.clear();
    this.environmentLoadedListeners.clear();
    this.environmentUnloadedListeners.clear();

    this.listeners.clear();
    this.loadedListeners.clear();
    this.unloadedListeners.clear();
}@Nullable
  public Environment loadEnvironment(IMap map) {
    Environment env = this.getEnvironment(map);
    this.loadEnvironment(env);
    return env;
}@Nullable
  public Environment loadEnvironment(String mapName) {
    Environment env = this.getEnvironment(mapName);
    this.loadEnvironment(env);
    return env;
}
}
```
```java
class de.gurkenlabs.litiengine.GameWindow {
GameWindow() {
    this.hostControl = new JFrame();

    this.resolutionChangedListeners = new CopyOnWriteArrayList<>();

    this.renderCanvas = new RenderComponent(Game.config().graphics().getResolution());
    this.cursor = new MouseCursor();
    if (!Game.isInNoGUIMode()) {
      this.hostControl.setBackground(Color.BLACK);
      this.hostControl.add(this.renderCanvas);

      this.initializeEventListeners();

      this.hostControl.setTitle(Game.info().getTitle());
      this.hostControl.setDefaultCloseOperation(WindowConstants.DO_NOTHING_ON_CLOSE);
      initializeWindowEventListeners(this.hostControl);
    }
}
}
```
```java
class de.gurkenlabs.litiengine.GameTime {
public long sinceEnvironmentLoad() {
    return this.since(this.environmentLoaded);
}public long since(final long tick) {
    return toMilliseconds(Game.loop().getTicks() - tick);
}public long sinceGameStart() {
    return this.toMilliseconds(Game.loop().getTicks());
}
}
```
```java
class de.gurkenlabs.litiengine.abilities.effects.Effect {
protected void cease(final EffectApplication appliance) {
    // 1. cease the effect for all affected entities
    for (final ICombatEntity entity : appliance.getAffectedEntities()) {
      this.cease(entity);
    }

    // 2. apply follow up effects
    this.getFollowUpEffects().forEach(followUp -> followUp.apply(appliance.getImpactArea()));
}protected boolean hasEnded(final EffectApplication appliance) {
    final long effectDuration = Game.time().since(appliance.getAppliedTicks());
    return effectDuration > this.getDuration();
}
}
```
```java
class de.gurkenlabs.litiengine.abilities.effects.EffectApplication {
protected EffectApplication(final List<ICombatEntity> affectedEntities, final Shape impactArea) {
    this.applied = Game.time().now();
    this.affectedEntities = affectedEntities;
    this.impactArea = impactArea;
}
}
```
```java
class de.gurkenlabs.litiengine.entities.CombatEntity {
@Override
  public boolean wasHit(int timeSpan) {
    return Game.time().since(this.lastHit) < timeSpan;
}@Override
  public void hit(final int damage, @Nullable final Ability ability) {
    if (this.isDead()) {
      return;
    }

    if (!this.isIndestructible()) {
      this.getHitPoints().modifyBaseValue(new AttributeModifier<>(Modification.SUBTRACT, damage));
    }

    final EntityHitEvent event = new EntityHitEvent(this, ability, damage, this.isDead());

    for (final CombatEntityListener listener : this.listeners) {
      listener.hit(event);
    }

    for (final CombatEntityHitListener listener : this.hitListeners) {
      listener.hit(event);
    }

    if (this.isDead()) {
      this.fireDeathEvent();
      this.setCollision(false);
    }

    this.lastHit = Game.time().now();
}
}
```
```java
class de.gurkenlabs.litiengine.graphics.ImageEffect {
protected ImageEffect(final int ttl, final String name) {
    this.ttl = ttl;
    this.name = name;
    this.aliveTick = Game.time().now();
}@Override
  public long getAliveTime() {
    return Game.time().since(this.aliveTick);
}
}
```
```java
class de.gurkenlabs.litiengine.abilities.AbilityExecution {
AbilityExecution(final Ability ability) {
    this.appliedEffects = new CopyOnWriteArrayList<>();
    this.ability = ability;
    this.executionTicks = Game.time().now();
    this.impactArea = ability.calculateImpactArea();
    this.castLocation = ability.getExecutor().getCenter();
    Game.loop().attach(this);
}@Override
  public void update() {
    // if there a no effects to apply -> unregister this instance and we're done
    if (this.getAbility().getEffects().isEmpty()
        || this.getAbility().getEffects().size() == this.getAppliedEffects().size()) {
      Game.loop().detach(this);
      return;
    }

    // handle all effects from the ability that were not applied yet
    for (final Effect effect : this.getAbility().getEffects()) {
      // if the ability was not executed yet or the delay of the effect is not
      // yet reached
      if (this.getAppliedEffects().contains(effect)
          || Game.time().since(this.getExecutionTicks()) < effect.getDelay()) {
        continue;
      }

      effect.apply(this.getExecutionImpactArea());
      this.getAppliedEffects().add(effect);
    }
}
}
```
```java
class de.gurkenlabs.litiengine.tweening.TweenEngine {
@Override
  public void update() {
    for (final Tweenable target : this.getTweens().keySet()) {
      for (final Tween tween : this.getTweens().get(target).values()) {
        if (tween.hasStopped()) {
          continue;
        }
        final long elapsed = Game.time().since(tween.getStartTime());
        if (elapsed >= tween.getDuration()) {
          tween.stop();
          continue;
        }
        final float[] currentValues = new float[tween.getTargetValues().length];
        for (int i = 0; i < tween.getTargetValues().length; i++) {
          currentValues[i] =
              tween.getStartValues()[i]
                  + tween.getEquation().compute(elapsed / (float) tween.getDuration())
                      * (tween.getTargetValues()[i] - tween.getStartValues()[i]);
        }
        tween.getTarget().setTweenValues(tween.getType(), currentValues);
      }
    }
}
}
```
```java
class de.gurkenlabs.litiengine.gui.SpeechBubble {
public static SpeechBubble create(
      final IEntity entity, final String text, SpeechBubbleAppearance appearance, Font font) {
    return new SpeechBubble(entity, text, appearance, font);
}public static SpeechBubble create(final IEntity entity, final Font font, final String text) {
    SpeechBubbleAppearance app =
        new SpeechBubbleAppearance(
            DEFAULT_APPEARANCE.getForeColor(),
            DEFAULT_APPEARANCE.getBackgroundColor1(),
            DEFAULT_APPEARANCE.getBorderColor(),
            DEFAULT_APPEARANCE.getPadding());
    return new SpeechBubble(entity, text, app, font);
}public static SpeechBubble create(final IEntity entity, final String text) {
    return new SpeechBubble(entity, text, null, GuiProperties.getDefaultFont());
}@Override
  public void update() {
    if (this.currentText == null) {
      this.hide();
      return;
    }

    this.entityCenter = Game.world().camera().getViewportLocation(this.getEntity().getCenter());

    // old text was displayed long enough
    if (this.lastTextDisplay != 0
        && Game.time().since(this.lastTextDisplay) > this.currentTextDisplayTime) {
      this.currentText = null;
      this.lastTextDisplay = 0;
      return;
    }

    // display new text
    if (this.textIndex < this.currentText.length()
        && Game.time().since(this.lastCharPoll) > LETTER_WRITE_DELAY) {
      this.textIndex++;
      this.lastCharPoll = Game.time().now();
      if (this.typeSound != null) {
        Game.audio().playSound(this.typeSound, this.getEntity());
      }
    }

    // continue displaying currently displayed text
}private SpeechBubble(
      final IEntity entity,
      final String text,
      final Sound typeSound,
      SpeechBubbleAppearance appearance,
      Font font) {
    this(entity, text, appearance, font);
    this.typeSound = typeSound;
}private SpeechBubble(
      final IEntity entity,
      final String text,
      @Nullable SpeechBubbleAppearance appearance,
      @Nullable Font font) {
    if (appearance == null) {
      this.appearance = DEFAULT_APPEARANCE;
    } else {
      this.appearance = appearance;
    }

    final SpeechBubble active = activeSpeechBubbles.get(entity);
    if (active != null) {
      active.hide();
    }
    this.setFont(font);

    this.textBoxWidth = (float) (entity.getWidth() * 4);
    this.entity = entity;

    this.currentText = text;
    this.currentTextDisplayTime = DISPLAYTIME_MIN + text.length() * DISPLAYTIME_PER_LETTER;

    this.lastTextDisplay = Game.time().now();
    this.createBubbleImage();
    entity.getEnvironment().add(this, RenderType.UI);
    Game.loop().attach(this);
    activeSpeechBubbles.put(entity, this);
}
}
```
```java
class de.gurkenlabs.litiengine.gui.TextFieldComponent {
@Override
  public void render(final Graphics2D g) {
    super.render(g);
    g.setFont(this.getFont());
    final FontMetrics fm = g.getFontMetrics();

    if (this.isSelected() && Game.time().since(this.lastToggled) > this.flickerDelay) {
      this.cursorVisible = !this.cursorVisible;
      this.lastToggled = Game.time().now();
    }
    if (this.isSelected() && this.cursorVisible) {
      final Rectangle2D cursor =
          new Rectangle2D.Double(
              this.getX() + this.getTextX() + fm.stringWidth(this.getTextToRender(g)),
              this.getY() + this.getTextY(),
              this.getFont().getSize2D() * 3 / 5,
              this.getFont().getSize2D() * 1 / 5);
      g.setColor(this.getAppearance().getForeColor());
      g.fill(cursor);
    }
}
}
```
```java
class de.gurkenlabs.litiengine.entities.Prop {
public Prop(
      final Point2D location, @Nullable final String spritesheetName, final Material material) {
    super();
    this.rotation = Rotation.NONE;
    this.spritesheetName = spritesheetName;
    this.material = material;
    this.setLocation(location);
    this.updateAnimationController();
}public void setSpritesheetName(@Nullable final String spriteName) {
    this.spritesheetName = spriteName;
    this.updateAnimationController();
}
}
```
```java
class de.gurkenlabs.litiengine.tweening.Tween {
public Tween begin() {
    this.started = Game.time().now();
    this.stopped = false;
    return this;
}
}
```
```java
class de.gurkenlabs.litiengine.graphics.emitters.particles.Particle {
public void update(final Point2D emitterOrigin, final float updateRatio) {
    if (this.aliveTick == 0) {
      this.aliveTick = Game.time().now();
    }

    this.aliveTime = Game.time().since(this.aliveTick);
    if (this.timeToLiveReached()) {
      return;
    }

    if (this.colliding) {
      return;
    }

    if (this.getDeltaWidth() != 0) {
      this.width += this.getDeltaWidth() * updateRatio;
    }

    if (this.getDeltaHeight() != 0) {
      this.height += this.getDeltaHeight() * updateRatio;
    }

    if (this.getDeltaAngle() != 0) {
      this.angle += this.getDeltaAngle() * updateRatio;
    }

    // test for ray cast collision
    final float targetX = this.x + this.getVelocityX() * updateRatio;
    final float targetY = this.y + this.getVelocityY() * updateRatio;

    if (targetX == this.x && targetY == this.y) {
      return;
    }

    if (this.checkForCollision(emitterOrigin, targetX, targetY)) {
      return;
    }

    if (this.getVelocityX() != 0) {
      this.x = targetX;
    }

    if (this.getVelocityY() != 0) {
      this.y = targetY;
    }

    if (this.getAccelerationX() != 0) {
      this.velocityX += this.getAccelerationX() * updateRatio;
    }

    if (this.getAccelerationY() != 0) {
      this.velocityY += this.getAccelerationY() * updateRatio;
    }
}
}
```
```java
class de.gurkenlabs.litiengine.graphics.animation.Animation {
@Override
  public void start() {
    this.playing = true;
    if (this.getKeyframes().isEmpty()) {
      return;
    }

    this.restart();
}@Override
  public void update() {
    // do nothing if the animation is not playing or the current keyframe is not finished
    if (!this.isPlaying()
        || Game.time().since(this.lastFrameUpdate) < this.getCurrentKeyFrame().getDuration()) {
      return;
    }

    // if we are not looping and the last keyframe is finished, we terminate the animation
    if (!this.isLooping() && this.isLastKeyFrame()) {
      this.terminate();
      return;
    }

    // make sure, we stay inside the keyframe list
    final int newFrameIndex =
        (this.getKeyframes().indexOf(this.currentFrame) + 1) % this.getKeyframes().size();
    final KeyFrame previousFrame = this.currentFrame;
    this.currentFrame = this.getKeyframes().get(newFrameIndex);

    for (KeyFrameListener listener : this.listeners) {
      listener.currentFrameChanged(previousFrame, this.currentFrame);
    }

    this.lastFrameUpdate = Game.loop().getTicks();
}
}
```
```java
class de.gurkenlabs.litiengine.graphics.animation.AnimationController {
@Override
  public void update() {
    for (final Animation animation : this.getAll()) {
      animation.update();
    }

    if (this.getCurrent() != null && this.getCurrent().isPaused()) {
      return;
    }

    final boolean playbackFinished = this.getCurrent() != null && !this.getCurrent().isPlaying();
    if (playbackFinished) {
      for (final AnimationListener listener : this.listeners) {
        listener.finished(this.getCurrent());
      }
    }

    if (this.getCurrent() == null || playbackFinished) {
      if (this.getDefault() != null) {
        this.play(this.getDefault().getName());
      } else {
        this.currentAnimation = null;
      }
    }
}
}
```
```java
class de.gurkenlabs.litiengine.graphics.RenderComponent {
private void handleFade() {
    if (this.fadeOutStart != -1) {
      final long timePassed = Game.time().since(this.fadeOutStart);
      this.currentAlpha = MathUtilities.clamp(1 - timePassed / (float) this.fadeOutTime, 0, 1);
      if (this.currentAlpha == 0f) {
        this.fadeOutStart = -1;
        this.fadeOutTime = -1;
      }

      return;
    }

    if (this.fadeInStart != -1) {
      final long timePassed = Game.time().since(this.fadeInStart);
      this.currentAlpha = MathUtilities.clamp(timePassed / (float) this.fadeInTime, 0, 1);
      if (this.currentAlpha == 1f) {
        this.fadeInStart = -1;
        this.fadeInTime = -1;
        this.currentAlpha = Float.NaN;
      }
    }
}public void fadeOut(final int ms) {
    this.fadeInStart = -1;
    this.fadeInTime = -1;
    this.fadeOutStart = Game.time().now();
    this.fadeOutTime = ms;
}public void fadeIn(final int ms) {
    this.fadeOutStart = -1;
    this.fadeOutTime = -1;
    this.fadeInStart = Game.time().now();
    this.fadeInTime = ms;
}
}
```
```java
class de.gurkenlabs.litiengine.entities.Trigger {
private boolean activate(final IEntity activator, final int tar) {
    if (!this.isLoaded()
        || this.isOneTimeTrigger && this.isActivated
        || this.getActivationType() == TriggerActivation.COLLISION
            && activator != null
            && this.collisionActivated.contains(activator)) {
      return false;
    }

    if (this.getCooldown() > 0 && Game.time().since(this.lastActivation) < this.getCooldown()) {
      return false;
    }

    List<Integer> triggerTargets = this.getTargets(tar);

    final TriggerEvent te = new TriggerEvent(this, activator, triggerTargets);

    if (!this.checkActivationPredicates(te)) {
      return false;
    }

    this.isActivated = true;
    if (activator != null) {
      this.collisionActivated.add(activator);
    }

    // if we actually have a trigger target, we send the message to the target
    for (final int target : triggerTargets) {
      final IEntity entity = this.getEnvironment().get(target);
      if (entity == null) {
        log.log(
            Level.WARNING,
            "trigger [{0}] was activated, but the trigger target [{1}] could not be found on the environment",
            new Object[] {this, target});
        continue;
      }

      entity.sendMessage(this, this.message);
    }

    // also send the trigger event to all registered consumers
    for (final TriggerActivatedListener listener : this.activatedListeners) {
      listener.activated(te);
    }

    if (this.isOneTimeTrigger) {
      this.getEnvironment().remove(this);
    }

    this.lastActivation = Game.time().now();
    return true;
}
}
```
```java
class de.gurkenlabs.litiengine.graphics.Camera {
private boolean isShakeEffectActive() {
    return this.getShakeTick() != 0
        && Game.time().since(this.getShakeTick()) < this.getShakeDuration();
}@Override
  public void update() {
    if (Game.world().camera() != null && !Game.world().camera().equals(this)) {
      return;
    }

    if (this.targetZoom > 0) {
      if (Game.time().since(this.zoomTick) >= this.zoomDelay) {
        this.zoom = this.targetZoom;
        this.targetZoom = 0;
        this.zoomDelay = 0;
        this.zoomTick = 0;
        this.zoomStep = 0;
      } else {
        this.zoom += this.zoomStep;
      }

      final ZoomChangedEvent event = new ZoomChangedEvent(this, this.getZoom());
      for (final ZoomChangedListener listener : this.zoomListeners) {
        listener.zoomChanged(event);
      }
    }

    if (this.panTime > 0) {
      if (--this.panTime <= 0) {
        this.setFocus(this.targetFocus);
        this.targetFocus = null;
      } else {
        double diff = this.panTime / (this.panTime + 1.0);
        this.focus =
            new Point2D.Double(
                this.focus.getX() * diff + this.targetFocus.getX() * (1.0 - diff),
                this.focus.getY() * diff + this.targetFocus.getY() * (1.0 - diff));
      }
    }

    if (!this.isShakeEffectActive()) {
      this.shakeOffsetX = 0;
      this.shakeOffsetY = 0;
      return;
    }

    if (Game.time().since(this.lastShake) > this.shakeDelay) {
      this.shakeOffsetX = this.getShakeIntensity() * ThreadLocalRandom.current().nextGaussian();
      this.shakeOffsetY = this.getShakeIntensity() * ThreadLocalRandom.current().nextGaussian();
      this.lastShake = Game.time().now();
    }
}@Override
  public void setZoom(final float targetZoom, final int delay) {
    if (delay == 0) {

      this.zoom = targetZoom;
      this.targetZoom = 0;
      this.zoomDelay = 0;
      this.zoomTick = 0;
      this.zoomStep = 0;

      final ZoomChangedEvent event = new ZoomChangedEvent(this, targetZoom);
      for (final ZoomChangedListener listener : this.zoomListeners) {
        listener.zoomChanged(event);
      }
    } else {
      this.zoomTick = Game.time().now();
      this.targetZoom = targetZoom;
      this.zoomDelay = delay;

      final double tickduration = 1000 / (double) Game.loop().getTickRate();
      final double tickAmount = delay / tickduration;
      final float totalDelta = this.targetZoom - this.zoom;
      this.zoomStep = tickAmount > 0 ? (float) (totalDelta / tickAmount) : totalDelta;
    }
}@Override
  public void shake(final double intensity, final int delay, final int shakeDuration) {
    this.shakeTick = Game.time().now();
    this.shakeDelay = delay;
    this.shakeIntensity = intensity;
    this.shakeDuration = shakeDuration;
}
}
```
```java
class de.gurkenlabs.litiengine.entities.Creature {
public void setSpritesheetName(String spritesheetName) {
    if (this.spritesheetName != null && this.spritesheetName.equals(spritesheetName)) {
      return;
    }

    this.spritesheetName = spritesheetName;
    this.updateAnimationController();
}public boolean isIdle() {
    return Game.time().since(this.lastMoved) > IDLE_DELAY;
}@Override
  public void setLocation(final Point2D position) {
    if (this.isDead() || position == null) {
      return;
    }

    final Point2D oldLocation = this.getLocation();
    super.setLocation(position);

    if (Game.hasStarted() && this.isLoaded()) {
      this.lastMoved = Game.time().now();
      this.fireMovedEvent(
          new EntityMovedEvent(
              this, this.getX() - oldLocation.getX(), this.getY() - oldLocation.getY()));
    }
}
}
```
```java
class de.gurkenlabs.litiengine.gui.screens.ScreenManager {
public void display(final String screenName) {
    if (this.current() != null && this.current().getName().equalsIgnoreCase(screenName)) {
      log.log(
          Level.INFO,
          "Skipping displaying of screen {0} because it is already the current screen.",
          screenName);
      return;
    }

    if (this.screens.stream()
        .noneMatch(element -> element.getName().equalsIgnoreCase(screenName))) {
      log.log(
          Level.WARNING,
          "Could not display the screen {0} because there is no screen with the specified name.",
          screenName);
      return;
    }

    Screen screen = this.get(screenName);
    if (screen == null) {
      return;
    }

    this.display(screen);
}public void add(final Screen screen) {
    screen.setWidth(Game.window().getWidth());
    screen.setHeight(Game.window().getHeight());
    this.screens.add(screen);

    if (this.current() == null) {
      this.display(screen);
    }
}public void remove(Screen screen) {
    this.screens.remove(screen);
    if (this.current() == screen) {
      if (!this.screens.isEmpty()) {
        this.display(this.screens.get(0));
      } else {
        this.display((Screen) null);
      }
    }
}public void display(@Nullable final Screen screen) {
    if (Game.hasStarted() && Game.time().since(this.lastScreenChange) < this.getChangeCooldown()) {
      log.log(
          Level.INFO,
          "Skipping displaying of screen {0} because screen changing is currently on cooldown.",
          screen != null ? screen.getName() : "");
      return;
    }

    final Screen previous = this.current();
    if (previous != null) {
      previous.suspend();
    }

    if (screen != null && !this.screens.contains(screen)) {
      this.screens.add(screen);
    }

    this.currentScreen = screen;
    if (!Game.isInNoGUIMode() && this.current() != null) {
      this.current().prepare();
    }

    this.lastScreenChange = Game.loop().getTicks();

    final ScreenChangedEvent event = new ScreenChangedEvent(this.current(), previous);
    for (final ScreenChangedListener listener : this.screenChangedListeners) {
      listener.changed(event);
    }
}
}
```
```java
class de.gurkenlabs.litiengine.abilities.Ability {
public boolean isOnCooldown() {
    return (this.getCurrentExecution() != null
        && this.getCurrentExecution().getExecutionTicks() > 0
        && Game.time().since(this.getCurrentExecution().getExecutionTicks())
            < this.getAttributes().cooldown().get());
}public boolean isActive() {
    return this.getCurrentExecution() != null
        && Game.time().since(this.getCurrentExecution().getExecutionTicks())
            < this.getAttributes().duration().get();
}@Nullable
  public AbilityExecution cast() {
    if (!this.canCast()) {
      return null;
    }
    this.currentExecution = new AbilityExecution(this);

    for (final AbilityCastListener listener : this.abilityCastListeners) {
      listener.abilityCast(this.currentExecution);
    }

    return this.getCurrentExecution();
}public float getRemainingCooldownInSeconds() {
    if (this.getCurrentExecution() == null
        || this.getExecutor() == null
        || this.getExecutor().isDead()) {
      return 0;
    }

    // calculate cooldown in seconds
    return (float)
        (!this.canCast()
            ? (this.getAttributes().cooldown().get()
                    - Game.time().since(this.getCurrentExecution().getExecutionTicks()))
                * 0.001
            : 0);
}
}
```
```java
class de.gurkenlabs.litiengine.entities.EntityHitEvent {
EntityHitEvent(
      final ICombatEntity hitEntity,
      @Nullable final Ability ability,
      final int damage,
      final boolean kill) {
    super(hitEntity);
    this.executor = ability != null ? ability.getExecutor() : null;
    this.hitEntity = hitEntity;
    this.ability = ability;
    this.damage = damage;
    this.kill = kill;
    this.time = Game.time().now();
}
}
```
```java
class de.gurkenlabs.litiengine.graphics.emitters.Emitter {
public void delete() {
    this.deactivate();
    if (Game.world().environment() != null) {
      Game.world().environment().remove(this);
    }
}public void activate() {
    if (this.activated) {
      return;
    }

    this.activated = true;
    this.activationTick = Game.time().now();
    Game.loop().attach(this);
}@Override
  public void update() {
    if (this.isPaused()) {
      return;
    }

    // clear particles if the effect time to life is reached
    if (this.isFinished()) {
      for (EmitterFinishedListener listener : this.finishedListeners) {
        listener.finished(this);
      }

      this.delete();
      return;
    }

    final float updateRatio = (float) this.data().getUpdateRate() / Game.loop().getTickRate();
    for (final Particle p : this.getParticles().stream().collect(Collectors.toList())) {
      if (this.particleCanBeRemoved(p)) {
        // remove dead particles
        this.particles.remove(p);
        continue;
      }

      p.update(this.getOrigin(), updateRatio);
    }

    this.aliveTime = Game.time().since(this.activationTick);
    if ((this.data().getSpawnRate() == 0
        || Game.time().since(this.lastSpawn) >= this.data().getSpawnRate())) {
      this.lastSpawn = Game.time().now();
      this.spawnParticle();
    }
}
}
```
```java
class de.gurkenlabs.litiengine.GameLoop {
@Override
  public int perform(int delay, Runnable action) {
    final long d = Game.time().toTicks(delay);

    TimedAction a = new TimedAction(this.getTicks() + d, action);
    this.actions.add(a);

    return a.getId();
}
}
```
```java
class de.gurkenlabs.litiengine.environment.EntitySpawner {
protected boolean shouldSpawn() {
    return this.lastSpawnWave == 0
        || Game.time().since(this.lastSpawnWave) >= this.getSpawnInterval();
}@Override
  public void update() {
    if (!this.shouldSpawn()) {
      return;
    }

    this.spawnNewEntities();
    this.lastSpawnWave = Game.time().now();
}
}
```
```java
class de.gurkenlabs.litiengine.graphics.FreeFlightCamera {
@Override
  public void update() {
    this.handleFreeFlightCamera();
}public FreeFlightCamera(double x, double y) {
    this(new Point2D.Double(x, y));
}
}
```
```java
class de.gurkenlabs.litiengine.environment.Environment {
public void unload() {
    if (!this.loaded) {
      return;
    }

    // unregister all updatable entities from the current environment
    for (final IEntity entity : this.allEntities.values()) {
      this.unload(entity);
    }

    this.loaded = false;
    this.fireEvent(l -> l.unloaded(this));
}private static void loadUpdatableOrEmitterEntity(IEntity entity) {
    if (entity instanceof Emitter) {
      final Emitter emitter = (Emitter) entity;
      if (emitter.isActivateOnInit()) {
        emitter.activate();
      }
    } else if (entity instanceof IUpdateable) {
      Game.loop().attach((IUpdateable) entity);
    }
}public void clear() {
    Game.physics().clear();

    this.combatEntities.clear();
    this.mobileEntities.clear();
    this.gravityForces.clear();
    this.layerEntities.clear();
    this.entitiesByTag.clear();
    this.allEntities.clear();

    for (RenderType renderType : RenderType.values()) {
      this.miscEntities.get(renderType).clear();
      this.renderListeners.get(renderType).clear();
      this.renderables.get(renderType).clear();
    }

    dispose(this.allEntities.values());
    dispose(this.triggers);
    this.emitters.clear();
    this.colliders.clear();
    this.props.clear();
    this.creatures.clear();
    this.staticShadows.clear();
    this.combatEntities.clear();
    this.mobileEntities.clear();
    this.lightSources.clear();
    this.spawnPoints.clear();
    this.soundSources.clear();
    this.mapAreas.clear();
    this.triggers.clear();

    this.ambientLight = null;
    this.staticShadowLayer = null;

    for (Map<Integer, IEntity> type : this.miscEntities.values()) {
      type.clear();
    }

    this.initialized = false;

    this.fireEvent(l -> l.cleared(this));
}private void load(final IEntity entity) {
    // an entity can only exist on one environment at a time, so remove it from the current one
    if (entity.getEnvironment() != null) {
      entity.getEnvironment().remove(entity);
    }

    // 1. add to physics engine
    loadPhysicsEntity(entity);

    // 2. register for update or activate
    loadUpdatableOrEmitterEntity(entity);

    // 3. if a gravity is defined, add a gravity force to the entity
    if (entity instanceof IMobileEntity && this.getGravity() != 0) {
      this.addGravityForce((IMobileEntity) entity);
    }

    // 4. attach all controllers
    entity.attachControllers();

    if (this.loaded && (entity instanceof LightSource || entity instanceof StaticShadow)) {
      this.updateLighting(entity);
    }

    entity.loaded(this);
}private void unload(final IEntity entity) {
    // 1. remove from physics engine
    if (entity instanceof ICollisionEntity) {
      Game.physics().remove((ICollisionEntity) entity);
    }

    // 2. unregister from update
    if (entity instanceof IUpdateable) {
      Game.loop().detach((IUpdateable) entity);
    }

    if (entity instanceof IMobileEntity) {
      this.removeGravity((IMobileEntity) entity);
    }

    // 3. detach all controllers
    entity.detachControllers();

    if (entity instanceof Emitter) {
      Emitter em = (Emitter) entity;
      em.deactivate();
    }

    if (this.loaded && (entity instanceof LightSource || entity instanceof StaticShadow)) {
      this.updateLighting(entity);
    }

    entity.removed(this);
}public void remove(final IEntity entity) {
    if (entity == null) {
      return;
    }

    this.allEntities.remove(entity.getMapId());
    Iterator<List<IEntity>> iter = this.layerEntities.values().iterator();
    while (iter.hasNext()) {
      List<IEntity> layer = iter.next();
      if (layer.remove(entity) && layer.isEmpty()) {
        iter.remove();
      }
    }
    if (this.miscEntities.get(entity.getRenderType()) != null) {
      this.miscEntities.get(entity.getRenderType()).values().remove(entity);
    }

    for (String tag : entity.getTags()) {
      if (this.getEntitiesByTag().containsKey(tag)) {
        this.getEntitiesByTag().get(tag).remove(entity);

        if (this.getEntitiesByTag().get(tag).isEmpty()) {
          this.getEntitiesByTag().remove(tag);
        }
      }
    }

    if (entity instanceof Emitter) {
      Emitter emitter = (Emitter) entity;
      this.removeEmitter(emitter);
    }

    if (entity instanceof MapArea) {
      this.mapAreas.remove(entity);
    }

    if (entity instanceof Prop) {
      this.props.remove(entity);
    }

    if (entity instanceof Creature) {
      this.creatures.remove(entity);
    }

    if (entity instanceof CollisionBox) {
      this.colliders.remove(entity);
      this.staticShadows.removeIf(x -> x.getOrigin() != null && x.getOrigin().equals(entity));
    }

    if (entity instanceof LightSource) {
      this.lightSources.remove(entity);
      this.updateLighting(entity);
    }

    if (entity instanceof Trigger) {
      this.triggers.remove(entity);
    }

    if (entity instanceof Spawnpoint) {
      this.spawnPoints.remove(entity);
    }
    if (entity instanceof SoundSource) {
      this.soundSources.remove(entity);
    }

    if (entity instanceof StaticShadow) {
      this.staticShadows.remove(entity);
      this.updateLighting(entity);
    }

    if (entity instanceof IMobileEntity) {
      this.mobileEntities.values().remove(entity);
    }

    if (entity instanceof ICombatEntity) {
      this.combatEntities.values().remove(entity);
    }

    this.unload(entity);

    this.fireEntityEvent(l -> l.entityRemoved(entity));
}
}
```
```java
class de.gurkenlabs.litiengine.physics.MovementController {
@Override
  public void update() {
    this.handleForces();
    this.handleMovement();
}
}
```
```java
class de.gurkenlabs.litiengine.Game {
static synchronized void terminate() {
    if (!initialized) {
      return;
    }

    hasStarted = false;
    initialized = false;

    config().save();
    gameLoop.terminate();
    tweenEngine.terminate();
    soundEngine.terminate();

    world().clear();

    for (final GameListener listener : gameListeners) {
      try {
        listener.terminated();
      } catch (Exception e) {
        log().log(Level.WARNING, "game listener threw an exception during shutdown", e);
      }
    }

    gameLoop = null;
    screenManager = null;
    gameWindow = null;
}public static synchronized void start() {
    if (!initialized) {
      throw new IllegalStateException(
          "The game cannot be started without being first initialized. Call Game.init(...) before Game.start().");
    }

    gameLoop.start();
    tweenEngine.start();
    soundEngine.start();

    for (final GameListener listener : gameListeners) {
      listener.started();
    }

    hasStarted = true;
}public static synchronized void init(String... args) {
    if (initialized) {
      log().log(Level.INFO, "The game has already been initialized.");
      return;
    }

    log.init();
    handleCommandLineArguments(args);

    config().load();
    Locale.setDefault(new Locale(config().client().getCountry(), config().client().getLanguage()));

    gameLoop = new GameLoop("Main Update Loop", config().client().getMaxFps());
    loop().attach(physics());
    loop().attach(world());

    // setup default exception handling for render and update loop
    setUncaughtExceptionHandler(
        new DefaultUncaughtExceptionHandler(config().client().exitOnError()));

    screenManager = new ScreenManager();
    gameWindow = new GameWindow();

    // initialize  the game window
    window().init();
    world.setCamera(new Camera());

    for (GameListener listener : gameListeners) {
      listener.initialized(args);
    }

    if (!isInNoGUIMode()) {
      window().getRenderComponent().onRendered(g -> metrics().render(g));

      graphics()
          .addEntityRenderedListener(
              e -> DebugRenderer.renderEntityDebugInfo(e.getGraphics(), e.getEntity()));

      window().getRenderComponent().onFpsChanged(fps -> metrics().setFramesPerSecond(fps));
      window()
          .setIcons(
              Arrays.asList(
                  Resources.images().get("liti-logo-x16.png"),
                  Resources.images().get("liti-logo-x20.png"),
                  Resources.images().get("liti-logo-x32.png"),
                  Resources.images().get("liti-logo-x48.png")));

      Input.keyboard()
          .onKeyTyped(
              KeyEvent.VK_PRINTSCREEN,
              key -> {
                // don't take a screenshot if a modifier is active
                if (key.getModifiers() != 0) {
                  return;
                }

                window().getRenderComponent().takeScreenshot();
              });
    }

    Runtime.getRuntime().addShutdownHook(new Thread(Game::terminate, "Shutdown"));

    initialized = true;
}
}
```


Response Format:
Provide the answer in **XML format** as follows:

#### If the method **cannot** return `null` at the specific call site:
```xml
<response>
  <reason><![CDATA[EXPLAIN WHY THE INVOCATION Game.loop() RESULT CANNOT BE NULL.]]></reason>
  <value>NO</value>
</response>

#### If the method can return null at the specific call site:
<response>
  <reason><![CDATA[EXPLAIN WHY THE INVOCATION Game.loop() RESULT CAN BE NULL.]]></reason>
  <value>YES</value>
</response>

#### If you are unsure or If there are any methods that directly or indirectly affect the return value and are not fully disclosed, request their declarations first, in the following format:
<response>
  <reason><![CDATA[EXPLAIN WHY THIS METHOD DECLARATION IS NECESSARY AND WHY YOU CANNOT MAKE A CONFIDENT DECISION WITHOUT IT]]></reason>
  <success>false</success>
  <methods>
    <method>methodName</method>
  </methods>
</response>

Additional Notes:
Be precise in your reasoning.
If a method’s return value depends on another method not provided, request its declaration before making a conclusion.
If the method can return null in this case but not in others, explain why it happens specifically for this call.

---ChatGPT.sendRequestToOpenAI---
Retrieving response from cache
---Response.<init>---
Creating Response:
```xml
<response>
  <reason><![CDATA[The method `Game.loop()` returns the static field `gameLoop`, which is initialized in the `Game.init(String... args)` method. In this method, a new `GameLoop` object is instantiated and assigned to `gameLoop`. Since `init()` must be called before `start()`, which is implied by the requirement of initializing the game, the `gameLoop` is guaranteed to be non-null during the lifetime of the game execution where `Game.loop()` is called. The absence of any code that could set `gameLoop` to null after its initialization ensures that `Game.loop()` cannot return null.]]></reason>
  <value>NO</value>
</response>
```
---Response.<init>---
Response created:
Disagreement: The method `Game.loop()` returns the static field `gameLoop`, which is initialized in the `Game.init(String... args)` method. In this method, a new `GameLoop` object is instantiated and assigned to `gameLoop`. Since `init()` must be called before `start()`, which is implied by the requirement of initializing the game, the `gameLoop` is guaranteed to be non-null during the lifetime of the game execution where `Game.loop()` is called. The absence of any code that could set `gameLoop` to null after its initialization ensures that `Game.loop()` cannot return null.
---AdvancedNullAwayCodeFix.resolveMethodDereferenceError---
Method is not returning nullable on call site. Injecting suppression annotation.
---AdvancedNullAwayCodeFix.constructCastToNonnullChange---
Constructing cast to nonnull change for reason: The method `Game.loop()` returns the static field `gameLoop`, which is initialized in the `Game.init(String... args)` method. In this method, a new `GameLoop` object is instantiated and assigned to `gameLoop`. Since `init()` must be called before `start()`, which is implied by the requirement of initializing the game, the `gameLoop` is guaranteed to be non-null during the lifetime of the game execution where `Game.loop()` is called. The absence of any code that could set `gameLoop` to null after its initialization ensures that `Game.loop()` cannot return null.
---ChatGPT.ask---
Asking ChatGPT:
For the reason you mentioned earlier:

"The method `Game.loop()` returns the static field `gameLoop`, which is initialized in the `Game.init(String... args)` method. In this method, a new `GameLoop` object is instantiated and assigned to `gameLoop`. Since `init()` must be called before `start()`, which is implied by the requirement of initializing the game, the `gameLoop` is guaranteed to be non-null during the lifetime of the game execution where `Game.loop()` is called. The absence of any code that could set `gameLoop` to null after its initialization ensures that `Game.loop()` cannot return null."

in the method below, the expression Game.loop() is not nullable at the point it is used.

```java
private void handleForces() {
    // clean up forces
    this.activeForces.forEach(
        x -> {
          if (x.hasEnded()) {
            this.activeForces.remove(x);
          }
        });

    if (this.activeForces.isEmpty()) {
      return;
    }

    // disable turn-on-move for force handling
    boolean turn = this.getEntity().turnOnMove();
    this.getEntity().setTurnOnMove(false);
    try {
      double deltaX = 0;
      double deltaY = 0;
      for (final Force force : this.activeForces) {
        if (force.cancelOnReached() && force.hasReached(this.getEntity())) {
          force.end();
          continue;
        }

        final Point2D collisionBoxCenter = this.getEntity().getCollisionBoxCenter();
        final double angle =
            GeometricUtilities.calcRotationAngleInDegrees(collisionBoxCenter, force.getLocation());
        final double strength =
            Game.loop().getDeltaTime() * 0.001f * force.getStrength() * Game.loop().getTimeScale();
        deltaX += GeometricUtilities.getDeltaX(angle, strength);
        deltaY += GeometricUtilities.getDeltaY(angle, strength);
      }

      final Point2D target =
          new Point2D.Double(this.getEntity().getX() + deltaX, this.getEntity().getY() + deltaY);
      final boolean success = Game.physics().move(this.getEntity(), target);
      if (!success) {
        for (final Force force : this.activeForces) {
          if (force.cancelOnCollision()) {
            force.end();
          }
        }
      }
    } finally {
      this.getEntity().setTurnOnMove(turn);
    }
}
```
Please Summarize the reason in max 5 words and rewrite the method so that at the line "            Game.loop().getDeltaTime() * 0.001f * force.getStrength() * Game.loop().getTimeScale();", at the occurrence of: "Game.loop()" is replaced with `NullabilityUtil.castToNonnull(Game.loop(), summary of reason)`
Replace "REASON" with the exact reason summary I provide to you (maximum 5 words), not with a generic explanation like "checked to be nonnull".
see the example below, for expression `foo.getBar()`, to wrap it with `NullabilityUtil.castToNonnull(foo.getBar(), "reason")`.

```java
public t(){
    String l = foo.getBar();
}
```

will be:
```java
public t(){
    String l = NullabilityUtil.castToNonnull(foo.getBar(), "checked to be nonnull");
}
```

### Instructions:

Do not import any additional classes.

Do not add Java comments.

Only modify relevant lines as required.

Return only the modified method wrapped in the XML format shown below.

Place the Java code inside the <code> tag using a CDATA block with ```java formatting.

Just give me the fixed code snippet in XML format in <response> tag like the example below. I will apply the fix to my codebase. Do not import any additional libraries or classes or add java comments. If you can provide the fixed code snippet, please provide it in the following format and place the code snippet in the <code> tag within ```java block.
<response>
  <success>true</success>
  <code><![CDATA[
  ```java
  Your fixed code snippet here
  ```
    ]]>
  </code>
</response>

---ChatGPT.sendRequestToOpenAI---
Sending request to OpenAI...
---ChatGPT.sendRequestToOpenAI---
Response received from OpenAI.
---Response.<init>---
Creating Response:
```xml
<response>
  <success>true</success>
  <code><![CDATA[
  ```java
  private void handleForces() {
      this.activeForces.forEach(
          x -> {
            if (x.hasEnded()) {
              this.activeForces.remove(x);
            }
          });

      if (this.activeForces.isEmpty()) {
        return;
      }

      boolean turn = this.getEntity().turnOnMove();
      this.getEntity().setTurnOnMove(false);
      try {
        double deltaX = 0;
        double deltaY = 0;
        for (final Force force : this.activeForces) {
          if (force.cancelOnReached() && force.hasReached(this.getEntity())) {
            force.end();
            continue;
          }

          final Point2D collisionBoxCenter = this.getEntity().getCollisionBoxCenter();
          final double angle =
              GeometricUtilities.calcRotationAngleInDegrees(collisionBoxCenter, force.getLocation());
          final double strength =
              NullabilityUtil.castToNonnull(Game.loop(), "guaranteed to be non-null").getDeltaTime() * 
              0.001f * force.getStrength() * 
              NullabilityUtil.castToNonnull(Game.loop(), "guaranteed to be non-null").getTimeScale();
          deltaX += GeometricUtilities.getDeltaX(angle, strength);
          deltaY += GeometricUtilities.getDeltaY(angle, strength);
        }

        final Point2D target =
            new Point2D.Double(this.getEntity().getX() + deltaX, this.getEntity().getY() + deltaY);
        final boolean success = Game.physics().move(this.getEntity(), target);
        if (!success) {
          for (final Force force : this.activeForces) {
            if (force.cancelOnCollision()) {
              force.end();
            }
          }
        }
      } finally {
        this.getEntity().setTurnOnMove(turn);
      }
  }
  ```
    ]]>
  </code>
</response>
```
---Response.<init>---
Response created:
private void handleForces() {
      this.activeForces.forEach(
          x -> {
            if (x.hasEnded()) {
              this.activeForces.remove(x);
            }
          });

      if (this.activeForces.isEmpty()) {
        return;
      }

      boolean turn = this.getEntity().turnOnMove();
      this.getEntity().setTurnOnMove(false);
      try {
        double deltaX = 0;
        double deltaY = 0;
        for (final Force force : this.activeForces) {
          if (force.cancelOnReached() && force.hasReached(this.getEntity())) {
            force.end();
            continue;
          }

          final Point2D collisionBoxCenter = this.getEntity().getCollisionBoxCenter();
          final double angle =
              GeometricUtilities.calcRotationAngleInDegrees(collisionBoxCenter, force.getLocation());
          final double strength =
              NullabilityUtil.castToNonnull(Game.loop(), "guaranteed to be non-null").getDeltaTime() * 
              0.001f * force.getStrength() * 
              NullabilityUtil.castToNonnull(Game.loop(), "guaranteed to be non-null").getTimeScale();
          deltaX += GeometricUtilities.getDeltaX(angle, strength);
          deltaY += GeometricUtilities.getDeltaY(angle, strength);
        }

        final Point2D target =
            new Point2D.Double(this.getEntity().getX() + deltaX, this.getEntity().getY() + deltaY);
        final boolean success = Game.physics().move(this.getEntity(), target);
        if (!success) {
          for (final Force force : this.activeForces) {
            if (force.cancelOnCollision()) {
              force.end();
            }
          }
        }
      } finally {
        this.getEntity().setTurnOnMove(turn);
      }
  }
---ChatGPT.fixDereferenceByAddingCastToNonnull---
Fixing the error by adding castToNonnull
---AdvancedNullAwayCodeFix.fixTriggeredErrorsForLocation---
Resolving unresolvable error for triggered error: Type='DEREFERENCE_NULLABLE', message='dereferenced expression Game.loop() is @Nullable'
/home/nima/Developer/nullness-benchmarks/litiengine/src/de/gurkenlabs/litiengine/entities/behavior/EntityNavigator.java:44
    Game.loop().attach(this);
---AdvancedNullAwayCodeFix.fix---
Fixing error: Type='DEREFERENCE_NULLABLE', message='dereferenced expression Game.loop() is @Nullable'
/home/nima/Developer/nullness-benchmarks/litiengine/src/de/gurkenlabs/litiengine/entities/behavior/EntityNavigator.java:44
    Game.loop().attach(this);
---AdvancedNullAwayCodeFix.resolveDereferenceError---
Resolving dereference error: Type='DEREFERENCE_NULLABLE', message='dereferenced expression Game.loop() is @Nullable'
/home/nima/Developer/nullness-benchmarks/litiengine/src/de/gurkenlabs/litiengine/entities/behavior/EntityNavigator.java:44
    Game.loop().attach(this);
---AdvancedNullAwayCodeFix.resolveDereferenceError---
Checking nullability possibility at error point
---ChatGPT.checkNullabilityPossibilityAtErrorPoint---
Asking if the expression can be null at error point point
---ChatGPT.ask---
Asking ChatGPT:
In the method below, is there a possibility that the expression "Game.loop()" at line "Game.loop().attach(this);" is null?
public EntityNavigator(final IMobileEntity entity, final PathFinder pathFinder) {
    this.cancelNavigationConditions = new CopyOnWriteArrayList<>();
    this.listeners = new CopyOnWriteArrayList<>();
    this.entity = entity;
    this.pathFinder = pathFinder;
    this.setAcceptableError(DEFAULT_ACCEPTABLE_ERROR);
    Game.loop().attach(this);
}
Give a single-word answer in XML format. If it is possible for the expression to be null, respond with:
```xml
<response>
    <reason><![CDATA[YOUR REASON]]></reason>
    <value>YES</value>
</response>
```
If it is not possible for the expression to be null, respond with:
```xml
<response>
    <reason><![CDATA[YOUR REASON]]></reason>
    <value>NO</value>
</response>
```
If you are unsure or need more information, respond with where you can ask for more details or what specific information you need.

If additional information is required, list each request inside a `<request>` tag. If no additional information is needed, omit the `<requests>` section.

Respond with:
```xml
<response>
    <reason><![CDATA[YOUR REASON]]></reason>
    <value>UNKNOWN</value>
    <!-- Include <requests> only if additional information is needed -->
    <requests>
        <request><![CDATA[YOUR REQUEST 1]]></request>
        <request><![CDATA[YOUR REQUEST 2]]></request>
    </requests>
</response>
```
---ChatGPT.sendRequestToOpenAI---
Sending request to OpenAI...
---ChatGPT.sendRequestToOpenAI---
Response received from OpenAI.
---Response.<init>---
Creating Response:
```xml
<response>
    <reason><![CDATA[The nullability of Game.loop() depends on the implementation of the Game class and its loop method, which is not provided in the context.]]></reason>
    <value>UNKNOWN</value>
    <requests>
        <request><![CDATA[Provide the implementation of the Game class, specifically the loop method.]]></request>
        <request><![CDATA[Clarify any nullable behavior or contract associated with Game.loop().]]></request>
    </requests>
</response>
```
---Response.<init>---
Response created:
Unknown: The nullability of Game.loop() depends on the implementation of the Game class and its loop method, which is not provided in the context.
---AdvancedNullAwayCodeFix.resolveMethodDereferenceError---
Resolving method dereference error.
---AdvancedNullAwayCodeFix.resolveMethodDereferenceError---
Method is in annotated package. Checking if the method is returning nullable.
---AdvancedNullAwayCodeFix.investigateMethodReturnNullability---
Checking if the method is returning nullable.
---ChatGPT.checkIfMethodIsReturningNullable---
Asking if the method is returning nullable: loop()
---ChatGPT.ask---
Asking ChatGPT:
In the method below, is there a possibility that the method returns null based only on its body? Consider the following points:

- The method may have multiple return paths; consider all return statements.
- If the method calls another method, do not assume its return value unless its full declaration is provided. Request its declaration if needed.
- The method may throw an exception instead of returning null. An exception path should not be considered a null return.
- Ensure you request the declarations of any methods whose return values directly or indirectly impact this method’s return value before making a conclusion.
- Carefully analyze all conditions and prior operations that may guarantee a non-null return value.

@Nullable public static IGameLoop loop() {
    return gameLoop;
}

Here are the method definitions in addition to the method inquired:

Depth: 0
```java
class de.gurkenlabs.litiengine.Game {
@Nullable public static IGameLoop loop() {
    return gameLoop;
}
}
```


Response Format:
Provide the answer in **XML format** as follows:

#### If the method **cannot** return `null`:
```xml
<response>
  <reason><![CDATA[EXPLAIN WHY THE METHOD CANNOT RETURN NULL]]></reason>
  <value>NO</value>
</response>
```

#### If the method can return null:
```xml
<response>
  <reason><![CDATA[EXPLAIN WHY THE METHOD CAN RETURN NULL]]></reason>
  <value>YES</value>
</response>
```

#### If you are unsure or need more information, respond with where you can ask for more details or what specific information you need.

#### If you are unsure or If there are any methods that directly or indirectly affect the return value and are not fully disclosed, request their declarations first, in the following format:
<response>
  <reason><![CDATA[YOUR REASON]]></reason>
  <value>UNKNOWN</value>
  <methods>
    <method>methodName</method>
  </methods>
</response>

If additional information is required other than method declaration, list each request inside a `<request>` tag. If no additional information is needed, omit the `<requests>` section.

Respond with:
```xml
<response>
    <reason><![CDATA[YOUR REASON]]></reason>
    <value>UNKNOWN</value>
    <!-- Include <requests> only if additional information is needed -->
    <requests>
        <request><![CDATA[YOUR REQUEST 1]]></request>
        <request><![CDATA[YOUR REQUEST 2]]></request>
    </requests>
</response>
```

Additional Notes:
Be precise in your reasoning.
If a method’s return value depends on another method not provided, request its declaration before making a conclusion.
If the method can return null in some cases but not others, explain under what conditions it can happen.

---ChatGPT.sendRequestToOpenAI---
Retrieving response from cache
---Response.<init>---
Creating Response:
```xml
<response>
  <reason><![CDATA[The method `loop` returns the variable `gameLoop`. Without the initialization or assignment details of `gameLoop`, it's unclear whether it can be null. The possibility of `gameLoop` being uninitialized or set to null elsewhere in the program means `loop` could potentially return null. Further information on `gameLoop` is required.]]></reason>
  <value>UNKNOWN</value>
  <requests>
    <request><![CDATA[Please provide the declaration and initialization of the variable `gameLoop` in the class `de.gurkenlabs.litiengine.Game`.]]></request>
  </requests>
</response>
```
---Response.<init>---
Response created:
Unknown: The method `loop` returns the variable `gameLoop`. Without the initialization or assignment details of `gameLoop`, it's unclear whether it can be null. The possibility of `gameLoop` being uninitialized or set to null elsewhere in the program means `loop` could potentially return null. Further information on `gameLoop` is required.
---AdvancedNullAwayCodeFix.investigateMethodReturnNullability---
Could not determine the nullability and model did not ask for any method.
---ChatGPT.checkIfMethodIsReturningNullableOnCallSite---
Asking if the method is returning nullable on the call site: Game.loop()
---ChatGPT.ask---
Asking ChatGPT:
In the method below, is there a possibility that the method returns null at the given call site?

```java
@Nullable public static IGameLoop loop() {
    return gameLoop;
}
```

## Guidelines:
- The method may have multiple return paths; consider all return statements.
- If the method calls another method, do not assume its return value unless its full declaration is provided. Request its declaration if needed.
- The method may throw an exception instead of returning null. An exception path should not be considered a null return.
- Ensure you request the declarations of any methods whose return values directly or indirectly impact this method’s return value before making a conclusion.
- If the method returns a value that is determined by a parameter, evaluate based on the actual argument at the given call site.
- Analyze based only on the specific invocation provided. Do not generalize to all possible inputs.- If the return value is guaranteed to be non-null at the call site, the answer should be a definitive NO.
- Do not generalize based on all possible inputs—your answer must be based only on the given invocation.
- Focus only on the given call site, not all possible invocations.

### call site:
Game.loop()

Here are the method definitions and the call chain for this method, showing the sequence of calls from the method to its callers at each depth level:

Depth: 0
```java
class de.gurkenlabs.litiengine.Game {
@Nullable public static IGameLoop loop() {
    return gameLoop;
}
}
```
Depth: 1
```java
class de.gurkenlabs.litiengine.environment.GameWorld {
public void loadEnvironment(@Nullable final Environment env) {
    Lock lock = Game.loop().getLock();
    lock.lock();
    try {
      unloadEnvironment();
      this.environment = env;
      if (env != null) {
        this.addEnvironment(env);

        if (env.getGravity() == 0 && this.gravity() != 0) {
          env.setGravity(this.gravity());
        }

        env.load();
        for (final EnvironmentLoadedListener listener : this.loadedListeners) {
          listener.loaded(env);
        }

        // call map specific listeners
        String mapName = getMapName(env);
        if (mapName != null && this.environmentLoadedListeners.containsKey(mapName)) {

          // for the default camera we center the camera on the environment
          if (this.camera().getClass().equals(Camera.class)) {
            camera().setFocus(env.getCenter());
          }

          for (EnvironmentLoadedListener listener : this.environmentLoadedListeners.get(mapName)) {
            listener.loaded(env);
          }
        }
      }
    } finally {
      lock.unlock();
    }
}public void setCamera(@Nullable final ICamera cam) {
    if (this.camera() != null) {
      Game.loop().detach(camera);
    }

    camera = cam;

    if (cam != null && !Game.isInNoGUIMode()) {
      Game.loop().attach(cam);
      cam.updateFocus();
    }
}
}
```
```java
class de.gurkenlabs.litiengine.entities.behavior.EntityNavigator {
public EntityNavigator(final IMobileEntity entity, final PathFinder pathFinder) {
    this.cancelNavigationConditions = new CopyOnWriteArrayList<>();
    this.listeners = new CopyOnWriteArrayList<>();
    this.entity = entity;
    this.pathFinder = pathFinder;
    this.setAcceptableError(DEFAULT_ACCEPTABLE_ERROR);
    Game.loop().attach(this);
}
}
```
```java
class de.gurkenlabs.litiengine.GameWindow {
private static void initializeWindowEventListeners(Window window) {

    window.addWindowStateListener(
        e -> {
          if (e.getNewState() == Frame.ICONIFIED) {
            Game.loop().setTickRate(ICONIFIED_MAX_FPS);
          } else {
            Game.loop().setTickRate(Game.config().client().getMaxFps());
          }
        });

    window.addWindowFocusListener(
        new WindowFocusListener() {
          @Override
          public void windowLostFocus(WindowEvent e) {
            if (Game.config().graphics().reduceFramesWhenNotFocused()) {
              Game.loop().setTickRate(NONE_FOCUS_MAX_FPS);
            }
          }

          @Override
          public void windowGainedFocus(WindowEvent e) {
            Game.loop().setTickRate(Game.config().client().getMaxFps());
          }
        });

    window.addWindowListener(
        new WindowAdapter() {
          @Override
          public void windowClosing(final WindowEvent event) {
            Game.exit();
          }
        });
}
}
```
```java
class de.gurkenlabs.litiengine.gui.screens.ScreenManager {
public void display(@Nullable final Screen screen) {
    if (Game.hasStarted() && Game.time().since(this.lastScreenChange) < this.getChangeCooldown()) {
      log.log(
          Level.INFO,
          "Skipping displaying of screen {0} because screen changing is currently on cooldown.",
          screen != null ? screen.getName() : "");
      return;
    }

    final Screen previous = this.current();
    if (previous != null) {
      previous.suspend();
    }

    if (screen != null && !this.screens.contains(screen)) {
      this.screens.add(screen);
    }

    this.currentScreen = screen;
    if (!Game.isInNoGUIMode() && this.current() != null) {
      this.current().prepare();
    }

    this.lastScreenChange = Game.loop().getTicks();

    final ScreenChangedEvent event = new ScreenChangedEvent(this.current(), previous);
    for (final ScreenChangedListener listener : this.screenChangedListeners) {
      listener.changed(event);
    }
}
}
```
```java
class de.gurkenlabs.litiengine.abilities.effects.Effect {
@Override
  public void update() {

    for (final Iterator<EffectApplication> iterator = this.getActiveAppliances().iterator();
        iterator.hasNext(); ) {
      final EffectApplication appliance = iterator.next();
      // if the effect duration is reached
      if (this.hasEnded(appliance)) {

        iterator.remove();
        this.cease(appliance);
      }
    }

    // 4. unregister if all appliances are finished
    if (this.getActiveAppliances().isEmpty()) {
      Game.loop().detach(this);
    }
}public void apply(final Shape impactArea) {
    final List<ICombatEntity> affected = this.lookForAffectedEntities(impactArea);
    for (final ICombatEntity affectedEntity : affected) {
      this.apply(affectedEntity);
    }

    this.appliances.add(new EffectApplication(affected, impactArea));

    // if it is the first appliance -> register for update
    if (this.appliances.size() == 1) {
      Game.loop().attach(this);
    }
}
}
```
```java
class de.gurkenlabs.litiengine.GameTime {
public long toTicks(final int milliseconds) {
    return this.toTicks(milliseconds, Game.loop().getTickRate());
}public long since(final long tick) {
    return toMilliseconds(Game.loop().getTicks() - tick);
}public long now() {
    return Game.loop().getTicks();
}public long sinceGameStart() {
    return this.toMilliseconds(Game.loop().getTicks());
}@Override
  public void loaded(Environment environment) {
    environmentLoaded = Game.loop().getTicks();
}public long toMilliseconds(final long ticks) {
    return this.toMilliseconds(ticks, Game.loop().getTickRate());
}
}
```
```java
class de.gurkenlabs.litiengine.GameMetrics {
@Override
  public void render(final Graphics2D g) {
    this.updateMetrics();

    if (!Game.config().client().showGameMetrics()) {
      return;
    }

    this.currentOffsetY = 0;

    g.setColor(this.renderColor);

    // render client metrics
    this.drawTitle(g, "[client]");
    this.drawMetric(g, "fps       : " + this.getFramesPerSecond());
    this.drawMetric(g, "max fps   : " + this.maxFramesPerSecond);
    this.drawMetric(g, "updatables: " + Game.loop().getUpdatableCount());

    // render jvm metrics if debug is enabled
    if (Game.config().debug().isDebugEnabled()) {
      this.drawTitle(g, "[jvm]");
      this.drawMetric(g, "java      : " + this.javaVersion);
      this.drawMetric(g, "memory    : " + String.format("%-5.5s", this.usedMemory) + " MB");
      this.drawMetric(g, "threads   : " + Thread.activeCount());
    }

    // render rendering metrics
    if (!this.renderMetrics.isEmpty()) {
      this.drawTitle(g, "[update]");

      for (RenderMetrics metric : this.renderMetrics) {
        this.drawMetric(g, metric.toString());
      }

      this.renderMetrics.clear();
    }
}
}
```
```java
class de.gurkenlabs.litiengine.graphics.emitters.Emitter {
public void deactivate() {
    if (!this.activated) {
      return;
    }

    this.activated = false;
    this.getParticles().clear();
    this.aliveTime = 0;
    this.activationTick = 0;
    this.lastSpawn = 0;
    Game.loop().detach(this);
}public void activate() {
    if (this.activated) {
      return;
    }

    this.activated = true;
    this.activationTick = Game.time().now();
    Game.loop().attach(this);
}@Override
  public void update() {
    if (this.isPaused()) {
      return;
    }

    // clear particles if the effect time to life is reached
    if (this.isFinished()) {
      for (EmitterFinishedListener listener : this.finishedListeners) {
        listener.finished(this);
      }

      this.delete();
      return;
    }

    final float updateRatio = (float) this.data().getUpdateRate() / Game.loop().getTickRate();
    for (final Particle p : this.getParticles().stream().collect(Collectors.toList())) {
      if (this.particleCanBeRemoved(p)) {
        // remove dead particles
        this.particles.remove(p);
        continue;
      }

      p.update(this.getOrigin(), updateRatio);
    }

    this.aliveTime = Game.time().since(this.activationTick);
    if ((this.data().getSpawnRate() == 0
        || Game.time().since(this.lastSpawn) >= this.data().getSpawnRate())) {
      this.lastSpawn = Game.time().now();
      this.spawnParticle();
    }
}
}
```
```java
class de.gurkenlabs.litiengine.entities.behavior.IBehaviorController {
public default void attach() {
    Game.loop().attach(this);
}public default void detach() {
    Game.loop().detach(this);
}
}
```
```java
class de.gurkenlabs.litiengine.abilities.AbilityExecution {
AbilityExecution(final Ability ability) {
    this.appliedEffects = new CopyOnWriteArrayList<>();
    this.ability = ability;
    this.executionTicks = Game.time().now();
    this.impactArea = ability.calculateImpactArea();
    this.castLocation = ability.getExecutor().getCenter();
    Game.loop().attach(this);
}@Override
  public void update() {
    // if there a no effects to apply -> unregister this instance and we're done
    if (this.getAbility().getEffects().isEmpty()
        || this.getAbility().getEffects().size() == this.getAppliedEffects().size()) {
      Game.loop().detach(this);
      return;
    }

    // handle all effects from the ability that were not applied yet
    for (final Effect effect : this.getAbility().getEffects()) {
      // if the ability was not executed yet or the delay of the effect is not
      // yet reached
      if (this.getAppliedEffects().contains(effect)
          || Game.time().since(this.getExecutionTicks()) < effect.getDelay()) {
        continue;
      }

      effect.apply(this.getExecutionImpactArea());
      this.getAppliedEffects().add(effect);
    }
}
}
```
```java
class de.gurkenlabs.litiengine.GameWindow$3 {
@Override
          public void windowGainedFocus(WindowEvent e) {
            Game.loop().setTickRate(Game.config().client().getMaxFps());
}@Override
          public void windowLostFocus(WindowEvent e) {
            if (Game.config().graphics().reduceFramesWhenNotFocused()) {
              Game.loop().setTickRate(NONE_FOCUS_MAX_FPS);
            }
}
}
```
```java
class de.gurkenlabs.litiengine.environment.EntitySpawner {
protected void spawnNewEntities() {
    if (this.getSpawnMode() != SpawnMode.CUSTOMSPAWNPOINTS && this.getSpawnPoints().isEmpty()) {
      return;
    }

    switch (this.getSpawnMode()) {
      case ALLSPAWNPOINTS:
        for (int i = 0; i < this.getSpawnPoints().size(); i++) {
          final int index = i;
          Game.loop()
              .perform(
                  this.getSpawnDelay() + this.getSpawnDelay() * i,
                  () -> this.spawn(this.getSpawnPoints().get(index), this.getSpawnAmount()));
        }
        break;
      case ONERANDOMSPAWNPOINT:
        this.spawn(Game.random().choose(this.getSpawnPoints()), this.getSpawnAmount());
        break;
      case RANDOMSPAWNPOINTS:
        for (int i = 0; i < this.getSpawnAmount(); i++) {
          Game.loop()
              .perform(
                  this.getSpawnDelay() + this.getSpawnDelay() * i,
                  () -> this.spawn(Game.random().choose(this.getSpawnPoints()), 1));
        }
        break;
      case CUSTOMSPAWNPOINTS:
        List<Spawnpoint> spawnPoints =
            this.customSpawnpoints != null
                ? this.customSpawnpoints.apply(this)
                : this.getCustomSpawnpoints();

        int index = 0;
        for (Spawnpoint spawn : spawnPoints) {
          Game.loop()
              .perform(
                  this.getSpawnDelay() + this.getSpawnDelay() * index, () -> this.spawn(spawn, 1));
          index++;
        }
        break;
      default:
        break;
    }
}
}
```
```java
class de.gurkenlabs.litiengine.tweening.TweenEngine {
@Override
  public void start() {
    Game.loop().attach(this);
}@Override
  public void terminate() {
    Game.loop().detach(this);
}
}
```
```java
class de.gurkenlabs.litiengine.gui.SpeechBubble {
public void hide() {
    Game.world().environment().removeRenderable(this);
    Game.loop().detach(this);
    if (activeSpeechBubbles.get(this.getEntity()) != null
        && activeSpeechBubbles.remove(this.getEntity()).equals(this)) {
      activeSpeechBubbles.remove(this.getEntity());
    }

    for (SpeechBubbleListener listener : this.listeners) {
      listener.hidden();
    }
}private SpeechBubble(
      final IEntity entity,
      final String text,
      @Nullable SpeechBubbleAppearance appearance,
      @Nullable Font font) {
    if (appearance == null) {
      this.appearance = DEFAULT_APPEARANCE;
    } else {
      this.appearance = appearance;
    }

    final SpeechBubble active = activeSpeechBubbles.get(entity);
    if (active != null) {
      active.hide();
    }
    this.setFont(font);

    this.textBoxWidth = (float) (entity.getWidth() * 4);
    this.entity = entity;

    this.currentText = text;
    this.currentTextDisplayTime = DISPLAYTIME_MIN + text.length() * DISPLAYTIME_PER_LETTER;

    this.lastTextDisplay = Game.time().now();
    this.createBubbleImage();
    entity.getEnvironment().add(this, RenderType.UI);
    Game.loop().attach(this);
    activeSpeechBubbles.put(entity, this);
}
}
```
```java
class de.gurkenlabs.litiengine.entities.Prop {
private void updateAnimationController() {
    IEntityAnimationController<?> controller = this.createAnimationController();
    this.getControllers().addController(controller);
    if (Game.world().environment() != null && Game.world().environment().isLoaded()) {
      Game.loop().attach(controller);
    }
}
}
```
```java
class de.gurkenlabs.litiengine.graphics.FreeFlightCamera {
public FreeFlightCamera(final Point2D focus) {
    this.setFocus(focus);
    this.velocity = DEFAULT_SCROLL_PIXELS_PER_SECOND;
    this.scrollPadding = DEFAULT_SCROLL_PADDING;
    this.setClampToMap(true);

    Game.loop().attach(this);
}private void handleFreeFlightCamera() {
    if (Game.world().environment() == null || Game.world().environment().getMap() == null) {
      return;
    }

    final Point2D mouseLocation = Input.mouse().getLocation();

    final double scrollSpeed =
        this.getVelocity()
            / (double) Game.loop().getTickRate()
            * Game.config().input().getMouseSensitivity();

    double x = this.getFocus().getX();
    double y = this.getFocus().getY();

    double deltaX = 0;
    if (mouseLocation.getX() < this.getScrollPadding()) {
      deltaX -= scrollSpeed;
    } else if (Game.window().getResolution().getWidth() - mouseLocation.getX()
        < this.getScrollPadding()) {
      deltaX += scrollSpeed;
    }

    double deltaY = 0;
    if (mouseLocation.getY() < this.getScrollPadding()) {
      deltaY -= scrollSpeed;
    } else if (Game.window().getResolution().getHeight() - mouseLocation.getY()
        < this.getScrollPadding()) {
      deltaY += scrollSpeed;
    }

    x += deltaX;
    y += deltaY;

    this.setFocus(new Point2D.Double(x, y));
}
}
```
```java
class de.gurkenlabs.litiengine.environment.Environment {
private static void dispose(final Collection<? extends IEntity> entities) {
    for (final IEntity entity : entities) {
      if (entity instanceof IUpdateable) {
        Game.loop().detach((IUpdateable) entity);
      }

      entity.detachControllers();
    }
}private static void loadUpdatableOrEmitterEntity(IEntity entity) {
    if (entity instanceof Emitter) {
      final Emitter emitter = (Emitter) entity;
      if (emitter.isActivateOnInit()) {
        emitter.activate();
      }
    } else if (entity instanceof IUpdateable) {
      Game.loop().attach((IUpdateable) entity);
    }
}private void unload(final IEntity entity) {
    // 1. remove from physics engine
    if (entity instanceof ICollisionEntity) {
      Game.physics().remove((ICollisionEntity) entity);
    }

    // 2. unregister from update
    if (entity instanceof IUpdateable) {
      Game.loop().detach((IUpdateable) entity);
    }

    if (entity instanceof IMobileEntity) {
      this.removeGravity((IMobileEntity) entity);
    }

    // 3. detach all controllers
    entity.detachControllers();

    if (entity instanceof Emitter) {
      Emitter em = (Emitter) entity;
      em.deactivate();
    }

    if (this.loaded && (entity instanceof LightSource || entity instanceof StaticShadow)) {
      this.updateLighting(entity);
    }

    entity.removed(this);
}
}
```
```java
class de.gurkenlabs.litiengine.graphics.animation.Animation {
@Override
  public void update() {
    // do nothing if the animation is not playing or the current keyframe is not finished
    if (!this.isPlaying()
        || Game.time().since(this.lastFrameUpdate) < this.getCurrentKeyFrame().getDuration()) {
      return;
    }

    // if we are not looping and the last keyframe is finished, we terminate the animation
    if (!this.isLooping() && this.isLastKeyFrame()) {
      this.terminate();
      return;
    }

    // make sure, we stay inside the keyframe list
    final int newFrameIndex =
        (this.getKeyframes().indexOf(this.currentFrame) + 1) % this.getKeyframes().size();
    final KeyFrame previousFrame = this.currentFrame;
    this.currentFrame = this.getKeyframes().get(newFrameIndex);

    for (KeyFrameListener listener : this.listeners) {
      listener.currentFrameChanged(previousFrame, this.currentFrame);
    }

    this.lastFrameUpdate = Game.loop().getTicks();
}public void restart() {
    this.currentFrame = this.firstFrame;
    this.lastFrameUpdate = Game.loop().getTicks();
}
}
```
```java
class de.gurkenlabs.litiengine.physics.MovementController {
@Override
  public void attach() {
    Game.loop().attach(this);
}private void handleForces() {
    // clean up forces
    this.activeForces.forEach(
        x -> {
          if (x.hasEnded()) {
            this.activeForces.remove(x);
          }
        });

    if (this.activeForces.isEmpty()) {
      return;
    }

    // disable turn-on-move for force handling
    boolean turn = this.getEntity().turnOnMove();
    this.getEntity().setTurnOnMove(false);
    try {
      double deltaX = 0;
      double deltaY = 0;
      for (final Force force : this.activeForces) {
        if (force.cancelOnReached() && force.hasReached(this.getEntity())) {
          force.end();
          continue;
        }

        final Point2D collisionBoxCenter = this.getEntity().getCollisionBoxCenter();
        final double angle =
            GeometricUtilities.calcRotationAngleInDegrees(collisionBoxCenter, force.getLocation());
        final double strength =
            Game.loop().getDeltaTime() * 0.001f * force.getStrength() * Game.loop().getTimeScale();
        deltaX += GeometricUtilities.getDeltaX(angle, strength);
        deltaY += GeometricUtilities.getDeltaY(angle, strength);
      }

      final Point2D target =
          new Point2D.Double(this.getEntity().getX() + deltaX, this.getEntity().getY() + deltaY);
      final boolean success = Game.physics().move(this.getEntity(), target);
      if (!success) {
        for (final Force force : this.activeForces) {
          if (force.cancelOnCollision()) {
            force.end();
          }
        }
      }
    } finally {
      this.getEntity().setTurnOnMove(turn);
    }
}@Override
  public void detach() {
    Game.loop().detach(this);
}public void handleMovement() {
    if (!this.isMovementAllowed()) {
      this.velocity = 0;
      return;
    }

    // max distance an entity can travel within one tick
    final double maxPixelsPerTick = this.getEntity().getTickVelocity();
    final double deltaTime = Game.loop().getDeltaTime() * Game.loop().getTimeScale();

    final double acceleration =
        this.getEntity().getAcceleration() == 0
            ? maxPixelsPerTick
            : deltaTime / this.getEntity().getAcceleration() * maxPixelsPerTick;
    final double deceleration =
        this.getEntity().getDeceleration() == 0
            ? this.getVelocity()
            : deltaTime / this.getEntity().getDeceleration() * maxPixelsPerTick;

    double dx = this.getDx();
    double dy = this.getDy();
    this.setDx(0);
    this.setDy(0);

    final double deltaVelocity =
        Math.min(Math.sqrt(Math.pow(dx, 2) + Math.pow(dy, 2)), acceleration);
    if (deltaVelocity != 0) {
      double newVelocity = this.getVelocity() + deltaVelocity;
      this.setVelocity(newVelocity);
    } else {
      final double newVelocity = Math.max(0, this.getVelocity() - deceleration);
      this.setVelocity(newVelocity);
      dx = GeometricUtilities.getDeltaX(this.moveAngle);
      dy = GeometricUtilities.getDeltaY(this.moveAngle);
    }

    if (this.getVelocity() == 0) {
      this.moveAngle = 0;
      return;
    }

    // actually move entity
    this.moveEntity(dx, dy);
}
}
```
```java
class de.gurkenlabs.litiengine.graphics.animation.AnimationController {
public void detach() {
    Game.loop().detach(this);
}public void attach() {
    Game.loop().attach(this);
}
}
```
```java
class de.gurkenlabs.litiengine.graphics.Camera {
@Override
  public void setZoom(final float targetZoom, final int delay) {
    if (delay == 0) {

      this.zoom = targetZoom;
      this.targetZoom = 0;
      this.zoomDelay = 0;
      this.zoomTick = 0;
      this.zoomStep = 0;

      final ZoomChangedEvent event = new ZoomChangedEvent(this, targetZoom);
      for (final ZoomChangedListener listener : this.zoomListeners) {
        listener.zoomChanged(event);
      }
    } else {
      this.zoomTick = Game.time().now();
      this.targetZoom = targetZoom;
      this.zoomDelay = delay;

      final double tickduration = 1000 / (double) Game.loop().getTickRate();
      final double tickAmount = delay / tickduration;
      final float totalDelta = this.targetZoom - this.zoom;
      this.zoomStep = tickAmount > 0 ? (float) (totalDelta / tickAmount) : totalDelta;
    }
}
}
```
```java
class de.gurkenlabs.litiengine.Game {
public static synchronized void init(String... args) {
    if (initialized) {
      log().log(Level.INFO, "The game has already been initialized.");
      return;
    }

    log.init();
    handleCommandLineArguments(args);

    config().load();
    Locale.setDefault(new Locale(config().client().getCountry(), config().client().getLanguage()));

    gameLoop = new GameLoop("Main Update Loop", config().client().getMaxFps());
    loop().attach(physics());
    loop().attach(world());

    // setup default exception handling for render and update loop
    setUncaughtExceptionHandler(
        new DefaultUncaughtExceptionHandler(config().client().exitOnError()));

    screenManager = new ScreenManager();
    gameWindow = new GameWindow();

    // initialize  the game window
    window().init();
    world.setCamera(new Camera());

    for (GameListener listener : gameListeners) {
      listener.initialized(args);
    }

    if (!isInNoGUIMode()) {
      window().getRenderComponent().onRendered(g -> metrics().render(g));

      graphics()
          .addEntityRenderedListener(
              e -> DebugRenderer.renderEntityDebugInfo(e.getGraphics(), e.getEntity()));

      window().getRenderComponent().onFpsChanged(fps -> metrics().setFramesPerSecond(fps));
      window()
          .setIcons(
              Arrays.asList(
                  Resources.images().get("liti-logo-x16.png"),
                  Resources.images().get("liti-logo-x20.png"),
                  Resources.images().get("liti-logo-x32.png"),
                  Resources.images().get("liti-logo-x48.png")));

      Input.keyboard()
          .onKeyTyped(
              KeyEvent.VK_PRINTSCREEN,
              key -> {
                // don't take a screenshot if a modifier is active
                if (key.getModifiers() != 0) {
                  return;
                }

                window().getRenderComponent().takeScreenshot();
              });
    }

    Runtime.getRuntime().addShutdownHook(new Thread(Game::terminate, "Shutdown"));

    initialized = true;
}
}
```
```java
class de.gurkenlabs.litiengine.entities.Creature {
protected void updateAnimationController() {
    IEntityAnimationController<?> controller = this.createAnimationController();
    this.getControllers().addController(controller);
    if (Game.world().environment() != null && Game.world().environment().isLoaded()) {
      Game.loop().attach(controller);
    }
}@Override
  public float getTickVelocity() {
    // pixels per ms multiplied by the passed ms
    // ensure that entities don't travel too far in case of lag
    return Math.min(Game.loop().getDeltaTime(), GameLoop.TICK_DELTATIME_LAG)
        * 0.001F
        * this.getVelocity().get()
        * Game.loop().getTimeScale();
}
}
```
Depth: 2
```java
class de.gurkenlabs.litiengine.environment.GameWorld {
public void clear() {
    this.unloadEnvironment();
    this.environments.clear();
    this.setCamera(null);
    Game.physics().clear();

    this.environmentListeners.clear();
    this.environmentLoadedListeners.clear();
    this.environmentUnloadedListeners.clear();

    this.listeners.clear();
    this.loadedListeners.clear();
    this.unloadedListeners.clear();
}@Nullable
  public Environment loadEnvironment(IMap map) {
    Environment env = this.getEnvironment(map);
    this.loadEnvironment(env);
    return env;
}@Nullable
  public Environment loadEnvironment(String mapName) {
    Environment env = this.getEnvironment(mapName);
    this.loadEnvironment(env);
    return env;
}
}
```
```java
class de.gurkenlabs.litiengine.GameWindow {
GameWindow() {
    this.hostControl = new JFrame();

    this.resolutionChangedListeners = new CopyOnWriteArrayList<>();

    this.renderCanvas = new RenderComponent(Game.config().graphics().getResolution());
    this.cursor = new MouseCursor();
    if (!Game.isInNoGUIMode()) {
      this.hostControl.setBackground(Color.BLACK);
      this.hostControl.add(this.renderCanvas);

      this.initializeEventListeners();

      this.hostControl.setTitle(Game.info().getTitle());
      this.hostControl.setDefaultCloseOperation(WindowConstants.DO_NOTHING_ON_CLOSE);
      initializeWindowEventListeners(this.hostControl);
    }
}
}
```
```java
class de.gurkenlabs.litiengine.GameTime {
public long sinceEnvironmentLoad() {
    return this.since(this.environmentLoaded);
}public long since(final long tick) {
    return toMilliseconds(Game.loop().getTicks() - tick);
}public long sinceGameStart() {
    return this.toMilliseconds(Game.loop().getTicks());
}
}
```
```java
class de.gurkenlabs.litiengine.abilities.effects.Effect {
protected void cease(final EffectApplication appliance) {
    // 1. cease the effect for all affected entities
    for (final ICombatEntity entity : appliance.getAffectedEntities()) {
      this.cease(entity);
    }

    // 2. apply follow up effects
    this.getFollowUpEffects().forEach(followUp -> followUp.apply(appliance.getImpactArea()));
}protected boolean hasEnded(final EffectApplication appliance) {
    final long effectDuration = Game.time().since(appliance.getAppliedTicks());
    return effectDuration > this.getDuration();
}
}
```
```java
class de.gurkenlabs.litiengine.abilities.effects.EffectApplication {
protected EffectApplication(final List<ICombatEntity> affectedEntities, final Shape impactArea) {
    this.applied = Game.time().now();
    this.affectedEntities = affectedEntities;
    this.impactArea = impactArea;
}
}
```
```java
class de.gurkenlabs.litiengine.entities.CombatEntity {
@Override
  public boolean wasHit(int timeSpan) {
    return Game.time().since(this.lastHit) < timeSpan;
}@Override
  public void hit(final int damage, @Nullable final Ability ability) {
    if (this.isDead()) {
      return;
    }

    if (!this.isIndestructible()) {
      this.getHitPoints().modifyBaseValue(new AttributeModifier<>(Modification.SUBTRACT, damage));
    }

    final EntityHitEvent event = new EntityHitEvent(this, ability, damage, this.isDead());

    for (final CombatEntityListener listener : this.listeners) {
      listener.hit(event);
    }

    for (final CombatEntityHitListener listener : this.hitListeners) {
      listener.hit(event);
    }

    if (this.isDead()) {
      this.fireDeathEvent();
      this.setCollision(false);
    }

    this.lastHit = Game.time().now();
}
}
```
```java
class de.gurkenlabs.litiengine.graphics.ImageEffect {
protected ImageEffect(final int ttl, final String name) {
    this.ttl = ttl;
    this.name = name;
    this.aliveTick = Game.time().now();
}@Override
  public long getAliveTime() {
    return Game.time().since(this.aliveTick);
}
}
```
```java
class de.gurkenlabs.litiengine.abilities.AbilityExecution {
AbilityExecution(final Ability ability) {
    this.appliedEffects = new CopyOnWriteArrayList<>();
    this.ability = ability;
    this.executionTicks = Game.time().now();
    this.impactArea = ability.calculateImpactArea();
    this.castLocation = ability.getExecutor().getCenter();
    Game.loop().attach(this);
}@Override
  public void update() {
    // if there a no effects to apply -> unregister this instance and we're done
    if (this.getAbility().getEffects().isEmpty()
        || this.getAbility().getEffects().size() == this.getAppliedEffects().size()) {
      Game.loop().detach(this);
      return;
    }

    // handle all effects from the ability that were not applied yet
    for (final Effect effect : this.getAbility().getEffects()) {
      // if the ability was not executed yet or the delay of the effect is not
      // yet reached
      if (this.getAppliedEffects().contains(effect)
          || Game.time().since(this.getExecutionTicks()) < effect.getDelay()) {
        continue;
      }

      effect.apply(this.getExecutionImpactArea());
      this.getAppliedEffects().add(effect);
    }
}
}
```
```java
class de.gurkenlabs.litiengine.tweening.TweenEngine {
@Override
  public void update() {
    for (final Tweenable target : this.getTweens().keySet()) {
      for (final Tween tween : this.getTweens().get(target).values()) {
        if (tween.hasStopped()) {
          continue;
        }
        final long elapsed = Game.time().since(tween.getStartTime());
        if (elapsed >= tween.getDuration()) {
          tween.stop();
          continue;
        }
        final float[] currentValues = new float[tween.getTargetValues().length];
        for (int i = 0; i < tween.getTargetValues().length; i++) {
          currentValues[i] =
              tween.getStartValues()[i]
                  + tween.getEquation().compute(elapsed / (float) tween.getDuration())
                      * (tween.getTargetValues()[i] - tween.getStartValues()[i]);
        }
        tween.getTarget().setTweenValues(tween.getType(), currentValues);
      }
    }
}
}
```
```java
class de.gurkenlabs.litiengine.gui.SpeechBubble {
public static SpeechBubble create(
      final IEntity entity, final String text, SpeechBubbleAppearance appearance, Font font) {
    return new SpeechBubble(entity, text, appearance, font);
}public static SpeechBubble create(final IEntity entity, final Font font, final String text) {
    SpeechBubbleAppearance app =
        new SpeechBubbleAppearance(
            DEFAULT_APPEARANCE.getForeColor(),
            DEFAULT_APPEARANCE.getBackgroundColor1(),
            DEFAULT_APPEARANCE.getBorderColor(),
            DEFAULT_APPEARANCE.getPadding());
    return new SpeechBubble(entity, text, app, font);
}public static SpeechBubble create(final IEntity entity, final String text) {
    return new SpeechBubble(entity, text, null, GuiProperties.getDefaultFont());
}@Override
  public void update() {
    if (this.currentText == null) {
      this.hide();
      return;
    }

    this.entityCenter = Game.world().camera().getViewportLocation(this.getEntity().getCenter());

    // old text was displayed long enough
    if (this.lastTextDisplay != 0
        && Game.time().since(this.lastTextDisplay) > this.currentTextDisplayTime) {
      this.currentText = null;
      this.lastTextDisplay = 0;
      return;
    }

    // display new text
    if (this.textIndex < this.currentText.length()
        && Game.time().since(this.lastCharPoll) > LETTER_WRITE_DELAY) {
      this.textIndex++;
      this.lastCharPoll = Game.time().now();
      if (this.typeSound != null) {
        Game.audio().playSound(this.typeSound, this.getEntity());
      }
    }

    // continue displaying currently displayed text
}private SpeechBubble(
      final IEntity entity,
      final String text,
      final Sound typeSound,
      SpeechBubbleAppearance appearance,
      Font font) {
    this(entity, text, appearance, font);
    this.typeSound = typeSound;
}private SpeechBubble(
      final IEntity entity,
      final String text,
      @Nullable SpeechBubbleAppearance appearance,
      @Nullable Font font) {
    if (appearance == null) {
      this.appearance = DEFAULT_APPEARANCE;
    } else {
      this.appearance = appearance;
    }

    final SpeechBubble active = activeSpeechBubbles.get(entity);
    if (active != null) {
      active.hide();
    }
    this.setFont(font);

    this.textBoxWidth = (float) (entity.getWidth() * 4);
    this.entity = entity;

    this.currentText = text;
    this.currentTextDisplayTime = DISPLAYTIME_MIN + text.length() * DISPLAYTIME_PER_LETTER;

    this.lastTextDisplay = Game.time().now();
    this.createBubbleImage();
    entity.getEnvironment().add(this, RenderType.UI);
    Game.loop().attach(this);
    activeSpeechBubbles.put(entity, this);
}
}
```
```java
class de.gurkenlabs.litiengine.gui.TextFieldComponent {
@Override
  public void render(final Graphics2D g) {
    super.render(g);
    g.setFont(this.getFont());
    final FontMetrics fm = g.getFontMetrics();

    if (this.isSelected() && Game.time().since(this.lastToggled) > this.flickerDelay) {
      this.cursorVisible = !this.cursorVisible;
      this.lastToggled = Game.time().now();
    }
    if (this.isSelected() && this.cursorVisible) {
      final Rectangle2D cursor =
          new Rectangle2D.Double(
              this.getX() + this.getTextX() + fm.stringWidth(this.getTextToRender(g)),
              this.getY() + this.getTextY(),
              this.getFont().getSize2D() * 3 / 5,
              this.getFont().getSize2D() * 1 / 5);
      g.setColor(this.getAppearance().getForeColor());
      g.fill(cursor);
    }
}
}
```
```java
class de.gurkenlabs.litiengine.entities.Prop {
public Prop(
      final Point2D location, @Nullable final String spritesheetName, final Material material) {
    super();
    this.rotation = Rotation.NONE;
    this.spritesheetName = spritesheetName;
    this.material = material;
    this.setLocation(location);
    this.updateAnimationController();
}public void setSpritesheetName(@Nullable final String spriteName) {
    this.spritesheetName = spriteName;
    this.updateAnimationController();
}
}
```
```java
class de.gurkenlabs.litiengine.tweening.Tween {
public Tween begin() {
    this.started = Game.time().now();
    this.stopped = false;
    return this;
}
}
```
```java
class de.gurkenlabs.litiengine.graphics.emitters.particles.Particle {
public void update(final Point2D emitterOrigin, final float updateRatio) {
    if (this.aliveTick == 0) {
      this.aliveTick = Game.time().now();
    }

    this.aliveTime = Game.time().since(this.aliveTick);
    if (this.timeToLiveReached()) {
      return;
    }

    if (this.colliding) {
      return;
    }

    if (this.getDeltaWidth() != 0) {
      this.width += this.getDeltaWidth() * updateRatio;
    }

    if (this.getDeltaHeight() != 0) {
      this.height += this.getDeltaHeight() * updateRatio;
    }

    if (this.getDeltaAngle() != 0) {
      this.angle += this.getDeltaAngle() * updateRatio;
    }

    // test for ray cast collision
    final float targetX = this.x + this.getVelocityX() * updateRatio;
    final float targetY = this.y + this.getVelocityY() * updateRatio;

    if (targetX == this.x && targetY == this.y) {
      return;
    }

    if (this.checkForCollision(emitterOrigin, targetX, targetY)) {
      return;
    }

    if (this.getVelocityX() != 0) {
      this.x = targetX;
    }

    if (this.getVelocityY() != 0) {
      this.y = targetY;
    }

    if (this.getAccelerationX() != 0) {
      this.velocityX += this.getAccelerationX() * updateRatio;
    }

    if (this.getAccelerationY() != 0) {
      this.velocityY += this.getAccelerationY() * updateRatio;
    }
}
}
```
```java
class de.gurkenlabs.litiengine.graphics.animation.Animation {
@Override
  public void start() {
    this.playing = true;
    if (this.getKeyframes().isEmpty()) {
      return;
    }

    this.restart();
}@Override
  public void update() {
    // do nothing if the animation is not playing or the current keyframe is not finished
    if (!this.isPlaying()
        || Game.time().since(this.lastFrameUpdate) < this.getCurrentKeyFrame().getDuration()) {
      return;
    }

    // if we are not looping and the last keyframe is finished, we terminate the animation
    if (!this.isLooping() && this.isLastKeyFrame()) {
      this.terminate();
      return;
    }

    // make sure, we stay inside the keyframe list
    final int newFrameIndex =
        (this.getKeyframes().indexOf(this.currentFrame) + 1) % this.getKeyframes().size();
    final KeyFrame previousFrame = this.currentFrame;
    this.currentFrame = this.getKeyframes().get(newFrameIndex);

    for (KeyFrameListener listener : this.listeners) {
      listener.currentFrameChanged(previousFrame, this.currentFrame);
    }

    this.lastFrameUpdate = Game.loop().getTicks();
}
}
```
```java
class de.gurkenlabs.litiengine.graphics.animation.AnimationController {
@Override
  public void update() {
    for (final Animation animation : this.getAll()) {
      animation.update();
    }

    if (this.getCurrent() != null && this.getCurrent().isPaused()) {
      return;
    }

    final boolean playbackFinished = this.getCurrent() != null && !this.getCurrent().isPlaying();
    if (playbackFinished) {
      for (final AnimationListener listener : this.listeners) {
        listener.finished(this.getCurrent());
      }
    }

    if (this.getCurrent() == null || playbackFinished) {
      if (this.getDefault() != null) {
        this.play(this.getDefault().getName());
      } else {
        this.currentAnimation = null;
      }
    }
}
}
```
```java
class de.gurkenlabs.litiengine.graphics.RenderComponent {
private void handleFade() {
    if (this.fadeOutStart != -1) {
      final long timePassed = Game.time().since(this.fadeOutStart);
      this.currentAlpha = MathUtilities.clamp(1 - timePassed / (float) this.fadeOutTime, 0, 1);
      if (this.currentAlpha == 0f) {
        this.fadeOutStart = -1;
        this.fadeOutTime = -1;
      }

      return;
    }

    if (this.fadeInStart != -1) {
      final long timePassed = Game.time().since(this.fadeInStart);
      this.currentAlpha = MathUtilities.clamp(timePassed / (float) this.fadeInTime, 0, 1);
      if (this.currentAlpha == 1f) {
        this.fadeInStart = -1;
        this.fadeInTime = -1;
        this.currentAlpha = Float.NaN;
      }
    }
}public void fadeOut(final int ms) {
    this.fadeInStart = -1;
    this.fadeInTime = -1;
    this.fadeOutStart = Game.time().now();
    this.fadeOutTime = ms;
}public void fadeIn(final int ms) {
    this.fadeOutStart = -1;
    this.fadeOutTime = -1;
    this.fadeInStart = Game.time().now();
    this.fadeInTime = ms;
}
}
```
```java
class de.gurkenlabs.litiengine.entities.Trigger {
private boolean activate(final IEntity activator, final int tar) {
    if (!this.isLoaded()
        || this.isOneTimeTrigger && this.isActivated
        || this.getActivationType() == TriggerActivation.COLLISION
            && activator != null
            && this.collisionActivated.contains(activator)) {
      return false;
    }

    if (this.getCooldown() > 0 && Game.time().since(this.lastActivation) < this.getCooldown()) {
      return false;
    }

    List<Integer> triggerTargets = this.getTargets(tar);

    final TriggerEvent te = new TriggerEvent(this, activator, triggerTargets);

    if (!this.checkActivationPredicates(te)) {
      return false;
    }

    this.isActivated = true;
    if (activator != null) {
      this.collisionActivated.add(activator);
    }

    // if we actually have a trigger target, we send the message to the target
    for (final int target : triggerTargets) {
      final IEntity entity = this.getEnvironment().get(target);
      if (entity == null) {
        log.log(
            Level.WARNING,
            "trigger [{0}] was activated, but the trigger target [{1}] could not be found on the environment",
            new Object[] {this, target});
        continue;
      }

      entity.sendMessage(this, this.message);
    }

    // also send the trigger event to all registered consumers
    for (final TriggerActivatedListener listener : this.activatedListeners) {
      listener.activated(te);
    }

    if (this.isOneTimeTrigger) {
      this.getEnvironment().remove(this);
    }

    this.lastActivation = Game.time().now();
    return true;
}
}
```
```java
class de.gurkenlabs.litiengine.graphics.Camera {
private boolean isShakeEffectActive() {
    return this.getShakeTick() != 0
        && Game.time().since(this.getShakeTick()) < this.getShakeDuration();
}@Override
  public void update() {
    if (Game.world().camera() != null && !Game.world().camera().equals(this)) {
      return;
    }

    if (this.targetZoom > 0) {
      if (Game.time().since(this.zoomTick) >= this.zoomDelay) {
        this.zoom = this.targetZoom;
        this.targetZoom = 0;
        this.zoomDelay = 0;
        this.zoomTick = 0;
        this.zoomStep = 0;
      } else {
        this.zoom += this.zoomStep;
      }

      final ZoomChangedEvent event = new ZoomChangedEvent(this, this.getZoom());
      for (final ZoomChangedListener listener : this.zoomListeners) {
        listener.zoomChanged(event);
      }
    }

    if (this.panTime > 0) {
      if (--this.panTime <= 0) {
        this.setFocus(this.targetFocus);
        this.targetFocus = null;
      } else {
        double diff = this.panTime / (this.panTime + 1.0);
        this.focus =
            new Point2D.Double(
                this.focus.getX() * diff + this.targetFocus.getX() * (1.0 - diff),
                this.focus.getY() * diff + this.targetFocus.getY() * (1.0 - diff));
      }
    }

    if (!this.isShakeEffectActive()) {
      this.shakeOffsetX = 0;
      this.shakeOffsetY = 0;
      return;
    }

    if (Game.time().since(this.lastShake) > this.shakeDelay) {
      this.shakeOffsetX = this.getShakeIntensity() * ThreadLocalRandom.current().nextGaussian();
      this.shakeOffsetY = this.getShakeIntensity() * ThreadLocalRandom.current().nextGaussian();
      this.lastShake = Game.time().now();
    }
}@Override
  public void setZoom(final float targetZoom, final int delay) {
    if (delay == 0) {

      this.zoom = targetZoom;
      this.targetZoom = 0;
      this.zoomDelay = 0;
      this.zoomTick = 0;
      this.zoomStep = 0;

      final ZoomChangedEvent event = new ZoomChangedEvent(this, targetZoom);
      for (final ZoomChangedListener listener : this.zoomListeners) {
        listener.zoomChanged(event);
      }
    } else {
      this.zoomTick = Game.time().now();
      this.targetZoom = targetZoom;
      this.zoomDelay = delay;

      final double tickduration = 1000 / (double) Game.loop().getTickRate();
      final double tickAmount = delay / tickduration;
      final float totalDelta = this.targetZoom - this.zoom;
      this.zoomStep = tickAmount > 0 ? (float) (totalDelta / tickAmount) : totalDelta;
    }
}@Override
  public void shake(final double intensity, final int delay, final int shakeDuration) {
    this.shakeTick = Game.time().now();
    this.shakeDelay = delay;
    this.shakeIntensity = intensity;
    this.shakeDuration = shakeDuration;
}
}
```
```java
class de.gurkenlabs.litiengine.entities.Creature {
public void setSpritesheetName(String spritesheetName) {
    if (this.spritesheetName != null && this.spritesheetName.equals(spritesheetName)) {
      return;
    }

    this.spritesheetName = spritesheetName;
    this.updateAnimationController();
}public boolean isIdle() {
    return Game.time().since(this.lastMoved) > IDLE_DELAY;
}@Override
  public void setLocation(final Point2D position) {
    if (this.isDead() || position == null) {
      return;
    }

    final Point2D oldLocation = this.getLocation();
    super.setLocation(position);

    if (Game.hasStarted() && this.isLoaded()) {
      this.lastMoved = Game.time().now();
      this.fireMovedEvent(
          new EntityMovedEvent(
              this, this.getX() - oldLocation.getX(), this.getY() - oldLocation.getY()));
    }
}
}
```
```java
class de.gurkenlabs.litiengine.gui.screens.ScreenManager {
public void display(final String screenName) {
    if (this.current() != null && this.current().getName().equalsIgnoreCase(screenName)) {
      log.log(
          Level.INFO,
          "Skipping displaying of screen {0} because it is already the current screen.",
          screenName);
      return;
    }

    if (this.screens.stream()
        .noneMatch(element -> element.getName().equalsIgnoreCase(screenName))) {
      log.log(
          Level.WARNING,
          "Could not display the screen {0} because there is no screen with the specified name.",
          screenName);
      return;
    }

    Screen screen = this.get(screenName);
    if (screen == null) {
      return;
    }

    this.display(screen);
}public void add(final Screen screen) {
    screen.setWidth(Game.window().getWidth());
    screen.setHeight(Game.window().getHeight());
    this.screens.add(screen);

    if (this.current() == null) {
      this.display(screen);
    }
}public void remove(Screen screen) {
    this.screens.remove(screen);
    if (this.current() == screen) {
      if (!this.screens.isEmpty()) {
        this.display(this.screens.get(0));
      } else {
        this.display((Screen) null);
      }
    }
}public void display(@Nullable final Screen screen) {
    if (Game.hasStarted() && Game.time().since(this.lastScreenChange) < this.getChangeCooldown()) {
      log.log(
          Level.INFO,
          "Skipping displaying of screen {0} because screen changing is currently on cooldown.",
          screen != null ? screen.getName() : "");
      return;
    }

    final Screen previous = this.current();
    if (previous != null) {
      previous.suspend();
    }

    if (screen != null && !this.screens.contains(screen)) {
      this.screens.add(screen);
    }

    this.currentScreen = screen;
    if (!Game.isInNoGUIMode() && this.current() != null) {
      this.current().prepare();
    }

    this.lastScreenChange = Game.loop().getTicks();

    final ScreenChangedEvent event = new ScreenChangedEvent(this.current(), previous);
    for (final ScreenChangedListener listener : this.screenChangedListeners) {
      listener.changed(event);
    }
}
}
```
```java
class de.gurkenlabs.litiengine.abilities.Ability {
public boolean isOnCooldown() {
    return (this.getCurrentExecution() != null
        && this.getCurrentExecution().getExecutionTicks() > 0
        && Game.time().since(this.getCurrentExecution().getExecutionTicks())
            < this.getAttributes().cooldown().get());
}public boolean isActive() {
    return this.getCurrentExecution() != null
        && Game.time().since(this.getCurrentExecution().getExecutionTicks())
            < this.getAttributes().duration().get();
}@Nullable
  public AbilityExecution cast() {
    if (!this.canCast()) {
      return null;
    }
    this.currentExecution = new AbilityExecution(this);

    for (final AbilityCastListener listener : this.abilityCastListeners) {
      listener.abilityCast(this.currentExecution);
    }

    return this.getCurrentExecution();
}public float getRemainingCooldownInSeconds() {
    if (this.getCurrentExecution() == null
        || this.getExecutor() == null
        || this.getExecutor().isDead()) {
      return 0;
    }

    // calculate cooldown in seconds
    return (float)
        (!this.canCast()
            ? (this.getAttributes().cooldown().get()
                    - Game.time().since(this.getCurrentExecution().getExecutionTicks()))
                * 0.001
            : 0);
}
}
```
```java
class de.gurkenlabs.litiengine.entities.EntityHitEvent {
EntityHitEvent(
      final ICombatEntity hitEntity,
      @Nullable final Ability ability,
      final int damage,
      final boolean kill) {
    super(hitEntity);
    this.executor = ability != null ? ability.getExecutor() : null;
    this.hitEntity = hitEntity;
    this.ability = ability;
    this.damage = damage;
    this.kill = kill;
    this.time = Game.time().now();
}
}
```
```java
class de.gurkenlabs.litiengine.graphics.emitters.Emitter {
public void delete() {
    this.deactivate();
    if (Game.world().environment() != null) {
      Game.world().environment().remove(this);
    }
}public void activate() {
    if (this.activated) {
      return;
    }

    this.activated = true;
    this.activationTick = Game.time().now();
    Game.loop().attach(this);
}@Override
  public void update() {
    if (this.isPaused()) {
      return;
    }

    // clear particles if the effect time to life is reached
    if (this.isFinished()) {
      for (EmitterFinishedListener listener : this.finishedListeners) {
        listener.finished(this);
      }

      this.delete();
      return;
    }

    final float updateRatio = (float) this.data().getUpdateRate() / Game.loop().getTickRate();
    for (final Particle p : this.getParticles().stream().collect(Collectors.toList())) {
      if (this.particleCanBeRemoved(p)) {
        // remove dead particles
        this.particles.remove(p);
        continue;
      }

      p.update(this.getOrigin(), updateRatio);
    }

    this.aliveTime = Game.time().since(this.activationTick);
    if ((this.data().getSpawnRate() == 0
        || Game.time().since(this.lastSpawn) >= this.data().getSpawnRate())) {
      this.lastSpawn = Game.time().now();
      this.spawnParticle();
    }
}
}
```
```java
class de.gurkenlabs.litiengine.GameLoop {
@Override
  public int perform(int delay, Runnable action) {
    final long d = Game.time().toTicks(delay);

    TimedAction a = new TimedAction(this.getTicks() + d, action);
    this.actions.add(a);

    return a.getId();
}
}
```
```java
class de.gurkenlabs.litiengine.environment.EntitySpawner {
protected boolean shouldSpawn() {
    return this.lastSpawnWave == 0
        || Game.time().since(this.lastSpawnWave) >= this.getSpawnInterval();
}@Override
  public void update() {
    if (!this.shouldSpawn()) {
      return;
    }

    this.spawnNewEntities();
    this.lastSpawnWave = Game.time().now();
}
}
```
```java
class de.gurkenlabs.litiengine.graphics.FreeFlightCamera {
@Override
  public void update() {
    this.handleFreeFlightCamera();
}public FreeFlightCamera(double x, double y) {
    this(new Point2D.Double(x, y));
}
}
```
```java
class de.gurkenlabs.litiengine.environment.Environment {
public void unload() {
    if (!this.loaded) {
      return;
    }

    // unregister all updatable entities from the current environment
    for (final IEntity entity : this.allEntities.values()) {
      this.unload(entity);
    }

    this.loaded = false;
    this.fireEvent(l -> l.unloaded(this));
}private static void loadUpdatableOrEmitterEntity(IEntity entity) {
    if (entity instanceof Emitter) {
      final Emitter emitter = (Emitter) entity;
      if (emitter.isActivateOnInit()) {
        emitter.activate();
      }
    } else if (entity instanceof IUpdateable) {
      Game.loop().attach((IUpdateable) entity);
    }
}public void clear() {
    Game.physics().clear();

    this.combatEntities.clear();
    this.mobileEntities.clear();
    this.gravityForces.clear();
    this.layerEntities.clear();
    this.entitiesByTag.clear();
    this.allEntities.clear();

    for (RenderType renderType : RenderType.values()) {
      this.miscEntities.get(renderType).clear();
      this.renderListeners.get(renderType).clear();
      this.renderables.get(renderType).clear();
    }

    dispose(this.allEntities.values());
    dispose(this.triggers);
    this.emitters.clear();
    this.colliders.clear();
    this.props.clear();
    this.creatures.clear();
    this.staticShadows.clear();
    this.combatEntities.clear();
    this.mobileEntities.clear();
    this.lightSources.clear();
    this.spawnPoints.clear();
    this.soundSources.clear();
    this.mapAreas.clear();
    this.triggers.clear();

    this.ambientLight = null;
    this.staticShadowLayer = null;

    for (Map<Integer, IEntity> type : this.miscEntities.values()) {
      type.clear();
    }

    this.initialized = false;

    this.fireEvent(l -> l.cleared(this));
}private void load(final IEntity entity) {
    // an entity can only exist on one environment at a time, so remove it from the current one
    if (entity.getEnvironment() != null) {
      entity.getEnvironment().remove(entity);
    }

    // 1. add to physics engine
    loadPhysicsEntity(entity);

    // 2. register for update or activate
    loadUpdatableOrEmitterEntity(entity);

    // 3. if a gravity is defined, add a gravity force to the entity
    if (entity instanceof IMobileEntity && this.getGravity() != 0) {
      this.addGravityForce((IMobileEntity) entity);
    }

    // 4. attach all controllers
    entity.attachControllers();

    if (this.loaded && (entity instanceof LightSource || entity instanceof StaticShadow)) {
      this.updateLighting(entity);
    }

    entity.loaded(this);
}private void unload(final IEntity entity) {
    // 1. remove from physics engine
    if (entity instanceof ICollisionEntity) {
      Game.physics().remove((ICollisionEntity) entity);
    }

    // 2. unregister from update
    if (entity instanceof IUpdateable) {
      Game.loop().detach((IUpdateable) entity);
    }

    if (entity instanceof IMobileEntity) {
      this.removeGravity((IMobileEntity) entity);
    }

    // 3. detach all controllers
    entity.detachControllers();

    if (entity instanceof Emitter) {
      Emitter em = (Emitter) entity;
      em.deactivate();
    }

    if (this.loaded && (entity instanceof LightSource || entity instanceof StaticShadow)) {
      this.updateLighting(entity);
    }

    entity.removed(this);
}public void remove(final IEntity entity) {
    if (entity == null) {
      return;
    }

    this.allEntities.remove(entity.getMapId());
    Iterator<List<IEntity>> iter = this.layerEntities.values().iterator();
    while (iter.hasNext()) {
      List<IEntity> layer = iter.next();
      if (layer.remove(entity) && layer.isEmpty()) {
        iter.remove();
      }
    }
    if (this.miscEntities.get(entity.getRenderType()) != null) {
      this.miscEntities.get(entity.getRenderType()).values().remove(entity);
    }

    for (String tag : entity.getTags()) {
      if (this.getEntitiesByTag().containsKey(tag)) {
        this.getEntitiesByTag().get(tag).remove(entity);

        if (this.getEntitiesByTag().get(tag).isEmpty()) {
          this.getEntitiesByTag().remove(tag);
        }
      }
    }

    if (entity instanceof Emitter) {
      Emitter emitter = (Emitter) entity;
      this.removeEmitter(emitter);
    }

    if (entity instanceof MapArea) {
      this.mapAreas.remove(entity);
    }

    if (entity instanceof Prop) {
      this.props.remove(entity);
    }

    if (entity instanceof Creature) {
      this.creatures.remove(entity);
    }

    if (entity instanceof CollisionBox) {
      this.colliders.remove(entity);
      this.staticShadows.removeIf(x -> x.getOrigin() != null && x.getOrigin().equals(entity));
    }

    if (entity instanceof LightSource) {
      this.lightSources.remove(entity);
      this.updateLighting(entity);
    }

    if (entity instanceof Trigger) {
      this.triggers.remove(entity);
    }

    if (entity instanceof Spawnpoint) {
      this.spawnPoints.remove(entity);
    }
    if (entity instanceof SoundSource) {
      this.soundSources.remove(entity);
    }

    if (entity instanceof StaticShadow) {
      this.staticShadows.remove(entity);
      this.updateLighting(entity);
    }

    if (entity instanceof IMobileEntity) {
      this.mobileEntities.values().remove(entity);
    }

    if (entity instanceof ICombatEntity) {
      this.combatEntities.values().remove(entity);
    }

    this.unload(entity);

    this.fireEntityEvent(l -> l.entityRemoved(entity));
}
}
```
```java
class de.gurkenlabs.litiengine.physics.MovementController {
@Override
  public void update() {
    this.handleForces();
    this.handleMovement();
}
}
```
```java
class de.gurkenlabs.litiengine.Game {
static synchronized void terminate() {
    if (!initialized) {
      return;
    }

    hasStarted = false;
    initialized = false;

    config().save();
    gameLoop.terminate();
    tweenEngine.terminate();
    soundEngine.terminate();

    world().clear();

    for (final GameListener listener : gameListeners) {
      try {
        listener.terminated();
      } catch (Exception e) {
        log().log(Level.WARNING, "game listener threw an exception during shutdown", e);
      }
    }

    gameLoop = null;
    screenManager = null;
    gameWindow = null;
}public static synchronized void start() {
    if (!initialized) {
      throw new IllegalStateException(
          "The game cannot be started without being first initialized. Call Game.init(...) before Game.start().");
    }

    gameLoop.start();
    tweenEngine.start();
    soundEngine.start();

    for (final GameListener listener : gameListeners) {
      listener.started();
    }

    hasStarted = true;
}public static synchronized void init(String... args) {
    if (initialized) {
      log().log(Level.INFO, "The game has already been initialized.");
      return;
    }

    log.init();
    handleCommandLineArguments(args);

    config().load();
    Locale.setDefault(new Locale(config().client().getCountry(), config().client().getLanguage()));

    gameLoop = new GameLoop("Main Update Loop", config().client().getMaxFps());
    loop().attach(physics());
    loop().attach(world());

    // setup default exception handling for render and update loop
    setUncaughtExceptionHandler(
        new DefaultUncaughtExceptionHandler(config().client().exitOnError()));

    screenManager = new ScreenManager();
    gameWindow = new GameWindow();

    // initialize  the game window
    window().init();
    world.setCamera(new Camera());

    for (GameListener listener : gameListeners) {
      listener.initialized(args);
    }

    if (!isInNoGUIMode()) {
      window().getRenderComponent().onRendered(g -> metrics().render(g));

      graphics()
          .addEntityRenderedListener(
              e -> DebugRenderer.renderEntityDebugInfo(e.getGraphics(), e.getEntity()));

      window().getRenderComponent().onFpsChanged(fps -> metrics().setFramesPerSecond(fps));
      window()
          .setIcons(
              Arrays.asList(
                  Resources.images().get("liti-logo-x16.png"),
                  Resources.images().get("liti-logo-x20.png"),
                  Resources.images().get("liti-logo-x32.png"),
                  Resources.images().get("liti-logo-x48.png")));

      Input.keyboard()
          .onKeyTyped(
              KeyEvent.VK_PRINTSCREEN,
              key -> {
                // don't take a screenshot if a modifier is active
                if (key.getModifiers() != 0) {
                  return;
                }

                window().getRenderComponent().takeScreenshot();
              });
    }

    Runtime.getRuntime().addShutdownHook(new Thread(Game::terminate, "Shutdown"));

    initialized = true;
}
}
```


Response Format:
Provide the answer in **XML format** as follows:

#### If the method **cannot** return `null` at the specific call site:
```xml
<response>
  <reason><![CDATA[EXPLAIN WHY THE INVOCATION Game.loop() RESULT CANNOT BE NULL.]]></reason>
  <value>NO</value>
</response>

#### If the method can return null at the specific call site:
<response>
  <reason><![CDATA[EXPLAIN WHY THE INVOCATION Game.loop() RESULT CAN BE NULL.]]></reason>
  <value>YES</value>
</response>

#### If you are unsure or If there are any methods that directly or indirectly affect the return value and are not fully disclosed, request their declarations first, in the following format:
<response>
  <reason><![CDATA[EXPLAIN WHY THIS METHOD DECLARATION IS NECESSARY AND WHY YOU CANNOT MAKE A CONFIDENT DECISION WITHOUT IT]]></reason>
  <success>false</success>
  <methods>
    <method>methodName</method>
  </methods>
</response>

Additional Notes:
Be precise in your reasoning.
If a method’s return value depends on another method not provided, request its declaration before making a conclusion.
If the method can return null in this case but not in others, explain why it happens specifically for this call.

---ChatGPT.sendRequestToOpenAI---
Retrieving response from cache
---Response.<init>---
Creating Response:
```xml
<response>
  <reason><![CDATA[The method `Game.loop()` returns the static field `gameLoop`, which is initialized in the `Game.init(String... args)` method. In this method, a new `GameLoop` object is instantiated and assigned to `gameLoop`. Since `init()` must be called before `start()`, which is implied by the requirement of initializing the game, the `gameLoop` is guaranteed to be non-null during the lifetime of the game execution where `Game.loop()` is called. The absence of any code that could set `gameLoop` to null after its initialization ensures that `Game.loop()` cannot return null.]]></reason>
  <value>NO</value>
</response>
```
---Response.<init>---
Response created:
Disagreement: The method `Game.loop()` returns the static field `gameLoop`, which is initialized in the `Game.init(String... args)` method. In this method, a new `GameLoop` object is instantiated and assigned to `gameLoop`. Since `init()` must be called before `start()`, which is implied by the requirement of initializing the game, the `gameLoop` is guaranteed to be non-null during the lifetime of the game execution where `Game.loop()` is called. The absence of any code that could set `gameLoop` to null after its initialization ensures that `Game.loop()` cannot return null.
---AdvancedNullAwayCodeFix.resolveMethodDereferenceError---
Method is not returning nullable on call site. Injecting suppression annotation.
---AdvancedNullAwayCodeFix.constructCastToNonnullChange---
Constructing cast to nonnull change for reason: The method `Game.loop()` returns the static field `gameLoop`, which is initialized in the `Game.init(String... args)` method. In this method, a new `GameLoop` object is instantiated and assigned to `gameLoop`. Since `init()` must be called before `start()`, which is implied by the requirement of initializing the game, the `gameLoop` is guaranteed to be non-null during the lifetime of the game execution where `Game.loop()` is called. The absence of any code that could set `gameLoop` to null after its initialization ensures that `Game.loop()` cannot return null.
---ChatGPT.ask---
Asking ChatGPT:
For the reason you mentioned earlier:

"The method `Game.loop()` returns the static field `gameLoop`, which is initialized in the `Game.init(String... args)` method. In this method, a new `GameLoop` object is instantiated and assigned to `gameLoop`. Since `init()` must be called before `start()`, which is implied by the requirement of initializing the game, the `gameLoop` is guaranteed to be non-null during the lifetime of the game execution where `Game.loop()` is called. The absence of any code that could set `gameLoop` to null after its initialization ensures that `Game.loop()` cannot return null."

in the method below, the expression Game.loop() is not nullable at the point it is used.

```java
public EntityNavigator(final IMobileEntity entity, final PathFinder pathFinder) {
    this.cancelNavigationConditions = new CopyOnWriteArrayList<>();
    this.listeners = new CopyOnWriteArrayList<>();
    this.entity = entity;
    this.pathFinder = pathFinder;
    this.setAcceptableError(DEFAULT_ACCEPTABLE_ERROR);
    Game.loop().attach(this);
}
```
Please Summarize the reason in max 5 words and rewrite the method so that at the line "    Game.loop().attach(this);", at the occurrence of: "Game.loop()" is replaced with `NullabilityUtil.castToNonnull(Game.loop(), summary of reason)`
Replace "REASON" with the exact reason summary I provide to you (maximum 5 words), not with a generic explanation like "checked to be nonnull".
see the example below, for expression `foo.getBar()`, to wrap it with `NullabilityUtil.castToNonnull(foo.getBar(), "reason")`.

```java
public t(){
    String l = foo.getBar();
}
```

will be:
```java
public t(){
    String l = NullabilityUtil.castToNonnull(foo.getBar(), "checked to be nonnull");
}
```

### Instructions:

Do not import any additional classes.

Do not add Java comments.

Only modify relevant lines as required.

Return only the modified method wrapped in the XML format shown below.

Place the Java code inside the <code> tag using a CDATA block with ```java formatting.

Just give me the fixed code snippet in XML format in <response> tag like the example below. I will apply the fix to my codebase. Do not import any additional libraries or classes or add java comments. If you can provide the fixed code snippet, please provide it in the following format and place the code snippet in the <code> tag within ```java block.
<response>
  <success>true</success>
  <code><![CDATA[
  ```java
  Your fixed code snippet here
  ```
    ]]>
  </code>
</response>

---ChatGPT.sendRequestToOpenAI---
Sending request to OpenAI...
---ChatGPT.sendRequestToOpenAI---
Response received from OpenAI.
---Response.<init>---
Creating Response:
<response>
  <success>true</success>
  <code><![CDATA[
  ```java
public EntityNavigator(final IMobileEntity entity, final PathFinder pathFinder) {
    this.cancelNavigationConditions = new CopyOnWriteArrayList<>();
    this.listeners = new CopyOnWriteArrayList<>();
    this.entity = entity;
    this.pathFinder = pathFinder;
    this.setAcceptableError(DEFAULT_ACCEPTABLE_ERROR);
    NullabilityUtil.castToNonnull(Game.loop(), "init must be called").attach(this);
}
  ```
    ]]>
  </code>
</response>
---Response.<init>---
Response created:
public EntityNavigator(final IMobileEntity entity, final PathFinder pathFinder) {
    this.cancelNavigationConditions = new CopyOnWriteArrayList<>();
    this.listeners = new CopyOnWriteArrayList<>();
    this.entity = entity;
    this.pathFinder = pathFinder;
    this.setAcceptableError(DEFAULT_ACCEPTABLE_ERROR);
    NullabilityUtil.castToNonnull(Game.loop(), "init must be called").attach(this);
}
---ChatGPT.fixDereferenceByAddingCastToNonnull---
Fixing the error by adding castToNonnull
---AdvancedNullAwayCodeFix.fixTriggeredErrorsForLocation---
Resolving unresolvable error for triggered error: Type='DEREFERENCE_NULLABLE', message='dereferenced expression Game.loop() is @Nullable'
/home/nima/Developer/nullness-benchmarks/litiengine/src/de/gurkenlabs/litiengine/environment/GameWorld.java:515
      Game.loop().detach(camera);
---AdvancedNullAwayCodeFix.fix---
Fixing error: Type='DEREFERENCE_NULLABLE', message='dereferenced expression Game.loop() is @Nullable'
/home/nima/Developer/nullness-benchmarks/litiengine/src/de/gurkenlabs/litiengine/environment/GameWorld.java:515
      Game.loop().detach(camera);
---AdvancedNullAwayCodeFix.resolveDereferenceError---
Resolving dereference error: Type='DEREFERENCE_NULLABLE', message='dereferenced expression Game.loop() is @Nullable'
/home/nima/Developer/nullness-benchmarks/litiengine/src/de/gurkenlabs/litiengine/environment/GameWorld.java:515
      Game.loop().detach(camera);
---AdvancedNullAwayCodeFix.resolveDereferenceError---
Checking nullability possibility at error point
---ChatGPT.checkNullabilityPossibilityAtErrorPoint---
Asking if the expression can be null at error point point
---ChatGPT.ask---
Asking ChatGPT:
In the method below, is there a possibility that the expression "Game.loop()" at line "Game.loop().detach(camera);" is null?
public void setCamera(@Nullable final ICamera cam) {
    if (this.camera() != null) {
      Game.loop().detach(camera);
    }

    camera = cam;

    if (cam != null && !Game.isInNoGUIMode()) {
      Game.loop().attach(cam);
      cam.updateFocus();
    }
}
Give a single-word answer in XML format. If it is possible for the expression to be null, respond with:
```xml
<response>
    <reason><![CDATA[YOUR REASON]]></reason>
    <value>YES</value>
</response>
```
If it is not possible for the expression to be null, respond with:
```xml
<response>
    <reason><![CDATA[YOUR REASON]]></reason>
    <value>NO</value>
</response>
```
If you are unsure or need more information, respond with where you can ask for more details or what specific information you need.

If additional information is required, list each request inside a `<request>` tag. If no additional information is needed, omit the `<requests>` section.

Respond with:
```xml
<response>
    <reason><![CDATA[YOUR REASON]]></reason>
    <value>UNKNOWN</value>
    <!-- Include <requests> only if additional information is needed -->
    <requests>
        <request><![CDATA[YOUR REQUEST 1]]></request>
        <request><![CDATA[YOUR REQUEST 2]]></request>
    </requests>
</response>
```
---ChatGPT.sendRequestToOpenAI---
Sending request to OpenAI...
---ChatGPT.sendRequestToOpenAI---
Response received from OpenAI.
---Response.<init>---
Creating Response:
```xml
<response>
    <reason><![CDATA[The possibility of Game.loop() being null depends on the implementation details of the Game class, which are not provided here.]]></reason>
    <value>UNKNOWN</value>
    <requests>
        <request><![CDATA[Information on how Game.loop() is implemented and if it can return null.]]></request>
    </requests>
</response>
```
---Response.<init>---
Response created:
Unknown: The possibility of Game.loop() being null depends on the implementation details of the Game class, which are not provided here.
---AdvancedNullAwayCodeFix.resolveMethodDereferenceError---
Resolving method dereference error.
---AdvancedNullAwayCodeFix.resolveMethodDereferenceError---
Method is in annotated package. Checking if the method is returning nullable.
---AdvancedNullAwayCodeFix.investigateMethodReturnNullability---
Checking if the method is returning nullable.
---ChatGPT.checkIfMethodIsReturningNullable---
Asking if the method is returning nullable: loop()
---ChatGPT.ask---
Asking ChatGPT:
In the method below, is there a possibility that the method returns null based only on its body? Consider the following points:

- The method may have multiple return paths; consider all return statements.
- If the method calls another method, do not assume its return value unless its full declaration is provided. Request its declaration if needed.
- The method may throw an exception instead of returning null. An exception path should not be considered a null return.
- Ensure you request the declarations of any methods whose return values directly or indirectly impact this method’s return value before making a conclusion.
- Carefully analyze all conditions and prior operations that may guarantee a non-null return value.

@Nullable public static IGameLoop loop() {
    return gameLoop;
}

Here are the method definitions in addition to the method inquired:

Depth: 0
```java
class de.gurkenlabs.litiengine.Game {
@Nullable public static IGameLoop loop() {
    return gameLoop;
}
}
```


Response Format:
Provide the answer in **XML format** as follows:

#### If the method **cannot** return `null`:
```xml
<response>
  <reason><![CDATA[EXPLAIN WHY THE METHOD CANNOT RETURN NULL]]></reason>
  <value>NO</value>
</response>
```

#### If the method can return null:
```xml
<response>
  <reason><![CDATA[EXPLAIN WHY THE METHOD CAN RETURN NULL]]></reason>
  <value>YES</value>
</response>
```

#### If you are unsure or need more information, respond with where you can ask for more details or what specific information you need.

#### If you are unsure or If there are any methods that directly or indirectly affect the return value and are not fully disclosed, request their declarations first, in the following format:
<response>
  <reason><![CDATA[YOUR REASON]]></reason>
  <value>UNKNOWN</value>
  <methods>
    <method>methodName</method>
  </methods>
</response>

If additional information is required other than method declaration, list each request inside a `<request>` tag. If no additional information is needed, omit the `<requests>` section.

Respond with:
```xml
<response>
    <reason><![CDATA[YOUR REASON]]></reason>
    <value>UNKNOWN</value>
    <!-- Include <requests> only if additional information is needed -->
    <requests>
        <request><![CDATA[YOUR REQUEST 1]]></request>
        <request><![CDATA[YOUR REQUEST 2]]></request>
    </requests>
</response>
```

Additional Notes:
Be precise in your reasoning.
If a method’s return value depends on another method not provided, request its declaration before making a conclusion.
If the method can return null in some cases but not others, explain under what conditions it can happen.

---ChatGPT.sendRequestToOpenAI---
Retrieving response from cache
---Response.<init>---
Creating Response:
```xml
<response>
  <reason><![CDATA[The method `loop` returns the variable `gameLoop`. Without the initialization or assignment details of `gameLoop`, it's unclear whether it can be null. The possibility of `gameLoop` being uninitialized or set to null elsewhere in the program means `loop` could potentially return null. Further information on `gameLoop` is required.]]></reason>
  <value>UNKNOWN</value>
  <requests>
    <request><![CDATA[Please provide the declaration and initialization of the variable `gameLoop` in the class `de.gurkenlabs.litiengine.Game`.]]></request>
  </requests>
</response>
```
---Response.<init>---
Response created:
Unknown: The method `loop` returns the variable `gameLoop`. Without the initialization or assignment details of `gameLoop`, it's unclear whether it can be null. The possibility of `gameLoop` being uninitialized or set to null elsewhere in the program means `loop` could potentially return null. Further information on `gameLoop` is required.
---AdvancedNullAwayCodeFix.investigateMethodReturnNullability---
Could not determine the nullability and model did not ask for any method.
---ChatGPT.checkIfMethodIsReturningNullableOnCallSite---
Asking if the method is returning nullable on the call site: Game.loop()
---ChatGPT.ask---
Asking ChatGPT:
In the method below, is there a possibility that the method returns null at the given call site?

```java
@Nullable public static IGameLoop loop() {
    return gameLoop;
}
```

## Guidelines:
- The method may have multiple return paths; consider all return statements.
- If the method calls another method, do not assume its return value unless its full declaration is provided. Request its declaration if needed.
- The method may throw an exception instead of returning null. An exception path should not be considered a null return.
- Ensure you request the declarations of any methods whose return values directly or indirectly impact this method’s return value before making a conclusion.
- If the method returns a value that is determined by a parameter, evaluate based on the actual argument at the given call site.
- Analyze based only on the specific invocation provided. Do not generalize to all possible inputs.- If the return value is guaranteed to be non-null at the call site, the answer should be a definitive NO.
- Do not generalize based on all possible inputs—your answer must be based only on the given invocation.
- Focus only on the given call site, not all possible invocations.

### call site:
Game.loop()

Here are the method definitions and the call chain for this method, showing the sequence of calls from the method to its callers at each depth level:

Depth: 0
```java
class de.gurkenlabs.litiengine.Game {
@Nullable public static IGameLoop loop() {
    return gameLoop;
}
}
```
Depth: 1
```java
class de.gurkenlabs.litiengine.environment.GameWorld {
public void loadEnvironment(@Nullable final Environment env) {
    Lock lock = Game.loop().getLock();
    lock.lock();
    try {
      unloadEnvironment();
      this.environment = env;
      if (env != null) {
        this.addEnvironment(env);

        if (env.getGravity() == 0 && this.gravity() != 0) {
          env.setGravity(this.gravity());
        }

        env.load();
        for (final EnvironmentLoadedListener listener : this.loadedListeners) {
          listener.loaded(env);
        }

        // call map specific listeners
        String mapName = getMapName(env);
        if (mapName != null && this.environmentLoadedListeners.containsKey(mapName)) {

          // for the default camera we center the camera on the environment
          if (this.camera().getClass().equals(Camera.class)) {
            camera().setFocus(env.getCenter());
          }

          for (EnvironmentLoadedListener listener : this.environmentLoadedListeners.get(mapName)) {
            listener.loaded(env);
          }
        }
      }
    } finally {
      lock.unlock();
    }
}public void setCamera(@Nullable final ICamera cam) {
    if (this.camera() != null) {
      Game.loop().detach(camera);
    }

    camera = cam;

    if (cam != null && !Game.isInNoGUIMode()) {
      Game.loop().attach(cam);
      cam.updateFocus();
    }
}
}
```
```java
class de.gurkenlabs.litiengine.entities.behavior.EntityNavigator {
public EntityNavigator(final IMobileEntity entity, final PathFinder pathFinder) {
    this.cancelNavigationConditions = new CopyOnWriteArrayList<>();
    this.listeners = new CopyOnWriteArrayList<>();
    this.entity = entity;
    this.pathFinder = pathFinder;
    this.setAcceptableError(DEFAULT_ACCEPTABLE_ERROR);
    Game.loop().attach(this);
}
}
```
```java
class de.gurkenlabs.litiengine.GameWindow {
private static void initializeWindowEventListeners(Window window) {

    window.addWindowStateListener(
        e -> {
          if (e.getNewState() == Frame.ICONIFIED) {
            Game.loop().setTickRate(ICONIFIED_MAX_FPS);
          } else {
            Game.loop().setTickRate(Game.config().client().getMaxFps());
          }
        });

    window.addWindowFocusListener(
        new WindowFocusListener() {
          @Override
          public void windowLostFocus(WindowEvent e) {
            if (Game.config().graphics().reduceFramesWhenNotFocused()) {
              Game.loop().setTickRate(NONE_FOCUS_MAX_FPS);
            }
          }

          @Override
          public void windowGainedFocus(WindowEvent e) {
            Game.loop().setTickRate(Game.config().client().getMaxFps());
          }
        });

    window.addWindowListener(
        new WindowAdapter() {
          @Override
          public void windowClosing(final WindowEvent event) {
            Game.exit();
          }
        });
}
}
```
```java
class de.gurkenlabs.litiengine.gui.screens.ScreenManager {
public void display(@Nullable final Screen screen) {
    if (Game.hasStarted() && Game.time().since(this.lastScreenChange) < this.getChangeCooldown()) {
      log.log(
          Level.INFO,
          "Skipping displaying of screen {0} because screen changing is currently on cooldown.",
          screen != null ? screen.getName() : "");
      return;
    }

    final Screen previous = this.current();
    if (previous != null) {
      previous.suspend();
    }

    if (screen != null && !this.screens.contains(screen)) {
      this.screens.add(screen);
    }

    this.currentScreen = screen;
    if (!Game.isInNoGUIMode() && this.current() != null) {
      this.current().prepare();
    }

    this.lastScreenChange = Game.loop().getTicks();

    final ScreenChangedEvent event = new ScreenChangedEvent(this.current(), previous);
    for (final ScreenChangedListener listener : this.screenChangedListeners) {
      listener.changed(event);
    }
}
}
```
```java
class de.gurkenlabs.litiengine.abilities.effects.Effect {
@Override
  public void update() {

    for (final Iterator<EffectApplication> iterator = this.getActiveAppliances().iterator();
        iterator.hasNext(); ) {
      final EffectApplication appliance = iterator.next();
      // if the effect duration is reached
      if (this.hasEnded(appliance)) {

        iterator.remove();
        this.cease(appliance);
      }
    }

    // 4. unregister if all appliances are finished
    if (this.getActiveAppliances().isEmpty()) {
      Game.loop().detach(this);
    }
}public void apply(final Shape impactArea) {
    final List<ICombatEntity> affected = this.lookForAffectedEntities(impactArea);
    for (final ICombatEntity affectedEntity : affected) {
      this.apply(affectedEntity);
    }

    this.appliances.add(new EffectApplication(affected, impactArea));

    // if it is the first appliance -> register for update
    if (this.appliances.size() == 1) {
      Game.loop().attach(this);
    }
}
}
```
```java
class de.gurkenlabs.litiengine.GameTime {
public long toTicks(final int milliseconds) {
    return this.toTicks(milliseconds, Game.loop().getTickRate());
}public long since(final long tick) {
    return toMilliseconds(Game.loop().getTicks() - tick);
}public long now() {
    return Game.loop().getTicks();
}public long sinceGameStart() {
    return this.toMilliseconds(Game.loop().getTicks());
}@Override
  public void loaded(Environment environment) {
    environmentLoaded = Game.loop().getTicks();
}public long toMilliseconds(final long ticks) {
    return this.toMilliseconds(ticks, Game.loop().getTickRate());
}
}
```
```java
class de.gurkenlabs.litiengine.GameMetrics {
@Override
  public void render(final Graphics2D g) {
    this.updateMetrics();

    if (!Game.config().client().showGameMetrics()) {
      return;
    }

    this.currentOffsetY = 0;

    g.setColor(this.renderColor);

    // render client metrics
    this.drawTitle(g, "[client]");
    this.drawMetric(g, "fps       : " + this.getFramesPerSecond());
    this.drawMetric(g, "max fps   : " + this.maxFramesPerSecond);
    this.drawMetric(g, "updatables: " + Game.loop().getUpdatableCount());

    // render jvm metrics if debug is enabled
    if (Game.config().debug().isDebugEnabled()) {
      this.drawTitle(g, "[jvm]");
      this.drawMetric(g, "java      : " + this.javaVersion);
      this.drawMetric(g, "memory    : " + String.format("%-5.5s", this.usedMemory) + " MB");
      this.drawMetric(g, "threads   : " + Thread.activeCount());
    }

    // render rendering metrics
    if (!this.renderMetrics.isEmpty()) {
      this.drawTitle(g, "[update]");

      for (RenderMetrics metric : this.renderMetrics) {
        this.drawMetric(g, metric.toString());
      }

      this.renderMetrics.clear();
    }
}
}
```
```java
class de.gurkenlabs.litiengine.graphics.emitters.Emitter {
public void deactivate() {
    if (!this.activated) {
      return;
    }

    this.activated = false;
    this.getParticles().clear();
    this.aliveTime = 0;
    this.activationTick = 0;
    this.lastSpawn = 0;
    Game.loop().detach(this);
}public void activate() {
    if (this.activated) {
      return;
    }

    this.activated = true;
    this.activationTick = Game.time().now();
    Game.loop().attach(this);
}@Override
  public void update() {
    if (this.isPaused()) {
      return;
    }

    // clear particles if the effect time to life is reached
    if (this.isFinished()) {
      for (EmitterFinishedListener listener : this.finishedListeners) {
        listener.finished(this);
      }

      this.delete();
      return;
    }

    final float updateRatio = (float) this.data().getUpdateRate() / Game.loop().getTickRate();
    for (final Particle p : this.getParticles().stream().collect(Collectors.toList())) {
      if (this.particleCanBeRemoved(p)) {
        // remove dead particles
        this.particles.remove(p);
        continue;
      }

      p.update(this.getOrigin(), updateRatio);
    }

    this.aliveTime = Game.time().since(this.activationTick);
    if ((this.data().getSpawnRate() == 0
        || Game.time().since(this.lastSpawn) >= this.data().getSpawnRate())) {
      this.lastSpawn = Game.time().now();
      this.spawnParticle();
    }
}
}
```
```java
class de.gurkenlabs.litiengine.entities.behavior.IBehaviorController {
public default void attach() {
    Game.loop().attach(this);
}public default void detach() {
    Game.loop().detach(this);
}
}
```
```java
class de.gurkenlabs.litiengine.abilities.AbilityExecution {
AbilityExecution(final Ability ability) {
    this.appliedEffects = new CopyOnWriteArrayList<>();
    this.ability = ability;
    this.executionTicks = Game.time().now();
    this.impactArea = ability.calculateImpactArea();
    this.castLocation = ability.getExecutor().getCenter();
    Game.loop().attach(this);
}@Override
  public void update() {
    // if there a no effects to apply -> unregister this instance and we're done
    if (this.getAbility().getEffects().isEmpty()
        || this.getAbility().getEffects().size() == this.getAppliedEffects().size()) {
      Game.loop().detach(this);
      return;
    }

    // handle all effects from the ability that were not applied yet
    for (final Effect effect : this.getAbility().getEffects()) {
      // if the ability was not executed yet or the delay of the effect is not
      // yet reached
      if (this.getAppliedEffects().contains(effect)
          || Game.time().since(this.getExecutionTicks()) < effect.getDelay()) {
        continue;
      }

      effect.apply(this.getExecutionImpactArea());
      this.getAppliedEffects().add(effect);
    }
}
}
```
```java
class de.gurkenlabs.litiengine.GameWindow$3 {
@Override
          public void windowGainedFocus(WindowEvent e) {
            Game.loop().setTickRate(Game.config().client().getMaxFps());
}@Override
          public void windowLostFocus(WindowEvent e) {
            if (Game.config().graphics().reduceFramesWhenNotFocused()) {
              Game.loop().setTickRate(NONE_FOCUS_MAX_FPS);
            }
}
}
```
```java
class de.gurkenlabs.litiengine.environment.EntitySpawner {
protected void spawnNewEntities() {
    if (this.getSpawnMode() != SpawnMode.CUSTOMSPAWNPOINTS && this.getSpawnPoints().isEmpty()) {
      return;
    }

    switch (this.getSpawnMode()) {
      case ALLSPAWNPOINTS:
        for (int i = 0; i < this.getSpawnPoints().size(); i++) {
          final int index = i;
          Game.loop()
              .perform(
                  this.getSpawnDelay() + this.getSpawnDelay() * i,
                  () -> this.spawn(this.getSpawnPoints().get(index), this.getSpawnAmount()));
        }
        break;
      case ONERANDOMSPAWNPOINT:
        this.spawn(Game.random().choose(this.getSpawnPoints()), this.getSpawnAmount());
        break;
      case RANDOMSPAWNPOINTS:
        for (int i = 0; i < this.getSpawnAmount(); i++) {
          Game.loop()
              .perform(
                  this.getSpawnDelay() + this.getSpawnDelay() * i,
                  () -> this.spawn(Game.random().choose(this.getSpawnPoints()), 1));
        }
        break;
      case CUSTOMSPAWNPOINTS:
        List<Spawnpoint> spawnPoints =
            this.customSpawnpoints != null
                ? this.customSpawnpoints.apply(this)
                : this.getCustomSpawnpoints();

        int index = 0;
        for (Spawnpoint spawn : spawnPoints) {
          Game.loop()
              .perform(
                  this.getSpawnDelay() + this.getSpawnDelay() * index, () -> this.spawn(spawn, 1));
          index++;
        }
        break;
      default:
        break;
    }
}
}
```
```java
class de.gurkenlabs.litiengine.tweening.TweenEngine {
@Override
  public void start() {
    Game.loop().attach(this);
}@Override
  public void terminate() {
    Game.loop().detach(this);
}
}
```
```java
class de.gurkenlabs.litiengine.gui.SpeechBubble {
public void hide() {
    Game.world().environment().removeRenderable(this);
    Game.loop().detach(this);
    if (activeSpeechBubbles.get(this.getEntity()) != null
        && activeSpeechBubbles.remove(this.getEntity()).equals(this)) {
      activeSpeechBubbles.remove(this.getEntity());
    }

    for (SpeechBubbleListener listener : this.listeners) {
      listener.hidden();
    }
}private SpeechBubble(
      final IEntity entity,
      final String text,
      @Nullable SpeechBubbleAppearance appearance,
      @Nullable Font font) {
    if (appearance == null) {
      this.appearance = DEFAULT_APPEARANCE;
    } else {
      this.appearance = appearance;
    }

    final SpeechBubble active = activeSpeechBubbles.get(entity);
    if (active != null) {
      active.hide();
    }
    this.setFont(font);

    this.textBoxWidth = (float) (entity.getWidth() * 4);
    this.entity = entity;

    this.currentText = text;
    this.currentTextDisplayTime = DISPLAYTIME_MIN + text.length() * DISPLAYTIME_PER_LETTER;

    this.lastTextDisplay = Game.time().now();
    this.createBubbleImage();
    entity.getEnvironment().add(this, RenderType.UI);
    Game.loop().attach(this);
    activeSpeechBubbles.put(entity, this);
}
}
```
```java
class de.gurkenlabs.litiengine.entities.Prop {
private void updateAnimationController() {
    IEntityAnimationController<?> controller = this.createAnimationController();
    this.getControllers().addController(controller);
    if (Game.world().environment() != null && Game.world().environment().isLoaded()) {
      Game.loop().attach(controller);
    }
}
}
```
```java
class de.gurkenlabs.litiengine.graphics.FreeFlightCamera {
public FreeFlightCamera(final Point2D focus) {
    this.setFocus(focus);
    this.velocity = DEFAULT_SCROLL_PIXELS_PER_SECOND;
    this.scrollPadding = DEFAULT_SCROLL_PADDING;
    this.setClampToMap(true);

    Game.loop().attach(this);
}private void handleFreeFlightCamera() {
    if (Game.world().environment() == null || Game.world().environment().getMap() == null) {
      return;
    }

    final Point2D mouseLocation = Input.mouse().getLocation();

    final double scrollSpeed =
        this.getVelocity()
            / (double) Game.loop().getTickRate()
            * Game.config().input().getMouseSensitivity();

    double x = this.getFocus().getX();
    double y = this.getFocus().getY();

    double deltaX = 0;
    if (mouseLocation.getX() < this.getScrollPadding()) {
      deltaX -= scrollSpeed;
    } else if (Game.window().getResolution().getWidth() - mouseLocation.getX()
        < this.getScrollPadding()) {
      deltaX += scrollSpeed;
    }

    double deltaY = 0;
    if (mouseLocation.getY() < this.getScrollPadding()) {
      deltaY -= scrollSpeed;
    } else if (Game.window().getResolution().getHeight() - mouseLocation.getY()
        < this.getScrollPadding()) {
      deltaY += scrollSpeed;
    }

    x += deltaX;
    y += deltaY;

    this.setFocus(new Point2D.Double(x, y));
}
}
```
```java
class de.gurkenlabs.litiengine.environment.Environment {
private static void dispose(final Collection<? extends IEntity> entities) {
    for (final IEntity entity : entities) {
      if (entity instanceof IUpdateable) {
        Game.loop().detach((IUpdateable) entity);
      }

      entity.detachControllers();
    }
}private static void loadUpdatableOrEmitterEntity(IEntity entity) {
    if (entity instanceof Emitter) {
      final Emitter emitter = (Emitter) entity;
      if (emitter.isActivateOnInit()) {
        emitter.activate();
      }
    } else if (entity instanceof IUpdateable) {
      Game.loop().attach((IUpdateable) entity);
    }
}private void unload(final IEntity entity) {
    // 1. remove from physics engine
    if (entity instanceof ICollisionEntity) {
      Game.physics().remove((ICollisionEntity) entity);
    }

    // 2. unregister from update
    if (entity instanceof IUpdateable) {
      Game.loop().detach((IUpdateable) entity);
    }

    if (entity instanceof IMobileEntity) {
      this.removeGravity((IMobileEntity) entity);
    }

    // 3. detach all controllers
    entity.detachControllers();

    if (entity instanceof Emitter) {
      Emitter em = (Emitter) entity;
      em.deactivate();
    }

    if (this.loaded && (entity instanceof LightSource || entity instanceof StaticShadow)) {
      this.updateLighting(entity);
    }

    entity.removed(this);
}
}
```
```java
class de.gurkenlabs.litiengine.graphics.animation.Animation {
@Override
  public void update() {
    // do nothing if the animation is not playing or the current keyframe is not finished
    if (!this.isPlaying()
        || Game.time().since(this.lastFrameUpdate) < this.getCurrentKeyFrame().getDuration()) {
      return;
    }

    // if we are not looping and the last keyframe is finished, we terminate the animation
    if (!this.isLooping() && this.isLastKeyFrame()) {
      this.terminate();
      return;
    }

    // make sure, we stay inside the keyframe list
    final int newFrameIndex =
        (this.getKeyframes().indexOf(this.currentFrame) + 1) % this.getKeyframes().size();
    final KeyFrame previousFrame = this.currentFrame;
    this.currentFrame = this.getKeyframes().get(newFrameIndex);

    for (KeyFrameListener listener : this.listeners) {
      listener.currentFrameChanged(previousFrame, this.currentFrame);
    }

    this.lastFrameUpdate = Game.loop().getTicks();
}public void restart() {
    this.currentFrame = this.firstFrame;
    this.lastFrameUpdate = Game.loop().getTicks();
}
}
```
```java
class de.gurkenlabs.litiengine.physics.MovementController {
@Override
  public void attach() {
    Game.loop().attach(this);
}private void handleForces() {
    // clean up forces
    this.activeForces.forEach(
        x -> {
          if (x.hasEnded()) {
            this.activeForces.remove(x);
          }
        });

    if (this.activeForces.isEmpty()) {
      return;
    }

    // disable turn-on-move for force handling
    boolean turn = this.getEntity().turnOnMove();
    this.getEntity().setTurnOnMove(false);
    try {
      double deltaX = 0;
      double deltaY = 0;
      for (final Force force : this.activeForces) {
        if (force.cancelOnReached() && force.hasReached(this.getEntity())) {
          force.end();
          continue;
        }

        final Point2D collisionBoxCenter = this.getEntity().getCollisionBoxCenter();
        final double angle =
            GeometricUtilities.calcRotationAngleInDegrees(collisionBoxCenter, force.getLocation());
        final double strength =
            Game.loop().getDeltaTime() * 0.001f * force.getStrength() * Game.loop().getTimeScale();
        deltaX += GeometricUtilities.getDeltaX(angle, strength);
        deltaY += GeometricUtilities.getDeltaY(angle, strength);
      }

      final Point2D target =
          new Point2D.Double(this.getEntity().getX() + deltaX, this.getEntity().getY() + deltaY);
      final boolean success = Game.physics().move(this.getEntity(), target);
      if (!success) {
        for (final Force force : this.activeForces) {
          if (force.cancelOnCollision()) {
            force.end();
          }
        }
      }
    } finally {
      this.getEntity().setTurnOnMove(turn);
    }
}@Override
  public void detach() {
    Game.loop().detach(this);
}public void handleMovement() {
    if (!this.isMovementAllowed()) {
      this.velocity = 0;
      return;
    }

    // max distance an entity can travel within one tick
    final double maxPixelsPerTick = this.getEntity().getTickVelocity();
    final double deltaTime = Game.loop().getDeltaTime() * Game.loop().getTimeScale();

    final double acceleration =
        this.getEntity().getAcceleration() == 0
            ? maxPixelsPerTick
            : deltaTime / this.getEntity().getAcceleration() * maxPixelsPerTick;
    final double deceleration =
        this.getEntity().getDeceleration() == 0
            ? this.getVelocity()
            : deltaTime / this.getEntity().getDeceleration() * maxPixelsPerTick;

    double dx = this.getDx();
    double dy = this.getDy();
    this.setDx(0);
    this.setDy(0);

    final double deltaVelocity =
        Math.min(Math.sqrt(Math.pow(dx, 2) + Math.pow(dy, 2)), acceleration);
    if (deltaVelocity != 0) {
      double newVelocity = this.getVelocity() + deltaVelocity;
      this.setVelocity(newVelocity);
    } else {
      final double newVelocity = Math.max(0, this.getVelocity() - deceleration);
      this.setVelocity(newVelocity);
      dx = GeometricUtilities.getDeltaX(this.moveAngle);
      dy = GeometricUtilities.getDeltaY(this.moveAngle);
    }

    if (this.getVelocity() == 0) {
      this.moveAngle = 0;
      return;
    }

    // actually move entity
    this.moveEntity(dx, dy);
}
}
```
```java
class de.gurkenlabs.litiengine.graphics.animation.AnimationController {
public void detach() {
    Game.loop().detach(this);
}public void attach() {
    Game.loop().attach(this);
}
}
```
```java
class de.gurkenlabs.litiengine.graphics.Camera {
@Override
  public void setZoom(final float targetZoom, final int delay) {
    if (delay == 0) {

      this.zoom = targetZoom;
      this.targetZoom = 0;
      this.zoomDelay = 0;
      this.zoomTick = 0;
      this.zoomStep = 0;

      final ZoomChangedEvent event = new ZoomChangedEvent(this, targetZoom);
      for (final ZoomChangedListener listener : this.zoomListeners) {
        listener.zoomChanged(event);
      }
    } else {
      this.zoomTick = Game.time().now();
      this.targetZoom = targetZoom;
      this.zoomDelay = delay;

      final double tickduration = 1000 / (double) Game.loop().getTickRate();
      final double tickAmount = delay / tickduration;
      final float totalDelta = this.targetZoom - this.zoom;
      this.zoomStep = tickAmount > 0 ? (float) (totalDelta / tickAmount) : totalDelta;
    }
}
}
```
```java
class de.gurkenlabs.litiengine.Game {
public static synchronized void init(String... args) {
    if (initialized) {
      log().log(Level.INFO, "The game has already been initialized.");
      return;
    }

    log.init();
    handleCommandLineArguments(args);

    config().load();
    Locale.setDefault(new Locale(config().client().getCountry(), config().client().getLanguage()));

    gameLoop = new GameLoop("Main Update Loop", config().client().getMaxFps());
    loop().attach(physics());
    loop().attach(world());

    // setup default exception handling for render and update loop
    setUncaughtExceptionHandler(
        new DefaultUncaughtExceptionHandler(config().client().exitOnError()));

    screenManager = new ScreenManager();
    gameWindow = new GameWindow();

    // initialize  the game window
    window().init();
    world.setCamera(new Camera());

    for (GameListener listener : gameListeners) {
      listener.initialized(args);
    }

    if (!isInNoGUIMode()) {
      window().getRenderComponent().onRendered(g -> metrics().render(g));

      graphics()
          .addEntityRenderedListener(
              e -> DebugRenderer.renderEntityDebugInfo(e.getGraphics(), e.getEntity()));

      window().getRenderComponent().onFpsChanged(fps -> metrics().setFramesPerSecond(fps));
      window()
          .setIcons(
              Arrays.asList(
                  Resources.images().get("liti-logo-x16.png"),
                  Resources.images().get("liti-logo-x20.png"),
                  Resources.images().get("liti-logo-x32.png"),
                  Resources.images().get("liti-logo-x48.png")));

      Input.keyboard()
          .onKeyTyped(
              KeyEvent.VK_PRINTSCREEN,
              key -> {
                // don't take a screenshot if a modifier is active
                if (key.getModifiers() != 0) {
                  return;
                }

                window().getRenderComponent().takeScreenshot();
              });
    }

    Runtime.getRuntime().addShutdownHook(new Thread(Game::terminate, "Shutdown"));

    initialized = true;
}
}
```
```java
class de.gurkenlabs.litiengine.entities.Creature {
protected void updateAnimationController() {
    IEntityAnimationController<?> controller = this.createAnimationController();
    this.getControllers().addController(controller);
    if (Game.world().environment() != null && Game.world().environment().isLoaded()) {
      Game.loop().attach(controller);
    }
}@Override
  public float getTickVelocity() {
    // pixels per ms multiplied by the passed ms
    // ensure that entities don't travel too far in case of lag
    return Math.min(Game.loop().getDeltaTime(), GameLoop.TICK_DELTATIME_LAG)
        * 0.001F
        * this.getVelocity().get()
        * Game.loop().getTimeScale();
}
}
```
Depth: 2
```java
class de.gurkenlabs.litiengine.environment.GameWorld {
public void clear() {
    this.unloadEnvironment();
    this.environments.clear();
    this.setCamera(null);
    Game.physics().clear();

    this.environmentListeners.clear();
    this.environmentLoadedListeners.clear();
    this.environmentUnloadedListeners.clear();

    this.listeners.clear();
    this.loadedListeners.clear();
    this.unloadedListeners.clear();
}@Nullable
  public Environment loadEnvironment(IMap map) {
    Environment env = this.getEnvironment(map);
    this.loadEnvironment(env);
    return env;
}@Nullable
  public Environment loadEnvironment(String mapName) {
    Environment env = this.getEnvironment(mapName);
    this.loadEnvironment(env);
    return env;
}
}
```
```java
class de.gurkenlabs.litiengine.GameWindow {
GameWindow() {
    this.hostControl = new JFrame();

    this.resolutionChangedListeners = new CopyOnWriteArrayList<>();

    this.renderCanvas = new RenderComponent(Game.config().graphics().getResolution());
    this.cursor = new MouseCursor();
    if (!Game.isInNoGUIMode()) {
      this.hostControl.setBackground(Color.BLACK);
      this.hostControl.add(this.renderCanvas);

      this.initializeEventListeners();

      this.hostControl.setTitle(Game.info().getTitle());
      this.hostControl.setDefaultCloseOperation(WindowConstants.DO_NOTHING_ON_CLOSE);
      initializeWindowEventListeners(this.hostControl);
    }
}
}
```
```java
class de.gurkenlabs.litiengine.GameTime {
public long sinceEnvironmentLoad() {
    return this.since(this.environmentLoaded);
}public long since(final long tick) {
    return toMilliseconds(Game.loop().getTicks() - tick);
}public long sinceGameStart() {
    return this.toMilliseconds(Game.loop().getTicks());
}
}
```
```java
class de.gurkenlabs.litiengine.abilities.effects.Effect {
protected void cease(final EffectApplication appliance) {
    // 1. cease the effect for all affected entities
    for (final ICombatEntity entity : appliance.getAffectedEntities()) {
      this.cease(entity);
    }

    // 2. apply follow up effects
    this.getFollowUpEffects().forEach(followUp -> followUp.apply(appliance.getImpactArea()));
}protected boolean hasEnded(final EffectApplication appliance) {
    final long effectDuration = Game.time().since(appliance.getAppliedTicks());
    return effectDuration > this.getDuration();
}
}
```
```java
class de.gurkenlabs.litiengine.abilities.effects.EffectApplication {
protected EffectApplication(final List<ICombatEntity> affectedEntities, final Shape impactArea) {
    this.applied = Game.time().now();
    this.affectedEntities = affectedEntities;
    this.impactArea = impactArea;
}
}
```
```java
class de.gurkenlabs.litiengine.entities.CombatEntity {
@Override
  public boolean wasHit(int timeSpan) {
    return Game.time().since(this.lastHit) < timeSpan;
}@Override
  public void hit(final int damage, @Nullable final Ability ability) {
    if (this.isDead()) {
      return;
    }

    if (!this.isIndestructible()) {
      this.getHitPoints().modifyBaseValue(new AttributeModifier<>(Modification.SUBTRACT, damage));
    }

    final EntityHitEvent event = new EntityHitEvent(this, ability, damage, this.isDead());

    for (final CombatEntityListener listener : this.listeners) {
      listener.hit(event);
    }

    for (final CombatEntityHitListener listener : this.hitListeners) {
      listener.hit(event);
    }

    if (this.isDead()) {
      this.fireDeathEvent();
      this.setCollision(false);
    }

    this.lastHit = Game.time().now();
}
}
```
```java
class de.gurkenlabs.litiengine.graphics.ImageEffect {
protected ImageEffect(final int ttl, final String name) {
    this.ttl = ttl;
    this.name = name;
    this.aliveTick = Game.time().now();
}@Override
  public long getAliveTime() {
    return Game.time().since(this.aliveTick);
}
}
```
```java
class de.gurkenlabs.litiengine.abilities.AbilityExecution {
AbilityExecution(final Ability ability) {
    this.appliedEffects = new CopyOnWriteArrayList<>();
    this.ability = ability;
    this.executionTicks = Game.time().now();
    this.impactArea = ability.calculateImpactArea();
    this.castLocation = ability.getExecutor().getCenter();
    Game.loop().attach(this);
}@Override
  public void update() {
    // if there a no effects to apply -> unregister this instance and we're done
    if (this.getAbility().getEffects().isEmpty()
        || this.getAbility().getEffects().size() == this.getAppliedEffects().size()) {
      Game.loop().detach(this);
      return;
    }

    // handle all effects from the ability that were not applied yet
    for (final Effect effect : this.getAbility().getEffects()) {
      // if the ability was not executed yet or the delay of the effect is not
      // yet reached
      if (this.getAppliedEffects().contains(effect)
          || Game.time().since(this.getExecutionTicks()) < effect.getDelay()) {
        continue;
      }

      effect.apply(this.getExecutionImpactArea());
      this.getAppliedEffects().add(effect);
    }
}
}
```
```java
class de.gurkenlabs.litiengine.tweening.TweenEngine {
@Override
  public void update() {
    for (final Tweenable target : this.getTweens().keySet()) {
      for (final Tween tween : this.getTweens().get(target).values()) {
        if (tween.hasStopped()) {
          continue;
        }
        final long elapsed = Game.time().since(tween.getStartTime());
        if (elapsed >= tween.getDuration()) {
          tween.stop();
          continue;
        }
        final float[] currentValues = new float[tween.getTargetValues().length];
        for (int i = 0; i < tween.getTargetValues().length; i++) {
          currentValues[i] =
              tween.getStartValues()[i]
                  + tween.getEquation().compute(elapsed / (float) tween.getDuration())
                      * (tween.getTargetValues()[i] - tween.getStartValues()[i]);
        }
        tween.getTarget().setTweenValues(tween.getType(), currentValues);
      }
    }
}
}
```
```java
class de.gurkenlabs.litiengine.gui.SpeechBubble {
public static SpeechBubble create(
      final IEntity entity, final String text, SpeechBubbleAppearance appearance, Font font) {
    return new SpeechBubble(entity, text, appearance, font);
}public static SpeechBubble create(final IEntity entity, final Font font, final String text) {
    SpeechBubbleAppearance app =
        new SpeechBubbleAppearance(
            DEFAULT_APPEARANCE.getForeColor(),
            DEFAULT_APPEARANCE.getBackgroundColor1(),
            DEFAULT_APPEARANCE.getBorderColor(),
            DEFAULT_APPEARANCE.getPadding());
    return new SpeechBubble(entity, text, app, font);
}public static SpeechBubble create(final IEntity entity, final String text) {
    return new SpeechBubble(entity, text, null, GuiProperties.getDefaultFont());
}@Override
  public void update() {
    if (this.currentText == null) {
      this.hide();
      return;
    }

    this.entityCenter = Game.world().camera().getViewportLocation(this.getEntity().getCenter());

    // old text was displayed long enough
    if (this.lastTextDisplay != 0
        && Game.time().since(this.lastTextDisplay) > this.currentTextDisplayTime) {
      this.currentText = null;
      this.lastTextDisplay = 0;
      return;
    }

    // display new text
    if (this.textIndex < this.currentText.length()
        && Game.time().since(this.lastCharPoll) > LETTER_WRITE_DELAY) {
      this.textIndex++;
      this.lastCharPoll = Game.time().now();
      if (this.typeSound != null) {
        Game.audio().playSound(this.typeSound, this.getEntity());
      }
    }

    // continue displaying currently displayed text
}private SpeechBubble(
      final IEntity entity,
      final String text,
      final Sound typeSound,
      SpeechBubbleAppearance appearance,
      Font font) {
    this(entity, text, appearance, font);
    this.typeSound = typeSound;
}private SpeechBubble(
      final IEntity entity,
      final String text,
      @Nullable SpeechBubbleAppearance appearance,
      @Nullable Font font) {
    if (appearance == null) {
      this.appearance = DEFAULT_APPEARANCE;
    } else {
      this.appearance = appearance;
    }

    final SpeechBubble active = activeSpeechBubbles.get(entity);
    if (active != null) {
      active.hide();
    }
    this.setFont(font);

    this.textBoxWidth = (float) (entity.getWidth() * 4);
    this.entity = entity;

    this.currentText = text;
    this.currentTextDisplayTime = DISPLAYTIME_MIN + text.length() * DISPLAYTIME_PER_LETTER;

    this.lastTextDisplay = Game.time().now();
    this.createBubbleImage();
    entity.getEnvironment().add(this, RenderType.UI);
    Game.loop().attach(this);
    activeSpeechBubbles.put(entity, this);
}
}
```
```java
class de.gurkenlabs.litiengine.gui.TextFieldComponent {
@Override
  public void render(final Graphics2D g) {
    super.render(g);
    g.setFont(this.getFont());
    final FontMetrics fm = g.getFontMetrics();

    if (this.isSelected() && Game.time().since(this.lastToggled) > this.flickerDelay) {
      this.cursorVisible = !this.cursorVisible;
      this.lastToggled = Game.time().now();
    }
    if (this.isSelected() && this.cursorVisible) {
      final Rectangle2D cursor =
          new Rectangle2D.Double(
              this.getX() + this.getTextX() + fm.stringWidth(this.getTextToRender(g)),
              this.getY() + this.getTextY(),
              this.getFont().getSize2D() * 3 / 5,
              this.getFont().getSize2D() * 1 / 5);
      g.setColor(this.getAppearance().getForeColor());
      g.fill(cursor);
    }
}
}
```
```java
class de.gurkenlabs.litiengine.entities.Prop {
public Prop(
      final Point2D location, @Nullable final String spritesheetName, final Material material) {
    super();
    this.rotation = Rotation.NONE;
    this.spritesheetName = spritesheetName;
    this.material = material;
    this.setLocation(location);
    this.updateAnimationController();
}public void setSpritesheetName(@Nullable final String spriteName) {
    this.spritesheetName = spriteName;
    this.updateAnimationController();
}
}
```
```java
class de.gurkenlabs.litiengine.tweening.Tween {
public Tween begin() {
    this.started = Game.time().now();
    this.stopped = false;
    return this;
}
}
```
```java
class de.gurkenlabs.litiengine.graphics.emitters.particles.Particle {
public void update(final Point2D emitterOrigin, final float updateRatio) {
    if (this.aliveTick == 0) {
      this.aliveTick = Game.time().now();
    }

    this.aliveTime = Game.time().since(this.aliveTick);
    if (this.timeToLiveReached()) {
      return;
    }

    if (this.colliding) {
      return;
    }

    if (this.getDeltaWidth() != 0) {
      this.width += this.getDeltaWidth() * updateRatio;
    }

    if (this.getDeltaHeight() != 0) {
      this.height += this.getDeltaHeight() * updateRatio;
    }

    if (this.getDeltaAngle() != 0) {
      this.angle += this.getDeltaAngle() * updateRatio;
    }

    // test for ray cast collision
    final float targetX = this.x + this.getVelocityX() * updateRatio;
    final float targetY = this.y + this.getVelocityY() * updateRatio;

    if (targetX == this.x && targetY == this.y) {
      return;
    }

    if (this.checkForCollision(emitterOrigin, targetX, targetY)) {
      return;
    }

    if (this.getVelocityX() != 0) {
      this.x = targetX;
    }

    if (this.getVelocityY() != 0) {
      this.y = targetY;
    }

    if (this.getAccelerationX() != 0) {
      this.velocityX += this.getAccelerationX() * updateRatio;
    }

    if (this.getAccelerationY() != 0) {
      this.velocityY += this.getAccelerationY() * updateRatio;
    }
}
}
```
```java
class de.gurkenlabs.litiengine.graphics.animation.Animation {
@Override
  public void start() {
    this.playing = true;
    if (this.getKeyframes().isEmpty()) {
      return;
    }

    this.restart();
}@Override
  public void update() {
    // do nothing if the animation is not playing or the current keyframe is not finished
    if (!this.isPlaying()
        || Game.time().since(this.lastFrameUpdate) < this.getCurrentKeyFrame().getDuration()) {
      return;
    }

    // if we are not looping and the last keyframe is finished, we terminate the animation
    if (!this.isLooping() && this.isLastKeyFrame()) {
      this.terminate();
      return;
    }

    // make sure, we stay inside the keyframe list
    final int newFrameIndex =
        (this.getKeyframes().indexOf(this.currentFrame) + 1) % this.getKeyframes().size();
    final KeyFrame previousFrame = this.currentFrame;
    this.currentFrame = this.getKeyframes().get(newFrameIndex);

    for (KeyFrameListener listener : this.listeners) {
      listener.currentFrameChanged(previousFrame, this.currentFrame);
    }

    this.lastFrameUpdate = Game.loop().getTicks();
}
}
```
```java
class de.gurkenlabs.litiengine.graphics.animation.AnimationController {
@Override
  public void update() {
    for (final Animation animation : this.getAll()) {
      animation.update();
    }

    if (this.getCurrent() != null && this.getCurrent().isPaused()) {
      return;
    }

    final boolean playbackFinished = this.getCurrent() != null && !this.getCurrent().isPlaying();
    if (playbackFinished) {
      for (final AnimationListener listener : this.listeners) {
        listener.finished(this.getCurrent());
      }
    }

    if (this.getCurrent() == null || playbackFinished) {
      if (this.getDefault() != null) {
        this.play(this.getDefault().getName());
      } else {
        this.currentAnimation = null;
      }
    }
}
}
```
```java
class de.gurkenlabs.litiengine.graphics.RenderComponent {
private void handleFade() {
    if (this.fadeOutStart != -1) {
      final long timePassed = Game.time().since(this.fadeOutStart);
      this.currentAlpha = MathUtilities.clamp(1 - timePassed / (float) this.fadeOutTime, 0, 1);
      if (this.currentAlpha == 0f) {
        this.fadeOutStart = -1;
        this.fadeOutTime = -1;
      }

      return;
    }

    if (this.fadeInStart != -1) {
      final long timePassed = Game.time().since(this.fadeInStart);
      this.currentAlpha = MathUtilities.clamp(timePassed / (float) this.fadeInTime, 0, 1);
      if (this.currentAlpha == 1f) {
        this.fadeInStart = -1;
        this.fadeInTime = -1;
        this.currentAlpha = Float.NaN;
      }
    }
}public void fadeOut(final int ms) {
    this.fadeInStart = -1;
    this.fadeInTime = -1;
    this.fadeOutStart = Game.time().now();
    this.fadeOutTime = ms;
}public void fadeIn(final int ms) {
    this.fadeOutStart = -1;
    this.fadeOutTime = -1;
    this.fadeInStart = Game.time().now();
    this.fadeInTime = ms;
}
}
```
```java
class de.gurkenlabs.litiengine.entities.Trigger {
private boolean activate(final IEntity activator, final int tar) {
    if (!this.isLoaded()
        || this.isOneTimeTrigger && this.isActivated
        || this.getActivationType() == TriggerActivation.COLLISION
            && activator != null
            && this.collisionActivated.contains(activator)) {
      return false;
    }

    if (this.getCooldown() > 0 && Game.time().since(this.lastActivation) < this.getCooldown()) {
      return false;
    }

    List<Integer> triggerTargets = this.getTargets(tar);

    final TriggerEvent te = new TriggerEvent(this, activator, triggerTargets);

    if (!this.checkActivationPredicates(te)) {
      return false;
    }

    this.isActivated = true;
    if (activator != null) {
      this.collisionActivated.add(activator);
    }

    // if we actually have a trigger target, we send the message to the target
    for (final int target : triggerTargets) {
      final IEntity entity = this.getEnvironment().get(target);
      if (entity == null) {
        log.log(
            Level.WARNING,
            "trigger [{0}] was activated, but the trigger target [{1}] could not be found on the environment",
            new Object[] {this, target});
        continue;
      }

      entity.sendMessage(this, this.message);
    }

    // also send the trigger event to all registered consumers
    for (final TriggerActivatedListener listener : this.activatedListeners) {
      listener.activated(te);
    }

    if (this.isOneTimeTrigger) {
      this.getEnvironment().remove(this);
    }

    this.lastActivation = Game.time().now();
    return true;
}
}
```
```java
class de.gurkenlabs.litiengine.graphics.Camera {
private boolean isShakeEffectActive() {
    return this.getShakeTick() != 0
        && Game.time().since(this.getShakeTick()) < this.getShakeDuration();
}@Override
  public void update() {
    if (Game.world().camera() != null && !Game.world().camera().equals(this)) {
      return;
    }

    if (this.targetZoom > 0) {
      if (Game.time().since(this.zoomTick) >= this.zoomDelay) {
        this.zoom = this.targetZoom;
        this.targetZoom = 0;
        this.zoomDelay = 0;
        this.zoomTick = 0;
        this.zoomStep = 0;
      } else {
        this.zoom += this.zoomStep;
      }

      final ZoomChangedEvent event = new ZoomChangedEvent(this, this.getZoom());
      for (final ZoomChangedListener listener : this.zoomListeners) {
        listener.zoomChanged(event);
      }
    }

    if (this.panTime > 0) {
      if (--this.panTime <= 0) {
        this.setFocus(this.targetFocus);
        this.targetFocus = null;
      } else {
        double diff = this.panTime / (this.panTime + 1.0);
        this.focus =
            new Point2D.Double(
                this.focus.getX() * diff + this.targetFocus.getX() * (1.0 - diff),
                this.focus.getY() * diff + this.targetFocus.getY() * (1.0 - diff));
      }
    }

    if (!this.isShakeEffectActive()) {
      this.shakeOffsetX = 0;
      this.shakeOffsetY = 0;
      return;
    }

    if (Game.time().since(this.lastShake) > this.shakeDelay) {
      this.shakeOffsetX = this.getShakeIntensity() * ThreadLocalRandom.current().nextGaussian();
      this.shakeOffsetY = this.getShakeIntensity() * ThreadLocalRandom.current().nextGaussian();
      this.lastShake = Game.time().now();
    }
}@Override
  public void setZoom(final float targetZoom, final int delay) {
    if (delay == 0) {

      this.zoom = targetZoom;
      this.targetZoom = 0;
      this.zoomDelay = 0;
      this.zoomTick = 0;
      this.zoomStep = 0;

      final ZoomChangedEvent event = new ZoomChangedEvent(this, targetZoom);
      for (final ZoomChangedListener listener : this.zoomListeners) {
        listener.zoomChanged(event);
      }
    } else {
      this.zoomTick = Game.time().now();
      this.targetZoom = targetZoom;
      this.zoomDelay = delay;

      final double tickduration = 1000 / (double) Game.loop().getTickRate();
      final double tickAmount = delay / tickduration;
      final float totalDelta = this.targetZoom - this.zoom;
      this.zoomStep = tickAmount > 0 ? (float) (totalDelta / tickAmount) : totalDelta;
    }
}@Override
  public void shake(final double intensity, final int delay, final int shakeDuration) {
    this.shakeTick = Game.time().now();
    this.shakeDelay = delay;
    this.shakeIntensity = intensity;
    this.shakeDuration = shakeDuration;
}
}
```
```java
class de.gurkenlabs.litiengine.entities.Creature {
public void setSpritesheetName(String spritesheetName) {
    if (this.spritesheetName != null && this.spritesheetName.equals(spritesheetName)) {
      return;
    }

    this.spritesheetName = spritesheetName;
    this.updateAnimationController();
}public boolean isIdle() {
    return Game.time().since(this.lastMoved) > IDLE_DELAY;
}@Override
  public void setLocation(final Point2D position) {
    if (this.isDead() || position == null) {
      return;
    }

    final Point2D oldLocation = this.getLocation();
    super.setLocation(position);

    if (Game.hasStarted() && this.isLoaded()) {
      this.lastMoved = Game.time().now();
      this.fireMovedEvent(
          new EntityMovedEvent(
              this, this.getX() - oldLocation.getX(), this.getY() - oldLocation.getY()));
    }
}
}
```
```java
class de.gurkenlabs.litiengine.gui.screens.ScreenManager {
public void display(final String screenName) {
    if (this.current() != null && this.current().getName().equalsIgnoreCase(screenName)) {
      log.log(
          Level.INFO,
          "Skipping displaying of screen {0} because it is already the current screen.",
          screenName);
      return;
    }

    if (this.screens.stream()
        .noneMatch(element -> element.getName().equalsIgnoreCase(screenName))) {
      log.log(
          Level.WARNING,
          "Could not display the screen {0} because there is no screen with the specified name.",
          screenName);
      return;
    }

    Screen screen = this.get(screenName);
    if (screen == null) {
      return;
    }

    this.display(screen);
}public void add(final Screen screen) {
    screen.setWidth(Game.window().getWidth());
    screen.setHeight(Game.window().getHeight());
    this.screens.add(screen);

    if (this.current() == null) {
      this.display(screen);
    }
}public void remove(Screen screen) {
    this.screens.remove(screen);
    if (this.current() == screen) {
      if (!this.screens.isEmpty()) {
        this.display(this.screens.get(0));
      } else {
        this.display((Screen) null);
      }
    }
}public void display(@Nullable final Screen screen) {
    if (Game.hasStarted() && Game.time().since(this.lastScreenChange) < this.getChangeCooldown()) {
      log.log(
          Level.INFO,
          "Skipping displaying of screen {0} because screen changing is currently on cooldown.",
          screen != null ? screen.getName() : "");
      return;
    }

    final Screen previous = this.current();
    if (previous != null) {
      previous.suspend();
    }

    if (screen != null && !this.screens.contains(screen)) {
      this.screens.add(screen);
    }

    this.currentScreen = screen;
    if (!Game.isInNoGUIMode() && this.current() != null) {
      this.current().prepare();
    }

    this.lastScreenChange = Game.loop().getTicks();

    final ScreenChangedEvent event = new ScreenChangedEvent(this.current(), previous);
    for (final ScreenChangedListener listener : this.screenChangedListeners) {
      listener.changed(event);
    }
}
}
```
```java
class de.gurkenlabs.litiengine.abilities.Ability {
public boolean isOnCooldown() {
    return (this.getCurrentExecution() != null
        && this.getCurrentExecution().getExecutionTicks() > 0
        && Game.time().since(this.getCurrentExecution().getExecutionTicks())
            < this.getAttributes().cooldown().get());
}public boolean isActive() {
    return this.getCurrentExecution() != null
        && Game.time().since(this.getCurrentExecution().getExecutionTicks())
            < this.getAttributes().duration().get();
}@Nullable
  public AbilityExecution cast() {
    if (!this.canCast()) {
      return null;
    }
    this.currentExecution = new AbilityExecution(this);

    for (final AbilityCastListener listener : this.abilityCastListeners) {
      listener.abilityCast(this.currentExecution);
    }

    return this.getCurrentExecution();
}public float getRemainingCooldownInSeconds() {
    if (this.getCurrentExecution() == null
        || this.getExecutor() == null
        || this.getExecutor().isDead()) {
      return 0;
    }

    // calculate cooldown in seconds
    return (float)
        (!this.canCast()
            ? (this.getAttributes().cooldown().get()
                    - Game.time().since(this.getCurrentExecution().getExecutionTicks()))
                * 0.001
            : 0);
}
}
```
```java
class de.gurkenlabs.litiengine.entities.EntityHitEvent {
EntityHitEvent(
      final ICombatEntity hitEntity,
      @Nullable final Ability ability,
      final int damage,
      final boolean kill) {
    super(hitEntity);
    this.executor = ability != null ? ability.getExecutor() : null;
    this.hitEntity = hitEntity;
    this.ability = ability;
    this.damage = damage;
    this.kill = kill;
    this.time = Game.time().now();
}
}
```
```java
class de.gurkenlabs.litiengine.graphics.emitters.Emitter {
public void delete() {
    this.deactivate();
    if (Game.world().environment() != null) {
      Game.world().environment().remove(this);
    }
}public void activate() {
    if (this.activated) {
      return;
    }

    this.activated = true;
    this.activationTick = Game.time().now();
    Game.loop().attach(this);
}@Override
  public void update() {
    if (this.isPaused()) {
      return;
    }

    // clear particles if the effect time to life is reached
    if (this.isFinished()) {
      for (EmitterFinishedListener listener : this.finishedListeners) {
        listener.finished(this);
      }

      this.delete();
      return;
    }

    final float updateRatio = (float) this.data().getUpdateRate() / Game.loop().getTickRate();
    for (final Particle p : this.getParticles().stream().collect(Collectors.toList())) {
      if (this.particleCanBeRemoved(p)) {
        // remove dead particles
        this.particles.remove(p);
        continue;
      }

      p.update(this.getOrigin(), updateRatio);
    }

    this.aliveTime = Game.time().since(this.activationTick);
    if ((this.data().getSpawnRate() == 0
        || Game.time().since(this.lastSpawn) >= this.data().getSpawnRate())) {
      this.lastSpawn = Game.time().now();
      this.spawnParticle();
    }
}
}
```
```java
class de.gurkenlabs.litiengine.GameLoop {
@Override
  public int perform(int delay, Runnable action) {
    final long d = Game.time().toTicks(delay);

    TimedAction a = new TimedAction(this.getTicks() + d, action);
    this.actions.add(a);

    return a.getId();
}
}
```
```java
class de.gurkenlabs.litiengine.environment.EntitySpawner {
protected boolean shouldSpawn() {
    return this.lastSpawnWave == 0
        || Game.time().since(this.lastSpawnWave) >= this.getSpawnInterval();
}@Override
  public void update() {
    if (!this.shouldSpawn()) {
      return;
    }

    this.spawnNewEntities();
    this.lastSpawnWave = Game.time().now();
}
}
```
```java
class de.gurkenlabs.litiengine.graphics.FreeFlightCamera {
@Override
  public void update() {
    this.handleFreeFlightCamera();
}public FreeFlightCamera(double x, double y) {
    this(new Point2D.Double(x, y));
}
}
```
```java
class de.gurkenlabs.litiengine.environment.Environment {
public void unload() {
    if (!this.loaded) {
      return;
    }

    // unregister all updatable entities from the current environment
    for (final IEntity entity : this.allEntities.values()) {
      this.unload(entity);
    }

    this.loaded = false;
    this.fireEvent(l -> l.unloaded(this));
}private static void loadUpdatableOrEmitterEntity(IEntity entity) {
    if (entity instanceof Emitter) {
      final Emitter emitter = (Emitter) entity;
      if (emitter.isActivateOnInit()) {
        emitter.activate();
      }
    } else if (entity instanceof IUpdateable) {
      Game.loop().attach((IUpdateable) entity);
    }
}public void clear() {
    Game.physics().clear();

    this.combatEntities.clear();
    this.mobileEntities.clear();
    this.gravityForces.clear();
    this.layerEntities.clear();
    this.entitiesByTag.clear();
    this.allEntities.clear();

    for (RenderType renderType : RenderType.values()) {
      this.miscEntities.get(renderType).clear();
      this.renderListeners.get(renderType).clear();
      this.renderables.get(renderType).clear();
    }

    dispose(this.allEntities.values());
    dispose(this.triggers);
    this.emitters.clear();
    this.colliders.clear();
    this.props.clear();
    this.creatures.clear();
    this.staticShadows.clear();
    this.combatEntities.clear();
    this.mobileEntities.clear();
    this.lightSources.clear();
    this.spawnPoints.clear();
    this.soundSources.clear();
    this.mapAreas.clear();
    this.triggers.clear();

    this.ambientLight = null;
    this.staticShadowLayer = null;

    for (Map<Integer, IEntity> type : this.miscEntities.values()) {
      type.clear();
    }

    this.initialized = false;

    this.fireEvent(l -> l.cleared(this));
}private void load(final IEntity entity) {
    // an entity can only exist on one environment at a time, so remove it from the current one
    if (entity.getEnvironment() != null) {
      entity.getEnvironment().remove(entity);
    }

    // 1. add to physics engine
    loadPhysicsEntity(entity);

    // 2. register for update or activate
    loadUpdatableOrEmitterEntity(entity);

    // 3. if a gravity is defined, add a gravity force to the entity
    if (entity instanceof IMobileEntity && this.getGravity() != 0) {
      this.addGravityForce((IMobileEntity) entity);
    }

    // 4. attach all controllers
    entity.attachControllers();

    if (this.loaded && (entity instanceof LightSource || entity instanceof StaticShadow)) {
      this.updateLighting(entity);
    }

    entity.loaded(this);
}private void unload(final IEntity entity) {
    // 1. remove from physics engine
    if (entity instanceof ICollisionEntity) {
      Game.physics().remove((ICollisionEntity) entity);
    }

    // 2. unregister from update
    if (entity instanceof IUpdateable) {
      Game.loop().detach((IUpdateable) entity);
    }

    if (entity instanceof IMobileEntity) {
      this.removeGravity((IMobileEntity) entity);
    }

    // 3. detach all controllers
    entity.detachControllers();

    if (entity instanceof Emitter) {
      Emitter em = (Emitter) entity;
      em.deactivate();
    }

    if (this.loaded && (entity instanceof LightSource || entity instanceof StaticShadow)) {
      this.updateLighting(entity);
    }

    entity.removed(this);
}public void remove(final IEntity entity) {
    if (entity == null) {
      return;
    }

    this.allEntities.remove(entity.getMapId());
    Iterator<List<IEntity>> iter = this.layerEntities.values().iterator();
    while (iter.hasNext()) {
      List<IEntity> layer = iter.next();
      if (layer.remove(entity) && layer.isEmpty()) {
        iter.remove();
      }
    }
    if (this.miscEntities.get(entity.getRenderType()) != null) {
      this.miscEntities.get(entity.getRenderType()).values().remove(entity);
    }

    for (String tag : entity.getTags()) {
      if (this.getEntitiesByTag().containsKey(tag)) {
        this.getEntitiesByTag().get(tag).remove(entity);

        if (this.getEntitiesByTag().get(tag).isEmpty()) {
          this.getEntitiesByTag().remove(tag);
        }
      }
    }

    if (entity instanceof Emitter) {
      Emitter emitter = (Emitter) entity;
      this.removeEmitter(emitter);
    }

    if (entity instanceof MapArea) {
      this.mapAreas.remove(entity);
    }

    if (entity instanceof Prop) {
      this.props.remove(entity);
    }

    if (entity instanceof Creature) {
      this.creatures.remove(entity);
    }

    if (entity instanceof CollisionBox) {
      this.colliders.remove(entity);
      this.staticShadows.removeIf(x -> x.getOrigin() != null && x.getOrigin().equals(entity));
    }

    if (entity instanceof LightSource) {
      this.lightSources.remove(entity);
      this.updateLighting(entity);
    }

    if (entity instanceof Trigger) {
      this.triggers.remove(entity);
    }

    if (entity instanceof Spawnpoint) {
      this.spawnPoints.remove(entity);
    }
    if (entity instanceof SoundSource) {
      this.soundSources.remove(entity);
    }

    if (entity instanceof StaticShadow) {
      this.staticShadows.remove(entity);
      this.updateLighting(entity);
    }

    if (entity instanceof IMobileEntity) {
      this.mobileEntities.values().remove(entity);
    }

    if (entity instanceof ICombatEntity) {
      this.combatEntities.values().remove(entity);
    }

    this.unload(entity);

    this.fireEntityEvent(l -> l.entityRemoved(entity));
}
}
```
```java
class de.gurkenlabs.litiengine.physics.MovementController {
@Override
  public void update() {
    this.handleForces();
    this.handleMovement();
}
}
```
```java
class de.gurkenlabs.litiengine.Game {
static synchronized void terminate() {
    if (!initialized) {
      return;
    }

    hasStarted = false;
    initialized = false;

    config().save();
    gameLoop.terminate();
    tweenEngine.terminate();
    soundEngine.terminate();

    world().clear();

    for (final GameListener listener : gameListeners) {
      try {
        listener.terminated();
      } catch (Exception e) {
        log().log(Level.WARNING, "game listener threw an exception during shutdown", e);
      }
    }

    gameLoop = null;
    screenManager = null;
    gameWindow = null;
}public static synchronized void start() {
    if (!initialized) {
      throw new IllegalStateException(
          "The game cannot be started without being first initialized. Call Game.init(...) before Game.start().");
    }

    gameLoop.start();
    tweenEngine.start();
    soundEngine.start();

    for (final GameListener listener : gameListeners) {
      listener.started();
    }

    hasStarted = true;
}public static synchronized void init(String... args) {
    if (initialized) {
      log().log(Level.INFO, "The game has already been initialized.");
      return;
    }

    log.init();
    handleCommandLineArguments(args);

    config().load();
    Locale.setDefault(new Locale(config().client().getCountry(), config().client().getLanguage()));

    gameLoop = new GameLoop("Main Update Loop", config().client().getMaxFps());
    loop().attach(physics());
    loop().attach(world());

    // setup default exception handling for render and update loop
    setUncaughtExceptionHandler(
        new DefaultUncaughtExceptionHandler(config().client().exitOnError()));

    screenManager = new ScreenManager();
    gameWindow = new GameWindow();

    // initialize  the game window
    window().init();
    world.setCamera(new Camera());

    for (GameListener listener : gameListeners) {
      listener.initialized(args);
    }

    if (!isInNoGUIMode()) {
      window().getRenderComponent().onRendered(g -> metrics().render(g));

      graphics()
          .addEntityRenderedListener(
              e -> DebugRenderer.renderEntityDebugInfo(e.getGraphics(), e.getEntity()));

      window().getRenderComponent().onFpsChanged(fps -> metrics().setFramesPerSecond(fps));
      window()
          .setIcons(
              Arrays.asList(
                  Resources.images().get("liti-logo-x16.png"),
                  Resources.images().get("liti-logo-x20.png"),
                  Resources.images().get("liti-logo-x32.png"),
                  Resources.images().get("liti-logo-x48.png")));

      Input.keyboard()
          .onKeyTyped(
              KeyEvent.VK_PRINTSCREEN,
              key -> {
                // don't take a screenshot if a modifier is active
                if (key.getModifiers() != 0) {
                  return;
                }

                window().getRenderComponent().takeScreenshot();
              });
    }

    Runtime.getRuntime().addShutdownHook(new Thread(Game::terminate, "Shutdown"));

    initialized = true;
}
}
```


Response Format:
Provide the answer in **XML format** as follows:

#### If the method **cannot** return `null` at the specific call site:
```xml
<response>
  <reason><![CDATA[EXPLAIN WHY THE INVOCATION Game.loop() RESULT CANNOT BE NULL.]]></reason>
  <value>NO</value>
</response>

#### If the method can return null at the specific call site:
<response>
  <reason><![CDATA[EXPLAIN WHY THE INVOCATION Game.loop() RESULT CAN BE NULL.]]></reason>
  <value>YES</value>
</response>

#### If you are unsure or If there are any methods that directly or indirectly affect the return value and are not fully disclosed, request their declarations first, in the following format:
<response>
  <reason><![CDATA[EXPLAIN WHY THIS METHOD DECLARATION IS NECESSARY AND WHY YOU CANNOT MAKE A CONFIDENT DECISION WITHOUT IT]]></reason>
  <success>false</success>
  <methods>
    <method>methodName</method>
  </methods>
</response>

Additional Notes:
Be precise in your reasoning.
If a method’s return value depends on another method not provided, request its declaration before making a conclusion.
If the method can return null in this case but not in others, explain why it happens specifically for this call.

---ChatGPT.sendRequestToOpenAI---
Retrieving response from cache
---Response.<init>---
Creating Response:
```xml
<response>
  <reason><![CDATA[The method `Game.loop()` returns the static field `gameLoop`, which is initialized in the `Game.init(String... args)` method. In this method, a new `GameLoop` object is instantiated and assigned to `gameLoop`. Since `init()` must be called before `start()`, which is implied by the requirement of initializing the game, the `gameLoop` is guaranteed to be non-null during the lifetime of the game execution where `Game.loop()` is called. The absence of any code that could set `gameLoop` to null after its initialization ensures that `Game.loop()` cannot return null.]]></reason>
  <value>NO</value>
</response>
```
---Response.<init>---
Response created:
Disagreement: The method `Game.loop()` returns the static field `gameLoop`, which is initialized in the `Game.init(String... args)` method. In this method, a new `GameLoop` object is instantiated and assigned to `gameLoop`. Since `init()` must be called before `start()`, which is implied by the requirement of initializing the game, the `gameLoop` is guaranteed to be non-null during the lifetime of the game execution where `Game.loop()` is called. The absence of any code that could set `gameLoop` to null after its initialization ensures that `Game.loop()` cannot return null.
---AdvancedNullAwayCodeFix.resolveMethodDereferenceError---
Method is not returning nullable on call site. Injecting suppression annotation.
---AdvancedNullAwayCodeFix.constructCastToNonnullChange---
Constructing cast to nonnull change for reason: The method `Game.loop()` returns the static field `gameLoop`, which is initialized in the `Game.init(String... args)` method. In this method, a new `GameLoop` object is instantiated and assigned to `gameLoop`. Since `init()` must be called before `start()`, which is implied by the requirement of initializing the game, the `gameLoop` is guaranteed to be non-null during the lifetime of the game execution where `Game.loop()` is called. The absence of any code that could set `gameLoop` to null after its initialization ensures that `Game.loop()` cannot return null.
---ChatGPT.ask---
Asking ChatGPT:
For the reason you mentioned earlier:

"The method `Game.loop()` returns the static field `gameLoop`, which is initialized in the `Game.init(String... args)` method. In this method, a new `GameLoop` object is instantiated and assigned to `gameLoop`. Since `init()` must be called before `start()`, which is implied by the requirement of initializing the game, the `gameLoop` is guaranteed to be non-null during the lifetime of the game execution where `Game.loop()` is called. The absence of any code that could set `gameLoop` to null after its initialization ensures that `Game.loop()` cannot return null."

in the method below, the expression Game.loop() is not nullable at the point it is used.

```java
public void setCamera(@Nullable final ICamera cam) {
    if (this.camera() != null) {
      Game.loop().detach(camera);
    }

    camera = cam;

    if (cam != null && !Game.isInNoGUIMode()) {
      Game.loop().attach(cam);
      cam.updateFocus();
    }
}
```
Please Summarize the reason in max 5 words and rewrite the method so that at the line "      Game.loop().detach(camera);", at the occurrence of: "Game.loop()" is replaced with `NullabilityUtil.castToNonnull(Game.loop(), summary of reason)`
Replace "REASON" with the exact reason summary I provide to you (maximum 5 words), not with a generic explanation like "checked to be nonnull".
see the example below, for expression `foo.getBar()`, to wrap it with `NullabilityUtil.castToNonnull(foo.getBar(), "reason")`.

```java
public t(){
    String l = foo.getBar();
}
```

will be:
```java
public t(){
    String l = NullabilityUtil.castToNonnull(foo.getBar(), "checked to be nonnull");
}
```

### Instructions:

Do not import any additional classes.

Do not add Java comments.

Only modify relevant lines as required.

Return only the modified method wrapped in the XML format shown below.

Place the Java code inside the <code> tag using a CDATA block with ```java formatting.

Just give me the fixed code snippet in XML format in <response> tag like the example below. I will apply the fix to my codebase. Do not import any additional libraries or classes or add java comments. If you can provide the fixed code snippet, please provide it in the following format and place the code snippet in the <code> tag within ```java block.
<response>
  <success>true</success>
  <code><![CDATA[
  ```java
  Your fixed code snippet here
  ```
    ]]>
  </code>
</response>

---ChatGPT.sendRequestToOpenAI---
Sending request to OpenAI...
---ChatGPT.sendRequestToOpenAI---
Response received from OpenAI.
---Response.<init>---
Creating Response:
<response>
  <success>true</success>
  <code><![CDATA[
  ```java
public void setCamera(final ICamera cam) {
    if (this.camera() != null) {
      NullabilityUtil.castToNonnull(Game.loop(), "guaranteed non-null post-init").detach(camera);
    }

    camera = cam;

    if (cam != null && !Game.isInNoGUIMode()) {
      Game.loop().attach(cam);
      cam.updateFocus();
    }
}
  ```
    ]]>
  </code>
</response>
---Response.<init>---
Response created:
public void setCamera(final ICamera cam) {
    if (this.camera() != null) {
      NullabilityUtil.castToNonnull(Game.loop(), "guaranteed non-null post-init").detach(camera);
    }

    camera = cam;

    if (cam != null && !Game.isInNoGUIMode()) {
      Game.loop().attach(cam);
      cam.updateFocus();
    }
}
---ChatGPT.fixDereferenceByAddingCastToNonnull---
Fixing the error by adding castToNonnull
---AdvancedNullAwayCodeFix.fixTriggeredErrorsForLocation---
Resolving unresolvable error for triggered error: Type='DEREFERENCE_NULLABLE', message='dereferenced expression Game.loop() is @Nullable'
/home/nima/Developer/nullness-benchmarks/litiengine/src/de/gurkenlabs/litiengine/GameTime.java:54
    return this.toMilliseconds(Game.loop().getTicks());
---AdvancedNullAwayCodeFix.fix---
Fixing error: Type='DEREFERENCE_NULLABLE', message='dereferenced expression Game.loop() is @Nullable'
/home/nima/Developer/nullness-benchmarks/litiengine/src/de/gurkenlabs/litiengine/GameTime.java:54
    return this.toMilliseconds(Game.loop().getTicks());
---AdvancedNullAwayCodeFix.resolveDereferenceError---
Resolving dereference error: Type='DEREFERENCE_NULLABLE', message='dereferenced expression Game.loop() is @Nullable'
/home/nima/Developer/nullness-benchmarks/litiengine/src/de/gurkenlabs/litiengine/GameTime.java:54
    return this.toMilliseconds(Game.loop().getTicks());
---AdvancedNullAwayCodeFix.resolveDereferenceError---
Checking nullability possibility at error point
---ChatGPT.checkNullabilityPossibilityAtErrorPoint---
Asking if the expression can be null at error point point
---ChatGPT.ask---
Asking ChatGPT:
In the method below, is there a possibility that the expression "Game.loop()" at line "return this.toMilliseconds(Game.loop().getTicks());" is null?
public long sinceGameStart() {
    return this.toMilliseconds(Game.loop().getTicks());
}
Give a single-word answer in XML format. If it is possible for the expression to be null, respond with:
```xml
<response>
    <reason><![CDATA[YOUR REASON]]></reason>
    <value>YES</value>
</response>
```
If it is not possible for the expression to be null, respond with:
```xml
<response>
    <reason><![CDATA[YOUR REASON]]></reason>
    <value>NO</value>
</response>
```
If you are unsure or need more information, respond with where you can ask for more details or what specific information you need.

If additional information is required, list each request inside a `<request>` tag. If no additional information is needed, omit the `<requests>` section.

Respond with:
```xml
<response>
    <reason><![CDATA[YOUR REASON]]></reason>
    <value>UNKNOWN</value>
    <!-- Include <requests> only if additional information is needed -->
    <requests>
        <request><![CDATA[YOUR REQUEST 1]]></request>
        <request><![CDATA[YOUR REQUEST 2]]></request>
    </requests>
</response>
```
---ChatGPT.sendRequestToOpenAI---
Sending request to OpenAI...
---ChatGPT.sendRequestToOpenAI---
Response received from OpenAI.
---Response.<init>---
Creating Response:
```xml
<response>
    <reason><![CDATA[Without additional context on how the Game class and its loop() method are implemented, it is unclear whether Game.loop() can return a null value.]]></reason>
    <value>UNKNOWN</value>
    <requests>
        <request><![CDATA[Details on how the Game class is implemented, specifically the loop() method.]]></request>
        <request><![CDATA[Information on the lifecycle or initialization process of the Game class.]]></request>
    </requests>
</response>
```
---Response.<init>---
Response created:
Unknown: Without additional context on how the Game class and its loop() method are implemented, it is unclear whether Game.loop() can return a null value.
---AdvancedNullAwayCodeFix.resolveMethodDereferenceError---
Resolving method dereference error.
---AdvancedNullAwayCodeFix.resolveMethodDereferenceError---
Method is in annotated package. Checking if the method is returning nullable.
---AdvancedNullAwayCodeFix.investigateMethodReturnNullability---
Checking if the method is returning nullable.
---ChatGPT.checkIfMethodIsReturningNullable---
Asking if the method is returning nullable: loop()
---ChatGPT.ask---
Asking ChatGPT:
In the method below, is there a possibility that the method returns null based only on its body? Consider the following points:

- The method may have multiple return paths; consider all return statements.
- If the method calls another method, do not assume its return value unless its full declaration is provided. Request its declaration if needed.
- The method may throw an exception instead of returning null. An exception path should not be considered a null return.
- Ensure you request the declarations of any methods whose return values directly or indirectly impact this method’s return value before making a conclusion.
- Carefully analyze all conditions and prior operations that may guarantee a non-null return value.

@Nullable public static IGameLoop loop() {
    return gameLoop;
}

Here are the method definitions in addition to the method inquired:

Depth: 0
```java
class de.gurkenlabs.litiengine.Game {
@Nullable public static IGameLoop loop() {
    return gameLoop;
}
}
```


Response Format:
Provide the answer in **XML format** as follows:

#### If the method **cannot** return `null`:
```xml
<response>
  <reason><![CDATA[EXPLAIN WHY THE METHOD CANNOT RETURN NULL]]></reason>
  <value>NO</value>
</response>
```

#### If the method can return null:
```xml
<response>
  <reason><![CDATA[EXPLAIN WHY THE METHOD CAN RETURN NULL]]></reason>
  <value>YES</value>
</response>
```

#### If you are unsure or need more information, respond with where you can ask for more details or what specific information you need.

#### If you are unsure or If there are any methods that directly or indirectly affect the return value and are not fully disclosed, request their declarations first, in the following format:
<response>
  <reason><![CDATA[YOUR REASON]]></reason>
  <value>UNKNOWN</value>
  <methods>
    <method>methodName</method>
  </methods>
</response>

If additional information is required other than method declaration, list each request inside a `<request>` tag. If no additional information is needed, omit the `<requests>` section.

Respond with:
```xml
<response>
    <reason><![CDATA[YOUR REASON]]></reason>
    <value>UNKNOWN</value>
    <!-- Include <requests> only if additional information is needed -->
    <requests>
        <request><![CDATA[YOUR REQUEST 1]]></request>
        <request><![CDATA[YOUR REQUEST 2]]></request>
    </requests>
</response>
```

Additional Notes:
Be precise in your reasoning.
If a method’s return value depends on another method not provided, request its declaration before making a conclusion.
If the method can return null in some cases but not others, explain under what conditions it can happen.

---ChatGPT.sendRequestToOpenAI---
Retrieving response from cache
---Response.<init>---
Creating Response:
```xml
<response>
  <reason><![CDATA[The method `loop` returns the variable `gameLoop`. Without the initialization or assignment details of `gameLoop`, it's unclear whether it can be null. The possibility of `gameLoop` being uninitialized or set to null elsewhere in the program means `loop` could potentially return null. Further information on `gameLoop` is required.]]></reason>
  <value>UNKNOWN</value>
  <requests>
    <request><![CDATA[Please provide the declaration and initialization of the variable `gameLoop` in the class `de.gurkenlabs.litiengine.Game`.]]></request>
  </requests>
</response>
```
---Response.<init>---
Response created:
Unknown: The method `loop` returns the variable `gameLoop`. Without the initialization or assignment details of `gameLoop`, it's unclear whether it can be null. The possibility of `gameLoop` being uninitialized or set to null elsewhere in the program means `loop` could potentially return null. Further information on `gameLoop` is required.
---AdvancedNullAwayCodeFix.investigateMethodReturnNullability---
Could not determine the nullability and model did not ask for any method.
---ChatGPT.checkIfMethodIsReturningNullableOnCallSite---
Asking if the method is returning nullable on the call site: Game.loop()
---ChatGPT.ask---
Asking ChatGPT:
In the method below, is there a possibility that the method returns null at the given call site?

```java
@Nullable public static IGameLoop loop() {
    return gameLoop;
}
```

## Guidelines:
- The method may have multiple return paths; consider all return statements.
- If the method calls another method, do not assume its return value unless its full declaration is provided. Request its declaration if needed.
- The method may throw an exception instead of returning null. An exception path should not be considered a null return.
- Ensure you request the declarations of any methods whose return values directly or indirectly impact this method’s return value before making a conclusion.
- If the method returns a value that is determined by a parameter, evaluate based on the actual argument at the given call site.
- Analyze based only on the specific invocation provided. Do not generalize to all possible inputs.- If the return value is guaranteed to be non-null at the call site, the answer should be a definitive NO.
- Do not generalize based on all possible inputs—your answer must be based only on the given invocation.
- Focus only on the given call site, not all possible invocations.

### call site:
Game.loop()

Here are the method definitions and the call chain for this method, showing the sequence of calls from the method to its callers at each depth level:

Depth: 0
```java
class de.gurkenlabs.litiengine.Game {
@Nullable public static IGameLoop loop() {
    return gameLoop;
}
}
```
Depth: 1
```java
class de.gurkenlabs.litiengine.environment.GameWorld {
public void loadEnvironment(@Nullable final Environment env) {
    Lock lock = Game.loop().getLock();
    lock.lock();
    try {
      unloadEnvironment();
      this.environment = env;
      if (env != null) {
        this.addEnvironment(env);

        if (env.getGravity() == 0 && this.gravity() != 0) {
          env.setGravity(this.gravity());
        }

        env.load();
        for (final EnvironmentLoadedListener listener : this.loadedListeners) {
          listener.loaded(env);
        }

        // call map specific listeners
        String mapName = getMapName(env);
        if (mapName != null && this.environmentLoadedListeners.containsKey(mapName)) {

          // for the default camera we center the camera on the environment
          if (this.camera().getClass().equals(Camera.class)) {
            camera().setFocus(env.getCenter());
          }

          for (EnvironmentLoadedListener listener : this.environmentLoadedListeners.get(mapName)) {
            listener.loaded(env);
          }
        }
      }
    } finally {
      lock.unlock();
    }
}public void setCamera(@Nullable final ICamera cam) {
    if (this.camera() != null) {
      Game.loop().detach(camera);
    }

    camera = cam;

    if (cam != null && !Game.isInNoGUIMode()) {
      Game.loop().attach(cam);
      cam.updateFocus();
    }
}
}
```
```java
class de.gurkenlabs.litiengine.entities.behavior.EntityNavigator {
public EntityNavigator(final IMobileEntity entity, final PathFinder pathFinder) {
    this.cancelNavigationConditions = new CopyOnWriteArrayList<>();
    this.listeners = new CopyOnWriteArrayList<>();
    this.entity = entity;
    this.pathFinder = pathFinder;
    this.setAcceptableError(DEFAULT_ACCEPTABLE_ERROR);
    Game.loop().attach(this);
}
}
```
```java
class de.gurkenlabs.litiengine.GameWindow {
private static void initializeWindowEventListeners(Window window) {

    window.addWindowStateListener(
        e -> {
          if (e.getNewState() == Frame.ICONIFIED) {
            Game.loop().setTickRate(ICONIFIED_MAX_FPS);
          } else {
            Game.loop().setTickRate(Game.config().client().getMaxFps());
          }
        });

    window.addWindowFocusListener(
        new WindowFocusListener() {
          @Override
          public void windowLostFocus(WindowEvent e) {
            if (Game.config().graphics().reduceFramesWhenNotFocused()) {
              Game.loop().setTickRate(NONE_FOCUS_MAX_FPS);
            }
          }

          @Override
          public void windowGainedFocus(WindowEvent e) {
            Game.loop().setTickRate(Game.config().client().getMaxFps());
          }
        });

    window.addWindowListener(
        new WindowAdapter() {
          @Override
          public void windowClosing(final WindowEvent event) {
            Game.exit();
          }
        });
}
}
```
```java
class de.gurkenlabs.litiengine.gui.screens.ScreenManager {
public void display(@Nullable final Screen screen) {
    if (Game.hasStarted() && Game.time().since(this.lastScreenChange) < this.getChangeCooldown()) {
      log.log(
          Level.INFO,
          "Skipping displaying of screen {0} because screen changing is currently on cooldown.",
          screen != null ? screen.getName() : "");
      return;
    }

    final Screen previous = this.current();
    if (previous != null) {
      previous.suspend();
    }

    if (screen != null && !this.screens.contains(screen)) {
      this.screens.add(screen);
    }

    this.currentScreen = screen;
    if (!Game.isInNoGUIMode() && this.current() != null) {
      this.current().prepare();
    }

    this.lastScreenChange = Game.loop().getTicks();

    final ScreenChangedEvent event = new ScreenChangedEvent(this.current(), previous);
    for (final ScreenChangedListener listener : this.screenChangedListeners) {
      listener.changed(event);
    }
}
}
```
```java
class de.gurkenlabs.litiengine.abilities.effects.Effect {
@Override
  public void update() {

    for (final Iterator<EffectApplication> iterator = this.getActiveAppliances().iterator();
        iterator.hasNext(); ) {
      final EffectApplication appliance = iterator.next();
      // if the effect duration is reached
      if (this.hasEnded(appliance)) {

        iterator.remove();
        this.cease(appliance);
      }
    }

    // 4. unregister if all appliances are finished
    if (this.getActiveAppliances().isEmpty()) {
      Game.loop().detach(this);
    }
}public void apply(final Shape impactArea) {
    final List<ICombatEntity> affected = this.lookForAffectedEntities(impactArea);
    for (final ICombatEntity affectedEntity : affected) {
      this.apply(affectedEntity);
    }

    this.appliances.add(new EffectApplication(affected, impactArea));

    // if it is the first appliance -> register for update
    if (this.appliances.size() == 1) {
      Game.loop().attach(this);
    }
}
}
```
```java
class de.gurkenlabs.litiengine.GameTime {
public long toTicks(final int milliseconds) {
    return this.toTicks(milliseconds, Game.loop().getTickRate());
}public long since(final long tick) {
    return toMilliseconds(Game.loop().getTicks() - tick);
}public long now() {
    return Game.loop().getTicks();
}public long sinceGameStart() {
    return this.toMilliseconds(Game.loop().getTicks());
}@Override
  public void loaded(Environment environment) {
    environmentLoaded = Game.loop().getTicks();
}public long toMilliseconds(final long ticks) {
    return this.toMilliseconds(ticks, Game.loop().getTickRate());
}
}
```
```java
class de.gurkenlabs.litiengine.GameMetrics {
@Override
  public void render(final Graphics2D g) {
    this.updateMetrics();

    if (!Game.config().client().showGameMetrics()) {
      return;
    }

    this.currentOffsetY = 0;

    g.setColor(this.renderColor);

    // render client metrics
    this.drawTitle(g, "[client]");
    this.drawMetric(g, "fps       : " + this.getFramesPerSecond());
    this.drawMetric(g, "max fps   : " + this.maxFramesPerSecond);
    this.drawMetric(g, "updatables: " + Game.loop().getUpdatableCount());

    // render jvm metrics if debug is enabled
    if (Game.config().debug().isDebugEnabled()) {
      this.drawTitle(g, "[jvm]");
      this.drawMetric(g, "java      : " + this.javaVersion);
      this.drawMetric(g, "memory    : " + String.format("%-5.5s", this.usedMemory) + " MB");
      this.drawMetric(g, "threads   : " + Thread.activeCount());
    }

    // render rendering metrics
    if (!this.renderMetrics.isEmpty()) {
      this.drawTitle(g, "[update]");

      for (RenderMetrics metric : this.renderMetrics) {
        this.drawMetric(g, metric.toString());
      }

      this.renderMetrics.clear();
    }
}
}
```
```java
class de.gurkenlabs.litiengine.graphics.emitters.Emitter {
public void deactivate() {
    if (!this.activated) {
      return;
    }

    this.activated = false;
    this.getParticles().clear();
    this.aliveTime = 0;
    this.activationTick = 0;
    this.lastSpawn = 0;
    Game.loop().detach(this);
}public void activate() {
    if (this.activated) {
      return;
    }

    this.activated = true;
    this.activationTick = Game.time().now();
    Game.loop().attach(this);
}@Override
  public void update() {
    if (this.isPaused()) {
      return;
    }

    // clear particles if the effect time to life is reached
    if (this.isFinished()) {
      for (EmitterFinishedListener listener : this.finishedListeners) {
        listener.finished(this);
      }

      this.delete();
      return;
    }

    final float updateRatio = (float) this.data().getUpdateRate() / Game.loop().getTickRate();
    for (final Particle p : this.getParticles().stream().collect(Collectors.toList())) {
      if (this.particleCanBeRemoved(p)) {
        // remove dead particles
        this.particles.remove(p);
        continue;
      }

      p.update(this.getOrigin(), updateRatio);
    }

    this.aliveTime = Game.time().since(this.activationTick);
    if ((this.data().getSpawnRate() == 0
        || Game.time().since(this.lastSpawn) >= this.data().getSpawnRate())) {
      this.lastSpawn = Game.time().now();
      this.spawnParticle();
    }
}
}
```
```java
class de.gurkenlabs.litiengine.entities.behavior.IBehaviorController {
public default void attach() {
    Game.loop().attach(this);
}public default void detach() {
    Game.loop().detach(this);
}
}
```
```java
class de.gurkenlabs.litiengine.abilities.AbilityExecution {
AbilityExecution(final Ability ability) {
    this.appliedEffects = new CopyOnWriteArrayList<>();
    this.ability = ability;
    this.executionTicks = Game.time().now();
    this.impactArea = ability.calculateImpactArea();
    this.castLocation = ability.getExecutor().getCenter();
    Game.loop().attach(this);
}@Override
  public void update() {
    // if there a no effects to apply -> unregister this instance and we're done
    if (this.getAbility().getEffects().isEmpty()
        || this.getAbility().getEffects().size() == this.getAppliedEffects().size()) {
      Game.loop().detach(this);
      return;
    }

    // handle all effects from the ability that were not applied yet
    for (final Effect effect : this.getAbility().getEffects()) {
      // if the ability was not executed yet or the delay of the effect is not
      // yet reached
      if (this.getAppliedEffects().contains(effect)
          || Game.time().since(this.getExecutionTicks()) < effect.getDelay()) {
        continue;
      }

      effect.apply(this.getExecutionImpactArea());
      this.getAppliedEffects().add(effect);
    }
}
}
```
```java
class de.gurkenlabs.litiengine.GameWindow$3 {
@Override
          public void windowGainedFocus(WindowEvent e) {
            Game.loop().setTickRate(Game.config().client().getMaxFps());
}@Override
          public void windowLostFocus(WindowEvent e) {
            if (Game.config().graphics().reduceFramesWhenNotFocused()) {
              Game.loop().setTickRate(NONE_FOCUS_MAX_FPS);
            }
}
}
```
```java
class de.gurkenlabs.litiengine.environment.EntitySpawner {
protected void spawnNewEntities() {
    if (this.getSpawnMode() != SpawnMode.CUSTOMSPAWNPOINTS && this.getSpawnPoints().isEmpty()) {
      return;
    }

    switch (this.getSpawnMode()) {
      case ALLSPAWNPOINTS:
        for (int i = 0; i < this.getSpawnPoints().size(); i++) {
          final int index = i;
          Game.loop()
              .perform(
                  this.getSpawnDelay() + this.getSpawnDelay() * i,
                  () -> this.spawn(this.getSpawnPoints().get(index), this.getSpawnAmount()));
        }
        break;
      case ONERANDOMSPAWNPOINT:
        this.spawn(Game.random().choose(this.getSpawnPoints()), this.getSpawnAmount());
        break;
      case RANDOMSPAWNPOINTS:
        for (int i = 0; i < this.getSpawnAmount(); i++) {
          Game.loop()
              .perform(
                  this.getSpawnDelay() + this.getSpawnDelay() * i,
                  () -> this.spawn(Game.random().choose(this.getSpawnPoints()), 1));
        }
        break;
      case CUSTOMSPAWNPOINTS:
        List<Spawnpoint> spawnPoints =
            this.customSpawnpoints != null
                ? this.customSpawnpoints.apply(this)
                : this.getCustomSpawnpoints();

        int index = 0;
        for (Spawnpoint spawn : spawnPoints) {
          Game.loop()
              .perform(
                  this.getSpawnDelay() + this.getSpawnDelay() * index, () -> this.spawn(spawn, 1));
          index++;
        }
        break;
      default:
        break;
    }
}
}
```
```java
class de.gurkenlabs.litiengine.tweening.TweenEngine {
@Override
  public void start() {
    Game.loop().attach(this);
}@Override
  public void terminate() {
    Game.loop().detach(this);
}
}
```
```java
class de.gurkenlabs.litiengine.gui.SpeechBubble {
public void hide() {
    Game.world().environment().removeRenderable(this);
    Game.loop().detach(this);
    if (activeSpeechBubbles.get(this.getEntity()) != null
        && activeSpeechBubbles.remove(this.getEntity()).equals(this)) {
      activeSpeechBubbles.remove(this.getEntity());
    }

    for (SpeechBubbleListener listener : this.listeners) {
      listener.hidden();
    }
}private SpeechBubble(
      final IEntity entity,
      final String text,
      @Nullable SpeechBubbleAppearance appearance,
      @Nullable Font font) {
    if (appearance == null) {
      this.appearance = DEFAULT_APPEARANCE;
    } else {
      this.appearance = appearance;
    }

    final SpeechBubble active = activeSpeechBubbles.get(entity);
    if (active != null) {
      active.hide();
    }
    this.setFont(font);

    this.textBoxWidth = (float) (entity.getWidth() * 4);
    this.entity = entity;

    this.currentText = text;
    this.currentTextDisplayTime = DISPLAYTIME_MIN + text.length() * DISPLAYTIME_PER_LETTER;

    this.lastTextDisplay = Game.time().now();
    this.createBubbleImage();
    entity.getEnvironment().add(this, RenderType.UI);
    Game.loop().attach(this);
    activeSpeechBubbles.put(entity, this);
}
}
```
```java
class de.gurkenlabs.litiengine.entities.Prop {
private void updateAnimationController() {
    IEntityAnimationController<?> controller = this.createAnimationController();
    this.getControllers().addController(controller);
    if (Game.world().environment() != null && Game.world().environment().isLoaded()) {
      Game.loop().attach(controller);
    }
}
}
```
```java
class de.gurkenlabs.litiengine.graphics.FreeFlightCamera {
public FreeFlightCamera(final Point2D focus) {
    this.setFocus(focus);
    this.velocity = DEFAULT_SCROLL_PIXELS_PER_SECOND;
    this.scrollPadding = DEFAULT_SCROLL_PADDING;
    this.setClampToMap(true);

    Game.loop().attach(this);
}private void handleFreeFlightCamera() {
    if (Game.world().environment() == null || Game.world().environment().getMap() == null) {
      return;
    }

    final Point2D mouseLocation = Input.mouse().getLocation();

    final double scrollSpeed =
        this.getVelocity()
            / (double) Game.loop().getTickRate()
            * Game.config().input().getMouseSensitivity();

    double x = this.getFocus().getX();
    double y = this.getFocus().getY();

    double deltaX = 0;
    if (mouseLocation.getX() < this.getScrollPadding()) {
      deltaX -= scrollSpeed;
    } else if (Game.window().getResolution().getWidth() - mouseLocation.getX()
        < this.getScrollPadding()) {
      deltaX += scrollSpeed;
    }

    double deltaY = 0;
    if (mouseLocation.getY() < this.getScrollPadding()) {
      deltaY -= scrollSpeed;
    } else if (Game.window().getResolution().getHeight() - mouseLocation.getY()
        < this.getScrollPadding()) {
      deltaY += scrollSpeed;
    }

    x += deltaX;
    y += deltaY;

    this.setFocus(new Point2D.Double(x, y));
}
}
```
```java
class de.gurkenlabs.litiengine.environment.Environment {
private static void dispose(final Collection<? extends IEntity> entities) {
    for (final IEntity entity : entities) {
      if (entity instanceof IUpdateable) {
        Game.loop().detach((IUpdateable) entity);
      }

      entity.detachControllers();
    }
}private static void loadUpdatableOrEmitterEntity(IEntity entity) {
    if (entity instanceof Emitter) {
      final Emitter emitter = (Emitter) entity;
      if (emitter.isActivateOnInit()) {
        emitter.activate();
      }
    } else if (entity instanceof IUpdateable) {
      Game.loop().attach((IUpdateable) entity);
    }
}private void unload(final IEntity entity) {
    // 1. remove from physics engine
    if (entity instanceof ICollisionEntity) {
      Game.physics().remove((ICollisionEntity) entity);
    }

    // 2. unregister from update
    if (entity instanceof IUpdateable) {
      Game.loop().detach((IUpdateable) entity);
    }

    if (entity instanceof IMobileEntity) {
      this.removeGravity((IMobileEntity) entity);
    }

    // 3. detach all controllers
    entity.detachControllers();

    if (entity instanceof Emitter) {
      Emitter em = (Emitter) entity;
      em.deactivate();
    }

    if (this.loaded && (entity instanceof LightSource || entity instanceof StaticShadow)) {
      this.updateLighting(entity);
    }

    entity.removed(this);
}
}
```
```java
class de.gurkenlabs.litiengine.graphics.animation.Animation {
@Override
  public void update() {
    // do nothing if the animation is not playing or the current keyframe is not finished
    if (!this.isPlaying()
        || Game.time().since(this.lastFrameUpdate) < this.getCurrentKeyFrame().getDuration()) {
      return;
    }

    // if we are not looping and the last keyframe is finished, we terminate the animation
    if (!this.isLooping() && this.isLastKeyFrame()) {
      this.terminate();
      return;
    }

    // make sure, we stay inside the keyframe list
    final int newFrameIndex =
        (this.getKeyframes().indexOf(this.currentFrame) + 1) % this.getKeyframes().size();
    final KeyFrame previousFrame = this.currentFrame;
    this.currentFrame = this.getKeyframes().get(newFrameIndex);

    for (KeyFrameListener listener : this.listeners) {
      listener.currentFrameChanged(previousFrame, this.currentFrame);
    }

    this.lastFrameUpdate = Game.loop().getTicks();
}public void restart() {
    this.currentFrame = this.firstFrame;
    this.lastFrameUpdate = Game.loop().getTicks();
}
}
```
```java
class de.gurkenlabs.litiengine.physics.MovementController {
@Override
  public void attach() {
    Game.loop().attach(this);
}private void handleForces() {
    // clean up forces
    this.activeForces.forEach(
        x -> {
          if (x.hasEnded()) {
            this.activeForces.remove(x);
          }
        });

    if (this.activeForces.isEmpty()) {
      return;
    }

    // disable turn-on-move for force handling
    boolean turn = this.getEntity().turnOnMove();
    this.getEntity().setTurnOnMove(false);
    try {
      double deltaX = 0;
      double deltaY = 0;
      for (final Force force : this.activeForces) {
        if (force.cancelOnReached() && force.hasReached(this.getEntity())) {
          force.end();
          continue;
        }

        final Point2D collisionBoxCenter = this.getEntity().getCollisionBoxCenter();
        final double angle =
            GeometricUtilities.calcRotationAngleInDegrees(collisionBoxCenter, force.getLocation());
        final double strength =
            Game.loop().getDeltaTime() * 0.001f * force.getStrength() * Game.loop().getTimeScale();
        deltaX += GeometricUtilities.getDeltaX(angle, strength);
        deltaY += GeometricUtilities.getDeltaY(angle, strength);
      }

      final Point2D target =
          new Point2D.Double(this.getEntity().getX() + deltaX, this.getEntity().getY() + deltaY);
      final boolean success = Game.physics().move(this.getEntity(), target);
      if (!success) {
        for (final Force force : this.activeForces) {
          if (force.cancelOnCollision()) {
            force.end();
          }
        }
      }
    } finally {
      this.getEntity().setTurnOnMove(turn);
    }
}@Override
  public void detach() {
    Game.loop().detach(this);
}public void handleMovement() {
    if (!this.isMovementAllowed()) {
      this.velocity = 0;
      return;
    }

    // max distance an entity can travel within one tick
    final double maxPixelsPerTick = this.getEntity().getTickVelocity();
    final double deltaTime = Game.loop().getDeltaTime() * Game.loop().getTimeScale();

    final double acceleration =
        this.getEntity().getAcceleration() == 0
            ? maxPixelsPerTick
            : deltaTime / this.getEntity().getAcceleration() * maxPixelsPerTick;
    final double deceleration =
        this.getEntity().getDeceleration() == 0
            ? this.getVelocity()
            : deltaTime / this.getEntity().getDeceleration() * maxPixelsPerTick;

    double dx = this.getDx();
    double dy = this.getDy();
    this.setDx(0);
    this.setDy(0);

    final double deltaVelocity =
        Math.min(Math.sqrt(Math.pow(dx, 2) + Math.pow(dy, 2)), acceleration);
    if (deltaVelocity != 0) {
      double newVelocity = this.getVelocity() + deltaVelocity;
      this.setVelocity(newVelocity);
    } else {
      final double newVelocity = Math.max(0, this.getVelocity() - deceleration);
      this.setVelocity(newVelocity);
      dx = GeometricUtilities.getDeltaX(this.moveAngle);
      dy = GeometricUtilities.getDeltaY(this.moveAngle);
    }

    if (this.getVelocity() == 0) {
      this.moveAngle = 0;
      return;
    }

    // actually move entity
    this.moveEntity(dx, dy);
}
}
```
```java
class de.gurkenlabs.litiengine.graphics.animation.AnimationController {
public void detach() {
    Game.loop().detach(this);
}public void attach() {
    Game.loop().attach(this);
}
}
```
```java
class de.gurkenlabs.litiengine.graphics.Camera {
@Override
  public void setZoom(final float targetZoom, final int delay) {
    if (delay == 0) {

      this.zoom = targetZoom;
      this.targetZoom = 0;
      this.zoomDelay = 0;
      this.zoomTick = 0;
      this.zoomStep = 0;

      final ZoomChangedEvent event = new ZoomChangedEvent(this, targetZoom);
      for (final ZoomChangedListener listener : this.zoomListeners) {
        listener.zoomChanged(event);
      }
    } else {
      this.zoomTick = Game.time().now();
      this.targetZoom = targetZoom;
      this.zoomDelay = delay;

      final double tickduration = 1000 / (double) Game.loop().getTickRate();
      final double tickAmount = delay / tickduration;
      final float totalDelta = this.targetZoom - this.zoom;
      this.zoomStep = tickAmount > 0 ? (float) (totalDelta / tickAmount) : totalDelta;
    }
}
}
```
```java
class de.gurkenlabs.litiengine.Game {
public static synchronized void init(String... args) {
    if (initialized) {
      log().log(Level.INFO, "The game has already been initialized.");
      return;
    }

    log.init();
    handleCommandLineArguments(args);

    config().load();
    Locale.setDefault(new Locale(config().client().getCountry(), config().client().getLanguage()));

    gameLoop = new GameLoop("Main Update Loop", config().client().getMaxFps());
    loop().attach(physics());
    loop().attach(world());

    // setup default exception handling for render and update loop
    setUncaughtExceptionHandler(
        new DefaultUncaughtExceptionHandler(config().client().exitOnError()));

    screenManager = new ScreenManager();
    gameWindow = new GameWindow();

    // initialize  the game window
    window().init();
    world.setCamera(new Camera());

    for (GameListener listener : gameListeners) {
      listener.initialized(args);
    }

    if (!isInNoGUIMode()) {
      window().getRenderComponent().onRendered(g -> metrics().render(g));

      graphics()
          .addEntityRenderedListener(
              e -> DebugRenderer.renderEntityDebugInfo(e.getGraphics(), e.getEntity()));

      window().getRenderComponent().onFpsChanged(fps -> metrics().setFramesPerSecond(fps));
      window()
          .setIcons(
              Arrays.asList(
                  Resources.images().get("liti-logo-x16.png"),
                  Resources.images().get("liti-logo-x20.png"),
                  Resources.images().get("liti-logo-x32.png"),
                  Resources.images().get("liti-logo-x48.png")));

      Input.keyboard()
          .onKeyTyped(
              KeyEvent.VK_PRINTSCREEN,
              key -> {
                // don't take a screenshot if a modifier is active
                if (key.getModifiers() != 0) {
                  return;
                }

                window().getRenderComponent().takeScreenshot();
              });
    }

    Runtime.getRuntime().addShutdownHook(new Thread(Game::terminate, "Shutdown"));

    initialized = true;
}
}
```
```java
class de.gurkenlabs.litiengine.entities.Creature {
protected void updateAnimationController() {
    IEntityAnimationController<?> controller = this.createAnimationController();
    this.getControllers().addController(controller);
    if (Game.world().environment() != null && Game.world().environment().isLoaded()) {
      Game.loop().attach(controller);
    }
}@Override
  public float getTickVelocity() {
    // pixels per ms multiplied by the passed ms
    // ensure that entities don't travel too far in case of lag
    return Math.min(Game.loop().getDeltaTime(), GameLoop.TICK_DELTATIME_LAG)
        * 0.001F
        * this.getVelocity().get()
        * Game.loop().getTimeScale();
}
}
```
Depth: 2
```java
class de.gurkenlabs.litiengine.environment.GameWorld {
public void clear() {
    this.unloadEnvironment();
    this.environments.clear();
    this.setCamera(null);
    Game.physics().clear();

    this.environmentListeners.clear();
    this.environmentLoadedListeners.clear();
    this.environmentUnloadedListeners.clear();

    this.listeners.clear();
    this.loadedListeners.clear();
    this.unloadedListeners.clear();
}@Nullable
  public Environment loadEnvironment(IMap map) {
    Environment env = this.getEnvironment(map);
    this.loadEnvironment(env);
    return env;
}@Nullable
  public Environment loadEnvironment(String mapName) {
    Environment env = this.getEnvironment(mapName);
    this.loadEnvironment(env);
    return env;
}
}
```
```java
class de.gurkenlabs.litiengine.GameWindow {
GameWindow() {
    this.hostControl = new JFrame();

    this.resolutionChangedListeners = new CopyOnWriteArrayList<>();

    this.renderCanvas = new RenderComponent(Game.config().graphics().getResolution());
    this.cursor = new MouseCursor();
    if (!Game.isInNoGUIMode()) {
      this.hostControl.setBackground(Color.BLACK);
      this.hostControl.add(this.renderCanvas);

      this.initializeEventListeners();

      this.hostControl.setTitle(Game.info().getTitle());
      this.hostControl.setDefaultCloseOperation(WindowConstants.DO_NOTHING_ON_CLOSE);
      initializeWindowEventListeners(this.hostControl);
    }
}
}
```
```java
class de.gurkenlabs.litiengine.GameTime {
public long sinceEnvironmentLoad() {
    return this.since(this.environmentLoaded);
}public long since(final long tick) {
    return toMilliseconds(Game.loop().getTicks() - tick);
}public long sinceGameStart() {
    return this.toMilliseconds(Game.loop().getTicks());
}
}
```
```java
class de.gurkenlabs.litiengine.abilities.effects.Effect {
protected void cease(final EffectApplication appliance) {
    // 1. cease the effect for all affected entities
    for (final ICombatEntity entity : appliance.getAffectedEntities()) {
      this.cease(entity);
    }

    // 2. apply follow up effects
    this.getFollowUpEffects().forEach(followUp -> followUp.apply(appliance.getImpactArea()));
}protected boolean hasEnded(final EffectApplication appliance) {
    final long effectDuration = Game.time().since(appliance.getAppliedTicks());
    return effectDuration > this.getDuration();
}
}
```
```java
class de.gurkenlabs.litiengine.abilities.effects.EffectApplication {
protected EffectApplication(final List<ICombatEntity> affectedEntities, final Shape impactArea) {
    this.applied = Game.time().now();
    this.affectedEntities = affectedEntities;
    this.impactArea = impactArea;
}
}
```
```java
class de.gurkenlabs.litiengine.entities.CombatEntity {
@Override
  public boolean wasHit(int timeSpan) {
    return Game.time().since(this.lastHit) < timeSpan;
}@Override
  public void hit(final int damage, @Nullable final Ability ability) {
    if (this.isDead()) {
      return;
    }

    if (!this.isIndestructible()) {
      this.getHitPoints().modifyBaseValue(new AttributeModifier<>(Modification.SUBTRACT, damage));
    }

    final EntityHitEvent event = new EntityHitEvent(this, ability, damage, this.isDead());

    for (final CombatEntityListener listener : this.listeners) {
      listener.hit(event);
    }

    for (final CombatEntityHitListener listener : this.hitListeners) {
      listener.hit(event);
    }

    if (this.isDead()) {
      this.fireDeathEvent();
      this.setCollision(false);
    }

    this.lastHit = Game.time().now();
}
}
```
```java
class de.gurkenlabs.litiengine.graphics.ImageEffect {
protected ImageEffect(final int ttl, final String name) {
    this.ttl = ttl;
    this.name = name;
    this.aliveTick = Game.time().now();
}@Override
  public long getAliveTime() {
    return Game.time().since(this.aliveTick);
}
}
```
```java
class de.gurkenlabs.litiengine.abilities.AbilityExecution {
AbilityExecution(final Ability ability) {
    this.appliedEffects = new CopyOnWriteArrayList<>();
    this.ability = ability;
    this.executionTicks = Game.time().now();
    this.impactArea = ability.calculateImpactArea();
    this.castLocation = ability.getExecutor().getCenter();
    Game.loop().attach(this);
}@Override
  public void update() {
    // if there a no effects to apply -> unregister this instance and we're done
    if (this.getAbility().getEffects().isEmpty()
        || this.getAbility().getEffects().size() == this.getAppliedEffects().size()) {
      Game.loop().detach(this);
      return;
    }

    // handle all effects from the ability that were not applied yet
    for (final Effect effect : this.getAbility().getEffects()) {
      // if the ability was not executed yet or the delay of the effect is not
      // yet reached
      if (this.getAppliedEffects().contains(effect)
          || Game.time().since(this.getExecutionTicks()) < effect.getDelay()) {
        continue;
      }

      effect.apply(this.getExecutionImpactArea());
      this.getAppliedEffects().add(effect);
    }
}
}
```
```java
class de.gurkenlabs.litiengine.tweening.TweenEngine {
@Override
  public void update() {
    for (final Tweenable target : this.getTweens().keySet()) {
      for (final Tween tween : this.getTweens().get(target).values()) {
        if (tween.hasStopped()) {
          continue;
        }
        final long elapsed = Game.time().since(tween.getStartTime());
        if (elapsed >= tween.getDuration()) {
          tween.stop();
          continue;
        }
        final float[] currentValues = new float[tween.getTargetValues().length];
        for (int i = 0; i < tween.getTargetValues().length; i++) {
          currentValues[i] =
              tween.getStartValues()[i]
                  + tween.getEquation().compute(elapsed / (float) tween.getDuration())
                      * (tween.getTargetValues()[i] - tween.getStartValues()[i]);
        }
        tween.getTarget().setTweenValues(tween.getType(), currentValues);
      }
    }
}
}
```
```java
class de.gurkenlabs.litiengine.gui.SpeechBubble {
public static SpeechBubble create(
      final IEntity entity, final String text, SpeechBubbleAppearance appearance, Font font) {
    return new SpeechBubble(entity, text, appearance, font);
}public static SpeechBubble create(final IEntity entity, final Font font, final String text) {
    SpeechBubbleAppearance app =
        new SpeechBubbleAppearance(
            DEFAULT_APPEARANCE.getForeColor(),
            DEFAULT_APPEARANCE.getBackgroundColor1(),
            DEFAULT_APPEARANCE.getBorderColor(),
            DEFAULT_APPEARANCE.getPadding());
    return new SpeechBubble(entity, text, app, font);
}public static SpeechBubble create(final IEntity entity, final String text) {
    return new SpeechBubble(entity, text, null, GuiProperties.getDefaultFont());
}@Override
  public void update() {
    if (this.currentText == null) {
      this.hide();
      return;
    }

    this.entityCenter = Game.world().camera().getViewportLocation(this.getEntity().getCenter());

    // old text was displayed long enough
    if (this.lastTextDisplay != 0
        && Game.time().since(this.lastTextDisplay) > this.currentTextDisplayTime) {
      this.currentText = null;
      this.lastTextDisplay = 0;
      return;
    }

    // display new text
    if (this.textIndex < this.currentText.length()
        && Game.time().since(this.lastCharPoll) > LETTER_WRITE_DELAY) {
      this.textIndex++;
      this.lastCharPoll = Game.time().now();
      if (this.typeSound != null) {
        Game.audio().playSound(this.typeSound, this.getEntity());
      }
    }

    // continue displaying currently displayed text
}private SpeechBubble(
      final IEntity entity,
      final String text,
      final Sound typeSound,
      SpeechBubbleAppearance appearance,
      Font font) {
    this(entity, text, appearance, font);
    this.typeSound = typeSound;
}private SpeechBubble(
      final IEntity entity,
      final String text,
      @Nullable SpeechBubbleAppearance appearance,
      @Nullable Font font) {
    if (appearance == null) {
      this.appearance = DEFAULT_APPEARANCE;
    } else {
      this.appearance = appearance;
    }

    final SpeechBubble active = activeSpeechBubbles.get(entity);
    if (active != null) {
      active.hide();
    }
    this.setFont(font);

    this.textBoxWidth = (float) (entity.getWidth() * 4);
    this.entity = entity;

    this.currentText = text;
    this.currentTextDisplayTime = DISPLAYTIME_MIN + text.length() * DISPLAYTIME_PER_LETTER;

    this.lastTextDisplay = Game.time().now();
    this.createBubbleImage();
    entity.getEnvironment().add(this, RenderType.UI);
    Game.loop().attach(this);
    activeSpeechBubbles.put(entity, this);
}
}
```
```java
class de.gurkenlabs.litiengine.gui.TextFieldComponent {
@Override
  public void render(final Graphics2D g) {
    super.render(g);
    g.setFont(this.getFont());
    final FontMetrics fm = g.getFontMetrics();

    if (this.isSelected() && Game.time().since(this.lastToggled) > this.flickerDelay) {
      this.cursorVisible = !this.cursorVisible;
      this.lastToggled = Game.time().now();
    }
    if (this.isSelected() && this.cursorVisible) {
      final Rectangle2D cursor =
          new Rectangle2D.Double(
              this.getX() + this.getTextX() + fm.stringWidth(this.getTextToRender(g)),
              this.getY() + this.getTextY(),
              this.getFont().getSize2D() * 3 / 5,
              this.getFont().getSize2D() * 1 / 5);
      g.setColor(this.getAppearance().getForeColor());
      g.fill(cursor);
    }
}
}
```
```java
class de.gurkenlabs.litiengine.entities.Prop {
public Prop(
      final Point2D location, @Nullable final String spritesheetName, final Material material) {
    super();
    this.rotation = Rotation.NONE;
    this.spritesheetName = spritesheetName;
    this.material = material;
    this.setLocation(location);
    this.updateAnimationController();
}public void setSpritesheetName(@Nullable final String spriteName) {
    this.spritesheetName = spriteName;
    this.updateAnimationController();
}
}
```
```java
class de.gurkenlabs.litiengine.tweening.Tween {
public Tween begin() {
    this.started = Game.time().now();
    this.stopped = false;
    return this;
}
}
```
```java
class de.gurkenlabs.litiengine.graphics.emitters.particles.Particle {
public void update(final Point2D emitterOrigin, final float updateRatio) {
    if (this.aliveTick == 0) {
      this.aliveTick = Game.time().now();
    }

    this.aliveTime = Game.time().since(this.aliveTick);
    if (this.timeToLiveReached()) {
      return;
    }

    if (this.colliding) {
      return;
    }

    if (this.getDeltaWidth() != 0) {
      this.width += this.getDeltaWidth() * updateRatio;
    }

    if (this.getDeltaHeight() != 0) {
      this.height += this.getDeltaHeight() * updateRatio;
    }

    if (this.getDeltaAngle() != 0) {
      this.angle += this.getDeltaAngle() * updateRatio;
    }

    // test for ray cast collision
    final float targetX = this.x + this.getVelocityX() * updateRatio;
    final float targetY = this.y + this.getVelocityY() * updateRatio;

    if (targetX == this.x && targetY == this.y) {
      return;
    }

    if (this.checkForCollision(emitterOrigin, targetX, targetY)) {
      return;
    }

    if (this.getVelocityX() != 0) {
      this.x = targetX;
    }

    if (this.getVelocityY() != 0) {
      this.y = targetY;
    }

    if (this.getAccelerationX() != 0) {
      this.velocityX += this.getAccelerationX() * updateRatio;
    }

    if (this.getAccelerationY() != 0) {
      this.velocityY += this.getAccelerationY() * updateRatio;
    }
}
}
```
```java
class de.gurkenlabs.litiengine.graphics.animation.Animation {
@Override
  public void start() {
    this.playing = true;
    if (this.getKeyframes().isEmpty()) {
      return;
    }

    this.restart();
}@Override
  public void update() {
    // do nothing if the animation is not playing or the current keyframe is not finished
    if (!this.isPlaying()
        || Game.time().since(this.lastFrameUpdate) < this.getCurrentKeyFrame().getDuration()) {
      return;
    }

    // if we are not looping and the last keyframe is finished, we terminate the animation
    if (!this.isLooping() && this.isLastKeyFrame()) {
      this.terminate();
      return;
    }

    // make sure, we stay inside the keyframe list
    final int newFrameIndex =
        (this.getKeyframes().indexOf(this.currentFrame) + 1) % this.getKeyframes().size();
    final KeyFrame previousFrame = this.currentFrame;
    this.currentFrame = this.getKeyframes().get(newFrameIndex);

    for (KeyFrameListener listener : this.listeners) {
      listener.currentFrameChanged(previousFrame, this.currentFrame);
    }

    this.lastFrameUpdate = Game.loop().getTicks();
}
}
```
```java
class de.gurkenlabs.litiengine.graphics.animation.AnimationController {
@Override
  public void update() {
    for (final Animation animation : this.getAll()) {
      animation.update();
    }

    if (this.getCurrent() != null && this.getCurrent().isPaused()) {
      return;
    }

    final boolean playbackFinished = this.getCurrent() != null && !this.getCurrent().isPlaying();
    if (playbackFinished) {
      for (final AnimationListener listener : this.listeners) {
        listener.finished(this.getCurrent());
      }
    }

    if (this.getCurrent() == null || playbackFinished) {
      if (this.getDefault() != null) {
        this.play(this.getDefault().getName());
      } else {
        this.currentAnimation = null;
      }
    }
}
}
```
```java
class de.gurkenlabs.litiengine.graphics.RenderComponent {
private void handleFade() {
    if (this.fadeOutStart != -1) {
      final long timePassed = Game.time().since(this.fadeOutStart);
      this.currentAlpha = MathUtilities.clamp(1 - timePassed / (float) this.fadeOutTime, 0, 1);
      if (this.currentAlpha == 0f) {
        this.fadeOutStart = -1;
        this.fadeOutTime = -1;
      }

      return;
    }

    if (this.fadeInStart != -1) {
      final long timePassed = Game.time().since(this.fadeInStart);
      this.currentAlpha = MathUtilities.clamp(timePassed / (float) this.fadeInTime, 0, 1);
      if (this.currentAlpha == 1f) {
        this.fadeInStart = -1;
        this.fadeInTime = -1;
        this.currentAlpha = Float.NaN;
      }
    }
}public void fadeOut(final int ms) {
    this.fadeInStart = -1;
    this.fadeInTime = -1;
    this.fadeOutStart = Game.time().now();
    this.fadeOutTime = ms;
}public void fadeIn(final int ms) {
    this.fadeOutStart = -1;
    this.fadeOutTime = -1;
    this.fadeInStart = Game.time().now();
    this.fadeInTime = ms;
}
}
```
```java
class de.gurkenlabs.litiengine.entities.Trigger {
private boolean activate(final IEntity activator, final int tar) {
    if (!this.isLoaded()
        || this.isOneTimeTrigger && this.isActivated
        || this.getActivationType() == TriggerActivation.COLLISION
            && activator != null
            && this.collisionActivated.contains(activator)) {
      return false;
    }

    if (this.getCooldown() > 0 && Game.time().since(this.lastActivation) < this.getCooldown()) {
      return false;
    }

    List<Integer> triggerTargets = this.getTargets(tar);

    final TriggerEvent te = new TriggerEvent(this, activator, triggerTargets);

    if (!this.checkActivationPredicates(te)) {
      return false;
    }

    this.isActivated = true;
    if (activator != null) {
      this.collisionActivated.add(activator);
    }

    // if we actually have a trigger target, we send the message to the target
    for (final int target : triggerTargets) {
      final IEntity entity = this.getEnvironment().get(target);
      if (entity == null) {
        log.log(
            Level.WARNING,
            "trigger [{0}] was activated, but the trigger target [{1}] could not be found on the environment",
            new Object[] {this, target});
        continue;
      }

      entity.sendMessage(this, this.message);
    }

    // also send the trigger event to all registered consumers
    for (final TriggerActivatedListener listener : this.activatedListeners) {
      listener.activated(te);
    }

    if (this.isOneTimeTrigger) {
      this.getEnvironment().remove(this);
    }

    this.lastActivation = Game.time().now();
    return true;
}
}
```
```java
class de.gurkenlabs.litiengine.graphics.Camera {
private boolean isShakeEffectActive() {
    return this.getShakeTick() != 0
        && Game.time().since(this.getShakeTick()) < this.getShakeDuration();
}@Override
  public void update() {
    if (Game.world().camera() != null && !Game.world().camera().equals(this)) {
      return;
    }

    if (this.targetZoom > 0) {
      if (Game.time().since(this.zoomTick) >= this.zoomDelay) {
        this.zoom = this.targetZoom;
        this.targetZoom = 0;
        this.zoomDelay = 0;
        this.zoomTick = 0;
        this.zoomStep = 0;
      } else {
        this.zoom += this.zoomStep;
      }

      final ZoomChangedEvent event = new ZoomChangedEvent(this, this.getZoom());
      for (final ZoomChangedListener listener : this.zoomListeners) {
        listener.zoomChanged(event);
      }
    }

    if (this.panTime > 0) {
      if (--this.panTime <= 0) {
        this.setFocus(this.targetFocus);
        this.targetFocus = null;
      } else {
        double diff = this.panTime / (this.panTime + 1.0);
        this.focus =
            new Point2D.Double(
                this.focus.getX() * diff + this.targetFocus.getX() * (1.0 - diff),
                this.focus.getY() * diff + this.targetFocus.getY() * (1.0 - diff));
      }
    }

    if (!this.isShakeEffectActive()) {
      this.shakeOffsetX = 0;
      this.shakeOffsetY = 0;
      return;
    }

    if (Game.time().since(this.lastShake) > this.shakeDelay) {
      this.shakeOffsetX = this.getShakeIntensity() * ThreadLocalRandom.current().nextGaussian();
      this.shakeOffsetY = this.getShakeIntensity() * ThreadLocalRandom.current().nextGaussian();
      this.lastShake = Game.time().now();
    }
}@Override
  public void setZoom(final float targetZoom, final int delay) {
    if (delay == 0) {

      this.zoom = targetZoom;
      this.targetZoom = 0;
      this.zoomDelay = 0;
      this.zoomTick = 0;
      this.zoomStep = 0;

      final ZoomChangedEvent event = new ZoomChangedEvent(this, targetZoom);
      for (final ZoomChangedListener listener : this.zoomListeners) {
        listener.zoomChanged(event);
      }
    } else {
      this.zoomTick = Game.time().now();
      this.targetZoom = targetZoom;
      this.zoomDelay = delay;

      final double tickduration = 1000 / (double) Game.loop().getTickRate();
      final double tickAmount = delay / tickduration;
      final float totalDelta = this.targetZoom - this.zoom;
      this.zoomStep = tickAmount > 0 ? (float) (totalDelta / tickAmount) : totalDelta;
    }
}@Override
  public void shake(final double intensity, final int delay, final int shakeDuration) {
    this.shakeTick = Game.time().now();
    this.shakeDelay = delay;
    this.shakeIntensity = intensity;
    this.shakeDuration = shakeDuration;
}
}
```
```java
class de.gurkenlabs.litiengine.entities.Creature {
public void setSpritesheetName(String spritesheetName) {
    if (this.spritesheetName != null && this.spritesheetName.equals(spritesheetName)) {
      return;
    }

    this.spritesheetName = spritesheetName;
    this.updateAnimationController();
}public boolean isIdle() {
    return Game.time().since(this.lastMoved) > IDLE_DELAY;
}@Override
  public void setLocation(final Point2D position) {
    if (this.isDead() || position == null) {
      return;
    }

    final Point2D oldLocation = this.getLocation();
    super.setLocation(position);

    if (Game.hasStarted() && this.isLoaded()) {
      this.lastMoved = Game.time().now();
      this.fireMovedEvent(
          new EntityMovedEvent(
              this, this.getX() - oldLocation.getX(), this.getY() - oldLocation.getY()));
    }
}
}
```
```java
class de.gurkenlabs.litiengine.gui.screens.ScreenManager {
public void display(final String screenName) {
    if (this.current() != null && this.current().getName().equalsIgnoreCase(screenName)) {
      log.log(
          Level.INFO,
          "Skipping displaying of screen {0} because it is already the current screen.",
          screenName);
      return;
    }

    if (this.screens.stream()
        .noneMatch(element -> element.getName().equalsIgnoreCase(screenName))) {
      log.log(
          Level.WARNING,
          "Could not display the screen {0} because there is no screen with the specified name.",
          screenName);
      return;
    }

    Screen screen = this.get(screenName);
    if (screen == null) {
      return;
    }

    this.display(screen);
}public void add(final Screen screen) {
    screen.setWidth(Game.window().getWidth());
    screen.setHeight(Game.window().getHeight());
    this.screens.add(screen);

    if (this.current() == null) {
      this.display(screen);
    }
}public void remove(Screen screen) {
    this.screens.remove(screen);
    if (this.current() == screen) {
      if (!this.screens.isEmpty()) {
        this.display(this.screens.get(0));
      } else {
        this.display((Screen) null);
      }
    }
}public void display(@Nullable final Screen screen) {
    if (Game.hasStarted() && Game.time().since(this.lastScreenChange) < this.getChangeCooldown()) {
      log.log(
          Level.INFO,
          "Skipping displaying of screen {0} because screen changing is currently on cooldown.",
          screen != null ? screen.getName() : "");
      return;
    }

    final Screen previous = this.current();
    if (previous != null) {
      previous.suspend();
    }

    if (screen != null && !this.screens.contains(screen)) {
      this.screens.add(screen);
    }

    this.currentScreen = screen;
    if (!Game.isInNoGUIMode() && this.current() != null) {
      this.current().prepare();
    }

    this.lastScreenChange = Game.loop().getTicks();

    final ScreenChangedEvent event = new ScreenChangedEvent(this.current(), previous);
    for (final ScreenChangedListener listener : this.screenChangedListeners) {
      listener.changed(event);
    }
}
}
```
```java
class de.gurkenlabs.litiengine.abilities.Ability {
public boolean isOnCooldown() {
    return (this.getCurrentExecution() != null
        && this.getCurrentExecution().getExecutionTicks() > 0
        && Game.time().since(this.getCurrentExecution().getExecutionTicks())
            < this.getAttributes().cooldown().get());
}public boolean isActive() {
    return this.getCurrentExecution() != null
        && Game.time().since(this.getCurrentExecution().getExecutionTicks())
            < this.getAttributes().duration().get();
}@Nullable
  public AbilityExecution cast() {
    if (!this.canCast()) {
      return null;
    }
    this.currentExecution = new AbilityExecution(this);

    for (final AbilityCastListener listener : this.abilityCastListeners) {
      listener.abilityCast(this.currentExecution);
    }

    return this.getCurrentExecution();
}public float getRemainingCooldownInSeconds() {
    if (this.getCurrentExecution() == null
        || this.getExecutor() == null
        || this.getExecutor().isDead()) {
      return 0;
    }

    // calculate cooldown in seconds
    return (float)
        (!this.canCast()
            ? (this.getAttributes().cooldown().get()
                    - Game.time().since(this.getCurrentExecution().getExecutionTicks()))
                * 0.001
            : 0);
}
}
```
```java
class de.gurkenlabs.litiengine.entities.EntityHitEvent {
EntityHitEvent(
      final ICombatEntity hitEntity,
      @Nullable final Ability ability,
      final int damage,
      final boolean kill) {
    super(hitEntity);
    this.executor = ability != null ? ability.getExecutor() : null;
    this.hitEntity = hitEntity;
    this.ability = ability;
    this.damage = damage;
    this.kill = kill;
    this.time = Game.time().now();
}
}
```
```java
class de.gurkenlabs.litiengine.graphics.emitters.Emitter {
public void delete() {
    this.deactivate();
    if (Game.world().environment() != null) {
      Game.world().environment().remove(this);
    }
}public void activate() {
    if (this.activated) {
      return;
    }

    this.activated = true;
    this.activationTick = Game.time().now();
    Game.loop().attach(this);
}@Override
  public void update() {
    if (this.isPaused()) {
      return;
    }

    // clear particles if the effect time to life is reached
    if (this.isFinished()) {
      for (EmitterFinishedListener listener : this.finishedListeners) {
        listener.finished(this);
      }

      this.delete();
      return;
    }

    final float updateRatio = (float) this.data().getUpdateRate() / Game.loop().getTickRate();
    for (final Particle p : this.getParticles().stream().collect(Collectors.toList())) {
      if (this.particleCanBeRemoved(p)) {
        // remove dead particles
        this.particles.remove(p);
        continue;
      }

      p.update(this.getOrigin(), updateRatio);
    }

    this.aliveTime = Game.time().since(this.activationTick);
    if ((this.data().getSpawnRate() == 0
        || Game.time().since(this.lastSpawn) >= this.data().getSpawnRate())) {
      this.lastSpawn = Game.time().now();
      this.spawnParticle();
    }
}
}
```
```java
class de.gurkenlabs.litiengine.GameLoop {
@Override
  public int perform(int delay, Runnable action) {
    final long d = Game.time().toTicks(delay);

    TimedAction a = new TimedAction(this.getTicks() + d, action);
    this.actions.add(a);

    return a.getId();
}
}
```
```java
class de.gurkenlabs.litiengine.environment.EntitySpawner {
protected boolean shouldSpawn() {
    return this.lastSpawnWave == 0
        || Game.time().since(this.lastSpawnWave) >= this.getSpawnInterval();
}@Override
  public void update() {
    if (!this.shouldSpawn()) {
      return;
    }

    this.spawnNewEntities();
    this.lastSpawnWave = Game.time().now();
}
}
```
```java
class de.gurkenlabs.litiengine.graphics.FreeFlightCamera {
@Override
  public void update() {
    this.handleFreeFlightCamera();
}public FreeFlightCamera(double x, double y) {
    this(new Point2D.Double(x, y));
}
}
```
```java
class de.gurkenlabs.litiengine.environment.Environment {
public void unload() {
    if (!this.loaded) {
      return;
    }

    // unregister all updatable entities from the current environment
    for (final IEntity entity : this.allEntities.values()) {
      this.unload(entity);
    }

    this.loaded = false;
    this.fireEvent(l -> l.unloaded(this));
}private static void loadUpdatableOrEmitterEntity(IEntity entity) {
    if (entity instanceof Emitter) {
      final Emitter emitter = (Emitter) entity;
      if (emitter.isActivateOnInit()) {
        emitter.activate();
      }
    } else if (entity instanceof IUpdateable) {
      Game.loop().attach((IUpdateable) entity);
    }
}public void clear() {
    Game.physics().clear();

    this.combatEntities.clear();
    this.mobileEntities.clear();
    this.gravityForces.clear();
    this.layerEntities.clear();
    this.entitiesByTag.clear();
    this.allEntities.clear();

    for (RenderType renderType : RenderType.values()) {
      this.miscEntities.get(renderType).clear();
      this.renderListeners.get(renderType).clear();
      this.renderables.get(renderType).clear();
    }

    dispose(this.allEntities.values());
    dispose(this.triggers);
    this.emitters.clear();
    this.colliders.clear();
    this.props.clear();
    this.creatures.clear();
    this.staticShadows.clear();
    this.combatEntities.clear();
    this.mobileEntities.clear();
    this.lightSources.clear();
    this.spawnPoints.clear();
    this.soundSources.clear();
    this.mapAreas.clear();
    this.triggers.clear();

    this.ambientLight = null;
    this.staticShadowLayer = null;

    for (Map<Integer, IEntity> type : this.miscEntities.values()) {
      type.clear();
    }

    this.initialized = false;

    this.fireEvent(l -> l.cleared(this));
}private void load(final IEntity entity) {
    // an entity can only exist on one environment at a time, so remove it from the current one
    if (entity.getEnvironment() != null) {
      entity.getEnvironment().remove(entity);
    }

    // 1. add to physics engine
    loadPhysicsEntity(entity);

    // 2. register for update or activate
    loadUpdatableOrEmitterEntity(entity);

    // 3. if a gravity is defined, add a gravity force to the entity
    if (entity instanceof IMobileEntity && this.getGravity() != 0) {
      this.addGravityForce((IMobileEntity) entity);
    }

    // 4. attach all controllers
    entity.attachControllers();

    if (this.loaded && (entity instanceof LightSource || entity instanceof StaticShadow)) {
      this.updateLighting(entity);
    }

    entity.loaded(this);
}private void unload(final IEntity entity) {
    // 1. remove from physics engine
    if (entity instanceof ICollisionEntity) {
      Game.physics().remove((ICollisionEntity) entity);
    }

    // 2. unregister from update
    if (entity instanceof IUpdateable) {
      Game.loop().detach((IUpdateable) entity);
    }

    if (entity instanceof IMobileEntity) {
      this.removeGravity((IMobileEntity) entity);
    }

    // 3. detach all controllers
    entity.detachControllers();

    if (entity instanceof Emitter) {
      Emitter em = (Emitter) entity;
      em.deactivate();
    }

    if (this.loaded && (entity instanceof LightSource || entity instanceof StaticShadow)) {
      this.updateLighting(entity);
    }

    entity.removed(this);
}public void remove(final IEntity entity) {
    if (entity == null) {
      return;
    }

    this.allEntities.remove(entity.getMapId());
    Iterator<List<IEntity>> iter = this.layerEntities.values().iterator();
    while (iter.hasNext()) {
      List<IEntity> layer = iter.next();
      if (layer.remove(entity) && layer.isEmpty()) {
        iter.remove();
      }
    }
    if (this.miscEntities.get(entity.getRenderType()) != null) {
      this.miscEntities.get(entity.getRenderType()).values().remove(entity);
    }

    for (String tag : entity.getTags()) {
      if (this.getEntitiesByTag().containsKey(tag)) {
        this.getEntitiesByTag().get(tag).remove(entity);

        if (this.getEntitiesByTag().get(tag).isEmpty()) {
          this.getEntitiesByTag().remove(tag);
        }
      }
    }

    if (entity instanceof Emitter) {
      Emitter emitter = (Emitter) entity;
      this.removeEmitter(emitter);
    }

    if (entity instanceof MapArea) {
      this.mapAreas.remove(entity);
    }

    if (entity instanceof Prop) {
      this.props.remove(entity);
    }

    if (entity instanceof Creature) {
      this.creatures.remove(entity);
    }

    if (entity instanceof CollisionBox) {
      this.colliders.remove(entity);
      this.staticShadows.removeIf(x -> x.getOrigin() != null && x.getOrigin().equals(entity));
    }

    if (entity instanceof LightSource) {
      this.lightSources.remove(entity);
      this.updateLighting(entity);
    }

    if (entity instanceof Trigger) {
      this.triggers.remove(entity);
    }

    if (entity instanceof Spawnpoint) {
      this.spawnPoints.remove(entity);
    }
    if (entity instanceof SoundSource) {
      this.soundSources.remove(entity);
    }

    if (entity instanceof StaticShadow) {
      this.staticShadows.remove(entity);
      this.updateLighting(entity);
    }

    if (entity instanceof IMobileEntity) {
      this.mobileEntities.values().remove(entity);
    }

    if (entity instanceof ICombatEntity) {
      this.combatEntities.values().remove(entity);
    }

    this.unload(entity);

    this.fireEntityEvent(l -> l.entityRemoved(entity));
}
}
```
```java
class de.gurkenlabs.litiengine.physics.MovementController {
@Override
  public void update() {
    this.handleForces();
    this.handleMovement();
}
}
```
```java
class de.gurkenlabs.litiengine.Game {
static synchronized void terminate() {
    if (!initialized) {
      return;
    }

    hasStarted = false;
    initialized = false;

    config().save();
    gameLoop.terminate();
    tweenEngine.terminate();
    soundEngine.terminate();

    world().clear();

    for (final GameListener listener : gameListeners) {
      try {
        listener.terminated();
      } catch (Exception e) {
        log().log(Level.WARNING, "game listener threw an exception during shutdown", e);
      }
    }

    gameLoop = null;
    screenManager = null;
    gameWindow = null;
}public static synchronized void start() {
    if (!initialized) {
      throw new IllegalStateException(
          "The game cannot be started without being first initialized. Call Game.init(...) before Game.start().");
    }

    gameLoop.start();
    tweenEngine.start();
    soundEngine.start();

    for (final GameListener listener : gameListeners) {
      listener.started();
    }

    hasStarted = true;
}public static synchronized void init(String... args) {
    if (initialized) {
      log().log(Level.INFO, "The game has already been initialized.");
      return;
    }

    log.init();
    handleCommandLineArguments(args);

    config().load();
    Locale.setDefault(new Locale(config().client().getCountry(), config().client().getLanguage()));

    gameLoop = new GameLoop("Main Update Loop", config().client().getMaxFps());
    loop().attach(physics());
    loop().attach(world());

    // setup default exception handling for render and update loop
    setUncaughtExceptionHandler(
        new DefaultUncaughtExceptionHandler(config().client().exitOnError()));

    screenManager = new ScreenManager();
    gameWindow = new GameWindow();

    // initialize  the game window
    window().init();
    world.setCamera(new Camera());

    for (GameListener listener : gameListeners) {
      listener.initialized(args);
    }

    if (!isInNoGUIMode()) {
      window().getRenderComponent().onRendered(g -> metrics().render(g));

      graphics()
          .addEntityRenderedListener(
              e -> DebugRenderer.renderEntityDebugInfo(e.getGraphics(), e.getEntity()));

      window().getRenderComponent().onFpsChanged(fps -> metrics().setFramesPerSecond(fps));
      window()
          .setIcons(
              Arrays.asList(
                  Resources.images().get("liti-logo-x16.png"),
                  Resources.images().get("liti-logo-x20.png"),
                  Resources.images().get("liti-logo-x32.png"),
                  Resources.images().get("liti-logo-x48.png")));

      Input.keyboard()
          .onKeyTyped(
              KeyEvent.VK_PRINTSCREEN,
              key -> {
                // don't take a screenshot if a modifier is active
                if (key.getModifiers() != 0) {
                  return;
                }

                window().getRenderComponent().takeScreenshot();
              });
    }

    Runtime.getRuntime().addShutdownHook(new Thread(Game::terminate, "Shutdown"));

    initialized = true;
}
}
```


Response Format:
Provide the answer in **XML format** as follows:

#### If the method **cannot** return `null` at the specific call site:
```xml
<response>
  <reason><![CDATA[EXPLAIN WHY THE INVOCATION Game.loop() RESULT CANNOT BE NULL.]]></reason>
  <value>NO</value>
</response>

#### If the method can return null at the specific call site:
<response>
  <reason><![CDATA[EXPLAIN WHY THE INVOCATION Game.loop() RESULT CAN BE NULL.]]></reason>
  <value>YES</value>
</response>

#### If you are unsure or If there are any methods that directly or indirectly affect the return value and are not fully disclosed, request their declarations first, in the following format:
<response>
  <reason><![CDATA[EXPLAIN WHY THIS METHOD DECLARATION IS NECESSARY AND WHY YOU CANNOT MAKE A CONFIDENT DECISION WITHOUT IT]]></reason>
  <success>false</success>
  <methods>
    <method>methodName</method>
  </methods>
</response>

Additional Notes:
Be precise in your reasoning.
If a method’s return value depends on another method not provided, request its declaration before making a conclusion.
If the method can return null in this case but not in others, explain why it happens specifically for this call.

---ChatGPT.sendRequestToOpenAI---
Retrieving response from cache
---Response.<init>---
Creating Response:
```xml
<response>
  <reason><![CDATA[The method `Game.loop()` returns the static field `gameLoop`, which is initialized in the `Game.init(String... args)` method. In this method, a new `GameLoop` object is instantiated and assigned to `gameLoop`. Since `init()` must be called before `start()`, which is implied by the requirement of initializing the game, the `gameLoop` is guaranteed to be non-null during the lifetime of the game execution where `Game.loop()` is called. The absence of any code that could set `gameLoop` to null after its initialization ensures that `Game.loop()` cannot return null.]]></reason>
  <value>NO</value>
</response>
```
---Response.<init>---
Response created:
Disagreement: The method `Game.loop()` returns the static field `gameLoop`, which is initialized in the `Game.init(String... args)` method. In this method, a new `GameLoop` object is instantiated and assigned to `gameLoop`. Since `init()` must be called before `start()`, which is implied by the requirement of initializing the game, the `gameLoop` is guaranteed to be non-null during the lifetime of the game execution where `Game.loop()` is called. The absence of any code that could set `gameLoop` to null after its initialization ensures that `Game.loop()` cannot return null.
---AdvancedNullAwayCodeFix.resolveMethodDereferenceError---
Method is not returning nullable on call site. Injecting suppression annotation.
---AdvancedNullAwayCodeFix.constructCastToNonnullChange---
Constructing cast to nonnull change for reason: The method `Game.loop()` returns the static field `gameLoop`, which is initialized in the `Game.init(String... args)` method. In this method, a new `GameLoop` object is instantiated and assigned to `gameLoop`. Since `init()` must be called before `start()`, which is implied by the requirement of initializing the game, the `gameLoop` is guaranteed to be non-null during the lifetime of the game execution where `Game.loop()` is called. The absence of any code that could set `gameLoop` to null after its initialization ensures that `Game.loop()` cannot return null.
---ChatGPT.ask---
Asking ChatGPT:
For the reason you mentioned earlier:

"The method `Game.loop()` returns the static field `gameLoop`, which is initialized in the `Game.init(String... args)` method. In this method, a new `GameLoop` object is instantiated and assigned to `gameLoop`. Since `init()` must be called before `start()`, which is implied by the requirement of initializing the game, the `gameLoop` is guaranteed to be non-null during the lifetime of the game execution where `Game.loop()` is called. The absence of any code that could set `gameLoop` to null after its initialization ensures that `Game.loop()` cannot return null."

in the method below, the expression Game.loop() is not nullable at the point it is used.

```java
public long sinceGameStart() {
    return this.toMilliseconds(Game.loop().getTicks());
}
```
Please Summarize the reason in max 5 words and rewrite the method so that at the line "    return this.toMilliseconds(Game.loop().getTicks());", at the occurrence of: "Game.loop()" is replaced with `NullabilityUtil.castToNonnull(Game.loop(), summary of reason)`
Replace "REASON" with the exact reason summary I provide to you (maximum 5 words), not with a generic explanation like "checked to be nonnull".
see the example below, for expression `foo.getBar()`, to wrap it with `NullabilityUtil.castToNonnull(foo.getBar(), "reason")`.

```java
public t(){
    String l = foo.getBar();
}
```

will be:
```java
public t(){
    String l = NullabilityUtil.castToNonnull(foo.getBar(), "checked to be nonnull");
}
```

### Instructions:

Do not import any additional classes.

Do not add Java comments.

Only modify relevant lines as required.

Return only the modified method wrapped in the XML format shown below.

Place the Java code inside the <code> tag using a CDATA block with ```java formatting.

Just give me the fixed code snippet in XML format in <response> tag like the example below. I will apply the fix to my codebase. Do not import any additional libraries or classes or add java comments. If you can provide the fixed code snippet, please provide it in the following format and place the code snippet in the <code> tag within ```java block.
<response>
  <success>true</success>
  <code><![CDATA[
  ```java
  Your fixed code snippet here
  ```
    ]]>
  </code>
</response>

---ChatGPT.sendRequestToOpenAI---
Sending request to OpenAI...
---ChatGPT.sendRequestToOpenAI---
Response received from OpenAI.
---Response.<init>---
Creating Response:
<response>
  <success>true</success>
  <code><![CDATA[
  ```java
  public long sinceGameStart() {
    return this.toMilliseconds(NullabilityUtil.castToNonnull(Game.loop(), "initialized before used").getTicks());
  }
  ```
    ]]>
  </code>
</response>
---Response.<init>---
Response created:
public long sinceGameStart() {
    return this.toMilliseconds(NullabilityUtil.castToNonnull(Game.loop(), "initialized before used").getTicks());
  }
---ChatGPT.fixDereferenceByAddingCastToNonnull---
Fixing the error by adding castToNonnull
---AdvancedNullAwayCodeFix.fixTriggeredErrorsForLocation---
Resolving unresolvable error for triggered error: Type='DEREFERENCE_NULLABLE', message='dereferenced expression Game.loop() is @Nullable'
/home/nima/Developer/nullness-benchmarks/litiengine/src/de/gurkenlabs/litiengine/entities/Prop.java:203
      Game.loop().attach(controller);
---AdvancedNullAwayCodeFix.fix---
Fixing error: Type='DEREFERENCE_NULLABLE', message='dereferenced expression Game.loop() is @Nullable'
/home/nima/Developer/nullness-benchmarks/litiengine/src/de/gurkenlabs/litiengine/entities/Prop.java:203
      Game.loop().attach(controller);
---AdvancedNullAwayCodeFix.resolveDereferenceError---
Resolving dereference error: Type='DEREFERENCE_NULLABLE', message='dereferenced expression Game.loop() is @Nullable'
/home/nima/Developer/nullness-benchmarks/litiengine/src/de/gurkenlabs/litiengine/entities/Prop.java:203
      Game.loop().attach(controller);
---AdvancedNullAwayCodeFix.resolveDereferenceError---
Checking nullability possibility at error point
---ChatGPT.checkNullabilityPossibilityAtErrorPoint---
Asking if the expression can be null at error point point
---ChatGPT.ask---
Asking ChatGPT:
In the method below, is there a possibility that the expression "Game.loop()" at line "Game.loop().attach(controller);" is null?
private void updateAnimationController() {
    IEntityAnimationController<?> controller = this.createAnimationController();
    this.getControllers().addController(controller);
    if (Game.world().environment() != null && Game.world().environment().isLoaded()) {
      Game.loop().attach(controller);
    }
}
Give a single-word answer in XML format. If it is possible for the expression to be null, respond with:
```xml
<response>
    <reason><![CDATA[YOUR REASON]]></reason>
    <value>YES</value>
</response>
```
If it is not possible for the expression to be null, respond with:
```xml
<response>
    <reason><![CDATA[YOUR REASON]]></reason>
    <value>NO</value>
</response>
```
If you are unsure or need more information, respond with where you can ask for more details or what specific information you need.

If additional information is required, list each request inside a `<request>` tag. If no additional information is needed, omit the `<requests>` section.

Respond with:
```xml
<response>
    <reason><![CDATA[YOUR REASON]]></reason>
    <value>UNKNOWN</value>
    <!-- Include <requests> only if additional information is needed -->
    <requests>
        <request><![CDATA[YOUR REQUEST 1]]></request>
        <request><![CDATA[YOUR REQUEST 2]]></request>
    </requests>
</response>
```
---ChatGPT.sendRequestToOpenAI---
Sending request to OpenAI...
---ChatGPT.sendRequestToOpenAI---
Response received from OpenAI.
---Response.<init>---
Creating Response:
```xml
<response>
    <reason><![CDATA[Without knowing the implementation details of the Game class and its methods, it's unclear whether Game.loop() returns a non-null object. If Game.loop() is designed to never return null, then it cannot be null. Otherwise, if there's a possibility based on its implementation, it could be null.]]></reason>
    <value>UNKNOWN</value>
    <requests>
        <request><![CDATA[Please provide the implementation of the Game class, particularly the loop() method.]]></request>
    </requests>
</response>
```
---Response.<init>---
Response created:
Unknown: Without knowing the implementation details of the Game class and its methods, it's unclear whether Game.loop() returns a non-null object. If Game.loop() is designed to never return null, then it cannot be null. Otherwise, if there's a possibility based on its implementation, it could be null.
---AdvancedNullAwayCodeFix.resolveMethodDereferenceError---
Resolving method dereference error.
---AdvancedNullAwayCodeFix.resolveMethodDereferenceError---
Method is in annotated package. Checking if the method is returning nullable.
---AdvancedNullAwayCodeFix.investigateMethodReturnNullability---
Checking if the method is returning nullable.
---ChatGPT.checkIfMethodIsReturningNullable---
Asking if the method is returning nullable: loop()
---ChatGPT.ask---
Asking ChatGPT:
In the method below, is there a possibility that the method returns null based only on its body? Consider the following points:

- The method may have multiple return paths; consider all return statements.
- If the method calls another method, do not assume its return value unless its full declaration is provided. Request its declaration if needed.
- The method may throw an exception instead of returning null. An exception path should not be considered a null return.
- Ensure you request the declarations of any methods whose return values directly or indirectly impact this method’s return value before making a conclusion.
- Carefully analyze all conditions and prior operations that may guarantee a non-null return value.

@Nullable public static IGameLoop loop() {
    return gameLoop;
}

Here are the method definitions in addition to the method inquired:

Depth: 0
```java
class de.gurkenlabs.litiengine.Game {
@Nullable public static IGameLoop loop() {
    return gameLoop;
}
}
```


Response Format:
Provide the answer in **XML format** as follows:

#### If the method **cannot** return `null`:
```xml
<response>
  <reason><![CDATA[EXPLAIN WHY THE METHOD CANNOT RETURN NULL]]></reason>
  <value>NO</value>
</response>
```

#### If the method can return null:
```xml
<response>
  <reason><![CDATA[EXPLAIN WHY THE METHOD CAN RETURN NULL]]></reason>
  <value>YES</value>
</response>
```

#### If you are unsure or need more information, respond with where you can ask for more details or what specific information you need.

#### If you are unsure or If there are any methods that directly or indirectly affect the return value and are not fully disclosed, request their declarations first, in the following format:
<response>
  <reason><![CDATA[YOUR REASON]]></reason>
  <value>UNKNOWN</value>
  <methods>
    <method>methodName</method>
  </methods>
</response>

If additional information is required other than method declaration, list each request inside a `<request>` tag. If no additional information is needed, omit the `<requests>` section.

Respond with:
```xml
<response>
    <reason><![CDATA[YOUR REASON]]></reason>
    <value>UNKNOWN</value>
    <!-- Include <requests> only if additional information is needed -->
    <requests>
        <request><![CDATA[YOUR REQUEST 1]]></request>
        <request><![CDATA[YOUR REQUEST 2]]></request>
    </requests>
</response>
```

Additional Notes:
Be precise in your reasoning.
If a method’s return value depends on another method not provided, request its declaration before making a conclusion.
If the method can return null in some cases but not others, explain under what conditions it can happen.

---ChatGPT.sendRequestToOpenAI---
Retrieving response from cache
---Response.<init>---
Creating Response:
```xml
<response>
  <reason><![CDATA[The method `loop` returns the variable `gameLoop`. Without the initialization or assignment details of `gameLoop`, it's unclear whether it can be null. The possibility of `gameLoop` being uninitialized or set to null elsewhere in the program means `loop` could potentially return null. Further information on `gameLoop` is required.]]></reason>
  <value>UNKNOWN</value>
  <requests>
    <request><![CDATA[Please provide the declaration and initialization of the variable `gameLoop` in the class `de.gurkenlabs.litiengine.Game`.]]></request>
  </requests>
</response>
```
---Response.<init>---
Response created:
Unknown: The method `loop` returns the variable `gameLoop`. Without the initialization or assignment details of `gameLoop`, it's unclear whether it can be null. The possibility of `gameLoop` being uninitialized or set to null elsewhere in the program means `loop` could potentially return null. Further information on `gameLoop` is required.
---AdvancedNullAwayCodeFix.investigateMethodReturnNullability---
Could not determine the nullability and model did not ask for any method.
---ChatGPT.checkIfMethodIsReturningNullableOnCallSite---
Asking if the method is returning nullable on the call site: Game.loop()
---ChatGPT.ask---
Asking ChatGPT:
In the method below, is there a possibility that the method returns null at the given call site?

```java
@Nullable public static IGameLoop loop() {
    return gameLoop;
}
```

## Guidelines:
- The method may have multiple return paths; consider all return statements.
- If the method calls another method, do not assume its return value unless its full declaration is provided. Request its declaration if needed.
- The method may throw an exception instead of returning null. An exception path should not be considered a null return.
- Ensure you request the declarations of any methods whose return values directly or indirectly impact this method’s return value before making a conclusion.
- If the method returns a value that is determined by a parameter, evaluate based on the actual argument at the given call site.
- Analyze based only on the specific invocation provided. Do not generalize to all possible inputs.- If the return value is guaranteed to be non-null at the call site, the answer should be a definitive NO.
- Do not generalize based on all possible inputs—your answer must be based only on the given invocation.
- Focus only on the given call site, not all possible invocations.

### call site:
Game.loop()

Here are the method definitions and the call chain for this method, showing the sequence of calls from the method to its callers at each depth level:

Depth: 0
```java
class de.gurkenlabs.litiengine.Game {
@Nullable public static IGameLoop loop() {
    return gameLoop;
}
}
```
Depth: 1
```java
class de.gurkenlabs.litiengine.environment.GameWorld {
public void loadEnvironment(@Nullable final Environment env) {
    Lock lock = Game.loop().getLock();
    lock.lock();
    try {
      unloadEnvironment();
      this.environment = env;
      if (env != null) {
        this.addEnvironment(env);

        if (env.getGravity() == 0 && this.gravity() != 0) {
          env.setGravity(this.gravity());
        }

        env.load();
        for (final EnvironmentLoadedListener listener : this.loadedListeners) {
          listener.loaded(env);
        }

        // call map specific listeners
        String mapName = getMapName(env);
        if (mapName != null && this.environmentLoadedListeners.containsKey(mapName)) {

          // for the default camera we center the camera on the environment
          if (this.camera().getClass().equals(Camera.class)) {
            camera().setFocus(env.getCenter());
          }

          for (EnvironmentLoadedListener listener : this.environmentLoadedListeners.get(mapName)) {
            listener.loaded(env);
          }
        }
      }
    } finally {
      lock.unlock();
    }
}public void setCamera(@Nullable final ICamera cam) {
    if (this.camera() != null) {
      Game.loop().detach(camera);
    }

    camera = cam;

    if (cam != null && !Game.isInNoGUIMode()) {
      Game.loop().attach(cam);
      cam.updateFocus();
    }
}
}
```
```java
class de.gurkenlabs.litiengine.entities.behavior.EntityNavigator {
public EntityNavigator(final IMobileEntity entity, final PathFinder pathFinder) {
    this.cancelNavigationConditions = new CopyOnWriteArrayList<>();
    this.listeners = new CopyOnWriteArrayList<>();
    this.entity = entity;
    this.pathFinder = pathFinder;
    this.setAcceptableError(DEFAULT_ACCEPTABLE_ERROR);
    Game.loop().attach(this);
}
}
```
```java
class de.gurkenlabs.litiengine.GameWindow {
private static void initializeWindowEventListeners(Window window) {

    window.addWindowStateListener(
        e -> {
          if (e.getNewState() == Frame.ICONIFIED) {
            Game.loop().setTickRate(ICONIFIED_MAX_FPS);
          } else {
            Game.loop().setTickRate(Game.config().client().getMaxFps());
          }
        });

    window.addWindowFocusListener(
        new WindowFocusListener() {
          @Override
          public void windowLostFocus(WindowEvent e) {
            if (Game.config().graphics().reduceFramesWhenNotFocused()) {
              Game.loop().setTickRate(NONE_FOCUS_MAX_FPS);
            }
          }

          @Override
          public void windowGainedFocus(WindowEvent e) {
            Game.loop().setTickRate(Game.config().client().getMaxFps());
          }
        });

    window.addWindowListener(
        new WindowAdapter() {
          @Override
          public void windowClosing(final WindowEvent event) {
            Game.exit();
          }
        });
}
}
```
```java
class de.gurkenlabs.litiengine.gui.screens.ScreenManager {
public void display(@Nullable final Screen screen) {
    if (Game.hasStarted() && Game.time().since(this.lastScreenChange) < this.getChangeCooldown()) {
      log.log(
          Level.INFO,
          "Skipping displaying of screen {0} because screen changing is currently on cooldown.",
          screen != null ? screen.getName() : "");
      return;
    }

    final Screen previous = this.current();
    if (previous != null) {
      previous.suspend();
    }

    if (screen != null && !this.screens.contains(screen)) {
      this.screens.add(screen);
    }

    this.currentScreen = screen;
    if (!Game.isInNoGUIMode() && this.current() != null) {
      this.current().prepare();
    }

    this.lastScreenChange = Game.loop().getTicks();

    final ScreenChangedEvent event = new ScreenChangedEvent(this.current(), previous);
    for (final ScreenChangedListener listener : this.screenChangedListeners) {
      listener.changed(event);
    }
}
}
```
```java
class de.gurkenlabs.litiengine.abilities.effects.Effect {
@Override
  public void update() {

    for (final Iterator<EffectApplication> iterator = this.getActiveAppliances().iterator();
        iterator.hasNext(); ) {
      final EffectApplication appliance = iterator.next();
      // if the effect duration is reached
      if (this.hasEnded(appliance)) {

        iterator.remove();
        this.cease(appliance);
      }
    }

    // 4. unregister if all appliances are finished
    if (this.getActiveAppliances().isEmpty()) {
      Game.loop().detach(this);
    }
}public void apply(final Shape impactArea) {
    final List<ICombatEntity> affected = this.lookForAffectedEntities(impactArea);
    for (final ICombatEntity affectedEntity : affected) {
      this.apply(affectedEntity);
    }

    this.appliances.add(new EffectApplication(affected, impactArea));

    // if it is the first appliance -> register for update
    if (this.appliances.size() == 1) {
      Game.loop().attach(this);
    }
}
}
```
```java
class de.gurkenlabs.litiengine.GameTime {
public long toTicks(final int milliseconds) {
    return this.toTicks(milliseconds, Game.loop().getTickRate());
}public long since(final long tick) {
    return toMilliseconds(Game.loop().getTicks() - tick);
}public long now() {
    return Game.loop().getTicks();
}public long sinceGameStart() {
    return this.toMilliseconds(Game.loop().getTicks());
}@Override
  public void loaded(Environment environment) {
    environmentLoaded = Game.loop().getTicks();
}public long toMilliseconds(final long ticks) {
    return this.toMilliseconds(ticks, Game.loop().getTickRate());
}
}
```
```java
class de.gurkenlabs.litiengine.GameMetrics {
@Override
  public void render(final Graphics2D g) {
    this.updateMetrics();

    if (!Game.config().client().showGameMetrics()) {
      return;
    }

    this.currentOffsetY = 0;

    g.setColor(this.renderColor);

    // render client metrics
    this.drawTitle(g, "[client]");
    this.drawMetric(g, "fps       : " + this.getFramesPerSecond());
    this.drawMetric(g, "max fps   : " + this.maxFramesPerSecond);
    this.drawMetric(g, "updatables: " + Game.loop().getUpdatableCount());

    // render jvm metrics if debug is enabled
    if (Game.config().debug().isDebugEnabled()) {
      this.drawTitle(g, "[jvm]");
      this.drawMetric(g, "java      : " + this.javaVersion);
      this.drawMetric(g, "memory    : " + String.format("%-5.5s", this.usedMemory) + " MB");
      this.drawMetric(g, "threads   : " + Thread.activeCount());
    }

    // render rendering metrics
    if (!this.renderMetrics.isEmpty()) {
      this.drawTitle(g, "[update]");

      for (RenderMetrics metric : this.renderMetrics) {
        this.drawMetric(g, metric.toString());
      }

      this.renderMetrics.clear();
    }
}
}
```
```java
class de.gurkenlabs.litiengine.graphics.emitters.Emitter {
public void deactivate() {
    if (!this.activated) {
      return;
    }

    this.activated = false;
    this.getParticles().clear();
    this.aliveTime = 0;
    this.activationTick = 0;
    this.lastSpawn = 0;
    Game.loop().detach(this);
}public void activate() {
    if (this.activated) {
      return;
    }

    this.activated = true;
    this.activationTick = Game.time().now();
    Game.loop().attach(this);
}@Override
  public void update() {
    if (this.isPaused()) {
      return;
    }

    // clear particles if the effect time to life is reached
    if (this.isFinished()) {
      for (EmitterFinishedListener listener : this.finishedListeners) {
        listener.finished(this);
      }

      this.delete();
      return;
    }

    final float updateRatio = (float) this.data().getUpdateRate() / Game.loop().getTickRate();
    for (final Particle p : this.getParticles().stream().collect(Collectors.toList())) {
      if (this.particleCanBeRemoved(p)) {
        // remove dead particles
        this.particles.remove(p);
        continue;
      }

      p.update(this.getOrigin(), updateRatio);
    }

    this.aliveTime = Game.time().since(this.activationTick);
    if ((this.data().getSpawnRate() == 0
        || Game.time().since(this.lastSpawn) >= this.data().getSpawnRate())) {
      this.lastSpawn = Game.time().now();
      this.spawnParticle();
    }
}
}
```
```java
class de.gurkenlabs.litiengine.entities.behavior.IBehaviorController {
public default void attach() {
    Game.loop().attach(this);
}public default void detach() {
    Game.loop().detach(this);
}
}
```
```java
class de.gurkenlabs.litiengine.abilities.AbilityExecution {
AbilityExecution(final Ability ability) {
    this.appliedEffects = new CopyOnWriteArrayList<>();
    this.ability = ability;
    this.executionTicks = Game.time().now();
    this.impactArea = ability.calculateImpactArea();
    this.castLocation = ability.getExecutor().getCenter();
    Game.loop().attach(this);
}@Override
  public void update() {
    // if there a no effects to apply -> unregister this instance and we're done
    if (this.getAbility().getEffects().isEmpty()
        || this.getAbility().getEffects().size() == this.getAppliedEffects().size()) {
      Game.loop().detach(this);
      return;
    }

    // handle all effects from the ability that were not applied yet
    for (final Effect effect : this.getAbility().getEffects()) {
      // if the ability was not executed yet or the delay of the effect is not
      // yet reached
      if (this.getAppliedEffects().contains(effect)
          || Game.time().since(this.getExecutionTicks()) < effect.getDelay()) {
        continue;
      }

      effect.apply(this.getExecutionImpactArea());
      this.getAppliedEffects().add(effect);
    }
}
}
```
```java
class de.gurkenlabs.litiengine.GameWindow$3 {
@Override
          public void windowGainedFocus(WindowEvent e) {
            Game.loop().setTickRate(Game.config().client().getMaxFps());
}@Override
          public void windowLostFocus(WindowEvent e) {
            if (Game.config().graphics().reduceFramesWhenNotFocused()) {
              Game.loop().setTickRate(NONE_FOCUS_MAX_FPS);
            }
}
}
```
```java
class de.gurkenlabs.litiengine.environment.EntitySpawner {
protected void spawnNewEntities() {
    if (this.getSpawnMode() != SpawnMode.CUSTOMSPAWNPOINTS && this.getSpawnPoints().isEmpty()) {
      return;
    }

    switch (this.getSpawnMode()) {
      case ALLSPAWNPOINTS:
        for (int i = 0; i < this.getSpawnPoints().size(); i++) {
          final int index = i;
          Game.loop()
              .perform(
                  this.getSpawnDelay() + this.getSpawnDelay() * i,
                  () -> this.spawn(this.getSpawnPoints().get(index), this.getSpawnAmount()));
        }
        break;
      case ONERANDOMSPAWNPOINT:
        this.spawn(Game.random().choose(this.getSpawnPoints()), this.getSpawnAmount());
        break;
      case RANDOMSPAWNPOINTS:
        for (int i = 0; i < this.getSpawnAmount(); i++) {
          Game.loop()
              .perform(
                  this.getSpawnDelay() + this.getSpawnDelay() * i,
                  () -> this.spawn(Game.random().choose(this.getSpawnPoints()), 1));
        }
        break;
      case CUSTOMSPAWNPOINTS:
        List<Spawnpoint> spawnPoints =
            this.customSpawnpoints != null
                ? this.customSpawnpoints.apply(this)
                : this.getCustomSpawnpoints();

        int index = 0;
        for (Spawnpoint spawn : spawnPoints) {
          Game.loop()
              .perform(
                  this.getSpawnDelay() + this.getSpawnDelay() * index, () -> this.spawn(spawn, 1));
          index++;
        }
        break;
      default:
        break;
    }
}
}
```
```java
class de.gurkenlabs.litiengine.tweening.TweenEngine {
@Override
  public void start() {
    Game.loop().attach(this);
}@Override
  public void terminate() {
    Game.loop().detach(this);
}
}
```
```java
class de.gurkenlabs.litiengine.gui.SpeechBubble {
public void hide() {
    Game.world().environment().removeRenderable(this);
    Game.loop().detach(this);
    if (activeSpeechBubbles.get(this.getEntity()) != null
        && activeSpeechBubbles.remove(this.getEntity()).equals(this)) {
      activeSpeechBubbles.remove(this.getEntity());
    }

    for (SpeechBubbleListener listener : this.listeners) {
      listener.hidden();
    }
}private SpeechBubble(
      final IEntity entity,
      final String text,
      @Nullable SpeechBubbleAppearance appearance,
      @Nullable Font font) {
    if (appearance == null) {
      this.appearance = DEFAULT_APPEARANCE;
    } else {
      this.appearance = appearance;
    }

    final SpeechBubble active = activeSpeechBubbles.get(entity);
    if (active != null) {
      active.hide();
    }
    this.setFont(font);

    this.textBoxWidth = (float) (entity.getWidth() * 4);
    this.entity = entity;

    this.currentText = text;
    this.currentTextDisplayTime = DISPLAYTIME_MIN + text.length() * DISPLAYTIME_PER_LETTER;

    this.lastTextDisplay = Game.time().now();
    this.createBubbleImage();
    entity.getEnvironment().add(this, RenderType.UI);
    Game.loop().attach(this);
    activeSpeechBubbles.put(entity, this);
}
}
```
```java
class de.gurkenlabs.litiengine.entities.Prop {
private void updateAnimationController() {
    IEntityAnimationController<?> controller = this.createAnimationController();
    this.getControllers().addController(controller);
    if (Game.world().environment() != null && Game.world().environment().isLoaded()) {
      Game.loop().attach(controller);
    }
}
}
```
```java
class de.gurkenlabs.litiengine.graphics.FreeFlightCamera {
public FreeFlightCamera(final Point2D focus) {
    this.setFocus(focus);
    this.velocity = DEFAULT_SCROLL_PIXELS_PER_SECOND;
    this.scrollPadding = DEFAULT_SCROLL_PADDING;
    this.setClampToMap(true);

    Game.loop().attach(this);
}private void handleFreeFlightCamera() {
    if (Game.world().environment() == null || Game.world().environment().getMap() == null) {
      return;
    }

    final Point2D mouseLocation = Input.mouse().getLocation();

    final double scrollSpeed =
        this.getVelocity()
            / (double) Game.loop().getTickRate()
            * Game.config().input().getMouseSensitivity();

    double x = this.getFocus().getX();
    double y = this.getFocus().getY();

    double deltaX = 0;
    if (mouseLocation.getX() < this.getScrollPadding()) {
      deltaX -= scrollSpeed;
    } else if (Game.window().getResolution().getWidth() - mouseLocation.getX()
        < this.getScrollPadding()) {
      deltaX += scrollSpeed;
    }

    double deltaY = 0;
    if (mouseLocation.getY() < this.getScrollPadding()) {
      deltaY -= scrollSpeed;
    } else if (Game.window().getResolution().getHeight() - mouseLocation.getY()
        < this.getScrollPadding()) {
      deltaY += scrollSpeed;
    }

    x += deltaX;
    y += deltaY;

    this.setFocus(new Point2D.Double(x, y));
}
}
```
```java
class de.gurkenlabs.litiengine.environment.Environment {
private static void dispose(final Collection<? extends IEntity> entities) {
    for (final IEntity entity : entities) {
      if (entity instanceof IUpdateable) {
        Game.loop().detach((IUpdateable) entity);
      }

      entity.detachControllers();
    }
}private static void loadUpdatableOrEmitterEntity(IEntity entity) {
    if (entity instanceof Emitter) {
      final Emitter emitter = (Emitter) entity;
      if (emitter.isActivateOnInit()) {
        emitter.activate();
      }
    } else if (entity instanceof IUpdateable) {
      Game.loop().attach((IUpdateable) entity);
    }
}private void unload(final IEntity entity) {
    // 1. remove from physics engine
    if (entity instanceof ICollisionEntity) {
      Game.physics().remove((ICollisionEntity) entity);
    }

    // 2. unregister from update
    if (entity instanceof IUpdateable) {
      Game.loop().detach((IUpdateable) entity);
    }

    if (entity instanceof IMobileEntity) {
      this.removeGravity((IMobileEntity) entity);
    }

    // 3. detach all controllers
    entity.detachControllers();

    if (entity instanceof Emitter) {
      Emitter em = (Emitter) entity;
      em.deactivate();
    }

    if (this.loaded && (entity instanceof LightSource || entity instanceof StaticShadow)) {
      this.updateLighting(entity);
    }

    entity.removed(this);
}
}
```
```java
class de.gurkenlabs.litiengine.graphics.animation.Animation {
@Override
  public void update() {
    // do nothing if the animation is not playing or the current keyframe is not finished
    if (!this.isPlaying()
        || Game.time().since(this.lastFrameUpdate) < this.getCurrentKeyFrame().getDuration()) {
      return;
    }

    // if we are not looping and the last keyframe is finished, we terminate the animation
    if (!this.isLooping() && this.isLastKeyFrame()) {
      this.terminate();
      return;
    }

    // make sure, we stay inside the keyframe list
    final int newFrameIndex =
        (this.getKeyframes().indexOf(this.currentFrame) + 1) % this.getKeyframes().size();
    final KeyFrame previousFrame = this.currentFrame;
    this.currentFrame = this.getKeyframes().get(newFrameIndex);

    for (KeyFrameListener listener : this.listeners) {
      listener.currentFrameChanged(previousFrame, this.currentFrame);
    }

    this.lastFrameUpdate = Game.loop().getTicks();
}public void restart() {
    this.currentFrame = this.firstFrame;
    this.lastFrameUpdate = Game.loop().getTicks();
}
}
```
```java
class de.gurkenlabs.litiengine.physics.MovementController {
@Override
  public void attach() {
    Game.loop().attach(this);
}private void handleForces() {
    // clean up forces
    this.activeForces.forEach(
        x -> {
          if (x.hasEnded()) {
            this.activeForces.remove(x);
          }
        });

    if (this.activeForces.isEmpty()) {
      return;
    }

    // disable turn-on-move for force handling
    boolean turn = this.getEntity().turnOnMove();
    this.getEntity().setTurnOnMove(false);
    try {
      double deltaX = 0;
      double deltaY = 0;
      for (final Force force : this.activeForces) {
        if (force.cancelOnReached() && force.hasReached(this.getEntity())) {
          force.end();
          continue;
        }

        final Point2D collisionBoxCenter = this.getEntity().getCollisionBoxCenter();
        final double angle =
            GeometricUtilities.calcRotationAngleInDegrees(collisionBoxCenter, force.getLocation());
        final double strength =
            Game.loop().getDeltaTime() * 0.001f * force.getStrength() * Game.loop().getTimeScale();
        deltaX += GeometricUtilities.getDeltaX(angle, strength);
        deltaY += GeometricUtilities.getDeltaY(angle, strength);
      }

      final Point2D target =
          new Point2D.Double(this.getEntity().getX() + deltaX, this.getEntity().getY() + deltaY);
      final boolean success = Game.physics().move(this.getEntity(), target);
      if (!success) {
        for (final Force force : this.activeForces) {
          if (force.cancelOnCollision()) {
            force.end();
          }
        }
      }
    } finally {
      this.getEntity().setTurnOnMove(turn);
    }
}@Override
  public void detach() {
    Game.loop().detach(this);
}public void handleMovement() {
    if (!this.isMovementAllowed()) {
      this.velocity = 0;
      return;
    }

    // max distance an entity can travel within one tick
    final double maxPixelsPerTick = this.getEntity().getTickVelocity();
    final double deltaTime = Game.loop().getDeltaTime() * Game.loop().getTimeScale();

    final double acceleration =
        this.getEntity().getAcceleration() == 0
            ? maxPixelsPerTick
            : deltaTime / this.getEntity().getAcceleration() * maxPixelsPerTick;
    final double deceleration =
        this.getEntity().getDeceleration() == 0
            ? this.getVelocity()
            : deltaTime / this.getEntity().getDeceleration() * maxPixelsPerTick;

    double dx = this.getDx();
    double dy = this.getDy();
    this.setDx(0);
    this.setDy(0);

    final double deltaVelocity =
        Math.min(Math.sqrt(Math.pow(dx, 2) + Math.pow(dy, 2)), acceleration);
    if (deltaVelocity != 0) {
      double newVelocity = this.getVelocity() + deltaVelocity;
      this.setVelocity(newVelocity);
    } else {
      final double newVelocity = Math.max(0, this.getVelocity() - deceleration);
      this.setVelocity(newVelocity);
      dx = GeometricUtilities.getDeltaX(this.moveAngle);
      dy = GeometricUtilities.getDeltaY(this.moveAngle);
    }

    if (this.getVelocity() == 0) {
      this.moveAngle = 0;
      return;
    }

    // actually move entity
    this.moveEntity(dx, dy);
}
}
```
```java
class de.gurkenlabs.litiengine.graphics.animation.AnimationController {
public void detach() {
    Game.loop().detach(this);
}public void attach() {
    Game.loop().attach(this);
}
}
```
```java
class de.gurkenlabs.litiengine.graphics.Camera {
@Override
  public void setZoom(final float targetZoom, final int delay) {
    if (delay == 0) {

      this.zoom = targetZoom;
      this.targetZoom = 0;
      this.zoomDelay = 0;
      this.zoomTick = 0;
      this.zoomStep = 0;

      final ZoomChangedEvent event = new ZoomChangedEvent(this, targetZoom);
      for (final ZoomChangedListener listener : this.zoomListeners) {
        listener.zoomChanged(event);
      }
    } else {
      this.zoomTick = Game.time().now();
      this.targetZoom = targetZoom;
      this.zoomDelay = delay;

      final double tickduration = 1000 / (double) Game.loop().getTickRate();
      final double tickAmount = delay / tickduration;
      final float totalDelta = this.targetZoom - this.zoom;
      this.zoomStep = tickAmount > 0 ? (float) (totalDelta / tickAmount) : totalDelta;
    }
}
}
```
```java
class de.gurkenlabs.litiengine.Game {
public static synchronized void init(String... args) {
    if (initialized) {
      log().log(Level.INFO, "The game has already been initialized.");
      return;
    }

    log.init();
    handleCommandLineArguments(args);

    config().load();
    Locale.setDefault(new Locale(config().client().getCountry(), config().client().getLanguage()));

    gameLoop = new GameLoop("Main Update Loop", config().client().getMaxFps());
    loop().attach(physics());
    loop().attach(world());

    // setup default exception handling for render and update loop
    setUncaughtExceptionHandler(
        new DefaultUncaughtExceptionHandler(config().client().exitOnError()));

    screenManager = new ScreenManager();
    gameWindow = new GameWindow();

    // initialize  the game window
    window().init();
    world.setCamera(new Camera());

    for (GameListener listener : gameListeners) {
      listener.initialized(args);
    }

    if (!isInNoGUIMode()) {
      window().getRenderComponent().onRendered(g -> metrics().render(g));

      graphics()
          .addEntityRenderedListener(
              e -> DebugRenderer.renderEntityDebugInfo(e.getGraphics(), e.getEntity()));

      window().getRenderComponent().onFpsChanged(fps -> metrics().setFramesPerSecond(fps));
      window()
          .setIcons(
              Arrays.asList(
                  Resources.images().get("liti-logo-x16.png"),
                  Resources.images().get("liti-logo-x20.png"),
                  Resources.images().get("liti-logo-x32.png"),
                  Resources.images().get("liti-logo-x48.png")));

      Input.keyboard()
          .onKeyTyped(
              KeyEvent.VK_PRINTSCREEN,
              key -> {
                // don't take a screenshot if a modifier is active
                if (key.getModifiers() != 0) {
                  return;
                }

                window().getRenderComponent().takeScreenshot();
              });
    }

    Runtime.getRuntime().addShutdownHook(new Thread(Game::terminate, "Shutdown"));

    initialized = true;
}
}
```
```java
class de.gurkenlabs.litiengine.entities.Creature {
protected void updateAnimationController() {
    IEntityAnimationController<?> controller = this.createAnimationController();
    this.getControllers().addController(controller);
    if (Game.world().environment() != null && Game.world().environment().isLoaded()) {
      Game.loop().attach(controller);
    }
}@Override
  public float getTickVelocity() {
    // pixels per ms multiplied by the passed ms
    // ensure that entities don't travel too far in case of lag
    return Math.min(Game.loop().getDeltaTime(), GameLoop.TICK_DELTATIME_LAG)
        * 0.001F
        * this.getVelocity().get()
        * Game.loop().getTimeScale();
}
}
```
Depth: 2
```java
class de.gurkenlabs.litiengine.environment.GameWorld {
public void clear() {
    this.unloadEnvironment();
    this.environments.clear();
    this.setCamera(null);
    Game.physics().clear();

    this.environmentListeners.clear();
    this.environmentLoadedListeners.clear();
    this.environmentUnloadedListeners.clear();

    this.listeners.clear();
    this.loadedListeners.clear();
    this.unloadedListeners.clear();
}@Nullable
  public Environment loadEnvironment(IMap map) {
    Environment env = this.getEnvironment(map);
    this.loadEnvironment(env);
    return env;
}@Nullable
  public Environment loadEnvironment(String mapName) {
    Environment env = this.getEnvironment(mapName);
    this.loadEnvironment(env);
    return env;
}
}
```
```java
class de.gurkenlabs.litiengine.GameWindow {
GameWindow() {
    this.hostControl = new JFrame();

    this.resolutionChangedListeners = new CopyOnWriteArrayList<>();

    this.renderCanvas = new RenderComponent(Game.config().graphics().getResolution());
    this.cursor = new MouseCursor();
    if (!Game.isInNoGUIMode()) {
      this.hostControl.setBackground(Color.BLACK);
      this.hostControl.add(this.renderCanvas);

      this.initializeEventListeners();

      this.hostControl.setTitle(Game.info().getTitle());
      this.hostControl.setDefaultCloseOperation(WindowConstants.DO_NOTHING_ON_CLOSE);
      initializeWindowEventListeners(this.hostControl);
    }
}
}
```
```java
class de.gurkenlabs.litiengine.GameTime {
public long sinceEnvironmentLoad() {
    return this.since(this.environmentLoaded);
}public long since(final long tick) {
    return toMilliseconds(Game.loop().getTicks() - tick);
}public long sinceGameStart() {
    return this.toMilliseconds(Game.loop().getTicks());
}
}
```
```java
class de.gurkenlabs.litiengine.abilities.effects.Effect {
protected void cease(final EffectApplication appliance) {
    // 1. cease the effect for all affected entities
    for (final ICombatEntity entity : appliance.getAffectedEntities()) {
      this.cease(entity);
    }

    // 2. apply follow up effects
    this.getFollowUpEffects().forEach(followUp -> followUp.apply(appliance.getImpactArea()));
}protected boolean hasEnded(final EffectApplication appliance) {
    final long effectDuration = Game.time().since(appliance.getAppliedTicks());
    return effectDuration > this.getDuration();
}
}
```
```java
class de.gurkenlabs.litiengine.abilities.effects.EffectApplication {
protected EffectApplication(final List<ICombatEntity> affectedEntities, final Shape impactArea) {
    this.applied = Game.time().now();
    this.affectedEntities = affectedEntities;
    this.impactArea = impactArea;
}
}
```
```java
class de.gurkenlabs.litiengine.entities.CombatEntity {
@Override
  public boolean wasHit(int timeSpan) {
    return Game.time().since(this.lastHit) < timeSpan;
}@Override
  public void hit(final int damage, @Nullable final Ability ability) {
    if (this.isDead()) {
      return;
    }

    if (!this.isIndestructible()) {
      this.getHitPoints().modifyBaseValue(new AttributeModifier<>(Modification.SUBTRACT, damage));
    }

    final EntityHitEvent event = new EntityHitEvent(this, ability, damage, this.isDead());

    for (final CombatEntityListener listener : this.listeners) {
      listener.hit(event);
    }

    for (final CombatEntityHitListener listener : this.hitListeners) {
      listener.hit(event);
    }

    if (this.isDead()) {
      this.fireDeathEvent();
      this.setCollision(false);
    }

    this.lastHit = Game.time().now();
}
}
```
```java
class de.gurkenlabs.litiengine.graphics.ImageEffect {
protected ImageEffect(final int ttl, final String name) {
    this.ttl = ttl;
    this.name = name;
    this.aliveTick = Game.time().now();
}@Override
  public long getAliveTime() {
    return Game.time().since(this.aliveTick);
}
}
```
```java
class de.gurkenlabs.litiengine.abilities.AbilityExecution {
AbilityExecution(final Ability ability) {
    this.appliedEffects = new CopyOnWriteArrayList<>();
    this.ability = ability;
    this.executionTicks = Game.time().now();
    this.impactArea = ability.calculateImpactArea();
    this.castLocation = ability.getExecutor().getCenter();
    Game.loop().attach(this);
}@Override
  public void update() {
    // if there a no effects to apply -> unregister this instance and we're done
    if (this.getAbility().getEffects().isEmpty()
        || this.getAbility().getEffects().size() == this.getAppliedEffects().size()) {
      Game.loop().detach(this);
      return;
    }

    // handle all effects from the ability that were not applied yet
    for (final Effect effect : this.getAbility().getEffects()) {
      // if the ability was not executed yet or the delay of the effect is not
      // yet reached
      if (this.getAppliedEffects().contains(effect)
          || Game.time().since(this.getExecutionTicks()) < effect.getDelay()) {
        continue;
      }

      effect.apply(this.getExecutionImpactArea());
      this.getAppliedEffects().add(effect);
    }
}
}
```
```java
class de.gurkenlabs.litiengine.tweening.TweenEngine {
@Override
  public void update() {
    for (final Tweenable target : this.getTweens().keySet()) {
      for (final Tween tween : this.getTweens().get(target).values()) {
        if (tween.hasStopped()) {
          continue;
        }
        final long elapsed = Game.time().since(tween.getStartTime());
        if (elapsed >= tween.getDuration()) {
          tween.stop();
          continue;
        }
        final float[] currentValues = new float[tween.getTargetValues().length];
        for (int i = 0; i < tween.getTargetValues().length; i++) {
          currentValues[i] =
              tween.getStartValues()[i]
                  + tween.getEquation().compute(elapsed / (float) tween.getDuration())
                      * (tween.getTargetValues()[i] - tween.getStartValues()[i]);
        }
        tween.getTarget().setTweenValues(tween.getType(), currentValues);
      }
    }
}
}
```
```java
class de.gurkenlabs.litiengine.gui.SpeechBubble {
public static SpeechBubble create(
      final IEntity entity, final String text, SpeechBubbleAppearance appearance, Font font) {
    return new SpeechBubble(entity, text, appearance, font);
}public static SpeechBubble create(final IEntity entity, final Font font, final String text) {
    SpeechBubbleAppearance app =
        new SpeechBubbleAppearance(
            DEFAULT_APPEARANCE.getForeColor(),
            DEFAULT_APPEARANCE.getBackgroundColor1(),
            DEFAULT_APPEARANCE.getBorderColor(),
            DEFAULT_APPEARANCE.getPadding());
    return new SpeechBubble(entity, text, app, font);
}public static SpeechBubble create(final IEntity entity, final String text) {
    return new SpeechBubble(entity, text, null, GuiProperties.getDefaultFont());
}@Override
  public void update() {
    if (this.currentText == null) {
      this.hide();
      return;
    }

    this.entityCenter = Game.world().camera().getViewportLocation(this.getEntity().getCenter());

    // old text was displayed long enough
    if (this.lastTextDisplay != 0
        && Game.time().since(this.lastTextDisplay) > this.currentTextDisplayTime) {
      this.currentText = null;
      this.lastTextDisplay = 0;
      return;
    }

    // display new text
    if (this.textIndex < this.currentText.length()
        && Game.time().since(this.lastCharPoll) > LETTER_WRITE_DELAY) {
      this.textIndex++;
      this.lastCharPoll = Game.time().now();
      if (this.typeSound != null) {
        Game.audio().playSound(this.typeSound, this.getEntity());
      }
    }

    // continue displaying currently displayed text
}private SpeechBubble(
      final IEntity entity,
      final String text,
      final Sound typeSound,
      SpeechBubbleAppearance appearance,
      Font font) {
    this(entity, text, appearance, font);
    this.typeSound = typeSound;
}private SpeechBubble(
      final IEntity entity,
      final String text,
      @Nullable SpeechBubbleAppearance appearance,
      @Nullable Font font) {
    if (appearance == null) {
      this.appearance = DEFAULT_APPEARANCE;
    } else {
      this.appearance = appearance;
    }

    final SpeechBubble active = activeSpeechBubbles.get(entity);
    if (active != null) {
      active.hide();
    }
    this.setFont(font);

    this.textBoxWidth = (float) (entity.getWidth() * 4);
    this.entity = entity;

    this.currentText = text;
    this.currentTextDisplayTime = DISPLAYTIME_MIN + text.length() * DISPLAYTIME_PER_LETTER;

    this.lastTextDisplay = Game.time().now();
    this.createBubbleImage();
    entity.getEnvironment().add(this, RenderType.UI);
    Game.loop().attach(this);
    activeSpeechBubbles.put(entity, this);
}
}
```
```java
class de.gurkenlabs.litiengine.gui.TextFieldComponent {
@Override
  public void render(final Graphics2D g) {
    super.render(g);
    g.setFont(this.getFont());
    final FontMetrics fm = g.getFontMetrics();

    if (this.isSelected() && Game.time().since(this.lastToggled) > this.flickerDelay) {
      this.cursorVisible = !this.cursorVisible;
      this.lastToggled = Game.time().now();
    }
    if (this.isSelected() && this.cursorVisible) {
      final Rectangle2D cursor =
          new Rectangle2D.Double(
              this.getX() + this.getTextX() + fm.stringWidth(this.getTextToRender(g)),
              this.getY() + this.getTextY(),
              this.getFont().getSize2D() * 3 / 5,
              this.getFont().getSize2D() * 1 / 5);
      g.setColor(this.getAppearance().getForeColor());
      g.fill(cursor);
    }
}
}
```
```java
class de.gurkenlabs.litiengine.entities.Prop {
public Prop(
      final Point2D location, @Nullable final String spritesheetName, final Material material) {
    super();
    this.rotation = Rotation.NONE;
    this.spritesheetName = spritesheetName;
    this.material = material;
    this.setLocation(location);
    this.updateAnimationController();
}public void setSpritesheetName(@Nullable final String spriteName) {
    this.spritesheetName = spriteName;
    this.updateAnimationController();
}
}
```
```java
class de.gurkenlabs.litiengine.tweening.Tween {
public Tween begin() {
    this.started = Game.time().now();
    this.stopped = false;
    return this;
}
}
```
```java
class de.gurkenlabs.litiengine.graphics.emitters.particles.Particle {
public void update(final Point2D emitterOrigin, final float updateRatio) {
    if (this.aliveTick == 0) {
      this.aliveTick = Game.time().now();
    }

    this.aliveTime = Game.time().since(this.aliveTick);
    if (this.timeToLiveReached()) {
      return;
    }

    if (this.colliding) {
      return;
    }

    if (this.getDeltaWidth() != 0) {
      this.width += this.getDeltaWidth() * updateRatio;
    }

    if (this.getDeltaHeight() != 0) {
      this.height += this.getDeltaHeight() * updateRatio;
    }

    if (this.getDeltaAngle() != 0) {
      this.angle += this.getDeltaAngle() * updateRatio;
    }

    // test for ray cast collision
    final float targetX = this.x + this.getVelocityX() * updateRatio;
    final float targetY = this.y + this.getVelocityY() * updateRatio;

    if (targetX == this.x && targetY == this.y) {
      return;
    }

    if (this.checkForCollision(emitterOrigin, targetX, targetY)) {
      return;
    }

    if (this.getVelocityX() != 0) {
      this.x = targetX;
    }

    if (this.getVelocityY() != 0) {
      this.y = targetY;
    }

    if (this.getAccelerationX() != 0) {
      this.velocityX += this.getAccelerationX() * updateRatio;
    }

    if (this.getAccelerationY() != 0) {
      this.velocityY += this.getAccelerationY() * updateRatio;
    }
}
}
```
```java
class de.gurkenlabs.litiengine.graphics.animation.Animation {
@Override
  public void start() {
    this.playing = true;
    if (this.getKeyframes().isEmpty()) {
      return;
    }

    this.restart();
}@Override
  public void update() {
    // do nothing if the animation is not playing or the current keyframe is not finished
    if (!this.isPlaying()
        || Game.time().since(this.lastFrameUpdate) < this.getCurrentKeyFrame().getDuration()) {
      return;
    }

    // if we are not looping and the last keyframe is finished, we terminate the animation
    if (!this.isLooping() && this.isLastKeyFrame()) {
      this.terminate();
      return;
    }

    // make sure, we stay inside the keyframe list
    final int newFrameIndex =
        (this.getKeyframes().indexOf(this.currentFrame) + 1) % this.getKeyframes().size();
    final KeyFrame previousFrame = this.currentFrame;
    this.currentFrame = this.getKeyframes().get(newFrameIndex);

    for (KeyFrameListener listener : this.listeners) {
      listener.currentFrameChanged(previousFrame, this.currentFrame);
    }

    this.lastFrameUpdate = Game.loop().getTicks();
}
}
```
```java
class de.gurkenlabs.litiengine.graphics.animation.AnimationController {
@Override
  public void update() {
    for (final Animation animation : this.getAll()) {
      animation.update();
    }

    if (this.getCurrent() != null && this.getCurrent().isPaused()) {
      return;
    }

    final boolean playbackFinished = this.getCurrent() != null && !this.getCurrent().isPlaying();
    if (playbackFinished) {
      for (final AnimationListener listener : this.listeners) {
        listener.finished(this.getCurrent());
      }
    }

    if (this.getCurrent() == null || playbackFinished) {
      if (this.getDefault() != null) {
        this.play(this.getDefault().getName());
      } else {
        this.currentAnimation = null;
      }
    }
}
}
```
```java
class de.gurkenlabs.litiengine.graphics.RenderComponent {
private void handleFade() {
    if (this.fadeOutStart != -1) {
      final long timePassed = Game.time().since(this.fadeOutStart);
      this.currentAlpha = MathUtilities.clamp(1 - timePassed / (float) this.fadeOutTime, 0, 1);
      if (this.currentAlpha == 0f) {
        this.fadeOutStart = -1;
        this.fadeOutTime = -1;
      }

      return;
    }

    if (this.fadeInStart != -1) {
      final long timePassed = Game.time().since(this.fadeInStart);
      this.currentAlpha = MathUtilities.clamp(timePassed / (float) this.fadeInTime, 0, 1);
      if (this.currentAlpha == 1f) {
        this.fadeInStart = -1;
        this.fadeInTime = -1;
        this.currentAlpha = Float.NaN;
      }
    }
}public void fadeOut(final int ms) {
    this.fadeInStart = -1;
    this.fadeInTime = -1;
    this.fadeOutStart = Game.time().now();
    this.fadeOutTime = ms;
}public void fadeIn(final int ms) {
    this.fadeOutStart = -1;
    this.fadeOutTime = -1;
    this.fadeInStart = Game.time().now();
    this.fadeInTime = ms;
}
}
```
```java
class de.gurkenlabs.litiengine.entities.Trigger {
private boolean activate(final IEntity activator, final int tar) {
    if (!this.isLoaded()
        || this.isOneTimeTrigger && this.isActivated
        || this.getActivationType() == TriggerActivation.COLLISION
            && activator != null
            && this.collisionActivated.contains(activator)) {
      return false;
    }

    if (this.getCooldown() > 0 && Game.time().since(this.lastActivation) < this.getCooldown()) {
      return false;
    }

    List<Integer> triggerTargets = this.getTargets(tar);

    final TriggerEvent te = new TriggerEvent(this, activator, triggerTargets);

    if (!this.checkActivationPredicates(te)) {
      return false;
    }

    this.isActivated = true;
    if (activator != null) {
      this.collisionActivated.add(activator);
    }

    // if we actually have a trigger target, we send the message to the target
    for (final int target : triggerTargets) {
      final IEntity entity = this.getEnvironment().get(target);
      if (entity == null) {
        log.log(
            Level.WARNING,
            "trigger [{0}] was activated, but the trigger target [{1}] could not be found on the environment",
            new Object[] {this, target});
        continue;
      }

      entity.sendMessage(this, this.message);
    }

    // also send the trigger event to all registered consumers
    for (final TriggerActivatedListener listener : this.activatedListeners) {
      listener.activated(te);
    }

    if (this.isOneTimeTrigger) {
      this.getEnvironment().remove(this);
    }

    this.lastActivation = Game.time().now();
    return true;
}
}
```
```java
class de.gurkenlabs.litiengine.graphics.Camera {
private boolean isShakeEffectActive() {
    return this.getShakeTick() != 0
        && Game.time().since(this.getShakeTick()) < this.getShakeDuration();
}@Override
  public void update() {
    if (Game.world().camera() != null && !Game.world().camera().equals(this)) {
      return;
    }

    if (this.targetZoom > 0) {
      if (Game.time().since(this.zoomTick) >= this.zoomDelay) {
        this.zoom = this.targetZoom;
        this.targetZoom = 0;
        this.zoomDelay = 0;
        this.zoomTick = 0;
        this.zoomStep = 0;
      } else {
        this.zoom += this.zoomStep;
      }

      final ZoomChangedEvent event = new ZoomChangedEvent(this, this.getZoom());
      for (final ZoomChangedListener listener : this.zoomListeners) {
        listener.zoomChanged(event);
      }
    }

    if (this.panTime > 0) {
      if (--this.panTime <= 0) {
        this.setFocus(this.targetFocus);
        this.targetFocus = null;
      } else {
        double diff = this.panTime / (this.panTime + 1.0);
        this.focus =
            new Point2D.Double(
                this.focus.getX() * diff + this.targetFocus.getX() * (1.0 - diff),
                this.focus.getY() * diff + this.targetFocus.getY() * (1.0 - diff));
      }
    }

    if (!this.isShakeEffectActive()) {
      this.shakeOffsetX = 0;
      this.shakeOffsetY = 0;
      return;
    }

    if (Game.time().since(this.lastShake) > this.shakeDelay) {
      this.shakeOffsetX = this.getShakeIntensity() * ThreadLocalRandom.current().nextGaussian();
      this.shakeOffsetY = this.getShakeIntensity() * ThreadLocalRandom.current().nextGaussian();
      this.lastShake = Game.time().now();
    }
}@Override
  public void setZoom(final float targetZoom, final int delay) {
    if (delay == 0) {

      this.zoom = targetZoom;
      this.targetZoom = 0;
      this.zoomDelay = 0;
      this.zoomTick = 0;
      this.zoomStep = 0;

      final ZoomChangedEvent event = new ZoomChangedEvent(this, targetZoom);
      for (final ZoomChangedListener listener : this.zoomListeners) {
        listener.zoomChanged(event);
      }
    } else {
      this.zoomTick = Game.time().now();
      this.targetZoom = targetZoom;
      this.zoomDelay = delay;

      final double tickduration = 1000 / (double) Game.loop().getTickRate();
      final double tickAmount = delay / tickduration;
      final float totalDelta = this.targetZoom - this.zoom;
      this.zoomStep = tickAmount > 0 ? (float) (totalDelta / tickAmount) : totalDelta;
    }
}@Override
  public void shake(final double intensity, final int delay, final int shakeDuration) {
    this.shakeTick = Game.time().now();
    this.shakeDelay = delay;
    this.shakeIntensity = intensity;
    this.shakeDuration = shakeDuration;
}
}
```
```java
class de.gurkenlabs.litiengine.entities.Creature {
public void setSpritesheetName(String spritesheetName) {
    if (this.spritesheetName != null && this.spritesheetName.equals(spritesheetName)) {
      return;
    }

    this.spritesheetName = spritesheetName;
    this.updateAnimationController();
}public boolean isIdle() {
    return Game.time().since(this.lastMoved) > IDLE_DELAY;
}@Override
  public void setLocation(final Point2D position) {
    if (this.isDead() || position == null) {
      return;
    }

    final Point2D oldLocation = this.getLocation();
    super.setLocation(position);

    if (Game.hasStarted() && this.isLoaded()) {
      this.lastMoved = Game.time().now();
      this.fireMovedEvent(
          new EntityMovedEvent(
              this, this.getX() - oldLocation.getX(), this.getY() - oldLocation.getY()));
    }
}
}
```
```java
class de.gurkenlabs.litiengine.gui.screens.ScreenManager {
public void display(final String screenName) {
    if (this.current() != null && this.current().getName().equalsIgnoreCase(screenName)) {
      log.log(
          Level.INFO,
          "Skipping displaying of screen {0} because it is already the current screen.",
          screenName);
      return;
    }

    if (this.screens.stream()
        .noneMatch(element -> element.getName().equalsIgnoreCase(screenName))) {
      log.log(
          Level.WARNING,
          "Could not display the screen {0} because there is no screen with the specified name.",
          screenName);
      return;
    }

    Screen screen = this.get(screenName);
    if (screen == null) {
      return;
    }

    this.display(screen);
}public void add(final Screen screen) {
    screen.setWidth(Game.window().getWidth());
    screen.setHeight(Game.window().getHeight());
    this.screens.add(screen);

    if (this.current() == null) {
      this.display(screen);
    }
}public void remove(Screen screen) {
    this.screens.remove(screen);
    if (this.current() == screen) {
      if (!this.screens.isEmpty()) {
        this.display(this.screens.get(0));
      } else {
        this.display((Screen) null);
      }
    }
}public void display(@Nullable final Screen screen) {
    if (Game.hasStarted() && Game.time().since(this.lastScreenChange) < this.getChangeCooldown()) {
      log.log(
          Level.INFO,
          "Skipping displaying of screen {0} because screen changing is currently on cooldown.",
          screen != null ? screen.getName() : "");
      return;
    }

    final Screen previous = this.current();
    if (previous != null) {
      previous.suspend();
    }

    if (screen != null && !this.screens.contains(screen)) {
      this.screens.add(screen);
    }

    this.currentScreen = screen;
    if (!Game.isInNoGUIMode() && this.current() != null) {
      this.current().prepare();
    }

    this.lastScreenChange = Game.loop().getTicks();

    final ScreenChangedEvent event = new ScreenChangedEvent(this.current(), previous);
    for (final ScreenChangedListener listener : this.screenChangedListeners) {
      listener.changed(event);
    }
}
}
```
```java
class de.gurkenlabs.litiengine.abilities.Ability {
public boolean isOnCooldown() {
    return (this.getCurrentExecution() != null
        && this.getCurrentExecution().getExecutionTicks() > 0
        && Game.time().since(this.getCurrentExecution().getExecutionTicks())
            < this.getAttributes().cooldown().get());
}public boolean isActive() {
    return this.getCurrentExecution() != null
        && Game.time().since(this.getCurrentExecution().getExecutionTicks())
            < this.getAttributes().duration().get();
}@Nullable
  public AbilityExecution cast() {
    if (!this.canCast()) {
      return null;
    }
    this.currentExecution = new AbilityExecution(this);

    for (final AbilityCastListener listener : this.abilityCastListeners) {
      listener.abilityCast(this.currentExecution);
    }

    return this.getCurrentExecution();
}public float getRemainingCooldownInSeconds() {
    if (this.getCurrentExecution() == null
        || this.getExecutor() == null
        || this.getExecutor().isDead()) {
      return 0;
    }

    // calculate cooldown in seconds
    return (float)
        (!this.canCast()
            ? (this.getAttributes().cooldown().get()
                    - Game.time().since(this.getCurrentExecution().getExecutionTicks()))
                * 0.001
            : 0);
}
}
```
```java
class de.gurkenlabs.litiengine.entities.EntityHitEvent {
EntityHitEvent(
      final ICombatEntity hitEntity,
      @Nullable final Ability ability,
      final int damage,
      final boolean kill) {
    super(hitEntity);
    this.executor = ability != null ? ability.getExecutor() : null;
    this.hitEntity = hitEntity;
    this.ability = ability;
    this.damage = damage;
    this.kill = kill;
    this.time = Game.time().now();
}
}
```
```java
class de.gurkenlabs.litiengine.graphics.emitters.Emitter {
public void delete() {
    this.deactivate();
    if (Game.world().environment() != null) {
      Game.world().environment().remove(this);
    }
}public void activate() {
    if (this.activated) {
      return;
    }

    this.activated = true;
    this.activationTick = Game.time().now();
    Game.loop().attach(this);
}@Override
  public void update() {
    if (this.isPaused()) {
      return;
    }

    // clear particles if the effect time to life is reached
    if (this.isFinished()) {
      for (EmitterFinishedListener listener : this.finishedListeners) {
        listener.finished(this);
      }

      this.delete();
      return;
    }

    final float updateRatio = (float) this.data().getUpdateRate() / Game.loop().getTickRate();
    for (final Particle p : this.getParticles().stream().collect(Collectors.toList())) {
      if (this.particleCanBeRemoved(p)) {
        // remove dead particles
        this.particles.remove(p);
        continue;
      }

      p.update(this.getOrigin(), updateRatio);
    }

    this.aliveTime = Game.time().since(this.activationTick);
    if ((this.data().getSpawnRate() == 0
        || Game.time().since(this.lastSpawn) >= this.data().getSpawnRate())) {
      this.lastSpawn = Game.time().now();
      this.spawnParticle();
    }
}
}
```
```java
class de.gurkenlabs.litiengine.GameLoop {
@Override
  public int perform(int delay, Runnable action) {
    final long d = Game.time().toTicks(delay);

    TimedAction a = new TimedAction(this.getTicks() + d, action);
    this.actions.add(a);

    return a.getId();
}
}
```
```java
class de.gurkenlabs.litiengine.environment.EntitySpawner {
protected boolean shouldSpawn() {
    return this.lastSpawnWave == 0
        || Game.time().since(this.lastSpawnWave) >= this.getSpawnInterval();
}@Override
  public void update() {
    if (!this.shouldSpawn()) {
      return;
    }

    this.spawnNewEntities();
    this.lastSpawnWave = Game.time().now();
}
}
```
```java
class de.gurkenlabs.litiengine.graphics.FreeFlightCamera {
@Override
  public void update() {
    this.handleFreeFlightCamera();
}public FreeFlightCamera(double x, double y) {
    this(new Point2D.Double(x, y));
}
}
```
```java
class de.gurkenlabs.litiengine.environment.Environment {
public void unload() {
    if (!this.loaded) {
      return;
    }

    // unregister all updatable entities from the current environment
    for (final IEntity entity : this.allEntities.values()) {
      this.unload(entity);
    }

    this.loaded = false;
    this.fireEvent(l -> l.unloaded(this));
}private static void loadUpdatableOrEmitterEntity(IEntity entity) {
    if (entity instanceof Emitter) {
      final Emitter emitter = (Emitter) entity;
      if (emitter.isActivateOnInit()) {
        emitter.activate();
      }
    } else if (entity instanceof IUpdateable) {
      Game.loop().attach((IUpdateable) entity);
    }
}public void clear() {
    Game.physics().clear();

    this.combatEntities.clear();
    this.mobileEntities.clear();
    this.gravityForces.clear();
    this.layerEntities.clear();
    this.entitiesByTag.clear();
    this.allEntities.clear();

    for (RenderType renderType : RenderType.values()) {
      this.miscEntities.get(renderType).clear();
      this.renderListeners.get(renderType).clear();
      this.renderables.get(renderType).clear();
    }

    dispose(this.allEntities.values());
    dispose(this.triggers);
    this.emitters.clear();
    this.colliders.clear();
    this.props.clear();
    this.creatures.clear();
    this.staticShadows.clear();
    this.combatEntities.clear();
    this.mobileEntities.clear();
    this.lightSources.clear();
    this.spawnPoints.clear();
    this.soundSources.clear();
    this.mapAreas.clear();
    this.triggers.clear();

    this.ambientLight = null;
    this.staticShadowLayer = null;

    for (Map<Integer, IEntity> type : this.miscEntities.values()) {
      type.clear();
    }

    this.initialized = false;

    this.fireEvent(l -> l.cleared(this));
}private void load(final IEntity entity) {
    // an entity can only exist on one environment at a time, so remove it from the current one
    if (entity.getEnvironment() != null) {
      entity.getEnvironment().remove(entity);
    }

    // 1. add to physics engine
    loadPhysicsEntity(entity);

    // 2. register for update or activate
    loadUpdatableOrEmitterEntity(entity);

    // 3. if a gravity is defined, add a gravity force to the entity
    if (entity instanceof IMobileEntity && this.getGravity() != 0) {
      this.addGravityForce((IMobileEntity) entity);
    }

    // 4. attach all controllers
    entity.attachControllers();

    if (this.loaded && (entity instanceof LightSource || entity instanceof StaticShadow)) {
      this.updateLighting(entity);
    }

    entity.loaded(this);
}private void unload(final IEntity entity) {
    // 1. remove from physics engine
    if (entity instanceof ICollisionEntity) {
      Game.physics().remove((ICollisionEntity) entity);
    }

    // 2. unregister from update
    if (entity instanceof IUpdateable) {
      Game.loop().detach((IUpdateable) entity);
    }

    if (entity instanceof IMobileEntity) {
      this.removeGravity((IMobileEntity) entity);
    }

    // 3. detach all controllers
    entity.detachControllers();

    if (entity instanceof Emitter) {
      Emitter em = (Emitter) entity;
      em.deactivate();
    }

    if (this.loaded && (entity instanceof LightSource || entity instanceof StaticShadow)) {
      this.updateLighting(entity);
    }

    entity.removed(this);
}public void remove(final IEntity entity) {
    if (entity == null) {
      return;
    }

    this.allEntities.remove(entity.getMapId());
    Iterator<List<IEntity>> iter = this.layerEntities.values().iterator();
    while (iter.hasNext()) {
      List<IEntity> layer = iter.next();
      if (layer.remove(entity) && layer.isEmpty()) {
        iter.remove();
      }
    }
    if (this.miscEntities.get(entity.getRenderType()) != null) {
      this.miscEntities.get(entity.getRenderType()).values().remove(entity);
    }

    for (String tag : entity.getTags()) {
      if (this.getEntitiesByTag().containsKey(tag)) {
        this.getEntitiesByTag().get(tag).remove(entity);

        if (this.getEntitiesByTag().get(tag).isEmpty()) {
          this.getEntitiesByTag().remove(tag);
        }
      }
    }

    if (entity instanceof Emitter) {
      Emitter emitter = (Emitter) entity;
      this.removeEmitter(emitter);
    }

    if (entity instanceof MapArea) {
      this.mapAreas.remove(entity);
    }

    if (entity instanceof Prop) {
      this.props.remove(entity);
    }

    if (entity instanceof Creature) {
      this.creatures.remove(entity);
    }

    if (entity instanceof CollisionBox) {
      this.colliders.remove(entity);
      this.staticShadows.removeIf(x -> x.getOrigin() != null && x.getOrigin().equals(entity));
    }

    if (entity instanceof LightSource) {
      this.lightSources.remove(entity);
      this.updateLighting(entity);
    }

    if (entity instanceof Trigger) {
      this.triggers.remove(entity);
    }

    if (entity instanceof Spawnpoint) {
      this.spawnPoints.remove(entity);
    }
    if (entity instanceof SoundSource) {
      this.soundSources.remove(entity);
    }

    if (entity instanceof StaticShadow) {
      this.staticShadows.remove(entity);
      this.updateLighting(entity);
    }

    if (entity instanceof IMobileEntity) {
      this.mobileEntities.values().remove(entity);
    }

    if (entity instanceof ICombatEntity) {
      this.combatEntities.values().remove(entity);
    }

    this.unload(entity);

    this.fireEntityEvent(l -> l.entityRemoved(entity));
}
}
```
```java
class de.gurkenlabs.litiengine.physics.MovementController {
@Override
  public void update() {
    this.handleForces();
    this.handleMovement();
}
}
```
```java
class de.gurkenlabs.litiengine.Game {
static synchronized void terminate() {
    if (!initialized) {
      return;
    }

    hasStarted = false;
    initialized = false;

    config().save();
    gameLoop.terminate();
    tweenEngine.terminate();
    soundEngine.terminate();

    world().clear();

    for (final GameListener listener : gameListeners) {
      try {
        listener.terminated();
      } catch (Exception e) {
        log().log(Level.WARNING, "game listener threw an exception during shutdown", e);
      }
    }

    gameLoop = null;
    screenManager = null;
    gameWindow = null;
}public static synchronized void start() {
    if (!initialized) {
      throw new IllegalStateException(
          "The game cannot be started without being first initialized. Call Game.init(...) before Game.start().");
    }

    gameLoop.start();
    tweenEngine.start();
    soundEngine.start();

    for (final GameListener listener : gameListeners) {
      listener.started();
    }

    hasStarted = true;
}public static synchronized void init(String... args) {
    if (initialized) {
      log().log(Level.INFO, "The game has already been initialized.");
      return;
    }

    log.init();
    handleCommandLineArguments(args);

    config().load();
    Locale.setDefault(new Locale(config().client().getCountry(), config().client().getLanguage()));

    gameLoop = new GameLoop("Main Update Loop", config().client().getMaxFps());
    loop().attach(physics());
    loop().attach(world());

    // setup default exception handling for render and update loop
    setUncaughtExceptionHandler(
        new DefaultUncaughtExceptionHandler(config().client().exitOnError()));

    screenManager = new ScreenManager();
    gameWindow = new GameWindow();

    // initialize  the game window
    window().init();
    world.setCamera(new Camera());

    for (GameListener listener : gameListeners) {
      listener.initialized(args);
    }

    if (!isInNoGUIMode()) {
      window().getRenderComponent().onRendered(g -> metrics().render(g));

      graphics()
          .addEntityRenderedListener(
              e -> DebugRenderer.renderEntityDebugInfo(e.getGraphics(), e.getEntity()));

      window().getRenderComponent().onFpsChanged(fps -> metrics().setFramesPerSecond(fps));
      window()
          .setIcons(
              Arrays.asList(
                  Resources.images().get("liti-logo-x16.png"),
                  Resources.images().get("liti-logo-x20.png"),
                  Resources.images().get("liti-logo-x32.png"),
                  Resources.images().get("liti-logo-x48.png")));

      Input.keyboard()
          .onKeyTyped(
              KeyEvent.VK_PRINTSCREEN,
              key -> {
                // don't take a screenshot if a modifier is active
                if (key.getModifiers() != 0) {
                  return;
                }

                window().getRenderComponent().takeScreenshot();
              });
    }

    Runtime.getRuntime().addShutdownHook(new Thread(Game::terminate, "Shutdown"));

    initialized = true;
}
}
```


Response Format:
Provide the answer in **XML format** as follows:

#### If the method **cannot** return `null` at the specific call site:
```xml
<response>
  <reason><![CDATA[EXPLAIN WHY THE INVOCATION Game.loop() RESULT CANNOT BE NULL.]]></reason>
  <value>NO</value>
</response>

#### If the method can return null at the specific call site:
<response>
  <reason><![CDATA[EXPLAIN WHY THE INVOCATION Game.loop() RESULT CAN BE NULL.]]></reason>
  <value>YES</value>
</response>

#### If you are unsure or If there are any methods that directly or indirectly affect the return value and are not fully disclosed, request their declarations first, in the following format:
<response>
  <reason><![CDATA[EXPLAIN WHY THIS METHOD DECLARATION IS NECESSARY AND WHY YOU CANNOT MAKE A CONFIDENT DECISION WITHOUT IT]]></reason>
  <success>false</success>
  <methods>
    <method>methodName</method>
  </methods>
</response>

Additional Notes:
Be precise in your reasoning.
If a method’s return value depends on another method not provided, request its declaration before making a conclusion.
If the method can return null in this case but not in others, explain why it happens specifically for this call.

---ChatGPT.sendRequestToOpenAI---
Retrieving response from cache
---Response.<init>---
Creating Response:
```xml
<response>
  <reason><![CDATA[The method `Game.loop()` returns the static field `gameLoop`, which is initialized in the `Game.init(String... args)` method. In this method, a new `GameLoop` object is instantiated and assigned to `gameLoop`. Since `init()` must be called before `start()`, which is implied by the requirement of initializing the game, the `gameLoop` is guaranteed to be non-null during the lifetime of the game execution where `Game.loop()` is called. The absence of any code that could set `gameLoop` to null after its initialization ensures that `Game.loop()` cannot return null.]]></reason>
  <value>NO</value>
</response>
```
---Response.<init>---
Response created:
Disagreement: The method `Game.loop()` returns the static field `gameLoop`, which is initialized in the `Game.init(String... args)` method. In this method, a new `GameLoop` object is instantiated and assigned to `gameLoop`. Since `init()` must be called before `start()`, which is implied by the requirement of initializing the game, the `gameLoop` is guaranteed to be non-null during the lifetime of the game execution where `Game.loop()` is called. The absence of any code that could set `gameLoop` to null after its initialization ensures that `Game.loop()` cannot return null.
---AdvancedNullAwayCodeFix.resolveMethodDereferenceError---
Method is not returning nullable on call site. Injecting suppression annotation.
---AdvancedNullAwayCodeFix.constructCastToNonnullChange---
Constructing cast to nonnull change for reason: The method `Game.loop()` returns the static field `gameLoop`, which is initialized in the `Game.init(String... args)` method. In this method, a new `GameLoop` object is instantiated and assigned to `gameLoop`. Since `init()` must be called before `start()`, which is implied by the requirement of initializing the game, the `gameLoop` is guaranteed to be non-null during the lifetime of the game execution where `Game.loop()` is called. The absence of any code that could set `gameLoop` to null after its initialization ensures that `Game.loop()` cannot return null.
---ChatGPT.ask---
Asking ChatGPT:
For the reason you mentioned earlier:

"The method `Game.loop()` returns the static field `gameLoop`, which is initialized in the `Game.init(String... args)` method. In this method, a new `GameLoop` object is instantiated and assigned to `gameLoop`. Since `init()` must be called before `start()`, which is implied by the requirement of initializing the game, the `gameLoop` is guaranteed to be non-null during the lifetime of the game execution where `Game.loop()` is called. The absence of any code that could set `gameLoop` to null after its initialization ensures that `Game.loop()` cannot return null."

in the method below, the expression Game.loop() is not nullable at the point it is used.

```java
private void updateAnimationController() {
    IEntityAnimationController<?> controller = this.createAnimationController();
    this.getControllers().addController(controller);
    if (Game.world().environment() != null && Game.world().environment().isLoaded()) {
      Game.loop().attach(controller);
    }
}
```
Please Summarize the reason in max 5 words and rewrite the method so that at the line "      Game.loop().attach(controller);", at the occurrence of: "Game.loop()" is replaced with `NullabilityUtil.castToNonnull(Game.loop(), summary of reason)`
Replace "REASON" with the exact reason summary I provide to you (maximum 5 words), not with a generic explanation like "checked to be nonnull".
see the example below, for expression `foo.getBar()`, to wrap it with `NullabilityUtil.castToNonnull(foo.getBar(), "reason")`.

```java
public t(){
    String l = foo.getBar();
}
```

will be:
```java
public t(){
    String l = NullabilityUtil.castToNonnull(foo.getBar(), "checked to be nonnull");
}
```

### Instructions:

Do not import any additional classes.

Do not add Java comments.

Only modify relevant lines as required.

Return only the modified method wrapped in the XML format shown below.

Place the Java code inside the <code> tag using a CDATA block with ```java formatting.

Just give me the fixed code snippet in XML format in <response> tag like the example below. I will apply the fix to my codebase. Do not import any additional libraries or classes or add java comments. If you can provide the fixed code snippet, please provide it in the following format and place the code snippet in the <code> tag within ```java block.
<response>
  <success>true</success>
  <code><![CDATA[
  ```java
  Your fixed code snippet here
  ```
    ]]>
  </code>
</response>

---ChatGPT.sendRequestToOpenAI---
Sending request to OpenAI...
---ChatGPT.sendRequestToOpenAI---
Response received from OpenAI.
---Response.<init>---
Creating Response:
```java
<response>
  <success>true</success>
  <code><![CDATA[
  ```java
  private void updateAnimationController() {
      IEntityAnimationController<?> controller = this.createAnimationController();
      this.getControllers().addController(controller);
      if (Game.world().environment() != null && Game.world().environment().isLoaded()) {
        NullabilityUtil.castToNonnull(Game.loop(), "cannot return null").attach(controller);
      }
  }
  ```
    ]]>
  </code>
</response>
```
---Response.<init>---
Response created:
private void updateAnimationController() {
      IEntityAnimationController<?> controller = this.createAnimationController();
      this.getControllers().addController(controller);
      if (Game.world().environment() != null && Game.world().environment().isLoaded()) {
        NullabilityUtil.castToNonnull(Game.loop(), "cannot return null").attach(controller);
      }
  }
---ChatGPT.fixDereferenceByAddingCastToNonnull---
Fixing the error by adding castToNonnull
---AdvancedNullAwayCodeFix.fixTriggeredErrorsForLocation---
Resolving unresolvable error for triggered error: Type='DEREFERENCE_NULLABLE', message='dereferenced expression Game.loop() is @Nullable'
/home/nima/Developer/nullness-benchmarks/litiengine/src/de/gurkenlabs/litiengine/gui/SpeechBubble.java:86
    Game.loop().attach(this);
---AdvancedNullAwayCodeFix.fix---
Fixing error: Type='DEREFERENCE_NULLABLE', message='dereferenced expression Game.loop() is @Nullable'
/home/nima/Developer/nullness-benchmarks/litiengine/src/de/gurkenlabs/litiengine/gui/SpeechBubble.java:86
    Game.loop().attach(this);
---AdvancedNullAwayCodeFix.resolveDereferenceError---
Resolving dereference error: Type='DEREFERENCE_NULLABLE', message='dereferenced expression Game.loop() is @Nullable'
/home/nima/Developer/nullness-benchmarks/litiengine/src/de/gurkenlabs/litiengine/gui/SpeechBubble.java:86
    Game.loop().attach(this);
---AdvancedNullAwayCodeFix.resolveDereferenceError---
Checking nullability possibility at error point
---ChatGPT.checkNullabilityPossibilityAtErrorPoint---
Asking if the expression can be null at error point point
---ChatGPT.ask---
Asking ChatGPT:
In the method below, is there a possibility that the expression "Game.loop()" at line "Game.loop().attach(this);" is null?
private SpeechBubble(
      final IEntity entity,
      final String text,
      @Nullable SpeechBubbleAppearance appearance,
      @Nullable Font font) {
    if (appearance == null) {
      this.appearance = DEFAULT_APPEARANCE;
    } else {
      this.appearance = appearance;
    }

    final SpeechBubble active = activeSpeechBubbles.get(entity);
    if (active != null) {
      active.hide();
    }
    this.setFont(font);

    this.textBoxWidth = (float) (entity.getWidth() * 4);
    this.entity = entity;

    this.currentText = text;
    this.currentTextDisplayTime = DISPLAYTIME_MIN + text.length() * DISPLAYTIME_PER_LETTER;

    this.lastTextDisplay = Game.time().now();
    this.createBubbleImage();
    entity.getEnvironment().add(this, RenderType.UI);
    Game.loop().attach(this);
    activeSpeechBubbles.put(entity, this);
}
Give a single-word answer in XML format. If it is possible for the expression to be null, respond with:
```xml
<response>
    <reason><![CDATA[YOUR REASON]]></reason>
    <value>YES</value>
</response>
```
If it is not possible for the expression to be null, respond with:
```xml
<response>
    <reason><![CDATA[YOUR REASON]]></reason>
    <value>NO</value>
</response>
```
If you are unsure or need more information, respond with where you can ask for more details or what specific information you need.

If additional information is required, list each request inside a `<request>` tag. If no additional information is needed, omit the `<requests>` section.

Respond with:
```xml
<response>
    <reason><![CDATA[YOUR REASON]]></reason>
    <value>UNKNOWN</value>
    <!-- Include <requests> only if additional information is needed -->
    <requests>
        <request><![CDATA[YOUR REQUEST 1]]></request>
        <request><![CDATA[YOUR REQUEST 2]]></request>
    </requests>
</response>
```
---ChatGPT.sendRequestToOpenAI---
Sending request to OpenAI...
---ChatGPT.sendRequestToOpenAI---
Response received from OpenAI.
---Response.<init>---
Creating Response:
```xml
<response>
    <reason><![CDATA[Without the implementation details of the Game class, we cannot determine if Game.loop() can return null.]]></reason>
    <value>UNKNOWN</value>
    <requests>
        <request><![CDATA[What is the implementation of the Game class, specifically the loop() method?]]></request>
    </requests>
</response>
```
---Response.<init>---
Response created:
Unknown: Without the implementation details of the Game class, we cannot determine if Game.loop() can return null.
---AdvancedNullAwayCodeFix.resolveMethodDereferenceError---
Resolving method dereference error.
---AdvancedNullAwayCodeFix.resolveMethodDereferenceError---
Method is in annotated package. Checking if the method is returning nullable.
---AdvancedNullAwayCodeFix.investigateMethodReturnNullability---
Checking if the method is returning nullable.
---ChatGPT.checkIfMethodIsReturningNullable---
Asking if the method is returning nullable: loop()
---ChatGPT.ask---
Asking ChatGPT:
In the method below, is there a possibility that the method returns null based only on its body? Consider the following points:

- The method may have multiple return paths; consider all return statements.
- If the method calls another method, do not assume its return value unless its full declaration is provided. Request its declaration if needed.
- The method may throw an exception instead of returning null. An exception path should not be considered a null return.
- Ensure you request the declarations of any methods whose return values directly or indirectly impact this method’s return value before making a conclusion.
- Carefully analyze all conditions and prior operations that may guarantee a non-null return value.

@Nullable public static IGameLoop loop() {
    return gameLoop;
}

Here are the method definitions in addition to the method inquired:

Depth: 0
```java
class de.gurkenlabs.litiengine.Game {
@Nullable public static IGameLoop loop() {
    return gameLoop;
}
}
```


Response Format:
Provide the answer in **XML format** as follows:

#### If the method **cannot** return `null`:
```xml
<response>
  <reason><![CDATA[EXPLAIN WHY THE METHOD CANNOT RETURN NULL]]></reason>
  <value>NO</value>
</response>
```

#### If the method can return null:
```xml
<response>
  <reason><![CDATA[EXPLAIN WHY THE METHOD CAN RETURN NULL]]></reason>
  <value>YES</value>
</response>
```

#### If you are unsure or need more information, respond with where you can ask for more details or what specific information you need.

#### If you are unsure or If there are any methods that directly or indirectly affect the return value and are not fully disclosed, request their declarations first, in the following format:
<response>
  <reason><![CDATA[YOUR REASON]]></reason>
  <value>UNKNOWN</value>
  <methods>
    <method>methodName</method>
  </methods>
</response>

If additional information is required other than method declaration, list each request inside a `<request>` tag. If no additional information is needed, omit the `<requests>` section.

Respond with:
```xml
<response>
    <reason><![CDATA[YOUR REASON]]></reason>
    <value>UNKNOWN</value>
    <!-- Include <requests> only if additional information is needed -->
    <requests>
        <request><![CDATA[YOUR REQUEST 1]]></request>
        <request><![CDATA[YOUR REQUEST 2]]></request>
    </requests>
</response>
```

Additional Notes:
Be precise in your reasoning.
If a method’s return value depends on another method not provided, request its declaration before making a conclusion.
If the method can return null in some cases but not others, explain under what conditions it can happen.

---ChatGPT.sendRequestToOpenAI---
Retrieving response from cache
---Response.<init>---
Creating Response:
```xml
<response>
  <reason><![CDATA[The method `loop` returns the variable `gameLoop`. Without the initialization or assignment details of `gameLoop`, it's unclear whether it can be null. The possibility of `gameLoop` being uninitialized or set to null elsewhere in the program means `loop` could potentially return null. Further information on `gameLoop` is required.]]></reason>
  <value>UNKNOWN</value>
  <requests>
    <request><![CDATA[Please provide the declaration and initialization of the variable `gameLoop` in the class `de.gurkenlabs.litiengine.Game`.]]></request>
  </requests>
</response>
```
---Response.<init>---
Response created:
Unknown: The method `loop` returns the variable `gameLoop`. Without the initialization or assignment details of `gameLoop`, it's unclear whether it can be null. The possibility of `gameLoop` being uninitialized or set to null elsewhere in the program means `loop` could potentially return null. Further information on `gameLoop` is required.
---AdvancedNullAwayCodeFix.investigateMethodReturnNullability---
Could not determine the nullability and model did not ask for any method.
---ChatGPT.checkIfMethodIsReturningNullableOnCallSite---
Asking if the method is returning nullable on the call site: Game.loop()
---ChatGPT.ask---
Asking ChatGPT:
In the method below, is there a possibility that the method returns null at the given call site?

```java
@Nullable public static IGameLoop loop() {
    return gameLoop;
}
```

## Guidelines:
- The method may have multiple return paths; consider all return statements.
- If the method calls another method, do not assume its return value unless its full declaration is provided. Request its declaration if needed.
- The method may throw an exception instead of returning null. An exception path should not be considered a null return.
- Ensure you request the declarations of any methods whose return values directly or indirectly impact this method’s return value before making a conclusion.
- If the method returns a value that is determined by a parameter, evaluate based on the actual argument at the given call site.
- Analyze based only on the specific invocation provided. Do not generalize to all possible inputs.- If the return value is guaranteed to be non-null at the call site, the answer should be a definitive NO.
- Do not generalize based on all possible inputs—your answer must be based only on the given invocation.
- Focus only on the given call site, not all possible invocations.

### call site:
Game.loop()

Here are the method definitions and the call chain for this method, showing the sequence of calls from the method to its callers at each depth level:

Depth: 0
```java
class de.gurkenlabs.litiengine.Game {
@Nullable public static IGameLoop loop() {
    return gameLoop;
}
}
```
Depth: 1
```java
class de.gurkenlabs.litiengine.environment.GameWorld {
public void loadEnvironment(@Nullable final Environment env) {
    Lock lock = Game.loop().getLock();
    lock.lock();
    try {
      unloadEnvironment();
      this.environment = env;
      if (env != null) {
        this.addEnvironment(env);

        if (env.getGravity() == 0 && this.gravity() != 0) {
          env.setGravity(this.gravity());
        }

        env.load();
        for (final EnvironmentLoadedListener listener : this.loadedListeners) {
          listener.loaded(env);
        }

        // call map specific listeners
        String mapName = getMapName(env);
        if (mapName != null && this.environmentLoadedListeners.containsKey(mapName)) {

          // for the default camera we center the camera on the environment
          if (this.camera().getClass().equals(Camera.class)) {
            camera().setFocus(env.getCenter());
          }

          for (EnvironmentLoadedListener listener : this.environmentLoadedListeners.get(mapName)) {
            listener.loaded(env);
          }
        }
      }
    } finally {
      lock.unlock();
    }
}public void setCamera(@Nullable final ICamera cam) {
    if (this.camera() != null) {
      Game.loop().detach(camera);
    }

    camera = cam;

    if (cam != null && !Game.isInNoGUIMode()) {
      Game.loop().attach(cam);
      cam.updateFocus();
    }
}
}
```
```java
class de.gurkenlabs.litiengine.entities.behavior.EntityNavigator {
public EntityNavigator(final IMobileEntity entity, final PathFinder pathFinder) {
    this.cancelNavigationConditions = new CopyOnWriteArrayList<>();
    this.listeners = new CopyOnWriteArrayList<>();
    this.entity = entity;
    this.pathFinder = pathFinder;
    this.setAcceptableError(DEFAULT_ACCEPTABLE_ERROR);
    Game.loop().attach(this);
}
}
```
```java
class de.gurkenlabs.litiengine.GameWindow {
private static void initializeWindowEventListeners(Window window) {

    window.addWindowStateListener(
        e -> {
          if (e.getNewState() == Frame.ICONIFIED) {
            Game.loop().setTickRate(ICONIFIED_MAX_FPS);
          } else {
            Game.loop().setTickRate(Game.config().client().getMaxFps());
          }
        });

    window.addWindowFocusListener(
        new WindowFocusListener() {
          @Override
          public void windowLostFocus(WindowEvent e) {
            if (Game.config().graphics().reduceFramesWhenNotFocused()) {
              Game.loop().setTickRate(NONE_FOCUS_MAX_FPS);
            }
          }

          @Override
          public void windowGainedFocus(WindowEvent e) {
            Game.loop().setTickRate(Game.config().client().getMaxFps());
          }
        });

    window.addWindowListener(
        new WindowAdapter() {
          @Override
          public void windowClosing(final WindowEvent event) {
            Game.exit();
          }
        });
}
}
```
```java
class de.gurkenlabs.litiengine.gui.screens.ScreenManager {
public void display(@Nullable final Screen screen) {
    if (Game.hasStarted() && Game.time().since(this.lastScreenChange) < this.getChangeCooldown()) {
      log.log(
          Level.INFO,
          "Skipping displaying of screen {0} because screen changing is currently on cooldown.",
          screen != null ? screen.getName() : "");
      return;
    }

    final Screen previous = this.current();
    if (previous != null) {
      previous.suspend();
    }

    if (screen != null && !this.screens.contains(screen)) {
      this.screens.add(screen);
    }

    this.currentScreen = screen;
    if (!Game.isInNoGUIMode() && this.current() != null) {
      this.current().prepare();
    }

    this.lastScreenChange = Game.loop().getTicks();

    final ScreenChangedEvent event = new ScreenChangedEvent(this.current(), previous);
    for (final ScreenChangedListener listener : this.screenChangedListeners) {
      listener.changed(event);
    }
}
}
```
```java
class de.gurkenlabs.litiengine.abilities.effects.Effect {
@Override
  public void update() {

    for (final Iterator<EffectApplication> iterator = this.getActiveAppliances().iterator();
        iterator.hasNext(); ) {
      final EffectApplication appliance = iterator.next();
      // if the effect duration is reached
      if (this.hasEnded(appliance)) {

        iterator.remove();
        this.cease(appliance);
      }
    }

    // 4. unregister if all appliances are finished
    if (this.getActiveAppliances().isEmpty()) {
      Game.loop().detach(this);
    }
}public void apply(final Shape impactArea) {
    final List<ICombatEntity> affected = this.lookForAffectedEntities(impactArea);
    for (final ICombatEntity affectedEntity : affected) {
      this.apply(affectedEntity);
    }

    this.appliances.add(new EffectApplication(affected, impactArea));

    // if it is the first appliance -> register for update
    if (this.appliances.size() == 1) {
      Game.loop().attach(this);
    }
}
}
```
```java
class de.gurkenlabs.litiengine.GameTime {
public long toTicks(final int milliseconds) {
    return this.toTicks(milliseconds, Game.loop().getTickRate());
}public long since(final long tick) {
    return toMilliseconds(Game.loop().getTicks() - tick);
}public long now() {
    return Game.loop().getTicks();
}public long sinceGameStart() {
    return this.toMilliseconds(Game.loop().getTicks());
}@Override
  public void loaded(Environment environment) {
    environmentLoaded = Game.loop().getTicks();
}public long toMilliseconds(final long ticks) {
    return this.toMilliseconds(ticks, Game.loop().getTickRate());
}
}
```
```java
class de.gurkenlabs.litiengine.GameMetrics {
@Override
  public void render(final Graphics2D g) {
    this.updateMetrics();

    if (!Game.config().client().showGameMetrics()) {
      return;
    }

    this.currentOffsetY = 0;

    g.setColor(this.renderColor);

    // render client metrics
    this.drawTitle(g, "[client]");
    this.drawMetric(g, "fps       : " + this.getFramesPerSecond());
    this.drawMetric(g, "max fps   : " + this.maxFramesPerSecond);
    this.drawMetric(g, "updatables: " + Game.loop().getUpdatableCount());

    // render jvm metrics if debug is enabled
    if (Game.config().debug().isDebugEnabled()) {
      this.drawTitle(g, "[jvm]");
      this.drawMetric(g, "java      : " + this.javaVersion);
      this.drawMetric(g, "memory    : " + String.format("%-5.5s", this.usedMemory) + " MB");
      this.drawMetric(g, "threads   : " + Thread.activeCount());
    }

    // render rendering metrics
    if (!this.renderMetrics.isEmpty()) {
      this.drawTitle(g, "[update]");

      for (RenderMetrics metric : this.renderMetrics) {
        this.drawMetric(g, metric.toString());
      }

      this.renderMetrics.clear();
    }
}
}
```
```java
class de.gurkenlabs.litiengine.graphics.emitters.Emitter {
public void deactivate() {
    if (!this.activated) {
      return;
    }

    this.activated = false;
    this.getParticles().clear();
    this.aliveTime = 0;
    this.activationTick = 0;
    this.lastSpawn = 0;
    Game.loop().detach(this);
}public void activate() {
    if (this.activated) {
      return;
    }

    this.activated = true;
    this.activationTick = Game.time().now();
    Game.loop().attach(this);
}@Override
  public void update() {
    if (this.isPaused()) {
      return;
    }

    // clear particles if the effect time to life is reached
    if (this.isFinished()) {
      for (EmitterFinishedListener listener : this.finishedListeners) {
        listener.finished(this);
      }

      this.delete();
      return;
    }

    final float updateRatio = (float) this.data().getUpdateRate() / Game.loop().getTickRate();
    for (final Particle p : this.getParticles().stream().collect(Collectors.toList())) {
      if (this.particleCanBeRemoved(p)) {
        // remove dead particles
        this.particles.remove(p);
        continue;
      }

      p.update(this.getOrigin(), updateRatio);
    }

    this.aliveTime = Game.time().since(this.activationTick);
    if ((this.data().getSpawnRate() == 0
        || Game.time().since(this.lastSpawn) >= this.data().getSpawnRate())) {
      this.lastSpawn = Game.time().now();
      this.spawnParticle();
    }
}
}
```
```java
class de.gurkenlabs.litiengine.entities.behavior.IBehaviorController {
public default void attach() {
    Game.loop().attach(this);
}public default void detach() {
    Game.loop().detach(this);
}
}
```
```java
class de.gurkenlabs.litiengine.abilities.AbilityExecution {
AbilityExecution(final Ability ability) {
    this.appliedEffects = new CopyOnWriteArrayList<>();
    this.ability = ability;
    this.executionTicks = Game.time().now();
    this.impactArea = ability.calculateImpactArea();
    this.castLocation = ability.getExecutor().getCenter();
    Game.loop().attach(this);
}@Override
  public void update() {
    // if there a no effects to apply -> unregister this instance and we're done
    if (this.getAbility().getEffects().isEmpty()
        || this.getAbility().getEffects().size() == this.getAppliedEffects().size()) {
      Game.loop().detach(this);
      return;
    }

    // handle all effects from the ability that were not applied yet
    for (final Effect effect : this.getAbility().getEffects()) {
      // if the ability was not executed yet or the delay of the effect is not
      // yet reached
      if (this.getAppliedEffects().contains(effect)
          || Game.time().since(this.getExecutionTicks()) < effect.getDelay()) {
        continue;
      }

      effect.apply(this.getExecutionImpactArea());
      this.getAppliedEffects().add(effect);
    }
}
}
```
```java
class de.gurkenlabs.litiengine.GameWindow$3 {
@Override
          public void windowGainedFocus(WindowEvent e) {
            Game.loop().setTickRate(Game.config().client().getMaxFps());
}@Override
          public void windowLostFocus(WindowEvent e) {
            if (Game.config().graphics().reduceFramesWhenNotFocused()) {
              Game.loop().setTickRate(NONE_FOCUS_MAX_FPS);
            }
}
}
```
```java
class de.gurkenlabs.litiengine.environment.EntitySpawner {
protected void spawnNewEntities() {
    if (this.getSpawnMode() != SpawnMode.CUSTOMSPAWNPOINTS && this.getSpawnPoints().isEmpty()) {
      return;
    }

    switch (this.getSpawnMode()) {
      case ALLSPAWNPOINTS:
        for (int i = 0; i < this.getSpawnPoints().size(); i++) {
          final int index = i;
          Game.loop()
              .perform(
                  this.getSpawnDelay() + this.getSpawnDelay() * i,
                  () -> this.spawn(this.getSpawnPoints().get(index), this.getSpawnAmount()));
        }
        break;
      case ONERANDOMSPAWNPOINT:
        this.spawn(Game.random().choose(this.getSpawnPoints()), this.getSpawnAmount());
        break;
      case RANDOMSPAWNPOINTS:
        for (int i = 0; i < this.getSpawnAmount(); i++) {
          Game.loop()
              .perform(
                  this.getSpawnDelay() + this.getSpawnDelay() * i,
                  () -> this.spawn(Game.random().choose(this.getSpawnPoints()), 1));
        }
        break;
      case CUSTOMSPAWNPOINTS:
        List<Spawnpoint> spawnPoints =
            this.customSpawnpoints != null
                ? this.customSpawnpoints.apply(this)
                : this.getCustomSpawnpoints();

        int index = 0;
        for (Spawnpoint spawn : spawnPoints) {
          Game.loop()
              .perform(
                  this.getSpawnDelay() + this.getSpawnDelay() * index, () -> this.spawn(spawn, 1));
          index++;
        }
        break;
      default:
        break;
    }
}
}
```
```java
class de.gurkenlabs.litiengine.tweening.TweenEngine {
@Override
  public void start() {
    Game.loop().attach(this);
}@Override
  public void terminate() {
    Game.loop().detach(this);
}
}
```
```java
class de.gurkenlabs.litiengine.gui.SpeechBubble {
public void hide() {
    Game.world().environment().removeRenderable(this);
    Game.loop().detach(this);
    if (activeSpeechBubbles.get(this.getEntity()) != null
        && activeSpeechBubbles.remove(this.getEntity()).equals(this)) {
      activeSpeechBubbles.remove(this.getEntity());
    }

    for (SpeechBubbleListener listener : this.listeners) {
      listener.hidden();
    }
}private SpeechBubble(
      final IEntity entity,
      final String text,
      @Nullable SpeechBubbleAppearance appearance,
      @Nullable Font font) {
    if (appearance == null) {
      this.appearance = DEFAULT_APPEARANCE;
    } else {
      this.appearance = appearance;
    }

    final SpeechBubble active = activeSpeechBubbles.get(entity);
    if (active != null) {
      active.hide();
    }
    this.setFont(font);

    this.textBoxWidth = (float) (entity.getWidth() * 4);
    this.entity = entity;

    this.currentText = text;
    this.currentTextDisplayTime = DISPLAYTIME_MIN + text.length() * DISPLAYTIME_PER_LETTER;

    this.lastTextDisplay = Game.time().now();
    this.createBubbleImage();
    entity.getEnvironment().add(this, RenderType.UI);
    Game.loop().attach(this);
    activeSpeechBubbles.put(entity, this);
}
}
```
```java
class de.gurkenlabs.litiengine.entities.Prop {
private void updateAnimationController() {
    IEntityAnimationController<?> controller = this.createAnimationController();
    this.getControllers().addController(controller);
    if (Game.world().environment() != null && Game.world().environment().isLoaded()) {
      Game.loop().attach(controller);
    }
}
}
```
```java
class de.gurkenlabs.litiengine.graphics.FreeFlightCamera {
public FreeFlightCamera(final Point2D focus) {
    this.setFocus(focus);
    this.velocity = DEFAULT_SCROLL_PIXELS_PER_SECOND;
    this.scrollPadding = DEFAULT_SCROLL_PADDING;
    this.setClampToMap(true);

    Game.loop().attach(this);
}private void handleFreeFlightCamera() {
    if (Game.world().environment() == null || Game.world().environment().getMap() == null) {
      return;
    }

    final Point2D mouseLocation = Input.mouse().getLocation();

    final double scrollSpeed =
        this.getVelocity()
            / (double) Game.loop().getTickRate()
            * Game.config().input().getMouseSensitivity();

    double x = this.getFocus().getX();
    double y = this.getFocus().getY();

    double deltaX = 0;
    if (mouseLocation.getX() < this.getScrollPadding()) {
      deltaX -= scrollSpeed;
    } else if (Game.window().getResolution().getWidth() - mouseLocation.getX()
        < this.getScrollPadding()) {
      deltaX += scrollSpeed;
    }

    double deltaY = 0;
    if (mouseLocation.getY() < this.getScrollPadding()) {
      deltaY -= scrollSpeed;
    } else if (Game.window().getResolution().getHeight() - mouseLocation.getY()
        < this.getScrollPadding()) {
      deltaY += scrollSpeed;
    }

    x += deltaX;
    y += deltaY;

    this.setFocus(new Point2D.Double(x, y));
}
}
```
```java
class de.gurkenlabs.litiengine.environment.Environment {
private static void dispose(final Collection<? extends IEntity> entities) {
    for (final IEntity entity : entities) {
      if (entity instanceof IUpdateable) {
        Game.loop().detach((IUpdateable) entity);
      }

      entity.detachControllers();
    }
}private static void loadUpdatableOrEmitterEntity(IEntity entity) {
    if (entity instanceof Emitter) {
      final Emitter emitter = (Emitter) entity;
      if (emitter.isActivateOnInit()) {
        emitter.activate();
      }
    } else if (entity instanceof IUpdateable) {
      Game.loop().attach((IUpdateable) entity);
    }
}private void unload(final IEntity entity) {
    // 1. remove from physics engine
    if (entity instanceof ICollisionEntity) {
      Game.physics().remove((ICollisionEntity) entity);
    }

    // 2. unregister from update
    if (entity instanceof IUpdateable) {
      Game.loop().detach((IUpdateable) entity);
    }

    if (entity instanceof IMobileEntity) {
      this.removeGravity((IMobileEntity) entity);
    }

    // 3. detach all controllers
    entity.detachControllers();

    if (entity instanceof Emitter) {
      Emitter em = (Emitter) entity;
      em.deactivate();
    }

    if (this.loaded && (entity instanceof LightSource || entity instanceof StaticShadow)) {
      this.updateLighting(entity);
    }

    entity.removed(this);
}
}
```
```java
class de.gurkenlabs.litiengine.graphics.animation.Animation {
@Override
  public void update() {
    // do nothing if the animation is not playing or the current keyframe is not finished
    if (!this.isPlaying()
        || Game.time().since(this.lastFrameUpdate) < this.getCurrentKeyFrame().getDuration()) {
      return;
    }

    // if we are not looping and the last keyframe is finished, we terminate the animation
    if (!this.isLooping() && this.isLastKeyFrame()) {
      this.terminate();
      return;
    }

    // make sure, we stay inside the keyframe list
    final int newFrameIndex =
        (this.getKeyframes().indexOf(this.currentFrame) + 1) % this.getKeyframes().size();
    final KeyFrame previousFrame = this.currentFrame;
    this.currentFrame = this.getKeyframes().get(newFrameIndex);

    for (KeyFrameListener listener : this.listeners) {
      listener.currentFrameChanged(previousFrame, this.currentFrame);
    }

    this.lastFrameUpdate = Game.loop().getTicks();
}public void restart() {
    this.currentFrame = this.firstFrame;
    this.lastFrameUpdate = Game.loop().getTicks();
}
}
```
```java
class de.gurkenlabs.litiengine.physics.MovementController {
@Override
  public void attach() {
    Game.loop().attach(this);
}private void handleForces() {
    // clean up forces
    this.activeForces.forEach(
        x -> {
          if (x.hasEnded()) {
            this.activeForces.remove(x);
          }
        });

    if (this.activeForces.isEmpty()) {
      return;
    }

    // disable turn-on-move for force handling
    boolean turn = this.getEntity().turnOnMove();
    this.getEntity().setTurnOnMove(false);
    try {
      double deltaX = 0;
      double deltaY = 0;
      for (final Force force : this.activeForces) {
        if (force.cancelOnReached() && force.hasReached(this.getEntity())) {
          force.end();
          continue;
        }

        final Point2D collisionBoxCenter = this.getEntity().getCollisionBoxCenter();
        final double angle =
            GeometricUtilities.calcRotationAngleInDegrees(collisionBoxCenter, force.getLocation());
        final double strength =
            Game.loop().getDeltaTime() * 0.001f * force.getStrength() * Game.loop().getTimeScale();
        deltaX += GeometricUtilities.getDeltaX(angle, strength);
        deltaY += GeometricUtilities.getDeltaY(angle, strength);
      }

      final Point2D target =
          new Point2D.Double(this.getEntity().getX() + deltaX, this.getEntity().getY() + deltaY);
      final boolean success = Game.physics().move(this.getEntity(), target);
      if (!success) {
        for (final Force force : this.activeForces) {
          if (force.cancelOnCollision()) {
            force.end();
          }
        }
      }
    } finally {
      this.getEntity().setTurnOnMove(turn);
    }
}@Override
  public void detach() {
    Game.loop().detach(this);
}public void handleMovement() {
    if (!this.isMovementAllowed()) {
      this.velocity = 0;
      return;
    }

    // max distance an entity can travel within one tick
    final double maxPixelsPerTick = this.getEntity().getTickVelocity();
    final double deltaTime = Game.loop().getDeltaTime() * Game.loop().getTimeScale();

    final double acceleration =
        this.getEntity().getAcceleration() == 0
            ? maxPixelsPerTick
            : deltaTime / this.getEntity().getAcceleration() * maxPixelsPerTick;
    final double deceleration =
        this.getEntity().getDeceleration() == 0
            ? this.getVelocity()
            : deltaTime / this.getEntity().getDeceleration() * maxPixelsPerTick;

    double dx = this.getDx();
    double dy = this.getDy();
    this.setDx(0);
    this.setDy(0);

    final double deltaVelocity =
        Math.min(Math.sqrt(Math.pow(dx, 2) + Math.pow(dy, 2)), acceleration);
    if (deltaVelocity != 0) {
      double newVelocity = this.getVelocity() + deltaVelocity;
      this.setVelocity(newVelocity);
    } else {
      final double newVelocity = Math.max(0, this.getVelocity() - deceleration);
      this.setVelocity(newVelocity);
      dx = GeometricUtilities.getDeltaX(this.moveAngle);
      dy = GeometricUtilities.getDeltaY(this.moveAngle);
    }

    if (this.getVelocity() == 0) {
      this.moveAngle = 0;
      return;
    }

    // actually move entity
    this.moveEntity(dx, dy);
}
}
```
```java
class de.gurkenlabs.litiengine.graphics.animation.AnimationController {
public void detach() {
    Game.loop().detach(this);
}public void attach() {
    Game.loop().attach(this);
}
}
```
```java
class de.gurkenlabs.litiengine.graphics.Camera {
@Override
  public void setZoom(final float targetZoom, final int delay) {
    if (delay == 0) {

      this.zoom = targetZoom;
      this.targetZoom = 0;
      this.zoomDelay = 0;
      this.zoomTick = 0;
      this.zoomStep = 0;

      final ZoomChangedEvent event = new ZoomChangedEvent(this, targetZoom);
      for (final ZoomChangedListener listener : this.zoomListeners) {
        listener.zoomChanged(event);
      }
    } else {
      this.zoomTick = Game.time().now();
      this.targetZoom = targetZoom;
      this.zoomDelay = delay;

      final double tickduration = 1000 / (double) Game.loop().getTickRate();
      final double tickAmount = delay / tickduration;
      final float totalDelta = this.targetZoom - this.zoom;
      this.zoomStep = tickAmount > 0 ? (float) (totalDelta / tickAmount) : totalDelta;
    }
}
}
```
```java
class de.gurkenlabs.litiengine.Game {
public static synchronized void init(String... args) {
    if (initialized) {
      log().log(Level.INFO, "The game has already been initialized.");
      return;
    }

    log.init();
    handleCommandLineArguments(args);

    config().load();
    Locale.setDefault(new Locale(config().client().getCountry(), config().client().getLanguage()));

    gameLoop = new GameLoop("Main Update Loop", config().client().getMaxFps());
    loop().attach(physics());
    loop().attach(world());

    // setup default exception handling for render and update loop
    setUncaughtExceptionHandler(
        new DefaultUncaughtExceptionHandler(config().client().exitOnError()));

    screenManager = new ScreenManager();
    gameWindow = new GameWindow();

    // initialize  the game window
    window().init();
    world.setCamera(new Camera());

    for (GameListener listener : gameListeners) {
      listener.initialized(args);
    }

    if (!isInNoGUIMode()) {
      window().getRenderComponent().onRendered(g -> metrics().render(g));

      graphics()
          .addEntityRenderedListener(
              e -> DebugRenderer.renderEntityDebugInfo(e.getGraphics(), e.getEntity()));

      window().getRenderComponent().onFpsChanged(fps -> metrics().setFramesPerSecond(fps));
      window()
          .setIcons(
              Arrays.asList(
                  Resources.images().get("liti-logo-x16.png"),
                  Resources.images().get("liti-logo-x20.png"),
                  Resources.images().get("liti-logo-x32.png"),
                  Resources.images().get("liti-logo-x48.png")));

      Input.keyboard()
          .onKeyTyped(
              KeyEvent.VK_PRINTSCREEN,
              key -> {
                // don't take a screenshot if a modifier is active
                if (key.getModifiers() != 0) {
                  return;
                }

                window().getRenderComponent().takeScreenshot();
              });
    }

    Runtime.getRuntime().addShutdownHook(new Thread(Game::terminate, "Shutdown"));

    initialized = true;
}
}
```
```java
class de.gurkenlabs.litiengine.entities.Creature {
protected void updateAnimationController() {
    IEntityAnimationController<?> controller = this.createAnimationController();
    this.getControllers().addController(controller);
    if (Game.world().environment() != null && Game.world().environment().isLoaded()) {
      Game.loop().attach(controller);
    }
}@Override
  public float getTickVelocity() {
    // pixels per ms multiplied by the passed ms
    // ensure that entities don't travel too far in case of lag
    return Math.min(Game.loop().getDeltaTime(), GameLoop.TICK_DELTATIME_LAG)
        * 0.001F
        * this.getVelocity().get()
        * Game.loop().getTimeScale();
}
}
```
Depth: 2
```java
class de.gurkenlabs.litiengine.environment.GameWorld {
public void clear() {
    this.unloadEnvironment();
    this.environments.clear();
    this.setCamera(null);
    Game.physics().clear();

    this.environmentListeners.clear();
    this.environmentLoadedListeners.clear();
    this.environmentUnloadedListeners.clear();

    this.listeners.clear();
    this.loadedListeners.clear();
    this.unloadedListeners.clear();
}@Nullable
  public Environment loadEnvironment(IMap map) {
    Environment env = this.getEnvironment(map);
    this.loadEnvironment(env);
    return env;
}@Nullable
  public Environment loadEnvironment(String mapName) {
    Environment env = this.getEnvironment(mapName);
    this.loadEnvironment(env);
    return env;
}
}
```
```java
class de.gurkenlabs.litiengine.GameWindow {
GameWindow() {
    this.hostControl = new JFrame();

    this.resolutionChangedListeners = new CopyOnWriteArrayList<>();

    this.renderCanvas = new RenderComponent(Game.config().graphics().getResolution());
    this.cursor = new MouseCursor();
    if (!Game.isInNoGUIMode()) {
      this.hostControl.setBackground(Color.BLACK);
      this.hostControl.add(this.renderCanvas);

      this.initializeEventListeners();

      this.hostControl.setTitle(Game.info().getTitle());
      this.hostControl.setDefaultCloseOperation(WindowConstants.DO_NOTHING_ON_CLOSE);
      initializeWindowEventListeners(this.hostControl);
    }
}
}
```
```java
class de.gurkenlabs.litiengine.GameTime {
public long sinceEnvironmentLoad() {
    return this.since(this.environmentLoaded);
}public long since(final long tick) {
    return toMilliseconds(Game.loop().getTicks() - tick);
}public long sinceGameStart() {
    return this.toMilliseconds(Game.loop().getTicks());
}
}
```
```java
class de.gurkenlabs.litiengine.abilities.effects.Effect {
protected void cease(final EffectApplication appliance) {
    // 1. cease the effect for all affected entities
    for (final ICombatEntity entity : appliance.getAffectedEntities()) {
      this.cease(entity);
    }

    // 2. apply follow up effects
    this.getFollowUpEffects().forEach(followUp -> followUp.apply(appliance.getImpactArea()));
}protected boolean hasEnded(final EffectApplication appliance) {
    final long effectDuration = Game.time().since(appliance.getAppliedTicks());
    return effectDuration > this.getDuration();
}
}
```
```java
class de.gurkenlabs.litiengine.abilities.effects.EffectApplication {
protected EffectApplication(final List<ICombatEntity> affectedEntities, final Shape impactArea) {
    this.applied = Game.time().now();
    this.affectedEntities = affectedEntities;
    this.impactArea = impactArea;
}
}
```
```java
class de.gurkenlabs.litiengine.entities.CombatEntity {
@Override
  public boolean wasHit(int timeSpan) {
    return Game.time().since(this.lastHit) < timeSpan;
}@Override
  public void hit(final int damage, @Nullable final Ability ability) {
    if (this.isDead()) {
      return;
    }

    if (!this.isIndestructible()) {
      this.getHitPoints().modifyBaseValue(new AttributeModifier<>(Modification.SUBTRACT, damage));
    }

    final EntityHitEvent event = new EntityHitEvent(this, ability, damage, this.isDead());

    for (final CombatEntityListener listener : this.listeners) {
      listener.hit(event);
    }

    for (final CombatEntityHitListener listener : this.hitListeners) {
      listener.hit(event);
    }

    if (this.isDead()) {
      this.fireDeathEvent();
      this.setCollision(false);
    }

    this.lastHit = Game.time().now();
}
}
```
```java
class de.gurkenlabs.litiengine.graphics.ImageEffect {
protected ImageEffect(final int ttl, final String name) {
    this.ttl = ttl;
    this.name = name;
    this.aliveTick = Game.time().now();
}@Override
  public long getAliveTime() {
    return Game.time().since(this.aliveTick);
}
}
```
```java
class de.gurkenlabs.litiengine.abilities.AbilityExecution {
AbilityExecution(final Ability ability) {
    this.appliedEffects = new CopyOnWriteArrayList<>();
    this.ability = ability;
    this.executionTicks = Game.time().now();
    this.impactArea = ability.calculateImpactArea();
    this.castLocation = ability.getExecutor().getCenter();
    Game.loop().attach(this);
}@Override
  public void update() {
    // if there a no effects to apply -> unregister this instance and we're done
    if (this.getAbility().getEffects().isEmpty()
        || this.getAbility().getEffects().size() == this.getAppliedEffects().size()) {
      Game.loop().detach(this);
      return;
    }

    // handle all effects from the ability that were not applied yet
    for (final Effect effect : this.getAbility().getEffects()) {
      // if the ability was not executed yet or the delay of the effect is not
      // yet reached
      if (this.getAppliedEffects().contains(effect)
          || Game.time().since(this.getExecutionTicks()) < effect.getDelay()) {
        continue;
      }

      effect.apply(this.getExecutionImpactArea());
      this.getAppliedEffects().add(effect);
    }
}
}
```
```java
class de.gurkenlabs.litiengine.tweening.TweenEngine {
@Override
  public void update() {
    for (final Tweenable target : this.getTweens().keySet()) {
      for (final Tween tween : this.getTweens().get(target).values()) {
        if (tween.hasStopped()) {
          continue;
        }
        final long elapsed = Game.time().since(tween.getStartTime());
        if (elapsed >= tween.getDuration()) {
          tween.stop();
          continue;
        }
        final float[] currentValues = new float[tween.getTargetValues().length];
        for (int i = 0; i < tween.getTargetValues().length; i++) {
          currentValues[i] =
              tween.getStartValues()[i]
                  + tween.getEquation().compute(elapsed / (float) tween.getDuration())
                      * (tween.getTargetValues()[i] - tween.getStartValues()[i]);
        }
        tween.getTarget().setTweenValues(tween.getType(), currentValues);
      }
    }
}
}
```
```java
class de.gurkenlabs.litiengine.gui.SpeechBubble {
public static SpeechBubble create(
      final IEntity entity, final String text, SpeechBubbleAppearance appearance, Font font) {
    return new SpeechBubble(entity, text, appearance, font);
}public static SpeechBubble create(final IEntity entity, final Font font, final String text) {
    SpeechBubbleAppearance app =
        new SpeechBubbleAppearance(
            DEFAULT_APPEARANCE.getForeColor(),
            DEFAULT_APPEARANCE.getBackgroundColor1(),
            DEFAULT_APPEARANCE.getBorderColor(),
            DEFAULT_APPEARANCE.getPadding());
    return new SpeechBubble(entity, text, app, font);
}public static SpeechBubble create(final IEntity entity, final String text) {
    return new SpeechBubble(entity, text, null, GuiProperties.getDefaultFont());
}@Override
  public void update() {
    if (this.currentText == null) {
      this.hide();
      return;
    }

    this.entityCenter = Game.world().camera().getViewportLocation(this.getEntity().getCenter());

    // old text was displayed long enough
    if (this.lastTextDisplay != 0
        && Game.time().since(this.lastTextDisplay) > this.currentTextDisplayTime) {
      this.currentText = null;
      this.lastTextDisplay = 0;
      return;
    }

    // display new text
    if (this.textIndex < this.currentText.length()
        && Game.time().since(this.lastCharPoll) > LETTER_WRITE_DELAY) {
      this.textIndex++;
      this.lastCharPoll = Game.time().now();
      if (this.typeSound != null) {
        Game.audio().playSound(this.typeSound, this.getEntity());
      }
    }

    // continue displaying currently displayed text
}private SpeechBubble(
      final IEntity entity,
      final String text,
      final Sound typeSound,
      SpeechBubbleAppearance appearance,
      Font font) {
    this(entity, text, appearance, font);
    this.typeSound = typeSound;
}private SpeechBubble(
      final IEntity entity,
      final String text,
      @Nullable SpeechBubbleAppearance appearance,
      @Nullable Font font) {
    if (appearance == null) {
      this.appearance = DEFAULT_APPEARANCE;
    } else {
      this.appearance = appearance;
    }

    final SpeechBubble active = activeSpeechBubbles.get(entity);
    if (active != null) {
      active.hide();
    }
    this.setFont(font);

    this.textBoxWidth = (float) (entity.getWidth() * 4);
    this.entity = entity;

    this.currentText = text;
    this.currentTextDisplayTime = DISPLAYTIME_MIN + text.length() * DISPLAYTIME_PER_LETTER;

    this.lastTextDisplay = Game.time().now();
    this.createBubbleImage();
    entity.getEnvironment().add(this, RenderType.UI);
    Game.loop().attach(this);
    activeSpeechBubbles.put(entity, this);
}
}
```
```java
class de.gurkenlabs.litiengine.gui.TextFieldComponent {
@Override
  public void render(final Graphics2D g) {
    super.render(g);
    g.setFont(this.getFont());
    final FontMetrics fm = g.getFontMetrics();

    if (this.isSelected() && Game.time().since(this.lastToggled) > this.flickerDelay) {
      this.cursorVisible = !this.cursorVisible;
      this.lastToggled = Game.time().now();
    }
    if (this.isSelected() && this.cursorVisible) {
      final Rectangle2D cursor =
          new Rectangle2D.Double(
              this.getX() + this.getTextX() + fm.stringWidth(this.getTextToRender(g)),
              this.getY() + this.getTextY(),
              this.getFont().getSize2D() * 3 / 5,
              this.getFont().getSize2D() * 1 / 5);
      g.setColor(this.getAppearance().getForeColor());
      g.fill(cursor);
    }
}
}
```
```java
class de.gurkenlabs.litiengine.entities.Prop {
public Prop(
      final Point2D location, @Nullable final String spritesheetName, final Material material) {
    super();
    this.rotation = Rotation.NONE;
    this.spritesheetName = spritesheetName;
    this.material = material;
    this.setLocation(location);
    this.updateAnimationController();
}public void setSpritesheetName(@Nullable final String spriteName) {
    this.spritesheetName = spriteName;
    this.updateAnimationController();
}
}
```
```java
class de.gurkenlabs.litiengine.tweening.Tween {
public Tween begin() {
    this.started = Game.time().now();
    this.stopped = false;
    return this;
}
}
```
```java
class de.gurkenlabs.litiengine.graphics.emitters.particles.Particle {
public void update(final Point2D emitterOrigin, final float updateRatio) {
    if (this.aliveTick == 0) {
      this.aliveTick = Game.time().now();
    }

    this.aliveTime = Game.time().since(this.aliveTick);
    if (this.timeToLiveReached()) {
      return;
    }

    if (this.colliding) {
      return;
    }

    if (this.getDeltaWidth() != 0) {
      this.width += this.getDeltaWidth() * updateRatio;
    }

    if (this.getDeltaHeight() != 0) {
      this.height += this.getDeltaHeight() * updateRatio;
    }

    if (this.getDeltaAngle() != 0) {
      this.angle += this.getDeltaAngle() * updateRatio;
    }

    // test for ray cast collision
    final float targetX = this.x + this.getVelocityX() * updateRatio;
    final float targetY = this.y + this.getVelocityY() * updateRatio;

    if (targetX == this.x && targetY == this.y) {
      return;
    }

    if (this.checkForCollision(emitterOrigin, targetX, targetY)) {
      return;
    }

    if (this.getVelocityX() != 0) {
      this.x = targetX;
    }

    if (this.getVelocityY() != 0) {
      this.y = targetY;
    }

    if (this.getAccelerationX() != 0) {
      this.velocityX += this.getAccelerationX() * updateRatio;
    }

    if (this.getAccelerationY() != 0) {
      this.velocityY += this.getAccelerationY() * updateRatio;
    }
}
}
```
```java
class de.gurkenlabs.litiengine.graphics.animation.Animation {
@Override
  public void start() {
    this.playing = true;
    if (this.getKeyframes().isEmpty()) {
      return;
    }

    this.restart();
}@Override
  public void update() {
    // do nothing if the animation is not playing or the current keyframe is not finished
    if (!this.isPlaying()
        || Game.time().since(this.lastFrameUpdate) < this.getCurrentKeyFrame().getDuration()) {
      return;
    }

    // if we are not looping and the last keyframe is finished, we terminate the animation
    if (!this.isLooping() && this.isLastKeyFrame()) {
      this.terminate();
      return;
    }

    // make sure, we stay inside the keyframe list
    final int newFrameIndex =
        (this.getKeyframes().indexOf(this.currentFrame) + 1) % this.getKeyframes().size();
    final KeyFrame previousFrame = this.currentFrame;
    this.currentFrame = this.getKeyframes().get(newFrameIndex);

    for (KeyFrameListener listener : this.listeners) {
      listener.currentFrameChanged(previousFrame, this.currentFrame);
    }

    this.lastFrameUpdate = Game.loop().getTicks();
}
}
```
```java
class de.gurkenlabs.litiengine.graphics.animation.AnimationController {
@Override
  public void update() {
    for (final Animation animation : this.getAll()) {
      animation.update();
    }

    if (this.getCurrent() != null && this.getCurrent().isPaused()) {
      return;
    }

    final boolean playbackFinished = this.getCurrent() != null && !this.getCurrent().isPlaying();
    if (playbackFinished) {
      for (final AnimationListener listener : this.listeners) {
        listener.finished(this.getCurrent());
      }
    }

    if (this.getCurrent() == null || playbackFinished) {
      if (this.getDefault() != null) {
        this.play(this.getDefault().getName());
      } else {
        this.currentAnimation = null;
      }
    }
}
}
```
```java
class de.gurkenlabs.litiengine.graphics.RenderComponent {
private void handleFade() {
    if (this.fadeOutStart != -1) {
      final long timePassed = Game.time().since(this.fadeOutStart);
      this.currentAlpha = MathUtilities.clamp(1 - timePassed / (float) this.fadeOutTime, 0, 1);
      if (this.currentAlpha == 0f) {
        this.fadeOutStart = -1;
        this.fadeOutTime = -1;
      }

      return;
    }

    if (this.fadeInStart != -1) {
      final long timePassed = Game.time().since(this.fadeInStart);
      this.currentAlpha = MathUtilities.clamp(timePassed / (float) this.fadeInTime, 0, 1);
      if (this.currentAlpha == 1f) {
        this.fadeInStart = -1;
        this.fadeInTime = -1;
        this.currentAlpha = Float.NaN;
      }
    }
}public void fadeOut(final int ms) {
    this.fadeInStart = -1;
    this.fadeInTime = -1;
    this.fadeOutStart = Game.time().now();
    this.fadeOutTime = ms;
}public void fadeIn(final int ms) {
    this.fadeOutStart = -1;
    this.fadeOutTime = -1;
    this.fadeInStart = Game.time().now();
    this.fadeInTime = ms;
}
}
```
```java
class de.gurkenlabs.litiengine.entities.Trigger {
private boolean activate(final IEntity activator, final int tar) {
    if (!this.isLoaded()
        || this.isOneTimeTrigger && this.isActivated
        || this.getActivationType() == TriggerActivation.COLLISION
            && activator != null
            && this.collisionActivated.contains(activator)) {
      return false;
    }

    if (this.getCooldown() > 0 && Game.time().since(this.lastActivation) < this.getCooldown()) {
      return false;
    }

    List<Integer> triggerTargets = this.getTargets(tar);

    final TriggerEvent te = new TriggerEvent(this, activator, triggerTargets);

    if (!this.checkActivationPredicates(te)) {
      return false;
    }

    this.isActivated = true;
    if (activator != null) {
      this.collisionActivated.add(activator);
    }

    // if we actually have a trigger target, we send the message to the target
    for (final int target : triggerTargets) {
      final IEntity entity = this.getEnvironment().get(target);
      if (entity == null) {
        log.log(
            Level.WARNING,
            "trigger [{0}] was activated, but the trigger target [{1}] could not be found on the environment",
            new Object[] {this, target});
        continue;
      }

      entity.sendMessage(this, this.message);
    }

    // also send the trigger event to all registered consumers
    for (final TriggerActivatedListener listener : this.activatedListeners) {
      listener.activated(te);
    }

    if (this.isOneTimeTrigger) {
      this.getEnvironment().remove(this);
    }

    this.lastActivation = Game.time().now();
    return true;
}
}
```
```java
class de.gurkenlabs.litiengine.graphics.Camera {
private boolean isShakeEffectActive() {
    return this.getShakeTick() != 0
        && Game.time().since(this.getShakeTick()) < this.getShakeDuration();
}@Override
  public void update() {
    if (Game.world().camera() != null && !Game.world().camera().equals(this)) {
      return;
    }

    if (this.targetZoom > 0) {
      if (Game.time().since(this.zoomTick) >= this.zoomDelay) {
        this.zoom = this.targetZoom;
        this.targetZoom = 0;
        this.zoomDelay = 0;
        this.zoomTick = 0;
        this.zoomStep = 0;
      } else {
        this.zoom += this.zoomStep;
      }

      final ZoomChangedEvent event = new ZoomChangedEvent(this, this.getZoom());
      for (final ZoomChangedListener listener : this.zoomListeners) {
        listener.zoomChanged(event);
      }
    }

    if (this.panTime > 0) {
      if (--this.panTime <= 0) {
        this.setFocus(this.targetFocus);
        this.targetFocus = null;
      } else {
        double diff = this.panTime / (this.panTime + 1.0);
        this.focus =
            new Point2D.Double(
                this.focus.getX() * diff + this.targetFocus.getX() * (1.0 - diff),
                this.focus.getY() * diff + this.targetFocus.getY() * (1.0 - diff));
      }
    }

    if (!this.isShakeEffectActive()) {
      this.shakeOffsetX = 0;
      this.shakeOffsetY = 0;
      return;
    }

    if (Game.time().since(this.lastShake) > this.shakeDelay) {
      this.shakeOffsetX = this.getShakeIntensity() * ThreadLocalRandom.current().nextGaussian();
      this.shakeOffsetY = this.getShakeIntensity() * ThreadLocalRandom.current().nextGaussian();
      this.lastShake = Game.time().now();
    }
}@Override
  public void setZoom(final float targetZoom, final int delay) {
    if (delay == 0) {

      this.zoom = targetZoom;
      this.targetZoom = 0;
      this.zoomDelay = 0;
      this.zoomTick = 0;
      this.zoomStep = 0;

      final ZoomChangedEvent event = new ZoomChangedEvent(this, targetZoom);
      for (final ZoomChangedListener listener : this.zoomListeners) {
        listener.zoomChanged(event);
      }
    } else {
      this.zoomTick = Game.time().now();
      this.targetZoom = targetZoom;
      this.zoomDelay = delay;

      final double tickduration = 1000 / (double) Game.loop().getTickRate();
      final double tickAmount = delay / tickduration;
      final float totalDelta = this.targetZoom - this.zoom;
      this.zoomStep = tickAmount > 0 ? (float) (totalDelta / tickAmount) : totalDelta;
    }
}@Override
  public void shake(final double intensity, final int delay, final int shakeDuration) {
    this.shakeTick = Game.time().now();
    this.shakeDelay = delay;
    this.shakeIntensity = intensity;
    this.shakeDuration = shakeDuration;
}
}
```
```java
class de.gurkenlabs.litiengine.entities.Creature {
public void setSpritesheetName(String spritesheetName) {
    if (this.spritesheetName != null && this.spritesheetName.equals(spritesheetName)) {
      return;
    }

    this.spritesheetName = spritesheetName;
    this.updateAnimationController();
}public boolean isIdle() {
    return Game.time().since(this.lastMoved) > IDLE_DELAY;
}@Override
  public void setLocation(final Point2D position) {
    if (this.isDead() || position == null) {
      return;
    }

    final Point2D oldLocation = this.getLocation();
    super.setLocation(position);

    if (Game.hasStarted() && this.isLoaded()) {
      this.lastMoved = Game.time().now();
      this.fireMovedEvent(
          new EntityMovedEvent(
              this, this.getX() - oldLocation.getX(), this.getY() - oldLocation.getY()));
    }
}
}
```
```java
class de.gurkenlabs.litiengine.gui.screens.ScreenManager {
public void display(final String screenName) {
    if (this.current() != null && this.current().getName().equalsIgnoreCase(screenName)) {
      log.log(
          Level.INFO,
          "Skipping displaying of screen {0} because it is already the current screen.",
          screenName);
      return;
    }

    if (this.screens.stream()
        .noneMatch(element -> element.getName().equalsIgnoreCase(screenName))) {
      log.log(
          Level.WARNING,
          "Could not display the screen {0} because there is no screen with the specified name.",
          screenName);
      return;
    }

    Screen screen = this.get(screenName);
    if (screen == null) {
      return;
    }

    this.display(screen);
}public void add(final Screen screen) {
    screen.setWidth(Game.window().getWidth());
    screen.setHeight(Game.window().getHeight());
    this.screens.add(screen);

    if (this.current() == null) {
      this.display(screen);
    }
}public void remove(Screen screen) {
    this.screens.remove(screen);
    if (this.current() == screen) {
      if (!this.screens.isEmpty()) {
        this.display(this.screens.get(0));
      } else {
        this.display((Screen) null);
      }
    }
}public void display(@Nullable final Screen screen) {
    if (Game.hasStarted() && Game.time().since(this.lastScreenChange) < this.getChangeCooldown()) {
      log.log(
          Level.INFO,
          "Skipping displaying of screen {0} because screen changing is currently on cooldown.",
          screen != null ? screen.getName() : "");
      return;
    }

    final Screen previous = this.current();
    if (previous != null) {
      previous.suspend();
    }

    if (screen != null && !this.screens.contains(screen)) {
      this.screens.add(screen);
    }

    this.currentScreen = screen;
    if (!Game.isInNoGUIMode() && this.current() != null) {
      this.current().prepare();
    }

    this.lastScreenChange = Game.loop().getTicks();

    final ScreenChangedEvent event = new ScreenChangedEvent(this.current(), previous);
    for (final ScreenChangedListener listener : this.screenChangedListeners) {
      listener.changed(event);
    }
}
}
```
```java
class de.gurkenlabs.litiengine.abilities.Ability {
public boolean isOnCooldown() {
    return (this.getCurrentExecution() != null
        && this.getCurrentExecution().getExecutionTicks() > 0
        && Game.time().since(this.getCurrentExecution().getExecutionTicks())
            < this.getAttributes().cooldown().get());
}public boolean isActive() {
    return this.getCurrentExecution() != null
        && Game.time().since(this.getCurrentExecution().getExecutionTicks())
            < this.getAttributes().duration().get();
}@Nullable
  public AbilityExecution cast() {
    if (!this.canCast()) {
      return null;
    }
    this.currentExecution = new AbilityExecution(this);

    for (final AbilityCastListener listener : this.abilityCastListeners) {
      listener.abilityCast(this.currentExecution);
    }

    return this.getCurrentExecution();
}public float getRemainingCooldownInSeconds() {
    if (this.getCurrentExecution() == null
        || this.getExecutor() == null
        || this.getExecutor().isDead()) {
      return 0;
    }

    // calculate cooldown in seconds
    return (float)
        (!this.canCast()
            ? (this.getAttributes().cooldown().get()
                    - Game.time().since(this.getCurrentExecution().getExecutionTicks()))
                * 0.001
            : 0);
}
}
```
```java
class de.gurkenlabs.litiengine.entities.EntityHitEvent {
EntityHitEvent(
      final ICombatEntity hitEntity,
      @Nullable final Ability ability,
      final int damage,
      final boolean kill) {
    super(hitEntity);
    this.executor = ability != null ? ability.getExecutor() : null;
    this.hitEntity = hitEntity;
    this.ability = ability;
    this.damage = damage;
    this.kill = kill;
    this.time = Game.time().now();
}
}
```
```java
class de.gurkenlabs.litiengine.graphics.emitters.Emitter {
public void delete() {
    this.deactivate();
    if (Game.world().environment() != null) {
      Game.world().environment().remove(this);
    }
}public void activate() {
    if (this.activated) {
      return;
    }

    this.activated = true;
    this.activationTick = Game.time().now();
    Game.loop().attach(this);
}@Override
  public void update() {
    if (this.isPaused()) {
      return;
    }

    // clear particles if the effect time to life is reached
    if (this.isFinished()) {
      for (EmitterFinishedListener listener : this.finishedListeners) {
        listener.finished(this);
      }

      this.delete();
      return;
    }

    final float updateRatio = (float) this.data().getUpdateRate() / Game.loop().getTickRate();
    for (final Particle p : this.getParticles().stream().collect(Collectors.toList())) {
      if (this.particleCanBeRemoved(p)) {
        // remove dead particles
        this.particles.remove(p);
        continue;
      }

      p.update(this.getOrigin(), updateRatio);
    }

    this.aliveTime = Game.time().since(this.activationTick);
    if ((this.data().getSpawnRate() == 0
        || Game.time().since(this.lastSpawn) >= this.data().getSpawnRate())) {
      this.lastSpawn = Game.time().now();
      this.spawnParticle();
    }
}
}
```
```java
class de.gurkenlabs.litiengine.GameLoop {
@Override
  public int perform(int delay, Runnable action) {
    final long d = Game.time().toTicks(delay);

    TimedAction a = new TimedAction(this.getTicks() + d, action);
    this.actions.add(a);

    return a.getId();
}
}
```
```java
class de.gurkenlabs.litiengine.environment.EntitySpawner {
protected boolean shouldSpawn() {
    return this.lastSpawnWave == 0
        || Game.time().since(this.lastSpawnWave) >= this.getSpawnInterval();
}@Override
  public void update() {
    if (!this.shouldSpawn()) {
      return;
    }

    this.spawnNewEntities();
    this.lastSpawnWave = Game.time().now();
}
}
```
```java
class de.gurkenlabs.litiengine.graphics.FreeFlightCamera {
@Override
  public void update() {
    this.handleFreeFlightCamera();
}public FreeFlightCamera(double x, double y) {
    this(new Point2D.Double(x, y));
}
}
```
```java
class de.gurkenlabs.litiengine.environment.Environment {
public void unload() {
    if (!this.loaded) {
      return;
    }

    // unregister all updatable entities from the current environment
    for (final IEntity entity : this.allEntities.values()) {
      this.unload(entity);
    }

    this.loaded = false;
    this.fireEvent(l -> l.unloaded(this));
}private static void loadUpdatableOrEmitterEntity(IEntity entity) {
    if (entity instanceof Emitter) {
      final Emitter emitter = (Emitter) entity;
      if (emitter.isActivateOnInit()) {
        emitter.activate();
      }
    } else if (entity instanceof IUpdateable) {
      Game.loop().attach((IUpdateable) entity);
    }
}public void clear() {
    Game.physics().clear();

    this.combatEntities.clear();
    this.mobileEntities.clear();
    this.gravityForces.clear();
    this.layerEntities.clear();
    this.entitiesByTag.clear();
    this.allEntities.clear();

    for (RenderType renderType : RenderType.values()) {
      this.miscEntities.get(renderType).clear();
      this.renderListeners.get(renderType).clear();
      this.renderables.get(renderType).clear();
    }

    dispose(this.allEntities.values());
    dispose(this.triggers);
    this.emitters.clear();
    this.colliders.clear();
    this.props.clear();
    this.creatures.clear();
    this.staticShadows.clear();
    this.combatEntities.clear();
    this.mobileEntities.clear();
    this.lightSources.clear();
    this.spawnPoints.clear();
    this.soundSources.clear();
    this.mapAreas.clear();
    this.triggers.clear();

    this.ambientLight = null;
    this.staticShadowLayer = null;

    for (Map<Integer, IEntity> type : this.miscEntities.values()) {
      type.clear();
    }

    this.initialized = false;

    this.fireEvent(l -> l.cleared(this));
}private void load(final IEntity entity) {
    // an entity can only exist on one environment at a time, so remove it from the current one
    if (entity.getEnvironment() != null) {
      entity.getEnvironment().remove(entity);
    }

    // 1. add to physics engine
    loadPhysicsEntity(entity);

    // 2. register for update or activate
    loadUpdatableOrEmitterEntity(entity);

    // 3. if a gravity is defined, add a gravity force to the entity
    if (entity instanceof IMobileEntity && this.getGravity() != 0) {
      this.addGravityForce((IMobileEntity) entity);
    }

    // 4. attach all controllers
    entity.attachControllers();

    if (this.loaded && (entity instanceof LightSource || entity instanceof StaticShadow)) {
      this.updateLighting(entity);
    }

    entity.loaded(this);
}private void unload(final IEntity entity) {
    // 1. remove from physics engine
    if (entity instanceof ICollisionEntity) {
      Game.physics().remove((ICollisionEntity) entity);
    }

    // 2. unregister from update
    if (entity instanceof IUpdateable) {
      Game.loop().detach((IUpdateable) entity);
    }

    if (entity instanceof IMobileEntity) {
      this.removeGravity((IMobileEntity) entity);
    }

    // 3. detach all controllers
    entity.detachControllers();

    if (entity instanceof Emitter) {
      Emitter em = (Emitter) entity;
      em.deactivate();
    }

    if (this.loaded && (entity instanceof LightSource || entity instanceof StaticShadow)) {
      this.updateLighting(entity);
    }

    entity.removed(this);
}public void remove(final IEntity entity) {
    if (entity == null) {
      return;
    }

    this.allEntities.remove(entity.getMapId());
    Iterator<List<IEntity>> iter = this.layerEntities.values().iterator();
    while (iter.hasNext()) {
      List<IEntity> layer = iter.next();
      if (layer.remove(entity) && layer.isEmpty()) {
        iter.remove();
      }
    }
    if (this.miscEntities.get(entity.getRenderType()) != null) {
      this.miscEntities.get(entity.getRenderType()).values().remove(entity);
    }

    for (String tag : entity.getTags()) {
      if (this.getEntitiesByTag().containsKey(tag)) {
        this.getEntitiesByTag().get(tag).remove(entity);

        if (this.getEntitiesByTag().get(tag).isEmpty()) {
          this.getEntitiesByTag().remove(tag);
        }
      }
    }

    if (entity instanceof Emitter) {
      Emitter emitter = (Emitter) entity;
      this.removeEmitter(emitter);
    }

    if (entity instanceof MapArea) {
      this.mapAreas.remove(entity);
    }

    if (entity instanceof Prop) {
      this.props.remove(entity);
    }

    if (entity instanceof Creature) {
      this.creatures.remove(entity);
    }

    if (entity instanceof CollisionBox) {
      this.colliders.remove(entity);
      this.staticShadows.removeIf(x -> x.getOrigin() != null && x.getOrigin().equals(entity));
    }

    if (entity instanceof LightSource) {
      this.lightSources.remove(entity);
      this.updateLighting(entity);
    }

    if (entity instanceof Trigger) {
      this.triggers.remove(entity);
    }

    if (entity instanceof Spawnpoint) {
      this.spawnPoints.remove(entity);
    }
    if (entity instanceof SoundSource) {
      this.soundSources.remove(entity);
    }

    if (entity instanceof StaticShadow) {
      this.staticShadows.remove(entity);
      this.updateLighting(entity);
    }

    if (entity instanceof IMobileEntity) {
      this.mobileEntities.values().remove(entity);
    }

    if (entity instanceof ICombatEntity) {
      this.combatEntities.values().remove(entity);
    }

    this.unload(entity);

    this.fireEntityEvent(l -> l.entityRemoved(entity));
}
}
```
```java
class de.gurkenlabs.litiengine.physics.MovementController {
@Override
  public void update() {
    this.handleForces();
    this.handleMovement();
}
}
```
```java
class de.gurkenlabs.litiengine.Game {
static synchronized void terminate() {
    if (!initialized) {
      return;
    }

    hasStarted = false;
    initialized = false;

    config().save();
    gameLoop.terminate();
    tweenEngine.terminate();
    soundEngine.terminate();

    world().clear();

    for (final GameListener listener : gameListeners) {
      try {
        listener.terminated();
      } catch (Exception e) {
        log().log(Level.WARNING, "game listener threw an exception during shutdown", e);
      }
    }

    gameLoop = null;
    screenManager = null;
    gameWindow = null;
}public static synchronized void start() {
    if (!initialized) {
      throw new IllegalStateException(
          "The game cannot be started without being first initialized. Call Game.init(...) before Game.start().");
    }

    gameLoop.start();
    tweenEngine.start();
    soundEngine.start();

    for (final GameListener listener : gameListeners) {
      listener.started();
    }

    hasStarted = true;
}public static synchronized void init(String... args) {
    if (initialized) {
      log().log(Level.INFO, "The game has already been initialized.");
      return;
    }

    log.init();
    handleCommandLineArguments(args);

    config().load();
    Locale.setDefault(new Locale(config().client().getCountry(), config().client().getLanguage()));

    gameLoop = new GameLoop("Main Update Loop", config().client().getMaxFps());
    loop().attach(physics());
    loop().attach(world());

    // setup default exception handling for render and update loop
    setUncaughtExceptionHandler(
        new DefaultUncaughtExceptionHandler(config().client().exitOnError()));

    screenManager = new ScreenManager();
    gameWindow = new GameWindow();

    // initialize  the game window
    window().init();
    world.setCamera(new Camera());

    for (GameListener listener : gameListeners) {
      listener.initialized(args);
    }

    if (!isInNoGUIMode()) {
      window().getRenderComponent().onRendered(g -> metrics().render(g));

      graphics()
          .addEntityRenderedListener(
              e -> DebugRenderer.renderEntityDebugInfo(e.getGraphics(), e.getEntity()));

      window().getRenderComponent().onFpsChanged(fps -> metrics().setFramesPerSecond(fps));
      window()
          .setIcons(
              Arrays.asList(
                  Resources.images().get("liti-logo-x16.png"),
                  Resources.images().get("liti-logo-x20.png"),
                  Resources.images().get("liti-logo-x32.png"),
                  Resources.images().get("liti-logo-x48.png")));

      Input.keyboard()
          .onKeyTyped(
              KeyEvent.VK_PRINTSCREEN,
              key -> {
                // don't take a screenshot if a modifier is active
                if (key.getModifiers() != 0) {
                  return;
                }

                window().getRenderComponent().takeScreenshot();
              });
    }

    Runtime.getRuntime().addShutdownHook(new Thread(Game::terminate, "Shutdown"));

    initialized = true;
}
}
```


Response Format:
Provide the answer in **XML format** as follows:

#### If the method **cannot** return `null` at the specific call site:
```xml
<response>
  <reason><![CDATA[EXPLAIN WHY THE INVOCATION Game.loop() RESULT CANNOT BE NULL.]]></reason>
  <value>NO</value>
</response>

#### If the method can return null at the specific call site:
<response>
  <reason><![CDATA[EXPLAIN WHY THE INVOCATION Game.loop() RESULT CAN BE NULL.]]></reason>
  <value>YES</value>
</response>

#### If you are unsure or If there are any methods that directly or indirectly affect the return value and are not fully disclosed, request their declarations first, in the following format:
<response>
  <reason><![CDATA[EXPLAIN WHY THIS METHOD DECLARATION IS NECESSARY AND WHY YOU CANNOT MAKE A CONFIDENT DECISION WITHOUT IT]]></reason>
  <success>false</success>
  <methods>
    <method>methodName</method>
  </methods>
</response>

Additional Notes:
Be precise in your reasoning.
If a method’s return value depends on another method not provided, request its declaration before making a conclusion.
If the method can return null in this case but not in others, explain why it happens specifically for this call.

---ChatGPT.sendRequestToOpenAI---
Retrieving response from cache
---Response.<init>---
Creating Response:
```xml
<response>
  <reason><![CDATA[The method `Game.loop()` returns the static field `gameLoop`, which is initialized in the `Game.init(String... args)` method. In this method, a new `GameLoop` object is instantiated and assigned to `gameLoop`. Since `init()` must be called before `start()`, which is implied by the requirement of initializing the game, the `gameLoop` is guaranteed to be non-null during the lifetime of the game execution where `Game.loop()` is called. The absence of any code that could set `gameLoop` to null after its initialization ensures that `Game.loop()` cannot return null.]]></reason>
  <value>NO</value>
</response>
```
---Response.<init>---
Response created:
Disagreement: The method `Game.loop()` returns the static field `gameLoop`, which is initialized in the `Game.init(String... args)` method. In this method, a new `GameLoop` object is instantiated and assigned to `gameLoop`. Since `init()` must be called before `start()`, which is implied by the requirement of initializing the game, the `gameLoop` is guaranteed to be non-null during the lifetime of the game execution where `Game.loop()` is called. The absence of any code that could set `gameLoop` to null after its initialization ensures that `Game.loop()` cannot return null.
---AdvancedNullAwayCodeFix.resolveMethodDereferenceError---
Method is not returning nullable on call site. Injecting suppression annotation.
---AdvancedNullAwayCodeFix.constructCastToNonnullChange---
Constructing cast to nonnull change for reason: The method `Game.loop()` returns the static field `gameLoop`, which is initialized in the `Game.init(String... args)` method. In this method, a new `GameLoop` object is instantiated and assigned to `gameLoop`. Since `init()` must be called before `start()`, which is implied by the requirement of initializing the game, the `gameLoop` is guaranteed to be non-null during the lifetime of the game execution where `Game.loop()` is called. The absence of any code that could set `gameLoop` to null after its initialization ensures that `Game.loop()` cannot return null.
---ChatGPT.ask---
Asking ChatGPT:
For the reason you mentioned earlier:

"The method `Game.loop()` returns the static field `gameLoop`, which is initialized in the `Game.init(String... args)` method. In this method, a new `GameLoop` object is instantiated and assigned to `gameLoop`. Since `init()` must be called before `start()`, which is implied by the requirement of initializing the game, the `gameLoop` is guaranteed to be non-null during the lifetime of the game execution where `Game.loop()` is called. The absence of any code that could set `gameLoop` to null after its initialization ensures that `Game.loop()` cannot return null."

in the method below, the expression Game.loop() is not nullable at the point it is used.

```java
private SpeechBubble(
      final IEntity entity,
      final String text,
      @Nullable SpeechBubbleAppearance appearance,
      @Nullable Font font) {
    if (appearance == null) {
      this.appearance = DEFAULT_APPEARANCE;
    } else {
      this.appearance = appearance;
    }

    final SpeechBubble active = activeSpeechBubbles.get(entity);
    if (active != null) {
      active.hide();
    }
    this.setFont(font);

    this.textBoxWidth = (float) (entity.getWidth() * 4);
    this.entity = entity;

    this.currentText = text;
    this.currentTextDisplayTime = DISPLAYTIME_MIN + text.length() * DISPLAYTIME_PER_LETTER;

    this.lastTextDisplay = Game.time().now();
    this.createBubbleImage();
    entity.getEnvironment().add(this, RenderType.UI);
    Game.loop().attach(this);
    activeSpeechBubbles.put(entity, this);
}
```
Please Summarize the reason in max 5 words and rewrite the method so that at the line "    Game.loop().attach(this);", at the occurrence of: "Game.loop()" is replaced with `NullabilityUtil.castToNonnull(Game.loop(), summary of reason)`
Replace "REASON" with the exact reason summary I provide to you (maximum 5 words), not with a generic explanation like "checked to be nonnull".
see the example below, for expression `foo.getBar()`, to wrap it with `NullabilityUtil.castToNonnull(foo.getBar(), "reason")`.

```java
public t(){
    String l = foo.getBar();
}
```

will be:
```java
public t(){
    String l = NullabilityUtil.castToNonnull(foo.getBar(), "checked to be nonnull");
}
```

### Instructions:

Do not import any additional classes.

Do not add Java comments.

Only modify relevant lines as required.

Return only the modified method wrapped in the XML format shown below.

Place the Java code inside the <code> tag using a CDATA block with ```java formatting.

Just give me the fixed code snippet in XML format in <response> tag like the example below. I will apply the fix to my codebase. Do not import any additional libraries or classes or add java comments. If you can provide the fixed code snippet, please provide it in the following format and place the code snippet in the <code> tag within ```java block.
<response>
  <success>true</success>
  <code><![CDATA[
  ```java
  Your fixed code snippet here
  ```
    ]]>
  </code>
</response>

---ChatGPT.sendRequestToOpenAI---
Sending request to OpenAI...
---ChatGPT.sendRequestToOpenAI---
Response received from OpenAI.
---Response.<init>---
Creating Response:
```xml
<response>
  <success>true</success>
  <code><![CDATA[
  ```java
private SpeechBubble(
      final IEntity entity,
      final String text,
       SpeechBubbleAppearance appearance,
       Font font) {
    if (appearance == null) {
      this.appearance = DEFAULT_APPEARANCE;
    } else {
      this.appearance = appearance;
    }

    final SpeechBubble active = activeSpeechBubbles.get(entity);
    if (active != null) {
      active.hide();
    }
    this.setFont(font);

    this.textBoxWidth = (float) (entity.getWidth() * 4);
    this.entity = entity;

    this.currentText = text;
    this.currentTextDisplayTime = DISPLAYTIME_MIN + text.length() * DISPLAYTIME_PER_LETTER;

    this.lastTextDisplay = Game.time().now();
    this.createBubbleImage();
    entity.getEnvironment().add(this, RenderType.UI);
    NullabilityUtil.castToNonnull(Game.loop(), "must call init first").attach(this);
    activeSpeechBubbles.put(entity, this);
}
  ```
  ]]>
  </code>
</response>
```
---Response.<init>---
Response created:
private SpeechBubble(
      final IEntity entity,
      final String text,
       SpeechBubbleAppearance appearance,
       Font font) {
    if (appearance == null) {
      this.appearance = DEFAULT_APPEARANCE;
    } else {
      this.appearance = appearance;
    }

    final SpeechBubble active = activeSpeechBubbles.get(entity);
    if (active != null) {
      active.hide();
    }
    this.setFont(font);

    this.textBoxWidth = (float) (entity.getWidth() * 4);
    this.entity = entity;

    this.currentText = text;
    this.currentTextDisplayTime = DISPLAYTIME_MIN + text.length() * DISPLAYTIME_PER_LETTER;

    this.lastTextDisplay = Game.time().now();
    this.createBubbleImage();
    entity.getEnvironment().add(this, RenderType.UI);
    NullabilityUtil.castToNonnull(Game.loop(), "must call init first").attach(this);
    activeSpeechBubbles.put(entity, this);
}
---ChatGPT.fixDereferenceByAddingCastToNonnull---
Fixing the error by adding castToNonnull
---AdvancedNullAwayCodeFix.fixTriggeredErrorsForLocation---
Resolving unresolvable error for triggered error: Type='DEREFERENCE_NULLABLE', message='dereferenced expression Game.loop() is @Nullable'
/home/nima/Developer/nullness-benchmarks/litiengine/src/de/gurkenlabs/litiengine/graphics/animation/AnimationController.java:142
    Game.loop().attach(this);
---AdvancedNullAwayCodeFix.fix---
Fixing error: Type='DEREFERENCE_NULLABLE', message='dereferenced expression Game.loop() is @Nullable'
/home/nima/Developer/nullness-benchmarks/litiengine/src/de/gurkenlabs/litiengine/graphics/animation/AnimationController.java:142
    Game.loop().attach(this);
---AdvancedNullAwayCodeFix.resolveDereferenceError---
Resolving dereference error: Type='DEREFERENCE_NULLABLE', message='dereferenced expression Game.loop() is @Nullable'
/home/nima/Developer/nullness-benchmarks/litiengine/src/de/gurkenlabs/litiengine/graphics/animation/AnimationController.java:142
    Game.loop().attach(this);
---AdvancedNullAwayCodeFix.resolveDereferenceError---
Checking nullability possibility at error point
---ChatGPT.checkNullabilityPossibilityAtErrorPoint---
Asking if the expression can be null at error point point
---ChatGPT.ask---
Asking ChatGPT:
In the method below, is there a possibility that the expression "Game.loop()" at line "Game.loop().attach(this);" is null?
public void attach() {
    Game.loop().attach(this);
}
Give a single-word answer in XML format. If it is possible for the expression to be null, respond with:
```xml
<response>
    <reason><![CDATA[YOUR REASON]]></reason>
    <value>YES</value>
</response>
```
If it is not possible for the expression to be null, respond with:
```xml
<response>
    <reason><![CDATA[YOUR REASON]]></reason>
    <value>NO</value>
</response>
```
If you are unsure or need more information, respond with where you can ask for more details or what specific information you need.

If additional information is required, list each request inside a `<request>` tag. If no additional information is needed, omit the `<requests>` section.

Respond with:
```xml
<response>
    <reason><![CDATA[YOUR REASON]]></reason>
    <value>UNKNOWN</value>
    <!-- Include <requests> only if additional information is needed -->
    <requests>
        <request><![CDATA[YOUR REQUEST 1]]></request>
        <request><![CDATA[YOUR REQUEST 2]]></request>
    </requests>
</response>
```
---ChatGPT.sendRequestToOpenAI---
Sending request to OpenAI...
---ChatGPT.sendRequestToOpenAI---
Response received from OpenAI.
---Response.<init>---
Creating Response:
```xml
<response>
    <reason><![CDATA[Whether Game.loop() can be null depends on the implementation of the Game class, which is not provided. Without more information, it is impossible to determine if the expression will be null.]]></reason>
    <value>UNKNOWN</value>
    <requests>
        <request><![CDATA[Please provide the implementation details of the Game class, specifically the loop method.]]></request>
        <request><![CDATA[Does Game.loop() ever intentionally return null in some situations?]]></request>
    </requests>
</response>
```
---Response.<init>---
Response created:
Unknown: Whether Game.loop() can be null depends on the implementation of the Game class, which is not provided. Without more information, it is impossible to determine if the expression will be null.
---AdvancedNullAwayCodeFix.resolveMethodDereferenceError---
Resolving method dereference error.
---AdvancedNullAwayCodeFix.resolveMethodDereferenceError---
Method is in annotated package. Checking if the method is returning nullable.
---AdvancedNullAwayCodeFix.investigateMethodReturnNullability---
Checking if the method is returning nullable.
---ChatGPT.checkIfMethodIsReturningNullable---
Asking if the method is returning nullable: loop()
---ChatGPT.ask---
Asking ChatGPT:
In the method below, is there a possibility that the method returns null based only on its body? Consider the following points:

- The method may have multiple return paths; consider all return statements.
- If the method calls another method, do not assume its return value unless its full declaration is provided. Request its declaration if needed.
- The method may throw an exception instead of returning null. An exception path should not be considered a null return.
- Ensure you request the declarations of any methods whose return values directly or indirectly impact this method’s return value before making a conclusion.
- Carefully analyze all conditions and prior operations that may guarantee a non-null return value.

@Nullable public static IGameLoop loop() {
    return gameLoop;
}

Here are the method definitions in addition to the method inquired:

Depth: 0
```java
class de.gurkenlabs.litiengine.Game {
@Nullable public static IGameLoop loop() {
    return gameLoop;
}
}
```


Response Format:
Provide the answer in **XML format** as follows:

#### If the method **cannot** return `null`:
```xml
<response>
  <reason><![CDATA[EXPLAIN WHY THE METHOD CANNOT RETURN NULL]]></reason>
  <value>NO</value>
</response>
```

#### If the method can return null:
```xml
<response>
  <reason><![CDATA[EXPLAIN WHY THE METHOD CAN RETURN NULL]]></reason>
  <value>YES</value>
</response>
```

#### If you are unsure or need more information, respond with where you can ask for more details or what specific information you need.

#### If you are unsure or If there are any methods that directly or indirectly affect the return value and are not fully disclosed, request their declarations first, in the following format:
<response>
  <reason><![CDATA[YOUR REASON]]></reason>
  <value>UNKNOWN</value>
  <methods>
    <method>methodName</method>
  </methods>
</response>

If additional information is required other than method declaration, list each request inside a `<request>` tag. If no additional information is needed, omit the `<requests>` section.

Respond with:
```xml
<response>
    <reason><![CDATA[YOUR REASON]]></reason>
    <value>UNKNOWN</value>
    <!-- Include <requests> only if additional information is needed -->
    <requests>
        <request><![CDATA[YOUR REQUEST 1]]></request>
        <request><![CDATA[YOUR REQUEST 2]]></request>
    </requests>
</response>
```

Additional Notes:
Be precise in your reasoning.
If a method’s return value depends on another method not provided, request its declaration before making a conclusion.
If the method can return null in some cases but not others, explain under what conditions it can happen.

---ChatGPT.sendRequestToOpenAI---
Retrieving response from cache
---Response.<init>---
Creating Response:
```xml
<response>
  <reason><![CDATA[The method `loop` returns the variable `gameLoop`. Without the initialization or assignment details of `gameLoop`, it's unclear whether it can be null. The possibility of `gameLoop` being uninitialized or set to null elsewhere in the program means `loop` could potentially return null. Further information on `gameLoop` is required.]]></reason>
  <value>UNKNOWN</value>
  <requests>
    <request><![CDATA[Please provide the declaration and initialization of the variable `gameLoop` in the class `de.gurkenlabs.litiengine.Game`.]]></request>
  </requests>
</response>
```
---Response.<init>---
Response created:
Unknown: The method `loop` returns the variable `gameLoop`. Without the initialization or assignment details of `gameLoop`, it's unclear whether it can be null. The possibility of `gameLoop` being uninitialized or set to null elsewhere in the program means `loop` could potentially return null. Further information on `gameLoop` is required.
---AdvancedNullAwayCodeFix.investigateMethodReturnNullability---
Could not determine the nullability and model did not ask for any method.
---ChatGPT.checkIfMethodIsReturningNullableOnCallSite---
Asking if the method is returning nullable on the call site: Game.loop()
---ChatGPT.ask---
Asking ChatGPT:
In the method below, is there a possibility that the method returns null at the given call site?

```java
@Nullable public static IGameLoop loop() {
    return gameLoop;
}
```

## Guidelines:
- The method may have multiple return paths; consider all return statements.
- If the method calls another method, do not assume its return value unless its full declaration is provided. Request its declaration if needed.
- The method may throw an exception instead of returning null. An exception path should not be considered a null return.
- Ensure you request the declarations of any methods whose return values directly or indirectly impact this method’s return value before making a conclusion.
- If the method returns a value that is determined by a parameter, evaluate based on the actual argument at the given call site.
- Analyze based only on the specific invocation provided. Do not generalize to all possible inputs.- If the return value is guaranteed to be non-null at the call site, the answer should be a definitive NO.
- Do not generalize based on all possible inputs—your answer must be based only on the given invocation.
- Focus only on the given call site, not all possible invocations.

### call site:
Game.loop()

Here are the method definitions and the call chain for this method, showing the sequence of calls from the method to its callers at each depth level:

Depth: 0
```java
class de.gurkenlabs.litiengine.Game {
@Nullable public static IGameLoop loop() {
    return gameLoop;
}
}
```
Depth: 1
```java
class de.gurkenlabs.litiengine.environment.GameWorld {
public void loadEnvironment(@Nullable final Environment env) {
    Lock lock = Game.loop().getLock();
    lock.lock();
    try {
      unloadEnvironment();
      this.environment = env;
      if (env != null) {
        this.addEnvironment(env);

        if (env.getGravity() == 0 && this.gravity() != 0) {
          env.setGravity(this.gravity());
        }

        env.load();
        for (final EnvironmentLoadedListener listener : this.loadedListeners) {
          listener.loaded(env);
        }

        // call map specific listeners
        String mapName = getMapName(env);
        if (mapName != null && this.environmentLoadedListeners.containsKey(mapName)) {

          // for the default camera we center the camera on the environment
          if (this.camera().getClass().equals(Camera.class)) {
            camera().setFocus(env.getCenter());
          }

          for (EnvironmentLoadedListener listener : this.environmentLoadedListeners.get(mapName)) {
            listener.loaded(env);
          }
        }
      }
    } finally {
      lock.unlock();
    }
}public void setCamera(@Nullable final ICamera cam) {
    if (this.camera() != null) {
      Game.loop().detach(camera);
    }

    camera = cam;

    if (cam != null && !Game.isInNoGUIMode()) {
      Game.loop().attach(cam);
      cam.updateFocus();
    }
}
}
```
```java
class de.gurkenlabs.litiengine.entities.behavior.EntityNavigator {
public EntityNavigator(final IMobileEntity entity, final PathFinder pathFinder) {
    this.cancelNavigationConditions = new CopyOnWriteArrayList<>();
    this.listeners = new CopyOnWriteArrayList<>();
    this.entity = entity;
    this.pathFinder = pathFinder;
    this.setAcceptableError(DEFAULT_ACCEPTABLE_ERROR);
    Game.loop().attach(this);
}
}
```
```java
class de.gurkenlabs.litiengine.GameWindow {
private static void initializeWindowEventListeners(Window window) {

    window.addWindowStateListener(
        e -> {
          if (e.getNewState() == Frame.ICONIFIED) {
            Game.loop().setTickRate(ICONIFIED_MAX_FPS);
          } else {
            Game.loop().setTickRate(Game.config().client().getMaxFps());
          }
        });

    window.addWindowFocusListener(
        new WindowFocusListener() {
          @Override
          public void windowLostFocus(WindowEvent e) {
            if (Game.config().graphics().reduceFramesWhenNotFocused()) {
              Game.loop().setTickRate(NONE_FOCUS_MAX_FPS);
            }
          }

          @Override
          public void windowGainedFocus(WindowEvent e) {
            Game.loop().setTickRate(Game.config().client().getMaxFps());
          }
        });

    window.addWindowListener(
        new WindowAdapter() {
          @Override
          public void windowClosing(final WindowEvent event) {
            Game.exit();
          }
        });
}
}
```
```java
class de.gurkenlabs.litiengine.gui.screens.ScreenManager {
public void display(@Nullable final Screen screen) {
    if (Game.hasStarted() && Game.time().since(this.lastScreenChange) < this.getChangeCooldown()) {
      log.log(
          Level.INFO,
          "Skipping displaying of screen {0} because screen changing is currently on cooldown.",
          screen != null ? screen.getName() : "");
      return;
    }

    final Screen previous = this.current();
    if (previous != null) {
      previous.suspend();
    }

    if (screen != null && !this.screens.contains(screen)) {
      this.screens.add(screen);
    }

    this.currentScreen = screen;
    if (!Game.isInNoGUIMode() && this.current() != null) {
      this.current().prepare();
    }

    this.lastScreenChange = Game.loop().getTicks();

    final ScreenChangedEvent event = new ScreenChangedEvent(this.current(), previous);
    for (final ScreenChangedListener listener : this.screenChangedListeners) {
      listener.changed(event);
    }
}
}
```
```java
class de.gurkenlabs.litiengine.abilities.effects.Effect {
@Override
  public void update() {

    for (final Iterator<EffectApplication> iterator = this.getActiveAppliances().iterator();
        iterator.hasNext(); ) {
      final EffectApplication appliance = iterator.next();
      // if the effect duration is reached
      if (this.hasEnded(appliance)) {

        iterator.remove();
        this.cease(appliance);
      }
    }

    // 4. unregister if all appliances are finished
    if (this.getActiveAppliances().isEmpty()) {
      Game.loop().detach(this);
    }
}public void apply(final Shape impactArea) {
    final List<ICombatEntity> affected = this.lookForAffectedEntities(impactArea);
    for (final ICombatEntity affectedEntity : affected) {
      this.apply(affectedEntity);
    }

    this.appliances.add(new EffectApplication(affected, impactArea));

    // if it is the first appliance -> register for update
    if (this.appliances.size() == 1) {
      Game.loop().attach(this);
    }
}
}
```
```java
class de.gurkenlabs.litiengine.GameTime {
public long toTicks(final int milliseconds) {
    return this.toTicks(milliseconds, Game.loop().getTickRate());
}public long since(final long tick) {
    return toMilliseconds(Game.loop().getTicks() - tick);
}public long now() {
    return Game.loop().getTicks();
}public long sinceGameStart() {
    return this.toMilliseconds(Game.loop().getTicks());
}@Override
  public void loaded(Environment environment) {
    environmentLoaded = Game.loop().getTicks();
}public long toMilliseconds(final long ticks) {
    return this.toMilliseconds(ticks, Game.loop().getTickRate());
}
}
```
```java
class de.gurkenlabs.litiengine.GameMetrics {
@Override
  public void render(final Graphics2D g) {
    this.updateMetrics();

    if (!Game.config().client().showGameMetrics()) {
      return;
    }

    this.currentOffsetY = 0;

    g.setColor(this.renderColor);

    // render client metrics
    this.drawTitle(g, "[client]");
    this.drawMetric(g, "fps       : " + this.getFramesPerSecond());
    this.drawMetric(g, "max fps   : " + this.maxFramesPerSecond);
    this.drawMetric(g, "updatables: " + Game.loop().getUpdatableCount());

    // render jvm metrics if debug is enabled
    if (Game.config().debug().isDebugEnabled()) {
      this.drawTitle(g, "[jvm]");
      this.drawMetric(g, "java      : " + this.javaVersion);
      this.drawMetric(g, "memory    : " + String.format("%-5.5s", this.usedMemory) + " MB");
      this.drawMetric(g, "threads   : " + Thread.activeCount());
    }

    // render rendering metrics
    if (!this.renderMetrics.isEmpty()) {
      this.drawTitle(g, "[update]");

      for (RenderMetrics metric : this.renderMetrics) {
        this.drawMetric(g, metric.toString());
      }

      this.renderMetrics.clear();
    }
}
}
```
```java
class de.gurkenlabs.litiengine.graphics.emitters.Emitter {
public void deactivate() {
    if (!this.activated) {
      return;
    }

    this.activated = false;
    this.getParticles().clear();
    this.aliveTime = 0;
    this.activationTick = 0;
    this.lastSpawn = 0;
    Game.loop().detach(this);
}public void activate() {
    if (this.activated) {
      return;
    }

    this.activated = true;
    this.activationTick = Game.time().now();
    Game.loop().attach(this);
}@Override
  public void update() {
    if (this.isPaused()) {
      return;
    }

    // clear particles if the effect time to life is reached
    if (this.isFinished()) {
      for (EmitterFinishedListener listener : this.finishedListeners) {
        listener.finished(this);
      }

      this.delete();
      return;
    }

    final float updateRatio = (float) this.data().getUpdateRate() / Game.loop().getTickRate();
    for (final Particle p : this.getParticles().stream().collect(Collectors.toList())) {
      if (this.particleCanBeRemoved(p)) {
        // remove dead particles
        this.particles.remove(p);
        continue;
      }

      p.update(this.getOrigin(), updateRatio);
    }

    this.aliveTime = Game.time().since(this.activationTick);
    if ((this.data().getSpawnRate() == 0
        || Game.time().since(this.lastSpawn) >= this.data().getSpawnRate())) {
      this.lastSpawn = Game.time().now();
      this.spawnParticle();
    }
}
}
```
```java
class de.gurkenlabs.litiengine.entities.behavior.IBehaviorController {
public default void attach() {
    Game.loop().attach(this);
}public default void detach() {
    Game.loop().detach(this);
}
}
```
```java
class de.gurkenlabs.litiengine.abilities.AbilityExecution {
AbilityExecution(final Ability ability) {
    this.appliedEffects = new CopyOnWriteArrayList<>();
    this.ability = ability;
    this.executionTicks = Game.time().now();
    this.impactArea = ability.calculateImpactArea();
    this.castLocation = ability.getExecutor().getCenter();
    Game.loop().attach(this);
}@Override
  public void update() {
    // if there a no effects to apply -> unregister this instance and we're done
    if (this.getAbility().getEffects().isEmpty()
        || this.getAbility().getEffects().size() == this.getAppliedEffects().size()) {
      Game.loop().detach(this);
      return;
    }

    // handle all effects from the ability that were not applied yet
    for (final Effect effect : this.getAbility().getEffects()) {
      // if the ability was not executed yet or the delay of the effect is not
      // yet reached
      if (this.getAppliedEffects().contains(effect)
          || Game.time().since(this.getExecutionTicks()) < effect.getDelay()) {
        continue;
      }

      effect.apply(this.getExecutionImpactArea());
      this.getAppliedEffects().add(effect);
    }
}
}
```
```java
class de.gurkenlabs.litiengine.GameWindow$3 {
@Override
          public void windowGainedFocus(WindowEvent e) {
            Game.loop().setTickRate(Game.config().client().getMaxFps());
}@Override
          public void windowLostFocus(WindowEvent e) {
            if (Game.config().graphics().reduceFramesWhenNotFocused()) {
              Game.loop().setTickRate(NONE_FOCUS_MAX_FPS);
            }
}
}
```
```java
class de.gurkenlabs.litiengine.environment.EntitySpawner {
protected void spawnNewEntities() {
    if (this.getSpawnMode() != SpawnMode.CUSTOMSPAWNPOINTS && this.getSpawnPoints().isEmpty()) {
      return;
    }

    switch (this.getSpawnMode()) {
      case ALLSPAWNPOINTS:
        for (int i = 0; i < this.getSpawnPoints().size(); i++) {
          final int index = i;
          Game.loop()
              .perform(
                  this.getSpawnDelay() + this.getSpawnDelay() * i,
                  () -> this.spawn(this.getSpawnPoints().get(index), this.getSpawnAmount()));
        }
        break;
      case ONERANDOMSPAWNPOINT:
        this.spawn(Game.random().choose(this.getSpawnPoints()), this.getSpawnAmount());
        break;
      case RANDOMSPAWNPOINTS:
        for (int i = 0; i < this.getSpawnAmount(); i++) {
          Game.loop()
              .perform(
                  this.getSpawnDelay() + this.getSpawnDelay() * i,
                  () -> this.spawn(Game.random().choose(this.getSpawnPoints()), 1));
        }
        break;
      case CUSTOMSPAWNPOINTS:
        List<Spawnpoint> spawnPoints =
            this.customSpawnpoints != null
                ? this.customSpawnpoints.apply(this)
                : this.getCustomSpawnpoints();

        int index = 0;
        for (Spawnpoint spawn : spawnPoints) {
          Game.loop()
              .perform(
                  this.getSpawnDelay() + this.getSpawnDelay() * index, () -> this.spawn(spawn, 1));
          index++;
        }
        break;
      default:
        break;
    }
}
}
```
```java
class de.gurkenlabs.litiengine.tweening.TweenEngine {
@Override
  public void start() {
    Game.loop().attach(this);
}@Override
  public void terminate() {
    Game.loop().detach(this);
}
}
```
```java
class de.gurkenlabs.litiengine.gui.SpeechBubble {
public void hide() {
    Game.world().environment().removeRenderable(this);
    Game.loop().detach(this);
    if (activeSpeechBubbles.get(this.getEntity()) != null
        && activeSpeechBubbles.remove(this.getEntity()).equals(this)) {
      activeSpeechBubbles.remove(this.getEntity());
    }

    for (SpeechBubbleListener listener : this.listeners) {
      listener.hidden();
    }
}private SpeechBubble(
      final IEntity entity,
      final String text,
      @Nullable SpeechBubbleAppearance appearance,
      @Nullable Font font) {
    if (appearance == null) {
      this.appearance = DEFAULT_APPEARANCE;
    } else {
      this.appearance = appearance;
    }

    final SpeechBubble active = activeSpeechBubbles.get(entity);
    if (active != null) {
      active.hide();
    }
    this.setFont(font);

    this.textBoxWidth = (float) (entity.getWidth() * 4);
    this.entity = entity;

    this.currentText = text;
    this.currentTextDisplayTime = DISPLAYTIME_MIN + text.length() * DISPLAYTIME_PER_LETTER;

    this.lastTextDisplay = Game.time().now();
    this.createBubbleImage();
    entity.getEnvironment().add(this, RenderType.UI);
    Game.loop().attach(this);
    activeSpeechBubbles.put(entity, this);
}
}
```
```java
class de.gurkenlabs.litiengine.entities.Prop {
private void updateAnimationController() {
    IEntityAnimationController<?> controller = this.createAnimationController();
    this.getControllers().addController(controller);
    if (Game.world().environment() != null && Game.world().environment().isLoaded()) {
      Game.loop().attach(controller);
    }
}
}
```
```java
class de.gurkenlabs.litiengine.graphics.FreeFlightCamera {
public FreeFlightCamera(final Point2D focus) {
    this.setFocus(focus);
    this.velocity = DEFAULT_SCROLL_PIXELS_PER_SECOND;
    this.scrollPadding = DEFAULT_SCROLL_PADDING;
    this.setClampToMap(true);

    Game.loop().attach(this);
}private void handleFreeFlightCamera() {
    if (Game.world().environment() == null || Game.world().environment().getMap() == null) {
      return;
    }

    final Point2D mouseLocation = Input.mouse().getLocation();

    final double scrollSpeed =
        this.getVelocity()
            / (double) Game.loop().getTickRate()
            * Game.config().input().getMouseSensitivity();

    double x = this.getFocus().getX();
    double y = this.getFocus().getY();

    double deltaX = 0;
    if (mouseLocation.getX() < this.getScrollPadding()) {
      deltaX -= scrollSpeed;
    } else if (Game.window().getResolution().getWidth() - mouseLocation.getX()
        < this.getScrollPadding()) {
      deltaX += scrollSpeed;
    }

    double deltaY = 0;
    if (mouseLocation.getY() < this.getScrollPadding()) {
      deltaY -= scrollSpeed;
    } else if (Game.window().getResolution().getHeight() - mouseLocation.getY()
        < this.getScrollPadding()) {
      deltaY += scrollSpeed;
    }

    x += deltaX;
    y += deltaY;

    this.setFocus(new Point2D.Double(x, y));
}
}
```
```java
class de.gurkenlabs.litiengine.environment.Environment {
private static void dispose(final Collection<? extends IEntity> entities) {
    for (final IEntity entity : entities) {
      if (entity instanceof IUpdateable) {
        Game.loop().detach((IUpdateable) entity);
      }

      entity.detachControllers();
    }
}private static void loadUpdatableOrEmitterEntity(IEntity entity) {
    if (entity instanceof Emitter) {
      final Emitter emitter = (Emitter) entity;
      if (emitter.isActivateOnInit()) {
        emitter.activate();
      }
    } else if (entity instanceof IUpdateable) {
      Game.loop().attach((IUpdateable) entity);
    }
}private void unload(final IEntity entity) {
    // 1. remove from physics engine
    if (entity instanceof ICollisionEntity) {
      Game.physics().remove((ICollisionEntity) entity);
    }

    // 2. unregister from update
    if (entity instanceof IUpdateable) {
      Game.loop().detach((IUpdateable) entity);
    }

    if (entity instanceof IMobileEntity) {
      this.removeGravity((IMobileEntity) entity);
    }

    // 3. detach all controllers
    entity.detachControllers();

    if (entity instanceof Emitter) {
      Emitter em = (Emitter) entity;
      em.deactivate();
    }

    if (this.loaded && (entity instanceof LightSource || entity instanceof StaticShadow)) {
      this.updateLighting(entity);
    }

    entity.removed(this);
}
}
```
```java
class de.gurkenlabs.litiengine.graphics.animation.Animation {
@Override
  public void update() {
    // do nothing if the animation is not playing or the current keyframe is not finished
    if (!this.isPlaying()
        || Game.time().since(this.lastFrameUpdate) < this.getCurrentKeyFrame().getDuration()) {
      return;
    }

    // if we are not looping and the last keyframe is finished, we terminate the animation
    if (!this.isLooping() && this.isLastKeyFrame()) {
      this.terminate();
      return;
    }

    // make sure, we stay inside the keyframe list
    final int newFrameIndex =
        (this.getKeyframes().indexOf(this.currentFrame) + 1) % this.getKeyframes().size();
    final KeyFrame previousFrame = this.currentFrame;
    this.currentFrame = this.getKeyframes().get(newFrameIndex);

    for (KeyFrameListener listener : this.listeners) {
      listener.currentFrameChanged(previousFrame, this.currentFrame);
    }

    this.lastFrameUpdate = Game.loop().getTicks();
}public void restart() {
    this.currentFrame = this.firstFrame;
    this.lastFrameUpdate = Game.loop().getTicks();
}
}
```
```java
class de.gurkenlabs.litiengine.physics.MovementController {
@Override
  public void attach() {
    Game.loop().attach(this);
}private void handleForces() {
    // clean up forces
    this.activeForces.forEach(
        x -> {
          if (x.hasEnded()) {
            this.activeForces.remove(x);
          }
        });

    if (this.activeForces.isEmpty()) {
      return;
    }

    // disable turn-on-move for force handling
    boolean turn = this.getEntity().turnOnMove();
    this.getEntity().setTurnOnMove(false);
    try {
      double deltaX = 0;
      double deltaY = 0;
      for (final Force force : this.activeForces) {
        if (force.cancelOnReached() && force.hasReached(this.getEntity())) {
          force.end();
          continue;
        }

        final Point2D collisionBoxCenter = this.getEntity().getCollisionBoxCenter();
        final double angle =
            GeometricUtilities.calcRotationAngleInDegrees(collisionBoxCenter, force.getLocation());
        final double strength =
            Game.loop().getDeltaTime() * 0.001f * force.getStrength() * Game.loop().getTimeScale();
        deltaX += GeometricUtilities.getDeltaX(angle, strength);
        deltaY += GeometricUtilities.getDeltaY(angle, strength);
      }

      final Point2D target =
          new Point2D.Double(this.getEntity().getX() + deltaX, this.getEntity().getY() + deltaY);
      final boolean success = Game.physics().move(this.getEntity(), target);
      if (!success) {
        for (final Force force : this.activeForces) {
          if (force.cancelOnCollision()) {
            force.end();
          }
        }
      }
    } finally {
      this.getEntity().setTurnOnMove(turn);
    }
}@Override
  public void detach() {
    Game.loop().detach(this);
}public void handleMovement() {
    if (!this.isMovementAllowed()) {
      this.velocity = 0;
      return;
    }

    // max distance an entity can travel within one tick
    final double maxPixelsPerTick = this.getEntity().getTickVelocity();
    final double deltaTime = Game.loop().getDeltaTime() * Game.loop().getTimeScale();

    final double acceleration =
        this.getEntity().getAcceleration() == 0
            ? maxPixelsPerTick
            : deltaTime / this.getEntity().getAcceleration() * maxPixelsPerTick;
    final double deceleration =
        this.getEntity().getDeceleration() == 0
            ? this.getVelocity()
            : deltaTime / this.getEntity().getDeceleration() * maxPixelsPerTick;

    double dx = this.getDx();
    double dy = this.getDy();
    this.setDx(0);
    this.setDy(0);

    final double deltaVelocity =
        Math.min(Math.sqrt(Math.pow(dx, 2) + Math.pow(dy, 2)), acceleration);
    if (deltaVelocity != 0) {
      double newVelocity = this.getVelocity() + deltaVelocity;
      this.setVelocity(newVelocity);
    } else {
      final double newVelocity = Math.max(0, this.getVelocity() - deceleration);
      this.setVelocity(newVelocity);
      dx = GeometricUtilities.getDeltaX(this.moveAngle);
      dy = GeometricUtilities.getDeltaY(this.moveAngle);
    }

    if (this.getVelocity() == 0) {
      this.moveAngle = 0;
      return;
    }

    // actually move entity
    this.moveEntity(dx, dy);
}
}
```
```java
class de.gurkenlabs.litiengine.graphics.animation.AnimationController {
public void detach() {
    Game.loop().detach(this);
}public void attach() {
    Game.loop().attach(this);
}
}
```
```java
class de.gurkenlabs.litiengine.graphics.Camera {
@Override
  public void setZoom(final float targetZoom, final int delay) {
    if (delay == 0) {

      this.zoom = targetZoom;
      this.targetZoom = 0;
      this.zoomDelay = 0;
      this.zoomTick = 0;
      this.zoomStep = 0;

      final ZoomChangedEvent event = new ZoomChangedEvent(this, targetZoom);
      for (final ZoomChangedListener listener : this.zoomListeners) {
        listener.zoomChanged(event);
      }
    } else {
      this.zoomTick = Game.time().now();
      this.targetZoom = targetZoom;
      this.zoomDelay = delay;

      final double tickduration = 1000 / (double) Game.loop().getTickRate();
      final double tickAmount = delay / tickduration;
      final float totalDelta = this.targetZoom - this.zoom;
      this.zoomStep = tickAmount > 0 ? (float) (totalDelta / tickAmount) : totalDelta;
    }
}
}
```
```java
class de.gurkenlabs.litiengine.Game {
public static synchronized void init(String... args) {
    if (initialized) {
      log().log(Level.INFO, "The game has already been initialized.");
      return;
    }

    log.init();
    handleCommandLineArguments(args);

    config().load();
    Locale.setDefault(new Locale(config().client().getCountry(), config().client().getLanguage()));

    gameLoop = new GameLoop("Main Update Loop", config().client().getMaxFps());
    loop().attach(physics());
    loop().attach(world());

    // setup default exception handling for render and update loop
    setUncaughtExceptionHandler(
        new DefaultUncaughtExceptionHandler(config().client().exitOnError()));

    screenManager = new ScreenManager();
    gameWindow = new GameWindow();

    // initialize  the game window
    window().init();
    world.setCamera(new Camera());

    for (GameListener listener : gameListeners) {
      listener.initialized(args);
    }

    if (!isInNoGUIMode()) {
      window().getRenderComponent().onRendered(g -> metrics().render(g));

      graphics()
          .addEntityRenderedListener(
              e -> DebugRenderer.renderEntityDebugInfo(e.getGraphics(), e.getEntity()));

      window().getRenderComponent().onFpsChanged(fps -> metrics().setFramesPerSecond(fps));
      window()
          .setIcons(
              Arrays.asList(
                  Resources.images().get("liti-logo-x16.png"),
                  Resources.images().get("liti-logo-x20.png"),
                  Resources.images().get("liti-logo-x32.png"),
                  Resources.images().get("liti-logo-x48.png")));

      Input.keyboard()
          .onKeyTyped(
              KeyEvent.VK_PRINTSCREEN,
              key -> {
                // don't take a screenshot if a modifier is active
                if (key.getModifiers() != 0) {
                  return;
                }

                window().getRenderComponent().takeScreenshot();
              });
    }

    Runtime.getRuntime().addShutdownHook(new Thread(Game::terminate, "Shutdown"));

    initialized = true;
}
}
```
```java
class de.gurkenlabs.litiengine.entities.Creature {
protected void updateAnimationController() {
    IEntityAnimationController<?> controller = this.createAnimationController();
    this.getControllers().addController(controller);
    if (Game.world().environment() != null && Game.world().environment().isLoaded()) {
      Game.loop().attach(controller);
    }
}@Override
  public float getTickVelocity() {
    // pixels per ms multiplied by the passed ms
    // ensure that entities don't travel too far in case of lag
    return Math.min(Game.loop().getDeltaTime(), GameLoop.TICK_DELTATIME_LAG)
        * 0.001F
        * this.getVelocity().get()
        * Game.loop().getTimeScale();
}
}
```
Depth: 2
```java
class de.gurkenlabs.litiengine.environment.GameWorld {
public void clear() {
    this.unloadEnvironment();
    this.environments.clear();
    this.setCamera(null);
    Game.physics().clear();

    this.environmentListeners.clear();
    this.environmentLoadedListeners.clear();
    this.environmentUnloadedListeners.clear();

    this.listeners.clear();
    this.loadedListeners.clear();
    this.unloadedListeners.clear();
}@Nullable
  public Environment loadEnvironment(IMap map) {
    Environment env = this.getEnvironment(map);
    this.loadEnvironment(env);
    return env;
}@Nullable
  public Environment loadEnvironment(String mapName) {
    Environment env = this.getEnvironment(mapName);
    this.loadEnvironment(env);
    return env;
}
}
```
```java
class de.gurkenlabs.litiengine.GameWindow {
GameWindow() {
    this.hostControl = new JFrame();

    this.resolutionChangedListeners = new CopyOnWriteArrayList<>();

    this.renderCanvas = new RenderComponent(Game.config().graphics().getResolution());
    this.cursor = new MouseCursor();
    if (!Game.isInNoGUIMode()) {
      this.hostControl.setBackground(Color.BLACK);
      this.hostControl.add(this.renderCanvas);

      this.initializeEventListeners();

      this.hostControl.setTitle(Game.info().getTitle());
      this.hostControl.setDefaultCloseOperation(WindowConstants.DO_NOTHING_ON_CLOSE);
      initializeWindowEventListeners(this.hostControl);
    }
}
}
```
```java
class de.gurkenlabs.litiengine.GameTime {
public long sinceEnvironmentLoad() {
    return this.since(this.environmentLoaded);
}public long since(final long tick) {
    return toMilliseconds(Game.loop().getTicks() - tick);
}public long sinceGameStart() {
    return this.toMilliseconds(Game.loop().getTicks());
}
}
```
```java
class de.gurkenlabs.litiengine.abilities.effects.Effect {
protected void cease(final EffectApplication appliance) {
    // 1. cease the effect for all affected entities
    for (final ICombatEntity entity : appliance.getAffectedEntities()) {
      this.cease(entity);
    }

    // 2. apply follow up effects
    this.getFollowUpEffects().forEach(followUp -> followUp.apply(appliance.getImpactArea()));
}protected boolean hasEnded(final EffectApplication appliance) {
    final long effectDuration = Game.time().since(appliance.getAppliedTicks());
    return effectDuration > this.getDuration();
}
}
```
```java
class de.gurkenlabs.litiengine.abilities.effects.EffectApplication {
protected EffectApplication(final List<ICombatEntity> affectedEntities, final Shape impactArea) {
    this.applied = Game.time().now();
    this.affectedEntities = affectedEntities;
    this.impactArea = impactArea;
}
}
```
```java
class de.gurkenlabs.litiengine.entities.CombatEntity {
@Override
  public boolean wasHit(int timeSpan) {
    return Game.time().since(this.lastHit) < timeSpan;
}@Override
  public void hit(final int damage, @Nullable final Ability ability) {
    if (this.isDead()) {
      return;
    }

    if (!this.isIndestructible()) {
      this.getHitPoints().modifyBaseValue(new AttributeModifier<>(Modification.SUBTRACT, damage));
    }

    final EntityHitEvent event = new EntityHitEvent(this, ability, damage, this.isDead());

    for (final CombatEntityListener listener : this.listeners) {
      listener.hit(event);
    }

    for (final CombatEntityHitListener listener : this.hitListeners) {
      listener.hit(event);
    }

    if (this.isDead()) {
      this.fireDeathEvent();
      this.setCollision(false);
    }

    this.lastHit = Game.time().now();
}
}
```
```java
class de.gurkenlabs.litiengine.graphics.ImageEffect {
protected ImageEffect(final int ttl, final String name) {
    this.ttl = ttl;
    this.name = name;
    this.aliveTick = Game.time().now();
}@Override
  public long getAliveTime() {
    return Game.time().since(this.aliveTick);
}
}
```
```java
class de.gurkenlabs.litiengine.abilities.AbilityExecution {
AbilityExecution(final Ability ability) {
    this.appliedEffects = new CopyOnWriteArrayList<>();
    this.ability = ability;
    this.executionTicks = Game.time().now();
    this.impactArea = ability.calculateImpactArea();
    this.castLocation = ability.getExecutor().getCenter();
    Game.loop().attach(this);
}@Override
  public void update() {
    // if there a no effects to apply -> unregister this instance and we're done
    if (this.getAbility().getEffects().isEmpty()
        || this.getAbility().getEffects().size() == this.getAppliedEffects().size()) {
      Game.loop().detach(this);
      return;
    }

    // handle all effects from the ability that were not applied yet
    for (final Effect effect : this.getAbility().getEffects()) {
      // if the ability was not executed yet or the delay of the effect is not
      // yet reached
      if (this.getAppliedEffects().contains(effect)
          || Game.time().since(this.getExecutionTicks()) < effect.getDelay()) {
        continue;
      }

      effect.apply(this.getExecutionImpactArea());
      this.getAppliedEffects().add(effect);
    }
}
}
```
```java
class de.gurkenlabs.litiengine.tweening.TweenEngine {
@Override
  public void update() {
    for (final Tweenable target : this.getTweens().keySet()) {
      for (final Tween tween : this.getTweens().get(target).values()) {
        if (tween.hasStopped()) {
          continue;
        }
        final long elapsed = Game.time().since(tween.getStartTime());
        if (elapsed >= tween.getDuration()) {
          tween.stop();
          continue;
        }
        final float[] currentValues = new float[tween.getTargetValues().length];
        for (int i = 0; i < tween.getTargetValues().length; i++) {
          currentValues[i] =
              tween.getStartValues()[i]
                  + tween.getEquation().compute(elapsed / (float) tween.getDuration())
                      * (tween.getTargetValues()[i] - tween.getStartValues()[i]);
        }
        tween.getTarget().setTweenValues(tween.getType(), currentValues);
      }
    }
}
}
```
```java
class de.gurkenlabs.litiengine.gui.SpeechBubble {
public static SpeechBubble create(
      final IEntity entity, final String text, SpeechBubbleAppearance appearance, Font font) {
    return new SpeechBubble(entity, text, appearance, font);
}public static SpeechBubble create(final IEntity entity, final Font font, final String text) {
    SpeechBubbleAppearance app =
        new SpeechBubbleAppearance(
            DEFAULT_APPEARANCE.getForeColor(),
            DEFAULT_APPEARANCE.getBackgroundColor1(),
            DEFAULT_APPEARANCE.getBorderColor(),
            DEFAULT_APPEARANCE.getPadding());
    return new SpeechBubble(entity, text, app, font);
}public static SpeechBubble create(final IEntity entity, final String text) {
    return new SpeechBubble(entity, text, null, GuiProperties.getDefaultFont());
}@Override
  public void update() {
    if (this.currentText == null) {
      this.hide();
      return;
    }

    this.entityCenter = Game.world().camera().getViewportLocation(this.getEntity().getCenter());

    // old text was displayed long enough
    if (this.lastTextDisplay != 0
        && Game.time().since(this.lastTextDisplay) > this.currentTextDisplayTime) {
      this.currentText = null;
      this.lastTextDisplay = 0;
      return;
    }

    // display new text
    if (this.textIndex < this.currentText.length()
        && Game.time().since(this.lastCharPoll) > LETTER_WRITE_DELAY) {
      this.textIndex++;
      this.lastCharPoll = Game.time().now();
      if (this.typeSound != null) {
        Game.audio().playSound(this.typeSound, this.getEntity());
      }
    }

    // continue displaying currently displayed text
}private SpeechBubble(
      final IEntity entity,
      final String text,
      final Sound typeSound,
      SpeechBubbleAppearance appearance,
      Font font) {
    this(entity, text, appearance, font);
    this.typeSound = typeSound;
}private SpeechBubble(
      final IEntity entity,
      final String text,
      @Nullable SpeechBubbleAppearance appearance,
      @Nullable Font font) {
    if (appearance == null) {
      this.appearance = DEFAULT_APPEARANCE;
    } else {
      this.appearance = appearance;
    }

    final SpeechBubble active = activeSpeechBubbles.get(entity);
    if (active != null) {
      active.hide();
    }
    this.setFont(font);

    this.textBoxWidth = (float) (entity.getWidth() * 4);
    this.entity = entity;

    this.currentText = text;
    this.currentTextDisplayTime = DISPLAYTIME_MIN + text.length() * DISPLAYTIME_PER_LETTER;

    this.lastTextDisplay = Game.time().now();
    this.createBubbleImage();
    entity.getEnvironment().add(this, RenderType.UI);
    Game.loop().attach(this);
    activeSpeechBubbles.put(entity, this);
}
}
```
```java
class de.gurkenlabs.litiengine.gui.TextFieldComponent {
@Override
  public void render(final Graphics2D g) {
    super.render(g);
    g.setFont(this.getFont());
    final FontMetrics fm = g.getFontMetrics();

    if (this.isSelected() && Game.time().since(this.lastToggled) > this.flickerDelay) {
      this.cursorVisible = !this.cursorVisible;
      this.lastToggled = Game.time().now();
    }
    if (this.isSelected() && this.cursorVisible) {
      final Rectangle2D cursor =
          new Rectangle2D.Double(
              this.getX() + this.getTextX() + fm.stringWidth(this.getTextToRender(g)),
              this.getY() + this.getTextY(),
              this.getFont().getSize2D() * 3 / 5,
              this.getFont().getSize2D() * 1 / 5);
      g.setColor(this.getAppearance().getForeColor());
      g.fill(cursor);
    }
}
}
```
```java
class de.gurkenlabs.litiengine.entities.Prop {
public Prop(
      final Point2D location, @Nullable final String spritesheetName, final Material material) {
    super();
    this.rotation = Rotation.NONE;
    this.spritesheetName = spritesheetName;
    this.material = material;
    this.setLocation(location);
    this.updateAnimationController();
}public void setSpritesheetName(@Nullable final String spriteName) {
    this.spritesheetName = spriteName;
    this.updateAnimationController();
}
}
```
```java
class de.gurkenlabs.litiengine.tweening.Tween {
public Tween begin() {
    this.started = Game.time().now();
    this.stopped = false;
    return this;
}
}
```
```java
class de.gurkenlabs.litiengine.graphics.emitters.particles.Particle {
public void update(final Point2D emitterOrigin, final float updateRatio) {
    if (this.aliveTick == 0) {
      this.aliveTick = Game.time().now();
    }

    this.aliveTime = Game.time().since(this.aliveTick);
    if (this.timeToLiveReached()) {
      return;
    }

    if (this.colliding) {
      return;
    }

    if (this.getDeltaWidth() != 0) {
      this.width += this.getDeltaWidth() * updateRatio;
    }

    if (this.getDeltaHeight() != 0) {
      this.height += this.getDeltaHeight() * updateRatio;
    }

    if (this.getDeltaAngle() != 0) {
      this.angle += this.getDeltaAngle() * updateRatio;
    }

    // test for ray cast collision
    final float targetX = this.x + this.getVelocityX() * updateRatio;
    final float targetY = this.y + this.getVelocityY() * updateRatio;

    if (targetX == this.x && targetY == this.y) {
      return;
    }

    if (this.checkForCollision(emitterOrigin, targetX, targetY)) {
      return;
    }

    if (this.getVelocityX() != 0) {
      this.x = targetX;
    }

    if (this.getVelocityY() != 0) {
      this.y = targetY;
    }

    if (this.getAccelerationX() != 0) {
      this.velocityX += this.getAccelerationX() * updateRatio;
    }

    if (this.getAccelerationY() != 0) {
      this.velocityY += this.getAccelerationY() * updateRatio;
    }
}
}
```
```java
class de.gurkenlabs.litiengine.graphics.animation.Animation {
@Override
  public void start() {
    this.playing = true;
    if (this.getKeyframes().isEmpty()) {
      return;
    }

    this.restart();
}@Override
  public void update() {
    // do nothing if the animation is not playing or the current keyframe is not finished
    if (!this.isPlaying()
        || Game.time().since(this.lastFrameUpdate) < this.getCurrentKeyFrame().getDuration()) {
      return;
    }

    // if we are not looping and the last keyframe is finished, we terminate the animation
    if (!this.isLooping() && this.isLastKeyFrame()) {
      this.terminate();
      return;
    }

    // make sure, we stay inside the keyframe list
    final int newFrameIndex =
        (this.getKeyframes().indexOf(this.currentFrame) + 1) % this.getKeyframes().size();
    final KeyFrame previousFrame = this.currentFrame;
    this.currentFrame = this.getKeyframes().get(newFrameIndex);

    for (KeyFrameListener listener : this.listeners) {
      listener.currentFrameChanged(previousFrame, this.currentFrame);
    }

    this.lastFrameUpdate = Game.loop().getTicks();
}
}
```
```java
class de.gurkenlabs.litiengine.graphics.animation.AnimationController {
@Override
  public void update() {
    for (final Animation animation : this.getAll()) {
      animation.update();
    }

    if (this.getCurrent() != null && this.getCurrent().isPaused()) {
      return;
    }

    final boolean playbackFinished = this.getCurrent() != null && !this.getCurrent().isPlaying();
    if (playbackFinished) {
      for (final AnimationListener listener : this.listeners) {
        listener.finished(this.getCurrent());
      }
    }

    if (this.getCurrent() == null || playbackFinished) {
      if (this.getDefault() != null) {
        this.play(this.getDefault().getName());
      } else {
        this.currentAnimation = null;
      }
    }
}
}
```
```java
class de.gurkenlabs.litiengine.graphics.RenderComponent {
private void handleFade() {
    if (this.fadeOutStart != -1) {
      final long timePassed = Game.time().since(this.fadeOutStart);
      this.currentAlpha = MathUtilities.clamp(1 - timePassed / (float) this.fadeOutTime, 0, 1);
      if (this.currentAlpha == 0f) {
        this.fadeOutStart = -1;
        this.fadeOutTime = -1;
      }

      return;
    }

    if (this.fadeInStart != -1) {
      final long timePassed = Game.time().since(this.fadeInStart);
      this.currentAlpha = MathUtilities.clamp(timePassed / (float) this.fadeInTime, 0, 1);
      if (this.currentAlpha == 1f) {
        this.fadeInStart = -1;
        this.fadeInTime = -1;
        this.currentAlpha = Float.NaN;
      }
    }
}public void fadeOut(final int ms) {
    this.fadeInStart = -1;
    this.fadeInTime = -1;
    this.fadeOutStart = Game.time().now();
    this.fadeOutTime = ms;
}public void fadeIn(final int ms) {
    this.fadeOutStart = -1;
    this.fadeOutTime = -1;
    this.fadeInStart = Game.time().now();
    this.fadeInTime = ms;
}
}
```
```java
class de.gurkenlabs.litiengine.entities.Trigger {
private boolean activate(final IEntity activator, final int tar) {
    if (!this.isLoaded()
        || this.isOneTimeTrigger && this.isActivated
        || this.getActivationType() == TriggerActivation.COLLISION
            && activator != null
            && this.collisionActivated.contains(activator)) {
      return false;
    }

    if (this.getCooldown() > 0 && Game.time().since(this.lastActivation) < this.getCooldown()) {
      return false;
    }

    List<Integer> triggerTargets = this.getTargets(tar);

    final TriggerEvent te = new TriggerEvent(this, activator, triggerTargets);

    if (!this.checkActivationPredicates(te)) {
      return false;
    }

    this.isActivated = true;
    if (activator != null) {
      this.collisionActivated.add(activator);
    }

    // if we actually have a trigger target, we send the message to the target
    for (final int target : triggerTargets) {
      final IEntity entity = this.getEnvironment().get(target);
      if (entity == null) {
        log.log(
            Level.WARNING,
            "trigger [{0}] was activated, but the trigger target [{1}] could not be found on the environment",
            new Object[] {this, target});
        continue;
      }

      entity.sendMessage(this, this.message);
    }

    // also send the trigger event to all registered consumers
    for (final TriggerActivatedListener listener : this.activatedListeners) {
      listener.activated(te);
    }

    if (this.isOneTimeTrigger) {
      this.getEnvironment().remove(this);
    }

    this.lastActivation = Game.time().now();
    return true;
}
}
```
```java
class de.gurkenlabs.litiengine.graphics.Camera {
private boolean isShakeEffectActive() {
    return this.getShakeTick() != 0
        && Game.time().since(this.getShakeTick()) < this.getShakeDuration();
}@Override
  public void update() {
    if (Game.world().camera() != null && !Game.world().camera().equals(this)) {
      return;
    }

    if (this.targetZoom > 0) {
      if (Game.time().since(this.zoomTick) >= this.zoomDelay) {
        this.zoom = this.targetZoom;
        this.targetZoom = 0;
        this.zoomDelay = 0;
        this.zoomTick = 0;
        this.zoomStep = 0;
      } else {
        this.zoom += this.zoomStep;
      }

      final ZoomChangedEvent event = new ZoomChangedEvent(this, this.getZoom());
      for (final ZoomChangedListener listener : this.zoomListeners) {
        listener.zoomChanged(event);
      }
    }

    if (this.panTime > 0) {
      if (--this.panTime <= 0) {
        this.setFocus(this.targetFocus);
        this.targetFocus = null;
      } else {
        double diff = this.panTime / (this.panTime + 1.0);
        this.focus =
            new Point2D.Double(
                this.focus.getX() * diff + this.targetFocus.getX() * (1.0 - diff),
                this.focus.getY() * diff + this.targetFocus.getY() * (1.0 - diff));
      }
    }

    if (!this.isShakeEffectActive()) {
      this.shakeOffsetX = 0;
      this.shakeOffsetY = 0;
      return;
    }

    if (Game.time().since(this.lastShake) > this.shakeDelay) {
      this.shakeOffsetX = this.getShakeIntensity() * ThreadLocalRandom.current().nextGaussian();
      this.shakeOffsetY = this.getShakeIntensity() * ThreadLocalRandom.current().nextGaussian();
      this.lastShake = Game.time().now();
    }
}@Override
  public void setZoom(final float targetZoom, final int delay) {
    if (delay == 0) {

      this.zoom = targetZoom;
      this.targetZoom = 0;
      this.zoomDelay = 0;
      this.zoomTick = 0;
      this.zoomStep = 0;

      final ZoomChangedEvent event = new ZoomChangedEvent(this, targetZoom);
      for (final ZoomChangedListener listener : this.zoomListeners) {
        listener.zoomChanged(event);
      }
    } else {
      this.zoomTick = Game.time().now();
      this.targetZoom = targetZoom;
      this.zoomDelay = delay;

      final double tickduration = 1000 / (double) Game.loop().getTickRate();
      final double tickAmount = delay / tickduration;
      final float totalDelta = this.targetZoom - this.zoom;
      this.zoomStep = tickAmount > 0 ? (float) (totalDelta / tickAmount) : totalDelta;
    }
}@Override
  public void shake(final double intensity, final int delay, final int shakeDuration) {
    this.shakeTick = Game.time().now();
    this.shakeDelay = delay;
    this.shakeIntensity = intensity;
    this.shakeDuration = shakeDuration;
}
}
```
```java
class de.gurkenlabs.litiengine.entities.Creature {
public void setSpritesheetName(String spritesheetName) {
    if (this.spritesheetName != null && this.spritesheetName.equals(spritesheetName)) {
      return;
    }

    this.spritesheetName = spritesheetName;
    this.updateAnimationController();
}public boolean isIdle() {
    return Game.time().since(this.lastMoved) > IDLE_DELAY;
}@Override
  public void setLocation(final Point2D position) {
    if (this.isDead() || position == null) {
      return;
    }

    final Point2D oldLocation = this.getLocation();
    super.setLocation(position);

    if (Game.hasStarted() && this.isLoaded()) {
      this.lastMoved = Game.time().now();
      this.fireMovedEvent(
          new EntityMovedEvent(
              this, this.getX() - oldLocation.getX(), this.getY() - oldLocation.getY()));
    }
}
}
```
```java
class de.gurkenlabs.litiengine.gui.screens.ScreenManager {
public void display(final String screenName) {
    if (this.current() != null && this.current().getName().equalsIgnoreCase(screenName)) {
      log.log(
          Level.INFO,
          "Skipping displaying of screen {0} because it is already the current screen.",
          screenName);
      return;
    }

    if (this.screens.stream()
        .noneMatch(element -> element.getName().equalsIgnoreCase(screenName))) {
      log.log(
          Level.WARNING,
          "Could not display the screen {0} because there is no screen with the specified name.",
          screenName);
      return;
    }

    Screen screen = this.get(screenName);
    if (screen == null) {
      return;
    }

    this.display(screen);
}public void add(final Screen screen) {
    screen.setWidth(Game.window().getWidth());
    screen.setHeight(Game.window().getHeight());
    this.screens.add(screen);

    if (this.current() == null) {
      this.display(screen);
    }
}public void remove(Screen screen) {
    this.screens.remove(screen);
    if (this.current() == screen) {
      if (!this.screens.isEmpty()) {
        this.display(this.screens.get(0));
      } else {
        this.display((Screen) null);
      }
    }
}public void display(@Nullable final Screen screen) {
    if (Game.hasStarted() && Game.time().since(this.lastScreenChange) < this.getChangeCooldown()) {
      log.log(
          Level.INFO,
          "Skipping displaying of screen {0} because screen changing is currently on cooldown.",
          screen != null ? screen.getName() : "");
      return;
    }

    final Screen previous = this.current();
    if (previous != null) {
      previous.suspend();
    }

    if (screen != null && !this.screens.contains(screen)) {
      this.screens.add(screen);
    }

    this.currentScreen = screen;
    if (!Game.isInNoGUIMode() && this.current() != null) {
      this.current().prepare();
    }

    this.lastScreenChange = Game.loop().getTicks();

    final ScreenChangedEvent event = new ScreenChangedEvent(this.current(), previous);
    for (final ScreenChangedListener listener : this.screenChangedListeners) {
      listener.changed(event);
    }
}
}
```
```java
class de.gurkenlabs.litiengine.abilities.Ability {
public boolean isOnCooldown() {
    return (this.getCurrentExecution() != null
        && this.getCurrentExecution().getExecutionTicks() > 0
        && Game.time().since(this.getCurrentExecution().getExecutionTicks())
            < this.getAttributes().cooldown().get());
}public boolean isActive() {
    return this.getCurrentExecution() != null
        && Game.time().since(this.getCurrentExecution().getExecutionTicks())
            < this.getAttributes().duration().get();
}@Nullable
  public AbilityExecution cast() {
    if (!this.canCast()) {
      return null;
    }
    this.currentExecution = new AbilityExecution(this);

    for (final AbilityCastListener listener : this.abilityCastListeners) {
      listener.abilityCast(this.currentExecution);
    }

    return this.getCurrentExecution();
}public float getRemainingCooldownInSeconds() {
    if (this.getCurrentExecution() == null
        || this.getExecutor() == null
        || this.getExecutor().isDead()) {
      return 0;
    }

    // calculate cooldown in seconds
    return (float)
        (!this.canCast()
            ? (this.getAttributes().cooldown().get()
                    - Game.time().since(this.getCurrentExecution().getExecutionTicks()))
                * 0.001
            : 0);
}
}
```
```java
class de.gurkenlabs.litiengine.entities.EntityHitEvent {
EntityHitEvent(
      final ICombatEntity hitEntity,
      @Nullable final Ability ability,
      final int damage,
      final boolean kill) {
    super(hitEntity);
    this.executor = ability != null ? ability.getExecutor() : null;
    this.hitEntity = hitEntity;
    this.ability = ability;
    this.damage = damage;
    this.kill = kill;
    this.time = Game.time().now();
}
}
```
```java
class de.gurkenlabs.litiengine.graphics.emitters.Emitter {
public void delete() {
    this.deactivate();
    if (Game.world().environment() != null) {
      Game.world().environment().remove(this);
    }
}public void activate() {
    if (this.activated) {
      return;
    }

    this.activated = true;
    this.activationTick = Game.time().now();
    Game.loop().attach(this);
}@Override
  public void update() {
    if (this.isPaused()) {
      return;
    }

    // clear particles if the effect time to life is reached
    if (this.isFinished()) {
      for (EmitterFinishedListener listener : this.finishedListeners) {
        listener.finished(this);
      }

      this.delete();
      return;
    }

    final float updateRatio = (float) this.data().getUpdateRate() / Game.loop().getTickRate();
    for (final Particle p : this.getParticles().stream().collect(Collectors.toList())) {
      if (this.particleCanBeRemoved(p)) {
        // remove dead particles
        this.particles.remove(p);
        continue;
      }

      p.update(this.getOrigin(), updateRatio);
    }

    this.aliveTime = Game.time().since(this.activationTick);
    if ((this.data().getSpawnRate() == 0
        || Game.time().since(this.lastSpawn) >= this.data().getSpawnRate())) {
      this.lastSpawn = Game.time().now();
      this.spawnParticle();
    }
}
}
```
```java
class de.gurkenlabs.litiengine.GameLoop {
@Override
  public int perform(int delay, Runnable action) {
    final long d = Game.time().toTicks(delay);

    TimedAction a = new TimedAction(this.getTicks() + d, action);
    this.actions.add(a);

    return a.getId();
}
}
```
```java
class de.gurkenlabs.litiengine.environment.EntitySpawner {
protected boolean shouldSpawn() {
    return this.lastSpawnWave == 0
        || Game.time().since(this.lastSpawnWave) >= this.getSpawnInterval();
}@Override
  public void update() {
    if (!this.shouldSpawn()) {
      return;
    }

    this.spawnNewEntities();
    this.lastSpawnWave = Game.time().now();
}
}
```
```java
class de.gurkenlabs.litiengine.graphics.FreeFlightCamera {
@Override
  public void update() {
    this.handleFreeFlightCamera();
}public FreeFlightCamera(double x, double y) {
    this(new Point2D.Double(x, y));
}
}
```
```java
class de.gurkenlabs.litiengine.environment.Environment {
public void unload() {
    if (!this.loaded) {
      return;
    }

    // unregister all updatable entities from the current environment
    for (final IEntity entity : this.allEntities.values()) {
      this.unload(entity);
    }

    this.loaded = false;
    this.fireEvent(l -> l.unloaded(this));
}private static void loadUpdatableOrEmitterEntity(IEntity entity) {
    if (entity instanceof Emitter) {
      final Emitter emitter = (Emitter) entity;
      if (emitter.isActivateOnInit()) {
        emitter.activate();
      }
    } else if (entity instanceof IUpdateable) {
      Game.loop().attach((IUpdateable) entity);
    }
}public void clear() {
    Game.physics().clear();

    this.combatEntities.clear();
    this.mobileEntities.clear();
    this.gravityForces.clear();
    this.layerEntities.clear();
    this.entitiesByTag.clear();
    this.allEntities.clear();

    for (RenderType renderType : RenderType.values()) {
      this.miscEntities.get(renderType).clear();
      this.renderListeners.get(renderType).clear();
      this.renderables.get(renderType).clear();
    }

    dispose(this.allEntities.values());
    dispose(this.triggers);
    this.emitters.clear();
    this.colliders.clear();
    this.props.clear();
    this.creatures.clear();
    this.staticShadows.clear();
    this.combatEntities.clear();
    this.mobileEntities.clear();
    this.lightSources.clear();
    this.spawnPoints.clear();
    this.soundSources.clear();
    this.mapAreas.clear();
    this.triggers.clear();

    this.ambientLight = null;
    this.staticShadowLayer = null;

    for (Map<Integer, IEntity> type : this.miscEntities.values()) {
      type.clear();
    }

    this.initialized = false;

    this.fireEvent(l -> l.cleared(this));
}private void load(final IEntity entity) {
    // an entity can only exist on one environment at a time, so remove it from the current one
    if (entity.getEnvironment() != null) {
      entity.getEnvironment().remove(entity);
    }

    // 1. add to physics engine
    loadPhysicsEntity(entity);

    // 2. register for update or activate
    loadUpdatableOrEmitterEntity(entity);

    // 3. if a gravity is defined, add a gravity force to the entity
    if (entity instanceof IMobileEntity && this.getGravity() != 0) {
      this.addGravityForce((IMobileEntity) entity);
    }

    // 4. attach all controllers
    entity.attachControllers();

    if (this.loaded && (entity instanceof LightSource || entity instanceof StaticShadow)) {
      this.updateLighting(entity);
    }

    entity.loaded(this);
}private void unload(final IEntity entity) {
    // 1. remove from physics engine
    if (entity instanceof ICollisionEntity) {
      Game.physics().remove((ICollisionEntity) entity);
    }

    // 2. unregister from update
    if (entity instanceof IUpdateable) {
      Game.loop().detach((IUpdateable) entity);
    }

    if (entity instanceof IMobileEntity) {
      this.removeGravity((IMobileEntity) entity);
    }

    // 3. detach all controllers
    entity.detachControllers();

    if (entity instanceof Emitter) {
      Emitter em = (Emitter) entity;
      em.deactivate();
    }

    if (this.loaded && (entity instanceof LightSource || entity instanceof StaticShadow)) {
      this.updateLighting(entity);
    }

    entity.removed(this);
}public void remove(final IEntity entity) {
    if (entity == null) {
      return;
    }

    this.allEntities.remove(entity.getMapId());
    Iterator<List<IEntity>> iter = this.layerEntities.values().iterator();
    while (iter.hasNext()) {
      List<IEntity> layer = iter.next();
      if (layer.remove(entity) && layer.isEmpty()) {
        iter.remove();
      }
    }
    if (this.miscEntities.get(entity.getRenderType()) != null) {
      this.miscEntities.get(entity.getRenderType()).values().remove(entity);
    }

    for (String tag : entity.getTags()) {
      if (this.getEntitiesByTag().containsKey(tag)) {
        this.getEntitiesByTag().get(tag).remove(entity);

        if (this.getEntitiesByTag().get(tag).isEmpty()) {
          this.getEntitiesByTag().remove(tag);
        }
      }
    }

    if (entity instanceof Emitter) {
      Emitter emitter = (Emitter) entity;
      this.removeEmitter(emitter);
    }

    if (entity instanceof MapArea) {
      this.mapAreas.remove(entity);
    }

    if (entity instanceof Prop) {
      this.props.remove(entity);
    }

    if (entity instanceof Creature) {
      this.creatures.remove(entity);
    }

    if (entity instanceof CollisionBox) {
      this.colliders.remove(entity);
      this.staticShadows.removeIf(x -> x.getOrigin() != null && x.getOrigin().equals(entity));
    }

    if (entity instanceof LightSource) {
      this.lightSources.remove(entity);
      this.updateLighting(entity);
    }

    if (entity instanceof Trigger) {
      this.triggers.remove(entity);
    }

    if (entity instanceof Spawnpoint) {
      this.spawnPoints.remove(entity);
    }
    if (entity instanceof SoundSource) {
      this.soundSources.remove(entity);
    }

    if (entity instanceof StaticShadow) {
      this.staticShadows.remove(entity);
      this.updateLighting(entity);
    }

    if (entity instanceof IMobileEntity) {
      this.mobileEntities.values().remove(entity);
    }

    if (entity instanceof ICombatEntity) {
      this.combatEntities.values().remove(entity);
    }

    this.unload(entity);

    this.fireEntityEvent(l -> l.entityRemoved(entity));
}
}
```
```java
class de.gurkenlabs.litiengine.physics.MovementController {
@Override
  public void update() {
    this.handleForces();
    this.handleMovement();
}
}
```
```java
class de.gurkenlabs.litiengine.Game {
static synchronized void terminate() {
    if (!initialized) {
      return;
    }

    hasStarted = false;
    initialized = false;

    config().save();
    gameLoop.terminate();
    tweenEngine.terminate();
    soundEngine.terminate();

    world().clear();

    for (final GameListener listener : gameListeners) {
      try {
        listener.terminated();
      } catch (Exception e) {
        log().log(Level.WARNING, "game listener threw an exception during shutdown", e);
      }
    }

    gameLoop = null;
    screenManager = null;
    gameWindow = null;
}public static synchronized void start() {
    if (!initialized) {
      throw new IllegalStateException(
          "The game cannot be started without being first initialized. Call Game.init(...) before Game.start().");
    }

    gameLoop.start();
    tweenEngine.start();
    soundEngine.start();

    for (final GameListener listener : gameListeners) {
      listener.started();
    }

    hasStarted = true;
}public static synchronized void init(String... args) {
    if (initialized) {
      log().log(Level.INFO, "The game has already been initialized.");
      return;
    }

    log.init();
    handleCommandLineArguments(args);

    config().load();
    Locale.setDefault(new Locale(config().client().getCountry(), config().client().getLanguage()));

    gameLoop = new GameLoop("Main Update Loop", config().client().getMaxFps());
    loop().attach(physics());
    loop().attach(world());

    // setup default exception handling for render and update loop
    setUncaughtExceptionHandler(
        new DefaultUncaughtExceptionHandler(config().client().exitOnError()));

    screenManager = new ScreenManager();
    gameWindow = new GameWindow();

    // initialize  the game window
    window().init();
    world.setCamera(new Camera());

    for (GameListener listener : gameListeners) {
      listener.initialized(args);
    }

    if (!isInNoGUIMode()) {
      window().getRenderComponent().onRendered(g -> metrics().render(g));

      graphics()
          .addEntityRenderedListener(
              e -> DebugRenderer.renderEntityDebugInfo(e.getGraphics(), e.getEntity()));

      window().getRenderComponent().onFpsChanged(fps -> metrics().setFramesPerSecond(fps));
      window()
          .setIcons(
              Arrays.asList(
                  Resources.images().get("liti-logo-x16.png"),
                  Resources.images().get("liti-logo-x20.png"),
                  Resources.images().get("liti-logo-x32.png"),
                  Resources.images().get("liti-logo-x48.png")));

      Input.keyboard()
          .onKeyTyped(
              KeyEvent.VK_PRINTSCREEN,
              key -> {
                // don't take a screenshot if a modifier is active
                if (key.getModifiers() != 0) {
                  return;
                }

                window().getRenderComponent().takeScreenshot();
              });
    }

    Runtime.getRuntime().addShutdownHook(new Thread(Game::terminate, "Shutdown"));

    initialized = true;
}
}
```


Response Format:
Provide the answer in **XML format** as follows:

#### If the method **cannot** return `null` at the specific call site:
```xml
<response>
  <reason><![CDATA[EXPLAIN WHY THE INVOCATION Game.loop() RESULT CANNOT BE NULL.]]></reason>
  <value>NO</value>
</response>

#### If the method can return null at the specific call site:
<response>
  <reason><![CDATA[EXPLAIN WHY THE INVOCATION Game.loop() RESULT CAN BE NULL.]]></reason>
  <value>YES</value>
</response>

#### If you are unsure or If there are any methods that directly or indirectly affect the return value and are not fully disclosed, request their declarations first, in the following format:
<response>
  <reason><![CDATA[EXPLAIN WHY THIS METHOD DECLARATION IS NECESSARY AND WHY YOU CANNOT MAKE A CONFIDENT DECISION WITHOUT IT]]></reason>
  <success>false</success>
  <methods>
    <method>methodName</method>
  </methods>
</response>

Additional Notes:
Be precise in your reasoning.
If a method’s return value depends on another method not provided, request its declaration before making a conclusion.
If the method can return null in this case but not in others, explain why it happens specifically for this call.

---ChatGPT.sendRequestToOpenAI---
Retrieving response from cache
---Response.<init>---
Creating Response:
```xml
<response>
  <reason><![CDATA[The method `Game.loop()` returns the static field `gameLoop`, which is initialized in the `Game.init(String... args)` method. In this method, a new `GameLoop` object is instantiated and assigned to `gameLoop`. Since `init()` must be called before `start()`, which is implied by the requirement of initializing the game, the `gameLoop` is guaranteed to be non-null during the lifetime of the game execution where `Game.loop()` is called. The absence of any code that could set `gameLoop` to null after its initialization ensures that `Game.loop()` cannot return null.]]></reason>
  <value>NO</value>
</response>
```
---Response.<init>---
Response created:
Disagreement: The method `Game.loop()` returns the static field `gameLoop`, which is initialized in the `Game.init(String... args)` method. In this method, a new `GameLoop` object is instantiated and assigned to `gameLoop`. Since `init()` must be called before `start()`, which is implied by the requirement of initializing the game, the `gameLoop` is guaranteed to be non-null during the lifetime of the game execution where `Game.loop()` is called. The absence of any code that could set `gameLoop` to null after its initialization ensures that `Game.loop()` cannot return null.
---AdvancedNullAwayCodeFix.resolveMethodDereferenceError---
Method is not returning nullable on call site. Injecting suppression annotation.
---AdvancedNullAwayCodeFix.constructCastToNonnullChange---
Constructing cast to nonnull change for reason: The method `Game.loop()` returns the static field `gameLoop`, which is initialized in the `Game.init(String... args)` method. In this method, a new `GameLoop` object is instantiated and assigned to `gameLoop`. Since `init()` must be called before `start()`, which is implied by the requirement of initializing the game, the `gameLoop` is guaranteed to be non-null during the lifetime of the game execution where `Game.loop()` is called. The absence of any code that could set `gameLoop` to null after its initialization ensures that `Game.loop()` cannot return null.
---ChatGPT.ask---
Asking ChatGPT:
For the reason you mentioned earlier:

"The method `Game.loop()` returns the static field `gameLoop`, which is initialized in the `Game.init(String... args)` method. In this method, a new `GameLoop` object is instantiated and assigned to `gameLoop`. Since `init()` must be called before `start()`, which is implied by the requirement of initializing the game, the `gameLoop` is guaranteed to be non-null during the lifetime of the game execution where `Game.loop()` is called. The absence of any code that could set `gameLoop` to null after its initialization ensures that `Game.loop()` cannot return null."

in the method below, the expression Game.loop() is not nullable at the point it is used.

```java
public void attach() {
    Game.loop().attach(this);
}
```
Please Summarize the reason in max 5 words and rewrite the method so that at the line "    Game.loop().attach(this);", at the occurrence of: "Game.loop()" is replaced with `NullabilityUtil.castToNonnull(Game.loop(), summary of reason)`
Replace "REASON" with the exact reason summary I provide to you (maximum 5 words), not with a generic explanation like "checked to be nonnull".
see the example below, for expression `foo.getBar()`, to wrap it with `NullabilityUtil.castToNonnull(foo.getBar(), "reason")`.

```java
public t(){
    String l = foo.getBar();
}
```

will be:
```java
public t(){
    String l = NullabilityUtil.castToNonnull(foo.getBar(), "checked to be nonnull");
}
```

### Instructions:

Do not import any additional classes.

Do not add Java comments.

Only modify relevant lines as required.

Return only the modified method wrapped in the XML format shown below.

Place the Java code inside the <code> tag using a CDATA block with ```java formatting.

Just give me the fixed code snippet in XML format in <response> tag like the example below. I will apply the fix to my codebase. Do not import any additional libraries or classes or add java comments. If you can provide the fixed code snippet, please provide it in the following format and place the code snippet in the <code> tag within ```java block.
<response>
  <success>true</success>
  <code><![CDATA[
  ```java
  Your fixed code snippet here
  ```
    ]]>
  </code>
</response>

---ChatGPT.sendRequestToOpenAI---
Sending request to OpenAI...
---ChatGPT.sendRequestToOpenAI---
Response received from OpenAI.
---Response.<init>---
Creating Response:
<response>
  <success>true</success>
  <code><![CDATA[
  ```java
public void attach() {
    NullabilityUtil.castToNonnull(Game.loop(), "always initialized before use").attach(this);
}
  ```
    ]]>
  </code>
</response>
---Response.<init>---
Response created:
public void attach() {
    NullabilityUtil.castToNonnull(Game.loop(), "always initialized before use").attach(this);
}
---ChatGPT.fixDereferenceByAddingCastToNonnull---
Fixing the error by adding castToNonnull
---AdvancedNullAwayCodeFix.fixTriggeredErrorsForLocation---
Resolving unresolvable error for triggered error: Type='DEREFERENCE_NULLABLE', message='dereferenced expression Game.loop() is @Nullable'
/home/nima/Developer/nullness-benchmarks/litiengine/src/de/gurkenlabs/litiengine/entities/Creature.java:152
    return Math.min(Game.loop().getDeltaTime(), GameLoop.TICK_DELTATIME_LAG)
---AdvancedNullAwayCodeFix.fix---
Fixing error: Type='DEREFERENCE_NULLABLE', message='dereferenced expression Game.loop() is @Nullable'
/home/nima/Developer/nullness-benchmarks/litiengine/src/de/gurkenlabs/litiengine/entities/Creature.java:152
    return Math.min(Game.loop().getDeltaTime(), GameLoop.TICK_DELTATIME_LAG)
---AdvancedNullAwayCodeFix.resolveDereferenceError---
Resolving dereference error: Type='DEREFERENCE_NULLABLE', message='dereferenced expression Game.loop() is @Nullable'
/home/nima/Developer/nullness-benchmarks/litiengine/src/de/gurkenlabs/litiengine/entities/Creature.java:152
    return Math.min(Game.loop().getDeltaTime(), GameLoop.TICK_DELTATIME_LAG)
---AdvancedNullAwayCodeFix.resolveDereferenceError---
Checking nullability possibility at error point
---ChatGPT.checkNullabilityPossibilityAtErrorPoint---
Asking if the expression can be null at error point point
---ChatGPT.ask---
Asking ChatGPT:
In the method below, is there a possibility that the expression "Game.loop()" at line "return Math.min(Game.loop().getDeltaTime(), GameLoop.TICK_DELTATIME_LAG)" is null?
@Override
  public float getTickVelocity() {
    // pixels per ms multiplied by the passed ms
    // ensure that entities don't travel too far in case of lag
    return Math.min(Game.loop().getDeltaTime(), GameLoop.TICK_DELTATIME_LAG)
        * 0.001F
        * this.getVelocity().get()
        * Game.loop().getTimeScale();
}
Give a single-word answer in XML format. If it is possible for the expression to be null, respond with:
```xml
<response>
    <reason><![CDATA[YOUR REASON]]></reason>
    <value>YES</value>
</response>
```
If it is not possible for the expression to be null, respond with:
```xml
<response>
    <reason><![CDATA[YOUR REASON]]></reason>
    <value>NO</value>
</response>
```
If you are unsure or need more information, respond with where you can ask for more details or what specific information you need.

If additional information is required, list each request inside a `<request>` tag. If no additional information is needed, omit the `<requests>` section.

Respond with:
```xml
<response>
    <reason><![CDATA[YOUR REASON]]></reason>
    <value>UNKNOWN</value>
    <!-- Include <requests> only if additional information is needed -->
    <requests>
        <request><![CDATA[YOUR REQUEST 1]]></request>
        <request><![CDATA[YOUR REQUEST 2]]></request>
    </requests>
</response>
```
---ChatGPT.sendRequestToOpenAI---
Sending request to OpenAI...
---ChatGPT.sendRequestToOpenAI---
Response received from OpenAI.
---Response.<init>---
Creating Response:
```xml
<response>
    <reason><![CDATA[The possibility of Game.loop() being null depends on its implementation details within the Game class. Without seeing the Game class code or knowing how loop() is supposed to work, one cannot definitively determine if it can be null.]]></reason>
    <value>UNKNOWN</value>
    <requests>
        <request><![CDATA[Is there any code or documentation that explains the Game.loop() method?]]></request>
        <request><![CDATA[What are the initialization and lifecycle details of the Game class?]]></request>
    </requests>
</response>
```
---Response.<init>---
Response created:
Unknown: The possibility of Game.loop() being null depends on its implementation details within the Game class. Without seeing the Game class code or knowing how loop() is supposed to work, one cannot definitively determine if it can be null.
---AdvancedNullAwayCodeFix.resolveMethodDereferenceError---
Resolving method dereference error.
---AdvancedNullAwayCodeFix.resolveMethodDereferenceError---
Method is in annotated package. Checking if the method is returning nullable.
---AdvancedNullAwayCodeFix.investigateMethodReturnNullability---
Checking if the method is returning nullable.
---ChatGPT.checkIfMethodIsReturningNullable---
Asking if the method is returning nullable: loop()
---ChatGPT.ask---
Asking ChatGPT:
In the method below, is there a possibility that the method returns null based only on its body? Consider the following points:

- The method may have multiple return paths; consider all return statements.
- If the method calls another method, do not assume its return value unless its full declaration is provided. Request its declaration if needed.
- The method may throw an exception instead of returning null. An exception path should not be considered a null return.
- Ensure you request the declarations of any methods whose return values directly or indirectly impact this method’s return value before making a conclusion.
- Carefully analyze all conditions and prior operations that may guarantee a non-null return value.

@Nullable public static IGameLoop loop() {
    return gameLoop;
}

Here are the method definitions in addition to the method inquired:

Depth: 0
```java
class de.gurkenlabs.litiengine.Game {
@Nullable public static IGameLoop loop() {
    return gameLoop;
}
}
```


Response Format:
Provide the answer in **XML format** as follows:

#### If the method **cannot** return `null`:
```xml
<response>
  <reason><![CDATA[EXPLAIN WHY THE METHOD CANNOT RETURN NULL]]></reason>
  <value>NO</value>
</response>
```

#### If the method can return null:
```xml
<response>
  <reason><![CDATA[EXPLAIN WHY THE METHOD CAN RETURN NULL]]></reason>
  <value>YES</value>
</response>
```

#### If you are unsure or need more information, respond with where you can ask for more details or what specific information you need.

#### If you are unsure or If there are any methods that directly or indirectly affect the return value and are not fully disclosed, request their declarations first, in the following format:
<response>
  <reason><![CDATA[YOUR REASON]]></reason>
  <value>UNKNOWN</value>
  <methods>
    <method>methodName</method>
  </methods>
</response>

If additional information is required other than method declaration, list each request inside a `<request>` tag. If no additional information is needed, omit the `<requests>` section.

Respond with:
```xml
<response>
    <reason><![CDATA[YOUR REASON]]></reason>
    <value>UNKNOWN</value>
    <!-- Include <requests> only if additional information is needed -->
    <requests>
        <request><![CDATA[YOUR REQUEST 1]]></request>
        <request><![CDATA[YOUR REQUEST 2]]></request>
    </requests>
</response>
```

Additional Notes:
Be precise in your reasoning.
If a method’s return value depends on another method not provided, request its declaration before making a conclusion.
If the method can return null in some cases but not others, explain under what conditions it can happen.

---ChatGPT.sendRequestToOpenAI---
Retrieving response from cache
---Response.<init>---
Creating Response:
```xml
<response>
  <reason><![CDATA[The method `loop` returns the variable `gameLoop`. Without the initialization or assignment details of `gameLoop`, it's unclear whether it can be null. The possibility of `gameLoop` being uninitialized or set to null elsewhere in the program means `loop` could potentially return null. Further information on `gameLoop` is required.]]></reason>
  <value>UNKNOWN</value>
  <requests>
    <request><![CDATA[Please provide the declaration and initialization of the variable `gameLoop` in the class `de.gurkenlabs.litiengine.Game`.]]></request>
  </requests>
</response>
```
---Response.<init>---
Response created:
Unknown: The method `loop` returns the variable `gameLoop`. Without the initialization or assignment details of `gameLoop`, it's unclear whether it can be null. The possibility of `gameLoop` being uninitialized or set to null elsewhere in the program means `loop` could potentially return null. Further information on `gameLoop` is required.
---AdvancedNullAwayCodeFix.investigateMethodReturnNullability---
Could not determine the nullability and model did not ask for any method.
---ChatGPT.checkIfMethodIsReturningNullableOnCallSite---
Asking if the method is returning nullable on the call site: Game.loop()
---ChatGPT.ask---
Asking ChatGPT:
In the method below, is there a possibility that the method returns null at the given call site?

```java
@Nullable public static IGameLoop loop() {
    return gameLoop;
}
```

## Guidelines:
- The method may have multiple return paths; consider all return statements.
- If the method calls another method, do not assume its return value unless its full declaration is provided. Request its declaration if needed.
- The method may throw an exception instead of returning null. An exception path should not be considered a null return.
- Ensure you request the declarations of any methods whose return values directly or indirectly impact this method’s return value before making a conclusion.
- If the method returns a value that is determined by a parameter, evaluate based on the actual argument at the given call site.
- Analyze based only on the specific invocation provided. Do not generalize to all possible inputs.- If the return value is guaranteed to be non-null at the call site, the answer should be a definitive NO.
- Do not generalize based on all possible inputs—your answer must be based only on the given invocation.
- Focus only on the given call site, not all possible invocations.

### call site:
Game.loop()

Here are the method definitions and the call chain for this method, showing the sequence of calls from the method to its callers at each depth level:

Depth: 0
```java
class de.gurkenlabs.litiengine.Game {
@Nullable public static IGameLoop loop() {
    return gameLoop;
}
}
```
Depth: 1
```java
class de.gurkenlabs.litiengine.environment.GameWorld {
public void loadEnvironment(@Nullable final Environment env) {
    Lock lock = Game.loop().getLock();
    lock.lock();
    try {
      unloadEnvironment();
      this.environment = env;
      if (env != null) {
        this.addEnvironment(env);

        if (env.getGravity() == 0 && this.gravity() != 0) {
          env.setGravity(this.gravity());
        }

        env.load();
        for (final EnvironmentLoadedListener listener : this.loadedListeners) {
          listener.loaded(env);
        }

        // call map specific listeners
        String mapName = getMapName(env);
        if (mapName != null && this.environmentLoadedListeners.containsKey(mapName)) {

          // for the default camera we center the camera on the environment
          if (this.camera().getClass().equals(Camera.class)) {
            camera().setFocus(env.getCenter());
          }

          for (EnvironmentLoadedListener listener : this.environmentLoadedListeners.get(mapName)) {
            listener.loaded(env);
          }
        }
      }
    } finally {
      lock.unlock();
    }
}public void setCamera(@Nullable final ICamera cam) {
    if (this.camera() != null) {
      Game.loop().detach(camera);
    }

    camera = cam;

    if (cam != null && !Game.isInNoGUIMode()) {
      Game.loop().attach(cam);
      cam.updateFocus();
    }
}
}
```
```java
class de.gurkenlabs.litiengine.entities.behavior.EntityNavigator {
public EntityNavigator(final IMobileEntity entity, final PathFinder pathFinder) {
    this.cancelNavigationConditions = new CopyOnWriteArrayList<>();
    this.listeners = new CopyOnWriteArrayList<>();
    this.entity = entity;
    this.pathFinder = pathFinder;
    this.setAcceptableError(DEFAULT_ACCEPTABLE_ERROR);
    Game.loop().attach(this);
}
}
```
```java
class de.gurkenlabs.litiengine.GameWindow {
private static void initializeWindowEventListeners(Window window) {

    window.addWindowStateListener(
        e -> {
          if (e.getNewState() == Frame.ICONIFIED) {
            Game.loop().setTickRate(ICONIFIED_MAX_FPS);
          } else {
            Game.loop().setTickRate(Game.config().client().getMaxFps());
          }
        });

    window.addWindowFocusListener(
        new WindowFocusListener() {
          @Override
          public void windowLostFocus(WindowEvent e) {
            if (Game.config().graphics().reduceFramesWhenNotFocused()) {
              Game.loop().setTickRate(NONE_FOCUS_MAX_FPS);
            }
          }

          @Override
          public void windowGainedFocus(WindowEvent e) {
            Game.loop().setTickRate(Game.config().client().getMaxFps());
          }
        });

    window.addWindowListener(
        new WindowAdapter() {
          @Override
          public void windowClosing(final WindowEvent event) {
            Game.exit();
          }
        });
}
}
```
```java
class de.gurkenlabs.litiengine.gui.screens.ScreenManager {
public void display(@Nullable final Screen screen) {
    if (Game.hasStarted() && Game.time().since(this.lastScreenChange) < this.getChangeCooldown()) {
      log.log(
          Level.INFO,
          "Skipping displaying of screen {0} because screen changing is currently on cooldown.",
          screen != null ? screen.getName() : "");
      return;
    }

    final Screen previous = this.current();
    if (previous != null) {
      previous.suspend();
    }

    if (screen != null && !this.screens.contains(screen)) {
      this.screens.add(screen);
    }

    this.currentScreen = screen;
    if (!Game.isInNoGUIMode() && this.current() != null) {
      this.current().prepare();
    }

    this.lastScreenChange = Game.loop().getTicks();

    final ScreenChangedEvent event = new ScreenChangedEvent(this.current(), previous);
    for (final ScreenChangedListener listener : this.screenChangedListeners) {
      listener.changed(event);
    }
}
}
```
```java
class de.gurkenlabs.litiengine.abilities.effects.Effect {
@Override
  public void update() {

    for (final Iterator<EffectApplication> iterator = this.getActiveAppliances().iterator();
        iterator.hasNext(); ) {
      final EffectApplication appliance = iterator.next();
      // if the effect duration is reached
      if (this.hasEnded(appliance)) {

        iterator.remove();
        this.cease(appliance);
      }
    }

    // 4. unregister if all appliances are finished
    if (this.getActiveAppliances().isEmpty()) {
      Game.loop().detach(this);
    }
}public void apply(final Shape impactArea) {
    final List<ICombatEntity> affected = this.lookForAffectedEntities(impactArea);
    for (final ICombatEntity affectedEntity : affected) {
      this.apply(affectedEntity);
    }

    this.appliances.add(new EffectApplication(affected, impactArea));

    // if it is the first appliance -> register for update
    if (this.appliances.size() == 1) {
      Game.loop().attach(this);
    }
}
}
```
```java
class de.gurkenlabs.litiengine.GameTime {
public long toTicks(final int milliseconds) {
    return this.toTicks(milliseconds, Game.loop().getTickRate());
}public long since(final long tick) {
    return toMilliseconds(Game.loop().getTicks() - tick);
}public long now() {
    return Game.loop().getTicks();
}public long sinceGameStart() {
    return this.toMilliseconds(Game.loop().getTicks());
}@Override
  public void loaded(Environment environment) {
    environmentLoaded = Game.loop().getTicks();
}public long toMilliseconds(final long ticks) {
    return this.toMilliseconds(ticks, Game.loop().getTickRate());
}
}
```
```java
class de.gurkenlabs.litiengine.GameMetrics {
@Override
  public void render(final Graphics2D g) {
    this.updateMetrics();

    if (!Game.config().client().showGameMetrics()) {
      return;
    }

    this.currentOffsetY = 0;

    g.setColor(this.renderColor);

    // render client metrics
    this.drawTitle(g, "[client]");
    this.drawMetric(g, "fps       : " + this.getFramesPerSecond());
    this.drawMetric(g, "max fps   : " + this.maxFramesPerSecond);
    this.drawMetric(g, "updatables: " + Game.loop().getUpdatableCount());

    // render jvm metrics if debug is enabled
    if (Game.config().debug().isDebugEnabled()) {
      this.drawTitle(g, "[jvm]");
      this.drawMetric(g, "java      : " + this.javaVersion);
      this.drawMetric(g, "memory    : " + String.format("%-5.5s", this.usedMemory) + " MB");
      this.drawMetric(g, "threads   : " + Thread.activeCount());
    }

    // render rendering metrics
    if (!this.renderMetrics.isEmpty()) {
      this.drawTitle(g, "[update]");

      for (RenderMetrics metric : this.renderMetrics) {
        this.drawMetric(g, metric.toString());
      }

      this.renderMetrics.clear();
    }
}
}
```
```java
class de.gurkenlabs.litiengine.graphics.emitters.Emitter {
public void deactivate() {
    if (!this.activated) {
      return;
    }

    this.activated = false;
    this.getParticles().clear();
    this.aliveTime = 0;
    this.activationTick = 0;
    this.lastSpawn = 0;
    Game.loop().detach(this);
}public void activate() {
    if (this.activated) {
      return;
    }

    this.activated = true;
    this.activationTick = Game.time().now();
    Game.loop().attach(this);
}@Override
  public void update() {
    if (this.isPaused()) {
      return;
    }

    // clear particles if the effect time to life is reached
    if (this.isFinished()) {
      for (EmitterFinishedListener listener : this.finishedListeners) {
        listener.finished(this);
      }

      this.delete();
      return;
    }

    final float updateRatio = (float) this.data().getUpdateRate() / Game.loop().getTickRate();
    for (final Particle p : this.getParticles().stream().collect(Collectors.toList())) {
      if (this.particleCanBeRemoved(p)) {
        // remove dead particles
        this.particles.remove(p);
        continue;
      }

      p.update(this.getOrigin(), updateRatio);
    }

    this.aliveTime = Game.time().since(this.activationTick);
    if ((this.data().getSpawnRate() == 0
        || Game.time().since(this.lastSpawn) >= this.data().getSpawnRate())) {
      this.lastSpawn = Game.time().now();
      this.spawnParticle();
    }
}
}
```
```java
class de.gurkenlabs.litiengine.entities.behavior.IBehaviorController {
public default void attach() {
    Game.loop().attach(this);
}public default void detach() {
    Game.loop().detach(this);
}
}
```
```java
class de.gurkenlabs.litiengine.abilities.AbilityExecution {
AbilityExecution(final Ability ability) {
    this.appliedEffects = new CopyOnWriteArrayList<>();
    this.ability = ability;
    this.executionTicks = Game.time().now();
    this.impactArea = ability.calculateImpactArea();
    this.castLocation = ability.getExecutor().getCenter();
    Game.loop().attach(this);
}@Override
  public void update() {
    // if there a no effects to apply -> unregister this instance and we're done
    if (this.getAbility().getEffects().isEmpty()
        || this.getAbility().getEffects().size() == this.getAppliedEffects().size()) {
      Game.loop().detach(this);
      return;
    }

    // handle all effects from the ability that were not applied yet
    for (final Effect effect : this.getAbility().getEffects()) {
      // if the ability was not executed yet or the delay of the effect is not
      // yet reached
      if (this.getAppliedEffects().contains(effect)
          || Game.time().since(this.getExecutionTicks()) < effect.getDelay()) {
        continue;
      }

      effect.apply(this.getExecutionImpactArea());
      this.getAppliedEffects().add(effect);
    }
}
}
```
```java
class de.gurkenlabs.litiengine.GameWindow$3 {
@Override
          public void windowGainedFocus(WindowEvent e) {
            Game.loop().setTickRate(Game.config().client().getMaxFps());
}@Override
          public void windowLostFocus(WindowEvent e) {
            if (Game.config().graphics().reduceFramesWhenNotFocused()) {
              Game.loop().setTickRate(NONE_FOCUS_MAX_FPS);
            }
}
}
```
```java
class de.gurkenlabs.litiengine.environment.EntitySpawner {
protected void spawnNewEntities() {
    if (this.getSpawnMode() != SpawnMode.CUSTOMSPAWNPOINTS && this.getSpawnPoints().isEmpty()) {
      return;
    }

    switch (this.getSpawnMode()) {
      case ALLSPAWNPOINTS:
        for (int i = 0; i < this.getSpawnPoints().size(); i++) {
          final int index = i;
          Game.loop()
              .perform(
                  this.getSpawnDelay() + this.getSpawnDelay() * i,
                  () -> this.spawn(this.getSpawnPoints().get(index), this.getSpawnAmount()));
        }
        break;
      case ONERANDOMSPAWNPOINT:
        this.spawn(Game.random().choose(this.getSpawnPoints()), this.getSpawnAmount());
        break;
      case RANDOMSPAWNPOINTS:
        for (int i = 0; i < this.getSpawnAmount(); i++) {
          Game.loop()
              .perform(
                  this.getSpawnDelay() + this.getSpawnDelay() * i,
                  () -> this.spawn(Game.random().choose(this.getSpawnPoints()), 1));
        }
        break;
      case CUSTOMSPAWNPOINTS:
        List<Spawnpoint> spawnPoints =
            this.customSpawnpoints != null
                ? this.customSpawnpoints.apply(this)
                : this.getCustomSpawnpoints();

        int index = 0;
        for (Spawnpoint spawn : spawnPoints) {
          Game.loop()
              .perform(
                  this.getSpawnDelay() + this.getSpawnDelay() * index, () -> this.spawn(spawn, 1));
          index++;
        }
        break;
      default:
        break;
    }
}
}
```
```java
class de.gurkenlabs.litiengine.tweening.TweenEngine {
@Override
  public void start() {
    Game.loop().attach(this);
}@Override
  public void terminate() {
    Game.loop().detach(this);
}
}
```
```java
class de.gurkenlabs.litiengine.gui.SpeechBubble {
public void hide() {
    Game.world().environment().removeRenderable(this);
    Game.loop().detach(this);
    if (activeSpeechBubbles.get(this.getEntity()) != null
        && activeSpeechBubbles.remove(this.getEntity()).equals(this)) {
      activeSpeechBubbles.remove(this.getEntity());
    }

    for (SpeechBubbleListener listener : this.listeners) {
      listener.hidden();
    }
}private SpeechBubble(
      final IEntity entity,
      final String text,
      @Nullable SpeechBubbleAppearance appearance,
      @Nullable Font font) {
    if (appearance == null) {
      this.appearance = DEFAULT_APPEARANCE;
    } else {
      this.appearance = appearance;
    }

    final SpeechBubble active = activeSpeechBubbles.get(entity);
    if (active != null) {
      active.hide();
    }
    this.setFont(font);

    this.textBoxWidth = (float) (entity.getWidth() * 4);
    this.entity = entity;

    this.currentText = text;
    this.currentTextDisplayTime = DISPLAYTIME_MIN + text.length() * DISPLAYTIME_PER_LETTER;

    this.lastTextDisplay = Game.time().now();
    this.createBubbleImage();
    entity.getEnvironment().add(this, RenderType.UI);
    Game.loop().attach(this);
    activeSpeechBubbles.put(entity, this);
}
}
```
```java
class de.gurkenlabs.litiengine.entities.Prop {
private void updateAnimationController() {
    IEntityAnimationController<?> controller = this.createAnimationController();
    this.getControllers().addController(controller);
    if (Game.world().environment() != null && Game.world().environment().isLoaded()) {
      Game.loop().attach(controller);
    }
}
}
```
```java
class de.gurkenlabs.litiengine.graphics.FreeFlightCamera {
public FreeFlightCamera(final Point2D focus) {
    this.setFocus(focus);
    this.velocity = DEFAULT_SCROLL_PIXELS_PER_SECOND;
    this.scrollPadding = DEFAULT_SCROLL_PADDING;
    this.setClampToMap(true);

    Game.loop().attach(this);
}private void handleFreeFlightCamera() {
    if (Game.world().environment() == null || Game.world().environment().getMap() == null) {
      return;
    }

    final Point2D mouseLocation = Input.mouse().getLocation();

    final double scrollSpeed =
        this.getVelocity()
            / (double) Game.loop().getTickRate()
            * Game.config().input().getMouseSensitivity();

    double x = this.getFocus().getX();
    double y = this.getFocus().getY();

    double deltaX = 0;
    if (mouseLocation.getX() < this.getScrollPadding()) {
      deltaX -= scrollSpeed;
    } else if (Game.window().getResolution().getWidth() - mouseLocation.getX()
        < this.getScrollPadding()) {
      deltaX += scrollSpeed;
    }

    double deltaY = 0;
    if (mouseLocation.getY() < this.getScrollPadding()) {
      deltaY -= scrollSpeed;
    } else if (Game.window().getResolution().getHeight() - mouseLocation.getY()
        < this.getScrollPadding()) {
      deltaY += scrollSpeed;
    }

    x += deltaX;
    y += deltaY;

    this.setFocus(new Point2D.Double(x, y));
}
}
```
```java
class de.gurkenlabs.litiengine.environment.Environment {
private static void dispose(final Collection<? extends IEntity> entities) {
    for (final IEntity entity : entities) {
      if (entity instanceof IUpdateable) {
        Game.loop().detach((IUpdateable) entity);
      }

      entity.detachControllers();
    }
}private static void loadUpdatableOrEmitterEntity(IEntity entity) {
    if (entity instanceof Emitter) {
      final Emitter emitter = (Emitter) entity;
      if (emitter.isActivateOnInit()) {
        emitter.activate();
      }
    } else if (entity instanceof IUpdateable) {
      Game.loop().attach((IUpdateable) entity);
    }
}private void unload(final IEntity entity) {
    // 1. remove from physics engine
    if (entity instanceof ICollisionEntity) {
      Game.physics().remove((ICollisionEntity) entity);
    }

    // 2. unregister from update
    if (entity instanceof IUpdateable) {
      Game.loop().detach((IUpdateable) entity);
    }

    if (entity instanceof IMobileEntity) {
      this.removeGravity((IMobileEntity) entity);
    }

    // 3. detach all controllers
    entity.detachControllers();

    if (entity instanceof Emitter) {
      Emitter em = (Emitter) entity;
      em.deactivate();
    }

    if (this.loaded && (entity instanceof LightSource || entity instanceof StaticShadow)) {
      this.updateLighting(entity);
    }

    entity.removed(this);
}
}
```
```java
class de.gurkenlabs.litiengine.graphics.animation.Animation {
@Override
  public void update() {
    // do nothing if the animation is not playing or the current keyframe is not finished
    if (!this.isPlaying()
        || Game.time().since(this.lastFrameUpdate) < this.getCurrentKeyFrame().getDuration()) {
      return;
    }

    // if we are not looping and the last keyframe is finished, we terminate the animation
    if (!this.isLooping() && this.isLastKeyFrame()) {
      this.terminate();
      return;
    }

    // make sure, we stay inside the keyframe list
    final int newFrameIndex =
        (this.getKeyframes().indexOf(this.currentFrame) + 1) % this.getKeyframes().size();
    final KeyFrame previousFrame = this.currentFrame;
    this.currentFrame = this.getKeyframes().get(newFrameIndex);

    for (KeyFrameListener listener : this.listeners) {
      listener.currentFrameChanged(previousFrame, this.currentFrame);
    }

    this.lastFrameUpdate = Game.loop().getTicks();
}public void restart() {
    this.currentFrame = this.firstFrame;
    this.lastFrameUpdate = Game.loop().getTicks();
}
}
```
```java
class de.gurkenlabs.litiengine.physics.MovementController {
@Override
  public void attach() {
    Game.loop().attach(this);
}private void handleForces() {
    // clean up forces
    this.activeForces.forEach(
        x -> {
          if (x.hasEnded()) {
            this.activeForces.remove(x);
          }
        });

    if (this.activeForces.isEmpty()) {
      return;
    }

    // disable turn-on-move for force handling
    boolean turn = this.getEntity().turnOnMove();
    this.getEntity().setTurnOnMove(false);
    try {
      double deltaX = 0;
      double deltaY = 0;
      for (final Force force : this.activeForces) {
        if (force.cancelOnReached() && force.hasReached(this.getEntity())) {
          force.end();
          continue;
        }

        final Point2D collisionBoxCenter = this.getEntity().getCollisionBoxCenter();
        final double angle =
            GeometricUtilities.calcRotationAngleInDegrees(collisionBoxCenter, force.getLocation());
        final double strength =
            Game.loop().getDeltaTime() * 0.001f * force.getStrength() * Game.loop().getTimeScale();
        deltaX += GeometricUtilities.getDeltaX(angle, strength);
        deltaY += GeometricUtilities.getDeltaY(angle, strength);
      }

      final Point2D target =
          new Point2D.Double(this.getEntity().getX() + deltaX, this.getEntity().getY() + deltaY);
      final boolean success = Game.physics().move(this.getEntity(), target);
      if (!success) {
        for (final Force force : this.activeForces) {
          if (force.cancelOnCollision()) {
            force.end();
          }
        }
      }
    } finally {
      this.getEntity().setTurnOnMove(turn);
    }
}@Override
  public void detach() {
    Game.loop().detach(this);
}public void handleMovement() {
    if (!this.isMovementAllowed()) {
      this.velocity = 0;
      return;
    }

    // max distance an entity can travel within one tick
    final double maxPixelsPerTick = this.getEntity().getTickVelocity();
    final double deltaTime = Game.loop().getDeltaTime() * Game.loop().getTimeScale();

    final double acceleration =
        this.getEntity().getAcceleration() == 0
            ? maxPixelsPerTick
            : deltaTime / this.getEntity().getAcceleration() * maxPixelsPerTick;
    final double deceleration =
        this.getEntity().getDeceleration() == 0
            ? this.getVelocity()
            : deltaTime / this.getEntity().getDeceleration() * maxPixelsPerTick;

    double dx = this.getDx();
    double dy = this.getDy();
    this.setDx(0);
    this.setDy(0);

    final double deltaVelocity =
        Math.min(Math.sqrt(Math.pow(dx, 2) + Math.pow(dy, 2)), acceleration);
    if (deltaVelocity != 0) {
      double newVelocity = this.getVelocity() + deltaVelocity;
      this.setVelocity(newVelocity);
    } else {
      final double newVelocity = Math.max(0, this.getVelocity() - deceleration);
      this.setVelocity(newVelocity);
      dx = GeometricUtilities.getDeltaX(this.moveAngle);
      dy = GeometricUtilities.getDeltaY(this.moveAngle);
    }

    if (this.getVelocity() == 0) {
      this.moveAngle = 0;
      return;
    }

    // actually move entity
    this.moveEntity(dx, dy);
}
}
```
```java
class de.gurkenlabs.litiengine.graphics.animation.AnimationController {
public void detach() {
    Game.loop().detach(this);
}public void attach() {
    Game.loop().attach(this);
}
}
```
```java
class de.gurkenlabs.litiengine.graphics.Camera {
@Override
  public void setZoom(final float targetZoom, final int delay) {
    if (delay == 0) {

      this.zoom = targetZoom;
      this.targetZoom = 0;
      this.zoomDelay = 0;
      this.zoomTick = 0;
      this.zoomStep = 0;

      final ZoomChangedEvent event = new ZoomChangedEvent(this, targetZoom);
      for (final ZoomChangedListener listener : this.zoomListeners) {
        listener.zoomChanged(event);
      }
    } else {
      this.zoomTick = Game.time().now();
      this.targetZoom = targetZoom;
      this.zoomDelay = delay;

      final double tickduration = 1000 / (double) Game.loop().getTickRate();
      final double tickAmount = delay / tickduration;
      final float totalDelta = this.targetZoom - this.zoom;
      this.zoomStep = tickAmount > 0 ? (float) (totalDelta / tickAmount) : totalDelta;
    }
}
}
```
```java
class de.gurkenlabs.litiengine.Game {
public static synchronized void init(String... args) {
    if (initialized) {
      log().log(Level.INFO, "The game has already been initialized.");
      return;
    }

    log.init();
    handleCommandLineArguments(args);

    config().load();
    Locale.setDefault(new Locale(config().client().getCountry(), config().client().getLanguage()));

    gameLoop = new GameLoop("Main Update Loop", config().client().getMaxFps());
    loop().attach(physics());
    loop().attach(world());

    // setup default exception handling for render and update loop
    setUncaughtExceptionHandler(
        new DefaultUncaughtExceptionHandler(config().client().exitOnError()));

    screenManager = new ScreenManager();
    gameWindow = new GameWindow();

    // initialize  the game window
    window().init();
    world.setCamera(new Camera());

    for (GameListener listener : gameListeners) {
      listener.initialized(args);
    }

    if (!isInNoGUIMode()) {
      window().getRenderComponent().onRendered(g -> metrics().render(g));

      graphics()
          .addEntityRenderedListener(
              e -> DebugRenderer.renderEntityDebugInfo(e.getGraphics(), e.getEntity()));

      window().getRenderComponent().onFpsChanged(fps -> metrics().setFramesPerSecond(fps));
      window()
          .setIcons(
              Arrays.asList(
                  Resources.images().get("liti-logo-x16.png"),
                  Resources.images().get("liti-logo-x20.png"),
                  Resources.images().get("liti-logo-x32.png"),
                  Resources.images().get("liti-logo-x48.png")));

      Input.keyboard()
          .onKeyTyped(
              KeyEvent.VK_PRINTSCREEN,
              key -> {
                // don't take a screenshot if a modifier is active
                if (key.getModifiers() != 0) {
                  return;
                }

                window().getRenderComponent().takeScreenshot();
              });
    }

    Runtime.getRuntime().addShutdownHook(new Thread(Game::terminate, "Shutdown"));

    initialized = true;
}
}
```
```java
class de.gurkenlabs.litiengine.entities.Creature {
protected void updateAnimationController() {
    IEntityAnimationController<?> controller = this.createAnimationController();
    this.getControllers().addController(controller);
    if (Game.world().environment() != null && Game.world().environment().isLoaded()) {
      Game.loop().attach(controller);
    }
}@Override
  public float getTickVelocity() {
    // pixels per ms multiplied by the passed ms
    // ensure that entities don't travel too far in case of lag
    return Math.min(Game.loop().getDeltaTime(), GameLoop.TICK_DELTATIME_LAG)
        * 0.001F
        * this.getVelocity().get()
        * Game.loop().getTimeScale();
}
}
```
Depth: 2
```java
class de.gurkenlabs.litiengine.environment.GameWorld {
public void clear() {
    this.unloadEnvironment();
    this.environments.clear();
    this.setCamera(null);
    Game.physics().clear();

    this.environmentListeners.clear();
    this.environmentLoadedListeners.clear();
    this.environmentUnloadedListeners.clear();

    this.listeners.clear();
    this.loadedListeners.clear();
    this.unloadedListeners.clear();
}@Nullable
  public Environment loadEnvironment(IMap map) {
    Environment env = this.getEnvironment(map);
    this.loadEnvironment(env);
    return env;
}@Nullable
  public Environment loadEnvironment(String mapName) {
    Environment env = this.getEnvironment(mapName);
    this.loadEnvironment(env);
    return env;
}
}
```
```java
class de.gurkenlabs.litiengine.GameWindow {
GameWindow() {
    this.hostControl = new JFrame();

    this.resolutionChangedListeners = new CopyOnWriteArrayList<>();

    this.renderCanvas = new RenderComponent(Game.config().graphics().getResolution());
    this.cursor = new MouseCursor();
    if (!Game.isInNoGUIMode()) {
      this.hostControl.setBackground(Color.BLACK);
      this.hostControl.add(this.renderCanvas);

      this.initializeEventListeners();

      this.hostControl.setTitle(Game.info().getTitle());
      this.hostControl.setDefaultCloseOperation(WindowConstants.DO_NOTHING_ON_CLOSE);
      initializeWindowEventListeners(this.hostControl);
    }
}
}
```
```java
class de.gurkenlabs.litiengine.GameTime {
public long sinceEnvironmentLoad() {
    return this.since(this.environmentLoaded);
}public long since(final long tick) {
    return toMilliseconds(Game.loop().getTicks() - tick);
}public long sinceGameStart() {
    return this.toMilliseconds(Game.loop().getTicks());
}
}
```
```java
class de.gurkenlabs.litiengine.abilities.effects.Effect {
protected void cease(final EffectApplication appliance) {
    // 1. cease the effect for all affected entities
    for (final ICombatEntity entity : appliance.getAffectedEntities()) {
      this.cease(entity);
    }

    // 2. apply follow up effects
    this.getFollowUpEffects().forEach(followUp -> followUp.apply(appliance.getImpactArea()));
}protected boolean hasEnded(final EffectApplication appliance) {
    final long effectDuration = Game.time().since(appliance.getAppliedTicks());
    return effectDuration > this.getDuration();
}
}
```
```java
class de.gurkenlabs.litiengine.abilities.effects.EffectApplication {
protected EffectApplication(final List<ICombatEntity> affectedEntities, final Shape impactArea) {
    this.applied = Game.time().now();
    this.affectedEntities = affectedEntities;
    this.impactArea = impactArea;
}
}
```
```java
class de.gurkenlabs.litiengine.entities.CombatEntity {
@Override
  public boolean wasHit(int timeSpan) {
    return Game.time().since(this.lastHit) < timeSpan;
}@Override
  public void hit(final int damage, @Nullable final Ability ability) {
    if (this.isDead()) {
      return;
    }

    if (!this.isIndestructible()) {
      this.getHitPoints().modifyBaseValue(new AttributeModifier<>(Modification.SUBTRACT, damage));
    }

    final EntityHitEvent event = new EntityHitEvent(this, ability, damage, this.isDead());

    for (final CombatEntityListener listener : this.listeners) {
      listener.hit(event);
    }

    for (final CombatEntityHitListener listener : this.hitListeners) {
      listener.hit(event);
    }

    if (this.isDead()) {
      this.fireDeathEvent();
      this.setCollision(false);
    }

    this.lastHit = Game.time().now();
}
}
```
```java
class de.gurkenlabs.litiengine.graphics.ImageEffect {
protected ImageEffect(final int ttl, final String name) {
    this.ttl = ttl;
    this.name = name;
    this.aliveTick = Game.time().now();
}@Override
  public long getAliveTime() {
    return Game.time().since(this.aliveTick);
}
}
```
```java
class de.gurkenlabs.litiengine.abilities.AbilityExecution {
AbilityExecution(final Ability ability) {
    this.appliedEffects = new CopyOnWriteArrayList<>();
    this.ability = ability;
    this.executionTicks = Game.time().now();
    this.impactArea = ability.calculateImpactArea();
    this.castLocation = ability.getExecutor().getCenter();
    Game.loop().attach(this);
}@Override
  public void update() {
    // if there a no effects to apply -> unregister this instance and we're done
    if (this.getAbility().getEffects().isEmpty()
        || this.getAbility().getEffects().size() == this.getAppliedEffects().size()) {
      Game.loop().detach(this);
      return;
    }

    // handle all effects from the ability that were not applied yet
    for (final Effect effect : this.getAbility().getEffects()) {
      // if the ability was not executed yet or the delay of the effect is not
      // yet reached
      if (this.getAppliedEffects().contains(effect)
          || Game.time().since(this.getExecutionTicks()) < effect.getDelay()) {
        continue;
      }

      effect.apply(this.getExecutionImpactArea());
      this.getAppliedEffects().add(effect);
    }
}
}
```
```java
class de.gurkenlabs.litiengine.tweening.TweenEngine {
@Override
  public void update() {
    for (final Tweenable target : this.getTweens().keySet()) {
      for (final Tween tween : this.getTweens().get(target).values()) {
        if (tween.hasStopped()) {
          continue;
        }
        final long elapsed = Game.time().since(tween.getStartTime());
        if (elapsed >= tween.getDuration()) {
          tween.stop();
          continue;
        }
        final float[] currentValues = new float[tween.getTargetValues().length];
        for (int i = 0; i < tween.getTargetValues().length; i++) {
          currentValues[i] =
              tween.getStartValues()[i]
                  + tween.getEquation().compute(elapsed / (float) tween.getDuration())
                      * (tween.getTargetValues()[i] - tween.getStartValues()[i]);
        }
        tween.getTarget().setTweenValues(tween.getType(), currentValues);
      }
    }
}
}
```
```java
class de.gurkenlabs.litiengine.gui.SpeechBubble {
public static SpeechBubble create(
      final IEntity entity, final String text, SpeechBubbleAppearance appearance, Font font) {
    return new SpeechBubble(entity, text, appearance, font);
}public static SpeechBubble create(final IEntity entity, final Font font, final String text) {
    SpeechBubbleAppearance app =
        new SpeechBubbleAppearance(
            DEFAULT_APPEARANCE.getForeColor(),
            DEFAULT_APPEARANCE.getBackgroundColor1(),
            DEFAULT_APPEARANCE.getBorderColor(),
            DEFAULT_APPEARANCE.getPadding());
    return new SpeechBubble(entity, text, app, font);
}public static SpeechBubble create(final IEntity entity, final String text) {
    return new SpeechBubble(entity, text, null, GuiProperties.getDefaultFont());
}@Override
  public void update() {
    if (this.currentText == null) {
      this.hide();
      return;
    }

    this.entityCenter = Game.world().camera().getViewportLocation(this.getEntity().getCenter());

    // old text was displayed long enough
    if (this.lastTextDisplay != 0
        && Game.time().since(this.lastTextDisplay) > this.currentTextDisplayTime) {
      this.currentText = null;
      this.lastTextDisplay = 0;
      return;
    }

    // display new text
    if (this.textIndex < this.currentText.length()
        && Game.time().since(this.lastCharPoll) > LETTER_WRITE_DELAY) {
      this.textIndex++;
      this.lastCharPoll = Game.time().now();
      if (this.typeSound != null) {
        Game.audio().playSound(this.typeSound, this.getEntity());
      }
    }

    // continue displaying currently displayed text
}private SpeechBubble(
      final IEntity entity,
      final String text,
      final Sound typeSound,
      SpeechBubbleAppearance appearance,
      Font font) {
    this(entity, text, appearance, font);
    this.typeSound = typeSound;
}private SpeechBubble(
      final IEntity entity,
      final String text,
      @Nullable SpeechBubbleAppearance appearance,
      @Nullable Font font) {
    if (appearance == null) {
      this.appearance = DEFAULT_APPEARANCE;
    } else {
      this.appearance = appearance;
    }

    final SpeechBubble active = activeSpeechBubbles.get(entity);
    if (active != null) {
      active.hide();
    }
    this.setFont(font);

    this.textBoxWidth = (float) (entity.getWidth() * 4);
    this.entity = entity;

    this.currentText = text;
    this.currentTextDisplayTime = DISPLAYTIME_MIN + text.length() * DISPLAYTIME_PER_LETTER;

    this.lastTextDisplay = Game.time().now();
    this.createBubbleImage();
    entity.getEnvironment().add(this, RenderType.UI);
    Game.loop().attach(this);
    activeSpeechBubbles.put(entity, this);
}
}
```
```java
class de.gurkenlabs.litiengine.gui.TextFieldComponent {
@Override
  public void render(final Graphics2D g) {
    super.render(g);
    g.setFont(this.getFont());
    final FontMetrics fm = g.getFontMetrics();

    if (this.isSelected() && Game.time().since(this.lastToggled) > this.flickerDelay) {
      this.cursorVisible = !this.cursorVisible;
      this.lastToggled = Game.time().now();
    }
    if (this.isSelected() && this.cursorVisible) {
      final Rectangle2D cursor =
          new Rectangle2D.Double(
              this.getX() + this.getTextX() + fm.stringWidth(this.getTextToRender(g)),
              this.getY() + this.getTextY(),
              this.getFont().getSize2D() * 3 / 5,
              this.getFont().getSize2D() * 1 / 5);
      g.setColor(this.getAppearance().getForeColor());
      g.fill(cursor);
    }
}
}
```
```java
class de.gurkenlabs.litiengine.entities.Prop {
public Prop(
      final Point2D location, @Nullable final String spritesheetName, final Material material) {
    super();
    this.rotation = Rotation.NONE;
    this.spritesheetName = spritesheetName;
    this.material = material;
    this.setLocation(location);
    this.updateAnimationController();
}public void setSpritesheetName(@Nullable final String spriteName) {
    this.spritesheetName = spriteName;
    this.updateAnimationController();
}
}
```
```java
class de.gurkenlabs.litiengine.tweening.Tween {
public Tween begin() {
    this.started = Game.time().now();
    this.stopped = false;
    return this;
}
}
```
```java
class de.gurkenlabs.litiengine.graphics.emitters.particles.Particle {
public void update(final Point2D emitterOrigin, final float updateRatio) {
    if (this.aliveTick == 0) {
      this.aliveTick = Game.time().now();
    }

    this.aliveTime = Game.time().since(this.aliveTick);
    if (this.timeToLiveReached()) {
      return;
    }

    if (this.colliding) {
      return;
    }

    if (this.getDeltaWidth() != 0) {
      this.width += this.getDeltaWidth() * updateRatio;
    }

    if (this.getDeltaHeight() != 0) {
      this.height += this.getDeltaHeight() * updateRatio;
    }

    if (this.getDeltaAngle() != 0) {
      this.angle += this.getDeltaAngle() * updateRatio;
    }

    // test for ray cast collision
    final float targetX = this.x + this.getVelocityX() * updateRatio;
    final float targetY = this.y + this.getVelocityY() * updateRatio;

    if (targetX == this.x && targetY == this.y) {
      return;
    }

    if (this.checkForCollision(emitterOrigin, targetX, targetY)) {
      return;
    }

    if (this.getVelocityX() != 0) {
      this.x = targetX;
    }

    if (this.getVelocityY() != 0) {
      this.y = targetY;
    }

    if (this.getAccelerationX() != 0) {
      this.velocityX += this.getAccelerationX() * updateRatio;
    }

    if (this.getAccelerationY() != 0) {
      this.velocityY += this.getAccelerationY() * updateRatio;
    }
}
}
```
```java
class de.gurkenlabs.litiengine.graphics.animation.Animation {
@Override
  public void start() {
    this.playing = true;
    if (this.getKeyframes().isEmpty()) {
      return;
    }

    this.restart();
}@Override
  public void update() {
    // do nothing if the animation is not playing or the current keyframe is not finished
    if (!this.isPlaying()
        || Game.time().since(this.lastFrameUpdate) < this.getCurrentKeyFrame().getDuration()) {
      return;
    }

    // if we are not looping and the last keyframe is finished, we terminate the animation
    if (!this.isLooping() && this.isLastKeyFrame()) {
      this.terminate();
      return;
    }

    // make sure, we stay inside the keyframe list
    final int newFrameIndex =
        (this.getKeyframes().indexOf(this.currentFrame) + 1) % this.getKeyframes().size();
    final KeyFrame previousFrame = this.currentFrame;
    this.currentFrame = this.getKeyframes().get(newFrameIndex);

    for (KeyFrameListener listener : this.listeners) {
      listener.currentFrameChanged(previousFrame, this.currentFrame);
    }

    this.lastFrameUpdate = Game.loop().getTicks();
}
}
```
```java
class de.gurkenlabs.litiengine.graphics.animation.AnimationController {
@Override
  public void update() {
    for (final Animation animation : this.getAll()) {
      animation.update();
    }

    if (this.getCurrent() != null && this.getCurrent().isPaused()) {
      return;
    }

    final boolean playbackFinished = this.getCurrent() != null && !this.getCurrent().isPlaying();
    if (playbackFinished) {
      for (final AnimationListener listener : this.listeners) {
        listener.finished(this.getCurrent());
      }
    }

    if (this.getCurrent() == null || playbackFinished) {
      if (this.getDefault() != null) {
        this.play(this.getDefault().getName());
      } else {
        this.currentAnimation = null;
      }
    }
}
}
```
```java
class de.gurkenlabs.litiengine.graphics.RenderComponent {
private void handleFade() {
    if (this.fadeOutStart != -1) {
      final long timePassed = Game.time().since(this.fadeOutStart);
      this.currentAlpha = MathUtilities.clamp(1 - timePassed / (float) this.fadeOutTime, 0, 1);
      if (this.currentAlpha == 0f) {
        this.fadeOutStart = -1;
        this.fadeOutTime = -1;
      }

      return;
    }

    if (this.fadeInStart != -1) {
      final long timePassed = Game.time().since(this.fadeInStart);
      this.currentAlpha = MathUtilities.clamp(timePassed / (float) this.fadeInTime, 0, 1);
      if (this.currentAlpha == 1f) {
        this.fadeInStart = -1;
        this.fadeInTime = -1;
        this.currentAlpha = Float.NaN;
      }
    }
}public void fadeOut(final int ms) {
    this.fadeInStart = -1;
    this.fadeInTime = -1;
    this.fadeOutStart = Game.time().now();
    this.fadeOutTime = ms;
}public void fadeIn(final int ms) {
    this.fadeOutStart = -1;
    this.fadeOutTime = -1;
    this.fadeInStart = Game.time().now();
    this.fadeInTime = ms;
}
}
```
```java
class de.gurkenlabs.litiengine.entities.Trigger {
private boolean activate(final IEntity activator, final int tar) {
    if (!this.isLoaded()
        || this.isOneTimeTrigger && this.isActivated
        || this.getActivationType() == TriggerActivation.COLLISION
            && activator != null
            && this.collisionActivated.contains(activator)) {
      return false;
    }

    if (this.getCooldown() > 0 && Game.time().since(this.lastActivation) < this.getCooldown()) {
      return false;
    }

    List<Integer> triggerTargets = this.getTargets(tar);

    final TriggerEvent te = new TriggerEvent(this, activator, triggerTargets);

    if (!this.checkActivationPredicates(te)) {
      return false;
    }

    this.isActivated = true;
    if (activator != null) {
      this.collisionActivated.add(activator);
    }

    // if we actually have a trigger target, we send the message to the target
    for (final int target : triggerTargets) {
      final IEntity entity = this.getEnvironment().get(target);
      if (entity == null) {
        log.log(
            Level.WARNING,
            "trigger [{0}] was activated, but the trigger target [{1}] could not be found on the environment",
            new Object[] {this, target});
        continue;
      }

      entity.sendMessage(this, this.message);
    }

    // also send the trigger event to all registered consumers
    for (final TriggerActivatedListener listener : this.activatedListeners) {
      listener.activated(te);
    }

    if (this.isOneTimeTrigger) {
      this.getEnvironment().remove(this);
    }

    this.lastActivation = Game.time().now();
    return true;
}
}
```
```java
class de.gurkenlabs.litiengine.graphics.Camera {
private boolean isShakeEffectActive() {
    return this.getShakeTick() != 0
        && Game.time().since(this.getShakeTick()) < this.getShakeDuration();
}@Override
  public void update() {
    if (Game.world().camera() != null && !Game.world().camera().equals(this)) {
      return;
    }

    if (this.targetZoom > 0) {
      if (Game.time().since(this.zoomTick) >= this.zoomDelay) {
        this.zoom = this.targetZoom;
        this.targetZoom = 0;
        this.zoomDelay = 0;
        this.zoomTick = 0;
        this.zoomStep = 0;
      } else {
        this.zoom += this.zoomStep;
      }

      final ZoomChangedEvent event = new ZoomChangedEvent(this, this.getZoom());
      for (final ZoomChangedListener listener : this.zoomListeners) {
        listener.zoomChanged(event);
      }
    }

    if (this.panTime > 0) {
      if (--this.panTime <= 0) {
        this.setFocus(this.targetFocus);
        this.targetFocus = null;
      } else {
        double diff = this.panTime / (this.panTime + 1.0);
        this.focus =
            new Point2D.Double(
                this.focus.getX() * diff + this.targetFocus.getX() * (1.0 - diff),
                this.focus.getY() * diff + this.targetFocus.getY() * (1.0 - diff));
      }
    }

    if (!this.isShakeEffectActive()) {
      this.shakeOffsetX = 0;
      this.shakeOffsetY = 0;
      return;
    }

    if (Game.time().since(this.lastShake) > this.shakeDelay) {
      this.shakeOffsetX = this.getShakeIntensity() * ThreadLocalRandom.current().nextGaussian();
      this.shakeOffsetY = this.getShakeIntensity() * ThreadLocalRandom.current().nextGaussian();
      this.lastShake = Game.time().now();
    }
}@Override
  public void setZoom(final float targetZoom, final int delay) {
    if (delay == 0) {

      this.zoom = targetZoom;
      this.targetZoom = 0;
      this.zoomDelay = 0;
      this.zoomTick = 0;
      this.zoomStep = 0;

      final ZoomChangedEvent event = new ZoomChangedEvent(this, targetZoom);
      for (final ZoomChangedListener listener : this.zoomListeners) {
        listener.zoomChanged(event);
      }
    } else {
      this.zoomTick = Game.time().now();
      this.targetZoom = targetZoom;
      this.zoomDelay = delay;

      final double tickduration = 1000 / (double) Game.loop().getTickRate();
      final double tickAmount = delay / tickduration;
      final float totalDelta = this.targetZoom - this.zoom;
      this.zoomStep = tickAmount > 0 ? (float) (totalDelta / tickAmount) : totalDelta;
    }
}@Override
  public void shake(final double intensity, final int delay, final int shakeDuration) {
    this.shakeTick = Game.time().now();
    this.shakeDelay = delay;
    this.shakeIntensity = intensity;
    this.shakeDuration = shakeDuration;
}
}
```
```java
class de.gurkenlabs.litiengine.entities.Creature {
public void setSpritesheetName(String spritesheetName) {
    if (this.spritesheetName != null && this.spritesheetName.equals(spritesheetName)) {
      return;
    }

    this.spritesheetName = spritesheetName;
    this.updateAnimationController();
}public boolean isIdle() {
    return Game.time().since(this.lastMoved) > IDLE_DELAY;
}@Override
  public void setLocation(final Point2D position) {
    if (this.isDead() || position == null) {
      return;
    }

    final Point2D oldLocation = this.getLocation();
    super.setLocation(position);

    if (Game.hasStarted() && this.isLoaded()) {
      this.lastMoved = Game.time().now();
      this.fireMovedEvent(
          new EntityMovedEvent(
              this, this.getX() - oldLocation.getX(), this.getY() - oldLocation.getY()));
    }
}
}
```
```java
class de.gurkenlabs.litiengine.gui.screens.ScreenManager {
public void display(final String screenName) {
    if (this.current() != null && this.current().getName().equalsIgnoreCase(screenName)) {
      log.log(
          Level.INFO,
          "Skipping displaying of screen {0} because it is already the current screen.",
          screenName);
      return;
    }

    if (this.screens.stream()
        .noneMatch(element -> element.getName().equalsIgnoreCase(screenName))) {
      log.log(
          Level.WARNING,
          "Could not display the screen {0} because there is no screen with the specified name.",
          screenName);
      return;
    }

    Screen screen = this.get(screenName);
    if (screen == null) {
      return;
    }

    this.display(screen);
}public void add(final Screen screen) {
    screen.setWidth(Game.window().getWidth());
    screen.setHeight(Game.window().getHeight());
    this.screens.add(screen);

    if (this.current() == null) {
      this.display(screen);
    }
}public void remove(Screen screen) {
    this.screens.remove(screen);
    if (this.current() == screen) {
      if (!this.screens.isEmpty()) {
        this.display(this.screens.get(0));
      } else {
        this.display((Screen) null);
      }
    }
}public void display(@Nullable final Screen screen) {
    if (Game.hasStarted() && Game.time().since(this.lastScreenChange) < this.getChangeCooldown()) {
      log.log(
          Level.INFO,
          "Skipping displaying of screen {0} because screen changing is currently on cooldown.",
          screen != null ? screen.getName() : "");
      return;
    }

    final Screen previous = this.current();
    if (previous != null) {
      previous.suspend();
    }

    if (screen != null && !this.screens.contains(screen)) {
      this.screens.add(screen);
    }

    this.currentScreen = screen;
    if (!Game.isInNoGUIMode() && this.current() != null) {
      this.current().prepare();
    }

    this.lastScreenChange = Game.loop().getTicks();

    final ScreenChangedEvent event = new ScreenChangedEvent(this.current(), previous);
    for (final ScreenChangedListener listener : this.screenChangedListeners) {
      listener.changed(event);
    }
}
}
```
```java
class de.gurkenlabs.litiengine.abilities.Ability {
public boolean isOnCooldown() {
    return (this.getCurrentExecution() != null
        && this.getCurrentExecution().getExecutionTicks() > 0
        && Game.time().since(this.getCurrentExecution().getExecutionTicks())
            < this.getAttributes().cooldown().get());
}public boolean isActive() {
    return this.getCurrentExecution() != null
        && Game.time().since(this.getCurrentExecution().getExecutionTicks())
            < this.getAttributes().duration().get();
}@Nullable
  public AbilityExecution cast() {
    if (!this.canCast()) {
      return null;
    }
    this.currentExecution = new AbilityExecution(this);

    for (final AbilityCastListener listener : this.abilityCastListeners) {
      listener.abilityCast(this.currentExecution);
    }

    return this.getCurrentExecution();
}public float getRemainingCooldownInSeconds() {
    if (this.getCurrentExecution() == null
        || this.getExecutor() == null
        || this.getExecutor().isDead()) {
      return 0;
    }

    // calculate cooldown in seconds
    return (float)
        (!this.canCast()
            ? (this.getAttributes().cooldown().get()
                    - Game.time().since(this.getCurrentExecution().getExecutionTicks()))
                * 0.001
            : 0);
}
}
```
```java
class de.gurkenlabs.litiengine.entities.EntityHitEvent {
EntityHitEvent(
      final ICombatEntity hitEntity,
      @Nullable final Ability ability,
      final int damage,
      final boolean kill) {
    super(hitEntity);
    this.executor = ability != null ? ability.getExecutor() : null;
    this.hitEntity = hitEntity;
    this.ability = ability;
    this.damage = damage;
    this.kill = kill;
    this.time = Game.time().now();
}
}
```
```java
class de.gurkenlabs.litiengine.graphics.emitters.Emitter {
public void delete() {
    this.deactivate();
    if (Game.world().environment() != null) {
      Game.world().environment().remove(this);
    }
}public void activate() {
    if (this.activated) {
      return;
    }

    this.activated = true;
    this.activationTick = Game.time().now();
    Game.loop().attach(this);
}@Override
  public void update() {
    if (this.isPaused()) {
      return;
    }

    // clear particles if the effect time to life is reached
    if (this.isFinished()) {
      for (EmitterFinishedListener listener : this.finishedListeners) {
        listener.finished(this);
      }

      this.delete();
      return;
    }

    final float updateRatio = (float) this.data().getUpdateRate() / Game.loop().getTickRate();
    for (final Particle p : this.getParticles().stream().collect(Collectors.toList())) {
      if (this.particleCanBeRemoved(p)) {
        // remove dead particles
        this.particles.remove(p);
        continue;
      }

      p.update(this.getOrigin(), updateRatio);
    }

    this.aliveTime = Game.time().since(this.activationTick);
    if ((this.data().getSpawnRate() == 0
        || Game.time().since(this.lastSpawn) >= this.data().getSpawnRate())) {
      this.lastSpawn = Game.time().now();
      this.spawnParticle();
    }
}
}
```
```java
class de.gurkenlabs.litiengine.GameLoop {
@Override
  public int perform(int delay, Runnable action) {
    final long d = Game.time().toTicks(delay);

    TimedAction a = new TimedAction(this.getTicks() + d, action);
    this.actions.add(a);

    return a.getId();
}
}
```
```java
class de.gurkenlabs.litiengine.environment.EntitySpawner {
protected boolean shouldSpawn() {
    return this.lastSpawnWave == 0
        || Game.time().since(this.lastSpawnWave) >= this.getSpawnInterval();
}@Override
  public void update() {
    if (!this.shouldSpawn()) {
      return;
    }

    this.spawnNewEntities();
    this.lastSpawnWave = Game.time().now();
}
}
```
```java
class de.gurkenlabs.litiengine.graphics.FreeFlightCamera {
@Override
  public void update() {
    this.handleFreeFlightCamera();
}public FreeFlightCamera(double x, double y) {
    this(new Point2D.Double(x, y));
}
}
```
```java
class de.gurkenlabs.litiengine.environment.Environment {
public void unload() {
    if (!this.loaded) {
      return;
    }

    // unregister all updatable entities from the current environment
    for (final IEntity entity : this.allEntities.values()) {
      this.unload(entity);
    }

    this.loaded = false;
    this.fireEvent(l -> l.unloaded(this));
}private static void loadUpdatableOrEmitterEntity(IEntity entity) {
    if (entity instanceof Emitter) {
      final Emitter emitter = (Emitter) entity;
      if (emitter.isActivateOnInit()) {
        emitter.activate();
      }
    } else if (entity instanceof IUpdateable) {
      Game.loop().attach((IUpdateable) entity);
    }
}public void clear() {
    Game.physics().clear();

    this.combatEntities.clear();
    this.mobileEntities.clear();
    this.gravityForces.clear();
    this.layerEntities.clear();
    this.entitiesByTag.clear();
    this.allEntities.clear();

    for (RenderType renderType : RenderType.values()) {
      this.miscEntities.get(renderType).clear();
      this.renderListeners.get(renderType).clear();
      this.renderables.get(renderType).clear();
    }

    dispose(this.allEntities.values());
    dispose(this.triggers);
    this.emitters.clear();
    this.colliders.clear();
    this.props.clear();
    this.creatures.clear();
    this.staticShadows.clear();
    this.combatEntities.clear();
    this.mobileEntities.clear();
    this.lightSources.clear();
    this.spawnPoints.clear();
    this.soundSources.clear();
    this.mapAreas.clear();
    this.triggers.clear();

    this.ambientLight = null;
    this.staticShadowLayer = null;

    for (Map<Integer, IEntity> type : this.miscEntities.values()) {
      type.clear();
    }

    this.initialized = false;

    this.fireEvent(l -> l.cleared(this));
}private void load(final IEntity entity) {
    // an entity can only exist on one environment at a time, so remove it from the current one
    if (entity.getEnvironment() != null) {
      entity.getEnvironment().remove(entity);
    }

    // 1. add to physics engine
    loadPhysicsEntity(entity);

    // 2. register for update or activate
    loadUpdatableOrEmitterEntity(entity);

    // 3. if a gravity is defined, add a gravity force to the entity
    if (entity instanceof IMobileEntity && this.getGravity() != 0) {
      this.addGravityForce((IMobileEntity) entity);
    }

    // 4. attach all controllers
    entity.attachControllers();

    if (this.loaded && (entity instanceof LightSource || entity instanceof StaticShadow)) {
      this.updateLighting(entity);
    }

    entity.loaded(this);
}private void unload(final IEntity entity) {
    // 1. remove from physics engine
    if (entity instanceof ICollisionEntity) {
      Game.physics().remove((ICollisionEntity) entity);
    }

    // 2. unregister from update
    if (entity instanceof IUpdateable) {
      Game.loop().detach((IUpdateable) entity);
    }

    if (entity instanceof IMobileEntity) {
      this.removeGravity((IMobileEntity) entity);
    }

    // 3. detach all controllers
    entity.detachControllers();

    if (entity instanceof Emitter) {
      Emitter em = (Emitter) entity;
      em.deactivate();
    }

    if (this.loaded && (entity instanceof LightSource || entity instanceof StaticShadow)) {
      this.updateLighting(entity);
    }

    entity.removed(this);
}public void remove(final IEntity entity) {
    if (entity == null) {
      return;
    }

    this.allEntities.remove(entity.getMapId());
    Iterator<List<IEntity>> iter = this.layerEntities.values().iterator();
    while (iter.hasNext()) {
      List<IEntity> layer = iter.next();
      if (layer.remove(entity) && layer.isEmpty()) {
        iter.remove();
      }
    }
    if (this.miscEntities.get(entity.getRenderType()) != null) {
      this.miscEntities.get(entity.getRenderType()).values().remove(entity);
    }

    for (String tag : entity.getTags()) {
      if (this.getEntitiesByTag().containsKey(tag)) {
        this.getEntitiesByTag().get(tag).remove(entity);

        if (this.getEntitiesByTag().get(tag).isEmpty()) {
          this.getEntitiesByTag().remove(tag);
        }
      }
    }

    if (entity instanceof Emitter) {
      Emitter emitter = (Emitter) entity;
      this.removeEmitter(emitter);
    }

    if (entity instanceof MapArea) {
      this.mapAreas.remove(entity);
    }

    if (entity instanceof Prop) {
      this.props.remove(entity);
    }

    if (entity instanceof Creature) {
      this.creatures.remove(entity);
    }

    if (entity instanceof CollisionBox) {
      this.colliders.remove(entity);
      this.staticShadows.removeIf(x -> x.getOrigin() != null && x.getOrigin().equals(entity));
    }

    if (entity instanceof LightSource) {
      this.lightSources.remove(entity);
      this.updateLighting(entity);
    }

    if (entity instanceof Trigger) {
      this.triggers.remove(entity);
    }

    if (entity instanceof Spawnpoint) {
      this.spawnPoints.remove(entity);
    }
    if (entity instanceof SoundSource) {
      this.soundSources.remove(entity);
    }

    if (entity instanceof StaticShadow) {
      this.staticShadows.remove(entity);
      this.updateLighting(entity);
    }

    if (entity instanceof IMobileEntity) {
      this.mobileEntities.values().remove(entity);
    }

    if (entity instanceof ICombatEntity) {
      this.combatEntities.values().remove(entity);
    }

    this.unload(entity);

    this.fireEntityEvent(l -> l.entityRemoved(entity));
}
}
```
```java
class de.gurkenlabs.litiengine.physics.MovementController {
@Override
  public void update() {
    this.handleForces();
    this.handleMovement();
}
}
```
```java
class de.gurkenlabs.litiengine.Game {
static synchronized void terminate() {
    if (!initialized) {
      return;
    }

    hasStarted = false;
    initialized = false;

    config().save();
    gameLoop.terminate();
    tweenEngine.terminate();
    soundEngine.terminate();

    world().clear();

    for (final GameListener listener : gameListeners) {
      try {
        listener.terminated();
      } catch (Exception e) {
        log().log(Level.WARNING, "game listener threw an exception during shutdown", e);
      }
    }

    gameLoop = null;
    screenManager = null;
    gameWindow = null;
}public static synchronized void start() {
    if (!initialized) {
      throw new IllegalStateException(
          "The game cannot be started without being first initialized. Call Game.init(...) before Game.start().");
    }

    gameLoop.start();
    tweenEngine.start();
    soundEngine.start();

    for (final GameListener listener : gameListeners) {
      listener.started();
    }

    hasStarted = true;
}public static synchronized void init(String... args) {
    if (initialized) {
      log().log(Level.INFO, "The game has already been initialized.");
      return;
    }

    log.init();
    handleCommandLineArguments(args);

    config().load();
    Locale.setDefault(new Locale(config().client().getCountry(), config().client().getLanguage()));

    gameLoop = new GameLoop("Main Update Loop", config().client().getMaxFps());
    loop().attach(physics());
    loop().attach(world());

    // setup default exception handling for render and update loop
    setUncaughtExceptionHandler(
        new DefaultUncaughtExceptionHandler(config().client().exitOnError()));

    screenManager = new ScreenManager();
    gameWindow = new GameWindow();

    // initialize  the game window
    window().init();
    world.setCamera(new Camera());

    for (GameListener listener : gameListeners) {
      listener.initialized(args);
    }

    if (!isInNoGUIMode()) {
      window().getRenderComponent().onRendered(g -> metrics().render(g));

      graphics()
          .addEntityRenderedListener(
              e -> DebugRenderer.renderEntityDebugInfo(e.getGraphics(), e.getEntity()));

      window().getRenderComponent().onFpsChanged(fps -> metrics().setFramesPerSecond(fps));
      window()
          .setIcons(
              Arrays.asList(
                  Resources.images().get("liti-logo-x16.png"),
                  Resources.images().get("liti-logo-x20.png"),
                  Resources.images().get("liti-logo-x32.png"),
                  Resources.images().get("liti-logo-x48.png")));

      Input.keyboard()
          .onKeyTyped(
              KeyEvent.VK_PRINTSCREEN,
              key -> {
                // don't take a screenshot if a modifier is active
                if (key.getModifiers() != 0) {
                  return;
                }

                window().getRenderComponent().takeScreenshot();
              });
    }

    Runtime.getRuntime().addShutdownHook(new Thread(Game::terminate, "Shutdown"));

    initialized = true;
}
}
```


Response Format:
Provide the answer in **XML format** as follows:

#### If the method **cannot** return `null` at the specific call site:
```xml
<response>
  <reason><![CDATA[EXPLAIN WHY THE INVOCATION Game.loop() RESULT CANNOT BE NULL.]]></reason>
  <value>NO</value>
</response>

#### If the method can return null at the specific call site:
<response>
  <reason><![CDATA[EXPLAIN WHY THE INVOCATION Game.loop() RESULT CAN BE NULL.]]></reason>
  <value>YES</value>
</response>

#### If you are unsure or If there are any methods that directly or indirectly affect the return value and are not fully disclosed, request their declarations first, in the following format:
<response>
  <reason><![CDATA[EXPLAIN WHY THIS METHOD DECLARATION IS NECESSARY AND WHY YOU CANNOT MAKE A CONFIDENT DECISION WITHOUT IT]]></reason>
  <success>false</success>
  <methods>
    <method>methodName</method>
  </methods>
</response>

Additional Notes:
Be precise in your reasoning.
If a method’s return value depends on another method not provided, request its declaration before making a conclusion.
If the method can return null in this case but not in others, explain why it happens specifically for this call.

---ChatGPT.sendRequestToOpenAI---
Retrieving response from cache
---Response.<init>---
Creating Response:
```xml
<response>
  <reason><![CDATA[The method `Game.loop()` returns the static field `gameLoop`, which is initialized in the `Game.init(String... args)` method. In this method, a new `GameLoop` object is instantiated and assigned to `gameLoop`. Since `init()` must be called before `start()`, which is implied by the requirement of initializing the game, the `gameLoop` is guaranteed to be non-null during the lifetime of the game execution where `Game.loop()` is called. The absence of any code that could set `gameLoop` to null after its initialization ensures that `Game.loop()` cannot return null.]]></reason>
  <value>NO</value>
</response>
```
---Response.<init>---
Response created:
Disagreement: The method `Game.loop()` returns the static field `gameLoop`, which is initialized in the `Game.init(String... args)` method. In this method, a new `GameLoop` object is instantiated and assigned to `gameLoop`. Since `init()` must be called before `start()`, which is implied by the requirement of initializing the game, the `gameLoop` is guaranteed to be non-null during the lifetime of the game execution where `Game.loop()` is called. The absence of any code that could set `gameLoop` to null after its initialization ensures that `Game.loop()` cannot return null.
---AdvancedNullAwayCodeFix.resolveMethodDereferenceError---
Method is not returning nullable on call site. Injecting suppression annotation.
---AdvancedNullAwayCodeFix.constructCastToNonnullChange---
Constructing cast to nonnull change for reason: The method `Game.loop()` returns the static field `gameLoop`, which is initialized in the `Game.init(String... args)` method. In this method, a new `GameLoop` object is instantiated and assigned to `gameLoop`. Since `init()` must be called before `start()`, which is implied by the requirement of initializing the game, the `gameLoop` is guaranteed to be non-null during the lifetime of the game execution where `Game.loop()` is called. The absence of any code that could set `gameLoop` to null after its initialization ensures that `Game.loop()` cannot return null.
---ChatGPT.ask---
Asking ChatGPT:
For the reason you mentioned earlier:

"The method `Game.loop()` returns the static field `gameLoop`, which is initialized in the `Game.init(String... args)` method. In this method, a new `GameLoop` object is instantiated and assigned to `gameLoop`. Since `init()` must be called before `start()`, which is implied by the requirement of initializing the game, the `gameLoop` is guaranteed to be non-null during the lifetime of the game execution where `Game.loop()` is called. The absence of any code that could set `gameLoop` to null after its initialization ensures that `Game.loop()` cannot return null."

in the method below, the expression Game.loop() is not nullable at the point it is used.

```java
@Override
  public float getTickVelocity() {
    // pixels per ms multiplied by the passed ms
    // ensure that entities don't travel too far in case of lag
    return Math.min(Game.loop().getDeltaTime(), GameLoop.TICK_DELTATIME_LAG)
        * 0.001F
        * this.getVelocity().get()
        * Game.loop().getTimeScale();
}
```
Please Summarize the reason in max 5 words and rewrite the method so that at the line "    return Math.min(Game.loop().getDeltaTime(), GameLoop.TICK_DELTATIME_LAG)", at the occurrence of: "Game.loop()" is replaced with `NullabilityUtil.castToNonnull(Game.loop(), summary of reason)`
Replace "REASON" with the exact reason summary I provide to you (maximum 5 words), not with a generic explanation like "checked to be nonnull".
see the example below, for expression `foo.getBar()`, to wrap it with `NullabilityUtil.castToNonnull(foo.getBar(), "reason")`.

```java
public t(){
    String l = foo.getBar();
}
```

will be:
```java
public t(){
    String l = NullabilityUtil.castToNonnull(foo.getBar(), "checked to be nonnull");
}
```

### Instructions:

Do not import any additional classes.

Do not add Java comments.

Only modify relevant lines as required.

Return only the modified method wrapped in the XML format shown below.

Place the Java code inside the <code> tag using a CDATA block with ```java formatting.

Just give me the fixed code snippet in XML format in <response> tag like the example below. I will apply the fix to my codebase. Do not import any additional libraries or classes or add java comments. If you can provide the fixed code snippet, please provide it in the following format and place the code snippet in the <code> tag within ```java block.
<response>
  <success>true</success>
  <code><![CDATA[
  ```java
  Your fixed code snippet here
  ```
    ]]>
  </code>
</response>

---ChatGPT.sendRequestToOpenAI---
Sending request to OpenAI...
---ChatGPT.sendRequestToOpenAI---
Response received from OpenAI.
---Response.<init>---
Creating Response:
Sure, here's the modified Java method as requested:

```xml
<response>
  <success>true</success>
  <code><![CDATA[
  ```java
  @Override
  public float getTickVelocity() {
    return Math.min(NullabilityUtil.castToNonnull(Game.loop(), "cannot return null").getDeltaTime(), GameLoop.TICK_DELTATIME_LAG)
        * 0.001F
        * this.getVelocity().get()
        * Game.loop().getTimeScale();
  }
  ```
  ]]>
  </code>
</response>
```
---Response.<init>---
Response created:
@Override
  public float getTickVelocity() {
    return Math.min(NullabilityUtil.castToNonnull(Game.loop(), "cannot return null").getDeltaTime(), GameLoop.TICK_DELTATIME_LAG)
        * 0.001F
        * this.getVelocity().get()
        * Game.loop().getTimeScale();
  }
---ChatGPT.fixDereferenceByAddingCastToNonnull---
Fixing the error by adding castToNonnull
---AdvancedNullAwayCodeFix.fixTriggeredErrorsForLocation---
Resolving unresolvable error for triggered error: Type='DEREFERENCE_NULLABLE', message='dereferenced expression Game.loop() is @Nullable'
/home/nima/Developer/nullness-benchmarks/litiengine/src/de/gurkenlabs/litiengine/graphics/emitters/Emitter.java:133
    Game.loop().attach(this);
---AdvancedNullAwayCodeFix.fix---
Fixing error: Type='DEREFERENCE_NULLABLE', message='dereferenced expression Game.loop() is @Nullable'
/home/nima/Developer/nullness-benchmarks/litiengine/src/de/gurkenlabs/litiengine/graphics/emitters/Emitter.java:133
    Game.loop().attach(this);
---AdvancedNullAwayCodeFix.resolveDereferenceError---
Resolving dereference error: Type='DEREFERENCE_NULLABLE', message='dereferenced expression Game.loop() is @Nullable'
/home/nima/Developer/nullness-benchmarks/litiengine/src/de/gurkenlabs/litiengine/graphics/emitters/Emitter.java:133
    Game.loop().attach(this);
---AdvancedNullAwayCodeFix.resolveDereferenceError---
Checking nullability possibility at error point
---ChatGPT.checkNullabilityPossibilityAtErrorPoint---
Asking if the expression can be null at error point point
---ChatGPT.ask---
Asking ChatGPT:
In the method below, is there a possibility that the expression "Game.loop()" at line "Game.loop().attach(this);" is null?
public void activate() {
    if (this.activated) {
      return;
    }

    this.activated = true;
    this.activationTick = Game.time().now();
    Game.loop().attach(this);
}
Give a single-word answer in XML format. If it is possible for the expression to be null, respond with:
```xml
<response>
    <reason><![CDATA[YOUR REASON]]></reason>
    <value>YES</value>
</response>
```
If it is not possible for the expression to be null, respond with:
```xml
<response>
    <reason><![CDATA[YOUR REASON]]></reason>
    <value>NO</value>
</response>
```
If you are unsure or need more information, respond with where you can ask for more details or what specific information you need.

If additional information is required, list each request inside a `<request>` tag. If no additional information is needed, omit the `<requests>` section.

Respond with:
```xml
<response>
    <reason><![CDATA[YOUR REASON]]></reason>
    <value>UNKNOWN</value>
    <!-- Include <requests> only if additional information is needed -->
    <requests>
        <request><![CDATA[YOUR REQUEST 1]]></request>
        <request><![CDATA[YOUR REQUEST 2]]></request>
    </requests>
</response>
```
---ChatGPT.sendRequestToOpenAI---
Sending request to OpenAI...
---ChatGPT.sendRequestToOpenAI---
Response received from OpenAI.
---Response.<init>---
Creating Response:
```xml
<response>
    <reason><![CDATA[Without further information about the implementation of the Game class, particularly the loop() method, it's not possible to definitively determine whether Game.loop() could return null.]]></reason>
    <value>UNKNOWN</value>
    <requests>
        <request><![CDATA[Please provide the implementation details or documentation for the Game.loop() method.]]></request>
        <request><![CDATA[Please provide information on any conditions or scenarios where Game.loop() might return null.]]></request>
    </requests>
</response>
```
---Response.<init>---
Response created:
Unknown: Without further information about the implementation of the Game class, particularly the loop() method, it's not possible to definitively determine whether Game.loop() could return null.
---AdvancedNullAwayCodeFix.resolveMethodDereferenceError---
Resolving method dereference error.
---AdvancedNullAwayCodeFix.resolveMethodDereferenceError---
Method is in annotated package. Checking if the method is returning nullable.
---AdvancedNullAwayCodeFix.investigateMethodReturnNullability---
Checking if the method is returning nullable.
---ChatGPT.checkIfMethodIsReturningNullable---
Asking if the method is returning nullable: loop()
---ChatGPT.ask---
Asking ChatGPT:
In the method below, is there a possibility that the method returns null based only on its body? Consider the following points:

- The method may have multiple return paths; consider all return statements.
- If the method calls another method, do not assume its return value unless its full declaration is provided. Request its declaration if needed.
- The method may throw an exception instead of returning null. An exception path should not be considered a null return.
- Ensure you request the declarations of any methods whose return values directly or indirectly impact this method’s return value before making a conclusion.
- Carefully analyze all conditions and prior operations that may guarantee a non-null return value.

@Nullable public static IGameLoop loop() {
    return gameLoop;
}

Here are the method definitions in addition to the method inquired:

Depth: 0
```java
class de.gurkenlabs.litiengine.Game {
@Nullable public static IGameLoop loop() {
    return gameLoop;
}
}
```


Response Format:
Provide the answer in **XML format** as follows:

#### If the method **cannot** return `null`:
```xml
<response>
  <reason><![CDATA[EXPLAIN WHY THE METHOD CANNOT RETURN NULL]]></reason>
  <value>NO</value>
</response>
```

#### If the method can return null:
```xml
<response>
  <reason><![CDATA[EXPLAIN WHY THE METHOD CAN RETURN NULL]]></reason>
  <value>YES</value>
</response>
```

#### If you are unsure or need more information, respond with where you can ask for more details or what specific information you need.

#### If you are unsure or If there are any methods that directly or indirectly affect the return value and are not fully disclosed, request their declarations first, in the following format:
<response>
  <reason><![CDATA[YOUR REASON]]></reason>
  <value>UNKNOWN</value>
  <methods>
    <method>methodName</method>
  </methods>
</response>

If additional information is required other than method declaration, list each request inside a `<request>` tag. If no additional information is needed, omit the `<requests>` section.

Respond with:
```xml
<response>
    <reason><![CDATA[YOUR REASON]]></reason>
    <value>UNKNOWN</value>
    <!-- Include <requests> only if additional information is needed -->
    <requests>
        <request><![CDATA[YOUR REQUEST 1]]></request>
        <request><![CDATA[YOUR REQUEST 2]]></request>
    </requests>
</response>
```

Additional Notes:
Be precise in your reasoning.
If a method’s return value depends on another method not provided, request its declaration before making a conclusion.
If the method can return null in some cases but not others, explain under what conditions it can happen.

---ChatGPT.sendRequestToOpenAI---
Retrieving response from cache
---Response.<init>---
Creating Response:
```xml
<response>
  <reason><![CDATA[The method `loop` returns the variable `gameLoop`. Without the initialization or assignment details of `gameLoop`, it's unclear whether it can be null. The possibility of `gameLoop` being uninitialized or set to null elsewhere in the program means `loop` could potentially return null. Further information on `gameLoop` is required.]]></reason>
  <value>UNKNOWN</value>
  <requests>
    <request><![CDATA[Please provide the declaration and initialization of the variable `gameLoop` in the class `de.gurkenlabs.litiengine.Game`.]]></request>
  </requests>
</response>
```
---Response.<init>---
Response created:
Unknown: The method `loop` returns the variable `gameLoop`. Without the initialization or assignment details of `gameLoop`, it's unclear whether it can be null. The possibility of `gameLoop` being uninitialized or set to null elsewhere in the program means `loop` could potentially return null. Further information on `gameLoop` is required.
---AdvancedNullAwayCodeFix.investigateMethodReturnNullability---
Could not determine the nullability and model did not ask for any method.
---ChatGPT.checkIfMethodIsReturningNullableOnCallSite---
Asking if the method is returning nullable on the call site: Game.loop()
---ChatGPT.ask---
Asking ChatGPT:
In the method below, is there a possibility that the method returns null at the given call site?

```java
@Nullable public static IGameLoop loop() {
    return gameLoop;
}
```

## Guidelines:
- The method may have multiple return paths; consider all return statements.
- If the method calls another method, do not assume its return value unless its full declaration is provided. Request its declaration if needed.
- The method may throw an exception instead of returning null. An exception path should not be considered a null return.
- Ensure you request the declarations of any methods whose return values directly or indirectly impact this method’s return value before making a conclusion.
- If the method returns a value that is determined by a parameter, evaluate based on the actual argument at the given call site.
- Analyze based only on the specific invocation provided. Do not generalize to all possible inputs.- If the return value is guaranteed to be non-null at the call site, the answer should be a definitive NO.
- Do not generalize based on all possible inputs—your answer must be based only on the given invocation.
- Focus only on the given call site, not all possible invocations.

### call site:
Game.loop()

Here are the method definitions and the call chain for this method, showing the sequence of calls from the method to its callers at each depth level:

Depth: 0
```java
class de.gurkenlabs.litiengine.Game {
@Nullable public static IGameLoop loop() {
    return gameLoop;
}
}
```
Depth: 1
```java
class de.gurkenlabs.litiengine.environment.GameWorld {
public void loadEnvironment(@Nullable final Environment env) {
    Lock lock = Game.loop().getLock();
    lock.lock();
    try {
      unloadEnvironment();
      this.environment = env;
      if (env != null) {
        this.addEnvironment(env);

        if (env.getGravity() == 0 && this.gravity() != 0) {
          env.setGravity(this.gravity());
        }

        env.load();
        for (final EnvironmentLoadedListener listener : this.loadedListeners) {
          listener.loaded(env);
        }

        // call map specific listeners
        String mapName = getMapName(env);
        if (mapName != null && this.environmentLoadedListeners.containsKey(mapName)) {

          // for the default camera we center the camera on the environment
          if (this.camera().getClass().equals(Camera.class)) {
            camera().setFocus(env.getCenter());
          }

          for (EnvironmentLoadedListener listener : this.environmentLoadedListeners.get(mapName)) {
            listener.loaded(env);
          }
        }
      }
    } finally {
      lock.unlock();
    }
}public void setCamera(@Nullable final ICamera cam) {
    if (this.camera() != null) {
      Game.loop().detach(camera);
    }

    camera = cam;

    if (cam != null && !Game.isInNoGUIMode()) {
      Game.loop().attach(cam);
      cam.updateFocus();
    }
}
}
```
```java
class de.gurkenlabs.litiengine.entities.behavior.EntityNavigator {
public EntityNavigator(final IMobileEntity entity, final PathFinder pathFinder) {
    this.cancelNavigationConditions = new CopyOnWriteArrayList<>();
    this.listeners = new CopyOnWriteArrayList<>();
    this.entity = entity;
    this.pathFinder = pathFinder;
    this.setAcceptableError(DEFAULT_ACCEPTABLE_ERROR);
    Game.loop().attach(this);
}
}
```
```java
class de.gurkenlabs.litiengine.GameWindow {
private static void initializeWindowEventListeners(Window window) {

    window.addWindowStateListener(
        e -> {
          if (e.getNewState() == Frame.ICONIFIED) {
            Game.loop().setTickRate(ICONIFIED_MAX_FPS);
          } else {
            Game.loop().setTickRate(Game.config().client().getMaxFps());
          }
        });

    window.addWindowFocusListener(
        new WindowFocusListener() {
          @Override
          public void windowLostFocus(WindowEvent e) {
            if (Game.config().graphics().reduceFramesWhenNotFocused()) {
              Game.loop().setTickRate(NONE_FOCUS_MAX_FPS);
            }
          }

          @Override
          public void windowGainedFocus(WindowEvent e) {
            Game.loop().setTickRate(Game.config().client().getMaxFps());
          }
        });

    window.addWindowListener(
        new WindowAdapter() {
          @Override
          public void windowClosing(final WindowEvent event) {
            Game.exit();
          }
        });
}
}
```
```java
class de.gurkenlabs.litiengine.gui.screens.ScreenManager {
public void display(@Nullable final Screen screen) {
    if (Game.hasStarted() && Game.time().since(this.lastScreenChange) < this.getChangeCooldown()) {
      log.log(
          Level.INFO,
          "Skipping displaying of screen {0} because screen changing is currently on cooldown.",
          screen != null ? screen.getName() : "");
      return;
    }

    final Screen previous = this.current();
    if (previous != null) {
      previous.suspend();
    }

    if (screen != null && !this.screens.contains(screen)) {
      this.screens.add(screen);
    }

    this.currentScreen = screen;
    if (!Game.isInNoGUIMode() && this.current() != null) {
      this.current().prepare();
    }

    this.lastScreenChange = Game.loop().getTicks();

    final ScreenChangedEvent event = new ScreenChangedEvent(this.current(), previous);
    for (final ScreenChangedListener listener : this.screenChangedListeners) {
      listener.changed(event);
    }
}
}
```
```java
class de.gurkenlabs.litiengine.abilities.effects.Effect {
@Override
  public void update() {

    for (final Iterator<EffectApplication> iterator = this.getActiveAppliances().iterator();
        iterator.hasNext(); ) {
      final EffectApplication appliance = iterator.next();
      // if the effect duration is reached
      if (this.hasEnded(appliance)) {

        iterator.remove();
        this.cease(appliance);
      }
    }

    // 4. unregister if all appliances are finished
    if (this.getActiveAppliances().isEmpty()) {
      Game.loop().detach(this);
    }
}public void apply(final Shape impactArea) {
    final List<ICombatEntity> affected = this.lookForAffectedEntities(impactArea);
    for (final ICombatEntity affectedEntity : affected) {
      this.apply(affectedEntity);
    }

    this.appliances.add(new EffectApplication(affected, impactArea));

    // if it is the first appliance -> register for update
    if (this.appliances.size() == 1) {
      Game.loop().attach(this);
    }
}
}
```
```java
class de.gurkenlabs.litiengine.GameTime {
public long toTicks(final int milliseconds) {
    return this.toTicks(milliseconds, Game.loop().getTickRate());
}public long since(final long tick) {
    return toMilliseconds(Game.loop().getTicks() - tick);
}public long now() {
    return Game.loop().getTicks();
}public long sinceGameStart() {
    return this.toMilliseconds(Game.loop().getTicks());
}@Override
  public void loaded(Environment environment) {
    environmentLoaded = Game.loop().getTicks();
}public long toMilliseconds(final long ticks) {
    return this.toMilliseconds(ticks, Game.loop().getTickRate());
}
}
```
```java
class de.gurkenlabs.litiengine.GameMetrics {
@Override
  public void render(final Graphics2D g) {
    this.updateMetrics();

    if (!Game.config().client().showGameMetrics()) {
      return;
    }

    this.currentOffsetY = 0;

    g.setColor(this.renderColor);

    // render client metrics
    this.drawTitle(g, "[client]");
    this.drawMetric(g, "fps       : " + this.getFramesPerSecond());
    this.drawMetric(g, "max fps   : " + this.maxFramesPerSecond);
    this.drawMetric(g, "updatables: " + Game.loop().getUpdatableCount());

    // render jvm metrics if debug is enabled
    if (Game.config().debug().isDebugEnabled()) {
      this.drawTitle(g, "[jvm]");
      this.drawMetric(g, "java      : " + this.javaVersion);
      this.drawMetric(g, "memory    : " + String.format("%-5.5s", this.usedMemory) + " MB");
      this.drawMetric(g, "threads   : " + Thread.activeCount());
    }

    // render rendering metrics
    if (!this.renderMetrics.isEmpty()) {
      this.drawTitle(g, "[update]");

      for (RenderMetrics metric : this.renderMetrics) {
        this.drawMetric(g, metric.toString());
      }

      this.renderMetrics.clear();
    }
}
}
```
```java
class de.gurkenlabs.litiengine.graphics.emitters.Emitter {
public void deactivate() {
    if (!this.activated) {
      return;
    }

    this.activated = false;
    this.getParticles().clear();
    this.aliveTime = 0;
    this.activationTick = 0;
    this.lastSpawn = 0;
    Game.loop().detach(this);
}public void activate() {
    if (this.activated) {
      return;
    }

    this.activated = true;
    this.activationTick = Game.time().now();
    Game.loop().attach(this);
}@Override
  public void update() {
    if (this.isPaused()) {
      return;
    }

    // clear particles if the effect time to life is reached
    if (this.isFinished()) {
      for (EmitterFinishedListener listener : this.finishedListeners) {
        listener.finished(this);
      }

      this.delete();
      return;
    }

    final float updateRatio = (float) this.data().getUpdateRate() / Game.loop().getTickRate();
    for (final Particle p : this.getParticles().stream().collect(Collectors.toList())) {
      if (this.particleCanBeRemoved(p)) {
        // remove dead particles
        this.particles.remove(p);
        continue;
      }

      p.update(this.getOrigin(), updateRatio);
    }

    this.aliveTime = Game.time().since(this.activationTick);
    if ((this.data().getSpawnRate() == 0
        || Game.time().since(this.lastSpawn) >= this.data().getSpawnRate())) {
      this.lastSpawn = Game.time().now();
      this.spawnParticle();
    }
}
}
```
```java
class de.gurkenlabs.litiengine.entities.behavior.IBehaviorController {
public default void attach() {
    Game.loop().attach(this);
}public default void detach() {
    Game.loop().detach(this);
}
}
```
```java
class de.gurkenlabs.litiengine.abilities.AbilityExecution {
AbilityExecution(final Ability ability) {
    this.appliedEffects = new CopyOnWriteArrayList<>();
    this.ability = ability;
    this.executionTicks = Game.time().now();
    this.impactArea = ability.calculateImpactArea();
    this.castLocation = ability.getExecutor().getCenter();
    Game.loop().attach(this);
}@Override
  public void update() {
    // if there a no effects to apply -> unregister this instance and we're done
    if (this.getAbility().getEffects().isEmpty()
        || this.getAbility().getEffects().size() == this.getAppliedEffects().size()) {
      Game.loop().detach(this);
      return;
    }

    // handle all effects from the ability that were not applied yet
    for (final Effect effect : this.getAbility().getEffects()) {
      // if the ability was not executed yet or the delay of the effect is not
      // yet reached
      if (this.getAppliedEffects().contains(effect)
          || Game.time().since(this.getExecutionTicks()) < effect.getDelay()) {
        continue;
      }

      effect.apply(this.getExecutionImpactArea());
      this.getAppliedEffects().add(effect);
    }
}
}
```
```java
class de.gurkenlabs.litiengine.GameWindow$3 {
@Override
          public void windowGainedFocus(WindowEvent e) {
            Game.loop().setTickRate(Game.config().client().getMaxFps());
}@Override
          public void windowLostFocus(WindowEvent e) {
            if (Game.config().graphics().reduceFramesWhenNotFocused()) {
              Game.loop().setTickRate(NONE_FOCUS_MAX_FPS);
            }
}
}
```
```java
class de.gurkenlabs.litiengine.environment.EntitySpawner {
protected void spawnNewEntities() {
    if (this.getSpawnMode() != SpawnMode.CUSTOMSPAWNPOINTS && this.getSpawnPoints().isEmpty()) {
      return;
    }

    switch (this.getSpawnMode()) {
      case ALLSPAWNPOINTS:
        for (int i = 0; i < this.getSpawnPoints().size(); i++) {
          final int index = i;
          Game.loop()
              .perform(
                  this.getSpawnDelay() + this.getSpawnDelay() * i,
                  () -> this.spawn(this.getSpawnPoints().get(index), this.getSpawnAmount()));
        }
        break;
      case ONERANDOMSPAWNPOINT:
        this.spawn(Game.random().choose(this.getSpawnPoints()), this.getSpawnAmount());
        break;
      case RANDOMSPAWNPOINTS:
        for (int i = 0; i < this.getSpawnAmount(); i++) {
          Game.loop()
              .perform(
                  this.getSpawnDelay() + this.getSpawnDelay() * i,
                  () -> this.spawn(Game.random().choose(this.getSpawnPoints()), 1));
        }
        break;
      case CUSTOMSPAWNPOINTS:
        List<Spawnpoint> spawnPoints =
            this.customSpawnpoints != null
                ? this.customSpawnpoints.apply(this)
                : this.getCustomSpawnpoints();

        int index = 0;
        for (Spawnpoint spawn : spawnPoints) {
          Game.loop()
              .perform(
                  this.getSpawnDelay() + this.getSpawnDelay() * index, () -> this.spawn(spawn, 1));
          index++;
        }
        break;
      default:
        break;
    }
}
}
```
```java
class de.gurkenlabs.litiengine.tweening.TweenEngine {
@Override
  public void start() {
    Game.loop().attach(this);
}@Override
  public void terminate() {
    Game.loop().detach(this);
}
}
```
```java
class de.gurkenlabs.litiengine.gui.SpeechBubble {
public void hide() {
    Game.world().environment().removeRenderable(this);
    Game.loop().detach(this);
    if (activeSpeechBubbles.get(this.getEntity()) != null
        && activeSpeechBubbles.remove(this.getEntity()).equals(this)) {
      activeSpeechBubbles.remove(this.getEntity());
    }

    for (SpeechBubbleListener listener : this.listeners) {
      listener.hidden();
    }
}private SpeechBubble(
      final IEntity entity,
      final String text,
      @Nullable SpeechBubbleAppearance appearance,
      @Nullable Font font) {
    if (appearance == null) {
      this.appearance = DEFAULT_APPEARANCE;
    } else {
      this.appearance = appearance;
    }

    final SpeechBubble active = activeSpeechBubbles.get(entity);
    if (active != null) {
      active.hide();
    }
    this.setFont(font);

    this.textBoxWidth = (float) (entity.getWidth() * 4);
    this.entity = entity;

    this.currentText = text;
    this.currentTextDisplayTime = DISPLAYTIME_MIN + text.length() * DISPLAYTIME_PER_LETTER;

    this.lastTextDisplay = Game.time().now();
    this.createBubbleImage();
    entity.getEnvironment().add(this, RenderType.UI);
    Game.loop().attach(this);
    activeSpeechBubbles.put(entity, this);
}
}
```
```java
class de.gurkenlabs.litiengine.entities.Prop {
private void updateAnimationController() {
    IEntityAnimationController<?> controller = this.createAnimationController();
    this.getControllers().addController(controller);
    if (Game.world().environment() != null && Game.world().environment().isLoaded()) {
      Game.loop().attach(controller);
    }
}
}
```
```java
class de.gurkenlabs.litiengine.graphics.FreeFlightCamera {
public FreeFlightCamera(final Point2D focus) {
    this.setFocus(focus);
    this.velocity = DEFAULT_SCROLL_PIXELS_PER_SECOND;
    this.scrollPadding = DEFAULT_SCROLL_PADDING;
    this.setClampToMap(true);

    Game.loop().attach(this);
}private void handleFreeFlightCamera() {
    if (Game.world().environment() == null || Game.world().environment().getMap() == null) {
      return;
    }

    final Point2D mouseLocation = Input.mouse().getLocation();

    final double scrollSpeed =
        this.getVelocity()
            / (double) Game.loop().getTickRate()
            * Game.config().input().getMouseSensitivity();

    double x = this.getFocus().getX();
    double y = this.getFocus().getY();

    double deltaX = 0;
    if (mouseLocation.getX() < this.getScrollPadding()) {
      deltaX -= scrollSpeed;
    } else if (Game.window().getResolution().getWidth() - mouseLocation.getX()
        < this.getScrollPadding()) {
      deltaX += scrollSpeed;
    }

    double deltaY = 0;
    if (mouseLocation.getY() < this.getScrollPadding()) {
      deltaY -= scrollSpeed;
    } else if (Game.window().getResolution().getHeight() - mouseLocation.getY()
        < this.getScrollPadding()) {
      deltaY += scrollSpeed;
    }

    x += deltaX;
    y += deltaY;

    this.setFocus(new Point2D.Double(x, y));
}
}
```
```java
class de.gurkenlabs.litiengine.environment.Environment {
private static void dispose(final Collection<? extends IEntity> entities) {
    for (final IEntity entity : entities) {
      if (entity instanceof IUpdateable) {
        Game.loop().detach((IUpdateable) entity);
      }

      entity.detachControllers();
    }
}private static void loadUpdatableOrEmitterEntity(IEntity entity) {
    if (entity instanceof Emitter) {
      final Emitter emitter = (Emitter) entity;
      if (emitter.isActivateOnInit()) {
        emitter.activate();
      }
    } else if (entity instanceof IUpdateable) {
      Game.loop().attach((IUpdateable) entity);
    }
}private void unload(final IEntity entity) {
    // 1. remove from physics engine
    if (entity instanceof ICollisionEntity) {
      Game.physics().remove((ICollisionEntity) entity);
    }

    // 2. unregister from update
    if (entity instanceof IUpdateable) {
      Game.loop().detach((IUpdateable) entity);
    }

    if (entity instanceof IMobileEntity) {
      this.removeGravity((IMobileEntity) entity);
    }

    // 3. detach all controllers
    entity.detachControllers();

    if (entity instanceof Emitter) {
      Emitter em = (Emitter) entity;
      em.deactivate();
    }

    if (this.loaded && (entity instanceof LightSource || entity instanceof StaticShadow)) {
      this.updateLighting(entity);
    }

    entity.removed(this);
}
}
```
```java
class de.gurkenlabs.litiengine.graphics.animation.Animation {
@Override
  public void update() {
    // do nothing if the animation is not playing or the current keyframe is not finished
    if (!this.isPlaying()
        || Game.time().since(this.lastFrameUpdate) < this.getCurrentKeyFrame().getDuration()) {
      return;
    }

    // if we are not looping and the last keyframe is finished, we terminate the animation
    if (!this.isLooping() && this.isLastKeyFrame()) {
      this.terminate();
      return;
    }

    // make sure, we stay inside the keyframe list
    final int newFrameIndex =
        (this.getKeyframes().indexOf(this.currentFrame) + 1) % this.getKeyframes().size();
    final KeyFrame previousFrame = this.currentFrame;
    this.currentFrame = this.getKeyframes().get(newFrameIndex);

    for (KeyFrameListener listener : this.listeners) {
      listener.currentFrameChanged(previousFrame, this.currentFrame);
    }

    this.lastFrameUpdate = Game.loop().getTicks();
}public void restart() {
    this.currentFrame = this.firstFrame;
    this.lastFrameUpdate = Game.loop().getTicks();
}
}
```
```java
class de.gurkenlabs.litiengine.physics.MovementController {
@Override
  public void attach() {
    Game.loop().attach(this);
}private void handleForces() {
    // clean up forces
    this.activeForces.forEach(
        x -> {
          if (x.hasEnded()) {
            this.activeForces.remove(x);
          }
        });

    if (this.activeForces.isEmpty()) {
      return;
    }

    // disable turn-on-move for force handling
    boolean turn = this.getEntity().turnOnMove();
    this.getEntity().setTurnOnMove(false);
    try {
      double deltaX = 0;
      double deltaY = 0;
      for (final Force force : this.activeForces) {
        if (force.cancelOnReached() && force.hasReached(this.getEntity())) {
          force.end();
          continue;
        }

        final Point2D collisionBoxCenter = this.getEntity().getCollisionBoxCenter();
        final double angle =
            GeometricUtilities.calcRotationAngleInDegrees(collisionBoxCenter, force.getLocation());
        final double strength =
            Game.loop().getDeltaTime() * 0.001f * force.getStrength() * Game.loop().getTimeScale();
        deltaX += GeometricUtilities.getDeltaX(angle, strength);
        deltaY += GeometricUtilities.getDeltaY(angle, strength);
      }

      final Point2D target =
          new Point2D.Double(this.getEntity().getX() + deltaX, this.getEntity().getY() + deltaY);
      final boolean success = Game.physics().move(this.getEntity(), target);
      if (!success) {
        for (final Force force : this.activeForces) {
          if (force.cancelOnCollision()) {
            force.end();
          }
        }
      }
    } finally {
      this.getEntity().setTurnOnMove(turn);
    }
}@Override
  public void detach() {
    Game.loop().detach(this);
}public void handleMovement() {
    if (!this.isMovementAllowed()) {
      this.velocity = 0;
      return;
    }

    // max distance an entity can travel within one tick
    final double maxPixelsPerTick = this.getEntity().getTickVelocity();
    final double deltaTime = Game.loop().getDeltaTime() * Game.loop().getTimeScale();

    final double acceleration =
        this.getEntity().getAcceleration() == 0
            ? maxPixelsPerTick
            : deltaTime / this.getEntity().getAcceleration() * maxPixelsPerTick;
    final double deceleration =
        this.getEntity().getDeceleration() == 0
            ? this.getVelocity()
            : deltaTime / this.getEntity().getDeceleration() * maxPixelsPerTick;

    double dx = this.getDx();
    double dy = this.getDy();
    this.setDx(0);
    this.setDy(0);

    final double deltaVelocity =
        Math.min(Math.sqrt(Math.pow(dx, 2) + Math.pow(dy, 2)), acceleration);
    if (deltaVelocity != 0) {
      double newVelocity = this.getVelocity() + deltaVelocity;
      this.setVelocity(newVelocity);
    } else {
      final double newVelocity = Math.max(0, this.getVelocity() - deceleration);
      this.setVelocity(newVelocity);
      dx = GeometricUtilities.getDeltaX(this.moveAngle);
      dy = GeometricUtilities.getDeltaY(this.moveAngle);
    }

    if (this.getVelocity() == 0) {
      this.moveAngle = 0;
      return;
    }

    // actually move entity
    this.moveEntity(dx, dy);
}
}
```
```java
class de.gurkenlabs.litiengine.graphics.animation.AnimationController {
public void detach() {
    Game.loop().detach(this);
}public void attach() {
    Game.loop().attach(this);
}
}
```
```java
class de.gurkenlabs.litiengine.graphics.Camera {
@Override
  public void setZoom(final float targetZoom, final int delay) {
    if (delay == 0) {

      this.zoom = targetZoom;
      this.targetZoom = 0;
      this.zoomDelay = 0;
      this.zoomTick = 0;
      this.zoomStep = 0;

      final ZoomChangedEvent event = new ZoomChangedEvent(this, targetZoom);
      for (final ZoomChangedListener listener : this.zoomListeners) {
        listener.zoomChanged(event);
      }
    } else {
      this.zoomTick = Game.time().now();
      this.targetZoom = targetZoom;
      this.zoomDelay = delay;

      final double tickduration = 1000 / (double) Game.loop().getTickRate();
      final double tickAmount = delay / tickduration;
      final float totalDelta = this.targetZoom - this.zoom;
      this.zoomStep = tickAmount > 0 ? (float) (totalDelta / tickAmount) : totalDelta;
    }
}
}
```
```java
class de.gurkenlabs.litiengine.Game {
public static synchronized void init(String... args) {
    if (initialized) {
      log().log(Level.INFO, "The game has already been initialized.");
      return;
    }

    log.init();
    handleCommandLineArguments(args);

    config().load();
    Locale.setDefault(new Locale(config().client().getCountry(), config().client().getLanguage()));

    gameLoop = new GameLoop("Main Update Loop", config().client().getMaxFps());
    loop().attach(physics());
    loop().attach(world());

    // setup default exception handling for render and update loop
    setUncaughtExceptionHandler(
        new DefaultUncaughtExceptionHandler(config().client().exitOnError()));

    screenManager = new ScreenManager();
    gameWindow = new GameWindow();

    // initialize  the game window
    window().init();
    world.setCamera(new Camera());

    for (GameListener listener : gameListeners) {
      listener.initialized(args);
    }

    if (!isInNoGUIMode()) {
      window().getRenderComponent().onRendered(g -> metrics().render(g));

      graphics()
          .addEntityRenderedListener(
              e -> DebugRenderer.renderEntityDebugInfo(e.getGraphics(), e.getEntity()));

      window().getRenderComponent().onFpsChanged(fps -> metrics().setFramesPerSecond(fps));
      window()
          .setIcons(
              Arrays.asList(
                  Resources.images().get("liti-logo-x16.png"),
                  Resources.images().get("liti-logo-x20.png"),
                  Resources.images().get("liti-logo-x32.png"),
                  Resources.images().get("liti-logo-x48.png")));

      Input.keyboard()
          .onKeyTyped(
              KeyEvent.VK_PRINTSCREEN,
              key -> {
                // don't take a screenshot if a modifier is active
                if (key.getModifiers() != 0) {
                  return;
                }

                window().getRenderComponent().takeScreenshot();
              });
    }

    Runtime.getRuntime().addShutdownHook(new Thread(Game::terminate, "Shutdown"));

    initialized = true;
}
}
```
```java
class de.gurkenlabs.litiengine.entities.Creature {
protected void updateAnimationController() {
    IEntityAnimationController<?> controller = this.createAnimationController();
    this.getControllers().addController(controller);
    if (Game.world().environment() != null && Game.world().environment().isLoaded()) {
      Game.loop().attach(controller);
    }
}@Override
  public float getTickVelocity() {
    // pixels per ms multiplied by the passed ms
    // ensure that entities don't travel too far in case of lag
    return Math.min(Game.loop().getDeltaTime(), GameLoop.TICK_DELTATIME_LAG)
        * 0.001F
        * this.getVelocity().get()
        * Game.loop().getTimeScale();
}
}
```
Depth: 2
```java
class de.gurkenlabs.litiengine.environment.GameWorld {
public void clear() {
    this.unloadEnvironment();
    this.environments.clear();
    this.setCamera(null);
    Game.physics().clear();

    this.environmentListeners.clear();
    this.environmentLoadedListeners.clear();
    this.environmentUnloadedListeners.clear();

    this.listeners.clear();
    this.loadedListeners.clear();
    this.unloadedListeners.clear();
}@Nullable
  public Environment loadEnvironment(IMap map) {
    Environment env = this.getEnvironment(map);
    this.loadEnvironment(env);
    return env;
}@Nullable
  public Environment loadEnvironment(String mapName) {
    Environment env = this.getEnvironment(mapName);
    this.loadEnvironment(env);
    return env;
}
}
```
```java
class de.gurkenlabs.litiengine.GameWindow {
GameWindow() {
    this.hostControl = new JFrame();

    this.resolutionChangedListeners = new CopyOnWriteArrayList<>();

    this.renderCanvas = new RenderComponent(Game.config().graphics().getResolution());
    this.cursor = new MouseCursor();
    if (!Game.isInNoGUIMode()) {
      this.hostControl.setBackground(Color.BLACK);
      this.hostControl.add(this.renderCanvas);

      this.initializeEventListeners();

      this.hostControl.setTitle(Game.info().getTitle());
      this.hostControl.setDefaultCloseOperation(WindowConstants.DO_NOTHING_ON_CLOSE);
      initializeWindowEventListeners(this.hostControl);
    }
}
}
```
```java
class de.gurkenlabs.litiengine.GameTime {
public long sinceEnvironmentLoad() {
    return this.since(this.environmentLoaded);
}public long since(final long tick) {
    return toMilliseconds(Game.loop().getTicks() - tick);
}public long sinceGameStart() {
    return this.toMilliseconds(Game.loop().getTicks());
}
}
```
```java
class de.gurkenlabs.litiengine.abilities.effects.Effect {
protected void cease(final EffectApplication appliance) {
    // 1. cease the effect for all affected entities
    for (final ICombatEntity entity : appliance.getAffectedEntities()) {
      this.cease(entity);
    }

    // 2. apply follow up effects
    this.getFollowUpEffects().forEach(followUp -> followUp.apply(appliance.getImpactArea()));
}protected boolean hasEnded(final EffectApplication appliance) {
    final long effectDuration = Game.time().since(appliance.getAppliedTicks());
    return effectDuration > this.getDuration();
}
}
```
```java
class de.gurkenlabs.litiengine.abilities.effects.EffectApplication {
protected EffectApplication(final List<ICombatEntity> affectedEntities, final Shape impactArea) {
    this.applied = Game.time().now();
    this.affectedEntities = affectedEntities;
    this.impactArea = impactArea;
}
}
```
```java
class de.gurkenlabs.litiengine.entities.CombatEntity {
@Override
  public boolean wasHit(int timeSpan) {
    return Game.time().since(this.lastHit) < timeSpan;
}@Override
  public void hit(final int damage, @Nullable final Ability ability) {
    if (this.isDead()) {
      return;
    }

    if (!this.isIndestructible()) {
      this.getHitPoints().modifyBaseValue(new AttributeModifier<>(Modification.SUBTRACT, damage));
    }

    final EntityHitEvent event = new EntityHitEvent(this, ability, damage, this.isDead());

    for (final CombatEntityListener listener : this.listeners) {
      listener.hit(event);
    }

    for (final CombatEntityHitListener listener : this.hitListeners) {
      listener.hit(event);
    }

    if (this.isDead()) {
      this.fireDeathEvent();
      this.setCollision(false);
    }

    this.lastHit = Game.time().now();
}
}
```
```java
class de.gurkenlabs.litiengine.graphics.ImageEffect {
protected ImageEffect(final int ttl, final String name) {
    this.ttl = ttl;
    this.name = name;
    this.aliveTick = Game.time().now();
}@Override
  public long getAliveTime() {
    return Game.time().since(this.aliveTick);
}
}
```
```java
class de.gurkenlabs.litiengine.abilities.AbilityExecution {
AbilityExecution(final Ability ability) {
    this.appliedEffects = new CopyOnWriteArrayList<>();
    this.ability = ability;
    this.executionTicks = Game.time().now();
    this.impactArea = ability.calculateImpactArea();
    this.castLocation = ability.getExecutor().getCenter();
    Game.loop().attach(this);
}@Override
  public void update() {
    // if there a no effects to apply -> unregister this instance and we're done
    if (this.getAbility().getEffects().isEmpty()
        || this.getAbility().getEffects().size() == this.getAppliedEffects().size()) {
      Game.loop().detach(this);
      return;
    }

    // handle all effects from the ability that were not applied yet
    for (final Effect effect : this.getAbility().getEffects()) {
      // if the ability was not executed yet or the delay of the effect is not
      // yet reached
      if (this.getAppliedEffects().contains(effect)
          || Game.time().since(this.getExecutionTicks()) < effect.getDelay()) {
        continue;
      }

      effect.apply(this.getExecutionImpactArea());
      this.getAppliedEffects().add(effect);
    }
}
}
```
```java
class de.gurkenlabs.litiengine.tweening.TweenEngine {
@Override
  public void update() {
    for (final Tweenable target : this.getTweens().keySet()) {
      for (final Tween tween : this.getTweens().get(target).values()) {
        if (tween.hasStopped()) {
          continue;
        }
        final long elapsed = Game.time().since(tween.getStartTime());
        if (elapsed >= tween.getDuration()) {
          tween.stop();
          continue;
        }
        final float[] currentValues = new float[tween.getTargetValues().length];
        for (int i = 0; i < tween.getTargetValues().length; i++) {
          currentValues[i] =
              tween.getStartValues()[i]
                  + tween.getEquation().compute(elapsed / (float) tween.getDuration())
                      * (tween.getTargetValues()[i] - tween.getStartValues()[i]);
        }
        tween.getTarget().setTweenValues(tween.getType(), currentValues);
      }
    }
}
}
```
```java
class de.gurkenlabs.litiengine.gui.SpeechBubble {
public static SpeechBubble create(
      final IEntity entity, final String text, SpeechBubbleAppearance appearance, Font font) {
    return new SpeechBubble(entity, text, appearance, font);
}public static SpeechBubble create(final IEntity entity, final Font font, final String text) {
    SpeechBubbleAppearance app =
        new SpeechBubbleAppearance(
            DEFAULT_APPEARANCE.getForeColor(),
            DEFAULT_APPEARANCE.getBackgroundColor1(),
            DEFAULT_APPEARANCE.getBorderColor(),
            DEFAULT_APPEARANCE.getPadding());
    return new SpeechBubble(entity, text, app, font);
}public static SpeechBubble create(final IEntity entity, final String text) {
    return new SpeechBubble(entity, text, null, GuiProperties.getDefaultFont());
}@Override
  public void update() {
    if (this.currentText == null) {
      this.hide();
      return;
    }

    this.entityCenter = Game.world().camera().getViewportLocation(this.getEntity().getCenter());

    // old text was displayed long enough
    if (this.lastTextDisplay != 0
        && Game.time().since(this.lastTextDisplay) > this.currentTextDisplayTime) {
      this.currentText = null;
      this.lastTextDisplay = 0;
      return;
    }

    // display new text
    if (this.textIndex < this.currentText.length()
        && Game.time().since(this.lastCharPoll) > LETTER_WRITE_DELAY) {
      this.textIndex++;
      this.lastCharPoll = Game.time().now();
      if (this.typeSound != null) {
        Game.audio().playSound(this.typeSound, this.getEntity());
      }
    }

    // continue displaying currently displayed text
}private SpeechBubble(
      final IEntity entity,
      final String text,
      final Sound typeSound,
      SpeechBubbleAppearance appearance,
      Font font) {
    this(entity, text, appearance, font);
    this.typeSound = typeSound;
}private SpeechBubble(
      final IEntity entity,
      final String text,
      @Nullable SpeechBubbleAppearance appearance,
      @Nullable Font font) {
    if (appearance == null) {
      this.appearance = DEFAULT_APPEARANCE;
    } else {
      this.appearance = appearance;
    }

    final SpeechBubble active = activeSpeechBubbles.get(entity);
    if (active != null) {
      active.hide();
    }
    this.setFont(font);

    this.textBoxWidth = (float) (entity.getWidth() * 4);
    this.entity = entity;

    this.currentText = text;
    this.currentTextDisplayTime = DISPLAYTIME_MIN + text.length() * DISPLAYTIME_PER_LETTER;

    this.lastTextDisplay = Game.time().now();
    this.createBubbleImage();
    entity.getEnvironment().add(this, RenderType.UI);
    Game.loop().attach(this);
    activeSpeechBubbles.put(entity, this);
}
}
```
```java
class de.gurkenlabs.litiengine.gui.TextFieldComponent {
@Override
  public void render(final Graphics2D g) {
    super.render(g);
    g.setFont(this.getFont());
    final FontMetrics fm = g.getFontMetrics();

    if (this.isSelected() && Game.time().since(this.lastToggled) > this.flickerDelay) {
      this.cursorVisible = !this.cursorVisible;
      this.lastToggled = Game.time().now();
    }
    if (this.isSelected() && this.cursorVisible) {
      final Rectangle2D cursor =
          new Rectangle2D.Double(
              this.getX() + this.getTextX() + fm.stringWidth(this.getTextToRender(g)),
              this.getY() + this.getTextY(),
              this.getFont().getSize2D() * 3 / 5,
              this.getFont().getSize2D() * 1 / 5);
      g.setColor(this.getAppearance().getForeColor());
      g.fill(cursor);
    }
}
}
```
```java
class de.gurkenlabs.litiengine.entities.Prop {
public Prop(
      final Point2D location, @Nullable final String spritesheetName, final Material material) {
    super();
    this.rotation = Rotation.NONE;
    this.spritesheetName = spritesheetName;
    this.material = material;
    this.setLocation(location);
    this.updateAnimationController();
}public void setSpritesheetName(@Nullable final String spriteName) {
    this.spritesheetName = spriteName;
    this.updateAnimationController();
}
}
```
```java
class de.gurkenlabs.litiengine.tweening.Tween {
public Tween begin() {
    this.started = Game.time().now();
    this.stopped = false;
    return this;
}
}
```
```java
class de.gurkenlabs.litiengine.graphics.emitters.particles.Particle {
public void update(final Point2D emitterOrigin, final float updateRatio) {
    if (this.aliveTick == 0) {
      this.aliveTick = Game.time().now();
    }

    this.aliveTime = Game.time().since(this.aliveTick);
    if (this.timeToLiveReached()) {
      return;
    }

    if (this.colliding) {
      return;
    }

    if (this.getDeltaWidth() != 0) {
      this.width += this.getDeltaWidth() * updateRatio;
    }

    if (this.getDeltaHeight() != 0) {
      this.height += this.getDeltaHeight() * updateRatio;
    }

    if (this.getDeltaAngle() != 0) {
      this.angle += this.getDeltaAngle() * updateRatio;
    }

    // test for ray cast collision
    final float targetX = this.x + this.getVelocityX() * updateRatio;
    final float targetY = this.y + this.getVelocityY() * updateRatio;

    if (targetX == this.x && targetY == this.y) {
      return;
    }

    if (this.checkForCollision(emitterOrigin, targetX, targetY)) {
      return;
    }

    if (this.getVelocityX() != 0) {
      this.x = targetX;
    }

    if (this.getVelocityY() != 0) {
      this.y = targetY;
    }

    if (this.getAccelerationX() != 0) {
      this.velocityX += this.getAccelerationX() * updateRatio;
    }

    if (this.getAccelerationY() != 0) {
      this.velocityY += this.getAccelerationY() * updateRatio;
    }
}
}
```
```java
class de.gurkenlabs.litiengine.graphics.animation.Animation {
@Override
  public void start() {
    this.playing = true;
    if (this.getKeyframes().isEmpty()) {
      return;
    }

    this.restart();
}@Override
  public void update() {
    // do nothing if the animation is not playing or the current keyframe is not finished
    if (!this.isPlaying()
        || Game.time().since(this.lastFrameUpdate) < this.getCurrentKeyFrame().getDuration()) {
      return;
    }

    // if we are not looping and the last keyframe is finished, we terminate the animation
    if (!this.isLooping() && this.isLastKeyFrame()) {
      this.terminate();
      return;
    }

    // make sure, we stay inside the keyframe list
    final int newFrameIndex =
        (this.getKeyframes().indexOf(this.currentFrame) + 1) % this.getKeyframes().size();
    final KeyFrame previousFrame = this.currentFrame;
    this.currentFrame = this.getKeyframes().get(newFrameIndex);

    for (KeyFrameListener listener : this.listeners) {
      listener.currentFrameChanged(previousFrame, this.currentFrame);
    }

    this.lastFrameUpdate = Game.loop().getTicks();
}
}
```
```java
class de.gurkenlabs.litiengine.graphics.animation.AnimationController {
@Override
  public void update() {
    for (final Animation animation : this.getAll()) {
      animation.update();
    }

    if (this.getCurrent() != null && this.getCurrent().isPaused()) {
      return;
    }

    final boolean playbackFinished = this.getCurrent() != null && !this.getCurrent().isPlaying();
    if (playbackFinished) {
      for (final AnimationListener listener : this.listeners) {
        listener.finished(this.getCurrent());
      }
    }

    if (this.getCurrent() == null || playbackFinished) {
      if (this.getDefault() != null) {
        this.play(this.getDefault().getName());
      } else {
        this.currentAnimation = null;
      }
    }
}
}
```
```java
class de.gurkenlabs.litiengine.graphics.RenderComponent {
private void handleFade() {
    if (this.fadeOutStart != -1) {
      final long timePassed = Game.time().since(this.fadeOutStart);
      this.currentAlpha = MathUtilities.clamp(1 - timePassed / (float) this.fadeOutTime, 0, 1);
      if (this.currentAlpha == 0f) {
        this.fadeOutStart = -1;
        this.fadeOutTime = -1;
      }

      return;
    }

    if (this.fadeInStart != -1) {
      final long timePassed = Game.time().since(this.fadeInStart);
      this.currentAlpha = MathUtilities.clamp(timePassed / (float) this.fadeInTime, 0, 1);
      if (this.currentAlpha == 1f) {
        this.fadeInStart = -1;
        this.fadeInTime = -1;
        this.currentAlpha = Float.NaN;
      }
    }
}public void fadeOut(final int ms) {
    this.fadeInStart = -1;
    this.fadeInTime = -1;
    this.fadeOutStart = Game.time().now();
    this.fadeOutTime = ms;
}public void fadeIn(final int ms) {
    this.fadeOutStart = -1;
    this.fadeOutTime = -1;
    this.fadeInStart = Game.time().now();
    this.fadeInTime = ms;
}
}
```
```java
class de.gurkenlabs.litiengine.entities.Trigger {
private boolean activate(final IEntity activator, final int tar) {
    if (!this.isLoaded()
        || this.isOneTimeTrigger && this.isActivated
        || this.getActivationType() == TriggerActivation.COLLISION
            && activator != null
            && this.collisionActivated.contains(activator)) {
      return false;
    }

    if (this.getCooldown() > 0 && Game.time().since(this.lastActivation) < this.getCooldown()) {
      return false;
    }

    List<Integer> triggerTargets = this.getTargets(tar);

    final TriggerEvent te = new TriggerEvent(this, activator, triggerTargets);

    if (!this.checkActivationPredicates(te)) {
      return false;
    }

    this.isActivated = true;
    if (activator != null) {
      this.collisionActivated.add(activator);
    }

    // if we actually have a trigger target, we send the message to the target
    for (final int target : triggerTargets) {
      final IEntity entity = this.getEnvironment().get(target);
      if (entity == null) {
        log.log(
            Level.WARNING,
            "trigger [{0}] was activated, but the trigger target [{1}] could not be found on the environment",
            new Object[] {this, target});
        continue;
      }

      entity.sendMessage(this, this.message);
    }

    // also send the trigger event to all registered consumers
    for (final TriggerActivatedListener listener : this.activatedListeners) {
      listener.activated(te);
    }

    if (this.isOneTimeTrigger) {
      this.getEnvironment().remove(this);
    }

    this.lastActivation = Game.time().now();
    return true;
}
}
```
```java
class de.gurkenlabs.litiengine.graphics.Camera {
private boolean isShakeEffectActive() {
    return this.getShakeTick() != 0
        && Game.time().since(this.getShakeTick()) < this.getShakeDuration();
}@Override
  public void update() {
    if (Game.world().camera() != null && !Game.world().camera().equals(this)) {
      return;
    }

    if (this.targetZoom > 0) {
      if (Game.time().since(this.zoomTick) >= this.zoomDelay) {
        this.zoom = this.targetZoom;
        this.targetZoom = 0;
        this.zoomDelay = 0;
        this.zoomTick = 0;
        this.zoomStep = 0;
      } else {
        this.zoom += this.zoomStep;
      }

      final ZoomChangedEvent event = new ZoomChangedEvent(this, this.getZoom());
      for (final ZoomChangedListener listener : this.zoomListeners) {
        listener.zoomChanged(event);
      }
    }

    if (this.panTime > 0) {
      if (--this.panTime <= 0) {
        this.setFocus(this.targetFocus);
        this.targetFocus = null;
      } else {
        double diff = this.panTime / (this.panTime + 1.0);
        this.focus =
            new Point2D.Double(
                this.focus.getX() * diff + this.targetFocus.getX() * (1.0 - diff),
                this.focus.getY() * diff + this.targetFocus.getY() * (1.0 - diff));
      }
    }

    if (!this.isShakeEffectActive()) {
      this.shakeOffsetX = 0;
      this.shakeOffsetY = 0;
      return;
    }

    if (Game.time().since(this.lastShake) > this.shakeDelay) {
      this.shakeOffsetX = this.getShakeIntensity() * ThreadLocalRandom.current().nextGaussian();
      this.shakeOffsetY = this.getShakeIntensity() * ThreadLocalRandom.current().nextGaussian();
      this.lastShake = Game.time().now();
    }
}@Override
  public void setZoom(final float targetZoom, final int delay) {
    if (delay == 0) {

      this.zoom = targetZoom;
      this.targetZoom = 0;
      this.zoomDelay = 0;
      this.zoomTick = 0;
      this.zoomStep = 0;

      final ZoomChangedEvent event = new ZoomChangedEvent(this, targetZoom);
      for (final ZoomChangedListener listener : this.zoomListeners) {
        listener.zoomChanged(event);
      }
    } else {
      this.zoomTick = Game.time().now();
      this.targetZoom = targetZoom;
      this.zoomDelay = delay;

      final double tickduration = 1000 / (double) Game.loop().getTickRate();
      final double tickAmount = delay / tickduration;
      final float totalDelta = this.targetZoom - this.zoom;
      this.zoomStep = tickAmount > 0 ? (float) (totalDelta / tickAmount) : totalDelta;
    }
}@Override
  public void shake(final double intensity, final int delay, final int shakeDuration) {
    this.shakeTick = Game.time().now();
    this.shakeDelay = delay;
    this.shakeIntensity = intensity;
    this.shakeDuration = shakeDuration;
}
}
```
```java
class de.gurkenlabs.litiengine.entities.Creature {
public void setSpritesheetName(String spritesheetName) {
    if (this.spritesheetName != null && this.spritesheetName.equals(spritesheetName)) {
      return;
    }

    this.spritesheetName = spritesheetName;
    this.updateAnimationController();
}public boolean isIdle() {
    return Game.time().since(this.lastMoved) > IDLE_DELAY;
}@Override
  public void setLocation(final Point2D position) {
    if (this.isDead() || position == null) {
      return;
    }

    final Point2D oldLocation = this.getLocation();
    super.setLocation(position);

    if (Game.hasStarted() && this.isLoaded()) {
      this.lastMoved = Game.time().now();
      this.fireMovedEvent(
          new EntityMovedEvent(
              this, this.getX() - oldLocation.getX(), this.getY() - oldLocation.getY()));
    }
}
}
```
```java
class de.gurkenlabs.litiengine.gui.screens.ScreenManager {
public void display(final String screenName) {
    if (this.current() != null && this.current().getName().equalsIgnoreCase(screenName)) {
      log.log(
          Level.INFO,
          "Skipping displaying of screen {0} because it is already the current screen.",
          screenName);
      return;
    }

    if (this.screens.stream()
        .noneMatch(element -> element.getName().equalsIgnoreCase(screenName))) {
      log.log(
          Level.WARNING,
          "Could not display the screen {0} because there is no screen with the specified name.",
          screenName);
      return;
    }

    Screen screen = this.get(screenName);
    if (screen == null) {
      return;
    }

    this.display(screen);
}public void add(final Screen screen) {
    screen.setWidth(Game.window().getWidth());
    screen.setHeight(Game.window().getHeight());
    this.screens.add(screen);

    if (this.current() == null) {
      this.display(screen);
    }
}public void remove(Screen screen) {
    this.screens.remove(screen);
    if (this.current() == screen) {
      if (!this.screens.isEmpty()) {
        this.display(this.screens.get(0));
      } else {
        this.display((Screen) null);
      }
    }
}public void display(@Nullable final Screen screen) {
    if (Game.hasStarted() && Game.time().since(this.lastScreenChange) < this.getChangeCooldown()) {
      log.log(
          Level.INFO,
          "Skipping displaying of screen {0} because screen changing is currently on cooldown.",
          screen != null ? screen.getName() : "");
      return;
    }

    final Screen previous = this.current();
    if (previous != null) {
      previous.suspend();
    }

    if (screen != null && !this.screens.contains(screen)) {
      this.screens.add(screen);
    }

    this.currentScreen = screen;
    if (!Game.isInNoGUIMode() && this.current() != null) {
      this.current().prepare();
    }

    this.lastScreenChange = Game.loop().getTicks();

    final ScreenChangedEvent event = new ScreenChangedEvent(this.current(), previous);
    for (final ScreenChangedListener listener : this.screenChangedListeners) {
      listener.changed(event);
    }
}
}
```
```java
class de.gurkenlabs.litiengine.abilities.Ability {
public boolean isOnCooldown() {
    return (this.getCurrentExecution() != null
        && this.getCurrentExecution().getExecutionTicks() > 0
        && Game.time().since(this.getCurrentExecution().getExecutionTicks())
            < this.getAttributes().cooldown().get());
}public boolean isActive() {
    return this.getCurrentExecution() != null
        && Game.time().since(this.getCurrentExecution().getExecutionTicks())
            < this.getAttributes().duration().get();
}@Nullable
  public AbilityExecution cast() {
    if (!this.canCast()) {
      return null;
    }
    this.currentExecution = new AbilityExecution(this);

    for (final AbilityCastListener listener : this.abilityCastListeners) {
      listener.abilityCast(this.currentExecution);
    }

    return this.getCurrentExecution();
}public float getRemainingCooldownInSeconds() {
    if (this.getCurrentExecution() == null
        || this.getExecutor() == null
        || this.getExecutor().isDead()) {
      return 0;
    }

    // calculate cooldown in seconds
    return (float)
        (!this.canCast()
            ? (this.getAttributes().cooldown().get()
                    - Game.time().since(this.getCurrentExecution().getExecutionTicks()))
                * 0.001
            : 0);
}
}
```
```java
class de.gurkenlabs.litiengine.entities.EntityHitEvent {
EntityHitEvent(
      final ICombatEntity hitEntity,
      @Nullable final Ability ability,
      final int damage,
      final boolean kill) {
    super(hitEntity);
    this.executor = ability != null ? ability.getExecutor() : null;
    this.hitEntity = hitEntity;
    this.ability = ability;
    this.damage = damage;
    this.kill = kill;
    this.time = Game.time().now();
}
}
```
```java
class de.gurkenlabs.litiengine.graphics.emitters.Emitter {
public void delete() {
    this.deactivate();
    if (Game.world().environment() != null) {
      Game.world().environment().remove(this);
    }
}public void activate() {
    if (this.activated) {
      return;
    }

    this.activated = true;
    this.activationTick = Game.time().now();
    Game.loop().attach(this);
}@Override
  public void update() {
    if (this.isPaused()) {
      return;
    }

    // clear particles if the effect time to life is reached
    if (this.isFinished()) {
      for (EmitterFinishedListener listener : this.finishedListeners) {
        listener.finished(this);
      }

      this.delete();
      return;
    }

    final float updateRatio = (float) this.data().getUpdateRate() / Game.loop().getTickRate();
    for (final Particle p : this.getParticles().stream().collect(Collectors.toList())) {
      if (this.particleCanBeRemoved(p)) {
        // remove dead particles
        this.particles.remove(p);
        continue;
      }

      p.update(this.getOrigin(), updateRatio);
    }

    this.aliveTime = Game.time().since(this.activationTick);
    if ((this.data().getSpawnRate() == 0
        || Game.time().since(this.lastSpawn) >= this.data().getSpawnRate())) {
      this.lastSpawn = Game.time().now();
      this.spawnParticle();
    }
}
}
```
```java
class de.gurkenlabs.litiengine.GameLoop {
@Override
  public int perform(int delay, Runnable action) {
    final long d = Game.time().toTicks(delay);

    TimedAction a = new TimedAction(this.getTicks() + d, action);
    this.actions.add(a);

    return a.getId();
}
}
```
```java
class de.gurkenlabs.litiengine.environment.EntitySpawner {
protected boolean shouldSpawn() {
    return this.lastSpawnWave == 0
        || Game.time().since(this.lastSpawnWave) >= this.getSpawnInterval();
}@Override
  public void update() {
    if (!this.shouldSpawn()) {
      return;
    }

    this.spawnNewEntities();
    this.lastSpawnWave = Game.time().now();
}
}
```
```java
class de.gurkenlabs.litiengine.graphics.FreeFlightCamera {
@Override
  public void update() {
    this.handleFreeFlightCamera();
}public FreeFlightCamera(double x, double y) {
    this(new Point2D.Double(x, y));
}
}
```
```java
class de.gurkenlabs.litiengine.environment.Environment {
public void unload() {
    if (!this.loaded) {
      return;
    }

    // unregister all updatable entities from the current environment
    for (final IEntity entity : this.allEntities.values()) {
      this.unload(entity);
    }

    this.loaded = false;
    this.fireEvent(l -> l.unloaded(this));
}private static void loadUpdatableOrEmitterEntity(IEntity entity) {
    if (entity instanceof Emitter) {
      final Emitter emitter = (Emitter) entity;
      if (emitter.isActivateOnInit()) {
        emitter.activate();
      }
    } else if (entity instanceof IUpdateable) {
      Game.loop().attach((IUpdateable) entity);
    }
}public void clear() {
    Game.physics().clear();

    this.combatEntities.clear();
    this.mobileEntities.clear();
    this.gravityForces.clear();
    this.layerEntities.clear();
    this.entitiesByTag.clear();
    this.allEntities.clear();

    for (RenderType renderType : RenderType.values()) {
      this.miscEntities.get(renderType).clear();
      this.renderListeners.get(renderType).clear();
      this.renderables.get(renderType).clear();
    }

    dispose(this.allEntities.values());
    dispose(this.triggers);
    this.emitters.clear();
    this.colliders.clear();
    this.props.clear();
    this.creatures.clear();
    this.staticShadows.clear();
    this.combatEntities.clear();
    this.mobileEntities.clear();
    this.lightSources.clear();
    this.spawnPoints.clear();
    this.soundSources.clear();
    this.mapAreas.clear();
    this.triggers.clear();

    this.ambientLight = null;
    this.staticShadowLayer = null;

    for (Map<Integer, IEntity> type : this.miscEntities.values()) {
      type.clear();
    }

    this.initialized = false;

    this.fireEvent(l -> l.cleared(this));
}private void load(final IEntity entity) {
    // an entity can only exist on one environment at a time, so remove it from the current one
    if (entity.getEnvironment() != null) {
      entity.getEnvironment().remove(entity);
    }

    // 1. add to physics engine
    loadPhysicsEntity(entity);

    // 2. register for update or activate
    loadUpdatableOrEmitterEntity(entity);

    // 3. if a gravity is defined, add a gravity force to the entity
    if (entity instanceof IMobileEntity && this.getGravity() != 0) {
      this.addGravityForce((IMobileEntity) entity);
    }

    // 4. attach all controllers
    entity.attachControllers();

    if (this.loaded && (entity instanceof LightSource || entity instanceof StaticShadow)) {
      this.updateLighting(entity);
    }

    entity.loaded(this);
}private void unload(final IEntity entity) {
    // 1. remove from physics engine
    if (entity instanceof ICollisionEntity) {
      Game.physics().remove((ICollisionEntity) entity);
    }

    // 2. unregister from update
    if (entity instanceof IUpdateable) {
      Game.loop().detach((IUpdateable) entity);
    }

    if (entity instanceof IMobileEntity) {
      this.removeGravity((IMobileEntity) entity);
    }

    // 3. detach all controllers
    entity.detachControllers();

    if (entity instanceof Emitter) {
      Emitter em = (Emitter) entity;
      em.deactivate();
    }

    if (this.loaded && (entity instanceof LightSource || entity instanceof StaticShadow)) {
      this.updateLighting(entity);
    }

    entity.removed(this);
}public void remove(final IEntity entity) {
    if (entity == null) {
      return;
    }

    this.allEntities.remove(entity.getMapId());
    Iterator<List<IEntity>> iter = this.layerEntities.values().iterator();
    while (iter.hasNext()) {
      List<IEntity> layer = iter.next();
      if (layer.remove(entity) && layer.isEmpty()) {
        iter.remove();
      }
    }
    if (this.miscEntities.get(entity.getRenderType()) != null) {
      this.miscEntities.get(entity.getRenderType()).values().remove(entity);
    }

    for (String tag : entity.getTags()) {
      if (this.getEntitiesByTag().containsKey(tag)) {
        this.getEntitiesByTag().get(tag).remove(entity);

        if (this.getEntitiesByTag().get(tag).isEmpty()) {
          this.getEntitiesByTag().remove(tag);
        }
      }
    }

    if (entity instanceof Emitter) {
      Emitter emitter = (Emitter) entity;
      this.removeEmitter(emitter);
    }

    if (entity instanceof MapArea) {
      this.mapAreas.remove(entity);
    }

    if (entity instanceof Prop) {
      this.props.remove(entity);
    }

    if (entity instanceof Creature) {
      this.creatures.remove(entity);
    }

    if (entity instanceof CollisionBox) {
      this.colliders.remove(entity);
      this.staticShadows.removeIf(x -> x.getOrigin() != null && x.getOrigin().equals(entity));
    }

    if (entity instanceof LightSource) {
      this.lightSources.remove(entity);
      this.updateLighting(entity);
    }

    if (entity instanceof Trigger) {
      this.triggers.remove(entity);
    }

    if (entity instanceof Spawnpoint) {
      this.spawnPoints.remove(entity);
    }
    if (entity instanceof SoundSource) {
      this.soundSources.remove(entity);
    }

    if (entity instanceof StaticShadow) {
      this.staticShadows.remove(entity);
      this.updateLighting(entity);
    }

    if (entity instanceof IMobileEntity) {
      this.mobileEntities.values().remove(entity);
    }

    if (entity instanceof ICombatEntity) {
      this.combatEntities.values().remove(entity);
    }

    this.unload(entity);

    this.fireEntityEvent(l -> l.entityRemoved(entity));
}
}
```
```java
class de.gurkenlabs.litiengine.physics.MovementController {
@Override
  public void update() {
    this.handleForces();
    this.handleMovement();
}
}
```
```java
class de.gurkenlabs.litiengine.Game {
static synchronized void terminate() {
    if (!initialized) {
      return;
    }

    hasStarted = false;
    initialized = false;

    config().save();
    gameLoop.terminate();
    tweenEngine.terminate();
    soundEngine.terminate();

    world().clear();

    for (final GameListener listener : gameListeners) {
      try {
        listener.terminated();
      } catch (Exception e) {
        log().log(Level.WARNING, "game listener threw an exception during shutdown", e);
      }
    }

    gameLoop = null;
    screenManager = null;
    gameWindow = null;
}public static synchronized void start() {
    if (!initialized) {
      throw new IllegalStateException(
          "The game cannot be started without being first initialized. Call Game.init(...) before Game.start().");
    }

    gameLoop.start();
    tweenEngine.start();
    soundEngine.start();

    for (final GameListener listener : gameListeners) {
      listener.started();
    }

    hasStarted = true;
}public static synchronized void init(String... args) {
    if (initialized) {
      log().log(Level.INFO, "The game has already been initialized.");
      return;
    }

    log.init();
    handleCommandLineArguments(args);

    config().load();
    Locale.setDefault(new Locale(config().client().getCountry(), config().client().getLanguage()));

    gameLoop = new GameLoop("Main Update Loop", config().client().getMaxFps());
    loop().attach(physics());
    loop().attach(world());

    // setup default exception handling for render and update loop
    setUncaughtExceptionHandler(
        new DefaultUncaughtExceptionHandler(config().client().exitOnError()));

    screenManager = new ScreenManager();
    gameWindow = new GameWindow();

    // initialize  the game window
    window().init();
    world.setCamera(new Camera());

    for (GameListener listener : gameListeners) {
      listener.initialized(args);
    }

    if (!isInNoGUIMode()) {
      window().getRenderComponent().onRendered(g -> metrics().render(g));

      graphics()
          .addEntityRenderedListener(
              e -> DebugRenderer.renderEntityDebugInfo(e.getGraphics(), e.getEntity()));

      window().getRenderComponent().onFpsChanged(fps -> metrics().setFramesPerSecond(fps));
      window()
          .setIcons(
              Arrays.asList(
                  Resources.images().get("liti-logo-x16.png"),
                  Resources.images().get("liti-logo-x20.png"),
                  Resources.images().get("liti-logo-x32.png"),
                  Resources.images().get("liti-logo-x48.png")));

      Input.keyboard()
          .onKeyTyped(
              KeyEvent.VK_PRINTSCREEN,
              key -> {
                // don't take a screenshot if a modifier is active
                if (key.getModifiers() != 0) {
                  return;
                }

                window().getRenderComponent().takeScreenshot();
              });
    }

    Runtime.getRuntime().addShutdownHook(new Thread(Game::terminate, "Shutdown"));

    initialized = true;
}
}
```


Response Format:
Provide the answer in **XML format** as follows:

#### If the method **cannot** return `null` at the specific call site:
```xml
<response>
  <reason><![CDATA[EXPLAIN WHY THE INVOCATION Game.loop() RESULT CANNOT BE NULL.]]></reason>
  <value>NO</value>
</response>

#### If the method can return null at the specific call site:
<response>
  <reason><![CDATA[EXPLAIN WHY THE INVOCATION Game.loop() RESULT CAN BE NULL.]]></reason>
  <value>YES</value>
</response>

#### If you are unsure or If there are any methods that directly or indirectly affect the return value and are not fully disclosed, request their declarations first, in the following format:
<response>
  <reason><![CDATA[EXPLAIN WHY THIS METHOD DECLARATION IS NECESSARY AND WHY YOU CANNOT MAKE A CONFIDENT DECISION WITHOUT IT]]></reason>
  <success>false</success>
  <methods>
    <method>methodName</method>
  </methods>
</response>

Additional Notes:
Be precise in your reasoning.
If a method’s return value depends on another method not provided, request its declaration before making a conclusion.
If the method can return null in this case but not in others, explain why it happens specifically for this call.

---ChatGPT.sendRequestToOpenAI---
Retrieving response from cache
---Response.<init>---
Creating Response:
```xml
<response>
  <reason><![CDATA[The method `Game.loop()` returns the static field `gameLoop`, which is initialized in the `Game.init(String... args)` method. In this method, a new `GameLoop` object is instantiated and assigned to `gameLoop`. Since `init()` must be called before `start()`, which is implied by the requirement of initializing the game, the `gameLoop` is guaranteed to be non-null during the lifetime of the game execution where `Game.loop()` is called. The absence of any code that could set `gameLoop` to null after its initialization ensures that `Game.loop()` cannot return null.]]></reason>
  <value>NO</value>
</response>
```
---Response.<init>---
Response created:
Disagreement: The method `Game.loop()` returns the static field `gameLoop`, which is initialized in the `Game.init(String... args)` method. In this method, a new `GameLoop` object is instantiated and assigned to `gameLoop`. Since `init()` must be called before `start()`, which is implied by the requirement of initializing the game, the `gameLoop` is guaranteed to be non-null during the lifetime of the game execution where `Game.loop()` is called. The absence of any code that could set `gameLoop` to null after its initialization ensures that `Game.loop()` cannot return null.
---AdvancedNullAwayCodeFix.resolveMethodDereferenceError---
Method is not returning nullable on call site. Injecting suppression annotation.
---AdvancedNullAwayCodeFix.constructCastToNonnullChange---
Constructing cast to nonnull change for reason: The method `Game.loop()` returns the static field `gameLoop`, which is initialized in the `Game.init(String... args)` method. In this method, a new `GameLoop` object is instantiated and assigned to `gameLoop`. Since `init()` must be called before `start()`, which is implied by the requirement of initializing the game, the `gameLoop` is guaranteed to be non-null during the lifetime of the game execution where `Game.loop()` is called. The absence of any code that could set `gameLoop` to null after its initialization ensures that `Game.loop()` cannot return null.
---ChatGPT.ask---
Asking ChatGPT:
For the reason you mentioned earlier:

"The method `Game.loop()` returns the static field `gameLoop`, which is initialized in the `Game.init(String... args)` method. In this method, a new `GameLoop` object is instantiated and assigned to `gameLoop`. Since `init()` must be called before `start()`, which is implied by the requirement of initializing the game, the `gameLoop` is guaranteed to be non-null during the lifetime of the game execution where `Game.loop()` is called. The absence of any code that could set `gameLoop` to null after its initialization ensures that `Game.loop()` cannot return null."

in the method below, the expression Game.loop() is not nullable at the point it is used.

```java
public void activate() {
    if (this.activated) {
      return;
    }

    this.activated = true;
    this.activationTick = Game.time().now();
    Game.loop().attach(this);
}
```
Please Summarize the reason in max 5 words and rewrite the method so that at the line "    Game.loop().attach(this);", at the occurrence of: "Game.loop()" is replaced with `NullabilityUtil.castToNonnull(Game.loop(), summary of reason)`
Replace "REASON" with the exact reason summary I provide to you (maximum 5 words), not with a generic explanation like "checked to be nonnull".
see the example below, for expression `foo.getBar()`, to wrap it with `NullabilityUtil.castToNonnull(foo.getBar(), "reason")`.

```java
public t(){
    String l = foo.getBar();
}
```

will be:
```java
public t(){
    String l = NullabilityUtil.castToNonnull(foo.getBar(), "checked to be nonnull");
}
```

### Instructions:

Do not import any additional classes.

Do not add Java comments.

Only modify relevant lines as required.

Return only the modified method wrapped in the XML format shown below.

Place the Java code inside the <code> tag using a CDATA block with ```java formatting.

Just give me the fixed code snippet in XML format in <response> tag like the example below. I will apply the fix to my codebase. Do not import any additional libraries or classes or add java comments. If you can provide the fixed code snippet, please provide it in the following format and place the code snippet in the <code> tag within ```java block.
<response>
  <success>true</success>
  <code><![CDATA[
  ```java
  Your fixed code snippet here
  ```
    ]]>
  </code>
</response>

---ChatGPT.sendRequestToOpenAI---
Sending request to OpenAI...
---ChatGPT.sendRequestToOpenAI---
Response received from OpenAI.
---Response.<init>---
Creating Response:
Here is the fixed code snippet in the requested format:

<response>
  <success>true</success>
  <code><![CDATA[
  ```java
  public void activate() {
      if (this.activated) {
        return;
      }

      this.activated = true;
      this.activationTick = Game.time().now();
      NullabilityUtil.castToNonnull(Game.loop(), "initialized before access").attach(this);
  }
  ```
  ]]>
  </code>
</response>
---Response.<init>---
Response created:
public void activate() {
      if (this.activated) {
        return;
      }

      this.activated = true;
      this.activationTick = Game.time().now();
      NullabilityUtil.castToNonnull(Game.loop(), "initialized before access").attach(this);
  }
---ChatGPT.fixDereferenceByAddingCastToNonnull---
Fixing the error by adding castToNonnull
---AdvancedNullAwayCodeFix.fixTriggeredErrorsForLocation---
Resolving unresolvable error for triggered error: Type='DEREFERENCE_NULLABLE', message='dereferenced expression Game.loop() is @Nullable'
/home/nima/Developer/nullness-benchmarks/litiengine/src/de/gurkenlabs/litiengine/graphics/emitters/Emitter.java:316
    final float updateRatio = (float) this.data().getUpdateRate() / Game.loop().getTickRate();
---AdvancedNullAwayCodeFix.fix---
Fixing error: Type='DEREFERENCE_NULLABLE', message='dereferenced expression Game.loop() is @Nullable'
/home/nima/Developer/nullness-benchmarks/litiengine/src/de/gurkenlabs/litiengine/graphics/emitters/Emitter.java:316
    final float updateRatio = (float) this.data().getUpdateRate() / Game.loop().getTickRate();
---AdvancedNullAwayCodeFix.resolveDereferenceError---
Resolving dereference error: Type='DEREFERENCE_NULLABLE', message='dereferenced expression Game.loop() is @Nullable'
/home/nima/Developer/nullness-benchmarks/litiengine/src/de/gurkenlabs/litiengine/graphics/emitters/Emitter.java:316
    final float updateRatio = (float) this.data().getUpdateRate() / Game.loop().getTickRate();
---AdvancedNullAwayCodeFix.resolveDereferenceError---
Checking nullability possibility at error point
---ChatGPT.checkNullabilityPossibilityAtErrorPoint---
Asking if the expression can be null at error point point
---ChatGPT.ask---
Asking ChatGPT:
In the method below, is there a possibility that the expression "Game.loop()" at line "final float updateRatio = (float) this.data().getUpdateRate() / Game.loop().getTickRate();" is null?
@Override
  public void update() {
    if (this.isPaused()) {
      return;
    }

    // clear particles if the effect time to life is reached
    if (this.isFinished()) {
      for (EmitterFinishedListener listener : this.finishedListeners) {
        listener.finished(this);
      }

      this.delete();
      return;
    }

    final float updateRatio = (float) this.data().getUpdateRate() / Game.loop().getTickRate();
    for (final Particle p : this.getParticles().stream().collect(Collectors.toList())) {
      if (this.particleCanBeRemoved(p)) {
        // remove dead particles
        this.particles.remove(p);
        continue;
      }

      p.update(this.getOrigin(), updateRatio);
    }

    this.aliveTime = Game.time().since(this.activationTick);
    if ((this.data().getSpawnRate() == 0
        || Game.time().since(this.lastSpawn) >= this.data().getSpawnRate())) {
      this.lastSpawn = Game.time().now();
      this.spawnParticle();
    }
}
Give a single-word answer in XML format. If it is possible for the expression to be null, respond with:
```xml
<response>
    <reason><![CDATA[YOUR REASON]]></reason>
    <value>YES</value>
</response>
```
If it is not possible for the expression to be null, respond with:
```xml
<response>
    <reason><![CDATA[YOUR REASON]]></reason>
    <value>NO</value>
</response>
```
If you are unsure or need more information, respond with where you can ask for more details or what specific information you need.

If additional information is required, list each request inside a `<request>` tag. If no additional information is needed, omit the `<requests>` section.

Respond with:
```xml
<response>
    <reason><![CDATA[YOUR REASON]]></reason>
    <value>UNKNOWN</value>
    <!-- Include <requests> only if additional information is needed -->
    <requests>
        <request><![CDATA[YOUR REQUEST 1]]></request>
        <request><![CDATA[YOUR REQUEST 2]]></request>
    </requests>
</response>
```
---ChatGPT.sendRequestToOpenAI---
Sending request to OpenAI...
---ChatGPT.sendRequestToOpenAI---
Response received from OpenAI.
---Response.<init>---
Creating Response:
```xml
<response>
    <reason><![CDATA[The possibility of `Game.loop()` being null depends on how the `Game` class and its `loop()` method are implemented. Without additional context or implementation details of the `Game` class, it is unclear whether `Game.loop()` can return null.]]></reason>
    <value>UNKNOWN</value>
    <requests>
        <request><![CDATA[Provide the implementation or documentation of the `Game` class, specifically focusing on the `loop()` method and its return value.]]></request>
    </requests>
</response>
```
---Response.<init>---
Response created:
Unknown: The possibility of `Game.loop()` being null depends on how the `Game` class and its `loop()` method are implemented. Without additional context or implementation details of the `Game` class, it is unclear whether `Game.loop()` can return null.
---AdvancedNullAwayCodeFix.resolveMethodDereferenceError---
Resolving method dereference error.
---AdvancedNullAwayCodeFix.resolveMethodDereferenceError---
Method is in annotated package. Checking if the method is returning nullable.
---AdvancedNullAwayCodeFix.investigateMethodReturnNullability---
Checking if the method is returning nullable.
---ChatGPT.checkIfMethodIsReturningNullable---
Asking if the method is returning nullable: loop()
---ChatGPT.ask---
Asking ChatGPT:
In the method below, is there a possibility that the method returns null based only on its body? Consider the following points:

- The method may have multiple return paths; consider all return statements.
- If the method calls another method, do not assume its return value unless its full declaration is provided. Request its declaration if needed.
- The method may throw an exception instead of returning null. An exception path should not be considered a null return.
- Ensure you request the declarations of any methods whose return values directly or indirectly impact this method’s return value before making a conclusion.
- Carefully analyze all conditions and prior operations that may guarantee a non-null return value.

@Nullable public static IGameLoop loop() {
    return gameLoop;
}

Here are the method definitions in addition to the method inquired:

Depth: 0
```java
class de.gurkenlabs.litiengine.Game {
@Nullable public static IGameLoop loop() {
    return gameLoop;
}
}
```


Response Format:
Provide the answer in **XML format** as follows:

#### If the method **cannot** return `null`:
```xml
<response>
  <reason><![CDATA[EXPLAIN WHY THE METHOD CANNOT RETURN NULL]]></reason>
  <value>NO</value>
</response>
```

#### If the method can return null:
```xml
<response>
  <reason><![CDATA[EXPLAIN WHY THE METHOD CAN RETURN NULL]]></reason>
  <value>YES</value>
</response>
```

#### If you are unsure or need more information, respond with where you can ask for more details or what specific information you need.

#### If you are unsure or If there are any methods that directly or indirectly affect the return value and are not fully disclosed, request their declarations first, in the following format:
<response>
  <reason><![CDATA[YOUR REASON]]></reason>
  <value>UNKNOWN</value>
  <methods>
    <method>methodName</method>
  </methods>
</response>

If additional information is required other than method declaration, list each request inside a `<request>` tag. If no additional information is needed, omit the `<requests>` section.

Respond with:
```xml
<response>
    <reason><![CDATA[YOUR REASON]]></reason>
    <value>UNKNOWN</value>
    <!-- Include <requests> only if additional information is needed -->
    <requests>
        <request><![CDATA[YOUR REQUEST 1]]></request>
        <request><![CDATA[YOUR REQUEST 2]]></request>
    </requests>
</response>
```

Additional Notes:
Be precise in your reasoning.
If a method’s return value depends on another method not provided, request its declaration before making a conclusion.
If the method can return null in some cases but not others, explain under what conditions it can happen.

---ChatGPT.sendRequestToOpenAI---
Retrieving response from cache
---Response.<init>---
Creating Response:
```xml
<response>
  <reason><![CDATA[The method `loop` returns the variable `gameLoop`. Without the initialization or assignment details of `gameLoop`, it's unclear whether it can be null. The possibility of `gameLoop` being uninitialized or set to null elsewhere in the program means `loop` could potentially return null. Further information on `gameLoop` is required.]]></reason>
  <value>UNKNOWN</value>
  <requests>
    <request><![CDATA[Please provide the declaration and initialization of the variable `gameLoop` in the class `de.gurkenlabs.litiengine.Game`.]]></request>
  </requests>
</response>
```
---Response.<init>---
Response created:
Unknown: The method `loop` returns the variable `gameLoop`. Without the initialization or assignment details of `gameLoop`, it's unclear whether it can be null. The possibility of `gameLoop` being uninitialized or set to null elsewhere in the program means `loop` could potentially return null. Further information on `gameLoop` is required.
---AdvancedNullAwayCodeFix.investigateMethodReturnNullability---
Could not determine the nullability and model did not ask for any method.
---ChatGPT.checkIfMethodIsReturningNullableOnCallSite---
Asking if the method is returning nullable on the call site: Game.loop()
---ChatGPT.ask---
Asking ChatGPT:
In the method below, is there a possibility that the method returns null at the given call site?

```java
@Nullable public static IGameLoop loop() {
    return gameLoop;
}
```

## Guidelines:
- The method may have multiple return paths; consider all return statements.
- If the method calls another method, do not assume its return value unless its full declaration is provided. Request its declaration if needed.
- The method may throw an exception instead of returning null. An exception path should not be considered a null return.
- Ensure you request the declarations of any methods whose return values directly or indirectly impact this method’s return value before making a conclusion.
- If the method returns a value that is determined by a parameter, evaluate based on the actual argument at the given call site.
- Analyze based only on the specific invocation provided. Do not generalize to all possible inputs.- If the return value is guaranteed to be non-null at the call site, the answer should be a definitive NO.
- Do not generalize based on all possible inputs—your answer must be based only on the given invocation.
- Focus only on the given call site, not all possible invocations.

### call site:
Game.loop()

Here are the method definitions and the call chain for this method, showing the sequence of calls from the method to its callers at each depth level:

Depth: 0
```java
class de.gurkenlabs.litiengine.Game {
@Nullable public static IGameLoop loop() {
    return gameLoop;
}
}
```
Depth: 1
```java
class de.gurkenlabs.litiengine.environment.GameWorld {
public void loadEnvironment(@Nullable final Environment env) {
    Lock lock = Game.loop().getLock();
    lock.lock();
    try {
      unloadEnvironment();
      this.environment = env;
      if (env != null) {
        this.addEnvironment(env);

        if (env.getGravity() == 0 && this.gravity() != 0) {
          env.setGravity(this.gravity());
        }

        env.load();
        for (final EnvironmentLoadedListener listener : this.loadedListeners) {
          listener.loaded(env);
        }

        // call map specific listeners
        String mapName = getMapName(env);
        if (mapName != null && this.environmentLoadedListeners.containsKey(mapName)) {

          // for the default camera we center the camera on the environment
          if (this.camera().getClass().equals(Camera.class)) {
            camera().setFocus(env.getCenter());
          }

          for (EnvironmentLoadedListener listener : this.environmentLoadedListeners.get(mapName)) {
            listener.loaded(env);
          }
        }
      }
    } finally {
      lock.unlock();
    }
}public void setCamera(@Nullable final ICamera cam) {
    if (this.camera() != null) {
      Game.loop().detach(camera);
    }

    camera = cam;

    if (cam != null && !Game.isInNoGUIMode()) {
      Game.loop().attach(cam);
      cam.updateFocus();
    }
}
}
```
```java
class de.gurkenlabs.litiengine.entities.behavior.EntityNavigator {
public EntityNavigator(final IMobileEntity entity, final PathFinder pathFinder) {
    this.cancelNavigationConditions = new CopyOnWriteArrayList<>();
    this.listeners = new CopyOnWriteArrayList<>();
    this.entity = entity;
    this.pathFinder = pathFinder;
    this.setAcceptableError(DEFAULT_ACCEPTABLE_ERROR);
    Game.loop().attach(this);
}
}
```
```java
class de.gurkenlabs.litiengine.GameWindow {
private static void initializeWindowEventListeners(Window window) {

    window.addWindowStateListener(
        e -> {
          if (e.getNewState() == Frame.ICONIFIED) {
            Game.loop().setTickRate(ICONIFIED_MAX_FPS);
          } else {
            Game.loop().setTickRate(Game.config().client().getMaxFps());
          }
        });

    window.addWindowFocusListener(
        new WindowFocusListener() {
          @Override
          public void windowLostFocus(WindowEvent e) {
            if (Game.config().graphics().reduceFramesWhenNotFocused()) {
              Game.loop().setTickRate(NONE_FOCUS_MAX_FPS);
            }
          }

          @Override
          public void windowGainedFocus(WindowEvent e) {
            Game.loop().setTickRate(Game.config().client().getMaxFps());
          }
        });

    window.addWindowListener(
        new WindowAdapter() {
          @Override
          public void windowClosing(final WindowEvent event) {
            Game.exit();
          }
        });
}
}
```
```java
class de.gurkenlabs.litiengine.gui.screens.ScreenManager {
public void display(@Nullable final Screen screen) {
    if (Game.hasStarted() && Game.time().since(this.lastScreenChange) < this.getChangeCooldown()) {
      log.log(
          Level.INFO,
          "Skipping displaying of screen {0} because screen changing is currently on cooldown.",
          screen != null ? screen.getName() : "");
      return;
    }

    final Screen previous = this.current();
    if (previous != null) {
      previous.suspend();
    }

    if (screen != null && !this.screens.contains(screen)) {
      this.screens.add(screen);
    }

    this.currentScreen = screen;
    if (!Game.isInNoGUIMode() && this.current() != null) {
      this.current().prepare();
    }

    this.lastScreenChange = Game.loop().getTicks();

    final ScreenChangedEvent event = new ScreenChangedEvent(this.current(), previous);
    for (final ScreenChangedListener listener : this.screenChangedListeners) {
      listener.changed(event);
    }
}
}
```
```java
class de.gurkenlabs.litiengine.abilities.effects.Effect {
@Override
  public void update() {

    for (final Iterator<EffectApplication> iterator = this.getActiveAppliances().iterator();
        iterator.hasNext(); ) {
      final EffectApplication appliance = iterator.next();
      // if the effect duration is reached
      if (this.hasEnded(appliance)) {

        iterator.remove();
        this.cease(appliance);
      }
    }

    // 4. unregister if all appliances are finished
    if (this.getActiveAppliances().isEmpty()) {
      Game.loop().detach(this);
    }
}public void apply(final Shape impactArea) {
    final List<ICombatEntity> affected = this.lookForAffectedEntities(impactArea);
    for (final ICombatEntity affectedEntity : affected) {
      this.apply(affectedEntity);
    }

    this.appliances.add(new EffectApplication(affected, impactArea));

    // if it is the first appliance -> register for update
    if (this.appliances.size() == 1) {
      Game.loop().attach(this);
    }
}
}
```
```java
class de.gurkenlabs.litiengine.GameTime {
public long toTicks(final int milliseconds) {
    return this.toTicks(milliseconds, Game.loop().getTickRate());
}public long since(final long tick) {
    return toMilliseconds(Game.loop().getTicks() - tick);
}public long now() {
    return Game.loop().getTicks();
}public long sinceGameStart() {
    return this.toMilliseconds(Game.loop().getTicks());
}@Override
  public void loaded(Environment environment) {
    environmentLoaded = Game.loop().getTicks();
}public long toMilliseconds(final long ticks) {
    return this.toMilliseconds(ticks, Game.loop().getTickRate());
}
}
```
```java
class de.gurkenlabs.litiengine.GameMetrics {
@Override
  public void render(final Graphics2D g) {
    this.updateMetrics();

    if (!Game.config().client().showGameMetrics()) {
      return;
    }

    this.currentOffsetY = 0;

    g.setColor(this.renderColor);

    // render client metrics
    this.drawTitle(g, "[client]");
    this.drawMetric(g, "fps       : " + this.getFramesPerSecond());
    this.drawMetric(g, "max fps   : " + this.maxFramesPerSecond);
    this.drawMetric(g, "updatables: " + Game.loop().getUpdatableCount());

    // render jvm metrics if debug is enabled
    if (Game.config().debug().isDebugEnabled()) {
      this.drawTitle(g, "[jvm]");
      this.drawMetric(g, "java      : " + this.javaVersion);
      this.drawMetric(g, "memory    : " + String.format("%-5.5s", this.usedMemory) + " MB");
      this.drawMetric(g, "threads   : " + Thread.activeCount());
    }

    // render rendering metrics
    if (!this.renderMetrics.isEmpty()) {
      this.drawTitle(g, "[update]");

      for (RenderMetrics metric : this.renderMetrics) {
        this.drawMetric(g, metric.toString());
      }

      this.renderMetrics.clear();
    }
}
}
```
```java
class de.gurkenlabs.litiengine.graphics.emitters.Emitter {
public void deactivate() {
    if (!this.activated) {
      return;
    }

    this.activated = false;
    this.getParticles().clear();
    this.aliveTime = 0;
    this.activationTick = 0;
    this.lastSpawn = 0;
    Game.loop().detach(this);
}public void activate() {
    if (this.activated) {
      return;
    }

    this.activated = true;
    this.activationTick = Game.time().now();
    Game.loop().attach(this);
}@Override
  public void update() {
    if (this.isPaused()) {
      return;
    }

    // clear particles if the effect time to life is reached
    if (this.isFinished()) {
      for (EmitterFinishedListener listener : this.finishedListeners) {
        listener.finished(this);
      }

      this.delete();
      return;
    }

    final float updateRatio = (float) this.data().getUpdateRate() / Game.loop().getTickRate();
    for (final Particle p : this.getParticles().stream().collect(Collectors.toList())) {
      if (this.particleCanBeRemoved(p)) {
        // remove dead particles
        this.particles.remove(p);
        continue;
      }

      p.update(this.getOrigin(), updateRatio);
    }

    this.aliveTime = Game.time().since(this.activationTick);
    if ((this.data().getSpawnRate() == 0
        || Game.time().since(this.lastSpawn) >= this.data().getSpawnRate())) {
      this.lastSpawn = Game.time().now();
      this.spawnParticle();
    }
}
}
```
```java
class de.gurkenlabs.litiengine.entities.behavior.IBehaviorController {
public default void attach() {
    Game.loop().attach(this);
}public default void detach() {
    Game.loop().detach(this);
}
}
```
```java
class de.gurkenlabs.litiengine.abilities.AbilityExecution {
AbilityExecution(final Ability ability) {
    this.appliedEffects = new CopyOnWriteArrayList<>();
    this.ability = ability;
    this.executionTicks = Game.time().now();
    this.impactArea = ability.calculateImpactArea();
    this.castLocation = ability.getExecutor().getCenter();
    Game.loop().attach(this);
}@Override
  public void update() {
    // if there a no effects to apply -> unregister this instance and we're done
    if (this.getAbility().getEffects().isEmpty()
        || this.getAbility().getEffects().size() == this.getAppliedEffects().size()) {
      Game.loop().detach(this);
      return;
    }

    // handle all effects from the ability that were not applied yet
    for (final Effect effect : this.getAbility().getEffects()) {
      // if the ability was not executed yet or the delay of the effect is not
      // yet reached
      if (this.getAppliedEffects().contains(effect)
          || Game.time().since(this.getExecutionTicks()) < effect.getDelay()) {
        continue;
      }

      effect.apply(this.getExecutionImpactArea());
      this.getAppliedEffects().add(effect);
    }
}
}
```
```java
class de.gurkenlabs.litiengine.GameWindow$3 {
@Override
          public void windowGainedFocus(WindowEvent e) {
            Game.loop().setTickRate(Game.config().client().getMaxFps());
}@Override
          public void windowLostFocus(WindowEvent e) {
            if (Game.config().graphics().reduceFramesWhenNotFocused()) {
              Game.loop().setTickRate(NONE_FOCUS_MAX_FPS);
            }
}
}
```
```java
class de.gurkenlabs.litiengine.environment.EntitySpawner {
protected void spawnNewEntities() {
    if (this.getSpawnMode() != SpawnMode.CUSTOMSPAWNPOINTS && this.getSpawnPoints().isEmpty()) {
      return;
    }

    switch (this.getSpawnMode()) {
      case ALLSPAWNPOINTS:
        for (int i = 0; i < this.getSpawnPoints().size(); i++) {
          final int index = i;
          Game.loop()
              .perform(
                  this.getSpawnDelay() + this.getSpawnDelay() * i,
                  () -> this.spawn(this.getSpawnPoints().get(index), this.getSpawnAmount()));
        }
        break;
      case ONERANDOMSPAWNPOINT:
        this.spawn(Game.random().choose(this.getSpawnPoints()), this.getSpawnAmount());
        break;
      case RANDOMSPAWNPOINTS:
        for (int i = 0; i < this.getSpawnAmount(); i++) {
          Game.loop()
              .perform(
                  this.getSpawnDelay() + this.getSpawnDelay() * i,
                  () -> this.spawn(Game.random().choose(this.getSpawnPoints()), 1));
        }
        break;
      case CUSTOMSPAWNPOINTS:
        List<Spawnpoint> spawnPoints =
            this.customSpawnpoints != null
                ? this.customSpawnpoints.apply(this)
                : this.getCustomSpawnpoints();

        int index = 0;
        for (Spawnpoint spawn : spawnPoints) {
          Game.loop()
              .perform(
                  this.getSpawnDelay() + this.getSpawnDelay() * index, () -> this.spawn(spawn, 1));
          index++;
        }
        break;
      default:
        break;
    }
}
}
```
```java
class de.gurkenlabs.litiengine.tweening.TweenEngine {
@Override
  public void start() {
    Game.loop().attach(this);
}@Override
  public void terminate() {
    Game.loop().detach(this);
}
}
```
```java
class de.gurkenlabs.litiengine.gui.SpeechBubble {
public void hide() {
    Game.world().environment().removeRenderable(this);
    Game.loop().detach(this);
    if (activeSpeechBubbles.get(this.getEntity()) != null
        && activeSpeechBubbles.remove(this.getEntity()).equals(this)) {
      activeSpeechBubbles.remove(this.getEntity());
    }

    for (SpeechBubbleListener listener : this.listeners) {
      listener.hidden();
    }
}private SpeechBubble(
      final IEntity entity,
      final String text,
      @Nullable SpeechBubbleAppearance appearance,
      @Nullable Font font) {
    if (appearance == null) {
      this.appearance = DEFAULT_APPEARANCE;
    } else {
      this.appearance = appearance;
    }

    final SpeechBubble active = activeSpeechBubbles.get(entity);
    if (active != null) {
      active.hide();
    }
    this.setFont(font);

    this.textBoxWidth = (float) (entity.getWidth() * 4);
    this.entity = entity;

    this.currentText = text;
    this.currentTextDisplayTime = DISPLAYTIME_MIN + text.length() * DISPLAYTIME_PER_LETTER;

    this.lastTextDisplay = Game.time().now();
    this.createBubbleImage();
    entity.getEnvironment().add(this, RenderType.UI);
    Game.loop().attach(this);
    activeSpeechBubbles.put(entity, this);
}
}
```
```java
class de.gurkenlabs.litiengine.entities.Prop {
private void updateAnimationController() {
    IEntityAnimationController<?> controller = this.createAnimationController();
    this.getControllers().addController(controller);
    if (Game.world().environment() != null && Game.world().environment().isLoaded()) {
      Game.loop().attach(controller);
    }
}
}
```
```java
class de.gurkenlabs.litiengine.graphics.FreeFlightCamera {
public FreeFlightCamera(final Point2D focus) {
    this.setFocus(focus);
    this.velocity = DEFAULT_SCROLL_PIXELS_PER_SECOND;
    this.scrollPadding = DEFAULT_SCROLL_PADDING;
    this.setClampToMap(true);

    Game.loop().attach(this);
}private void handleFreeFlightCamera() {
    if (Game.world().environment() == null || Game.world().environment().getMap() == null) {
      return;
    }

    final Point2D mouseLocation = Input.mouse().getLocation();

    final double scrollSpeed =
        this.getVelocity()
            / (double) Game.loop().getTickRate()
            * Game.config().input().getMouseSensitivity();

    double x = this.getFocus().getX();
    double y = this.getFocus().getY();

    double deltaX = 0;
    if (mouseLocation.getX() < this.getScrollPadding()) {
      deltaX -= scrollSpeed;
    } else if (Game.window().getResolution().getWidth() - mouseLocation.getX()
        < this.getScrollPadding()) {
      deltaX += scrollSpeed;
    }

    double deltaY = 0;
    if (mouseLocation.getY() < this.getScrollPadding()) {
      deltaY -= scrollSpeed;
    } else if (Game.window().getResolution().getHeight() - mouseLocation.getY()
        < this.getScrollPadding()) {
      deltaY += scrollSpeed;
    }

    x += deltaX;
    y += deltaY;

    this.setFocus(new Point2D.Double(x, y));
}
}
```
```java
class de.gurkenlabs.litiengine.environment.Environment {
private static void dispose(final Collection<? extends IEntity> entities) {
    for (final IEntity entity : entities) {
      if (entity instanceof IUpdateable) {
        Game.loop().detach((IUpdateable) entity);
      }

      entity.detachControllers();
    }
}private static void loadUpdatableOrEmitterEntity(IEntity entity) {
    if (entity instanceof Emitter) {
      final Emitter emitter = (Emitter) entity;
      if (emitter.isActivateOnInit()) {
        emitter.activate();
      }
    } else if (entity instanceof IUpdateable) {
      Game.loop().attach((IUpdateable) entity);
    }
}private void unload(final IEntity entity) {
    // 1. remove from physics engine
    if (entity instanceof ICollisionEntity) {
      Game.physics().remove((ICollisionEntity) entity);
    }

    // 2. unregister from update
    if (entity instanceof IUpdateable) {
      Game.loop().detach((IUpdateable) entity);
    }

    if (entity instanceof IMobileEntity) {
      this.removeGravity((IMobileEntity) entity);
    }

    // 3. detach all controllers
    entity.detachControllers();

    if (entity instanceof Emitter) {
      Emitter em = (Emitter) entity;
      em.deactivate();
    }

    if (this.loaded && (entity instanceof LightSource || entity instanceof StaticShadow)) {
      this.updateLighting(entity);
    }

    entity.removed(this);
}
}
```
```java
class de.gurkenlabs.litiengine.graphics.animation.Animation {
@Override
  public void update() {
    // do nothing if the animation is not playing or the current keyframe is not finished
    if (!this.isPlaying()
        || Game.time().since(this.lastFrameUpdate) < this.getCurrentKeyFrame().getDuration()) {
      return;
    }

    // if we are not looping and the last keyframe is finished, we terminate the animation
    if (!this.isLooping() && this.isLastKeyFrame()) {
      this.terminate();
      return;
    }

    // make sure, we stay inside the keyframe list
    final int newFrameIndex =
        (this.getKeyframes().indexOf(this.currentFrame) + 1) % this.getKeyframes().size();
    final KeyFrame previousFrame = this.currentFrame;
    this.currentFrame = this.getKeyframes().get(newFrameIndex);

    for (KeyFrameListener listener : this.listeners) {
      listener.currentFrameChanged(previousFrame, this.currentFrame);
    }

    this.lastFrameUpdate = Game.loop().getTicks();
}public void restart() {
    this.currentFrame = this.firstFrame;
    this.lastFrameUpdate = Game.loop().getTicks();
}
}
```
```java
class de.gurkenlabs.litiengine.physics.MovementController {
@Override
  public void attach() {
    Game.loop().attach(this);
}private void handleForces() {
    // clean up forces
    this.activeForces.forEach(
        x -> {
          if (x.hasEnded()) {
            this.activeForces.remove(x);
          }
        });

    if (this.activeForces.isEmpty()) {
      return;
    }

    // disable turn-on-move for force handling
    boolean turn = this.getEntity().turnOnMove();
    this.getEntity().setTurnOnMove(false);
    try {
      double deltaX = 0;
      double deltaY = 0;
      for (final Force force : this.activeForces) {
        if (force.cancelOnReached() && force.hasReached(this.getEntity())) {
          force.end();
          continue;
        }

        final Point2D collisionBoxCenter = this.getEntity().getCollisionBoxCenter();
        final double angle =
            GeometricUtilities.calcRotationAngleInDegrees(collisionBoxCenter, force.getLocation());
        final double strength =
            Game.loop().getDeltaTime() * 0.001f * force.getStrength() * Game.loop().getTimeScale();
        deltaX += GeometricUtilities.getDeltaX(angle, strength);
        deltaY += GeometricUtilities.getDeltaY(angle, strength);
      }

      final Point2D target =
          new Point2D.Double(this.getEntity().getX() + deltaX, this.getEntity().getY() + deltaY);
      final boolean success = Game.physics().move(this.getEntity(), target);
      if (!success) {
        for (final Force force : this.activeForces) {
          if (force.cancelOnCollision()) {
            force.end();
          }
        }
      }
    } finally {
      this.getEntity().setTurnOnMove(turn);
    }
}@Override
  public void detach() {
    Game.loop().detach(this);
}public void handleMovement() {
    if (!this.isMovementAllowed()) {
      this.velocity = 0;
      return;
    }

    // max distance an entity can travel within one tick
    final double maxPixelsPerTick = this.getEntity().getTickVelocity();
    final double deltaTime = Game.loop().getDeltaTime() * Game.loop().getTimeScale();

    final double acceleration =
        this.getEntity().getAcceleration() == 0
            ? maxPixelsPerTick
            : deltaTime / this.getEntity().getAcceleration() * maxPixelsPerTick;
    final double deceleration =
        this.getEntity().getDeceleration() == 0
            ? this.getVelocity()
            : deltaTime / this.getEntity().getDeceleration() * maxPixelsPerTick;

    double dx = this.getDx();
    double dy = this.getDy();
    this.setDx(0);
    this.setDy(0);

    final double deltaVelocity =
        Math.min(Math.sqrt(Math.pow(dx, 2) + Math.pow(dy, 2)), acceleration);
    if (deltaVelocity != 0) {
      double newVelocity = this.getVelocity() + deltaVelocity;
      this.setVelocity(newVelocity);
    } else {
      final double newVelocity = Math.max(0, this.getVelocity() - deceleration);
      this.setVelocity(newVelocity);
      dx = GeometricUtilities.getDeltaX(this.moveAngle);
      dy = GeometricUtilities.getDeltaY(this.moveAngle);
    }

    if (this.getVelocity() == 0) {
      this.moveAngle = 0;
      return;
    }

    // actually move entity
    this.moveEntity(dx, dy);
}
}
```
```java
class de.gurkenlabs.litiengine.graphics.animation.AnimationController {
public void detach() {
    Game.loop().detach(this);
}public void attach() {
    Game.loop().attach(this);
}
}
```
```java
class de.gurkenlabs.litiengine.graphics.Camera {
@Override
  public void setZoom(final float targetZoom, final int delay) {
    if (delay == 0) {

      this.zoom = targetZoom;
      this.targetZoom = 0;
      this.zoomDelay = 0;
      this.zoomTick = 0;
      this.zoomStep = 0;

      final ZoomChangedEvent event = new ZoomChangedEvent(this, targetZoom);
      for (final ZoomChangedListener listener : this.zoomListeners) {
        listener.zoomChanged(event);
      }
    } else {
      this.zoomTick = Game.time().now();
      this.targetZoom = targetZoom;
      this.zoomDelay = delay;

      final double tickduration = 1000 / (double) Game.loop().getTickRate();
      final double tickAmount = delay / tickduration;
      final float totalDelta = this.targetZoom - this.zoom;
      this.zoomStep = tickAmount > 0 ? (float) (totalDelta / tickAmount) : totalDelta;
    }
}
}
```
```java
class de.gurkenlabs.litiengine.Game {
public static synchronized void init(String... args) {
    if (initialized) {
      log().log(Level.INFO, "The game has already been initialized.");
      return;
    }

    log.init();
    handleCommandLineArguments(args);

    config().load();
    Locale.setDefault(new Locale(config().client().getCountry(), config().client().getLanguage()));

    gameLoop = new GameLoop("Main Update Loop", config().client().getMaxFps());
    loop().attach(physics());
    loop().attach(world());

    // setup default exception handling for render and update loop
    setUncaughtExceptionHandler(
        new DefaultUncaughtExceptionHandler(config().client().exitOnError()));

    screenManager = new ScreenManager();
    gameWindow = new GameWindow();

    // initialize  the game window
    window().init();
    world.setCamera(new Camera());

    for (GameListener listener : gameListeners) {
      listener.initialized(args);
    }

    if (!isInNoGUIMode()) {
      window().getRenderComponent().onRendered(g -> metrics().render(g));

      graphics()
          .addEntityRenderedListener(
              e -> DebugRenderer.renderEntityDebugInfo(e.getGraphics(), e.getEntity()));

      window().getRenderComponent().onFpsChanged(fps -> metrics().setFramesPerSecond(fps));
      window()
          .setIcons(
              Arrays.asList(
                  Resources.images().get("liti-logo-x16.png"),
                  Resources.images().get("liti-logo-x20.png"),
                  Resources.images().get("liti-logo-x32.png"),
                  Resources.images().get("liti-logo-x48.png")));

      Input.keyboard()
          .onKeyTyped(
              KeyEvent.VK_PRINTSCREEN,
              key -> {
                // don't take a screenshot if a modifier is active
                if (key.getModifiers() != 0) {
                  return;
                }

                window().getRenderComponent().takeScreenshot();
              });
    }

    Runtime.getRuntime().addShutdownHook(new Thread(Game::terminate, "Shutdown"));

    initialized = true;
}
}
```
```java
class de.gurkenlabs.litiengine.entities.Creature {
protected void updateAnimationController() {
    IEntityAnimationController<?> controller = this.createAnimationController();
    this.getControllers().addController(controller);
    if (Game.world().environment() != null && Game.world().environment().isLoaded()) {
      Game.loop().attach(controller);
    }
}@Override
  public float getTickVelocity() {
    // pixels per ms multiplied by the passed ms
    // ensure that entities don't travel too far in case of lag
    return Math.min(Game.loop().getDeltaTime(), GameLoop.TICK_DELTATIME_LAG)
        * 0.001F
        * this.getVelocity().get()
        * Game.loop().getTimeScale();
}
}
```
Depth: 2
```java
class de.gurkenlabs.litiengine.environment.GameWorld {
public void clear() {
    this.unloadEnvironment();
    this.environments.clear();
    this.setCamera(null);
    Game.physics().clear();

    this.environmentListeners.clear();
    this.environmentLoadedListeners.clear();
    this.environmentUnloadedListeners.clear();

    this.listeners.clear();
    this.loadedListeners.clear();
    this.unloadedListeners.clear();
}@Nullable
  public Environment loadEnvironment(IMap map) {
    Environment env = this.getEnvironment(map);
    this.loadEnvironment(env);
    return env;
}@Nullable
  public Environment loadEnvironment(String mapName) {
    Environment env = this.getEnvironment(mapName);
    this.loadEnvironment(env);
    return env;
}
}
```
```java
class de.gurkenlabs.litiengine.GameWindow {
GameWindow() {
    this.hostControl = new JFrame();

    this.resolutionChangedListeners = new CopyOnWriteArrayList<>();

    this.renderCanvas = new RenderComponent(Game.config().graphics().getResolution());
    this.cursor = new MouseCursor();
    if (!Game.isInNoGUIMode()) {
      this.hostControl.setBackground(Color.BLACK);
      this.hostControl.add(this.renderCanvas);

      this.initializeEventListeners();

      this.hostControl.setTitle(Game.info().getTitle());
      this.hostControl.setDefaultCloseOperation(WindowConstants.DO_NOTHING_ON_CLOSE);
      initializeWindowEventListeners(this.hostControl);
    }
}
}
```
```java
class de.gurkenlabs.litiengine.GameTime {
public long sinceEnvironmentLoad() {
    return this.since(this.environmentLoaded);
}public long since(final long tick) {
    return toMilliseconds(Game.loop().getTicks() - tick);
}public long sinceGameStart() {
    return this.toMilliseconds(Game.loop().getTicks());
}
}
```
```java
class de.gurkenlabs.litiengine.abilities.effects.Effect {
protected void cease(final EffectApplication appliance) {
    // 1. cease the effect for all affected entities
    for (final ICombatEntity entity : appliance.getAffectedEntities()) {
      this.cease(entity);
    }

    // 2. apply follow up effects
    this.getFollowUpEffects().forEach(followUp -> followUp.apply(appliance.getImpactArea()));
}protected boolean hasEnded(final EffectApplication appliance) {
    final long effectDuration = Game.time().since(appliance.getAppliedTicks());
    return effectDuration > this.getDuration();
}
}
```
```java
class de.gurkenlabs.litiengine.abilities.effects.EffectApplication {
protected EffectApplication(final List<ICombatEntity> affectedEntities, final Shape impactArea) {
    this.applied = Game.time().now();
    this.affectedEntities = affectedEntities;
    this.impactArea = impactArea;
}
}
```
```java
class de.gurkenlabs.litiengine.entities.CombatEntity {
@Override
  public boolean wasHit(int timeSpan) {
    return Game.time().since(this.lastHit) < timeSpan;
}@Override
  public void hit(final int damage, @Nullable final Ability ability) {
    if (this.isDead()) {
      return;
    }

    if (!this.isIndestructible()) {
      this.getHitPoints().modifyBaseValue(new AttributeModifier<>(Modification.SUBTRACT, damage));
    }

    final EntityHitEvent event = new EntityHitEvent(this, ability, damage, this.isDead());

    for (final CombatEntityListener listener : this.listeners) {
      listener.hit(event);
    }

    for (final CombatEntityHitListener listener : this.hitListeners) {
      listener.hit(event);
    }

    if (this.isDead()) {
      this.fireDeathEvent();
      this.setCollision(false);
    }

    this.lastHit = Game.time().now();
}
}
```
```java
class de.gurkenlabs.litiengine.graphics.ImageEffect {
protected ImageEffect(final int ttl, final String name) {
    this.ttl = ttl;
    this.name = name;
    this.aliveTick = Game.time().now();
}@Override
  public long getAliveTime() {
    return Game.time().since(this.aliveTick);
}
}
```
```java
class de.gurkenlabs.litiengine.abilities.AbilityExecution {
AbilityExecution(final Ability ability) {
    this.appliedEffects = new CopyOnWriteArrayList<>();
    this.ability = ability;
    this.executionTicks = Game.time().now();
    this.impactArea = ability.calculateImpactArea();
    this.castLocation = ability.getExecutor().getCenter();
    Game.loop().attach(this);
}@Override
  public void update() {
    // if there a no effects to apply -> unregister this instance and we're done
    if (this.getAbility().getEffects().isEmpty()
        || this.getAbility().getEffects().size() == this.getAppliedEffects().size()) {
      Game.loop().detach(this);
      return;
    }

    // handle all effects from the ability that were not applied yet
    for (final Effect effect : this.getAbility().getEffects()) {
      // if the ability was not executed yet or the delay of the effect is not
      // yet reached
      if (this.getAppliedEffects().contains(effect)
          || Game.time().since(this.getExecutionTicks()) < effect.getDelay()) {
        continue;
      }

      effect.apply(this.getExecutionImpactArea());
      this.getAppliedEffects().add(effect);
    }
}
}
```
```java
class de.gurkenlabs.litiengine.tweening.TweenEngine {
@Override
  public void update() {
    for (final Tweenable target : this.getTweens().keySet()) {
      for (final Tween tween : this.getTweens().get(target).values()) {
        if (tween.hasStopped()) {
          continue;
        }
        final long elapsed = Game.time().since(tween.getStartTime());
        if (elapsed >= tween.getDuration()) {
          tween.stop();
          continue;
        }
        final float[] currentValues = new float[tween.getTargetValues().length];
        for (int i = 0; i < tween.getTargetValues().length; i++) {
          currentValues[i] =
              tween.getStartValues()[i]
                  + tween.getEquation().compute(elapsed / (float) tween.getDuration())
                      * (tween.getTargetValues()[i] - tween.getStartValues()[i]);
        }
        tween.getTarget().setTweenValues(tween.getType(), currentValues);
      }
    }
}
}
```
```java
class de.gurkenlabs.litiengine.gui.SpeechBubble {
public static SpeechBubble create(
      final IEntity entity, final String text, SpeechBubbleAppearance appearance, Font font) {
    return new SpeechBubble(entity, text, appearance, font);
}public static SpeechBubble create(final IEntity entity, final Font font, final String text) {
    SpeechBubbleAppearance app =
        new SpeechBubbleAppearance(
            DEFAULT_APPEARANCE.getForeColor(),
            DEFAULT_APPEARANCE.getBackgroundColor1(),
            DEFAULT_APPEARANCE.getBorderColor(),
            DEFAULT_APPEARANCE.getPadding());
    return new SpeechBubble(entity, text, app, font);
}public static SpeechBubble create(final IEntity entity, final String text) {
    return new SpeechBubble(entity, text, null, GuiProperties.getDefaultFont());
}@Override
  public void update() {
    if (this.currentText == null) {
      this.hide();
      return;
    }

    this.entityCenter = Game.world().camera().getViewportLocation(this.getEntity().getCenter());

    // old text was displayed long enough
    if (this.lastTextDisplay != 0
        && Game.time().since(this.lastTextDisplay) > this.currentTextDisplayTime) {
      this.currentText = null;
      this.lastTextDisplay = 0;
      return;
    }

    // display new text
    if (this.textIndex < this.currentText.length()
        && Game.time().since(this.lastCharPoll) > LETTER_WRITE_DELAY) {
      this.textIndex++;
      this.lastCharPoll = Game.time().now();
      if (this.typeSound != null) {
        Game.audio().playSound(this.typeSound, this.getEntity());
      }
    }

    // continue displaying currently displayed text
}private SpeechBubble(
      final IEntity entity,
      final String text,
      final Sound typeSound,
      SpeechBubbleAppearance appearance,
      Font font) {
    this(entity, text, appearance, font);
    this.typeSound = typeSound;
}private SpeechBubble(
      final IEntity entity,
      final String text,
      @Nullable SpeechBubbleAppearance appearance,
      @Nullable Font font) {
    if (appearance == null) {
      this.appearance = DEFAULT_APPEARANCE;
    } else {
      this.appearance = appearance;
    }

    final SpeechBubble active = activeSpeechBubbles.get(entity);
    if (active != null) {
      active.hide();
    }
    this.setFont(font);

    this.textBoxWidth = (float) (entity.getWidth() * 4);
    this.entity = entity;

    this.currentText = text;
    this.currentTextDisplayTime = DISPLAYTIME_MIN + text.length() * DISPLAYTIME_PER_LETTER;

    this.lastTextDisplay = Game.time().now();
    this.createBubbleImage();
    entity.getEnvironment().add(this, RenderType.UI);
    Game.loop().attach(this);
    activeSpeechBubbles.put(entity, this);
}
}
```
```java
class de.gurkenlabs.litiengine.gui.TextFieldComponent {
@Override
  public void render(final Graphics2D g) {
    super.render(g);
    g.setFont(this.getFont());
    final FontMetrics fm = g.getFontMetrics();

    if (this.isSelected() && Game.time().since(this.lastToggled) > this.flickerDelay) {
      this.cursorVisible = !this.cursorVisible;
      this.lastToggled = Game.time().now();
    }
    if (this.isSelected() && this.cursorVisible) {
      final Rectangle2D cursor =
          new Rectangle2D.Double(
              this.getX() + this.getTextX() + fm.stringWidth(this.getTextToRender(g)),
              this.getY() + this.getTextY(),
              this.getFont().getSize2D() * 3 / 5,
              this.getFont().getSize2D() * 1 / 5);
      g.setColor(this.getAppearance().getForeColor());
      g.fill(cursor);
    }
}
}
```
```java
class de.gurkenlabs.litiengine.entities.Prop {
public Prop(
      final Point2D location, @Nullable final String spritesheetName, final Material material) {
    super();
    this.rotation = Rotation.NONE;
    this.spritesheetName = spritesheetName;
    this.material = material;
    this.setLocation(location);
    this.updateAnimationController();
}public void setSpritesheetName(@Nullable final String spriteName) {
    this.spritesheetName = spriteName;
    this.updateAnimationController();
}
}
```
```java
class de.gurkenlabs.litiengine.tweening.Tween {
public Tween begin() {
    this.started = Game.time().now();
    this.stopped = false;
    return this;
}
}
```
```java
class de.gurkenlabs.litiengine.graphics.emitters.particles.Particle {
public void update(final Point2D emitterOrigin, final float updateRatio) {
    if (this.aliveTick == 0) {
      this.aliveTick = Game.time().now();
    }

    this.aliveTime = Game.time().since(this.aliveTick);
    if (this.timeToLiveReached()) {
      return;
    }

    if (this.colliding) {
      return;
    }

    if (this.getDeltaWidth() != 0) {
      this.width += this.getDeltaWidth() * updateRatio;
    }

    if (this.getDeltaHeight() != 0) {
      this.height += this.getDeltaHeight() * updateRatio;
    }

    if (this.getDeltaAngle() != 0) {
      this.angle += this.getDeltaAngle() * updateRatio;
    }

    // test for ray cast collision
    final float targetX = this.x + this.getVelocityX() * updateRatio;
    final float targetY = this.y + this.getVelocityY() * updateRatio;

    if (targetX == this.x && targetY == this.y) {
      return;
    }

    if (this.checkForCollision(emitterOrigin, targetX, targetY)) {
      return;
    }

    if (this.getVelocityX() != 0) {
      this.x = targetX;
    }

    if (this.getVelocityY() != 0) {
      this.y = targetY;
    }

    if (this.getAccelerationX() != 0) {
      this.velocityX += this.getAccelerationX() * updateRatio;
    }

    if (this.getAccelerationY() != 0) {
      this.velocityY += this.getAccelerationY() * updateRatio;
    }
}
}
```
```java
class de.gurkenlabs.litiengine.graphics.animation.Animation {
@Override
  public void start() {
    this.playing = true;
    if (this.getKeyframes().isEmpty()) {
      return;
    }

    this.restart();
}@Override
  public void update() {
    // do nothing if the animation is not playing or the current keyframe is not finished
    if (!this.isPlaying()
        || Game.time().since(this.lastFrameUpdate) < this.getCurrentKeyFrame().getDuration()) {
      return;
    }

    // if we are not looping and the last keyframe is finished, we terminate the animation
    if (!this.isLooping() && this.isLastKeyFrame()) {
      this.terminate();
      return;
    }

    // make sure, we stay inside the keyframe list
    final int newFrameIndex =
        (this.getKeyframes().indexOf(this.currentFrame) + 1) % this.getKeyframes().size();
    final KeyFrame previousFrame = this.currentFrame;
    this.currentFrame = this.getKeyframes().get(newFrameIndex);

    for (KeyFrameListener listener : this.listeners) {
      listener.currentFrameChanged(previousFrame, this.currentFrame);
    }

    this.lastFrameUpdate = Game.loop().getTicks();
}
}
```
```java
class de.gurkenlabs.litiengine.graphics.animation.AnimationController {
@Override
  public void update() {
    for (final Animation animation : this.getAll()) {
      animation.update();
    }

    if (this.getCurrent() != null && this.getCurrent().isPaused()) {
      return;
    }

    final boolean playbackFinished = this.getCurrent() != null && !this.getCurrent().isPlaying();
    if (playbackFinished) {
      for (final AnimationListener listener : this.listeners) {
        listener.finished(this.getCurrent());
      }
    }

    if (this.getCurrent() == null || playbackFinished) {
      if (this.getDefault() != null) {
        this.play(this.getDefault().getName());
      } else {
        this.currentAnimation = null;
      }
    }
}
}
```
```java
class de.gurkenlabs.litiengine.graphics.RenderComponent {
private void handleFade() {
    if (this.fadeOutStart != -1) {
      final long timePassed = Game.time().since(this.fadeOutStart);
      this.currentAlpha = MathUtilities.clamp(1 - timePassed / (float) this.fadeOutTime, 0, 1);
      if (this.currentAlpha == 0f) {
        this.fadeOutStart = -1;
        this.fadeOutTime = -1;
      }

      return;
    }

    if (this.fadeInStart != -1) {
      final long timePassed = Game.time().since(this.fadeInStart);
      this.currentAlpha = MathUtilities.clamp(timePassed / (float) this.fadeInTime, 0, 1);
      if (this.currentAlpha == 1f) {
        this.fadeInStart = -1;
        this.fadeInTime = -1;
        this.currentAlpha = Float.NaN;
      }
    }
}public void fadeOut(final int ms) {
    this.fadeInStart = -1;
    this.fadeInTime = -1;
    this.fadeOutStart = Game.time().now();
    this.fadeOutTime = ms;
}public void fadeIn(final int ms) {
    this.fadeOutStart = -1;
    this.fadeOutTime = -1;
    this.fadeInStart = Game.time().now();
    this.fadeInTime = ms;
}
}
```
```java
class de.gurkenlabs.litiengine.entities.Trigger {
private boolean activate(final IEntity activator, final int tar) {
    if (!this.isLoaded()
        || this.isOneTimeTrigger && this.isActivated
        || this.getActivationType() == TriggerActivation.COLLISION
            && activator != null
            && this.collisionActivated.contains(activator)) {
      return false;
    }

    if (this.getCooldown() > 0 && Game.time().since(this.lastActivation) < this.getCooldown()) {
      return false;
    }

    List<Integer> triggerTargets = this.getTargets(tar);

    final TriggerEvent te = new TriggerEvent(this, activator, triggerTargets);

    if (!this.checkActivationPredicates(te)) {
      return false;
    }

    this.isActivated = true;
    if (activator != null) {
      this.collisionActivated.add(activator);
    }

    // if we actually have a trigger target, we send the message to the target
    for (final int target : triggerTargets) {
      final IEntity entity = this.getEnvironment().get(target);
      if (entity == null) {
        log.log(
            Level.WARNING,
            "trigger [{0}] was activated, but the trigger target [{1}] could not be found on the environment",
            new Object[] {this, target});
        continue;
      }

      entity.sendMessage(this, this.message);
    }

    // also send the trigger event to all registered consumers
    for (final TriggerActivatedListener listener : this.activatedListeners) {
      listener.activated(te);
    }

    if (this.isOneTimeTrigger) {
      this.getEnvironment().remove(this);
    }

    this.lastActivation = Game.time().now();
    return true;
}
}
```
```java
class de.gurkenlabs.litiengine.graphics.Camera {
private boolean isShakeEffectActive() {
    return this.getShakeTick() != 0
        && Game.time().since(this.getShakeTick()) < this.getShakeDuration();
}@Override
  public void update() {
    if (Game.world().camera() != null && !Game.world().camera().equals(this)) {
      return;
    }

    if (this.targetZoom > 0) {
      if (Game.time().since(this.zoomTick) >= this.zoomDelay) {
        this.zoom = this.targetZoom;
        this.targetZoom = 0;
        this.zoomDelay = 0;
        this.zoomTick = 0;
        this.zoomStep = 0;
      } else {
        this.zoom += this.zoomStep;
      }

      final ZoomChangedEvent event = new ZoomChangedEvent(this, this.getZoom());
      for (final ZoomChangedListener listener : this.zoomListeners) {
        listener.zoomChanged(event);
      }
    }

    if (this.panTime > 0) {
      if (--this.panTime <= 0) {
        this.setFocus(this.targetFocus);
        this.targetFocus = null;
      } else {
        double diff = this.panTime / (this.panTime + 1.0);
        this.focus =
            new Point2D.Double(
                this.focus.getX() * diff + this.targetFocus.getX() * (1.0 - diff),
                this.focus.getY() * diff + this.targetFocus.getY() * (1.0 - diff));
      }
    }

    if (!this.isShakeEffectActive()) {
      this.shakeOffsetX = 0;
      this.shakeOffsetY = 0;
      return;
    }

    if (Game.time().since(this.lastShake) > this.shakeDelay) {
      this.shakeOffsetX = this.getShakeIntensity() * ThreadLocalRandom.current().nextGaussian();
      this.shakeOffsetY = this.getShakeIntensity() * ThreadLocalRandom.current().nextGaussian();
      this.lastShake = Game.time().now();
    }
}@Override
  public void setZoom(final float targetZoom, final int delay) {
    if (delay == 0) {

      this.zoom = targetZoom;
      this.targetZoom = 0;
      this.zoomDelay = 0;
      this.zoomTick = 0;
      this.zoomStep = 0;

      final ZoomChangedEvent event = new ZoomChangedEvent(this, targetZoom);
      for (final ZoomChangedListener listener : this.zoomListeners) {
        listener.zoomChanged(event);
      }
    } else {
      this.zoomTick = Game.time().now();
      this.targetZoom = targetZoom;
      this.zoomDelay = delay;

      final double tickduration = 1000 / (double) Game.loop().getTickRate();
      final double tickAmount = delay / tickduration;
      final float totalDelta = this.targetZoom - this.zoom;
      this.zoomStep = tickAmount > 0 ? (float) (totalDelta / tickAmount) : totalDelta;
    }
}@Override
  public void shake(final double intensity, final int delay, final int shakeDuration) {
    this.shakeTick = Game.time().now();
    this.shakeDelay = delay;
    this.shakeIntensity = intensity;
    this.shakeDuration = shakeDuration;
}
}
```
```java
class de.gurkenlabs.litiengine.entities.Creature {
public void setSpritesheetName(String spritesheetName) {
    if (this.spritesheetName != null && this.spritesheetName.equals(spritesheetName)) {
      return;
    }

    this.spritesheetName = spritesheetName;
    this.updateAnimationController();
}public boolean isIdle() {
    return Game.time().since(this.lastMoved) > IDLE_DELAY;
}@Override
  public void setLocation(final Point2D position) {
    if (this.isDead() || position == null) {
      return;
    }

    final Point2D oldLocation = this.getLocation();
    super.setLocation(position);

    if (Game.hasStarted() && this.isLoaded()) {
      this.lastMoved = Game.time().now();
      this.fireMovedEvent(
          new EntityMovedEvent(
              this, this.getX() - oldLocation.getX(), this.getY() - oldLocation.getY()));
    }
}
}
```
```java
class de.gurkenlabs.litiengine.gui.screens.ScreenManager {
public void display(final String screenName) {
    if (this.current() != null && this.current().getName().equalsIgnoreCase(screenName)) {
      log.log(
          Level.INFO,
          "Skipping displaying of screen {0} because it is already the current screen.",
          screenName);
      return;
    }

    if (this.screens.stream()
        .noneMatch(element -> element.getName().equalsIgnoreCase(screenName))) {
      log.log(
          Level.WARNING,
          "Could not display the screen {0} because there is no screen with the specified name.",
          screenName);
      return;
    }

    Screen screen = this.get(screenName);
    if (screen == null) {
      return;
    }

    this.display(screen);
}public void add(final Screen screen) {
    screen.setWidth(Game.window().getWidth());
    screen.setHeight(Game.window().getHeight());
    this.screens.add(screen);

    if (this.current() == null) {
      this.display(screen);
    }
}public void remove(Screen screen) {
    this.screens.remove(screen);
    if (this.current() == screen) {
      if (!this.screens.isEmpty()) {
        this.display(this.screens.get(0));
      } else {
        this.display((Screen) null);
      }
    }
}public void display(@Nullable final Screen screen) {
    if (Game.hasStarted() && Game.time().since(this.lastScreenChange) < this.getChangeCooldown()) {
      log.log(
          Level.INFO,
          "Skipping displaying of screen {0} because screen changing is currently on cooldown.",
          screen != null ? screen.getName() : "");
      return;
    }

    final Screen previous = this.current();
    if (previous != null) {
      previous.suspend();
    }

    if (screen != null && !this.screens.contains(screen)) {
      this.screens.add(screen);
    }

    this.currentScreen = screen;
    if (!Game.isInNoGUIMode() && this.current() != null) {
      this.current().prepare();
    }

    this.lastScreenChange = Game.loop().getTicks();

    final ScreenChangedEvent event = new ScreenChangedEvent(this.current(), previous);
    for (final ScreenChangedListener listener : this.screenChangedListeners) {
      listener.changed(event);
    }
}
}
```
```java
class de.gurkenlabs.litiengine.abilities.Ability {
public boolean isOnCooldown() {
    return (this.getCurrentExecution() != null
        && this.getCurrentExecution().getExecutionTicks() > 0
        && Game.time().since(this.getCurrentExecution().getExecutionTicks())
            < this.getAttributes().cooldown().get());
}public boolean isActive() {
    return this.getCurrentExecution() != null
        && Game.time().since(this.getCurrentExecution().getExecutionTicks())
            < this.getAttributes().duration().get();
}@Nullable
  public AbilityExecution cast() {
    if (!this.canCast()) {
      return null;
    }
    this.currentExecution = new AbilityExecution(this);

    for (final AbilityCastListener listener : this.abilityCastListeners) {
      listener.abilityCast(this.currentExecution);
    }

    return this.getCurrentExecution();
}public float getRemainingCooldownInSeconds() {
    if (this.getCurrentExecution() == null
        || this.getExecutor() == null
        || this.getExecutor().isDead()) {
      return 0;
    }

    // calculate cooldown in seconds
    return (float)
        (!this.canCast()
            ? (this.getAttributes().cooldown().get()
                    - Game.time().since(this.getCurrentExecution().getExecutionTicks()))
                * 0.001
            : 0);
}
}
```
```java
class de.gurkenlabs.litiengine.entities.EntityHitEvent {
EntityHitEvent(
      final ICombatEntity hitEntity,
      @Nullable final Ability ability,
      final int damage,
      final boolean kill) {
    super(hitEntity);
    this.executor = ability != null ? ability.getExecutor() : null;
    this.hitEntity = hitEntity;
    this.ability = ability;
    this.damage = damage;
    this.kill = kill;
    this.time = Game.time().now();
}
}
```
```java
class de.gurkenlabs.litiengine.graphics.emitters.Emitter {
public void delete() {
    this.deactivate();
    if (Game.world().environment() != null) {
      Game.world().environment().remove(this);
    }
}public void activate() {
    if (this.activated) {
      return;
    }

    this.activated = true;
    this.activationTick = Game.time().now();
    Game.loop().attach(this);
}@Override
  public void update() {
    if (this.isPaused()) {
      return;
    }

    // clear particles if the effect time to life is reached
    if (this.isFinished()) {
      for (EmitterFinishedListener listener : this.finishedListeners) {
        listener.finished(this);
      }

      this.delete();
      return;
    }

    final float updateRatio = (float) this.data().getUpdateRate() / Game.loop().getTickRate();
    for (final Particle p : this.getParticles().stream().collect(Collectors.toList())) {
      if (this.particleCanBeRemoved(p)) {
        // remove dead particles
        this.particles.remove(p);
        continue;
      }

      p.update(this.getOrigin(), updateRatio);
    }

    this.aliveTime = Game.time().since(this.activationTick);
    if ((this.data().getSpawnRate() == 0
        || Game.time().since(this.lastSpawn) >= this.data().getSpawnRate())) {
      this.lastSpawn = Game.time().now();
      this.spawnParticle();
    }
}
}
```
```java
class de.gurkenlabs.litiengine.GameLoop {
@Override
  public int perform(int delay, Runnable action) {
    final long d = Game.time().toTicks(delay);

    TimedAction a = new TimedAction(this.getTicks() + d, action);
    this.actions.add(a);

    return a.getId();
}
}
```
```java
class de.gurkenlabs.litiengine.environment.EntitySpawner {
protected boolean shouldSpawn() {
    return this.lastSpawnWave == 0
        || Game.time().since(this.lastSpawnWave) >= this.getSpawnInterval();
}@Override
  public void update() {
    if (!this.shouldSpawn()) {
      return;
    }

    this.spawnNewEntities();
    this.lastSpawnWave = Game.time().now();
}
}
```
```java
class de.gurkenlabs.litiengine.graphics.FreeFlightCamera {
@Override
  public void update() {
    this.handleFreeFlightCamera();
}public FreeFlightCamera(double x, double y) {
    this(new Point2D.Double(x, y));
}
}
```
```java
class de.gurkenlabs.litiengine.environment.Environment {
public void unload() {
    if (!this.loaded) {
      return;
    }

    // unregister all updatable entities from the current environment
    for (final IEntity entity : this.allEntities.values()) {
      this.unload(entity);
    }

    this.loaded = false;
    this.fireEvent(l -> l.unloaded(this));
}private static void loadUpdatableOrEmitterEntity(IEntity entity) {
    if (entity instanceof Emitter) {
      final Emitter emitter = (Emitter) entity;
      if (emitter.isActivateOnInit()) {
        emitter.activate();
      }
    } else if (entity instanceof IUpdateable) {
      Game.loop().attach((IUpdateable) entity);
    }
}public void clear() {
    Game.physics().clear();

    this.combatEntities.clear();
    this.mobileEntities.clear();
    this.gravityForces.clear();
    this.layerEntities.clear();
    this.entitiesByTag.clear();
    this.allEntities.clear();

    for (RenderType renderType : RenderType.values()) {
      this.miscEntities.get(renderType).clear();
      this.renderListeners.get(renderType).clear();
      this.renderables.get(renderType).clear();
    }

    dispose(this.allEntities.values());
    dispose(this.triggers);
    this.emitters.clear();
    this.colliders.clear();
    this.props.clear();
    this.creatures.clear();
    this.staticShadows.clear();
    this.combatEntities.clear();
    this.mobileEntities.clear();
    this.lightSources.clear();
    this.spawnPoints.clear();
    this.soundSources.clear();
    this.mapAreas.clear();
    this.triggers.clear();

    this.ambientLight = null;
    this.staticShadowLayer = null;

    for (Map<Integer, IEntity> type : this.miscEntities.values()) {
      type.clear();
    }

    this.initialized = false;

    this.fireEvent(l -> l.cleared(this));
}private void load(final IEntity entity) {
    // an entity can only exist on one environment at a time, so remove it from the current one
    if (entity.getEnvironment() != null) {
      entity.getEnvironment().remove(entity);
    }

    // 1. add to physics engine
    loadPhysicsEntity(entity);

    // 2. register for update or activate
    loadUpdatableOrEmitterEntity(entity);

    // 3. if a gravity is defined, add a gravity force to the entity
    if (entity instanceof IMobileEntity && this.getGravity() != 0) {
      this.addGravityForce((IMobileEntity) entity);
    }

    // 4. attach all controllers
    entity.attachControllers();

    if (this.loaded && (entity instanceof LightSource || entity instanceof StaticShadow)) {
      this.updateLighting(entity);
    }

    entity.loaded(this);
}private void unload(final IEntity entity) {
    // 1. remove from physics engine
    if (entity instanceof ICollisionEntity) {
      Game.physics().remove((ICollisionEntity) entity);
    }

    // 2. unregister from update
    if (entity instanceof IUpdateable) {
      Game.loop().detach((IUpdateable) entity);
    }

    if (entity instanceof IMobileEntity) {
      this.removeGravity((IMobileEntity) entity);
    }

    // 3. detach all controllers
    entity.detachControllers();

    if (entity instanceof Emitter) {
      Emitter em = (Emitter) entity;
      em.deactivate();
    }

    if (this.loaded && (entity instanceof LightSource || entity instanceof StaticShadow)) {
      this.updateLighting(entity);
    }

    entity.removed(this);
}public void remove(final IEntity entity) {
    if (entity == null) {
      return;
    }

    this.allEntities.remove(entity.getMapId());
    Iterator<List<IEntity>> iter = this.layerEntities.values().iterator();
    while (iter.hasNext()) {
      List<IEntity> layer = iter.next();
      if (layer.remove(entity) && layer.isEmpty()) {
        iter.remove();
      }
    }
    if (this.miscEntities.get(entity.getRenderType()) != null) {
      this.miscEntities.get(entity.getRenderType()).values().remove(entity);
    }

    for (String tag : entity.getTags()) {
      if (this.getEntitiesByTag().containsKey(tag)) {
        this.getEntitiesByTag().get(tag).remove(entity);

        if (this.getEntitiesByTag().get(tag).isEmpty()) {
          this.getEntitiesByTag().remove(tag);
        }
      }
    }

    if (entity instanceof Emitter) {
      Emitter emitter = (Emitter) entity;
      this.removeEmitter(emitter);
    }

    if (entity instanceof MapArea) {
      this.mapAreas.remove(entity);
    }

    if (entity instanceof Prop) {
      this.props.remove(entity);
    }

    if (entity instanceof Creature) {
      this.creatures.remove(entity);
    }

    if (entity instanceof CollisionBox) {
      this.colliders.remove(entity);
      this.staticShadows.removeIf(x -> x.getOrigin() != null && x.getOrigin().equals(entity));
    }

    if (entity instanceof LightSource) {
      this.lightSources.remove(entity);
      this.updateLighting(entity);
    }

    if (entity instanceof Trigger) {
      this.triggers.remove(entity);
    }

    if (entity instanceof Spawnpoint) {
      this.spawnPoints.remove(entity);
    }
    if (entity instanceof SoundSource) {
      this.soundSources.remove(entity);
    }

    if (entity instanceof StaticShadow) {
      this.staticShadows.remove(entity);
      this.updateLighting(entity);
    }

    if (entity instanceof IMobileEntity) {
      this.mobileEntities.values().remove(entity);
    }

    if (entity instanceof ICombatEntity) {
      this.combatEntities.values().remove(entity);
    }

    this.unload(entity);

    this.fireEntityEvent(l -> l.entityRemoved(entity));
}
}
```
```java
class de.gurkenlabs.litiengine.physics.MovementController {
@Override
  public void update() {
    this.handleForces();
    this.handleMovement();
}
}
```
```java
class de.gurkenlabs.litiengine.Game {
static synchronized void terminate() {
    if (!initialized) {
      return;
    }

    hasStarted = false;
    initialized = false;

    config().save();
    gameLoop.terminate();
    tweenEngine.terminate();
    soundEngine.terminate();

    world().clear();

    for (final GameListener listener : gameListeners) {
      try {
        listener.terminated();
      } catch (Exception e) {
        log().log(Level.WARNING, "game listener threw an exception during shutdown", e);
      }
    }

    gameLoop = null;
    screenManager = null;
    gameWindow = null;
}public static synchronized void start() {
    if (!initialized) {
      throw new IllegalStateException(
          "The game cannot be started without being first initialized. Call Game.init(...) before Game.start().");
    }

    gameLoop.start();
    tweenEngine.start();
    soundEngine.start();

    for (final GameListener listener : gameListeners) {
      listener.started();
    }

    hasStarted = true;
}public static synchronized void init(String... args) {
    if (initialized) {
      log().log(Level.INFO, "The game has already been initialized.");
      return;
    }

    log.init();
    handleCommandLineArguments(args);

    config().load();
    Locale.setDefault(new Locale(config().client().getCountry(), config().client().getLanguage()));

    gameLoop = new GameLoop("Main Update Loop", config().client().getMaxFps());
    loop().attach(physics());
    loop().attach(world());

    // setup default exception handling for render and update loop
    setUncaughtExceptionHandler(
        new DefaultUncaughtExceptionHandler(config().client().exitOnError()));

    screenManager = new ScreenManager();
    gameWindow = new GameWindow();

    // initialize  the game window
    window().init();
    world.setCamera(new Camera());

    for (GameListener listener : gameListeners) {
      listener.initialized(args);
    }

    if (!isInNoGUIMode()) {
      window().getRenderComponent().onRendered(g -> metrics().render(g));

      graphics()
          .addEntityRenderedListener(
              e -> DebugRenderer.renderEntityDebugInfo(e.getGraphics(), e.getEntity()));

      window().getRenderComponent().onFpsChanged(fps -> metrics().setFramesPerSecond(fps));
      window()
          .setIcons(
              Arrays.asList(
                  Resources.images().get("liti-logo-x16.png"),
                  Resources.images().get("liti-logo-x20.png"),
                  Resources.images().get("liti-logo-x32.png"),
                  Resources.images().get("liti-logo-x48.png")));

      Input.keyboard()
          .onKeyTyped(
              KeyEvent.VK_PRINTSCREEN,
              key -> {
                // don't take a screenshot if a modifier is active
                if (key.getModifiers() != 0) {
                  return;
                }

                window().getRenderComponent().takeScreenshot();
              });
    }

    Runtime.getRuntime().addShutdownHook(new Thread(Game::terminate, "Shutdown"));

    initialized = true;
}
}
```


Response Format:
Provide the answer in **XML format** as follows:

#### If the method **cannot** return `null` at the specific call site:
```xml
<response>
  <reason><![CDATA[EXPLAIN WHY THE INVOCATION Game.loop() RESULT CANNOT BE NULL.]]></reason>
  <value>NO</value>
</response>

#### If the method can return null at the specific call site:
<response>
  <reason><![CDATA[EXPLAIN WHY THE INVOCATION Game.loop() RESULT CAN BE NULL.]]></reason>
  <value>YES</value>
</response>

#### If you are unsure or If there are any methods that directly or indirectly affect the return value and are not fully disclosed, request their declarations first, in the following format:
<response>
  <reason><![CDATA[EXPLAIN WHY THIS METHOD DECLARATION IS NECESSARY AND WHY YOU CANNOT MAKE A CONFIDENT DECISION WITHOUT IT]]></reason>
  <success>false</success>
  <methods>
    <method>methodName</method>
  </methods>
</response>

Additional Notes:
Be precise in your reasoning.
If a method’s return value depends on another method not provided, request its declaration before making a conclusion.
If the method can return null in this case but not in others, explain why it happens specifically for this call.

---ChatGPT.sendRequestToOpenAI---
Retrieving response from cache
---Response.<init>---
Creating Response:
```xml
<response>
  <reason><![CDATA[The method `Game.loop()` returns the static field `gameLoop`, which is initialized in the `Game.init(String... args)` method. In this method, a new `GameLoop` object is instantiated and assigned to `gameLoop`. Since `init()` must be called before `start()`, which is implied by the requirement of initializing the game, the `gameLoop` is guaranteed to be non-null during the lifetime of the game execution where `Game.loop()` is called. The absence of any code that could set `gameLoop` to null after its initialization ensures that `Game.loop()` cannot return null.]]></reason>
  <value>NO</value>
</response>
```
---Response.<init>---
Response created:
Disagreement: The method `Game.loop()` returns the static field `gameLoop`, which is initialized in the `Game.init(String... args)` method. In this method, a new `GameLoop` object is instantiated and assigned to `gameLoop`. Since `init()` must be called before `start()`, which is implied by the requirement of initializing the game, the `gameLoop` is guaranteed to be non-null during the lifetime of the game execution where `Game.loop()` is called. The absence of any code that could set `gameLoop` to null after its initialization ensures that `Game.loop()` cannot return null.
---AdvancedNullAwayCodeFix.resolveMethodDereferenceError---
Method is not returning nullable on call site. Injecting suppression annotation.
---AdvancedNullAwayCodeFix.constructCastToNonnullChange---
Constructing cast to nonnull change for reason: The method `Game.loop()` returns the static field `gameLoop`, which is initialized in the `Game.init(String... args)` method. In this method, a new `GameLoop` object is instantiated and assigned to `gameLoop`. Since `init()` must be called before `start()`, which is implied by the requirement of initializing the game, the `gameLoop` is guaranteed to be non-null during the lifetime of the game execution where `Game.loop()` is called. The absence of any code that could set `gameLoop` to null after its initialization ensures that `Game.loop()` cannot return null.
---ChatGPT.ask---
Asking ChatGPT:
For the reason you mentioned earlier:

"The method `Game.loop()` returns the static field `gameLoop`, which is initialized in the `Game.init(String... args)` method. In this method, a new `GameLoop` object is instantiated and assigned to `gameLoop`. Since `init()` must be called before `start()`, which is implied by the requirement of initializing the game, the `gameLoop` is guaranteed to be non-null during the lifetime of the game execution where `Game.loop()` is called. The absence of any code that could set `gameLoop` to null after its initialization ensures that `Game.loop()` cannot return null."

in the method below, the expression Game.loop() is not nullable at the point it is used.

```java
@Override
  public void update() {
    if (this.isPaused()) {
      return;
    }

    // clear particles if the effect time to life is reached
    if (this.isFinished()) {
      for (EmitterFinishedListener listener : this.finishedListeners) {
        listener.finished(this);
      }

      this.delete();
      return;
    }

    final float updateRatio = (float) this.data().getUpdateRate() / Game.loop().getTickRate();
    for (final Particle p : this.getParticles().stream().collect(Collectors.toList())) {
      if (this.particleCanBeRemoved(p)) {
        // remove dead particles
        this.particles.remove(p);
        continue;
      }

      p.update(this.getOrigin(), updateRatio);
    }

    this.aliveTime = Game.time().since(this.activationTick);
    if ((this.data().getSpawnRate() == 0
        || Game.time().since(this.lastSpawn) >= this.data().getSpawnRate())) {
      this.lastSpawn = Game.time().now();
      this.spawnParticle();
    }
}
```
Please Summarize the reason in max 5 words and rewrite the method so that at the line "    final float updateRatio = (float) this.data().getUpdateRate() / Game.loop().getTickRate();", at the occurrence of: "Game.loop()" is replaced with `NullabilityUtil.castToNonnull(Game.loop(), summary of reason)`
Replace "REASON" with the exact reason summary I provide to you (maximum 5 words), not with a generic explanation like "checked to be nonnull".
see the example below, for expression `foo.getBar()`, to wrap it with `NullabilityUtil.castToNonnull(foo.getBar(), "reason")`.

```java
public t(){
    String l = foo.getBar();
}
```

will be:
```java
public t(){
    String l = NullabilityUtil.castToNonnull(foo.getBar(), "checked to be nonnull");
}
```

### Instructions:

Do not import any additional classes.

Do not add Java comments.

Only modify relevant lines as required.

Return only the modified method wrapped in the XML format shown below.

Place the Java code inside the <code> tag using a CDATA block with ```java formatting.

Just give me the fixed code snippet in XML format in <response> tag like the example below. I will apply the fix to my codebase. Do not import any additional libraries or classes or add java comments. If you can provide the fixed code snippet, please provide it in the following format and place the code snippet in the <code> tag within ```java block.
<response>
  <success>true</success>
  <code><![CDATA[
  ```java
  Your fixed code snippet here
  ```
    ]]>
  </code>
</response>

---ChatGPT.sendRequestToOpenAI---
Sending request to OpenAI...
---ChatGPT.sendRequestToOpenAI---
Response received from OpenAI.
---Response.<init>---
Creating Response:
<response>
  <success>true</success>
  <code><![CDATA[
  ```java
  @Override
  public void update() {
    if (this.isPaused()) {
      return;
    }

    // clear particles if the effect time to life is reached
    if (this.isFinished()) {
      for (EmitterFinishedListener listener : this.finishedListeners) {
        listener.finished(this);
      }

      this.delete();
      return;
    }

    final float updateRatio = (float) this.data().getUpdateRate() / NullabilityUtil.castToNonnull(Game.loop(), "guaranteed non-null").getTickRate();
    for (final Particle p : this.getParticles().stream().collect(Collectors.toList())) {
      if (this.particleCanBeRemoved(p)) {
        // remove dead particles
        this.particles.remove(p);
        continue;
      }

      p.update(this.getOrigin(), updateRatio);
    }

    this.aliveTime = Game.time().since(this.activationTick);
    if ((this.data().getSpawnRate() == 0
        || Game.time().since(this.lastSpawn) >= this.data().getSpawnRate())) {
      this.lastSpawn = Game.time().now();
      this.spawnParticle();
    }
  }
  ```
    ]]>
  </code>
</response>
---Response.<init>---
Response created:
@Override
  public void update() {
    if (this.isPaused()) {
      return;
    }

    // clear particles if the effect time to life is reached
    if (this.isFinished()) {
      for (EmitterFinishedListener listener : this.finishedListeners) {
        listener.finished(this);
      }

      this.delete();
      return;
    }

    final float updateRatio = (float) this.data().getUpdateRate() / NullabilityUtil.castToNonnull(Game.loop(), "guaranteed non-null").getTickRate();
    for (final Particle p : this.getParticles().stream().collect(Collectors.toList())) {
      if (this.particleCanBeRemoved(p)) {
        // remove dead particles
        this.particles.remove(p);
        continue;
      }

      p.update(this.getOrigin(), updateRatio);
    }

    this.aliveTime = Game.time().since(this.activationTick);
    if ((this.data().getSpawnRate() == 0
        || Game.time().since(this.lastSpawn) >= this.data().getSpawnRate())) {
      this.lastSpawn = Game.time().now();
      this.spawnParticle();
    }
  }
---ChatGPT.fixDereferenceByAddingCastToNonnull---
Fixing the error by adding castToNonnull
---AdvancedNullAwayCodeFix.fixTriggeredErrorsForLocation---
Resolving unresolvable error for triggered error: Type='DEREFERENCE_NULLABLE', message='dereferenced expression Game.loop() is @Nullable'
/home/nima/Developer/nullness-benchmarks/litiengine/src/de/gurkenlabs/litiengine/GameWindow.java:381
            Game.loop().setTickRate(Game.config().client().getMaxFps());
---AdvancedNullAwayCodeFix.fix---
Fixing error: Type='DEREFERENCE_NULLABLE', message='dereferenced expression Game.loop() is @Nullable'
/home/nima/Developer/nullness-benchmarks/litiengine/src/de/gurkenlabs/litiengine/GameWindow.java:381
            Game.loop().setTickRate(Game.config().client().getMaxFps());
---AdvancedNullAwayCodeFix.resolveDereferenceError---
Resolving dereference error: Type='DEREFERENCE_NULLABLE', message='dereferenced expression Game.loop() is @Nullable'
/home/nima/Developer/nullness-benchmarks/litiengine/src/de/gurkenlabs/litiengine/GameWindow.java:381
            Game.loop().setTickRate(Game.config().client().getMaxFps());
---AdvancedNullAwayCodeFix.resolveDereferenceError---
Checking nullability possibility at error point
---ChatGPT.checkNullabilityPossibilityAtErrorPoint---
Asking if the expression can be null at error point point
---ChatGPT.ask---
Asking ChatGPT:
In the method below, is there a possibility that the expression "Game.loop()" at line "Game.loop().setTickRate(Game.config().client().getMaxFps());" is null?
private static void initializeWindowEventListeners(Window window) {

    window.addWindowStateListener(
        e -> {
          if (e.getNewState() == Frame.ICONIFIED) {
            Game.loop().setTickRate(ICONIFIED_MAX_FPS);
          } else {
            Game.loop().setTickRate(Game.config().client().getMaxFps());
          }
        });

    window.addWindowFocusListener(
        new WindowFocusListener() {
          @Override
          public void windowLostFocus(WindowEvent e) {
            if (Game.config().graphics().reduceFramesWhenNotFocused()) {
              Game.loop().setTickRate(NONE_FOCUS_MAX_FPS);
            }
          }

          @Override
          public void windowGainedFocus(WindowEvent e) {
            Game.loop().setTickRate(Game.config().client().getMaxFps());
          }
        });

    window.addWindowListener(
        new WindowAdapter() {
          @Override
          public void windowClosing(final WindowEvent event) {
            Game.exit();
          }
        });
}
Give a single-word answer in XML format. If it is possible for the expression to be null, respond with:
```xml
<response>
    <reason><![CDATA[YOUR REASON]]></reason>
    <value>YES</value>
</response>
```
If it is not possible for the expression to be null, respond with:
```xml
<response>
    <reason><![CDATA[YOUR REASON]]></reason>
    <value>NO</value>
</response>
```
If you are unsure or need more information, respond with where you can ask for more details or what specific information you need.

If additional information is required, list each request inside a `<request>` tag. If no additional information is needed, omit the `<requests>` section.

Respond with:
```xml
<response>
    <reason><![CDATA[YOUR REASON]]></reason>
    <value>UNKNOWN</value>
    <!-- Include <requests> only if additional information is needed -->
    <requests>
        <request><![CDATA[YOUR REQUEST 1]]></request>
        <request><![CDATA[YOUR REQUEST 2]]></request>
    </requests>
</response>
```
---ChatGPT.sendRequestToOpenAI---
Sending request to OpenAI...
---ChatGPT.sendRequestToOpenAI---
Response received from OpenAI.
---Response.<init>---
Creating Response:
```xml
<response>
    <reason><![CDATA[Without additional details or context about the Game class and the loop method, it's unclear whether Game.loop() can be null. This depends on how Game.loop() is implemented, the initialization logic, and lifecycle management in the Game class.]]></reason>
    <value>UNKNOWN</value>
    <requests>
        <request><![CDATA[Provide information or code regarding how Game.loop() is implemented or initialized.]]></request>
        <request><![CDATA[Clarify if there are conditions or configurations in which Game.loop() can return null.]]></request>
    </requests>
</response>
```
---Response.<init>---
Response created:
Unknown: Without additional details or context about the Game class and the loop method, it's unclear whether Game.loop() can be null. This depends on how Game.loop() is implemented, the initialization logic, and lifecycle management in the Game class.
---AdvancedNullAwayCodeFix.resolveMethodDereferenceError---
Resolving method dereference error.
---AdvancedNullAwayCodeFix.resolveMethodDereferenceError---
Method is in annotated package. Checking if the method is returning nullable.
---AdvancedNullAwayCodeFix.investigateMethodReturnNullability---
Checking if the method is returning nullable.
---ChatGPT.checkIfMethodIsReturningNullable---
Asking if the method is returning nullable: loop()
---ChatGPT.ask---
Asking ChatGPT:
In the method below, is there a possibility that the method returns null based only on its body? Consider the following points:

- The method may have multiple return paths; consider all return statements.
- If the method calls another method, do not assume its return value unless its full declaration is provided. Request its declaration if needed.
- The method may throw an exception instead of returning null. An exception path should not be considered a null return.
- Ensure you request the declarations of any methods whose return values directly or indirectly impact this method’s return value before making a conclusion.
- Carefully analyze all conditions and prior operations that may guarantee a non-null return value.

@Nullable public static IGameLoop loop() {
    return gameLoop;
}

Here are the method definitions in addition to the method inquired:

Depth: 0
```java
class de.gurkenlabs.litiengine.Game {
@Nullable public static IGameLoop loop() {
    return gameLoop;
}
}
```


Response Format:
Provide the answer in **XML format** as follows:

#### If the method **cannot** return `null`:
```xml
<response>
  <reason><![CDATA[EXPLAIN WHY THE METHOD CANNOT RETURN NULL]]></reason>
  <value>NO</value>
</response>
```

#### If the method can return null:
```xml
<response>
  <reason><![CDATA[EXPLAIN WHY THE METHOD CAN RETURN NULL]]></reason>
  <value>YES</value>
</response>
```

#### If you are unsure or need more information, respond with where you can ask for more details or what specific information you need.

#### If you are unsure or If there are any methods that directly or indirectly affect the return value and are not fully disclosed, request their declarations first, in the following format:
<response>
  <reason><![CDATA[YOUR REASON]]></reason>
  <value>UNKNOWN</value>
  <methods>
    <method>methodName</method>
  </methods>
</response>

If additional information is required other than method declaration, list each request inside a `<request>` tag. If no additional information is needed, omit the `<requests>` section.

Respond with:
```xml
<response>
    <reason><![CDATA[YOUR REASON]]></reason>
    <value>UNKNOWN</value>
    <!-- Include <requests> only if additional information is needed -->
    <requests>
        <request><![CDATA[YOUR REQUEST 1]]></request>
        <request><![CDATA[YOUR REQUEST 2]]></request>
    </requests>
</response>
```

Additional Notes:
Be precise in your reasoning.
If a method’s return value depends on another method not provided, request its declaration before making a conclusion.
If the method can return null in some cases but not others, explain under what conditions it can happen.

---ChatGPT.sendRequestToOpenAI---
Retrieving response from cache
---Response.<init>---
Creating Response:
```xml
<response>
  <reason><![CDATA[The method `loop` returns the variable `gameLoop`. Without the initialization or assignment details of `gameLoop`, it's unclear whether it can be null. The possibility of `gameLoop` being uninitialized or set to null elsewhere in the program means `loop` could potentially return null. Further information on `gameLoop` is required.]]></reason>
  <value>UNKNOWN</value>
  <requests>
    <request><![CDATA[Please provide the declaration and initialization of the variable `gameLoop` in the class `de.gurkenlabs.litiengine.Game`.]]></request>
  </requests>
</response>
```
---Response.<init>---
Response created:
Unknown: The method `loop` returns the variable `gameLoop`. Without the initialization or assignment details of `gameLoop`, it's unclear whether it can be null. The possibility of `gameLoop` being uninitialized or set to null elsewhere in the program means `loop` could potentially return null. Further information on `gameLoop` is required.
---AdvancedNullAwayCodeFix.investigateMethodReturnNullability---
Could not determine the nullability and model did not ask for any method.
---ChatGPT.checkIfMethodIsReturningNullableOnCallSite---
Asking if the method is returning nullable on the call site: Game.loop()
---ChatGPT.ask---
Asking ChatGPT:
In the method below, is there a possibility that the method returns null at the given call site?

```java
@Nullable public static IGameLoop loop() {
    return gameLoop;
}
```

## Guidelines:
- The method may have multiple return paths; consider all return statements.
- If the method calls another method, do not assume its return value unless its full declaration is provided. Request its declaration if needed.
- The method may throw an exception instead of returning null. An exception path should not be considered a null return.
- Ensure you request the declarations of any methods whose return values directly or indirectly impact this method’s return value before making a conclusion.
- If the method returns a value that is determined by a parameter, evaluate based on the actual argument at the given call site.
- Analyze based only on the specific invocation provided. Do not generalize to all possible inputs.- If the return value is guaranteed to be non-null at the call site, the answer should be a definitive NO.
- Do not generalize based on all possible inputs—your answer must be based only on the given invocation.
- Focus only on the given call site, not all possible invocations.

### call site:
Game.loop()

Here are the method definitions and the call chain for this method, showing the sequence of calls from the method to its callers at each depth level:

Depth: 0
```java
class de.gurkenlabs.litiengine.Game {
@Nullable public static IGameLoop loop() {
    return gameLoop;
}
}
```
Depth: 1
```java
class de.gurkenlabs.litiengine.environment.GameWorld {
public void loadEnvironment(@Nullable final Environment env) {
    Lock lock = Game.loop().getLock();
    lock.lock();
    try {
      unloadEnvironment();
      this.environment = env;
      if (env != null) {
        this.addEnvironment(env);

        if (env.getGravity() == 0 && this.gravity() != 0) {
          env.setGravity(this.gravity());
        }

        env.load();
        for (final EnvironmentLoadedListener listener : this.loadedListeners) {
          listener.loaded(env);
        }

        // call map specific listeners
        String mapName = getMapName(env);
        if (mapName != null && this.environmentLoadedListeners.containsKey(mapName)) {

          // for the default camera we center the camera on the environment
          if (this.camera().getClass().equals(Camera.class)) {
            camera().setFocus(env.getCenter());
          }

          for (EnvironmentLoadedListener listener : this.environmentLoadedListeners.get(mapName)) {
            listener.loaded(env);
          }
        }
      }
    } finally {
      lock.unlock();
    }
}public void setCamera(@Nullable final ICamera cam) {
    if (this.camera() != null) {
      Game.loop().detach(camera);
    }

    camera = cam;

    if (cam != null && !Game.isInNoGUIMode()) {
      Game.loop().attach(cam);
      cam.updateFocus();
    }
}
}
```
```java
class de.gurkenlabs.litiengine.entities.behavior.EntityNavigator {
public EntityNavigator(final IMobileEntity entity, final PathFinder pathFinder) {
    this.cancelNavigationConditions = new CopyOnWriteArrayList<>();
    this.listeners = new CopyOnWriteArrayList<>();
    this.entity = entity;
    this.pathFinder = pathFinder;
    this.setAcceptableError(DEFAULT_ACCEPTABLE_ERROR);
    Game.loop().attach(this);
}
}
```
```java
class de.gurkenlabs.litiengine.GameWindow {
private static void initializeWindowEventListeners(Window window) {

    window.addWindowStateListener(
        e -> {
          if (e.getNewState() == Frame.ICONIFIED) {
            Game.loop().setTickRate(ICONIFIED_MAX_FPS);
          } else {
            Game.loop().setTickRate(Game.config().client().getMaxFps());
          }
        });

    window.addWindowFocusListener(
        new WindowFocusListener() {
          @Override
          public void windowLostFocus(WindowEvent e) {
            if (Game.config().graphics().reduceFramesWhenNotFocused()) {
              Game.loop().setTickRate(NONE_FOCUS_MAX_FPS);
            }
          }

          @Override
          public void windowGainedFocus(WindowEvent e) {
            Game.loop().setTickRate(Game.config().client().getMaxFps());
          }
        });

    window.addWindowListener(
        new WindowAdapter() {
          @Override
          public void windowClosing(final WindowEvent event) {
            Game.exit();
          }
        });
}
}
```
```java
class de.gurkenlabs.litiengine.gui.screens.ScreenManager {
public void display(@Nullable final Screen screen) {
    if (Game.hasStarted() && Game.time().since(this.lastScreenChange) < this.getChangeCooldown()) {
      log.log(
          Level.INFO,
          "Skipping displaying of screen {0} because screen changing is currently on cooldown.",
          screen != null ? screen.getName() : "");
      return;
    }

    final Screen previous = this.current();
    if (previous != null) {
      previous.suspend();
    }

    if (screen != null && !this.screens.contains(screen)) {
      this.screens.add(screen);
    }

    this.currentScreen = screen;
    if (!Game.isInNoGUIMode() && this.current() != null) {
      this.current().prepare();
    }

    this.lastScreenChange = Game.loop().getTicks();

    final ScreenChangedEvent event = new ScreenChangedEvent(this.current(), previous);
    for (final ScreenChangedListener listener : this.screenChangedListeners) {
      listener.changed(event);
    }
}
}
```
```java
class de.gurkenlabs.litiengine.abilities.effects.Effect {
@Override
  public void update() {

    for (final Iterator<EffectApplication> iterator = this.getActiveAppliances().iterator();
        iterator.hasNext(); ) {
      final EffectApplication appliance = iterator.next();
      // if the effect duration is reached
      if (this.hasEnded(appliance)) {

        iterator.remove();
        this.cease(appliance);
      }
    }

    // 4. unregister if all appliances are finished
    if (this.getActiveAppliances().isEmpty()) {
      Game.loop().detach(this);
    }
}public void apply(final Shape impactArea) {
    final List<ICombatEntity> affected = this.lookForAffectedEntities(impactArea);
    for (final ICombatEntity affectedEntity : affected) {
      this.apply(affectedEntity);
    }

    this.appliances.add(new EffectApplication(affected, impactArea));

    // if it is the first appliance -> register for update
    if (this.appliances.size() == 1) {
      Game.loop().attach(this);
    }
}
}
```
```java
class de.gurkenlabs.litiengine.GameTime {
public long toTicks(final int milliseconds) {
    return this.toTicks(milliseconds, Game.loop().getTickRate());
}public long since(final long tick) {
    return toMilliseconds(Game.loop().getTicks() - tick);
}public long now() {
    return Game.loop().getTicks();
}public long sinceGameStart() {
    return this.toMilliseconds(Game.loop().getTicks());
}@Override
  public void loaded(Environment environment) {
    environmentLoaded = Game.loop().getTicks();
}public long toMilliseconds(final long ticks) {
    return this.toMilliseconds(ticks, Game.loop().getTickRate());
}
}
```
```java
class de.gurkenlabs.litiengine.GameMetrics {
@Override
  public void render(final Graphics2D g) {
    this.updateMetrics();

    if (!Game.config().client().showGameMetrics()) {
      return;
    }

    this.currentOffsetY = 0;

    g.setColor(this.renderColor);

    // render client metrics
    this.drawTitle(g, "[client]");
    this.drawMetric(g, "fps       : " + this.getFramesPerSecond());
    this.drawMetric(g, "max fps   : " + this.maxFramesPerSecond);
    this.drawMetric(g, "updatables: " + Game.loop().getUpdatableCount());

    // render jvm metrics if debug is enabled
    if (Game.config().debug().isDebugEnabled()) {
      this.drawTitle(g, "[jvm]");
      this.drawMetric(g, "java      : " + this.javaVersion);
      this.drawMetric(g, "memory    : " + String.format("%-5.5s", this.usedMemory) + " MB");
      this.drawMetric(g, "threads   : " + Thread.activeCount());
    }

    // render rendering metrics
    if (!this.renderMetrics.isEmpty()) {
      this.drawTitle(g, "[update]");

      for (RenderMetrics metric : this.renderMetrics) {
        this.drawMetric(g, metric.toString());
      }

      this.renderMetrics.clear();
    }
}
}
```
```java
class de.gurkenlabs.litiengine.graphics.emitters.Emitter {
public void deactivate() {
    if (!this.activated) {
      return;
    }

    this.activated = false;
    this.getParticles().clear();
    this.aliveTime = 0;
    this.activationTick = 0;
    this.lastSpawn = 0;
    Game.loop().detach(this);
}public void activate() {
    if (this.activated) {
      return;
    }

    this.activated = true;
    this.activationTick = Game.time().now();
    Game.loop().attach(this);
}@Override
  public void update() {
    if (this.isPaused()) {
      return;
    }

    // clear particles if the effect time to life is reached
    if (this.isFinished()) {
      for (EmitterFinishedListener listener : this.finishedListeners) {
        listener.finished(this);
      }

      this.delete();
      return;
    }

    final float updateRatio = (float) this.data().getUpdateRate() / Game.loop().getTickRate();
    for (final Particle p : this.getParticles().stream().collect(Collectors.toList())) {
      if (this.particleCanBeRemoved(p)) {
        // remove dead particles
        this.particles.remove(p);
        continue;
      }

      p.update(this.getOrigin(), updateRatio);
    }

    this.aliveTime = Game.time().since(this.activationTick);
    if ((this.data().getSpawnRate() == 0
        || Game.time().since(this.lastSpawn) >= this.data().getSpawnRate())) {
      this.lastSpawn = Game.time().now();
      this.spawnParticle();
    }
}
}
```
```java
class de.gurkenlabs.litiengine.entities.behavior.IBehaviorController {
public default void attach() {
    Game.loop().attach(this);
}public default void detach() {
    Game.loop().detach(this);
}
}
```
```java
class de.gurkenlabs.litiengine.abilities.AbilityExecution {
AbilityExecution(final Ability ability) {
    this.appliedEffects = new CopyOnWriteArrayList<>();
    this.ability = ability;
    this.executionTicks = Game.time().now();
    this.impactArea = ability.calculateImpactArea();
    this.castLocation = ability.getExecutor().getCenter();
    Game.loop().attach(this);
}@Override
  public void update() {
    // if there a no effects to apply -> unregister this instance and we're done
    if (this.getAbility().getEffects().isEmpty()
        || this.getAbility().getEffects().size() == this.getAppliedEffects().size()) {
      Game.loop().detach(this);
      return;
    }

    // handle all effects from the ability that were not applied yet
    for (final Effect effect : this.getAbility().getEffects()) {
      // if the ability was not executed yet or the delay of the effect is not
      // yet reached
      if (this.getAppliedEffects().contains(effect)
          || Game.time().since(this.getExecutionTicks()) < effect.getDelay()) {
        continue;
      }

      effect.apply(this.getExecutionImpactArea());
      this.getAppliedEffects().add(effect);
    }
}
}
```
```java
class de.gurkenlabs.litiengine.GameWindow$3 {
@Override
          public void windowGainedFocus(WindowEvent e) {
            Game.loop().setTickRate(Game.config().client().getMaxFps());
}@Override
          public void windowLostFocus(WindowEvent e) {
            if (Game.config().graphics().reduceFramesWhenNotFocused()) {
              Game.loop().setTickRate(NONE_FOCUS_MAX_FPS);
            }
}
}
```
```java
class de.gurkenlabs.litiengine.environment.EntitySpawner {
protected void spawnNewEntities() {
    if (this.getSpawnMode() != SpawnMode.CUSTOMSPAWNPOINTS && this.getSpawnPoints().isEmpty()) {
      return;
    }

    switch (this.getSpawnMode()) {
      case ALLSPAWNPOINTS:
        for (int i = 0; i < this.getSpawnPoints().size(); i++) {
          final int index = i;
          Game.loop()
              .perform(
                  this.getSpawnDelay() + this.getSpawnDelay() * i,
                  () -> this.spawn(this.getSpawnPoints().get(index), this.getSpawnAmount()));
        }
        break;
      case ONERANDOMSPAWNPOINT:
        this.spawn(Game.random().choose(this.getSpawnPoints()), this.getSpawnAmount());
        break;
      case RANDOMSPAWNPOINTS:
        for (int i = 0; i < this.getSpawnAmount(); i++) {
          Game.loop()
              .perform(
                  this.getSpawnDelay() + this.getSpawnDelay() * i,
                  () -> this.spawn(Game.random().choose(this.getSpawnPoints()), 1));
        }
        break;
      case CUSTOMSPAWNPOINTS:
        List<Spawnpoint> spawnPoints =
            this.customSpawnpoints != null
                ? this.customSpawnpoints.apply(this)
                : this.getCustomSpawnpoints();

        int index = 0;
        for (Spawnpoint spawn : spawnPoints) {
          Game.loop()
              .perform(
                  this.getSpawnDelay() + this.getSpawnDelay() * index, () -> this.spawn(spawn, 1));
          index++;
        }
        break;
      default:
        break;
    }
}
}
```
```java
class de.gurkenlabs.litiengine.tweening.TweenEngine {
@Override
  public void start() {
    Game.loop().attach(this);
}@Override
  public void terminate() {
    Game.loop().detach(this);
}
}
```
```java
class de.gurkenlabs.litiengine.gui.SpeechBubble {
public void hide() {
    Game.world().environment().removeRenderable(this);
    Game.loop().detach(this);
    if (activeSpeechBubbles.get(this.getEntity()) != null
        && activeSpeechBubbles.remove(this.getEntity()).equals(this)) {
      activeSpeechBubbles.remove(this.getEntity());
    }

    for (SpeechBubbleListener listener : this.listeners) {
      listener.hidden();
    }
}private SpeechBubble(
      final IEntity entity,
      final String text,
      @Nullable SpeechBubbleAppearance appearance,
      @Nullable Font font) {
    if (appearance == null) {
      this.appearance = DEFAULT_APPEARANCE;
    } else {
      this.appearance = appearance;
    }

    final SpeechBubble active = activeSpeechBubbles.get(entity);
    if (active != null) {
      active.hide();
    }
    this.setFont(font);

    this.textBoxWidth = (float) (entity.getWidth() * 4);
    this.entity = entity;

    this.currentText = text;
    this.currentTextDisplayTime = DISPLAYTIME_MIN + text.length() * DISPLAYTIME_PER_LETTER;

    this.lastTextDisplay = Game.time().now();
    this.createBubbleImage();
    entity.getEnvironment().add(this, RenderType.UI);
    Game.loop().attach(this);
    activeSpeechBubbles.put(entity, this);
}
}
```
```java
class de.gurkenlabs.litiengine.entities.Prop {
private void updateAnimationController() {
    IEntityAnimationController<?> controller = this.createAnimationController();
    this.getControllers().addController(controller);
    if (Game.world().environment() != null && Game.world().environment().isLoaded()) {
      Game.loop().attach(controller);
    }
}
}
```
```java
class de.gurkenlabs.litiengine.graphics.FreeFlightCamera {
public FreeFlightCamera(final Point2D focus) {
    this.setFocus(focus);
    this.velocity = DEFAULT_SCROLL_PIXELS_PER_SECOND;
    this.scrollPadding = DEFAULT_SCROLL_PADDING;
    this.setClampToMap(true);

    Game.loop().attach(this);
}private void handleFreeFlightCamera() {
    if (Game.world().environment() == null || Game.world().environment().getMap() == null) {
      return;
    }

    final Point2D mouseLocation = Input.mouse().getLocation();

    final double scrollSpeed =
        this.getVelocity()
            / (double) Game.loop().getTickRate()
            * Game.config().input().getMouseSensitivity();

    double x = this.getFocus().getX();
    double y = this.getFocus().getY();

    double deltaX = 0;
    if (mouseLocation.getX() < this.getScrollPadding()) {
      deltaX -= scrollSpeed;
    } else if (Game.window().getResolution().getWidth() - mouseLocation.getX()
        < this.getScrollPadding()) {
      deltaX += scrollSpeed;
    }

    double deltaY = 0;
    if (mouseLocation.getY() < this.getScrollPadding()) {
      deltaY -= scrollSpeed;
    } else if (Game.window().getResolution().getHeight() - mouseLocation.getY()
        < this.getScrollPadding()) {
      deltaY += scrollSpeed;
    }

    x += deltaX;
    y += deltaY;

    this.setFocus(new Point2D.Double(x, y));
}
}
```
```java
class de.gurkenlabs.litiengine.environment.Environment {
private static void dispose(final Collection<? extends IEntity> entities) {
    for (final IEntity entity : entities) {
      if (entity instanceof IUpdateable) {
        Game.loop().detach((IUpdateable) entity);
      }

      entity.detachControllers();
    }
}private static void loadUpdatableOrEmitterEntity(IEntity entity) {
    if (entity instanceof Emitter) {
      final Emitter emitter = (Emitter) entity;
      if (emitter.isActivateOnInit()) {
        emitter.activate();
      }
    } else if (entity instanceof IUpdateable) {
      Game.loop().attach((IUpdateable) entity);
    }
}private void unload(final IEntity entity) {
    // 1. remove from physics engine
    if (entity instanceof ICollisionEntity) {
      Game.physics().remove((ICollisionEntity) entity);
    }

    // 2. unregister from update
    if (entity instanceof IUpdateable) {
      Game.loop().detach((IUpdateable) entity);
    }

    if (entity instanceof IMobileEntity) {
      this.removeGravity((IMobileEntity) entity);
    }

    // 3. detach all controllers
    entity.detachControllers();

    if (entity instanceof Emitter) {
      Emitter em = (Emitter) entity;
      em.deactivate();
    }

    if (this.loaded && (entity instanceof LightSource || entity instanceof StaticShadow)) {
      this.updateLighting(entity);
    }

    entity.removed(this);
}
}
```
```java
class de.gurkenlabs.litiengine.graphics.animation.Animation {
@Override
  public void update() {
    // do nothing if the animation is not playing or the current keyframe is not finished
    if (!this.isPlaying()
        || Game.time().since(this.lastFrameUpdate) < this.getCurrentKeyFrame().getDuration()) {
      return;
    }

    // if we are not looping and the last keyframe is finished, we terminate the animation
    if (!this.isLooping() && this.isLastKeyFrame()) {
      this.terminate();
      return;
    }

    // make sure, we stay inside the keyframe list
    final int newFrameIndex =
        (this.getKeyframes().indexOf(this.currentFrame) + 1) % this.getKeyframes().size();
    final KeyFrame previousFrame = this.currentFrame;
    this.currentFrame = this.getKeyframes().get(newFrameIndex);

    for (KeyFrameListener listener : this.listeners) {
      listener.currentFrameChanged(previousFrame, this.currentFrame);
    }

    this.lastFrameUpdate = Game.loop().getTicks();
}public void restart() {
    this.currentFrame = this.firstFrame;
    this.lastFrameUpdate = Game.loop().getTicks();
}
}
```
```java
class de.gurkenlabs.litiengine.physics.MovementController {
@Override
  public void attach() {
    Game.loop().attach(this);
}private void handleForces() {
    // clean up forces
    this.activeForces.forEach(
        x -> {
          if (x.hasEnded()) {
            this.activeForces.remove(x);
          }
        });

    if (this.activeForces.isEmpty()) {
      return;
    }

    // disable turn-on-move for force handling
    boolean turn = this.getEntity().turnOnMove();
    this.getEntity().setTurnOnMove(false);
    try {
      double deltaX = 0;
      double deltaY = 0;
      for (final Force force : this.activeForces) {
        if (force.cancelOnReached() && force.hasReached(this.getEntity())) {
          force.end();
          continue;
        }

        final Point2D collisionBoxCenter = this.getEntity().getCollisionBoxCenter();
        final double angle =
            GeometricUtilities.calcRotationAngleInDegrees(collisionBoxCenter, force.getLocation());
        final double strength =
            Game.loop().getDeltaTime() * 0.001f * force.getStrength() * Game.loop().getTimeScale();
        deltaX += GeometricUtilities.getDeltaX(angle, strength);
        deltaY += GeometricUtilities.getDeltaY(angle, strength);
      }

      final Point2D target =
          new Point2D.Double(this.getEntity().getX() + deltaX, this.getEntity().getY() + deltaY);
      final boolean success = Game.physics().move(this.getEntity(), target);
      if (!success) {
        for (final Force force : this.activeForces) {
          if (force.cancelOnCollision()) {
            force.end();
          }
        }
      }
    } finally {
      this.getEntity().setTurnOnMove(turn);
    }
}@Override
  public void detach() {
    Game.loop().detach(this);
}public void handleMovement() {
    if (!this.isMovementAllowed()) {
      this.velocity = 0;
      return;
    }

    // max distance an entity can travel within one tick
    final double maxPixelsPerTick = this.getEntity().getTickVelocity();
    final double deltaTime = Game.loop().getDeltaTime() * Game.loop().getTimeScale();

    final double acceleration =
        this.getEntity().getAcceleration() == 0
            ? maxPixelsPerTick
            : deltaTime / this.getEntity().getAcceleration() * maxPixelsPerTick;
    final double deceleration =
        this.getEntity().getDeceleration() == 0
            ? this.getVelocity()
            : deltaTime / this.getEntity().getDeceleration() * maxPixelsPerTick;

    double dx = this.getDx();
    double dy = this.getDy();
    this.setDx(0);
    this.setDy(0);

    final double deltaVelocity =
        Math.min(Math.sqrt(Math.pow(dx, 2) + Math.pow(dy, 2)), acceleration);
    if (deltaVelocity != 0) {
      double newVelocity = this.getVelocity() + deltaVelocity;
      this.setVelocity(newVelocity);
    } else {
      final double newVelocity = Math.max(0, this.getVelocity() - deceleration);
      this.setVelocity(newVelocity);
      dx = GeometricUtilities.getDeltaX(this.moveAngle);
      dy = GeometricUtilities.getDeltaY(this.moveAngle);
    }

    if (this.getVelocity() == 0) {
      this.moveAngle = 0;
      return;
    }

    // actually move entity
    this.moveEntity(dx, dy);
}
}
```
```java
class de.gurkenlabs.litiengine.graphics.animation.AnimationController {
public void detach() {
    Game.loop().detach(this);
}public void attach() {
    Game.loop().attach(this);
}
}
```
```java
class de.gurkenlabs.litiengine.graphics.Camera {
@Override
  public void setZoom(final float targetZoom, final int delay) {
    if (delay == 0) {

      this.zoom = targetZoom;
      this.targetZoom = 0;
      this.zoomDelay = 0;
      this.zoomTick = 0;
      this.zoomStep = 0;

      final ZoomChangedEvent event = new ZoomChangedEvent(this, targetZoom);
      for (final ZoomChangedListener listener : this.zoomListeners) {
        listener.zoomChanged(event);
      }
    } else {
      this.zoomTick = Game.time().now();
      this.targetZoom = targetZoom;
      this.zoomDelay = delay;

      final double tickduration = 1000 / (double) Game.loop().getTickRate();
      final double tickAmount = delay / tickduration;
      final float totalDelta = this.targetZoom - this.zoom;
      this.zoomStep = tickAmount > 0 ? (float) (totalDelta / tickAmount) : totalDelta;
    }
}
}
```
```java
class de.gurkenlabs.litiengine.Game {
public static synchronized void init(String... args) {
    if (initialized) {
      log().log(Level.INFO, "The game has already been initialized.");
      return;
    }

    log.init();
    handleCommandLineArguments(args);

    config().load();
    Locale.setDefault(new Locale(config().client().getCountry(), config().client().getLanguage()));

    gameLoop = new GameLoop("Main Update Loop", config().client().getMaxFps());
    loop().attach(physics());
    loop().attach(world());

    // setup default exception handling for render and update loop
    setUncaughtExceptionHandler(
        new DefaultUncaughtExceptionHandler(config().client().exitOnError()));

    screenManager = new ScreenManager();
    gameWindow = new GameWindow();

    // initialize  the game window
    window().init();
    world.setCamera(new Camera());

    for (GameListener listener : gameListeners) {
      listener.initialized(args);
    }

    if (!isInNoGUIMode()) {
      window().getRenderComponent().onRendered(g -> metrics().render(g));

      graphics()
          .addEntityRenderedListener(
              e -> DebugRenderer.renderEntityDebugInfo(e.getGraphics(), e.getEntity()));

      window().getRenderComponent().onFpsChanged(fps -> metrics().setFramesPerSecond(fps));
      window()
          .setIcons(
              Arrays.asList(
                  Resources.images().get("liti-logo-x16.png"),
                  Resources.images().get("liti-logo-x20.png"),
                  Resources.images().get("liti-logo-x32.png"),
                  Resources.images().get("liti-logo-x48.png")));

      Input.keyboard()
          .onKeyTyped(
              KeyEvent.VK_PRINTSCREEN,
              key -> {
                // don't take a screenshot if a modifier is active
                if (key.getModifiers() != 0) {
                  return;
                }

                window().getRenderComponent().takeScreenshot();
              });
    }

    Runtime.getRuntime().addShutdownHook(new Thread(Game::terminate, "Shutdown"));

    initialized = true;
}
}
```
```java
class de.gurkenlabs.litiengine.entities.Creature {
protected void updateAnimationController() {
    IEntityAnimationController<?> controller = this.createAnimationController();
    this.getControllers().addController(controller);
    if (Game.world().environment() != null && Game.world().environment().isLoaded()) {
      Game.loop().attach(controller);
    }
}@Override
  public float getTickVelocity() {
    // pixels per ms multiplied by the passed ms
    // ensure that entities don't travel too far in case of lag
    return Math.min(Game.loop().getDeltaTime(), GameLoop.TICK_DELTATIME_LAG)
        * 0.001F
        * this.getVelocity().get()
        * Game.loop().getTimeScale();
}
}
```
Depth: 2
```java
class de.gurkenlabs.litiengine.environment.GameWorld {
public void clear() {
    this.unloadEnvironment();
    this.environments.clear();
    this.setCamera(null);
    Game.physics().clear();

    this.environmentListeners.clear();
    this.environmentLoadedListeners.clear();
    this.environmentUnloadedListeners.clear();

    this.listeners.clear();
    this.loadedListeners.clear();
    this.unloadedListeners.clear();
}@Nullable
  public Environment loadEnvironment(IMap map) {
    Environment env = this.getEnvironment(map);
    this.loadEnvironment(env);
    return env;
}@Nullable
  public Environment loadEnvironment(String mapName) {
    Environment env = this.getEnvironment(mapName);
    this.loadEnvironment(env);
    return env;
}
}
```
```java
class de.gurkenlabs.litiengine.GameWindow {
GameWindow() {
    this.hostControl = new JFrame();

    this.resolutionChangedListeners = new CopyOnWriteArrayList<>();

    this.renderCanvas = new RenderComponent(Game.config().graphics().getResolution());
    this.cursor = new MouseCursor();
    if (!Game.isInNoGUIMode()) {
      this.hostControl.setBackground(Color.BLACK);
      this.hostControl.add(this.renderCanvas);

      this.initializeEventListeners();

      this.hostControl.setTitle(Game.info().getTitle());
      this.hostControl.setDefaultCloseOperation(WindowConstants.DO_NOTHING_ON_CLOSE);
      initializeWindowEventListeners(this.hostControl);
    }
}
}
```
```java
class de.gurkenlabs.litiengine.GameTime {
public long sinceEnvironmentLoad() {
    return this.since(this.environmentLoaded);
}public long since(final long tick) {
    return toMilliseconds(Game.loop().getTicks() - tick);
}public long sinceGameStart() {
    return this.toMilliseconds(Game.loop().getTicks());
}
}
```
```java
class de.gurkenlabs.litiengine.abilities.effects.Effect {
protected void cease(final EffectApplication appliance) {
    // 1. cease the effect for all affected entities
    for (final ICombatEntity entity : appliance.getAffectedEntities()) {
      this.cease(entity);
    }

    // 2. apply follow up effects
    this.getFollowUpEffects().forEach(followUp -> followUp.apply(appliance.getImpactArea()));
}protected boolean hasEnded(final EffectApplication appliance) {
    final long effectDuration = Game.time().since(appliance.getAppliedTicks());
    return effectDuration > this.getDuration();
}
}
```
```java
class de.gurkenlabs.litiengine.abilities.effects.EffectApplication {
protected EffectApplication(final List<ICombatEntity> affectedEntities, final Shape impactArea) {
    this.applied = Game.time().now();
    this.affectedEntities = affectedEntities;
    this.impactArea = impactArea;
}
}
```
```java
class de.gurkenlabs.litiengine.entities.CombatEntity {
@Override
  public boolean wasHit(int timeSpan) {
    return Game.time().since(this.lastHit) < timeSpan;
}@Override
  public void hit(final int damage, @Nullable final Ability ability) {
    if (this.isDead()) {
      return;
    }

    if (!this.isIndestructible()) {
      this.getHitPoints().modifyBaseValue(new AttributeModifier<>(Modification.SUBTRACT, damage));
    }

    final EntityHitEvent event = new EntityHitEvent(this, ability, damage, this.isDead());

    for (final CombatEntityListener listener : this.listeners) {
      listener.hit(event);
    }

    for (final CombatEntityHitListener listener : this.hitListeners) {
      listener.hit(event);
    }

    if (this.isDead()) {
      this.fireDeathEvent();
      this.setCollision(false);
    }

    this.lastHit = Game.time().now();
}
}
```
```java
class de.gurkenlabs.litiengine.graphics.ImageEffect {
protected ImageEffect(final int ttl, final String name) {
    this.ttl = ttl;
    this.name = name;
    this.aliveTick = Game.time().now();
}@Override
  public long getAliveTime() {
    return Game.time().since(this.aliveTick);
}
}
```
```java
class de.gurkenlabs.litiengine.abilities.AbilityExecution {
AbilityExecution(final Ability ability) {
    this.appliedEffects = new CopyOnWriteArrayList<>();
    this.ability = ability;
    this.executionTicks = Game.time().now();
    this.impactArea = ability.calculateImpactArea();
    this.castLocation = ability.getExecutor().getCenter();
    Game.loop().attach(this);
}@Override
  public void update() {
    // if there a no effects to apply -> unregister this instance and we're done
    if (this.getAbility().getEffects().isEmpty()
        || this.getAbility().getEffects().size() == this.getAppliedEffects().size()) {
      Game.loop().detach(this);
      return;
    }

    // handle all effects from the ability that were not applied yet
    for (final Effect effect : this.getAbility().getEffects()) {
      // if the ability was not executed yet or the delay of the effect is not
      // yet reached
      if (this.getAppliedEffects().contains(effect)
          || Game.time().since(this.getExecutionTicks()) < effect.getDelay()) {
        continue;
      }

      effect.apply(this.getExecutionImpactArea());
      this.getAppliedEffects().add(effect);
    }
}
}
```
```java
class de.gurkenlabs.litiengine.tweening.TweenEngine {
@Override
  public void update() {
    for (final Tweenable target : this.getTweens().keySet()) {
      for (final Tween tween : this.getTweens().get(target).values()) {
        if (tween.hasStopped()) {
          continue;
        }
        final long elapsed = Game.time().since(tween.getStartTime());
        if (elapsed >= tween.getDuration()) {
          tween.stop();
          continue;
        }
        final float[] currentValues = new float[tween.getTargetValues().length];
        for (int i = 0; i < tween.getTargetValues().length; i++) {
          currentValues[i] =
              tween.getStartValues()[i]
                  + tween.getEquation().compute(elapsed / (float) tween.getDuration())
                      * (tween.getTargetValues()[i] - tween.getStartValues()[i]);
        }
        tween.getTarget().setTweenValues(tween.getType(), currentValues);
      }
    }
}
}
```
```java
class de.gurkenlabs.litiengine.gui.SpeechBubble {
public static SpeechBubble create(
      final IEntity entity, final String text, SpeechBubbleAppearance appearance, Font font) {
    return new SpeechBubble(entity, text, appearance, font);
}public static SpeechBubble create(final IEntity entity, final Font font, final String text) {
    SpeechBubbleAppearance app =
        new SpeechBubbleAppearance(
            DEFAULT_APPEARANCE.getForeColor(),
            DEFAULT_APPEARANCE.getBackgroundColor1(),
            DEFAULT_APPEARANCE.getBorderColor(),
            DEFAULT_APPEARANCE.getPadding());
    return new SpeechBubble(entity, text, app, font);
}public static SpeechBubble create(final IEntity entity, final String text) {
    return new SpeechBubble(entity, text, null, GuiProperties.getDefaultFont());
}@Override
  public void update() {
    if (this.currentText == null) {
      this.hide();
      return;
    }

    this.entityCenter = Game.world().camera().getViewportLocation(this.getEntity().getCenter());

    // old text was displayed long enough
    if (this.lastTextDisplay != 0
        && Game.time().since(this.lastTextDisplay) > this.currentTextDisplayTime) {
      this.currentText = null;
      this.lastTextDisplay = 0;
      return;
    }

    // display new text
    if (this.textIndex < this.currentText.length()
        && Game.time().since(this.lastCharPoll) > LETTER_WRITE_DELAY) {
      this.textIndex++;
      this.lastCharPoll = Game.time().now();
      if (this.typeSound != null) {
        Game.audio().playSound(this.typeSound, this.getEntity());
      }
    }

    // continue displaying currently displayed text
}private SpeechBubble(
      final IEntity entity,
      final String text,
      final Sound typeSound,
      SpeechBubbleAppearance appearance,
      Font font) {
    this(entity, text, appearance, font);
    this.typeSound = typeSound;
}private SpeechBubble(
      final IEntity entity,
      final String text,
      @Nullable SpeechBubbleAppearance appearance,
      @Nullable Font font) {
    if (appearance == null) {
      this.appearance = DEFAULT_APPEARANCE;
    } else {
      this.appearance = appearance;
    }

    final SpeechBubble active = activeSpeechBubbles.get(entity);
    if (active != null) {
      active.hide();
    }
    this.setFont(font);

    this.textBoxWidth = (float) (entity.getWidth() * 4);
    this.entity = entity;

    this.currentText = text;
    this.currentTextDisplayTime = DISPLAYTIME_MIN + text.length() * DISPLAYTIME_PER_LETTER;

    this.lastTextDisplay = Game.time().now();
    this.createBubbleImage();
    entity.getEnvironment().add(this, RenderType.UI);
    Game.loop().attach(this);
    activeSpeechBubbles.put(entity, this);
}
}
```
```java
class de.gurkenlabs.litiengine.gui.TextFieldComponent {
@Override
  public void render(final Graphics2D g) {
    super.render(g);
    g.setFont(this.getFont());
    final FontMetrics fm = g.getFontMetrics();

    if (this.isSelected() && Game.time().since(this.lastToggled) > this.flickerDelay) {
      this.cursorVisible = !this.cursorVisible;
      this.lastToggled = Game.time().now();
    }
    if (this.isSelected() && this.cursorVisible) {
      final Rectangle2D cursor =
          new Rectangle2D.Double(
              this.getX() + this.getTextX() + fm.stringWidth(this.getTextToRender(g)),
              this.getY() + this.getTextY(),
              this.getFont().getSize2D() * 3 / 5,
              this.getFont().getSize2D() * 1 / 5);
      g.setColor(this.getAppearance().getForeColor());
      g.fill(cursor);
    }
}
}
```
```java
class de.gurkenlabs.litiengine.entities.Prop {
public Prop(
      final Point2D location, @Nullable final String spritesheetName, final Material material) {
    super();
    this.rotation = Rotation.NONE;
    this.spritesheetName = spritesheetName;
    this.material = material;
    this.setLocation(location);
    this.updateAnimationController();
}public void setSpritesheetName(@Nullable final String spriteName) {
    this.spritesheetName = spriteName;
    this.updateAnimationController();
}
}
```
```java
class de.gurkenlabs.litiengine.tweening.Tween {
public Tween begin() {
    this.started = Game.time().now();
    this.stopped = false;
    return this;
}
}
```
```java
class de.gurkenlabs.litiengine.graphics.emitters.particles.Particle {
public void update(final Point2D emitterOrigin, final float updateRatio) {
    if (this.aliveTick == 0) {
      this.aliveTick = Game.time().now();
    }

    this.aliveTime = Game.time().since(this.aliveTick);
    if (this.timeToLiveReached()) {
      return;
    }

    if (this.colliding) {
      return;
    }

    if (this.getDeltaWidth() != 0) {
      this.width += this.getDeltaWidth() * updateRatio;
    }

    if (this.getDeltaHeight() != 0) {
      this.height += this.getDeltaHeight() * updateRatio;
    }

    if (this.getDeltaAngle() != 0) {
      this.angle += this.getDeltaAngle() * updateRatio;
    }

    // test for ray cast collision
    final float targetX = this.x + this.getVelocityX() * updateRatio;
    final float targetY = this.y + this.getVelocityY() * updateRatio;

    if (targetX == this.x && targetY == this.y) {
      return;
    }

    if (this.checkForCollision(emitterOrigin, targetX, targetY)) {
      return;
    }

    if (this.getVelocityX() != 0) {
      this.x = targetX;
    }

    if (this.getVelocityY() != 0) {
      this.y = targetY;
    }

    if (this.getAccelerationX() != 0) {
      this.velocityX += this.getAccelerationX() * updateRatio;
    }

    if (this.getAccelerationY() != 0) {
      this.velocityY += this.getAccelerationY() * updateRatio;
    }
}
}
```
```java
class de.gurkenlabs.litiengine.graphics.animation.Animation {
@Override
  public void start() {
    this.playing = true;
    if (this.getKeyframes().isEmpty()) {
      return;
    }

    this.restart();
}@Override
  public void update() {
    // do nothing if the animation is not playing or the current keyframe is not finished
    if (!this.isPlaying()
        || Game.time().since(this.lastFrameUpdate) < this.getCurrentKeyFrame().getDuration()) {
      return;
    }

    // if we are not looping and the last keyframe is finished, we terminate the animation
    if (!this.isLooping() && this.isLastKeyFrame()) {
      this.terminate();
      return;
    }

    // make sure, we stay inside the keyframe list
    final int newFrameIndex =
        (this.getKeyframes().indexOf(this.currentFrame) + 1) % this.getKeyframes().size();
    final KeyFrame previousFrame = this.currentFrame;
    this.currentFrame = this.getKeyframes().get(newFrameIndex);

    for (KeyFrameListener listener : this.listeners) {
      listener.currentFrameChanged(previousFrame, this.currentFrame);
    }

    this.lastFrameUpdate = Game.loop().getTicks();
}
}
```
```java
class de.gurkenlabs.litiengine.graphics.animation.AnimationController {
@Override
  public void update() {
    for (final Animation animation : this.getAll()) {
      animation.update();
    }

    if (this.getCurrent() != null && this.getCurrent().isPaused()) {
      return;
    }

    final boolean playbackFinished = this.getCurrent() != null && !this.getCurrent().isPlaying();
    if (playbackFinished) {
      for (final AnimationListener listener : this.listeners) {
        listener.finished(this.getCurrent());
      }
    }

    if (this.getCurrent() == null || playbackFinished) {
      if (this.getDefault() != null) {
        this.play(this.getDefault().getName());
      } else {
        this.currentAnimation = null;
      }
    }
}
}
```
```java
class de.gurkenlabs.litiengine.graphics.RenderComponent {
private void handleFade() {
    if (this.fadeOutStart != -1) {
      final long timePassed = Game.time().since(this.fadeOutStart);
      this.currentAlpha = MathUtilities.clamp(1 - timePassed / (float) this.fadeOutTime, 0, 1);
      if (this.currentAlpha == 0f) {
        this.fadeOutStart = -1;
        this.fadeOutTime = -1;
      }

      return;
    }

    if (this.fadeInStart != -1) {
      final long timePassed = Game.time().since(this.fadeInStart);
      this.currentAlpha = MathUtilities.clamp(timePassed / (float) this.fadeInTime, 0, 1);
      if (this.currentAlpha == 1f) {
        this.fadeInStart = -1;
        this.fadeInTime = -1;
        this.currentAlpha = Float.NaN;
      }
    }
}public void fadeOut(final int ms) {
    this.fadeInStart = -1;
    this.fadeInTime = -1;
    this.fadeOutStart = Game.time().now();
    this.fadeOutTime = ms;
}public void fadeIn(final int ms) {
    this.fadeOutStart = -1;
    this.fadeOutTime = -1;
    this.fadeInStart = Game.time().now();
    this.fadeInTime = ms;
}
}
```
```java
class de.gurkenlabs.litiengine.entities.Trigger {
private boolean activate(final IEntity activator, final int tar) {
    if (!this.isLoaded()
        || this.isOneTimeTrigger && this.isActivated
        || this.getActivationType() == TriggerActivation.COLLISION
            && activator != null
            && this.collisionActivated.contains(activator)) {
      return false;
    }

    if (this.getCooldown() > 0 && Game.time().since(this.lastActivation) < this.getCooldown()) {
      return false;
    }

    List<Integer> triggerTargets = this.getTargets(tar);

    final TriggerEvent te = new TriggerEvent(this, activator, triggerTargets);

    if (!this.checkActivationPredicates(te)) {
      return false;
    }

    this.isActivated = true;
    if (activator != null) {
      this.collisionActivated.add(activator);
    }

    // if we actually have a trigger target, we send the message to the target
    for (final int target : triggerTargets) {
      final IEntity entity = this.getEnvironment().get(target);
      if (entity == null) {
        log.log(
            Level.WARNING,
            "trigger [{0}] was activated, but the trigger target [{1}] could not be found on the environment",
            new Object[] {this, target});
        continue;
      }

      entity.sendMessage(this, this.message);
    }

    // also send the trigger event to all registered consumers
    for (final TriggerActivatedListener listener : this.activatedListeners) {
      listener.activated(te);
    }

    if (this.isOneTimeTrigger) {
      this.getEnvironment().remove(this);
    }

    this.lastActivation = Game.time().now();
    return true;
}
}
```
```java
class de.gurkenlabs.litiengine.graphics.Camera {
private boolean isShakeEffectActive() {
    return this.getShakeTick() != 0
        && Game.time().since(this.getShakeTick()) < this.getShakeDuration();
}@Override
  public void update() {
    if (Game.world().camera() != null && !Game.world().camera().equals(this)) {
      return;
    }

    if (this.targetZoom > 0) {
      if (Game.time().since(this.zoomTick) >= this.zoomDelay) {
        this.zoom = this.targetZoom;
        this.targetZoom = 0;
        this.zoomDelay = 0;
        this.zoomTick = 0;
        this.zoomStep = 0;
      } else {
        this.zoom += this.zoomStep;
      }

      final ZoomChangedEvent event = new ZoomChangedEvent(this, this.getZoom());
      for (final ZoomChangedListener listener : this.zoomListeners) {
        listener.zoomChanged(event);
      }
    }

    if (this.panTime > 0) {
      if (--this.panTime <= 0) {
        this.setFocus(this.targetFocus);
        this.targetFocus = null;
      } else {
        double diff = this.panTime / (this.panTime + 1.0);
        this.focus =
            new Point2D.Double(
                this.focus.getX() * diff + this.targetFocus.getX() * (1.0 - diff),
                this.focus.getY() * diff + this.targetFocus.getY() * (1.0 - diff));
      }
    }

    if (!this.isShakeEffectActive()) {
      this.shakeOffsetX = 0;
      this.shakeOffsetY = 0;
      return;
    }

    if (Game.time().since(this.lastShake) > this.shakeDelay) {
      this.shakeOffsetX = this.getShakeIntensity() * ThreadLocalRandom.current().nextGaussian();
      this.shakeOffsetY = this.getShakeIntensity() * ThreadLocalRandom.current().nextGaussian();
      this.lastShake = Game.time().now();
    }
}@Override
  public void setZoom(final float targetZoom, final int delay) {
    if (delay == 0) {

      this.zoom = targetZoom;
      this.targetZoom = 0;
      this.zoomDelay = 0;
      this.zoomTick = 0;
      this.zoomStep = 0;

      final ZoomChangedEvent event = new ZoomChangedEvent(this, targetZoom);
      for (final ZoomChangedListener listener : this.zoomListeners) {
        listener.zoomChanged(event);
      }
    } else {
      this.zoomTick = Game.time().now();
      this.targetZoom = targetZoom;
      this.zoomDelay = delay;

      final double tickduration = 1000 / (double) Game.loop().getTickRate();
      final double tickAmount = delay / tickduration;
      final float totalDelta = this.targetZoom - this.zoom;
      this.zoomStep = tickAmount > 0 ? (float) (totalDelta / tickAmount) : totalDelta;
    }
}@Override
  public void shake(final double intensity, final int delay, final int shakeDuration) {
    this.shakeTick = Game.time().now();
    this.shakeDelay = delay;
    this.shakeIntensity = intensity;
    this.shakeDuration = shakeDuration;
}
}
```
```java
class de.gurkenlabs.litiengine.entities.Creature {
public void setSpritesheetName(String spritesheetName) {
    if (this.spritesheetName != null && this.spritesheetName.equals(spritesheetName)) {
      return;
    }

    this.spritesheetName = spritesheetName;
    this.updateAnimationController();
}public boolean isIdle() {
    return Game.time().since(this.lastMoved) > IDLE_DELAY;
}@Override
  public void setLocation(final Point2D position) {
    if (this.isDead() || position == null) {
      return;
    }

    final Point2D oldLocation = this.getLocation();
    super.setLocation(position);

    if (Game.hasStarted() && this.isLoaded()) {
      this.lastMoved = Game.time().now();
      this.fireMovedEvent(
          new EntityMovedEvent(
              this, this.getX() - oldLocation.getX(), this.getY() - oldLocation.getY()));
    }
}
}
```
```java
class de.gurkenlabs.litiengine.gui.screens.ScreenManager {
public void display(final String screenName) {
    if (this.current() != null && this.current().getName().equalsIgnoreCase(screenName)) {
      log.log(
          Level.INFO,
          "Skipping displaying of screen {0} because it is already the current screen.",
          screenName);
      return;
    }

    if (this.screens.stream()
        .noneMatch(element -> element.getName().equalsIgnoreCase(screenName))) {
      log.log(
          Level.WARNING,
          "Could not display the screen {0} because there is no screen with the specified name.",
          screenName);
      return;
    }

    Screen screen = this.get(screenName);
    if (screen == null) {
      return;
    }

    this.display(screen);
}public void add(final Screen screen) {
    screen.setWidth(Game.window().getWidth());
    screen.setHeight(Game.window().getHeight());
    this.screens.add(screen);

    if (this.current() == null) {
      this.display(screen);
    }
}public void remove(Screen screen) {
    this.screens.remove(screen);
    if (this.current() == screen) {
      if (!this.screens.isEmpty()) {
        this.display(this.screens.get(0));
      } else {
        this.display((Screen) null);
      }
    }
}public void display(@Nullable final Screen screen) {
    if (Game.hasStarted() && Game.time().since(this.lastScreenChange) < this.getChangeCooldown()) {
      log.log(
          Level.INFO,
          "Skipping displaying of screen {0} because screen changing is currently on cooldown.",
          screen != null ? screen.getName() : "");
      return;
    }

    final Screen previous = this.current();
    if (previous != null) {
      previous.suspend();
    }

    if (screen != null && !this.screens.contains(screen)) {
      this.screens.add(screen);
    }

    this.currentScreen = screen;
    if (!Game.isInNoGUIMode() && this.current() != null) {
      this.current().prepare();
    }

    this.lastScreenChange = Game.loop().getTicks();

    final ScreenChangedEvent event = new ScreenChangedEvent(this.current(), previous);
    for (final ScreenChangedListener listener : this.screenChangedListeners) {
      listener.changed(event);
    }
}
}
```
```java
class de.gurkenlabs.litiengine.abilities.Ability {
public boolean isOnCooldown() {
    return (this.getCurrentExecution() != null
        && this.getCurrentExecution().getExecutionTicks() > 0
        && Game.time().since(this.getCurrentExecution().getExecutionTicks())
            < this.getAttributes().cooldown().get());
}public boolean isActive() {
    return this.getCurrentExecution() != null
        && Game.time().since(this.getCurrentExecution().getExecutionTicks())
            < this.getAttributes().duration().get();
}@Nullable
  public AbilityExecution cast() {
    if (!this.canCast()) {
      return null;
    }
    this.currentExecution = new AbilityExecution(this);

    for (final AbilityCastListener listener : this.abilityCastListeners) {
      listener.abilityCast(this.currentExecution);
    }

    return this.getCurrentExecution();
}public float getRemainingCooldownInSeconds() {
    if (this.getCurrentExecution() == null
        || this.getExecutor() == null
        || this.getExecutor().isDead()) {
      return 0;
    }

    // calculate cooldown in seconds
    return (float)
        (!this.canCast()
            ? (this.getAttributes().cooldown().get()
                    - Game.time().since(this.getCurrentExecution().getExecutionTicks()))
                * 0.001
            : 0);
}
}
```
```java
class de.gurkenlabs.litiengine.entities.EntityHitEvent {
EntityHitEvent(
      final ICombatEntity hitEntity,
      @Nullable final Ability ability,
      final int damage,
      final boolean kill) {
    super(hitEntity);
    this.executor = ability != null ? ability.getExecutor() : null;
    this.hitEntity = hitEntity;
    this.ability = ability;
    this.damage = damage;
    this.kill = kill;
    this.time = Game.time().now();
}
}
```
```java
class de.gurkenlabs.litiengine.graphics.emitters.Emitter {
public void delete() {
    this.deactivate();
    if (Game.world().environment() != null) {
      Game.world().environment().remove(this);
    }
}public void activate() {
    if (this.activated) {
      return;
    }

    this.activated = true;
    this.activationTick = Game.time().now();
    Game.loop().attach(this);
}@Override
  public void update() {
    if (this.isPaused()) {
      return;
    }

    // clear particles if the effect time to life is reached
    if (this.isFinished()) {
      for (EmitterFinishedListener listener : this.finishedListeners) {
        listener.finished(this);
      }

      this.delete();
      return;
    }

    final float updateRatio = (float) this.data().getUpdateRate() / Game.loop().getTickRate();
    for (final Particle p : this.getParticles().stream().collect(Collectors.toList())) {
      if (this.particleCanBeRemoved(p)) {
        // remove dead particles
        this.particles.remove(p);
        continue;
      }

      p.update(this.getOrigin(), updateRatio);
    }

    this.aliveTime = Game.time().since(this.activationTick);
    if ((this.data().getSpawnRate() == 0
        || Game.time().since(this.lastSpawn) >= this.data().getSpawnRate())) {
      this.lastSpawn = Game.time().now();
      this.spawnParticle();
    }
}
}
```
```java
class de.gurkenlabs.litiengine.GameLoop {
@Override
  public int perform(int delay, Runnable action) {
    final long d = Game.time().toTicks(delay);

    TimedAction a = new TimedAction(this.getTicks() + d, action);
    this.actions.add(a);

    return a.getId();
}
}
```
```java
class de.gurkenlabs.litiengine.environment.EntitySpawner {
protected boolean shouldSpawn() {
    return this.lastSpawnWave == 0
        || Game.time().since(this.lastSpawnWave) >= this.getSpawnInterval();
}@Override
  public void update() {
    if (!this.shouldSpawn()) {
      return;
    }

    this.spawnNewEntities();
    this.lastSpawnWave = Game.time().now();
}
}
```
```java
class de.gurkenlabs.litiengine.graphics.FreeFlightCamera {
@Override
  public void update() {
    this.handleFreeFlightCamera();
}public FreeFlightCamera(double x, double y) {
    this(new Point2D.Double(x, y));
}
}
```
```java
class de.gurkenlabs.litiengine.environment.Environment {
public void unload() {
    if (!this.loaded) {
      return;
    }

    // unregister all updatable entities from the current environment
    for (final IEntity entity : this.allEntities.values()) {
      this.unload(entity);
    }

    this.loaded = false;
    this.fireEvent(l -> l.unloaded(this));
}private static void loadUpdatableOrEmitterEntity(IEntity entity) {
    if (entity instanceof Emitter) {
      final Emitter emitter = (Emitter) entity;
      if (emitter.isActivateOnInit()) {
        emitter.activate();
      }
    } else if (entity instanceof IUpdateable) {
      Game.loop().attach((IUpdateable) entity);
    }
}public void clear() {
    Game.physics().clear();

    this.combatEntities.clear();
    this.mobileEntities.clear();
    this.gravityForces.clear();
    this.layerEntities.clear();
    this.entitiesByTag.clear();
    this.allEntities.clear();

    for (RenderType renderType : RenderType.values()) {
      this.miscEntities.get(renderType).clear();
      this.renderListeners.get(renderType).clear();
      this.renderables.get(renderType).clear();
    }

    dispose(this.allEntities.values());
    dispose(this.triggers);
    this.emitters.clear();
    this.colliders.clear();
    this.props.clear();
    this.creatures.clear();
    this.staticShadows.clear();
    this.combatEntities.clear();
    this.mobileEntities.clear();
    this.lightSources.clear();
    this.spawnPoints.clear();
    this.soundSources.clear();
    this.mapAreas.clear();
    this.triggers.clear();

    this.ambientLight = null;
    this.staticShadowLayer = null;

    for (Map<Integer, IEntity> type : this.miscEntities.values()) {
      type.clear();
    }

    this.initialized = false;

    this.fireEvent(l -> l.cleared(this));
}private void load(final IEntity entity) {
    // an entity can only exist on one environment at a time, so remove it from the current one
    if (entity.getEnvironment() != null) {
      entity.getEnvironment().remove(entity);
    }

    // 1. add to physics engine
    loadPhysicsEntity(entity);

    // 2. register for update or activate
    loadUpdatableOrEmitterEntity(entity);

    // 3. if a gravity is defined, add a gravity force to the entity
    if (entity instanceof IMobileEntity && this.getGravity() != 0) {
      this.addGravityForce((IMobileEntity) entity);
    }

    // 4. attach all controllers
    entity.attachControllers();

    if (this.loaded && (entity instanceof LightSource || entity instanceof StaticShadow)) {
      this.updateLighting(entity);
    }

    entity.loaded(this);
}private void unload(final IEntity entity) {
    // 1. remove from physics engine
    if (entity instanceof ICollisionEntity) {
      Game.physics().remove((ICollisionEntity) entity);
    }

    // 2. unregister from update
    if (entity instanceof IUpdateable) {
      Game.loop().detach((IUpdateable) entity);
    }

    if (entity instanceof IMobileEntity) {
      this.removeGravity((IMobileEntity) entity);
    }

    // 3. detach all controllers
    entity.detachControllers();

    if (entity instanceof Emitter) {
      Emitter em = (Emitter) entity;
      em.deactivate();
    }

    if (this.loaded && (entity instanceof LightSource || entity instanceof StaticShadow)) {
      this.updateLighting(entity);
    }

    entity.removed(this);
}public void remove(final IEntity entity) {
    if (entity == null) {
      return;
    }

    this.allEntities.remove(entity.getMapId());
    Iterator<List<IEntity>> iter = this.layerEntities.values().iterator();
    while (iter.hasNext()) {
      List<IEntity> layer = iter.next();
      if (layer.remove(entity) && layer.isEmpty()) {
        iter.remove();
      }
    }
    if (this.miscEntities.get(entity.getRenderType()) != null) {
      this.miscEntities.get(entity.getRenderType()).values().remove(entity);
    }

    for (String tag : entity.getTags()) {
      if (this.getEntitiesByTag().containsKey(tag)) {
        this.getEntitiesByTag().get(tag).remove(entity);

        if (this.getEntitiesByTag().get(tag).isEmpty()) {
          this.getEntitiesByTag().remove(tag);
        }
      }
    }

    if (entity instanceof Emitter) {
      Emitter emitter = (Emitter) entity;
      this.removeEmitter(emitter);
    }

    if (entity instanceof MapArea) {
      this.mapAreas.remove(entity);
    }

    if (entity instanceof Prop) {
      this.props.remove(entity);
    }

    if (entity instanceof Creature) {
      this.creatures.remove(entity);
    }

    if (entity instanceof CollisionBox) {
      this.colliders.remove(entity);
      this.staticShadows.removeIf(x -> x.getOrigin() != null && x.getOrigin().equals(entity));
    }

    if (entity instanceof LightSource) {
      this.lightSources.remove(entity);
      this.updateLighting(entity);
    }

    if (entity instanceof Trigger) {
      this.triggers.remove(entity);
    }

    if (entity instanceof Spawnpoint) {
      this.spawnPoints.remove(entity);
    }
    if (entity instanceof SoundSource) {
      this.soundSources.remove(entity);
    }

    if (entity instanceof StaticShadow) {
      this.staticShadows.remove(entity);
      this.updateLighting(entity);
    }

    if (entity instanceof IMobileEntity) {
      this.mobileEntities.values().remove(entity);
    }

    if (entity instanceof ICombatEntity) {
      this.combatEntities.values().remove(entity);
    }

    this.unload(entity);

    this.fireEntityEvent(l -> l.entityRemoved(entity));
}
}
```
```java
class de.gurkenlabs.litiengine.physics.MovementController {
@Override
  public void update() {
    this.handleForces();
    this.handleMovement();
}
}
```
```java
class de.gurkenlabs.litiengine.Game {
static synchronized void terminate() {
    if (!initialized) {
      return;
    }

    hasStarted = false;
    initialized = false;

    config().save();
    gameLoop.terminate();
    tweenEngine.terminate();
    soundEngine.terminate();

    world().clear();

    for (final GameListener listener : gameListeners) {
      try {
        listener.terminated();
      } catch (Exception e) {
        log().log(Level.WARNING, "game listener threw an exception during shutdown", e);
      }
    }

    gameLoop = null;
    screenManager = null;
    gameWindow = null;
}public static synchronized void start() {
    if (!initialized) {
      throw new IllegalStateException(
          "The game cannot be started without being first initialized. Call Game.init(...) before Game.start().");
    }

    gameLoop.start();
    tweenEngine.start();
    soundEngine.start();

    for (final GameListener listener : gameListeners) {
      listener.started();
    }

    hasStarted = true;
}public static synchronized void init(String... args) {
    if (initialized) {
      log().log(Level.INFO, "The game has already been initialized.");
      return;
    }

    log.init();
    handleCommandLineArguments(args);

    config().load();
    Locale.setDefault(new Locale(config().client().getCountry(), config().client().getLanguage()));

    gameLoop = new GameLoop("Main Update Loop", config().client().getMaxFps());
    loop().attach(physics());
    loop().attach(world());

    // setup default exception handling for render and update loop
    setUncaughtExceptionHandler(
        new DefaultUncaughtExceptionHandler(config().client().exitOnError()));

    screenManager = new ScreenManager();
    gameWindow = new GameWindow();

    // initialize  the game window
    window().init();
    world.setCamera(new Camera());

    for (GameListener listener : gameListeners) {
      listener.initialized(args);
    }

    if (!isInNoGUIMode()) {
      window().getRenderComponent().onRendered(g -> metrics().render(g));

      graphics()
          .addEntityRenderedListener(
              e -> DebugRenderer.renderEntityDebugInfo(e.getGraphics(), e.getEntity()));

      window().getRenderComponent().onFpsChanged(fps -> metrics().setFramesPerSecond(fps));
      window()
          .setIcons(
              Arrays.asList(
                  Resources.images().get("liti-logo-x16.png"),
                  Resources.images().get("liti-logo-x20.png"),
                  Resources.images().get("liti-logo-x32.png"),
                  Resources.images().get("liti-logo-x48.png")));

      Input.keyboard()
          .onKeyTyped(
              KeyEvent.VK_PRINTSCREEN,
              key -> {
                // don't take a screenshot if a modifier is active
                if (key.getModifiers() != 0) {
                  return;
                }

                window().getRenderComponent().takeScreenshot();
              });
    }

    Runtime.getRuntime().addShutdownHook(new Thread(Game::terminate, "Shutdown"));

    initialized = true;
}
}
```


Response Format:
Provide the answer in **XML format** as follows:

#### If the method **cannot** return `null` at the specific call site:
```xml
<response>
  <reason><![CDATA[EXPLAIN WHY THE INVOCATION Game.loop() RESULT CANNOT BE NULL.]]></reason>
  <value>NO</value>
</response>

#### If the method can return null at the specific call site:
<response>
  <reason><![CDATA[EXPLAIN WHY THE INVOCATION Game.loop() RESULT CAN BE NULL.]]></reason>
  <value>YES</value>
</response>

#### If you are unsure or If there are any methods that directly or indirectly affect the return value and are not fully disclosed, request their declarations first, in the following format:
<response>
  <reason><![CDATA[EXPLAIN WHY THIS METHOD DECLARATION IS NECESSARY AND WHY YOU CANNOT MAKE A CONFIDENT DECISION WITHOUT IT]]></reason>
  <success>false</success>
  <methods>
    <method>methodName</method>
  </methods>
</response>

Additional Notes:
Be precise in your reasoning.
If a method’s return value depends on another method not provided, request its declaration before making a conclusion.
If the method can return null in this case but not in others, explain why it happens specifically for this call.

---ChatGPT.sendRequestToOpenAI---
Retrieving response from cache
---Response.<init>---
Creating Response:
```xml
<response>
  <reason><![CDATA[The method `Game.loop()` returns the static field `gameLoop`, which is initialized in the `Game.init(String... args)` method. In this method, a new `GameLoop` object is instantiated and assigned to `gameLoop`. Since `init()` must be called before `start()`, which is implied by the requirement of initializing the game, the `gameLoop` is guaranteed to be non-null during the lifetime of the game execution where `Game.loop()` is called. The absence of any code that could set `gameLoop` to null after its initialization ensures that `Game.loop()` cannot return null.]]></reason>
  <value>NO</value>
</response>
```
---Response.<init>---
Response created:
Disagreement: The method `Game.loop()` returns the static field `gameLoop`, which is initialized in the `Game.init(String... args)` method. In this method, a new `GameLoop` object is instantiated and assigned to `gameLoop`. Since `init()` must be called before `start()`, which is implied by the requirement of initializing the game, the `gameLoop` is guaranteed to be non-null during the lifetime of the game execution where `Game.loop()` is called. The absence of any code that could set `gameLoop` to null after its initialization ensures that `Game.loop()` cannot return null.
---AdvancedNullAwayCodeFix.resolveMethodDereferenceError---
Method is not returning nullable on call site. Injecting suppression annotation.
---AdvancedNullAwayCodeFix.constructCastToNonnullChange---
Constructing cast to nonnull change for reason: The method `Game.loop()` returns the static field `gameLoop`, which is initialized in the `Game.init(String... args)` method. In this method, a new `GameLoop` object is instantiated and assigned to `gameLoop`. Since `init()` must be called before `start()`, which is implied by the requirement of initializing the game, the `gameLoop` is guaranteed to be non-null during the lifetime of the game execution where `Game.loop()` is called. The absence of any code that could set `gameLoop` to null after its initialization ensures that `Game.loop()` cannot return null.
---ChatGPT.ask---
Asking ChatGPT:
For the reason you mentioned earlier:

"The method `Game.loop()` returns the static field `gameLoop`, which is initialized in the `Game.init(String... args)` method. In this method, a new `GameLoop` object is instantiated and assigned to `gameLoop`. Since `init()` must be called before `start()`, which is implied by the requirement of initializing the game, the `gameLoop` is guaranteed to be non-null during the lifetime of the game execution where `Game.loop()` is called. The absence of any code that could set `gameLoop` to null after its initialization ensures that `Game.loop()` cannot return null."

in the method below, the expression Game.loop() is not nullable at the point it is used.

```java
private static void initializeWindowEventListeners(Window window) {

    window.addWindowStateListener(
        e -> {
          if (e.getNewState() == Frame.ICONIFIED) {
            Game.loop().setTickRate(ICONIFIED_MAX_FPS);
          } else {
            Game.loop().setTickRate(Game.config().client().getMaxFps());
          }
        });

    window.addWindowFocusListener(
        new WindowFocusListener() {
          @Override
          public void windowLostFocus(WindowEvent e) {
            if (Game.config().graphics().reduceFramesWhenNotFocused()) {
              Game.loop().setTickRate(NONE_FOCUS_MAX_FPS);
            }
          }

          @Override
          public void windowGainedFocus(WindowEvent e) {
            Game.loop().setTickRate(Game.config().client().getMaxFps());
          }
        });

    window.addWindowListener(
        new WindowAdapter() {
          @Override
          public void windowClosing(final WindowEvent event) {
            Game.exit();
          }
        });
}
```
Please Summarize the reason in max 5 words and rewrite the method so that at the line "            Game.loop().setTickRate(Game.config().client().getMaxFps());", at the occurrence of: "Game.loop()" is replaced with `NullabilityUtil.castToNonnull(Game.loop(), summary of reason)`
Replace "REASON" with the exact reason summary I provide to you (maximum 5 words), not with a generic explanation like "checked to be nonnull".
see the example below, for expression `foo.getBar()`, to wrap it with `NullabilityUtil.castToNonnull(foo.getBar(), "reason")`.

```java
public t(){
    String l = foo.getBar();
}
```

will be:
```java
public t(){
    String l = NullabilityUtil.castToNonnull(foo.getBar(), "checked to be nonnull");
}
```

### Instructions:

Do not import any additional classes.

Do not add Java comments.

Only modify relevant lines as required.

Return only the modified method wrapped in the XML format shown below.

Place the Java code inside the <code> tag using a CDATA block with ```java formatting.

Just give me the fixed code snippet in XML format in <response> tag like the example below. I will apply the fix to my codebase. Do not import any additional libraries or classes or add java comments. If you can provide the fixed code snippet, please provide it in the following format and place the code snippet in the <code> tag within ```java block.
<response>
  <success>true</success>
  <code><![CDATA[
  ```java
  Your fixed code snippet here
  ```
    ]]>
  </code>
</response>

---ChatGPT.sendRequestToOpenAI---
Sending request to OpenAI...
---ChatGPT.sendRequestToOpenAI---
Response received from OpenAI.
---Response.<init>---
Creating Response:
<response>
  <success>true</success>
  <code><![CDATA[
  ```java
  private static void initializeWindowEventListeners(Window window) {

    window.addWindowStateListener(
        e -> {
          if (e.getNewState() == Frame.ICONIFIED) {
            Game.loop().setTickRate(ICONIFIED_MAX_FPS);
          } else {
            Game.loop().setTickRate(NullabilityUtil.castToNonnull(Game.config().client().getMaxFps(), "cannot return null"));
          }
        });

    window.addWindowFocusListener(
        new WindowFocusListener() {
          @Override
          public void windowLostFocus(WindowEvent e) {
            if (Game.config().graphics().reduceFramesWhenNotFocused()) {
              Game.loop().setTickRate(NONE_FOCUS_MAX_FPS);
            }
          }

          @Override
          public void windowGainedFocus(WindowEvent e) {
            Game.loop().setTickRate(NullabilityUtil.castToNonnull(Game.config().client().getMaxFps(), "cannot return null"));
          }
        });

    window.addWindowListener(
        new WindowAdapter() {
          @Override
          public void windowClosing(final WindowEvent event) {
            Game.exit();
          }
        });
  }
  ```
  ]]>
  </code>
</response>
---Response.<init>---
Response created:
private static void initializeWindowEventListeners(Window window) {

    window.addWindowStateListener(
        e -> {
          if (e.getNewState() == Frame.ICONIFIED) {
            Game.loop().setTickRate(ICONIFIED_MAX_FPS);
          } else {
            Game.loop().setTickRate(NullabilityUtil.castToNonnull(Game.config().client().getMaxFps(), "cannot return null"));
          }
        });

    window.addWindowFocusListener(
        new WindowFocusListener() {
          @Override
          public void windowLostFocus(WindowEvent e) {
            if (Game.config().graphics().reduceFramesWhenNotFocused()) {
              Game.loop().setTickRate(NONE_FOCUS_MAX_FPS);
            }
          }

          @Override
          public void windowGainedFocus(WindowEvent e) {
            Game.loop().setTickRate(NullabilityUtil.castToNonnull(Game.config().client().getMaxFps(), "cannot return null"));
          }
        });

    window.addWindowListener(
        new WindowAdapter() {
          @Override
          public void windowClosing(final WindowEvent event) {
            Game.exit();
          }
        });
  }
---ChatGPT.fixDereferenceByAddingCastToNonnull---
Fixing the error by adding castToNonnull
---AdvancedNullAwayCodeFix.fixTriggeredErrorsForLocation---
Resolving unresolvable error for triggered error: Type='DEREFERENCE_NULLABLE', message='dereferenced expression Game.loop() is @Nullable'
/home/nima/Developer/nullness-benchmarks/litiengine/src/de/gurkenlabs/litiengine/GameTime.java:44
    return toMilliseconds(Game.loop().getTicks() - tick);
---AdvancedNullAwayCodeFix.fix---
Fixing error: Type='DEREFERENCE_NULLABLE', message='dereferenced expression Game.loop() is @Nullable'
/home/nima/Developer/nullness-benchmarks/litiengine/src/de/gurkenlabs/litiengine/GameTime.java:44
    return toMilliseconds(Game.loop().getTicks() - tick);
---AdvancedNullAwayCodeFix.resolveDereferenceError---
Resolving dereference error: Type='DEREFERENCE_NULLABLE', message='dereferenced expression Game.loop() is @Nullable'
/home/nima/Developer/nullness-benchmarks/litiengine/src/de/gurkenlabs/litiengine/GameTime.java:44
    return toMilliseconds(Game.loop().getTicks() - tick);
---AdvancedNullAwayCodeFix.resolveDereferenceError---
Checking nullability possibility at error point
---ChatGPT.checkNullabilityPossibilityAtErrorPoint---
Asking if the expression can be null at error point point
---ChatGPT.ask---
Asking ChatGPT:
In the method below, is there a possibility that the expression "Game.loop()" at line "return toMilliseconds(Game.loop().getTicks() - tick);" is null?
public long since(final long tick) {
    return toMilliseconds(Game.loop().getTicks() - tick);
}
Give a single-word answer in XML format. If it is possible for the expression to be null, respond with:
```xml
<response>
    <reason><![CDATA[YOUR REASON]]></reason>
    <value>YES</value>
</response>
```
If it is not possible for the expression to be null, respond with:
```xml
<response>
    <reason><![CDATA[YOUR REASON]]></reason>
    <value>NO</value>
</response>
```
If you are unsure or need more information, respond with where you can ask for more details or what specific information you need.

If additional information is required, list each request inside a `<request>` tag. If no additional information is needed, omit the `<requests>` section.

Respond with:
```xml
<response>
    <reason><![CDATA[YOUR REASON]]></reason>
    <value>UNKNOWN</value>
    <!-- Include <requests> only if additional information is needed -->
    <requests>
        <request><![CDATA[YOUR REQUEST 1]]></request>
        <request><![CDATA[YOUR REQUEST 2]]></request>
    </requests>
</response>
```
---ChatGPT.sendRequestToOpenAI---
Sending request to OpenAI...
---ChatGPT.sendRequestToOpenAI---
Response received from OpenAI.
---Response.<init>---
Creating Response:
```xml
<response>
    <reason><![CDATA[Without details on how Game.loop() is implemented, it's unclear if it can return a null value. Additional information on the Game class and its loop method is needed.]]></reason>
    <value>UNKNOWN</value>
    <requests>
        <request><![CDATA[Provide the implementation details of the Game.loop() method.]]></request>
        <request><![CDATA[Specify any assumptions or constraints regarding the Game class.]]></request>
    </requests>
</response>
```
---Response.<init>---
Response created:
Unknown: Without details on how Game.loop() is implemented, it's unclear if it can return a null value. Additional information on the Game class and its loop method is needed.
---AdvancedNullAwayCodeFix.resolveMethodDereferenceError---
Resolving method dereference error.
---AdvancedNullAwayCodeFix.resolveMethodDereferenceError---
Method is in annotated package. Checking if the method is returning nullable.
---AdvancedNullAwayCodeFix.investigateMethodReturnNullability---
Checking if the method is returning nullable.
---ChatGPT.checkIfMethodIsReturningNullable---
Asking if the method is returning nullable: loop()
---ChatGPT.ask---
Asking ChatGPT:
In the method below, is there a possibility that the method returns null based only on its body? Consider the following points:

- The method may have multiple return paths; consider all return statements.
- If the method calls another method, do not assume its return value unless its full declaration is provided. Request its declaration if needed.
- The method may throw an exception instead of returning null. An exception path should not be considered a null return.
- Ensure you request the declarations of any methods whose return values directly or indirectly impact this method’s return value before making a conclusion.
- Carefully analyze all conditions and prior operations that may guarantee a non-null return value.

@Nullable public static IGameLoop loop() {
    return gameLoop;
}

Here are the method definitions in addition to the method inquired:

Depth: 0
```java
class de.gurkenlabs.litiengine.Game {
@Nullable public static IGameLoop loop() {
    return gameLoop;
}
}
```


Response Format:
Provide the answer in **XML format** as follows:

#### If the method **cannot** return `null`:
```xml
<response>
  <reason><![CDATA[EXPLAIN WHY THE METHOD CANNOT RETURN NULL]]></reason>
  <value>NO</value>
</response>
```

#### If the method can return null:
```xml
<response>
  <reason><![CDATA[EXPLAIN WHY THE METHOD CAN RETURN NULL]]></reason>
  <value>YES</value>
</response>
```

#### If you are unsure or need more information, respond with where you can ask for more details or what specific information you need.

#### If you are unsure or If there are any methods that directly or indirectly affect the return value and are not fully disclosed, request their declarations first, in the following format:
<response>
  <reason><![CDATA[YOUR REASON]]></reason>
  <value>UNKNOWN</value>
  <methods>
    <method>methodName</method>
  </methods>
</response>

If additional information is required other than method declaration, list each request inside a `<request>` tag. If no additional information is needed, omit the `<requests>` section.

Respond with:
```xml
<response>
    <reason><![CDATA[YOUR REASON]]></reason>
    <value>UNKNOWN</value>
    <!-- Include <requests> only if additional information is needed -->
    <requests>
        <request><![CDATA[YOUR REQUEST 1]]></request>
        <request><![CDATA[YOUR REQUEST 2]]></request>
    </requests>
</response>
```

Additional Notes:
Be precise in your reasoning.
If a method’s return value depends on another method not provided, request its declaration before making a conclusion.
If the method can return null in some cases but not others, explain under what conditions it can happen.

---ChatGPT.sendRequestToOpenAI---
Retrieving response from cache
---Response.<init>---
Creating Response:
```xml
<response>
  <reason><![CDATA[The method `loop` returns the variable `gameLoop`. Without the initialization or assignment details of `gameLoop`, it's unclear whether it can be null. The possibility of `gameLoop` being uninitialized or set to null elsewhere in the program means `loop` could potentially return null. Further information on `gameLoop` is required.]]></reason>
  <value>UNKNOWN</value>
  <requests>
    <request><![CDATA[Please provide the declaration and initialization of the variable `gameLoop` in the class `de.gurkenlabs.litiengine.Game`.]]></request>
  </requests>
</response>
```
---Response.<init>---
Response created:
Unknown: The method `loop` returns the variable `gameLoop`. Without the initialization or assignment details of `gameLoop`, it's unclear whether it can be null. The possibility of `gameLoop` being uninitialized or set to null elsewhere in the program means `loop` could potentially return null. Further information on `gameLoop` is required.
---AdvancedNullAwayCodeFix.investigateMethodReturnNullability---
Could not determine the nullability and model did not ask for any method.
---ChatGPT.checkIfMethodIsReturningNullableOnCallSite---
Asking if the method is returning nullable on the call site: Game.loop()
---ChatGPT.ask---
Asking ChatGPT:
In the method below, is there a possibility that the method returns null at the given call site?

```java
@Nullable public static IGameLoop loop() {
    return gameLoop;
}
```

## Guidelines:
- The method may have multiple return paths; consider all return statements.
- If the method calls another method, do not assume its return value unless its full declaration is provided. Request its declaration if needed.
- The method may throw an exception instead of returning null. An exception path should not be considered a null return.
- Ensure you request the declarations of any methods whose return values directly or indirectly impact this method’s return value before making a conclusion.
- If the method returns a value that is determined by a parameter, evaluate based on the actual argument at the given call site.
- Analyze based only on the specific invocation provided. Do not generalize to all possible inputs.- If the return value is guaranteed to be non-null at the call site, the answer should be a definitive NO.
- Do not generalize based on all possible inputs—your answer must be based only on the given invocation.
- Focus only on the given call site, not all possible invocations.

### call site:
Game.loop()

Here are the method definitions and the call chain for this method, showing the sequence of calls from the method to its callers at each depth level:

Depth: 0
```java
class de.gurkenlabs.litiengine.Game {
@Nullable public static IGameLoop loop() {
    return gameLoop;
}
}
```
Depth: 1
```java
class de.gurkenlabs.litiengine.environment.GameWorld {
public void loadEnvironment(@Nullable final Environment env) {
    Lock lock = Game.loop().getLock();
    lock.lock();
    try {
      unloadEnvironment();
      this.environment = env;
      if (env != null) {
        this.addEnvironment(env);

        if (env.getGravity() == 0 && this.gravity() != 0) {
          env.setGravity(this.gravity());
        }

        env.load();
        for (final EnvironmentLoadedListener listener : this.loadedListeners) {
          listener.loaded(env);
        }

        // call map specific listeners
        String mapName = getMapName(env);
        if (mapName != null && this.environmentLoadedListeners.containsKey(mapName)) {

          // for the default camera we center the camera on the environment
          if (this.camera().getClass().equals(Camera.class)) {
            camera().setFocus(env.getCenter());
          }

          for (EnvironmentLoadedListener listener : this.environmentLoadedListeners.get(mapName)) {
            listener.loaded(env);
          }
        }
      }
    } finally {
      lock.unlock();
    }
}public void setCamera(@Nullable final ICamera cam) {
    if (this.camera() != null) {
      Game.loop().detach(camera);
    }

    camera = cam;

    if (cam != null && !Game.isInNoGUIMode()) {
      Game.loop().attach(cam);
      cam.updateFocus();
    }
}
}
```
```java
class de.gurkenlabs.litiengine.entities.behavior.EntityNavigator {
public EntityNavigator(final IMobileEntity entity, final PathFinder pathFinder) {
    this.cancelNavigationConditions = new CopyOnWriteArrayList<>();
    this.listeners = new CopyOnWriteArrayList<>();
    this.entity = entity;
    this.pathFinder = pathFinder;
    this.setAcceptableError(DEFAULT_ACCEPTABLE_ERROR);
    Game.loop().attach(this);
}
}
```
```java
class de.gurkenlabs.litiengine.GameWindow {
private static void initializeWindowEventListeners(Window window) {

    window.addWindowStateListener(
        e -> {
          if (e.getNewState() == Frame.ICONIFIED) {
            Game.loop().setTickRate(ICONIFIED_MAX_FPS);
          } else {
            Game.loop().setTickRate(Game.config().client().getMaxFps());
          }
        });

    window.addWindowFocusListener(
        new WindowFocusListener() {
          @Override
          public void windowLostFocus(WindowEvent e) {
            if (Game.config().graphics().reduceFramesWhenNotFocused()) {
              Game.loop().setTickRate(NONE_FOCUS_MAX_FPS);
            }
          }

          @Override
          public void windowGainedFocus(WindowEvent e) {
            Game.loop().setTickRate(Game.config().client().getMaxFps());
          }
        });

    window.addWindowListener(
        new WindowAdapter() {
          @Override
          public void windowClosing(final WindowEvent event) {
            Game.exit();
          }
        });
}
}
```
```java
class de.gurkenlabs.litiengine.gui.screens.ScreenManager {
public void display(@Nullable final Screen screen) {
    if (Game.hasStarted() && Game.time().since(this.lastScreenChange) < this.getChangeCooldown()) {
      log.log(
          Level.INFO,
          "Skipping displaying of screen {0} because screen changing is currently on cooldown.",
          screen != null ? screen.getName() : "");
      return;
    }

    final Screen previous = this.current();
    if (previous != null) {
      previous.suspend();
    }

    if (screen != null && !this.screens.contains(screen)) {
      this.screens.add(screen);
    }

    this.currentScreen = screen;
    if (!Game.isInNoGUIMode() && this.current() != null) {
      this.current().prepare();
    }

    this.lastScreenChange = Game.loop().getTicks();

    final ScreenChangedEvent event = new ScreenChangedEvent(this.current(), previous);
    for (final ScreenChangedListener listener : this.screenChangedListeners) {
      listener.changed(event);
    }
}
}
```
```java
class de.gurkenlabs.litiengine.abilities.effects.Effect {
@Override
  public void update() {

    for (final Iterator<EffectApplication> iterator = this.getActiveAppliances().iterator();
        iterator.hasNext(); ) {
      final EffectApplication appliance = iterator.next();
      // if the effect duration is reached
      if (this.hasEnded(appliance)) {

        iterator.remove();
        this.cease(appliance);
      }
    }

    // 4. unregister if all appliances are finished
    if (this.getActiveAppliances().isEmpty()) {
      Game.loop().detach(this);
    }
}public void apply(final Shape impactArea) {
    final List<ICombatEntity> affected = this.lookForAffectedEntities(impactArea);
    for (final ICombatEntity affectedEntity : affected) {
      this.apply(affectedEntity);
    }

    this.appliances.add(new EffectApplication(affected, impactArea));

    // if it is the first appliance -> register for update
    if (this.appliances.size() == 1) {
      Game.loop().attach(this);
    }
}
}
```
```java
class de.gurkenlabs.litiengine.GameTime {
public long toTicks(final int milliseconds) {
    return this.toTicks(milliseconds, Game.loop().getTickRate());
}public long since(final long tick) {
    return toMilliseconds(Game.loop().getTicks() - tick);
}public long now() {
    return Game.loop().getTicks();
}public long sinceGameStart() {
    return this.toMilliseconds(Game.loop().getTicks());
}@Override
  public void loaded(Environment environment) {
    environmentLoaded = Game.loop().getTicks();
}public long toMilliseconds(final long ticks) {
    return this.toMilliseconds(ticks, Game.loop().getTickRate());
}
}
```
```java
class de.gurkenlabs.litiengine.GameMetrics {
@Override
  public void render(final Graphics2D g) {
    this.updateMetrics();

    if (!Game.config().client().showGameMetrics()) {
      return;
    }

    this.currentOffsetY = 0;

    g.setColor(this.renderColor);

    // render client metrics
    this.drawTitle(g, "[client]");
    this.drawMetric(g, "fps       : " + this.getFramesPerSecond());
    this.drawMetric(g, "max fps   : " + this.maxFramesPerSecond);
    this.drawMetric(g, "updatables: " + Game.loop().getUpdatableCount());

    // render jvm metrics if debug is enabled
    if (Game.config().debug().isDebugEnabled()) {
      this.drawTitle(g, "[jvm]");
      this.drawMetric(g, "java      : " + this.javaVersion);
      this.drawMetric(g, "memory    : " + String.format("%-5.5s", this.usedMemory) + " MB");
      this.drawMetric(g, "threads   : " + Thread.activeCount());
    }

    // render rendering metrics
    if (!this.renderMetrics.isEmpty()) {
      this.drawTitle(g, "[update]");

      for (RenderMetrics metric : this.renderMetrics) {
        this.drawMetric(g, metric.toString());
      }

      this.renderMetrics.clear();
    }
}
}
```
```java
class de.gurkenlabs.litiengine.graphics.emitters.Emitter {
public void deactivate() {
    if (!this.activated) {
      return;
    }

    this.activated = false;
    this.getParticles().clear();
    this.aliveTime = 0;
    this.activationTick = 0;
    this.lastSpawn = 0;
    Game.loop().detach(this);
}public void activate() {
    if (this.activated) {
      return;
    }

    this.activated = true;
    this.activationTick = Game.time().now();
    Game.loop().attach(this);
}@Override
  public void update() {
    if (this.isPaused()) {
      return;
    }

    // clear particles if the effect time to life is reached
    if (this.isFinished()) {
      for (EmitterFinishedListener listener : this.finishedListeners) {
        listener.finished(this);
      }

      this.delete();
      return;
    }

    final float updateRatio = (float) this.data().getUpdateRate() / Game.loop().getTickRate();
    for (final Particle p : this.getParticles().stream().collect(Collectors.toList())) {
      if (this.particleCanBeRemoved(p)) {
        // remove dead particles
        this.particles.remove(p);
        continue;
      }

      p.update(this.getOrigin(), updateRatio);
    }

    this.aliveTime = Game.time().since(this.activationTick);
    if ((this.data().getSpawnRate() == 0
        || Game.time().since(this.lastSpawn) >= this.data().getSpawnRate())) {
      this.lastSpawn = Game.time().now();
      this.spawnParticle();
    }
}
}
```
```java
class de.gurkenlabs.litiengine.entities.behavior.IBehaviorController {
public default void attach() {
    Game.loop().attach(this);
}public default void detach() {
    Game.loop().detach(this);
}
}
```
```java
class de.gurkenlabs.litiengine.abilities.AbilityExecution {
AbilityExecution(final Ability ability) {
    this.appliedEffects = new CopyOnWriteArrayList<>();
    this.ability = ability;
    this.executionTicks = Game.time().now();
    this.impactArea = ability.calculateImpactArea();
    this.castLocation = ability.getExecutor().getCenter();
    Game.loop().attach(this);
}@Override
  public void update() {
    // if there a no effects to apply -> unregister this instance and we're done
    if (this.getAbility().getEffects().isEmpty()
        || this.getAbility().getEffects().size() == this.getAppliedEffects().size()) {
      Game.loop().detach(this);
      return;
    }

    // handle all effects from the ability that were not applied yet
    for (final Effect effect : this.getAbility().getEffects()) {
      // if the ability was not executed yet or the delay of the effect is not
      // yet reached
      if (this.getAppliedEffects().contains(effect)
          || Game.time().since(this.getExecutionTicks()) < effect.getDelay()) {
        continue;
      }

      effect.apply(this.getExecutionImpactArea());
      this.getAppliedEffects().add(effect);
    }
}
}
```
```java
class de.gurkenlabs.litiengine.GameWindow$3 {
@Override
          public void windowGainedFocus(WindowEvent e) {
            Game.loop().setTickRate(Game.config().client().getMaxFps());
}@Override
          public void windowLostFocus(WindowEvent e) {
            if (Game.config().graphics().reduceFramesWhenNotFocused()) {
              Game.loop().setTickRate(NONE_FOCUS_MAX_FPS);
            }
}
}
```
```java
class de.gurkenlabs.litiengine.environment.EntitySpawner {
protected void spawnNewEntities() {
    if (this.getSpawnMode() != SpawnMode.CUSTOMSPAWNPOINTS && this.getSpawnPoints().isEmpty()) {
      return;
    }

    switch (this.getSpawnMode()) {
      case ALLSPAWNPOINTS:
        for (int i = 0; i < this.getSpawnPoints().size(); i++) {
          final int index = i;
          Game.loop()
              .perform(
                  this.getSpawnDelay() + this.getSpawnDelay() * i,
                  () -> this.spawn(this.getSpawnPoints().get(index), this.getSpawnAmount()));
        }
        break;
      case ONERANDOMSPAWNPOINT:
        this.spawn(Game.random().choose(this.getSpawnPoints()), this.getSpawnAmount());
        break;
      case RANDOMSPAWNPOINTS:
        for (int i = 0; i < this.getSpawnAmount(); i++) {
          Game.loop()
              .perform(
                  this.getSpawnDelay() + this.getSpawnDelay() * i,
                  () -> this.spawn(Game.random().choose(this.getSpawnPoints()), 1));
        }
        break;
      case CUSTOMSPAWNPOINTS:
        List<Spawnpoint> spawnPoints =
            this.customSpawnpoints != null
                ? this.customSpawnpoints.apply(this)
                : this.getCustomSpawnpoints();

        int index = 0;
        for (Spawnpoint spawn : spawnPoints) {
          Game.loop()
              .perform(
                  this.getSpawnDelay() + this.getSpawnDelay() * index, () -> this.spawn(spawn, 1));
          index++;
        }
        break;
      default:
        break;
    }
}
}
```
```java
class de.gurkenlabs.litiengine.tweening.TweenEngine {
@Override
  public void start() {
    Game.loop().attach(this);
}@Override
  public void terminate() {
    Game.loop().detach(this);
}
}
```
```java
class de.gurkenlabs.litiengine.gui.SpeechBubble {
public void hide() {
    Game.world().environment().removeRenderable(this);
    Game.loop().detach(this);
    if (activeSpeechBubbles.get(this.getEntity()) != null
        && activeSpeechBubbles.remove(this.getEntity()).equals(this)) {
      activeSpeechBubbles.remove(this.getEntity());
    }

    for (SpeechBubbleListener listener : this.listeners) {
      listener.hidden();
    }
}private SpeechBubble(
      final IEntity entity,
      final String text,
      @Nullable SpeechBubbleAppearance appearance,
      @Nullable Font font) {
    if (appearance == null) {
      this.appearance = DEFAULT_APPEARANCE;
    } else {
      this.appearance = appearance;
    }

    final SpeechBubble active = activeSpeechBubbles.get(entity);
    if (active != null) {
      active.hide();
    }
    this.setFont(font);

    this.textBoxWidth = (float) (entity.getWidth() * 4);
    this.entity = entity;

    this.currentText = text;
    this.currentTextDisplayTime = DISPLAYTIME_MIN + text.length() * DISPLAYTIME_PER_LETTER;

    this.lastTextDisplay = Game.time().now();
    this.createBubbleImage();
    entity.getEnvironment().add(this, RenderType.UI);
    Game.loop().attach(this);
    activeSpeechBubbles.put(entity, this);
}
}
```
```java
class de.gurkenlabs.litiengine.entities.Prop {
private void updateAnimationController() {
    IEntityAnimationController<?> controller = this.createAnimationController();
    this.getControllers().addController(controller);
    if (Game.world().environment() != null && Game.world().environment().isLoaded()) {
      Game.loop().attach(controller);
    }
}
}
```
```java
class de.gurkenlabs.litiengine.graphics.FreeFlightCamera {
public FreeFlightCamera(final Point2D focus) {
    this.setFocus(focus);
    this.velocity = DEFAULT_SCROLL_PIXELS_PER_SECOND;
    this.scrollPadding = DEFAULT_SCROLL_PADDING;
    this.setClampToMap(true);

    Game.loop().attach(this);
}private void handleFreeFlightCamera() {
    if (Game.world().environment() == null || Game.world().environment().getMap() == null) {
      return;
    }

    final Point2D mouseLocation = Input.mouse().getLocation();

    final double scrollSpeed =
        this.getVelocity()
            / (double) Game.loop().getTickRate()
            * Game.config().input().getMouseSensitivity();

    double x = this.getFocus().getX();
    double y = this.getFocus().getY();

    double deltaX = 0;
    if (mouseLocation.getX() < this.getScrollPadding()) {
      deltaX -= scrollSpeed;
    } else if (Game.window().getResolution().getWidth() - mouseLocation.getX()
        < this.getScrollPadding()) {
      deltaX += scrollSpeed;
    }

    double deltaY = 0;
    if (mouseLocation.getY() < this.getScrollPadding()) {
      deltaY -= scrollSpeed;
    } else if (Game.window().getResolution().getHeight() - mouseLocation.getY()
        < this.getScrollPadding()) {
      deltaY += scrollSpeed;
    }

    x += deltaX;
    y += deltaY;

    this.setFocus(new Point2D.Double(x, y));
}
}
```
```java
class de.gurkenlabs.litiengine.environment.Environment {
private static void dispose(final Collection<? extends IEntity> entities) {
    for (final IEntity entity : entities) {
      if (entity instanceof IUpdateable) {
        Game.loop().detach((IUpdateable) entity);
      }

      entity.detachControllers();
    }
}private static void loadUpdatableOrEmitterEntity(IEntity entity) {
    if (entity instanceof Emitter) {
      final Emitter emitter = (Emitter) entity;
      if (emitter.isActivateOnInit()) {
        emitter.activate();
      }
    } else if (entity instanceof IUpdateable) {
      Game.loop().attach((IUpdateable) entity);
    }
}private void unload(final IEntity entity) {
    // 1. remove from physics engine
    if (entity instanceof ICollisionEntity) {
      Game.physics().remove((ICollisionEntity) entity);
    }

    // 2. unregister from update
    if (entity instanceof IUpdateable) {
      Game.loop().detach((IUpdateable) entity);
    }

    if (entity instanceof IMobileEntity) {
      this.removeGravity((IMobileEntity) entity);
    }

    // 3. detach all controllers
    entity.detachControllers();

    if (entity instanceof Emitter) {
      Emitter em = (Emitter) entity;
      em.deactivate();
    }

    if (this.loaded && (entity instanceof LightSource || entity instanceof StaticShadow)) {
      this.updateLighting(entity);
    }

    entity.removed(this);
}
}
```
```java
class de.gurkenlabs.litiengine.graphics.animation.Animation {
@Override
  public void update() {
    // do nothing if the animation is not playing or the current keyframe is not finished
    if (!this.isPlaying()
        || Game.time().since(this.lastFrameUpdate) < this.getCurrentKeyFrame().getDuration()) {
      return;
    }

    // if we are not looping and the last keyframe is finished, we terminate the animation
    if (!this.isLooping() && this.isLastKeyFrame()) {
      this.terminate();
      return;
    }

    // make sure, we stay inside the keyframe list
    final int newFrameIndex =
        (this.getKeyframes().indexOf(this.currentFrame) + 1) % this.getKeyframes().size();
    final KeyFrame previousFrame = this.currentFrame;
    this.currentFrame = this.getKeyframes().get(newFrameIndex);

    for (KeyFrameListener listener : this.listeners) {
      listener.currentFrameChanged(previousFrame, this.currentFrame);
    }

    this.lastFrameUpdate = Game.loop().getTicks();
}public void restart() {
    this.currentFrame = this.firstFrame;
    this.lastFrameUpdate = Game.loop().getTicks();
}
}
```
```java
class de.gurkenlabs.litiengine.physics.MovementController {
@Override
  public void attach() {
    Game.loop().attach(this);
}private void handleForces() {
    // clean up forces
    this.activeForces.forEach(
        x -> {
          if (x.hasEnded()) {
            this.activeForces.remove(x);
          }
        });

    if (this.activeForces.isEmpty()) {
      return;
    }

    // disable turn-on-move for force handling
    boolean turn = this.getEntity().turnOnMove();
    this.getEntity().setTurnOnMove(false);
    try {
      double deltaX = 0;
      double deltaY = 0;
      for (final Force force : this.activeForces) {
        if (force.cancelOnReached() && force.hasReached(this.getEntity())) {
          force.end();
          continue;
        }

        final Point2D collisionBoxCenter = this.getEntity().getCollisionBoxCenter();
        final double angle =
            GeometricUtilities.calcRotationAngleInDegrees(collisionBoxCenter, force.getLocation());
        final double strength =
            Game.loop().getDeltaTime() * 0.001f * force.getStrength() * Game.loop().getTimeScale();
        deltaX += GeometricUtilities.getDeltaX(angle, strength);
        deltaY += GeometricUtilities.getDeltaY(angle, strength);
      }

      final Point2D target =
          new Point2D.Double(this.getEntity().getX() + deltaX, this.getEntity().getY() + deltaY);
      final boolean success = Game.physics().move(this.getEntity(), target);
      if (!success) {
        for (final Force force : this.activeForces) {
          if (force.cancelOnCollision()) {
            force.end();
          }
        }
      }
    } finally {
      this.getEntity().setTurnOnMove(turn);
    }
}@Override
  public void detach() {
    Game.loop().detach(this);
}public void handleMovement() {
    if (!this.isMovementAllowed()) {
      this.velocity = 0;
      return;
    }

    // max distance an entity can travel within one tick
    final double maxPixelsPerTick = this.getEntity().getTickVelocity();
    final double deltaTime = Game.loop().getDeltaTime() * Game.loop().getTimeScale();

    final double acceleration =
        this.getEntity().getAcceleration() == 0
            ? maxPixelsPerTick
            : deltaTime / this.getEntity().getAcceleration() * maxPixelsPerTick;
    final double deceleration =
        this.getEntity().getDeceleration() == 0
            ? this.getVelocity()
            : deltaTime / this.getEntity().getDeceleration() * maxPixelsPerTick;

    double dx = this.getDx();
    double dy = this.getDy();
    this.setDx(0);
    this.setDy(0);

    final double deltaVelocity =
        Math.min(Math.sqrt(Math.pow(dx, 2) + Math.pow(dy, 2)), acceleration);
    if (deltaVelocity != 0) {
      double newVelocity = this.getVelocity() + deltaVelocity;
      this.setVelocity(newVelocity);
    } else {
      final double newVelocity = Math.max(0, this.getVelocity() - deceleration);
      this.setVelocity(newVelocity);
      dx = GeometricUtilities.getDeltaX(this.moveAngle);
      dy = GeometricUtilities.getDeltaY(this.moveAngle);
    }

    if (this.getVelocity() == 0) {
      this.moveAngle = 0;
      return;
    }

    // actually move entity
    this.moveEntity(dx, dy);
}
}
```
```java
class de.gurkenlabs.litiengine.graphics.animation.AnimationController {
public void detach() {
    Game.loop().detach(this);
}public void attach() {
    Game.loop().attach(this);
}
}
```
```java
class de.gurkenlabs.litiengine.graphics.Camera {
@Override
  public void setZoom(final float targetZoom, final int delay) {
    if (delay == 0) {

      this.zoom = targetZoom;
      this.targetZoom = 0;
      this.zoomDelay = 0;
      this.zoomTick = 0;
      this.zoomStep = 0;

      final ZoomChangedEvent event = new ZoomChangedEvent(this, targetZoom);
      for (final ZoomChangedListener listener : this.zoomListeners) {
        listener.zoomChanged(event);
      }
    } else {
      this.zoomTick = Game.time().now();
      this.targetZoom = targetZoom;
      this.zoomDelay = delay;

      final double tickduration = 1000 / (double) Game.loop().getTickRate();
      final double tickAmount = delay / tickduration;
      final float totalDelta = this.targetZoom - this.zoom;
      this.zoomStep = tickAmount > 0 ? (float) (totalDelta / tickAmount) : totalDelta;
    }
}
}
```
```java
class de.gurkenlabs.litiengine.Game {
public static synchronized void init(String... args) {
    if (initialized) {
      log().log(Level.INFO, "The game has already been initialized.");
      return;
    }

    log.init();
    handleCommandLineArguments(args);

    config().load();
    Locale.setDefault(new Locale(config().client().getCountry(), config().client().getLanguage()));

    gameLoop = new GameLoop("Main Update Loop", config().client().getMaxFps());
    loop().attach(physics());
    loop().attach(world());

    // setup default exception handling for render and update loop
    setUncaughtExceptionHandler(
        new DefaultUncaughtExceptionHandler(config().client().exitOnError()));

    screenManager = new ScreenManager();
    gameWindow = new GameWindow();

    // initialize  the game window
    window().init();
    world.setCamera(new Camera());

    for (GameListener listener : gameListeners) {
      listener.initialized(args);
    }

    if (!isInNoGUIMode()) {
      window().getRenderComponent().onRendered(g -> metrics().render(g));

      graphics()
          .addEntityRenderedListener(
              e -> DebugRenderer.renderEntityDebugInfo(e.getGraphics(), e.getEntity()));

      window().getRenderComponent().onFpsChanged(fps -> metrics().setFramesPerSecond(fps));
      window()
          .setIcons(
              Arrays.asList(
                  Resources.images().get("liti-logo-x16.png"),
                  Resources.images().get("liti-logo-x20.png"),
                  Resources.images().get("liti-logo-x32.png"),
                  Resources.images().get("liti-logo-x48.png")));

      Input.keyboard()
          .onKeyTyped(
              KeyEvent.VK_PRINTSCREEN,
              key -> {
                // don't take a screenshot if a modifier is active
                if (key.getModifiers() != 0) {
                  return;
                }

                window().getRenderComponent().takeScreenshot();
              });
    }

    Runtime.getRuntime().addShutdownHook(new Thread(Game::terminate, "Shutdown"));

    initialized = true;
}
}
```
```java
class de.gurkenlabs.litiengine.entities.Creature {
protected void updateAnimationController() {
    IEntityAnimationController<?> controller = this.createAnimationController();
    this.getControllers().addController(controller);
    if (Game.world().environment() != null && Game.world().environment().isLoaded()) {
      Game.loop().attach(controller);
    }
}@Override
  public float getTickVelocity() {
    // pixels per ms multiplied by the passed ms
    // ensure that entities don't travel too far in case of lag
    return Math.min(Game.loop().getDeltaTime(), GameLoop.TICK_DELTATIME_LAG)
        * 0.001F
        * this.getVelocity().get()
        * Game.loop().getTimeScale();
}
}
```
Depth: 2
```java
class de.gurkenlabs.litiengine.environment.GameWorld {
public void clear() {
    this.unloadEnvironment();
    this.environments.clear();
    this.setCamera(null);
    Game.physics().clear();

    this.environmentListeners.clear();
    this.environmentLoadedListeners.clear();
    this.environmentUnloadedListeners.clear();

    this.listeners.clear();
    this.loadedListeners.clear();
    this.unloadedListeners.clear();
}@Nullable
  public Environment loadEnvironment(IMap map) {
    Environment env = this.getEnvironment(map);
    this.loadEnvironment(env);
    return env;
}@Nullable
  public Environment loadEnvironment(String mapName) {
    Environment env = this.getEnvironment(mapName);
    this.loadEnvironment(env);
    return env;
}
}
```
```java
class de.gurkenlabs.litiengine.GameWindow {
GameWindow() {
    this.hostControl = new JFrame();

    this.resolutionChangedListeners = new CopyOnWriteArrayList<>();

    this.renderCanvas = new RenderComponent(Game.config().graphics().getResolution());
    this.cursor = new MouseCursor();
    if (!Game.isInNoGUIMode()) {
      this.hostControl.setBackground(Color.BLACK);
      this.hostControl.add(this.renderCanvas);

      this.initializeEventListeners();

      this.hostControl.setTitle(Game.info().getTitle());
      this.hostControl.setDefaultCloseOperation(WindowConstants.DO_NOTHING_ON_CLOSE);
      initializeWindowEventListeners(this.hostControl);
    }
}
}
```
```java
class de.gurkenlabs.litiengine.GameTime {
public long sinceEnvironmentLoad() {
    return this.since(this.environmentLoaded);
}public long since(final long tick) {
    return toMilliseconds(Game.loop().getTicks() - tick);
}public long sinceGameStart() {
    return this.toMilliseconds(Game.loop().getTicks());
}
}
```
```java
class de.gurkenlabs.litiengine.abilities.effects.Effect {
protected void cease(final EffectApplication appliance) {
    // 1. cease the effect for all affected entities
    for (final ICombatEntity entity : appliance.getAffectedEntities()) {
      this.cease(entity);
    }

    // 2. apply follow up effects
    this.getFollowUpEffects().forEach(followUp -> followUp.apply(appliance.getImpactArea()));
}protected boolean hasEnded(final EffectApplication appliance) {
    final long effectDuration = Game.time().since(appliance.getAppliedTicks());
    return effectDuration > this.getDuration();
}
}
```
```java
class de.gurkenlabs.litiengine.abilities.effects.EffectApplication {
protected EffectApplication(final List<ICombatEntity> affectedEntities, final Shape impactArea) {
    this.applied = Game.time().now();
    this.affectedEntities = affectedEntities;
    this.impactArea = impactArea;
}
}
```
```java
class de.gurkenlabs.litiengine.entities.CombatEntity {
@Override
  public boolean wasHit(int timeSpan) {
    return Game.time().since(this.lastHit) < timeSpan;
}@Override
  public void hit(final int damage, @Nullable final Ability ability) {
    if (this.isDead()) {
      return;
    }

    if (!this.isIndestructible()) {
      this.getHitPoints().modifyBaseValue(new AttributeModifier<>(Modification.SUBTRACT, damage));
    }

    final EntityHitEvent event = new EntityHitEvent(this, ability, damage, this.isDead());

    for (final CombatEntityListener listener : this.listeners) {
      listener.hit(event);
    }

    for (final CombatEntityHitListener listener : this.hitListeners) {
      listener.hit(event);
    }

    if (this.isDead()) {
      this.fireDeathEvent();
      this.setCollision(false);
    }

    this.lastHit = Game.time().now();
}
}
```
```java
class de.gurkenlabs.litiengine.graphics.ImageEffect {
protected ImageEffect(final int ttl, final String name) {
    this.ttl = ttl;
    this.name = name;
    this.aliveTick = Game.time().now();
}@Override
  public long getAliveTime() {
    return Game.time().since(this.aliveTick);
}
}
```
```java
class de.gurkenlabs.litiengine.abilities.AbilityExecution {
AbilityExecution(final Ability ability) {
    this.appliedEffects = new CopyOnWriteArrayList<>();
    this.ability = ability;
    this.executionTicks = Game.time().now();
    this.impactArea = ability.calculateImpactArea();
    this.castLocation = ability.getExecutor().getCenter();
    Game.loop().attach(this);
}@Override
  public void update() {
    // if there a no effects to apply -> unregister this instance and we're done
    if (this.getAbility().getEffects().isEmpty()
        || this.getAbility().getEffects().size() == this.getAppliedEffects().size()) {
      Game.loop().detach(this);
      return;
    }

    // handle all effects from the ability that were not applied yet
    for (final Effect effect : this.getAbility().getEffects()) {
      // if the ability was not executed yet or the delay of the effect is not
      // yet reached
      if (this.getAppliedEffects().contains(effect)
          || Game.time().since(this.getExecutionTicks()) < effect.getDelay()) {
        continue;
      }

      effect.apply(this.getExecutionImpactArea());
      this.getAppliedEffects().add(effect);
    }
}
}
```
```java
class de.gurkenlabs.litiengine.tweening.TweenEngine {
@Override
  public void update() {
    for (final Tweenable target : this.getTweens().keySet()) {
      for (final Tween tween : this.getTweens().get(target).values()) {
        if (tween.hasStopped()) {
          continue;
        }
        final long elapsed = Game.time().since(tween.getStartTime());
        if (elapsed >= tween.getDuration()) {
          tween.stop();
          continue;
        }
        final float[] currentValues = new float[tween.getTargetValues().length];
        for (int i = 0; i < tween.getTargetValues().length; i++) {
          currentValues[i] =
              tween.getStartValues()[i]
                  + tween.getEquation().compute(elapsed / (float) tween.getDuration())
                      * (tween.getTargetValues()[i] - tween.getStartValues()[i]);
        }
        tween.getTarget().setTweenValues(tween.getType(), currentValues);
      }
    }
}
}
```
```java
class de.gurkenlabs.litiengine.gui.SpeechBubble {
public static SpeechBubble create(
      final IEntity entity, final String text, SpeechBubbleAppearance appearance, Font font) {
    return new SpeechBubble(entity, text, appearance, font);
}public static SpeechBubble create(final IEntity entity, final Font font, final String text) {
    SpeechBubbleAppearance app =
        new SpeechBubbleAppearance(
            DEFAULT_APPEARANCE.getForeColor(),
            DEFAULT_APPEARANCE.getBackgroundColor1(),
            DEFAULT_APPEARANCE.getBorderColor(),
            DEFAULT_APPEARANCE.getPadding());
    return new SpeechBubble(entity, text, app, font);
}public static SpeechBubble create(final IEntity entity, final String text) {
    return new SpeechBubble(entity, text, null, GuiProperties.getDefaultFont());
}@Override
  public void update() {
    if (this.currentText == null) {
      this.hide();
      return;
    }

    this.entityCenter = Game.world().camera().getViewportLocation(this.getEntity().getCenter());

    // old text was displayed long enough
    if (this.lastTextDisplay != 0
        && Game.time().since(this.lastTextDisplay) > this.currentTextDisplayTime) {
      this.currentText = null;
      this.lastTextDisplay = 0;
      return;
    }

    // display new text
    if (this.textIndex < this.currentText.length()
        && Game.time().since(this.lastCharPoll) > LETTER_WRITE_DELAY) {
      this.textIndex++;
      this.lastCharPoll = Game.time().now();
      if (this.typeSound != null) {
        Game.audio().playSound(this.typeSound, this.getEntity());
      }
    }

    // continue displaying currently displayed text
}private SpeechBubble(
      final IEntity entity,
      final String text,
      final Sound typeSound,
      SpeechBubbleAppearance appearance,
      Font font) {
    this(entity, text, appearance, font);
    this.typeSound = typeSound;
}private SpeechBubble(
      final IEntity entity,
      final String text,
      @Nullable SpeechBubbleAppearance appearance,
      @Nullable Font font) {
    if (appearance == null) {
      this.appearance = DEFAULT_APPEARANCE;
    } else {
      this.appearance = appearance;
    }

    final SpeechBubble active = activeSpeechBubbles.get(entity);
    if (active != null) {
      active.hide();
    }
    this.setFont(font);

    this.textBoxWidth = (float) (entity.getWidth() * 4);
    this.entity = entity;

    this.currentText = text;
    this.currentTextDisplayTime = DISPLAYTIME_MIN + text.length() * DISPLAYTIME_PER_LETTER;

    this.lastTextDisplay = Game.time().now();
    this.createBubbleImage();
    entity.getEnvironment().add(this, RenderType.UI);
    Game.loop().attach(this);
    activeSpeechBubbles.put(entity, this);
}
}
```
```java
class de.gurkenlabs.litiengine.gui.TextFieldComponent {
@Override
  public void render(final Graphics2D g) {
    super.render(g);
    g.setFont(this.getFont());
    final FontMetrics fm = g.getFontMetrics();

    if (this.isSelected() && Game.time().since(this.lastToggled) > this.flickerDelay) {
      this.cursorVisible = !this.cursorVisible;
      this.lastToggled = Game.time().now();
    }
    if (this.isSelected() && this.cursorVisible) {
      final Rectangle2D cursor =
          new Rectangle2D.Double(
              this.getX() + this.getTextX() + fm.stringWidth(this.getTextToRender(g)),
              this.getY() + this.getTextY(),
              this.getFont().getSize2D() * 3 / 5,
              this.getFont().getSize2D() * 1 / 5);
      g.setColor(this.getAppearance().getForeColor());
      g.fill(cursor);
    }
}
}
```
```java
class de.gurkenlabs.litiengine.entities.Prop {
public Prop(
      final Point2D location, @Nullable final String spritesheetName, final Material material) {
    super();
    this.rotation = Rotation.NONE;
    this.spritesheetName = spritesheetName;
    this.material = material;
    this.setLocation(location);
    this.updateAnimationController();
}public void setSpritesheetName(@Nullable final String spriteName) {
    this.spritesheetName = spriteName;
    this.updateAnimationController();
}
}
```
```java
class de.gurkenlabs.litiengine.tweening.Tween {
public Tween begin() {
    this.started = Game.time().now();
    this.stopped = false;
    return this;
}
}
```
```java
class de.gurkenlabs.litiengine.graphics.emitters.particles.Particle {
public void update(final Point2D emitterOrigin, final float updateRatio) {
    if (this.aliveTick == 0) {
      this.aliveTick = Game.time().now();
    }

    this.aliveTime = Game.time().since(this.aliveTick);
    if (this.timeToLiveReached()) {
      return;
    }

    if (this.colliding) {
      return;
    }

    if (this.getDeltaWidth() != 0) {
      this.width += this.getDeltaWidth() * updateRatio;
    }

    if (this.getDeltaHeight() != 0) {
      this.height += this.getDeltaHeight() * updateRatio;
    }

    if (this.getDeltaAngle() != 0) {
      this.angle += this.getDeltaAngle() * updateRatio;
    }

    // test for ray cast collision
    final float targetX = this.x + this.getVelocityX() * updateRatio;
    final float targetY = this.y + this.getVelocityY() * updateRatio;

    if (targetX == this.x && targetY == this.y) {
      return;
    }

    if (this.checkForCollision(emitterOrigin, targetX, targetY)) {
      return;
    }

    if (this.getVelocityX() != 0) {
      this.x = targetX;
    }

    if (this.getVelocityY() != 0) {
      this.y = targetY;
    }

    if (this.getAccelerationX() != 0) {
      this.velocityX += this.getAccelerationX() * updateRatio;
    }

    if (this.getAccelerationY() != 0) {
      this.velocityY += this.getAccelerationY() * updateRatio;
    }
}
}
```
```java
class de.gurkenlabs.litiengine.graphics.animation.Animation {
@Override
  public void start() {
    this.playing = true;
    if (this.getKeyframes().isEmpty()) {
      return;
    }

    this.restart();
}@Override
  public void update() {
    // do nothing if the animation is not playing or the current keyframe is not finished
    if (!this.isPlaying()
        || Game.time().since(this.lastFrameUpdate) < this.getCurrentKeyFrame().getDuration()) {
      return;
    }

    // if we are not looping and the last keyframe is finished, we terminate the animation
    if (!this.isLooping() && this.isLastKeyFrame()) {
      this.terminate();
      return;
    }

    // make sure, we stay inside the keyframe list
    final int newFrameIndex =
        (this.getKeyframes().indexOf(this.currentFrame) + 1) % this.getKeyframes().size();
    final KeyFrame previousFrame = this.currentFrame;
    this.currentFrame = this.getKeyframes().get(newFrameIndex);

    for (KeyFrameListener listener : this.listeners) {
      listener.currentFrameChanged(previousFrame, this.currentFrame);
    }

    this.lastFrameUpdate = Game.loop().getTicks();
}
}
```
```java
class de.gurkenlabs.litiengine.graphics.animation.AnimationController {
@Override
  public void update() {
    for (final Animation animation : this.getAll()) {
      animation.update();
    }

    if (this.getCurrent() != null && this.getCurrent().isPaused()) {
      return;
    }

    final boolean playbackFinished = this.getCurrent() != null && !this.getCurrent().isPlaying();
    if (playbackFinished) {
      for (final AnimationListener listener : this.listeners) {
        listener.finished(this.getCurrent());
      }
    }

    if (this.getCurrent() == null || playbackFinished) {
      if (this.getDefault() != null) {
        this.play(this.getDefault().getName());
      } else {
        this.currentAnimation = null;
      }
    }
}
}
```
```java
class de.gurkenlabs.litiengine.graphics.RenderComponent {
private void handleFade() {
    if (this.fadeOutStart != -1) {
      final long timePassed = Game.time().since(this.fadeOutStart);
      this.currentAlpha = MathUtilities.clamp(1 - timePassed / (float) this.fadeOutTime, 0, 1);
      if (this.currentAlpha == 0f) {
        this.fadeOutStart = -1;
        this.fadeOutTime = -1;
      }

      return;
    }

    if (this.fadeInStart != -1) {
      final long timePassed = Game.time().since(this.fadeInStart);
      this.currentAlpha = MathUtilities.clamp(timePassed / (float) this.fadeInTime, 0, 1);
      if (this.currentAlpha == 1f) {
        this.fadeInStart = -1;
        this.fadeInTime = -1;
        this.currentAlpha = Float.NaN;
      }
    }
}public void fadeOut(final int ms) {
    this.fadeInStart = -1;
    this.fadeInTime = -1;
    this.fadeOutStart = Game.time().now();
    this.fadeOutTime = ms;
}public void fadeIn(final int ms) {
    this.fadeOutStart = -1;
    this.fadeOutTime = -1;
    this.fadeInStart = Game.time().now();
    this.fadeInTime = ms;
}
}
```
```java
class de.gurkenlabs.litiengine.entities.Trigger {
private boolean activate(final IEntity activator, final int tar) {
    if (!this.isLoaded()
        || this.isOneTimeTrigger && this.isActivated
        || this.getActivationType() == TriggerActivation.COLLISION
            && activator != null
            && this.collisionActivated.contains(activator)) {
      return false;
    }

    if (this.getCooldown() > 0 && Game.time().since(this.lastActivation) < this.getCooldown()) {
      return false;
    }

    List<Integer> triggerTargets = this.getTargets(tar);

    final TriggerEvent te = new TriggerEvent(this, activator, triggerTargets);

    if (!this.checkActivationPredicates(te)) {
      return false;
    }

    this.isActivated = true;
    if (activator != null) {
      this.collisionActivated.add(activator);
    }

    // if we actually have a trigger target, we send the message to the target
    for (final int target : triggerTargets) {
      final IEntity entity = this.getEnvironment().get(target);
      if (entity == null) {
        log.log(
            Level.WARNING,
            "trigger [{0}] was activated, but the trigger target [{1}] could not be found on the environment",
            new Object[] {this, target});
        continue;
      }

      entity.sendMessage(this, this.message);
    }

    // also send the trigger event to all registered consumers
    for (final TriggerActivatedListener listener : this.activatedListeners) {
      listener.activated(te);
    }

    if (this.isOneTimeTrigger) {
      this.getEnvironment().remove(this);
    }

    this.lastActivation = Game.time().now();
    return true;
}
}
```
```java
class de.gurkenlabs.litiengine.graphics.Camera {
private boolean isShakeEffectActive() {
    return this.getShakeTick() != 0
        && Game.time().since(this.getShakeTick()) < this.getShakeDuration();
}@Override
  public void update() {
    if (Game.world().camera() != null && !Game.world().camera().equals(this)) {
      return;
    }

    if (this.targetZoom > 0) {
      if (Game.time().since(this.zoomTick) >= this.zoomDelay) {
        this.zoom = this.targetZoom;
        this.targetZoom = 0;
        this.zoomDelay = 0;
        this.zoomTick = 0;
        this.zoomStep = 0;
      } else {
        this.zoom += this.zoomStep;
      }

      final ZoomChangedEvent event = new ZoomChangedEvent(this, this.getZoom());
      for (final ZoomChangedListener listener : this.zoomListeners) {
        listener.zoomChanged(event);
      }
    }

    if (this.panTime > 0) {
      if (--this.panTime <= 0) {
        this.setFocus(this.targetFocus);
        this.targetFocus = null;
      } else {
        double diff = this.panTime / (this.panTime + 1.0);
        this.focus =
            new Point2D.Double(
                this.focus.getX() * diff + this.targetFocus.getX() * (1.0 - diff),
                this.focus.getY() * diff + this.targetFocus.getY() * (1.0 - diff));
      }
    }

    if (!this.isShakeEffectActive()) {
      this.shakeOffsetX = 0;
      this.shakeOffsetY = 0;
      return;
    }

    if (Game.time().since(this.lastShake) > this.shakeDelay) {
      this.shakeOffsetX = this.getShakeIntensity() * ThreadLocalRandom.current().nextGaussian();
      this.shakeOffsetY = this.getShakeIntensity() * ThreadLocalRandom.current().nextGaussian();
      this.lastShake = Game.time().now();
    }
}@Override
  public void setZoom(final float targetZoom, final int delay) {
    if (delay == 0) {

      this.zoom = targetZoom;
      this.targetZoom = 0;
      this.zoomDelay = 0;
      this.zoomTick = 0;
      this.zoomStep = 0;

      final ZoomChangedEvent event = new ZoomChangedEvent(this, targetZoom);
      for (final ZoomChangedListener listener : this.zoomListeners) {
        listener.zoomChanged(event);
      }
    } else {
      this.zoomTick = Game.time().now();
      this.targetZoom = targetZoom;
      this.zoomDelay = delay;

      final double tickduration = 1000 / (double) Game.loop().getTickRate();
      final double tickAmount = delay / tickduration;
      final float totalDelta = this.targetZoom - this.zoom;
      this.zoomStep = tickAmount > 0 ? (float) (totalDelta / tickAmount) : totalDelta;
    }
}@Override
  public void shake(final double intensity, final int delay, final int shakeDuration) {
    this.shakeTick = Game.time().now();
    this.shakeDelay = delay;
    this.shakeIntensity = intensity;
    this.shakeDuration = shakeDuration;
}
}
```
```java
class de.gurkenlabs.litiengine.entities.Creature {
public void setSpritesheetName(String spritesheetName) {
    if (this.spritesheetName != null && this.spritesheetName.equals(spritesheetName)) {
      return;
    }

    this.spritesheetName = spritesheetName;
    this.updateAnimationController();
}public boolean isIdle() {
    return Game.time().since(this.lastMoved) > IDLE_DELAY;
}@Override
  public void setLocation(final Point2D position) {
    if (this.isDead() || position == null) {
      return;
    }

    final Point2D oldLocation = this.getLocation();
    super.setLocation(position);

    if (Game.hasStarted() && this.isLoaded()) {
      this.lastMoved = Game.time().now();
      this.fireMovedEvent(
          new EntityMovedEvent(
              this, this.getX() - oldLocation.getX(), this.getY() - oldLocation.getY()));
    }
}
}
```
```java
class de.gurkenlabs.litiengine.gui.screens.ScreenManager {
public void display(final String screenName) {
    if (this.current() != null && this.current().getName().equalsIgnoreCase(screenName)) {
      log.log(
          Level.INFO,
          "Skipping displaying of screen {0} because it is already the current screen.",
          screenName);
      return;
    }

    if (this.screens.stream()
        .noneMatch(element -> element.getName().equalsIgnoreCase(screenName))) {
      log.log(
          Level.WARNING,
          "Could not display the screen {0} because there is no screen with the specified name.",
          screenName);
      return;
    }

    Screen screen = this.get(screenName);
    if (screen == null) {
      return;
    }

    this.display(screen);
}public void add(final Screen screen) {
    screen.setWidth(Game.window().getWidth());
    screen.setHeight(Game.window().getHeight());
    this.screens.add(screen);

    if (this.current() == null) {
      this.display(screen);
    }
}public void remove(Screen screen) {
    this.screens.remove(screen);
    if (this.current() == screen) {
      if (!this.screens.isEmpty()) {
        this.display(this.screens.get(0));
      } else {
        this.display((Screen) null);
      }
    }
}public void display(@Nullable final Screen screen) {
    if (Game.hasStarted() && Game.time().since(this.lastScreenChange) < this.getChangeCooldown()) {
      log.log(
          Level.INFO,
          "Skipping displaying of screen {0} because screen changing is currently on cooldown.",
          screen != null ? screen.getName() : "");
      return;
    }

    final Screen previous = this.current();
    if (previous != null) {
      previous.suspend();
    }

    if (screen != null && !this.screens.contains(screen)) {
      this.screens.add(screen);
    }

    this.currentScreen = screen;
    if (!Game.isInNoGUIMode() && this.current() != null) {
      this.current().prepare();
    }

    this.lastScreenChange = Game.loop().getTicks();

    final ScreenChangedEvent event = new ScreenChangedEvent(this.current(), previous);
    for (final ScreenChangedListener listener : this.screenChangedListeners) {
      listener.changed(event);
    }
}
}
```
```java
class de.gurkenlabs.litiengine.abilities.Ability {
public boolean isOnCooldown() {
    return (this.getCurrentExecution() != null
        && this.getCurrentExecution().getExecutionTicks() > 0
        && Game.time().since(this.getCurrentExecution().getExecutionTicks())
            < this.getAttributes().cooldown().get());
}public boolean isActive() {
    return this.getCurrentExecution() != null
        && Game.time().since(this.getCurrentExecution().getExecutionTicks())
            < this.getAttributes().duration().get();
}@Nullable
  public AbilityExecution cast() {
    if (!this.canCast()) {
      return null;
    }
    this.currentExecution = new AbilityExecution(this);

    for (final AbilityCastListener listener : this.abilityCastListeners) {
      listener.abilityCast(this.currentExecution);
    }

    return this.getCurrentExecution();
}public float getRemainingCooldownInSeconds() {
    if (this.getCurrentExecution() == null
        || this.getExecutor() == null
        || this.getExecutor().isDead()) {
      return 0;
    }

    // calculate cooldown in seconds
    return (float)
        (!this.canCast()
            ? (this.getAttributes().cooldown().get()
                    - Game.time().since(this.getCurrentExecution().getExecutionTicks()))
                * 0.001
            : 0);
}
}
```
```java
class de.gurkenlabs.litiengine.entities.EntityHitEvent {
EntityHitEvent(
      final ICombatEntity hitEntity,
      @Nullable final Ability ability,
      final int damage,
      final boolean kill) {
    super(hitEntity);
    this.executor = ability != null ? ability.getExecutor() : null;
    this.hitEntity = hitEntity;
    this.ability = ability;
    this.damage = damage;
    this.kill = kill;
    this.time = Game.time().now();
}
}
```
```java
class de.gurkenlabs.litiengine.graphics.emitters.Emitter {
public void delete() {
    this.deactivate();
    if (Game.world().environment() != null) {
      Game.world().environment().remove(this);
    }
}public void activate() {
    if (this.activated) {
      return;
    }

    this.activated = true;
    this.activationTick = Game.time().now();
    Game.loop().attach(this);
}@Override
  public void update() {
    if (this.isPaused()) {
      return;
    }

    // clear particles if the effect time to life is reached
    if (this.isFinished()) {
      for (EmitterFinishedListener listener : this.finishedListeners) {
        listener.finished(this);
      }

      this.delete();
      return;
    }

    final float updateRatio = (float) this.data().getUpdateRate() / Game.loop().getTickRate();
    for (final Particle p : this.getParticles().stream().collect(Collectors.toList())) {
      if (this.particleCanBeRemoved(p)) {
        // remove dead particles
        this.particles.remove(p);
        continue;
      }

      p.update(this.getOrigin(), updateRatio);
    }

    this.aliveTime = Game.time().since(this.activationTick);
    if ((this.data().getSpawnRate() == 0
        || Game.time().since(this.lastSpawn) >= this.data().getSpawnRate())) {
      this.lastSpawn = Game.time().now();
      this.spawnParticle();
    }
}
}
```
```java
class de.gurkenlabs.litiengine.GameLoop {
@Override
  public int perform(int delay, Runnable action) {
    final long d = Game.time().toTicks(delay);

    TimedAction a = new TimedAction(this.getTicks() + d, action);
    this.actions.add(a);

    return a.getId();
}
}
```
```java
class de.gurkenlabs.litiengine.environment.EntitySpawner {
protected boolean shouldSpawn() {
    return this.lastSpawnWave == 0
        || Game.time().since(this.lastSpawnWave) >= this.getSpawnInterval();
}@Override
  public void update() {
    if (!this.shouldSpawn()) {
      return;
    }

    this.spawnNewEntities();
    this.lastSpawnWave = Game.time().now();
}
}
```
```java
class de.gurkenlabs.litiengine.graphics.FreeFlightCamera {
@Override
  public void update() {
    this.handleFreeFlightCamera();
}public FreeFlightCamera(double x, double y) {
    this(new Point2D.Double(x, y));
}
}
```
```java
class de.gurkenlabs.litiengine.environment.Environment {
public void unload() {
    if (!this.loaded) {
      return;
    }

    // unregister all updatable entities from the current environment
    for (final IEntity entity : this.allEntities.values()) {
      this.unload(entity);
    }

    this.loaded = false;
    this.fireEvent(l -> l.unloaded(this));
}private static void loadUpdatableOrEmitterEntity(IEntity entity) {
    if (entity instanceof Emitter) {
      final Emitter emitter = (Emitter) entity;
      if (emitter.isActivateOnInit()) {
        emitter.activate();
      }
    } else if (entity instanceof IUpdateable) {
      Game.loop().attach((IUpdateable) entity);
    }
}public void clear() {
    Game.physics().clear();

    this.combatEntities.clear();
    this.mobileEntities.clear();
    this.gravityForces.clear();
    this.layerEntities.clear();
    this.entitiesByTag.clear();
    this.allEntities.clear();

    for (RenderType renderType : RenderType.values()) {
      this.miscEntities.get(renderType).clear();
      this.renderListeners.get(renderType).clear();
      this.renderables.get(renderType).clear();
    }

    dispose(this.allEntities.values());
    dispose(this.triggers);
    this.emitters.clear();
    this.colliders.clear();
    this.props.clear();
    this.creatures.clear();
    this.staticShadows.clear();
    this.combatEntities.clear();
    this.mobileEntities.clear();
    this.lightSources.clear();
    this.spawnPoints.clear();
    this.soundSources.clear();
    this.mapAreas.clear();
    this.triggers.clear();

    this.ambientLight = null;
    this.staticShadowLayer = null;

    for (Map<Integer, IEntity> type : this.miscEntities.values()) {
      type.clear();
    }

    this.initialized = false;

    this.fireEvent(l -> l.cleared(this));
}private void load(final IEntity entity) {
    // an entity can only exist on one environment at a time, so remove it from the current one
    if (entity.getEnvironment() != null) {
      entity.getEnvironment().remove(entity);
    }

    // 1. add to physics engine
    loadPhysicsEntity(entity);

    // 2. register for update or activate
    loadUpdatableOrEmitterEntity(entity);

    // 3. if a gravity is defined, add a gravity force to the entity
    if (entity instanceof IMobileEntity && this.getGravity() != 0) {
      this.addGravityForce((IMobileEntity) entity);
    }

    // 4. attach all controllers
    entity.attachControllers();

    if (this.loaded && (entity instanceof LightSource || entity instanceof StaticShadow)) {
      this.updateLighting(entity);
    }

    entity.loaded(this);
}private void unload(final IEntity entity) {
    // 1. remove from physics engine
    if (entity instanceof ICollisionEntity) {
      Game.physics().remove((ICollisionEntity) entity);
    }

    // 2. unregister from update
    if (entity instanceof IUpdateable) {
      Game.loop().detach((IUpdateable) entity);
    }

    if (entity instanceof IMobileEntity) {
      this.removeGravity((IMobileEntity) entity);
    }

    // 3. detach all controllers
    entity.detachControllers();

    if (entity instanceof Emitter) {
      Emitter em = (Emitter) entity;
      em.deactivate();
    }

    if (this.loaded && (entity instanceof LightSource || entity instanceof StaticShadow)) {
      this.updateLighting(entity);
    }

    entity.removed(this);
}public void remove(final IEntity entity) {
    if (entity == null) {
      return;
    }

    this.allEntities.remove(entity.getMapId());
    Iterator<List<IEntity>> iter = this.layerEntities.values().iterator();
    while (iter.hasNext()) {
      List<IEntity> layer = iter.next();
      if (layer.remove(entity) && layer.isEmpty()) {
        iter.remove();
      }
    }
    if (this.miscEntities.get(entity.getRenderType()) != null) {
      this.miscEntities.get(entity.getRenderType()).values().remove(entity);
    }

    for (String tag : entity.getTags()) {
      if (this.getEntitiesByTag().containsKey(tag)) {
        this.getEntitiesByTag().get(tag).remove(entity);

        if (this.getEntitiesByTag().get(tag).isEmpty()) {
          this.getEntitiesByTag().remove(tag);
        }
      }
    }

    if (entity instanceof Emitter) {
      Emitter emitter = (Emitter) entity;
      this.removeEmitter(emitter);
    }

    if (entity instanceof MapArea) {
      this.mapAreas.remove(entity);
    }

    if (entity instanceof Prop) {
      this.props.remove(entity);
    }

    if (entity instanceof Creature) {
      this.creatures.remove(entity);
    }

    if (entity instanceof CollisionBox) {
      this.colliders.remove(entity);
      this.staticShadows.removeIf(x -> x.getOrigin() != null && x.getOrigin().equals(entity));
    }

    if (entity instanceof LightSource) {
      this.lightSources.remove(entity);
      this.updateLighting(entity);
    }

    if (entity instanceof Trigger) {
      this.triggers.remove(entity);
    }

    if (entity instanceof Spawnpoint) {
      this.spawnPoints.remove(entity);
    }
    if (entity instanceof SoundSource) {
      this.soundSources.remove(entity);
    }

    if (entity instanceof StaticShadow) {
      this.staticShadows.remove(entity);
      this.updateLighting(entity);
    }

    if (entity instanceof IMobileEntity) {
      this.mobileEntities.values().remove(entity);
    }

    if (entity instanceof ICombatEntity) {
      this.combatEntities.values().remove(entity);
    }

    this.unload(entity);

    this.fireEntityEvent(l -> l.entityRemoved(entity));
}
}
```
```java
class de.gurkenlabs.litiengine.physics.MovementController {
@Override
  public void update() {
    this.handleForces();
    this.handleMovement();
}
}
```
```java
class de.gurkenlabs.litiengine.Game {
static synchronized void terminate() {
    if (!initialized) {
      return;
    }

    hasStarted = false;
    initialized = false;

    config().save();
    gameLoop.terminate();
    tweenEngine.terminate();
    soundEngine.terminate();

    world().clear();

    for (final GameListener listener : gameListeners) {
      try {
        listener.terminated();
      } catch (Exception e) {
        log().log(Level.WARNING, "game listener threw an exception during shutdown", e);
      }
    }

    gameLoop = null;
    screenManager = null;
    gameWindow = null;
}public static synchronized void start() {
    if (!initialized) {
      throw new IllegalStateException(
          "The game cannot be started without being first initialized. Call Game.init(...) before Game.start().");
    }

    gameLoop.start();
    tweenEngine.start();
    soundEngine.start();

    for (final GameListener listener : gameListeners) {
      listener.started();
    }

    hasStarted = true;
}public static synchronized void init(String... args) {
    if (initialized) {
      log().log(Level.INFO, "The game has already been initialized.");
      return;
    }

    log.init();
    handleCommandLineArguments(args);

    config().load();
    Locale.setDefault(new Locale(config().client().getCountry(), config().client().getLanguage()));

    gameLoop = new GameLoop("Main Update Loop", config().client().getMaxFps());
    loop().attach(physics());
    loop().attach(world());

    // setup default exception handling for render and update loop
    setUncaughtExceptionHandler(
        new DefaultUncaughtExceptionHandler(config().client().exitOnError()));

    screenManager = new ScreenManager();
    gameWindow = new GameWindow();

    // initialize  the game window
    window().init();
    world.setCamera(new Camera());

    for (GameListener listener : gameListeners) {
      listener.initialized(args);
    }

    if (!isInNoGUIMode()) {
      window().getRenderComponent().onRendered(g -> metrics().render(g));

      graphics()
          .addEntityRenderedListener(
              e -> DebugRenderer.renderEntityDebugInfo(e.getGraphics(), e.getEntity()));

      window().getRenderComponent().onFpsChanged(fps -> metrics().setFramesPerSecond(fps));
      window()
          .setIcons(
              Arrays.asList(
                  Resources.images().get("liti-logo-x16.png"),
                  Resources.images().get("liti-logo-x20.png"),
                  Resources.images().get("liti-logo-x32.png"),
                  Resources.images().get("liti-logo-x48.png")));

      Input.keyboard()
          .onKeyTyped(
              KeyEvent.VK_PRINTSCREEN,
              key -> {
                // don't take a screenshot if a modifier is active
                if (key.getModifiers() != 0) {
                  return;
                }

                window().getRenderComponent().takeScreenshot();
              });
    }

    Runtime.getRuntime().addShutdownHook(new Thread(Game::terminate, "Shutdown"));

    initialized = true;
}
}
```


Response Format:
Provide the answer in **XML format** as follows:

#### If the method **cannot** return `null` at the specific call site:
```xml
<response>
  <reason><![CDATA[EXPLAIN WHY THE INVOCATION Game.loop() RESULT CANNOT BE NULL.]]></reason>
  <value>NO</value>
</response>

#### If the method can return null at the specific call site:
<response>
  <reason><![CDATA[EXPLAIN WHY THE INVOCATION Game.loop() RESULT CAN BE NULL.]]></reason>
  <value>YES</value>
</response>

#### If you are unsure or If there are any methods that directly or indirectly affect the return value and are not fully disclosed, request their declarations first, in the following format:
<response>
  <reason><![CDATA[EXPLAIN WHY THIS METHOD DECLARATION IS NECESSARY AND WHY YOU CANNOT MAKE A CONFIDENT DECISION WITHOUT IT]]></reason>
  <success>false</success>
  <methods>
    <method>methodName</method>
  </methods>
</response>

Additional Notes:
Be precise in your reasoning.
If a method’s return value depends on another method not provided, request its declaration before making a conclusion.
If the method can return null in this case but not in others, explain why it happens specifically for this call.

---ChatGPT.sendRequestToOpenAI---
Retrieving response from cache
---Response.<init>---
Creating Response:
```xml
<response>
  <reason><![CDATA[The method `Game.loop()` returns the static field `gameLoop`, which is initialized in the `Game.init(String... args)` method. In this method, a new `GameLoop` object is instantiated and assigned to `gameLoop`. Since `init()` must be called before `start()`, which is implied by the requirement of initializing the game, the `gameLoop` is guaranteed to be non-null during the lifetime of the game execution where `Game.loop()` is called. The absence of any code that could set `gameLoop` to null after its initialization ensures that `Game.loop()` cannot return null.]]></reason>
  <value>NO</value>
</response>
```
---Response.<init>---
Response created:
Disagreement: The method `Game.loop()` returns the static field `gameLoop`, which is initialized in the `Game.init(String... args)` method. In this method, a new `GameLoop` object is instantiated and assigned to `gameLoop`. Since `init()` must be called before `start()`, which is implied by the requirement of initializing the game, the `gameLoop` is guaranteed to be non-null during the lifetime of the game execution where `Game.loop()` is called. The absence of any code that could set `gameLoop` to null after its initialization ensures that `Game.loop()` cannot return null.
---AdvancedNullAwayCodeFix.resolveMethodDereferenceError---
Method is not returning nullable on call site. Injecting suppression annotation.
---AdvancedNullAwayCodeFix.constructCastToNonnullChange---
Constructing cast to nonnull change for reason: The method `Game.loop()` returns the static field `gameLoop`, which is initialized in the `Game.init(String... args)` method. In this method, a new `GameLoop` object is instantiated and assigned to `gameLoop`. Since `init()` must be called before `start()`, which is implied by the requirement of initializing the game, the `gameLoop` is guaranteed to be non-null during the lifetime of the game execution where `Game.loop()` is called. The absence of any code that could set `gameLoop` to null after its initialization ensures that `Game.loop()` cannot return null.
---ChatGPT.ask---
Asking ChatGPT:
For the reason you mentioned earlier:

"The method `Game.loop()` returns the static field `gameLoop`, which is initialized in the `Game.init(String... args)` method. In this method, a new `GameLoop` object is instantiated and assigned to `gameLoop`. Since `init()` must be called before `start()`, which is implied by the requirement of initializing the game, the `gameLoop` is guaranteed to be non-null during the lifetime of the game execution where `Game.loop()` is called. The absence of any code that could set `gameLoop` to null after its initialization ensures that `Game.loop()` cannot return null."

in the method below, the expression Game.loop() is not nullable at the point it is used.

```java
public long since(final long tick) {
    return toMilliseconds(Game.loop().getTicks() - tick);
}
```
Please Summarize the reason in max 5 words and rewrite the method so that at the line "    return toMilliseconds(Game.loop().getTicks() - tick);", at the occurrence of: "Game.loop()" is replaced with `NullabilityUtil.castToNonnull(Game.loop(), summary of reason)`
Replace "REASON" with the exact reason summary I provide to you (maximum 5 words), not with a generic explanation like "checked to be nonnull".
see the example below, for expression `foo.getBar()`, to wrap it with `NullabilityUtil.castToNonnull(foo.getBar(), "reason")`.

```java
public t(){
    String l = foo.getBar();
}
```

will be:
```java
public t(){
    String l = NullabilityUtil.castToNonnull(foo.getBar(), "checked to be nonnull");
}
```

### Instructions:

Do not import any additional classes.

Do not add Java comments.

Only modify relevant lines as required.

Return only the modified method wrapped in the XML format shown below.

Place the Java code inside the <code> tag using a CDATA block with ```java formatting.

Just give me the fixed code snippet in XML format in <response> tag like the example below. I will apply the fix to my codebase. Do not import any additional libraries or classes or add java comments. If you can provide the fixed code snippet, please provide it in the following format and place the code snippet in the <code> tag within ```java block.
<response>
  <success>true</success>
  <code><![CDATA[
  ```java
  Your fixed code snippet here
  ```
    ]]>
  </code>
</response>

---ChatGPT.sendRequestToOpenAI---
Sending request to OpenAI...
---ChatGPT.sendRequestToOpenAI---
Response received from OpenAI.
---Response.<init>---
Creating Response:
Here is your fixed code snippet:

```xml
<response>
  <success>true</success>
  <code><![CDATA[
  ```java
  public long since(final long tick) {
      return toMilliseconds(NullabilityUtil.castToNonnull(Game.loop(), "cannot be null").getTicks() - tick);
  }
  ```
    ]]>
  </code>
</response>
```
---Response.<init>---
Response created:
public long since(final long tick) {
      return toMilliseconds(NullabilityUtil.castToNonnull(Game.loop(), "cannot be null").getTicks() - tick);
  }
---ChatGPT.fixDereferenceByAddingCastToNonnull---
Fixing the error by adding castToNonnull
---AdvancedNullAwayCodeFix.fixTriggeredErrorsForLocation---
Resolving unresolvable error for triggered error: Type='DEREFERENCE_NULLABLE', message='dereferenced expression Game.loop() is @Nullable'
/home/nima/Developer/nullness-benchmarks/litiengine/src/de/gurkenlabs/litiengine/environment/EntitySpawner.java:173
          Game.loop()
---AdvancedNullAwayCodeFix.fix---
Fixing error: Type='DEREFERENCE_NULLABLE', message='dereferenced expression Game.loop() is @Nullable'
/home/nima/Developer/nullness-benchmarks/litiengine/src/de/gurkenlabs/litiengine/environment/EntitySpawner.java:173
          Game.loop()
---AdvancedNullAwayCodeFix.resolveDereferenceError---
Resolving dereference error: Type='DEREFERENCE_NULLABLE', message='dereferenced expression Game.loop() is @Nullable'
/home/nima/Developer/nullness-benchmarks/litiengine/src/de/gurkenlabs/litiengine/environment/EntitySpawner.java:173
          Game.loop()
---AdvancedNullAwayCodeFix.resolveDereferenceError---
Checking nullability possibility at error point
---ChatGPT.checkNullabilityPossibilityAtErrorPoint---
Asking if the expression can be null at error point point
---ChatGPT.ask---
Asking ChatGPT:
In the method below, is there a possibility that the expression "Game.loop()" at line "Game.loop()" is null?
protected void spawnNewEntities() {
    if (this.getSpawnMode() != SpawnMode.CUSTOMSPAWNPOINTS && this.getSpawnPoints().isEmpty()) {
      return;
    }

    switch (this.getSpawnMode()) {
      case ALLSPAWNPOINTS:
        for (int i = 0; i < this.getSpawnPoints().size(); i++) {
          final int index = i;
          Game.loop()
              .perform(
                  this.getSpawnDelay() + this.getSpawnDelay() * i,
                  () -> this.spawn(this.getSpawnPoints().get(index), this.getSpawnAmount()));
        }
        break;
      case ONERANDOMSPAWNPOINT:
        this.spawn(Game.random().choose(this.getSpawnPoints()), this.getSpawnAmount());
        break;
      case RANDOMSPAWNPOINTS:
        for (int i = 0; i < this.getSpawnAmount(); i++) {
          Game.loop()
              .perform(
                  this.getSpawnDelay() + this.getSpawnDelay() * i,
                  () -> this.spawn(Game.random().choose(this.getSpawnPoints()), 1));
        }
        break;
      case CUSTOMSPAWNPOINTS:
        List<Spawnpoint> spawnPoints =
            this.customSpawnpoints != null
                ? this.customSpawnpoints.apply(this)
                : this.getCustomSpawnpoints();

        int index = 0;
        for (Spawnpoint spawn : spawnPoints) {
          Game.loop()
              .perform(
                  this.getSpawnDelay() + this.getSpawnDelay() * index, () -> this.spawn(spawn, 1));
          index++;
        }
        break;
      default:
        break;
    }
}
Give a single-word answer in XML format. If it is possible for the expression to be null, respond with:
```xml
<response>
    <reason><![CDATA[YOUR REASON]]></reason>
    <value>YES</value>
</response>
```
If it is not possible for the expression to be null, respond with:
```xml
<response>
    <reason><![CDATA[YOUR REASON]]></reason>
    <value>NO</value>
</response>
```
If you are unsure or need more information, respond with where you can ask for more details or what specific information you need.

If additional information is required, list each request inside a `<request>` tag. If no additional information is needed, omit the `<requests>` section.

Respond with:
```xml
<response>
    <reason><![CDATA[YOUR REASON]]></reason>
    <value>UNKNOWN</value>
    <!-- Include <requests> only if additional information is needed -->
    <requests>
        <request><![CDATA[YOUR REQUEST 1]]></request>
        <request><![CDATA[YOUR REQUEST 2]]></request>
    </requests>
</response>
```
---ChatGPT.sendRequestToOpenAI---
Retrieving response from cache
---Response.<init>---
Creating Response:
```xml
<response>
    <reason><![CDATA[The possibility of "Game.loop()" being null depends on how it is implemented and initialized elsewhere in the code. Without access to the implementation details or specifications of the Game class, it is uncertain if "Game.loop()" could be null.]]></reason>
    <value>UNKNOWN</value>
    <requests>
        <request><![CDATA[Provide the implementation or initialization details of the "Game.loop()" method.]]></request>
        <request><![CDATA[Clarify if there are any guarantees or constraints regarding the non-null status of "Game.loop()".]]></request>
    </requests>
</response>
```
---Response.<init>---
Response created:
Unknown: The possibility of "Game.loop()" being null depends on how it is implemented and initialized elsewhere in the code. Without access to the implementation details or specifications of the Game class, it is uncertain if "Game.loop()" could be null.
---AdvancedNullAwayCodeFix.resolveMethodDereferenceError---
Resolving method dereference error.
---AdvancedNullAwayCodeFix.resolveMethodDereferenceError---
Method is in annotated package. Checking if the method is returning nullable.
---AdvancedNullAwayCodeFix.investigateMethodReturnNullability---
Checking if the method is returning nullable.
---ChatGPT.checkIfMethodIsReturningNullable---
Asking if the method is returning nullable: loop()
---ChatGPT.ask---
Asking ChatGPT:
In the method below, is there a possibility that the method returns null based only on its body? Consider the following points:

- The method may have multiple return paths; consider all return statements.
- If the method calls another method, do not assume its return value unless its full declaration is provided. Request its declaration if needed.
- The method may throw an exception instead of returning null. An exception path should not be considered a null return.
- Ensure you request the declarations of any methods whose return values directly or indirectly impact this method’s return value before making a conclusion.
- Carefully analyze all conditions and prior operations that may guarantee a non-null return value.

@Nullable public static IGameLoop loop() {
    return gameLoop;
}

Here are the method definitions in addition to the method inquired:

Depth: 0
```java
class de.gurkenlabs.litiengine.Game {
@Nullable public static IGameLoop loop() {
    return gameLoop;
}
}
```


Response Format:
Provide the answer in **XML format** as follows:

#### If the method **cannot** return `null`:
```xml
<response>
  <reason><![CDATA[EXPLAIN WHY THE METHOD CANNOT RETURN NULL]]></reason>
  <value>NO</value>
</response>
```

#### If the method can return null:
```xml
<response>
  <reason><![CDATA[EXPLAIN WHY THE METHOD CAN RETURN NULL]]></reason>
  <value>YES</value>
</response>
```

#### If you are unsure or need more information, respond with where you can ask for more details or what specific information you need.

#### If you are unsure or If there are any methods that directly or indirectly affect the return value and are not fully disclosed, request their declarations first, in the following format:
<response>
  <reason><![CDATA[YOUR REASON]]></reason>
  <value>UNKNOWN</value>
  <methods>
    <method>methodName</method>
  </methods>
</response>

If additional information is required other than method declaration, list each request inside a `<request>` tag. If no additional information is needed, omit the `<requests>` section.

Respond with:
```xml
<response>
    <reason><![CDATA[YOUR REASON]]></reason>
    <value>UNKNOWN</value>
    <!-- Include <requests> only if additional information is needed -->
    <requests>
        <request><![CDATA[YOUR REQUEST 1]]></request>
        <request><![CDATA[YOUR REQUEST 2]]></request>
    </requests>
</response>
```

Additional Notes:
Be precise in your reasoning.
If a method’s return value depends on another method not provided, request its declaration before making a conclusion.
If the method can return null in some cases but not others, explain under what conditions it can happen.

---ChatGPT.sendRequestToOpenAI---
Retrieving response from cache
---Response.<init>---
Creating Response:
```xml
<response>
  <reason><![CDATA[The method `loop` returns the variable `gameLoop`. Without the initialization or assignment details of `gameLoop`, it's unclear whether it can be null. The possibility of `gameLoop` being uninitialized or set to null elsewhere in the program means `loop` could potentially return null. Further information on `gameLoop` is required.]]></reason>
  <value>UNKNOWN</value>
  <requests>
    <request><![CDATA[Please provide the declaration and initialization of the variable `gameLoop` in the class `de.gurkenlabs.litiengine.Game`.]]></request>
  </requests>
</response>
```
---Response.<init>---
Response created:
Unknown: The method `loop` returns the variable `gameLoop`. Without the initialization or assignment details of `gameLoop`, it's unclear whether it can be null. The possibility of `gameLoop` being uninitialized or set to null elsewhere in the program means `loop` could potentially return null. Further information on `gameLoop` is required.
---AdvancedNullAwayCodeFix.investigateMethodReturnNullability---
Could not determine the nullability and model did not ask for any method.
---ChatGPT.checkIfMethodIsReturningNullableOnCallSite---
Asking if the method is returning nullable on the call site: Game.loop()
---ChatGPT.ask---
Asking ChatGPT:
In the method below, is there a possibility that the method returns null at the given call site?

```java
@Nullable public static IGameLoop loop() {
    return gameLoop;
}
```

## Guidelines:
- The method may have multiple return paths; consider all return statements.
- If the method calls another method, do not assume its return value unless its full declaration is provided. Request its declaration if needed.
- The method may throw an exception instead of returning null. An exception path should not be considered a null return.
- Ensure you request the declarations of any methods whose return values directly or indirectly impact this method’s return value before making a conclusion.
- If the method returns a value that is determined by a parameter, evaluate based on the actual argument at the given call site.
- Analyze based only on the specific invocation provided. Do not generalize to all possible inputs.- If the return value is guaranteed to be non-null at the call site, the answer should be a definitive NO.
- Do not generalize based on all possible inputs—your answer must be based only on the given invocation.
- Focus only on the given call site, not all possible invocations.

### call site:
Game.loop()

Here are the method definitions and the call chain for this method, showing the sequence of calls from the method to its callers at each depth level:

Depth: 0
```java
class de.gurkenlabs.litiengine.Game {
@Nullable public static IGameLoop loop() {
    return gameLoop;
}
}
```
Depth: 1
```java
class de.gurkenlabs.litiengine.environment.GameWorld {
public void loadEnvironment(@Nullable final Environment env) {
    Lock lock = Game.loop().getLock();
    lock.lock();
    try {
      unloadEnvironment();
      this.environment = env;
      if (env != null) {
        this.addEnvironment(env);

        if (env.getGravity() == 0 && this.gravity() != 0) {
          env.setGravity(this.gravity());
        }

        env.load();
        for (final EnvironmentLoadedListener listener : this.loadedListeners) {
          listener.loaded(env);
        }

        // call map specific listeners
        String mapName = getMapName(env);
        if (mapName != null && this.environmentLoadedListeners.containsKey(mapName)) {

          // for the default camera we center the camera on the environment
          if (this.camera().getClass().equals(Camera.class)) {
            camera().setFocus(env.getCenter());
          }

          for (EnvironmentLoadedListener listener : this.environmentLoadedListeners.get(mapName)) {
            listener.loaded(env);
          }
        }
      }
    } finally {
      lock.unlock();
    }
}public void setCamera(@Nullable final ICamera cam) {
    if (this.camera() != null) {
      Game.loop().detach(camera);
    }

    camera = cam;

    if (cam != null && !Game.isInNoGUIMode()) {
      Game.loop().attach(cam);
      cam.updateFocus();
    }
}
}
```
```java
class de.gurkenlabs.litiengine.entities.behavior.EntityNavigator {
public EntityNavigator(final IMobileEntity entity, final PathFinder pathFinder) {
    this.cancelNavigationConditions = new CopyOnWriteArrayList<>();
    this.listeners = new CopyOnWriteArrayList<>();
    this.entity = entity;
    this.pathFinder = pathFinder;
    this.setAcceptableError(DEFAULT_ACCEPTABLE_ERROR);
    Game.loop().attach(this);
}
}
```
```java
class de.gurkenlabs.litiengine.GameWindow {
private static void initializeWindowEventListeners(Window window) {

    window.addWindowStateListener(
        e -> {
          if (e.getNewState() == Frame.ICONIFIED) {
            Game.loop().setTickRate(ICONIFIED_MAX_FPS);
          } else {
            Game.loop().setTickRate(Game.config().client().getMaxFps());
          }
        });

    window.addWindowFocusListener(
        new WindowFocusListener() {
          @Override
          public void windowLostFocus(WindowEvent e) {
            if (Game.config().graphics().reduceFramesWhenNotFocused()) {
              Game.loop().setTickRate(NONE_FOCUS_MAX_FPS);
            }
          }

          @Override
          public void windowGainedFocus(WindowEvent e) {
            Game.loop().setTickRate(Game.config().client().getMaxFps());
          }
        });

    window.addWindowListener(
        new WindowAdapter() {
          @Override
          public void windowClosing(final WindowEvent event) {
            Game.exit();
          }
        });
}
}
```
```java
class de.gurkenlabs.litiengine.gui.screens.ScreenManager {
public void display(@Nullable final Screen screen) {
    if (Game.hasStarted() && Game.time().since(this.lastScreenChange) < this.getChangeCooldown()) {
      log.log(
          Level.INFO,
          "Skipping displaying of screen {0} because screen changing is currently on cooldown.",
          screen != null ? screen.getName() : "");
      return;
    }

    final Screen previous = this.current();
    if (previous != null) {
      previous.suspend();
    }

    if (screen != null && !this.screens.contains(screen)) {
      this.screens.add(screen);
    }

    this.currentScreen = screen;
    if (!Game.isInNoGUIMode() && this.current() != null) {
      this.current().prepare();
    }

    this.lastScreenChange = Game.loop().getTicks();

    final ScreenChangedEvent event = new ScreenChangedEvent(this.current(), previous);
    for (final ScreenChangedListener listener : this.screenChangedListeners) {
      listener.changed(event);
    }
}
}
```
```java
class de.gurkenlabs.litiengine.abilities.effects.Effect {
@Override
  public void update() {

    for (final Iterator<EffectApplication> iterator = this.getActiveAppliances().iterator();
        iterator.hasNext(); ) {
      final EffectApplication appliance = iterator.next();
      // if the effect duration is reached
      if (this.hasEnded(appliance)) {

        iterator.remove();
        this.cease(appliance);
      }
    }

    // 4. unregister if all appliances are finished
    if (this.getActiveAppliances().isEmpty()) {
      Game.loop().detach(this);
    }
}public void apply(final Shape impactArea) {
    final List<ICombatEntity> affected = this.lookForAffectedEntities(impactArea);
    for (final ICombatEntity affectedEntity : affected) {
      this.apply(affectedEntity);
    }

    this.appliances.add(new EffectApplication(affected, impactArea));

    // if it is the first appliance -> register for update
    if (this.appliances.size() == 1) {
      Game.loop().attach(this);
    }
}
}
```
```java
class de.gurkenlabs.litiengine.GameTime {
public long toTicks(final int milliseconds) {
    return this.toTicks(milliseconds, Game.loop().getTickRate());
}public long since(final long tick) {
    return toMilliseconds(Game.loop().getTicks() - tick);
}public long now() {
    return Game.loop().getTicks();
}public long sinceGameStart() {
    return this.toMilliseconds(Game.loop().getTicks());
}@Override
  public void loaded(Environment environment) {
    environmentLoaded = Game.loop().getTicks();
}public long toMilliseconds(final long ticks) {
    return this.toMilliseconds(ticks, Game.loop().getTickRate());
}
}
```
```java
class de.gurkenlabs.litiengine.GameMetrics {
@Override
  public void render(final Graphics2D g) {
    this.updateMetrics();

    if (!Game.config().client().showGameMetrics()) {
      return;
    }

    this.currentOffsetY = 0;

    g.setColor(this.renderColor);

    // render client metrics
    this.drawTitle(g, "[client]");
    this.drawMetric(g, "fps       : " + this.getFramesPerSecond());
    this.drawMetric(g, "max fps   : " + this.maxFramesPerSecond);
    this.drawMetric(g, "updatables: " + Game.loop().getUpdatableCount());

    // render jvm metrics if debug is enabled
    if (Game.config().debug().isDebugEnabled()) {
      this.drawTitle(g, "[jvm]");
      this.drawMetric(g, "java      : " + this.javaVersion);
      this.drawMetric(g, "memory    : " + String.format("%-5.5s", this.usedMemory) + " MB");
      this.drawMetric(g, "threads   : " + Thread.activeCount());
    }

    // render rendering metrics
    if (!this.renderMetrics.isEmpty()) {
      this.drawTitle(g, "[update]");

      for (RenderMetrics metric : this.renderMetrics) {
        this.drawMetric(g, metric.toString());
      }

      this.renderMetrics.clear();
    }
}
}
```
```java
class de.gurkenlabs.litiengine.graphics.emitters.Emitter {
public void deactivate() {
    if (!this.activated) {
      return;
    }

    this.activated = false;
    this.getParticles().clear();
    this.aliveTime = 0;
    this.activationTick = 0;
    this.lastSpawn = 0;
    Game.loop().detach(this);
}public void activate() {
    if (this.activated) {
      return;
    }

    this.activated = true;
    this.activationTick = Game.time().now();
    Game.loop().attach(this);
}@Override
  public void update() {
    if (this.isPaused()) {
      return;
    }

    // clear particles if the effect time to life is reached
    if (this.isFinished()) {
      for (EmitterFinishedListener listener : this.finishedListeners) {
        listener.finished(this);
      }

      this.delete();
      return;
    }

    final float updateRatio = (float) this.data().getUpdateRate() / Game.loop().getTickRate();
    for (final Particle p : this.getParticles().stream().collect(Collectors.toList())) {
      if (this.particleCanBeRemoved(p)) {
        // remove dead particles
        this.particles.remove(p);
        continue;
      }

      p.update(this.getOrigin(), updateRatio);
    }

    this.aliveTime = Game.time().since(this.activationTick);
    if ((this.data().getSpawnRate() == 0
        || Game.time().since(this.lastSpawn) >= this.data().getSpawnRate())) {
      this.lastSpawn = Game.time().now();
      this.spawnParticle();
    }
}
}
```
```java
class de.gurkenlabs.litiengine.entities.behavior.IBehaviorController {
public default void attach() {
    Game.loop().attach(this);
}public default void detach() {
    Game.loop().detach(this);
}
}
```
```java
class de.gurkenlabs.litiengine.abilities.AbilityExecution {
AbilityExecution(final Ability ability) {
    this.appliedEffects = new CopyOnWriteArrayList<>();
    this.ability = ability;
    this.executionTicks = Game.time().now();
    this.impactArea = ability.calculateImpactArea();
    this.castLocation = ability.getExecutor().getCenter();
    Game.loop().attach(this);
}@Override
  public void update() {
    // if there a no effects to apply -> unregister this instance and we're done
    if (this.getAbility().getEffects().isEmpty()
        || this.getAbility().getEffects().size() == this.getAppliedEffects().size()) {
      Game.loop().detach(this);
      return;
    }

    // handle all effects from the ability that were not applied yet
    for (final Effect effect : this.getAbility().getEffects()) {
      // if the ability was not executed yet or the delay of the effect is not
      // yet reached
      if (this.getAppliedEffects().contains(effect)
          || Game.time().since(this.getExecutionTicks()) < effect.getDelay()) {
        continue;
      }

      effect.apply(this.getExecutionImpactArea());
      this.getAppliedEffects().add(effect);
    }
}
}
```
```java
class de.gurkenlabs.litiengine.GameWindow$3 {
@Override
          public void windowGainedFocus(WindowEvent e) {
            Game.loop().setTickRate(Game.config().client().getMaxFps());
}@Override
          public void windowLostFocus(WindowEvent e) {
            if (Game.config().graphics().reduceFramesWhenNotFocused()) {
              Game.loop().setTickRate(NONE_FOCUS_MAX_FPS);
            }
}
}
```
```java
class de.gurkenlabs.litiengine.environment.EntitySpawner {
protected void spawnNewEntities() {
    if (this.getSpawnMode() != SpawnMode.CUSTOMSPAWNPOINTS && this.getSpawnPoints().isEmpty()) {
      return;
    }

    switch (this.getSpawnMode()) {
      case ALLSPAWNPOINTS:
        for (int i = 0; i < this.getSpawnPoints().size(); i++) {
          final int index = i;
          Game.loop()
              .perform(
                  this.getSpawnDelay() + this.getSpawnDelay() * i,
                  () -> this.spawn(this.getSpawnPoints().get(index), this.getSpawnAmount()));
        }
        break;
      case ONERANDOMSPAWNPOINT:
        this.spawn(Game.random().choose(this.getSpawnPoints()), this.getSpawnAmount());
        break;
      case RANDOMSPAWNPOINTS:
        for (int i = 0; i < this.getSpawnAmount(); i++) {
          Game.loop()
              .perform(
                  this.getSpawnDelay() + this.getSpawnDelay() * i,
                  () -> this.spawn(Game.random().choose(this.getSpawnPoints()), 1));
        }
        break;
      case CUSTOMSPAWNPOINTS:
        List<Spawnpoint> spawnPoints =
            this.customSpawnpoints != null
                ? this.customSpawnpoints.apply(this)
                : this.getCustomSpawnpoints();

        int index = 0;
        for (Spawnpoint spawn : spawnPoints) {
          Game.loop()
              .perform(
                  this.getSpawnDelay() + this.getSpawnDelay() * index, () -> this.spawn(spawn, 1));
          index++;
        }
        break;
      default:
        break;
    }
}
}
```
```java
class de.gurkenlabs.litiengine.tweening.TweenEngine {
@Override
  public void start() {
    Game.loop().attach(this);
}@Override
  public void terminate() {
    Game.loop().detach(this);
}
}
```
```java
class de.gurkenlabs.litiengine.gui.SpeechBubble {
public void hide() {
    Game.world().environment().removeRenderable(this);
    Game.loop().detach(this);
    if (activeSpeechBubbles.get(this.getEntity()) != null
        && activeSpeechBubbles.remove(this.getEntity()).equals(this)) {
      activeSpeechBubbles.remove(this.getEntity());
    }

    for (SpeechBubbleListener listener : this.listeners) {
      listener.hidden();
    }
}private SpeechBubble(
      final IEntity entity,
      final String text,
      @Nullable SpeechBubbleAppearance appearance,
      @Nullable Font font) {
    if (appearance == null) {
      this.appearance = DEFAULT_APPEARANCE;
    } else {
      this.appearance = appearance;
    }

    final SpeechBubble active = activeSpeechBubbles.get(entity);
    if (active != null) {
      active.hide();
    }
    this.setFont(font);

    this.textBoxWidth = (float) (entity.getWidth() * 4);
    this.entity = entity;

    this.currentText = text;
    this.currentTextDisplayTime = DISPLAYTIME_MIN + text.length() * DISPLAYTIME_PER_LETTER;

    this.lastTextDisplay = Game.time().now();
    this.createBubbleImage();
    entity.getEnvironment().add(this, RenderType.UI);
    Game.loop().attach(this);
    activeSpeechBubbles.put(entity, this);
}
}
```
```java
class de.gurkenlabs.litiengine.entities.Prop {
private void updateAnimationController() {
    IEntityAnimationController<?> controller = this.createAnimationController();
    this.getControllers().addController(controller);
    if (Game.world().environment() != null && Game.world().environment().isLoaded()) {
      Game.loop().attach(controller);
    }
}
}
```
```java
class de.gurkenlabs.litiengine.graphics.FreeFlightCamera {
public FreeFlightCamera(final Point2D focus) {
    this.setFocus(focus);
    this.velocity = DEFAULT_SCROLL_PIXELS_PER_SECOND;
    this.scrollPadding = DEFAULT_SCROLL_PADDING;
    this.setClampToMap(true);

    Game.loop().attach(this);
}private void handleFreeFlightCamera() {
    if (Game.world().environment() == null || Game.world().environment().getMap() == null) {
      return;
    }

    final Point2D mouseLocation = Input.mouse().getLocation();

    final double scrollSpeed =
        this.getVelocity()
            / (double) Game.loop().getTickRate()
            * Game.config().input().getMouseSensitivity();

    double x = this.getFocus().getX();
    double y = this.getFocus().getY();

    double deltaX = 0;
    if (mouseLocation.getX() < this.getScrollPadding()) {
      deltaX -= scrollSpeed;
    } else if (Game.window().getResolution().getWidth() - mouseLocation.getX()
        < this.getScrollPadding()) {
      deltaX += scrollSpeed;
    }

    double deltaY = 0;
    if (mouseLocation.getY() < this.getScrollPadding()) {
      deltaY -= scrollSpeed;
    } else if (Game.window().getResolution().getHeight() - mouseLocation.getY()
        < this.getScrollPadding()) {
      deltaY += scrollSpeed;
    }

    x += deltaX;
    y += deltaY;

    this.setFocus(new Point2D.Double(x, y));
}
}
```
```java
class de.gurkenlabs.litiengine.environment.Environment {
private static void dispose(final Collection<? extends IEntity> entities) {
    for (final IEntity entity : entities) {
      if (entity instanceof IUpdateable) {
        Game.loop().detach((IUpdateable) entity);
      }

      entity.detachControllers();
    }
}private static void loadUpdatableOrEmitterEntity(IEntity entity) {
    if (entity instanceof Emitter) {
      final Emitter emitter = (Emitter) entity;
      if (emitter.isActivateOnInit()) {
        emitter.activate();
      }
    } else if (entity instanceof IUpdateable) {
      Game.loop().attach((IUpdateable) entity);
    }
}private void unload(final IEntity entity) {
    // 1. remove from physics engine
    if (entity instanceof ICollisionEntity) {
      Game.physics().remove((ICollisionEntity) entity);
    }

    // 2. unregister from update
    if (entity instanceof IUpdateable) {
      Game.loop().detach((IUpdateable) entity);
    }

    if (entity instanceof IMobileEntity) {
      this.removeGravity((IMobileEntity) entity);
    }

    // 3. detach all controllers
    entity.detachControllers();

    if (entity instanceof Emitter) {
      Emitter em = (Emitter) entity;
      em.deactivate();
    }

    if (this.loaded && (entity instanceof LightSource || entity instanceof StaticShadow)) {
      this.updateLighting(entity);
    }

    entity.removed(this);
}
}
```
```java
class de.gurkenlabs.litiengine.graphics.animation.Animation {
@Override
  public void update() {
    // do nothing if the animation is not playing or the current keyframe is not finished
    if (!this.isPlaying()
        || Game.time().since(this.lastFrameUpdate) < this.getCurrentKeyFrame().getDuration()) {
      return;
    }

    // if we are not looping and the last keyframe is finished, we terminate the animation
    if (!this.isLooping() && this.isLastKeyFrame()) {
      this.terminate();
      return;
    }

    // make sure, we stay inside the keyframe list
    final int newFrameIndex =
        (this.getKeyframes().indexOf(this.currentFrame) + 1) % this.getKeyframes().size();
    final KeyFrame previousFrame = this.currentFrame;
    this.currentFrame = this.getKeyframes().get(newFrameIndex);

    for (KeyFrameListener listener : this.listeners) {
      listener.currentFrameChanged(previousFrame, this.currentFrame);
    }

    this.lastFrameUpdate = Game.loop().getTicks();
}public void restart() {
    this.currentFrame = this.firstFrame;
    this.lastFrameUpdate = Game.loop().getTicks();
}
}
```
```java
class de.gurkenlabs.litiengine.physics.MovementController {
@Override
  public void attach() {
    Game.loop().attach(this);
}private void handleForces() {
    // clean up forces
    this.activeForces.forEach(
        x -> {
          if (x.hasEnded()) {
            this.activeForces.remove(x);
          }
        });

    if (this.activeForces.isEmpty()) {
      return;
    }

    // disable turn-on-move for force handling
    boolean turn = this.getEntity().turnOnMove();
    this.getEntity().setTurnOnMove(false);
    try {
      double deltaX = 0;
      double deltaY = 0;
      for (final Force force : this.activeForces) {
        if (force.cancelOnReached() && force.hasReached(this.getEntity())) {
          force.end();
          continue;
        }

        final Point2D collisionBoxCenter = this.getEntity().getCollisionBoxCenter();
        final double angle =
            GeometricUtilities.calcRotationAngleInDegrees(collisionBoxCenter, force.getLocation());
        final double strength =
            Game.loop().getDeltaTime() * 0.001f * force.getStrength() * Game.loop().getTimeScale();
        deltaX += GeometricUtilities.getDeltaX(angle, strength);
        deltaY += GeometricUtilities.getDeltaY(angle, strength);
      }

      final Point2D target =
          new Point2D.Double(this.getEntity().getX() + deltaX, this.getEntity().getY() + deltaY);
      final boolean success = Game.physics().move(this.getEntity(), target);
      if (!success) {
        for (final Force force : this.activeForces) {
          if (force.cancelOnCollision()) {
            force.end();
          }
        }
      }
    } finally {
      this.getEntity().setTurnOnMove(turn);
    }
}@Override
  public void detach() {
    Game.loop().detach(this);
}public void handleMovement() {
    if (!this.isMovementAllowed()) {
      this.velocity = 0;
      return;
    }

    // max distance an entity can travel within one tick
    final double maxPixelsPerTick = this.getEntity().getTickVelocity();
    final double deltaTime = Game.loop().getDeltaTime() * Game.loop().getTimeScale();

    final double acceleration =
        this.getEntity().getAcceleration() == 0
            ? maxPixelsPerTick
            : deltaTime / this.getEntity().getAcceleration() * maxPixelsPerTick;
    final double deceleration =
        this.getEntity().getDeceleration() == 0
            ? this.getVelocity()
            : deltaTime / this.getEntity().getDeceleration() * maxPixelsPerTick;

    double dx = this.getDx();
    double dy = this.getDy();
    this.setDx(0);
    this.setDy(0);

    final double deltaVelocity =
        Math.min(Math.sqrt(Math.pow(dx, 2) + Math.pow(dy, 2)), acceleration);
    if (deltaVelocity != 0) {
      double newVelocity = this.getVelocity() + deltaVelocity;
      this.setVelocity(newVelocity);
    } else {
      final double newVelocity = Math.max(0, this.getVelocity() - deceleration);
      this.setVelocity(newVelocity);
      dx = GeometricUtilities.getDeltaX(this.moveAngle);
      dy = GeometricUtilities.getDeltaY(this.moveAngle);
    }

    if (this.getVelocity() == 0) {
      this.moveAngle = 0;
      return;
    }

    // actually move entity
    this.moveEntity(dx, dy);
}
}
```
```java
class de.gurkenlabs.litiengine.graphics.animation.AnimationController {
public void detach() {
    Game.loop().detach(this);
}public void attach() {
    Game.loop().attach(this);
}
}
```
```java
class de.gurkenlabs.litiengine.graphics.Camera {
@Override
  public void setZoom(final float targetZoom, final int delay) {
    if (delay == 0) {

      this.zoom = targetZoom;
      this.targetZoom = 0;
      this.zoomDelay = 0;
      this.zoomTick = 0;
      this.zoomStep = 0;

      final ZoomChangedEvent event = new ZoomChangedEvent(this, targetZoom);
      for (final ZoomChangedListener listener : this.zoomListeners) {
        listener.zoomChanged(event);
      }
    } else {
      this.zoomTick = Game.time().now();
      this.targetZoom = targetZoom;
      this.zoomDelay = delay;

      final double tickduration = 1000 / (double) Game.loop().getTickRate();
      final double tickAmount = delay / tickduration;
      final float totalDelta = this.targetZoom - this.zoom;
      this.zoomStep = tickAmount > 0 ? (float) (totalDelta / tickAmount) : totalDelta;
    }
}
}
```
```java
class de.gurkenlabs.litiengine.Game {
public static synchronized void init(String... args) {
    if (initialized) {
      log().log(Level.INFO, "The game has already been initialized.");
      return;
    }

    log.init();
    handleCommandLineArguments(args);

    config().load();
    Locale.setDefault(new Locale(config().client().getCountry(), config().client().getLanguage()));

    gameLoop = new GameLoop("Main Update Loop", config().client().getMaxFps());
    loop().attach(physics());
    loop().attach(world());

    // setup default exception handling for render and update loop
    setUncaughtExceptionHandler(
        new DefaultUncaughtExceptionHandler(config().client().exitOnError()));

    screenManager = new ScreenManager();
    gameWindow = new GameWindow();

    // initialize  the game window
    window().init();
    world.setCamera(new Camera());

    for (GameListener listener : gameListeners) {
      listener.initialized(args);
    }

    if (!isInNoGUIMode()) {
      window().getRenderComponent().onRendered(g -> metrics().render(g));

      graphics()
          .addEntityRenderedListener(
              e -> DebugRenderer.renderEntityDebugInfo(e.getGraphics(), e.getEntity()));

      window().getRenderComponent().onFpsChanged(fps -> metrics().setFramesPerSecond(fps));
      window()
          .setIcons(
              Arrays.asList(
                  Resources.images().get("liti-logo-x16.png"),
                  Resources.images().get("liti-logo-x20.png"),
                  Resources.images().get("liti-logo-x32.png"),
                  Resources.images().get("liti-logo-x48.png")));

      Input.keyboard()
          .onKeyTyped(
              KeyEvent.VK_PRINTSCREEN,
              key -> {
                // don't take a screenshot if a modifier is active
                if (key.getModifiers() != 0) {
                  return;
                }

                window().getRenderComponent().takeScreenshot();
              });
    }

    Runtime.getRuntime().addShutdownHook(new Thread(Game::terminate, "Shutdown"));

    initialized = true;
}
}
```
```java
class de.gurkenlabs.litiengine.entities.Creature {
protected void updateAnimationController() {
    IEntityAnimationController<?> controller = this.createAnimationController();
    this.getControllers().addController(controller);
    if (Game.world().environment() != null && Game.world().environment().isLoaded()) {
      Game.loop().attach(controller);
    }
}@Override
  public float getTickVelocity() {
    // pixels per ms multiplied by the passed ms
    // ensure that entities don't travel too far in case of lag
    return Math.min(Game.loop().getDeltaTime(), GameLoop.TICK_DELTATIME_LAG)
        * 0.001F
        * this.getVelocity().get()
        * Game.loop().getTimeScale();
}
}
```
Depth: 2
```java
class de.gurkenlabs.litiengine.environment.GameWorld {
public void clear() {
    this.unloadEnvironment();
    this.environments.clear();
    this.setCamera(null);
    Game.physics().clear();

    this.environmentListeners.clear();
    this.environmentLoadedListeners.clear();
    this.environmentUnloadedListeners.clear();

    this.listeners.clear();
    this.loadedListeners.clear();
    this.unloadedListeners.clear();
}@Nullable
  public Environment loadEnvironment(IMap map) {
    Environment env = this.getEnvironment(map);
    this.loadEnvironment(env);
    return env;
}@Nullable
  public Environment loadEnvironment(String mapName) {
    Environment env = this.getEnvironment(mapName);
    this.loadEnvironment(env);
    return env;
}
}
```
```java
class de.gurkenlabs.litiengine.GameWindow {
GameWindow() {
    this.hostControl = new JFrame();

    this.resolutionChangedListeners = new CopyOnWriteArrayList<>();

    this.renderCanvas = new RenderComponent(Game.config().graphics().getResolution());
    this.cursor = new MouseCursor();
    if (!Game.isInNoGUIMode()) {
      this.hostControl.setBackground(Color.BLACK);
      this.hostControl.add(this.renderCanvas);

      this.initializeEventListeners();

      this.hostControl.setTitle(Game.info().getTitle());
      this.hostControl.setDefaultCloseOperation(WindowConstants.DO_NOTHING_ON_CLOSE);
      initializeWindowEventListeners(this.hostControl);
    }
}
}
```
```java
class de.gurkenlabs.litiengine.GameTime {
public long sinceEnvironmentLoad() {
    return this.since(this.environmentLoaded);
}public long since(final long tick) {
    return toMilliseconds(Game.loop().getTicks() - tick);
}public long sinceGameStart() {
    return this.toMilliseconds(Game.loop().getTicks());
}
}
```
```java
class de.gurkenlabs.litiengine.abilities.effects.Effect {
protected void cease(final EffectApplication appliance) {
    // 1. cease the effect for all affected entities
    for (final ICombatEntity entity : appliance.getAffectedEntities()) {
      this.cease(entity);
    }

    // 2. apply follow up effects
    this.getFollowUpEffects().forEach(followUp -> followUp.apply(appliance.getImpactArea()));
}protected boolean hasEnded(final EffectApplication appliance) {
    final long effectDuration = Game.time().since(appliance.getAppliedTicks());
    return effectDuration > this.getDuration();
}
}
```
```java
class de.gurkenlabs.litiengine.abilities.effects.EffectApplication {
protected EffectApplication(final List<ICombatEntity> affectedEntities, final Shape impactArea) {
    this.applied = Game.time().now();
    this.affectedEntities = affectedEntities;
    this.impactArea = impactArea;
}
}
```
```java
class de.gurkenlabs.litiengine.entities.CombatEntity {
@Override
  public boolean wasHit(int timeSpan) {
    return Game.time().since(this.lastHit) < timeSpan;
}@Override
  public void hit(final int damage, @Nullable final Ability ability) {
    if (this.isDead()) {
      return;
    }

    if (!this.isIndestructible()) {
      this.getHitPoints().modifyBaseValue(new AttributeModifier<>(Modification.SUBTRACT, damage));
    }

    final EntityHitEvent event = new EntityHitEvent(this, ability, damage, this.isDead());

    for (final CombatEntityListener listener : this.listeners) {
      listener.hit(event);
    }

    for (final CombatEntityHitListener listener : this.hitListeners) {
      listener.hit(event);
    }

    if (this.isDead()) {
      this.fireDeathEvent();
      this.setCollision(false);
    }

    this.lastHit = Game.time().now();
}
}
```
```java
class de.gurkenlabs.litiengine.graphics.ImageEffect {
protected ImageEffect(final int ttl, final String name) {
    this.ttl = ttl;
    this.name = name;
    this.aliveTick = Game.time().now();
}@Override
  public long getAliveTime() {
    return Game.time().since(this.aliveTick);
}
}
```
```java
class de.gurkenlabs.litiengine.abilities.AbilityExecution {
AbilityExecution(final Ability ability) {
    this.appliedEffects = new CopyOnWriteArrayList<>();
    this.ability = ability;
    this.executionTicks = Game.time().now();
    this.impactArea = ability.calculateImpactArea();
    this.castLocation = ability.getExecutor().getCenter();
    Game.loop().attach(this);
}@Override
  public void update() {
    // if there a no effects to apply -> unregister this instance and we're done
    if (this.getAbility().getEffects().isEmpty()
        || this.getAbility().getEffects().size() == this.getAppliedEffects().size()) {
      Game.loop().detach(this);
      return;
    }

    // handle all effects from the ability that were not applied yet
    for (final Effect effect : this.getAbility().getEffects()) {
      // if the ability was not executed yet or the delay of the effect is not
      // yet reached
      if (this.getAppliedEffects().contains(effect)
          || Game.time().since(this.getExecutionTicks()) < effect.getDelay()) {
        continue;
      }

      effect.apply(this.getExecutionImpactArea());
      this.getAppliedEffects().add(effect);
    }
}
}
```
```java
class de.gurkenlabs.litiengine.tweening.TweenEngine {
@Override
  public void update() {
    for (final Tweenable target : this.getTweens().keySet()) {
      for (final Tween tween : this.getTweens().get(target).values()) {
        if (tween.hasStopped()) {
          continue;
        }
        final long elapsed = Game.time().since(tween.getStartTime());
        if (elapsed >= tween.getDuration()) {
          tween.stop();
          continue;
        }
        final float[] currentValues = new float[tween.getTargetValues().length];
        for (int i = 0; i < tween.getTargetValues().length; i++) {
          currentValues[i] =
              tween.getStartValues()[i]
                  + tween.getEquation().compute(elapsed / (float) tween.getDuration())
                      * (tween.getTargetValues()[i] - tween.getStartValues()[i]);
        }
        tween.getTarget().setTweenValues(tween.getType(), currentValues);
      }
    }
}
}
```
```java
class de.gurkenlabs.litiengine.gui.SpeechBubble {
public static SpeechBubble create(
      final IEntity entity, final String text, SpeechBubbleAppearance appearance, Font font) {
    return new SpeechBubble(entity, text, appearance, font);
}public static SpeechBubble create(final IEntity entity, final Font font, final String text) {
    SpeechBubbleAppearance app =
        new SpeechBubbleAppearance(
            DEFAULT_APPEARANCE.getForeColor(),
            DEFAULT_APPEARANCE.getBackgroundColor1(),
            DEFAULT_APPEARANCE.getBorderColor(),
            DEFAULT_APPEARANCE.getPadding());
    return new SpeechBubble(entity, text, app, font);
}public static SpeechBubble create(final IEntity entity, final String text) {
    return new SpeechBubble(entity, text, null, GuiProperties.getDefaultFont());
}@Override
  public void update() {
    if (this.currentText == null) {
      this.hide();
      return;
    }

    this.entityCenter = Game.world().camera().getViewportLocation(this.getEntity().getCenter());

    // old text was displayed long enough
    if (this.lastTextDisplay != 0
        && Game.time().since(this.lastTextDisplay) > this.currentTextDisplayTime) {
      this.currentText = null;
      this.lastTextDisplay = 0;
      return;
    }

    // display new text
    if (this.textIndex < this.currentText.length()
        && Game.time().since(this.lastCharPoll) > LETTER_WRITE_DELAY) {
      this.textIndex++;
      this.lastCharPoll = Game.time().now();
      if (this.typeSound != null) {
        Game.audio().playSound(this.typeSound, this.getEntity());
      }
    }

    // continue displaying currently displayed text
}private SpeechBubble(
      final IEntity entity,
      final String text,
      final Sound typeSound,
      SpeechBubbleAppearance appearance,
      Font font) {
    this(entity, text, appearance, font);
    this.typeSound = typeSound;
}private SpeechBubble(
      final IEntity entity,
      final String text,
      @Nullable SpeechBubbleAppearance appearance,
      @Nullable Font font) {
    if (appearance == null) {
      this.appearance = DEFAULT_APPEARANCE;
    } else {
      this.appearance = appearance;
    }

    final SpeechBubble active = activeSpeechBubbles.get(entity);
    if (active != null) {
      active.hide();
    }
    this.setFont(font);

    this.textBoxWidth = (float) (entity.getWidth() * 4);
    this.entity = entity;

    this.currentText = text;
    this.currentTextDisplayTime = DISPLAYTIME_MIN + text.length() * DISPLAYTIME_PER_LETTER;

    this.lastTextDisplay = Game.time().now();
    this.createBubbleImage();
    entity.getEnvironment().add(this, RenderType.UI);
    Game.loop().attach(this);
    activeSpeechBubbles.put(entity, this);
}
}
```
```java
class de.gurkenlabs.litiengine.gui.TextFieldComponent {
@Override
  public void render(final Graphics2D g) {
    super.render(g);
    g.setFont(this.getFont());
    final FontMetrics fm = g.getFontMetrics();

    if (this.isSelected() && Game.time().since(this.lastToggled) > this.flickerDelay) {
      this.cursorVisible = !this.cursorVisible;
      this.lastToggled = Game.time().now();
    }
    if (this.isSelected() && this.cursorVisible) {
      final Rectangle2D cursor =
          new Rectangle2D.Double(
              this.getX() + this.getTextX() + fm.stringWidth(this.getTextToRender(g)),
              this.getY() + this.getTextY(),
              this.getFont().getSize2D() * 3 / 5,
              this.getFont().getSize2D() * 1 / 5);
      g.setColor(this.getAppearance().getForeColor());
      g.fill(cursor);
    }
}
}
```
```java
class de.gurkenlabs.litiengine.entities.Prop {
public Prop(
      final Point2D location, @Nullable final String spritesheetName, final Material material) {
    super();
    this.rotation = Rotation.NONE;
    this.spritesheetName = spritesheetName;
    this.material = material;
    this.setLocation(location);
    this.updateAnimationController();
}public void setSpritesheetName(@Nullable final String spriteName) {
    this.spritesheetName = spriteName;
    this.updateAnimationController();
}
}
```
```java
class de.gurkenlabs.litiengine.tweening.Tween {
public Tween begin() {
    this.started = Game.time().now();
    this.stopped = false;
    return this;
}
}
```
```java
class de.gurkenlabs.litiengine.graphics.emitters.particles.Particle {
public void update(final Point2D emitterOrigin, final float updateRatio) {
    if (this.aliveTick == 0) {
      this.aliveTick = Game.time().now();
    }

    this.aliveTime = Game.time().since(this.aliveTick);
    if (this.timeToLiveReached()) {
      return;
    }

    if (this.colliding) {
      return;
    }

    if (this.getDeltaWidth() != 0) {
      this.width += this.getDeltaWidth() * updateRatio;
    }

    if (this.getDeltaHeight() != 0) {
      this.height += this.getDeltaHeight() * updateRatio;
    }

    if (this.getDeltaAngle() != 0) {
      this.angle += this.getDeltaAngle() * updateRatio;
    }

    // test for ray cast collision
    final float targetX = this.x + this.getVelocityX() * updateRatio;
    final float targetY = this.y + this.getVelocityY() * updateRatio;

    if (targetX == this.x && targetY == this.y) {
      return;
    }

    if (this.checkForCollision(emitterOrigin, targetX, targetY)) {
      return;
    }

    if (this.getVelocityX() != 0) {
      this.x = targetX;
    }

    if (this.getVelocityY() != 0) {
      this.y = targetY;
    }

    if (this.getAccelerationX() != 0) {
      this.velocityX += this.getAccelerationX() * updateRatio;
    }

    if (this.getAccelerationY() != 0) {
      this.velocityY += this.getAccelerationY() * updateRatio;
    }
}
}
```
```java
class de.gurkenlabs.litiengine.graphics.animation.Animation {
@Override
  public void start() {
    this.playing = true;
    if (this.getKeyframes().isEmpty()) {
      return;
    }

    this.restart();
}@Override
  public void update() {
    // do nothing if the animation is not playing or the current keyframe is not finished
    if (!this.isPlaying()
        || Game.time().since(this.lastFrameUpdate) < this.getCurrentKeyFrame().getDuration()) {
      return;
    }

    // if we are not looping and the last keyframe is finished, we terminate the animation
    if (!this.isLooping() && this.isLastKeyFrame()) {
      this.terminate();
      return;
    }

    // make sure, we stay inside the keyframe list
    final int newFrameIndex =
        (this.getKeyframes().indexOf(this.currentFrame) + 1) % this.getKeyframes().size();
    final KeyFrame previousFrame = this.currentFrame;
    this.currentFrame = this.getKeyframes().get(newFrameIndex);

    for (KeyFrameListener listener : this.listeners) {
      listener.currentFrameChanged(previousFrame, this.currentFrame);
    }

    this.lastFrameUpdate = Game.loop().getTicks();
}
}
```
```java
class de.gurkenlabs.litiengine.graphics.animation.AnimationController {
@Override
  public void update() {
    for (final Animation animation : this.getAll()) {
      animation.update();
    }

    if (this.getCurrent() != null && this.getCurrent().isPaused()) {
      return;
    }

    final boolean playbackFinished = this.getCurrent() != null && !this.getCurrent().isPlaying();
    if (playbackFinished) {
      for (final AnimationListener listener : this.listeners) {
        listener.finished(this.getCurrent());
      }
    }

    if (this.getCurrent() == null || playbackFinished) {
      if (this.getDefault() != null) {
        this.play(this.getDefault().getName());
      } else {
        this.currentAnimation = null;
      }
    }
}
}
```
```java
class de.gurkenlabs.litiengine.graphics.RenderComponent {
private void handleFade() {
    if (this.fadeOutStart != -1) {
      final long timePassed = Game.time().since(this.fadeOutStart);
      this.currentAlpha = MathUtilities.clamp(1 - timePassed / (float) this.fadeOutTime, 0, 1);
      if (this.currentAlpha == 0f) {
        this.fadeOutStart = -1;
        this.fadeOutTime = -1;
      }

      return;
    }

    if (this.fadeInStart != -1) {
      final long timePassed = Game.time().since(this.fadeInStart);
      this.currentAlpha = MathUtilities.clamp(timePassed / (float) this.fadeInTime, 0, 1);
      if (this.currentAlpha == 1f) {
        this.fadeInStart = -1;
        this.fadeInTime = -1;
        this.currentAlpha = Float.NaN;
      }
    }
}public void fadeOut(final int ms) {
    this.fadeInStart = -1;
    this.fadeInTime = -1;
    this.fadeOutStart = Game.time().now();
    this.fadeOutTime = ms;
}public void fadeIn(final int ms) {
    this.fadeOutStart = -1;
    this.fadeOutTime = -1;
    this.fadeInStart = Game.time().now();
    this.fadeInTime = ms;
}
}
```
```java
class de.gurkenlabs.litiengine.entities.Trigger {
private boolean activate(final IEntity activator, final int tar) {
    if (!this.isLoaded()
        || this.isOneTimeTrigger && this.isActivated
        || this.getActivationType() == TriggerActivation.COLLISION
            && activator != null
            && this.collisionActivated.contains(activator)) {
      return false;
    }

    if (this.getCooldown() > 0 && Game.time().since(this.lastActivation) < this.getCooldown()) {
      return false;
    }

    List<Integer> triggerTargets = this.getTargets(tar);

    final TriggerEvent te = new TriggerEvent(this, activator, triggerTargets);

    if (!this.checkActivationPredicates(te)) {
      return false;
    }

    this.isActivated = true;
    if (activator != null) {
      this.collisionActivated.add(activator);
    }

    // if we actually have a trigger target, we send the message to the target
    for (final int target : triggerTargets) {
      final IEntity entity = this.getEnvironment().get(target);
      if (entity == null) {
        log.log(
            Level.WARNING,
            "trigger [{0}] was activated, but the trigger target [{1}] could not be found on the environment",
            new Object[] {this, target});
        continue;
      }

      entity.sendMessage(this, this.message);
    }

    // also send the trigger event to all registered consumers
    for (final TriggerActivatedListener listener : this.activatedListeners) {
      listener.activated(te);
    }

    if (this.isOneTimeTrigger) {
      this.getEnvironment().remove(this);
    }

    this.lastActivation = Game.time().now();
    return true;
}
}
```
```java
class de.gurkenlabs.litiengine.graphics.Camera {
private boolean isShakeEffectActive() {
    return this.getShakeTick() != 0
        && Game.time().since(this.getShakeTick()) < this.getShakeDuration();
}@Override
  public void update() {
    if (Game.world().camera() != null && !Game.world().camera().equals(this)) {
      return;
    }

    if (this.targetZoom > 0) {
      if (Game.time().since(this.zoomTick) >= this.zoomDelay) {
        this.zoom = this.targetZoom;
        this.targetZoom = 0;
        this.zoomDelay = 0;
        this.zoomTick = 0;
        this.zoomStep = 0;
      } else {
        this.zoom += this.zoomStep;
      }

      final ZoomChangedEvent event = new ZoomChangedEvent(this, this.getZoom());
      for (final ZoomChangedListener listener : this.zoomListeners) {
        listener.zoomChanged(event);
      }
    }

    if (this.panTime > 0) {
      if (--this.panTime <= 0) {
        this.setFocus(this.targetFocus);
        this.targetFocus = null;
      } else {
        double diff = this.panTime / (this.panTime + 1.0);
        this.focus =
            new Point2D.Double(
                this.focus.getX() * diff + this.targetFocus.getX() * (1.0 - diff),
                this.focus.getY() * diff + this.targetFocus.getY() * (1.0 - diff));
      }
    }

    if (!this.isShakeEffectActive()) {
      this.shakeOffsetX = 0;
      this.shakeOffsetY = 0;
      return;
    }

    if (Game.time().since(this.lastShake) > this.shakeDelay) {
      this.shakeOffsetX = this.getShakeIntensity() * ThreadLocalRandom.current().nextGaussian();
      this.shakeOffsetY = this.getShakeIntensity() * ThreadLocalRandom.current().nextGaussian();
      this.lastShake = Game.time().now();
    }
}@Override
  public void setZoom(final float targetZoom, final int delay) {
    if (delay == 0) {

      this.zoom = targetZoom;
      this.targetZoom = 0;
      this.zoomDelay = 0;
      this.zoomTick = 0;
      this.zoomStep = 0;

      final ZoomChangedEvent event = new ZoomChangedEvent(this, targetZoom);
      for (final ZoomChangedListener listener : this.zoomListeners) {
        listener.zoomChanged(event);
      }
    } else {
      this.zoomTick = Game.time().now();
      this.targetZoom = targetZoom;
      this.zoomDelay = delay;

      final double tickduration = 1000 / (double) Game.loop().getTickRate();
      final double tickAmount = delay / tickduration;
      final float totalDelta = this.targetZoom - this.zoom;
      this.zoomStep = tickAmount > 0 ? (float) (totalDelta / tickAmount) : totalDelta;
    }
}@Override
  public void shake(final double intensity, final int delay, final int shakeDuration) {
    this.shakeTick = Game.time().now();
    this.shakeDelay = delay;
    this.shakeIntensity = intensity;
    this.shakeDuration = shakeDuration;
}
}
```
```java
class de.gurkenlabs.litiengine.entities.Creature {
public void setSpritesheetName(String spritesheetName) {
    if (this.spritesheetName != null && this.spritesheetName.equals(spritesheetName)) {
      return;
    }

    this.spritesheetName = spritesheetName;
    this.updateAnimationController();
}public boolean isIdle() {
    return Game.time().since(this.lastMoved) > IDLE_DELAY;
}@Override
  public void setLocation(final Point2D position) {
    if (this.isDead() || position == null) {
      return;
    }

    final Point2D oldLocation = this.getLocation();
    super.setLocation(position);

    if (Game.hasStarted() && this.isLoaded()) {
      this.lastMoved = Game.time().now();
      this.fireMovedEvent(
          new EntityMovedEvent(
              this, this.getX() - oldLocation.getX(), this.getY() - oldLocation.getY()));
    }
}
}
```
```java
class de.gurkenlabs.litiengine.gui.screens.ScreenManager {
public void display(final String screenName) {
    if (this.current() != null && this.current().getName().equalsIgnoreCase(screenName)) {
      log.log(
          Level.INFO,
          "Skipping displaying of screen {0} because it is already the current screen.",
          screenName);
      return;
    }

    if (this.screens.stream()
        .noneMatch(element -> element.getName().equalsIgnoreCase(screenName))) {
      log.log(
          Level.WARNING,
          "Could not display the screen {0} because there is no screen with the specified name.",
          screenName);
      return;
    }

    Screen screen = this.get(screenName);
    if (screen == null) {
      return;
    }

    this.display(screen);
}public void add(final Screen screen) {
    screen.setWidth(Game.window().getWidth());
    screen.setHeight(Game.window().getHeight());
    this.screens.add(screen);

    if (this.current() == null) {
      this.display(screen);
    }
}public void remove(Screen screen) {
    this.screens.remove(screen);
    if (this.current() == screen) {
      if (!this.screens.isEmpty()) {
        this.display(this.screens.get(0));
      } else {
        this.display((Screen) null);
      }
    }
}public void display(@Nullable final Screen screen) {
    if (Game.hasStarted() && Game.time().since(this.lastScreenChange) < this.getChangeCooldown()) {
      log.log(
          Level.INFO,
          "Skipping displaying of screen {0} because screen changing is currently on cooldown.",
          screen != null ? screen.getName() : "");
      return;
    }

    final Screen previous = this.current();
    if (previous != null) {
      previous.suspend();
    }

    if (screen != null && !this.screens.contains(screen)) {
      this.screens.add(screen);
    }

    this.currentScreen = screen;
    if (!Game.isInNoGUIMode() && this.current() != null) {
      this.current().prepare();
    }

    this.lastScreenChange = Game.loop().getTicks();

    final ScreenChangedEvent event = new ScreenChangedEvent(this.current(), previous);
    for (final ScreenChangedListener listener : this.screenChangedListeners) {
      listener.changed(event);
    }
}
}
```
```java
class de.gurkenlabs.litiengine.abilities.Ability {
public boolean isOnCooldown() {
    return (this.getCurrentExecution() != null
        && this.getCurrentExecution().getExecutionTicks() > 0
        && Game.time().since(this.getCurrentExecution().getExecutionTicks())
            < this.getAttributes().cooldown().get());
}public boolean isActive() {
    return this.getCurrentExecution() != null
        && Game.time().since(this.getCurrentExecution().getExecutionTicks())
            < this.getAttributes().duration().get();
}@Nullable
  public AbilityExecution cast() {
    if (!this.canCast()) {
      return null;
    }
    this.currentExecution = new AbilityExecution(this);

    for (final AbilityCastListener listener : this.abilityCastListeners) {
      listener.abilityCast(this.currentExecution);
    }

    return this.getCurrentExecution();
}public float getRemainingCooldownInSeconds() {
    if (this.getCurrentExecution() == null
        || this.getExecutor() == null
        || this.getExecutor().isDead()) {
      return 0;
    }

    // calculate cooldown in seconds
    return (float)
        (!this.canCast()
            ? (this.getAttributes().cooldown().get()
                    - Game.time().since(this.getCurrentExecution().getExecutionTicks()))
                * 0.001
            : 0);
}
}
```
```java
class de.gurkenlabs.litiengine.entities.EntityHitEvent {
EntityHitEvent(
      final ICombatEntity hitEntity,
      @Nullable final Ability ability,
      final int damage,
      final boolean kill) {
    super(hitEntity);
    this.executor = ability != null ? ability.getExecutor() : null;
    this.hitEntity = hitEntity;
    this.ability = ability;
    this.damage = damage;
    this.kill = kill;
    this.time = Game.time().now();
}
}
```
```java
class de.gurkenlabs.litiengine.graphics.emitters.Emitter {
public void delete() {
    this.deactivate();
    if (Game.world().environment() != null) {
      Game.world().environment().remove(this);
    }
}public void activate() {
    if (this.activated) {
      return;
    }

    this.activated = true;
    this.activationTick = Game.time().now();
    Game.loop().attach(this);
}@Override
  public void update() {
    if (this.isPaused()) {
      return;
    }

    // clear particles if the effect time to life is reached
    if (this.isFinished()) {
      for (EmitterFinishedListener listener : this.finishedListeners) {
        listener.finished(this);
      }

      this.delete();
      return;
    }

    final float updateRatio = (float) this.data().getUpdateRate() / Game.loop().getTickRate();
    for (final Particle p : this.getParticles().stream().collect(Collectors.toList())) {
      if (this.particleCanBeRemoved(p)) {
        // remove dead particles
        this.particles.remove(p);
        continue;
      }

      p.update(this.getOrigin(), updateRatio);
    }

    this.aliveTime = Game.time().since(this.activationTick);
    if ((this.data().getSpawnRate() == 0
        || Game.time().since(this.lastSpawn) >= this.data().getSpawnRate())) {
      this.lastSpawn = Game.time().now();
      this.spawnParticle();
    }
}
}
```
```java
class de.gurkenlabs.litiengine.GameLoop {
@Override
  public int perform(int delay, Runnable action) {
    final long d = Game.time().toTicks(delay);

    TimedAction a = new TimedAction(this.getTicks() + d, action);
    this.actions.add(a);

    return a.getId();
}
}
```
```java
class de.gurkenlabs.litiengine.environment.EntitySpawner {
protected boolean shouldSpawn() {
    return this.lastSpawnWave == 0
        || Game.time().since(this.lastSpawnWave) >= this.getSpawnInterval();
}@Override
  public void update() {
    if (!this.shouldSpawn()) {
      return;
    }

    this.spawnNewEntities();
    this.lastSpawnWave = Game.time().now();
}
}
```
```java
class de.gurkenlabs.litiengine.graphics.FreeFlightCamera {
@Override
  public void update() {
    this.handleFreeFlightCamera();
}public FreeFlightCamera(double x, double y) {
    this(new Point2D.Double(x, y));
}
}
```
```java
class de.gurkenlabs.litiengine.environment.Environment {
public void unload() {
    if (!this.loaded) {
      return;
    }

    // unregister all updatable entities from the current environment
    for (final IEntity entity : this.allEntities.values()) {
      this.unload(entity);
    }

    this.loaded = false;
    this.fireEvent(l -> l.unloaded(this));
}private static void loadUpdatableOrEmitterEntity(IEntity entity) {
    if (entity instanceof Emitter) {
      final Emitter emitter = (Emitter) entity;
      if (emitter.isActivateOnInit()) {
        emitter.activate();
      }
    } else if (entity instanceof IUpdateable) {
      Game.loop().attach((IUpdateable) entity);
    }
}public void clear() {
    Game.physics().clear();

    this.combatEntities.clear();
    this.mobileEntities.clear();
    this.gravityForces.clear();
    this.layerEntities.clear();
    this.entitiesByTag.clear();
    this.allEntities.clear();

    for (RenderType renderType : RenderType.values()) {
      this.miscEntities.get(renderType).clear();
      this.renderListeners.get(renderType).clear();
      this.renderables.get(renderType).clear();
    }

    dispose(this.allEntities.values());
    dispose(this.triggers);
    this.emitters.clear();
    this.colliders.clear();
    this.props.clear();
    this.creatures.clear();
    this.staticShadows.clear();
    this.combatEntities.clear();
    this.mobileEntities.clear();
    this.lightSources.clear();
    this.spawnPoints.clear();
    this.soundSources.clear();
    this.mapAreas.clear();
    this.triggers.clear();

    this.ambientLight = null;
    this.staticShadowLayer = null;

    for (Map<Integer, IEntity> type : this.miscEntities.values()) {
      type.clear();
    }

    this.initialized = false;

    this.fireEvent(l -> l.cleared(this));
}private void load(final IEntity entity) {
    // an entity can only exist on one environment at a time, so remove it from the current one
    if (entity.getEnvironment() != null) {
      entity.getEnvironment().remove(entity);
    }

    // 1. add to physics engine
    loadPhysicsEntity(entity);

    // 2. register for update or activate
    loadUpdatableOrEmitterEntity(entity);

    // 3. if a gravity is defined, add a gravity force to the entity
    if (entity instanceof IMobileEntity && this.getGravity() != 0) {
      this.addGravityForce((IMobileEntity) entity);
    }

    // 4. attach all controllers
    entity.attachControllers();

    if (this.loaded && (entity instanceof LightSource || entity instanceof StaticShadow)) {
      this.updateLighting(entity);
    }

    entity.loaded(this);
}private void unload(final IEntity entity) {
    // 1. remove from physics engine
    if (entity instanceof ICollisionEntity) {
      Game.physics().remove((ICollisionEntity) entity);
    }

    // 2. unregister from update
    if (entity instanceof IUpdateable) {
      Game.loop().detach((IUpdateable) entity);
    }

    if (entity instanceof IMobileEntity) {
      this.removeGravity((IMobileEntity) entity);
    }

    // 3. detach all controllers
    entity.detachControllers();

    if (entity instanceof Emitter) {
      Emitter em = (Emitter) entity;
      em.deactivate();
    }

    if (this.loaded && (entity instanceof LightSource || entity instanceof StaticShadow)) {
      this.updateLighting(entity);
    }

    entity.removed(this);
}public void remove(final IEntity entity) {
    if (entity == null) {
      return;
    }

    this.allEntities.remove(entity.getMapId());
    Iterator<List<IEntity>> iter = this.layerEntities.values().iterator();
    while (iter.hasNext()) {
      List<IEntity> layer = iter.next();
      if (layer.remove(entity) && layer.isEmpty()) {
        iter.remove();
      }
    }
    if (this.miscEntities.get(entity.getRenderType()) != null) {
      this.miscEntities.get(entity.getRenderType()).values().remove(entity);
    }

    for (String tag : entity.getTags()) {
      if (this.getEntitiesByTag().containsKey(tag)) {
        this.getEntitiesByTag().get(tag).remove(entity);

        if (this.getEntitiesByTag().get(tag).isEmpty()) {
          this.getEntitiesByTag().remove(tag);
        }
      }
    }

    if (entity instanceof Emitter) {
      Emitter emitter = (Emitter) entity;
      this.removeEmitter(emitter);
    }

    if (entity instanceof MapArea) {
      this.mapAreas.remove(entity);
    }

    if (entity instanceof Prop) {
      this.props.remove(entity);
    }

    if (entity instanceof Creature) {
      this.creatures.remove(entity);
    }

    if (entity instanceof CollisionBox) {
      this.colliders.remove(entity);
      this.staticShadows.removeIf(x -> x.getOrigin() != null && x.getOrigin().equals(entity));
    }

    if (entity instanceof LightSource) {
      this.lightSources.remove(entity);
      this.updateLighting(entity);
    }

    if (entity instanceof Trigger) {
      this.triggers.remove(entity);
    }

    if (entity instanceof Spawnpoint) {
      this.spawnPoints.remove(entity);
    }
    if (entity instanceof SoundSource) {
      this.soundSources.remove(entity);
    }

    if (entity instanceof StaticShadow) {
      this.staticShadows.remove(entity);
      this.updateLighting(entity);
    }

    if (entity instanceof IMobileEntity) {
      this.mobileEntities.values().remove(entity);
    }

    if (entity instanceof ICombatEntity) {
      this.combatEntities.values().remove(entity);
    }

    this.unload(entity);

    this.fireEntityEvent(l -> l.entityRemoved(entity));
}
}
```
```java
class de.gurkenlabs.litiengine.physics.MovementController {
@Override
  public void update() {
    this.handleForces();
    this.handleMovement();
}
}
```
```java
class de.gurkenlabs.litiengine.Game {
static synchronized void terminate() {
    if (!initialized) {
      return;
    }

    hasStarted = false;
    initialized = false;

    config().save();
    gameLoop.terminate();
    tweenEngine.terminate();
    soundEngine.terminate();

    world().clear();

    for (final GameListener listener : gameListeners) {
      try {
        listener.terminated();
      } catch (Exception e) {
        log().log(Level.WARNING, "game listener threw an exception during shutdown", e);
      }
    }

    gameLoop = null;
    screenManager = null;
    gameWindow = null;
}public static synchronized void start() {
    if (!initialized) {
      throw new IllegalStateException(
          "The game cannot be started without being first initialized. Call Game.init(...) before Game.start().");
    }

    gameLoop.start();
    tweenEngine.start();
    soundEngine.start();

    for (final GameListener listener : gameListeners) {
      listener.started();
    }

    hasStarted = true;
}public static synchronized void init(String... args) {
    if (initialized) {
      log().log(Level.INFO, "The game has already been initialized.");
      return;
    }

    log.init();
    handleCommandLineArguments(args);

    config().load();
    Locale.setDefault(new Locale(config().client().getCountry(), config().client().getLanguage()));

    gameLoop = new GameLoop("Main Update Loop", config().client().getMaxFps());
    loop().attach(physics());
    loop().attach(world());

    // setup default exception handling for render and update loop
    setUncaughtExceptionHandler(
        new DefaultUncaughtExceptionHandler(config().client().exitOnError()));

    screenManager = new ScreenManager();
    gameWindow = new GameWindow();

    // initialize  the game window
    window().init();
    world.setCamera(new Camera());

    for (GameListener listener : gameListeners) {
      listener.initialized(args);
    }

    if (!isInNoGUIMode()) {
      window().getRenderComponent().onRendered(g -> metrics().render(g));

      graphics()
          .addEntityRenderedListener(
              e -> DebugRenderer.renderEntityDebugInfo(e.getGraphics(), e.getEntity()));

      window().getRenderComponent().onFpsChanged(fps -> metrics().setFramesPerSecond(fps));
      window()
          .setIcons(
              Arrays.asList(
                  Resources.images().get("liti-logo-x16.png"),
                  Resources.images().get("liti-logo-x20.png"),
                  Resources.images().get("liti-logo-x32.png"),
                  Resources.images().get("liti-logo-x48.png")));

      Input.keyboard()
          .onKeyTyped(
              KeyEvent.VK_PRINTSCREEN,
              key -> {
                // don't take a screenshot if a modifier is active
                if (key.getModifiers() != 0) {
                  return;
                }

                window().getRenderComponent().takeScreenshot();
              });
    }

    Runtime.getRuntime().addShutdownHook(new Thread(Game::terminate, "Shutdown"));

    initialized = true;
}
}
```


Response Format:
Provide the answer in **XML format** as follows:

#### If the method **cannot** return `null` at the specific call site:
```xml
<response>
  <reason><![CDATA[EXPLAIN WHY THE INVOCATION Game.loop() RESULT CANNOT BE NULL.]]></reason>
  <value>NO</value>
</response>

#### If the method can return null at the specific call site:
<response>
  <reason><![CDATA[EXPLAIN WHY THE INVOCATION Game.loop() RESULT CAN BE NULL.]]></reason>
  <value>YES</value>
</response>

#### If you are unsure or If there are any methods that directly or indirectly affect the return value and are not fully disclosed, request their declarations first, in the following format:
<response>
  <reason><![CDATA[EXPLAIN WHY THIS METHOD DECLARATION IS NECESSARY AND WHY YOU CANNOT MAKE A CONFIDENT DECISION WITHOUT IT]]></reason>
  <success>false</success>
  <methods>
    <method>methodName</method>
  </methods>
</response>

Additional Notes:
Be precise in your reasoning.
If a method’s return value depends on another method not provided, request its declaration before making a conclusion.
If the method can return null in this case but not in others, explain why it happens specifically for this call.

---ChatGPT.sendRequestToOpenAI---
Retrieving response from cache
---Response.<init>---
Creating Response:
```xml
<response>
  <reason><![CDATA[The method `Game.loop()` returns the static field `gameLoop`, which is initialized in the `Game.init(String... args)` method. In this method, a new `GameLoop` object is instantiated and assigned to `gameLoop`. Since `init()` must be called before `start()`, which is implied by the requirement of initializing the game, the `gameLoop` is guaranteed to be non-null during the lifetime of the game execution where `Game.loop()` is called. The absence of any code that could set `gameLoop` to null after its initialization ensures that `Game.loop()` cannot return null.]]></reason>
  <value>NO</value>
</response>
```
---Response.<init>---
Response created:
Disagreement: The method `Game.loop()` returns the static field `gameLoop`, which is initialized in the `Game.init(String... args)` method. In this method, a new `GameLoop` object is instantiated and assigned to `gameLoop`. Since `init()` must be called before `start()`, which is implied by the requirement of initializing the game, the `gameLoop` is guaranteed to be non-null during the lifetime of the game execution where `Game.loop()` is called. The absence of any code that could set `gameLoop` to null after its initialization ensures that `Game.loop()` cannot return null.
---AdvancedNullAwayCodeFix.resolveMethodDereferenceError---
Method is not returning nullable on call site. Injecting suppression annotation.
---AdvancedNullAwayCodeFix.constructCastToNonnullChange---
Constructing cast to nonnull change for reason: The method `Game.loop()` returns the static field `gameLoop`, which is initialized in the `Game.init(String... args)` method. In this method, a new `GameLoop` object is instantiated and assigned to `gameLoop`. Since `init()` must be called before `start()`, which is implied by the requirement of initializing the game, the `gameLoop` is guaranteed to be non-null during the lifetime of the game execution where `Game.loop()` is called. The absence of any code that could set `gameLoop` to null after its initialization ensures that `Game.loop()` cannot return null.
---ChatGPT.ask---
Asking ChatGPT:
For the reason you mentioned earlier:

"The method `Game.loop()` returns the static field `gameLoop`, which is initialized in the `Game.init(String... args)` method. In this method, a new `GameLoop` object is instantiated and assigned to `gameLoop`. Since `init()` must be called before `start()`, which is implied by the requirement of initializing the game, the `gameLoop` is guaranteed to be non-null during the lifetime of the game execution where `Game.loop()` is called. The absence of any code that could set `gameLoop` to null after its initialization ensures that `Game.loop()` cannot return null."

in the method below, the expression Game.loop() is not nullable at the point it is used.

```java
protected void spawnNewEntities() {
    if (this.getSpawnMode() != SpawnMode.CUSTOMSPAWNPOINTS && this.getSpawnPoints().isEmpty()) {
      return;
    }

    switch (this.getSpawnMode()) {
      case ALLSPAWNPOINTS:
        for (int i = 0; i < this.getSpawnPoints().size(); i++) {
          final int index = i;
          Game.loop()
              .perform(
                  this.getSpawnDelay() + this.getSpawnDelay() * i,
                  () -> this.spawn(this.getSpawnPoints().get(index), this.getSpawnAmount()));
        }
        break;
      case ONERANDOMSPAWNPOINT:
        this.spawn(Game.random().choose(this.getSpawnPoints()), this.getSpawnAmount());
        break;
      case RANDOMSPAWNPOINTS:
        for (int i = 0; i < this.getSpawnAmount(); i++) {
          Game.loop()
              .perform(
                  this.getSpawnDelay() + this.getSpawnDelay() * i,
                  () -> this.spawn(Game.random().choose(this.getSpawnPoints()), 1));
        }
        break;
      case CUSTOMSPAWNPOINTS:
        List<Spawnpoint> spawnPoints =
            this.customSpawnpoints != null
                ? this.customSpawnpoints.apply(this)
                : this.getCustomSpawnpoints();

        int index = 0;
        for (Spawnpoint spawn : spawnPoints) {
          Game.loop()
              .perform(
                  this.getSpawnDelay() + this.getSpawnDelay() * index, () -> this.spawn(spawn, 1));
          index++;
        }
        break;
      default:
        break;
    }
}
```
Please Summarize the reason in max 5 words and rewrite the method so that at the line "          Game.loop()", at the occurrence of: "Game.loop()" is replaced with `NullabilityUtil.castToNonnull(Game.loop(), summary of reason)`
Replace "REASON" with the exact reason summary I provide to you (maximum 5 words), not with a generic explanation like "checked to be nonnull".
see the example below, for expression `foo.getBar()`, to wrap it with `NullabilityUtil.castToNonnull(foo.getBar(), "reason")`.

```java
public t(){
    String l = foo.getBar();
}
```

will be:
```java
public t(){
    String l = NullabilityUtil.castToNonnull(foo.getBar(), "checked to be nonnull");
}
```

### Instructions:

Do not import any additional classes.

Do not add Java comments.

Only modify relevant lines as required.

Return only the modified method wrapped in the XML format shown below.

Place the Java code inside the <code> tag using a CDATA block with ```java formatting.

Just give me the fixed code snippet in XML format in <response> tag like the example below. I will apply the fix to my codebase. Do not import any additional libraries or classes or add java comments. If you can provide the fixed code snippet, please provide it in the following format and place the code snippet in the <code> tag within ```java block.
<response>
  <success>true</success>
  <code><![CDATA[
  ```java
  Your fixed code snippet here
  ```
    ]]>
  </code>
</response>

---ChatGPT.sendRequestToOpenAI---
Retrieving response from cache
---Response.<init>---
Creating Response:
<response>
  <success>true</success>
  <code><![CDATA[
  ```java
  protected void spawnNewEntities() {
      if (this.getSpawnMode() != SpawnMode.CUSTOMSPAWNPOINTS && this.getSpawnPoints().isEmpty()) {
        return;
      }
  
      switch (this.getSpawnMode()) {
        case ALLSPAWNPOINTS:
          for (int i = 0; i < this.getSpawnPoints().size(); i++) {
            final int index = i;
            NullabilityUtil.castToNonnull(Game.loop(), "guaranteed to be non-null")
                .perform(
                    this.getSpawnDelay() + this.getSpawnDelay() * i,
                    () -> this.spawn(this.getSpawnPoints().get(index), this.getSpawnAmount()));
          }
          break;
        case ONERANDOMSPAWNPOINT:
          this.spawn(Game.random().choose(this.getSpawnPoints()), this.getSpawnAmount());
          break;
        case RANDOMSPAWNPOINTS:
          for (int i = 0; i < this.getSpawnAmount(); i++) {
            NullabilityUtil.castToNonnull(Game.loop(), "guaranteed to be non-null")
                .perform(
                    this.getSpawnDelay() + this.getSpawnDelay() * i,
                    () -> this.spawn(Game.random().choose(this.getSpawnPoints()), 1));
          }
          break;
        case CUSTOMSPAWNPOINTS:
          List<Spawnpoint> spawnPoints =
              this.customSpawnpoints != null
                  ? this.customSpawnpoints.apply(this)
                  : this.getCustomSpawnpoints();
  
          int index = 0;
          for (Spawnpoint spawn : spawnPoints) {
            NullabilityUtil.castToNonnull(Game.loop(), "guaranteed to be non-null")
                .perform(
                    this.getSpawnDelay() + this.getSpawnDelay() * index, () -> this.spawn(spawn, 1));
            index++;
          }
          break;
        default:
          break;
      }
  }
  ```
    ]]>
  </code>
</response>
---Response.<init>---
Response created:
protected void spawnNewEntities() {
      if (this.getSpawnMode() != SpawnMode.CUSTOMSPAWNPOINTS && this.getSpawnPoints().isEmpty()) {
        return;
      }
  
      switch (this.getSpawnMode()) {
        case ALLSPAWNPOINTS:
          for (int i = 0; i < this.getSpawnPoints().size(); i++) {
            final int index = i;
            NullabilityUtil.castToNonnull(Game.loop(), "guaranteed to be non-null")
                .perform(
                    this.getSpawnDelay() + this.getSpawnDelay() * i,
                    () -> this.spawn(this.getSpawnPoints().get(index), this.getSpawnAmount()));
          }
          break;
        case ONERANDOMSPAWNPOINT:
          this.spawn(Game.random().choose(this.getSpawnPoints()), this.getSpawnAmount());
          break;
        case RANDOMSPAWNPOINTS:
          for (int i = 0; i < this.getSpawnAmount(); i++) {
            NullabilityUtil.castToNonnull(Game.loop(), "guaranteed to be non-null")
                .perform(
                    this.getSpawnDelay() + this.getSpawnDelay() * i,
                    () -> this.spawn(Game.random().choose(this.getSpawnPoints()), 1));
          }
          break;
        case CUSTOMSPAWNPOINTS:
          List<Spawnpoint> spawnPoints =
              this.customSpawnpoints != null
                  ? this.customSpawnpoints.apply(this)
                  : this.getCustomSpawnpoints();
  
          int index = 0;
          for (Spawnpoint spawn : spawnPoints) {
            NullabilityUtil.castToNonnull(Game.loop(), "guaranteed to be non-null")
                .perform(
                    this.getSpawnDelay() + this.getSpawnDelay() * index, () -> this.spawn(spawn, 1));
            index++;
          }
          break;
        default:
          break;
      }
  }
---ChatGPT.fixDereferenceByAddingCastToNonnull---
Fixing the error by adding castToNonnull
---AdvancedNullAwayCodeFix.fixTriggeredErrorsForLocation---
Resolving unresolvable error for triggered error: Type='DEREFERENCE_NULLABLE', message='dereferenced expression Game.loop() is @Nullable'
/home/nima/Developer/nullness-benchmarks/litiengine/src/de/gurkenlabs/litiengine/entities/behavior/IBehaviorController.java:13
    Game.loop().attach(this);
---AdvancedNullAwayCodeFix.fix---
Fixing error: Type='DEREFERENCE_NULLABLE', message='dereferenced expression Game.loop() is @Nullable'
/home/nima/Developer/nullness-benchmarks/litiengine/src/de/gurkenlabs/litiengine/entities/behavior/IBehaviorController.java:13
    Game.loop().attach(this);
---AdvancedNullAwayCodeFix.resolveDereferenceError---
Resolving dereference error: Type='DEREFERENCE_NULLABLE', message='dereferenced expression Game.loop() is @Nullable'
/home/nima/Developer/nullness-benchmarks/litiengine/src/de/gurkenlabs/litiengine/entities/behavior/IBehaviorController.java:13
    Game.loop().attach(this);
---AdvancedNullAwayCodeFix.resolveDereferenceError---
Checking nullability possibility at error point
---ChatGPT.checkNullabilityPossibilityAtErrorPoint---
Asking if the expression can be null at error point point
---ChatGPT.ask---
Asking ChatGPT:
In the method below, is there a possibility that the expression "Game.loop()" at line "Game.loop().attach(this);" is null?
public default void attach() {
    Game.loop().attach(this);
}
Give a single-word answer in XML format. If it is possible for the expression to be null, respond with:
```xml
<response>
    <reason><![CDATA[YOUR REASON]]></reason>
    <value>YES</value>
</response>
```
If it is not possible for the expression to be null, respond with:
```xml
<response>
    <reason><![CDATA[YOUR REASON]]></reason>
    <value>NO</value>
</response>
```
If you are unsure or need more information, respond with where you can ask for more details or what specific information you need.

If additional information is required, list each request inside a `<request>` tag. If no additional information is needed, omit the `<requests>` section.

Respond with:
```xml
<response>
    <reason><![CDATA[YOUR REASON]]></reason>
    <value>UNKNOWN</value>
    <!-- Include <requests> only if additional information is needed -->
    <requests>
        <request><![CDATA[YOUR REQUEST 1]]></request>
        <request><![CDATA[YOUR REQUEST 2]]></request>
    </requests>
</response>
```
---ChatGPT.sendRequestToOpenAI---
Sending request to OpenAI...
---ChatGPT.sendRequestToOpenAI---
Response received from OpenAI.
---Response.<init>---
Creating Response:
```xml
<response>
    <reason><![CDATA[There is insufficient information provided regarding the implementation of Game.loop(), specifically whether it can ever return null.]]></reason>
    <value>UNKNOWN</value>
    <requests>
        <request><![CDATA[Clarification on whether Game.loop() can return null.]]></request>
        <request><![CDATA[Insight into the implementation of the Game class and loop() method.]]></request>
    </requests>
</response>
```
---Response.<init>---
Response created:
Unknown: There is insufficient information provided regarding the implementation of Game.loop(), specifically whether it can ever return null.
---AdvancedNullAwayCodeFix.resolveMethodDereferenceError---
Resolving method dereference error.
---AdvancedNullAwayCodeFix.resolveMethodDereferenceError---
Method is in annotated package. Checking if the method is returning nullable.
---AdvancedNullAwayCodeFix.investigateMethodReturnNullability---
Checking if the method is returning nullable.
---ChatGPT.checkIfMethodIsReturningNullable---
Asking if the method is returning nullable: loop()
---ChatGPT.ask---
Asking ChatGPT:
In the method below, is there a possibility that the method returns null based only on its body? Consider the following points:

- The method may have multiple return paths; consider all return statements.
- If the method calls another method, do not assume its return value unless its full declaration is provided. Request its declaration if needed.
- The method may throw an exception instead of returning null. An exception path should not be considered a null return.
- Ensure you request the declarations of any methods whose return values directly or indirectly impact this method’s return value before making a conclusion.
- Carefully analyze all conditions and prior operations that may guarantee a non-null return value.

@Nullable public static IGameLoop loop() {
    return gameLoop;
}

Here are the method definitions in addition to the method inquired:

Depth: 0
```java
class de.gurkenlabs.litiengine.Game {
@Nullable public static IGameLoop loop() {
    return gameLoop;
}
}
```


Response Format:
Provide the answer in **XML format** as follows:

#### If the method **cannot** return `null`:
```xml
<response>
  <reason><![CDATA[EXPLAIN WHY THE METHOD CANNOT RETURN NULL]]></reason>
  <value>NO</value>
</response>
```

#### If the method can return null:
```xml
<response>
  <reason><![CDATA[EXPLAIN WHY THE METHOD CAN RETURN NULL]]></reason>
  <value>YES</value>
</response>
```

#### If you are unsure or need more information, respond with where you can ask for more details or what specific information you need.

#### If you are unsure or If there are any methods that directly or indirectly affect the return value and are not fully disclosed, request their declarations first, in the following format:
<response>
  <reason><![CDATA[YOUR REASON]]></reason>
  <value>UNKNOWN</value>
  <methods>
    <method>methodName</method>
  </methods>
</response>

If additional information is required other than method declaration, list each request inside a `<request>` tag. If no additional information is needed, omit the `<requests>` section.

Respond with:
```xml
<response>
    <reason><![CDATA[YOUR REASON]]></reason>
    <value>UNKNOWN</value>
    <!-- Include <requests> only if additional information is needed -->
    <requests>
        <request><![CDATA[YOUR REQUEST 1]]></request>
        <request><![CDATA[YOUR REQUEST 2]]></request>
    </requests>
</response>
```

Additional Notes:
Be precise in your reasoning.
If a method’s return value depends on another method not provided, request its declaration before making a conclusion.
If the method can return null in some cases but not others, explain under what conditions it can happen.

---ChatGPT.sendRequestToOpenAI---
Retrieving response from cache
---Response.<init>---
Creating Response:
```xml
<response>
  <reason><![CDATA[The method `loop` returns the variable `gameLoop`. Without the initialization or assignment details of `gameLoop`, it's unclear whether it can be null. The possibility of `gameLoop` being uninitialized or set to null elsewhere in the program means `loop` could potentially return null. Further information on `gameLoop` is required.]]></reason>
  <value>UNKNOWN</value>
  <requests>
    <request><![CDATA[Please provide the declaration and initialization of the variable `gameLoop` in the class `de.gurkenlabs.litiengine.Game`.]]></request>
  </requests>
</response>
```
---Response.<init>---
Response created:
Unknown: The method `loop` returns the variable `gameLoop`. Without the initialization or assignment details of `gameLoop`, it's unclear whether it can be null. The possibility of `gameLoop` being uninitialized or set to null elsewhere in the program means `loop` could potentially return null. Further information on `gameLoop` is required.
---AdvancedNullAwayCodeFix.investigateMethodReturnNullability---
Could not determine the nullability and model did not ask for any method.
---ChatGPT.checkIfMethodIsReturningNullableOnCallSite---
Asking if the method is returning nullable on the call site: Game.loop()
---ChatGPT.ask---
Asking ChatGPT:
In the method below, is there a possibility that the method returns null at the given call site?

```java
@Nullable public static IGameLoop loop() {
    return gameLoop;
}
```

## Guidelines:
- The method may have multiple return paths; consider all return statements.
- If the method calls another method, do not assume its return value unless its full declaration is provided. Request its declaration if needed.
- The method may throw an exception instead of returning null. An exception path should not be considered a null return.
- Ensure you request the declarations of any methods whose return values directly or indirectly impact this method’s return value before making a conclusion.
- If the method returns a value that is determined by a parameter, evaluate based on the actual argument at the given call site.
- Analyze based only on the specific invocation provided. Do not generalize to all possible inputs.- If the return value is guaranteed to be non-null at the call site, the answer should be a definitive NO.
- Do not generalize based on all possible inputs—your answer must be based only on the given invocation.
- Focus only on the given call site, not all possible invocations.

### call site:
Game.loop()

Here are the method definitions and the call chain for this method, showing the sequence of calls from the method to its callers at each depth level:

Depth: 0
```java
class de.gurkenlabs.litiengine.Game {
@Nullable public static IGameLoop loop() {
    return gameLoop;
}
}
```
Depth: 1
```java
class de.gurkenlabs.litiengine.environment.GameWorld {
public void loadEnvironment(@Nullable final Environment env) {
    Lock lock = Game.loop().getLock();
    lock.lock();
    try {
      unloadEnvironment();
      this.environment = env;
      if (env != null) {
        this.addEnvironment(env);

        if (env.getGravity() == 0 && this.gravity() != 0) {
          env.setGravity(this.gravity());
        }

        env.load();
        for (final EnvironmentLoadedListener listener : this.loadedListeners) {
          listener.loaded(env);
        }

        // call map specific listeners
        String mapName = getMapName(env);
        if (mapName != null && this.environmentLoadedListeners.containsKey(mapName)) {

          // for the default camera we center the camera on the environment
          if (this.camera().getClass().equals(Camera.class)) {
            camera().setFocus(env.getCenter());
          }

          for (EnvironmentLoadedListener listener : this.environmentLoadedListeners.get(mapName)) {
            listener.loaded(env);
          }
        }
      }
    } finally {
      lock.unlock();
    }
}public void setCamera(@Nullable final ICamera cam) {
    if (this.camera() != null) {
      Game.loop().detach(camera);
    }

    camera = cam;

    if (cam != null && !Game.isInNoGUIMode()) {
      Game.loop().attach(cam);
      cam.updateFocus();
    }
}
}
```
```java
class de.gurkenlabs.litiengine.entities.behavior.EntityNavigator {
public EntityNavigator(final IMobileEntity entity, final PathFinder pathFinder) {
    this.cancelNavigationConditions = new CopyOnWriteArrayList<>();
    this.listeners = new CopyOnWriteArrayList<>();
    this.entity = entity;
    this.pathFinder = pathFinder;
    this.setAcceptableError(DEFAULT_ACCEPTABLE_ERROR);
    Game.loop().attach(this);
}
}
```
```java
class de.gurkenlabs.litiengine.GameWindow {
private static void initializeWindowEventListeners(Window window) {

    window.addWindowStateListener(
        e -> {
          if (e.getNewState() == Frame.ICONIFIED) {
            Game.loop().setTickRate(ICONIFIED_MAX_FPS);
          } else {
            Game.loop().setTickRate(Game.config().client().getMaxFps());
          }
        });

    window.addWindowFocusListener(
        new WindowFocusListener() {
          @Override
          public void windowLostFocus(WindowEvent e) {
            if (Game.config().graphics().reduceFramesWhenNotFocused()) {
              Game.loop().setTickRate(NONE_FOCUS_MAX_FPS);
            }
          }

          @Override
          public void windowGainedFocus(WindowEvent e) {
            Game.loop().setTickRate(Game.config().client().getMaxFps());
          }
        });

    window.addWindowListener(
        new WindowAdapter() {
          @Override
          public void windowClosing(final WindowEvent event) {
            Game.exit();
          }
        });
}
}
```
```java
class de.gurkenlabs.litiengine.gui.screens.ScreenManager {
public void display(@Nullable final Screen screen) {
    if (Game.hasStarted() && Game.time().since(this.lastScreenChange) < this.getChangeCooldown()) {
      log.log(
          Level.INFO,
          "Skipping displaying of screen {0} because screen changing is currently on cooldown.",
          screen != null ? screen.getName() : "");
      return;
    }

    final Screen previous = this.current();
    if (previous != null) {
      previous.suspend();
    }

    if (screen != null && !this.screens.contains(screen)) {
      this.screens.add(screen);
    }

    this.currentScreen = screen;
    if (!Game.isInNoGUIMode() && this.current() != null) {
      this.current().prepare();
    }

    this.lastScreenChange = Game.loop().getTicks();

    final ScreenChangedEvent event = new ScreenChangedEvent(this.current(), previous);
    for (final ScreenChangedListener listener : this.screenChangedListeners) {
      listener.changed(event);
    }
}
}
```
```java
class de.gurkenlabs.litiengine.abilities.effects.Effect {
@Override
  public void update() {

    for (final Iterator<EffectApplication> iterator = this.getActiveAppliances().iterator();
        iterator.hasNext(); ) {
      final EffectApplication appliance = iterator.next();
      // if the effect duration is reached
      if (this.hasEnded(appliance)) {

        iterator.remove();
        this.cease(appliance);
      }
    }

    // 4. unregister if all appliances are finished
    if (this.getActiveAppliances().isEmpty()) {
      Game.loop().detach(this);
    }
}public void apply(final Shape impactArea) {
    final List<ICombatEntity> affected = this.lookForAffectedEntities(impactArea);
    for (final ICombatEntity affectedEntity : affected) {
      this.apply(affectedEntity);
    }

    this.appliances.add(new EffectApplication(affected, impactArea));

    // if it is the first appliance -> register for update
    if (this.appliances.size() == 1) {
      Game.loop().attach(this);
    }
}
}
```
```java
class de.gurkenlabs.litiengine.GameTime {
public long toTicks(final int milliseconds) {
    return this.toTicks(milliseconds, Game.loop().getTickRate());
}public long since(final long tick) {
    return toMilliseconds(Game.loop().getTicks() - tick);
}public long now() {
    return Game.loop().getTicks();
}public long sinceGameStart() {
    return this.toMilliseconds(Game.loop().getTicks());
}@Override
  public void loaded(Environment environment) {
    environmentLoaded = Game.loop().getTicks();
}public long toMilliseconds(final long ticks) {
    return this.toMilliseconds(ticks, Game.loop().getTickRate());
}
}
```
```java
class de.gurkenlabs.litiengine.GameMetrics {
@Override
  public void render(final Graphics2D g) {
    this.updateMetrics();

    if (!Game.config().client().showGameMetrics()) {
      return;
    }

    this.currentOffsetY = 0;

    g.setColor(this.renderColor);

    // render client metrics
    this.drawTitle(g, "[client]");
    this.drawMetric(g, "fps       : " + this.getFramesPerSecond());
    this.drawMetric(g, "max fps   : " + this.maxFramesPerSecond);
    this.drawMetric(g, "updatables: " + Game.loop().getUpdatableCount());

    // render jvm metrics if debug is enabled
    if (Game.config().debug().isDebugEnabled()) {
      this.drawTitle(g, "[jvm]");
      this.drawMetric(g, "java      : " + this.javaVersion);
      this.drawMetric(g, "memory    : " + String.format("%-5.5s", this.usedMemory) + " MB");
      this.drawMetric(g, "threads   : " + Thread.activeCount());
    }

    // render rendering metrics
    if (!this.renderMetrics.isEmpty()) {
      this.drawTitle(g, "[update]");

      for (RenderMetrics metric : this.renderMetrics) {
        this.drawMetric(g, metric.toString());
      }

      this.renderMetrics.clear();
    }
}
}
```
```java
class de.gurkenlabs.litiengine.graphics.emitters.Emitter {
public void deactivate() {
    if (!this.activated) {
      return;
    }

    this.activated = false;
    this.getParticles().clear();
    this.aliveTime = 0;
    this.activationTick = 0;
    this.lastSpawn = 0;
    Game.loop().detach(this);
}public void activate() {
    if (this.activated) {
      return;
    }

    this.activated = true;
    this.activationTick = Game.time().now();
    Game.loop().attach(this);
}@Override
  public void update() {
    if (this.isPaused()) {
      return;
    }

    // clear particles if the effect time to life is reached
    if (this.isFinished()) {
      for (EmitterFinishedListener listener : this.finishedListeners) {
        listener.finished(this);
      }

      this.delete();
      return;
    }

    final float updateRatio = (float) this.data().getUpdateRate() / Game.loop().getTickRate();
    for (final Particle p : this.getParticles().stream().collect(Collectors.toList())) {
      if (this.particleCanBeRemoved(p)) {
        // remove dead particles
        this.particles.remove(p);
        continue;
      }

      p.update(this.getOrigin(), updateRatio);
    }

    this.aliveTime = Game.time().since(this.activationTick);
    if ((this.data().getSpawnRate() == 0
        || Game.time().since(this.lastSpawn) >= this.data().getSpawnRate())) {
      this.lastSpawn = Game.time().now();
      this.spawnParticle();
    }
}
}
```
```java
class de.gurkenlabs.litiengine.entities.behavior.IBehaviorController {
public default void attach() {
    Game.loop().attach(this);
}public default void detach() {
    Game.loop().detach(this);
}
}
```
```java
class de.gurkenlabs.litiengine.abilities.AbilityExecution {
AbilityExecution(final Ability ability) {
    this.appliedEffects = new CopyOnWriteArrayList<>();
    this.ability = ability;
    this.executionTicks = Game.time().now();
    this.impactArea = ability.calculateImpactArea();
    this.castLocation = ability.getExecutor().getCenter();
    Game.loop().attach(this);
}@Override
  public void update() {
    // if there a no effects to apply -> unregister this instance and we're done
    if (this.getAbility().getEffects().isEmpty()
        || this.getAbility().getEffects().size() == this.getAppliedEffects().size()) {
      Game.loop().detach(this);
      return;
    }

    // handle all effects from the ability that were not applied yet
    for (final Effect effect : this.getAbility().getEffects()) {
      // if the ability was not executed yet or the delay of the effect is not
      // yet reached
      if (this.getAppliedEffects().contains(effect)
          || Game.time().since(this.getExecutionTicks()) < effect.getDelay()) {
        continue;
      }

      effect.apply(this.getExecutionImpactArea());
      this.getAppliedEffects().add(effect);
    }
}
}
```
```java
class de.gurkenlabs.litiengine.GameWindow$3 {
@Override
          public void windowGainedFocus(WindowEvent e) {
            Game.loop().setTickRate(Game.config().client().getMaxFps());
}@Override
          public void windowLostFocus(WindowEvent e) {
            if (Game.config().graphics().reduceFramesWhenNotFocused()) {
              Game.loop().setTickRate(NONE_FOCUS_MAX_FPS);
            }
}
}
```
```java
class de.gurkenlabs.litiengine.environment.EntitySpawner {
protected void spawnNewEntities() {
    if (this.getSpawnMode() != SpawnMode.CUSTOMSPAWNPOINTS && this.getSpawnPoints().isEmpty()) {
      return;
    }

    switch (this.getSpawnMode()) {
      case ALLSPAWNPOINTS:
        for (int i = 0; i < this.getSpawnPoints().size(); i++) {
          final int index = i;
          Game.loop()
              .perform(
                  this.getSpawnDelay() + this.getSpawnDelay() * i,
                  () -> this.spawn(this.getSpawnPoints().get(index), this.getSpawnAmount()));
        }
        break;
      case ONERANDOMSPAWNPOINT:
        this.spawn(Game.random().choose(this.getSpawnPoints()), this.getSpawnAmount());
        break;
      case RANDOMSPAWNPOINTS:
        for (int i = 0; i < this.getSpawnAmount(); i++) {
          Game.loop()
              .perform(
                  this.getSpawnDelay() + this.getSpawnDelay() * i,
                  () -> this.spawn(Game.random().choose(this.getSpawnPoints()), 1));
        }
        break;
      case CUSTOMSPAWNPOINTS:
        List<Spawnpoint> spawnPoints =
            this.customSpawnpoints != null
                ? this.customSpawnpoints.apply(this)
                : this.getCustomSpawnpoints();

        int index = 0;
        for (Spawnpoint spawn : spawnPoints) {
          Game.loop()
              .perform(
                  this.getSpawnDelay() + this.getSpawnDelay() * index, () -> this.spawn(spawn, 1));
          index++;
        }
        break;
      default:
        break;
    }
}
}
```
```java
class de.gurkenlabs.litiengine.tweening.TweenEngine {
@Override
  public void start() {
    Game.loop().attach(this);
}@Override
  public void terminate() {
    Game.loop().detach(this);
}
}
```
```java
class de.gurkenlabs.litiengine.gui.SpeechBubble {
public void hide() {
    Game.world().environment().removeRenderable(this);
    Game.loop().detach(this);
    if (activeSpeechBubbles.get(this.getEntity()) != null
        && activeSpeechBubbles.remove(this.getEntity()).equals(this)) {
      activeSpeechBubbles.remove(this.getEntity());
    }

    for (SpeechBubbleListener listener : this.listeners) {
      listener.hidden();
    }
}private SpeechBubble(
      final IEntity entity,
      final String text,
      @Nullable SpeechBubbleAppearance appearance,
      @Nullable Font font) {
    if (appearance == null) {
      this.appearance = DEFAULT_APPEARANCE;
    } else {
      this.appearance = appearance;
    }

    final SpeechBubble active = activeSpeechBubbles.get(entity);
    if (active != null) {
      active.hide();
    }
    this.setFont(font);

    this.textBoxWidth = (float) (entity.getWidth() * 4);
    this.entity = entity;

    this.currentText = text;
    this.currentTextDisplayTime = DISPLAYTIME_MIN + text.length() * DISPLAYTIME_PER_LETTER;

    this.lastTextDisplay = Game.time().now();
    this.createBubbleImage();
    entity.getEnvironment().add(this, RenderType.UI);
    Game.loop().attach(this);
    activeSpeechBubbles.put(entity, this);
}
}
```
```java
class de.gurkenlabs.litiengine.entities.Prop {
private void updateAnimationController() {
    IEntityAnimationController<?> controller = this.createAnimationController();
    this.getControllers().addController(controller);
    if (Game.world().environment() != null && Game.world().environment().isLoaded()) {
      Game.loop().attach(controller);
    }
}
}
```
```java
class de.gurkenlabs.litiengine.graphics.FreeFlightCamera {
public FreeFlightCamera(final Point2D focus) {
    this.setFocus(focus);
    this.velocity = DEFAULT_SCROLL_PIXELS_PER_SECOND;
    this.scrollPadding = DEFAULT_SCROLL_PADDING;
    this.setClampToMap(true);

    Game.loop().attach(this);
}private void handleFreeFlightCamera() {
    if (Game.world().environment() == null || Game.world().environment().getMap() == null) {
      return;
    }

    final Point2D mouseLocation = Input.mouse().getLocation();

    final double scrollSpeed =
        this.getVelocity()
            / (double) Game.loop().getTickRate()
            * Game.config().input().getMouseSensitivity();

    double x = this.getFocus().getX();
    double y = this.getFocus().getY();

    double deltaX = 0;
    if (mouseLocation.getX() < this.getScrollPadding()) {
      deltaX -= scrollSpeed;
    } else if (Game.window().getResolution().getWidth() - mouseLocation.getX()
        < this.getScrollPadding()) {
      deltaX += scrollSpeed;
    }

    double deltaY = 0;
    if (mouseLocation.getY() < this.getScrollPadding()) {
      deltaY -= scrollSpeed;
    } else if (Game.window().getResolution().getHeight() - mouseLocation.getY()
        < this.getScrollPadding()) {
      deltaY += scrollSpeed;
    }

    x += deltaX;
    y += deltaY;

    this.setFocus(new Point2D.Double(x, y));
}
}
```
```java
class de.gurkenlabs.litiengine.environment.Environment {
private static void dispose(final Collection<? extends IEntity> entities) {
    for (final IEntity entity : entities) {
      if (entity instanceof IUpdateable) {
        Game.loop().detach((IUpdateable) entity);
      }

      entity.detachControllers();
    }
}private static void loadUpdatableOrEmitterEntity(IEntity entity) {
    if (entity instanceof Emitter) {
      final Emitter emitter = (Emitter) entity;
      if (emitter.isActivateOnInit()) {
        emitter.activate();
      }
    } else if (entity instanceof IUpdateable) {
      Game.loop().attach((IUpdateable) entity);
    }
}private void unload(final IEntity entity) {
    // 1. remove from physics engine
    if (entity instanceof ICollisionEntity) {
      Game.physics().remove((ICollisionEntity) entity);
    }

    // 2. unregister from update
    if (entity instanceof IUpdateable) {
      Game.loop().detach((IUpdateable) entity);
    }

    if (entity instanceof IMobileEntity) {
      this.removeGravity((IMobileEntity) entity);
    }

    // 3. detach all controllers
    entity.detachControllers();

    if (entity instanceof Emitter) {
      Emitter em = (Emitter) entity;
      em.deactivate();
    }

    if (this.loaded && (entity instanceof LightSource || entity instanceof StaticShadow)) {
      this.updateLighting(entity);
    }

    entity.removed(this);
}
}
```
```java
class de.gurkenlabs.litiengine.graphics.animation.Animation {
@Override
  public void update() {
    // do nothing if the animation is not playing or the current keyframe is not finished
    if (!this.isPlaying()
        || Game.time().since(this.lastFrameUpdate) < this.getCurrentKeyFrame().getDuration()) {
      return;
    }

    // if we are not looping and the last keyframe is finished, we terminate the animation
    if (!this.isLooping() && this.isLastKeyFrame()) {
      this.terminate();
      return;
    }

    // make sure, we stay inside the keyframe list
    final int newFrameIndex =
        (this.getKeyframes().indexOf(this.currentFrame) + 1) % this.getKeyframes().size();
    final KeyFrame previousFrame = this.currentFrame;
    this.currentFrame = this.getKeyframes().get(newFrameIndex);

    for (KeyFrameListener listener : this.listeners) {
      listener.currentFrameChanged(previousFrame, this.currentFrame);
    }

    this.lastFrameUpdate = Game.loop().getTicks();
}public void restart() {
    this.currentFrame = this.firstFrame;
    this.lastFrameUpdate = Game.loop().getTicks();
}
}
```
```java
class de.gurkenlabs.litiengine.physics.MovementController {
@Override
  public void attach() {
    Game.loop().attach(this);
}private void handleForces() {
    // clean up forces
    this.activeForces.forEach(
        x -> {
          if (x.hasEnded()) {
            this.activeForces.remove(x);
          }
        });

    if (this.activeForces.isEmpty()) {
      return;
    }

    // disable turn-on-move for force handling
    boolean turn = this.getEntity().turnOnMove();
    this.getEntity().setTurnOnMove(false);
    try {
      double deltaX = 0;
      double deltaY = 0;
      for (final Force force : this.activeForces) {
        if (force.cancelOnReached() && force.hasReached(this.getEntity())) {
          force.end();
          continue;
        }

        final Point2D collisionBoxCenter = this.getEntity().getCollisionBoxCenter();
        final double angle =
            GeometricUtilities.calcRotationAngleInDegrees(collisionBoxCenter, force.getLocation());
        final double strength =
            Game.loop().getDeltaTime() * 0.001f * force.getStrength() * Game.loop().getTimeScale();
        deltaX += GeometricUtilities.getDeltaX(angle, strength);
        deltaY += GeometricUtilities.getDeltaY(angle, strength);
      }

      final Point2D target =
          new Point2D.Double(this.getEntity().getX() + deltaX, this.getEntity().getY() + deltaY);
      final boolean success = Game.physics().move(this.getEntity(), target);
      if (!success) {
        for (final Force force : this.activeForces) {
          if (force.cancelOnCollision()) {
            force.end();
          }
        }
      }
    } finally {
      this.getEntity().setTurnOnMove(turn);
    }
}@Override
  public void detach() {
    Game.loop().detach(this);
}public void handleMovement() {
    if (!this.isMovementAllowed()) {
      this.velocity = 0;
      return;
    }

    // max distance an entity can travel within one tick
    final double maxPixelsPerTick = this.getEntity().getTickVelocity();
    final double deltaTime = Game.loop().getDeltaTime() * Game.loop().getTimeScale();

    final double acceleration =
        this.getEntity().getAcceleration() == 0
            ? maxPixelsPerTick
            : deltaTime / this.getEntity().getAcceleration() * maxPixelsPerTick;
    final double deceleration =
        this.getEntity().getDeceleration() == 0
            ? this.getVelocity()
            : deltaTime / this.getEntity().getDeceleration() * maxPixelsPerTick;

    double dx = this.getDx();
    double dy = this.getDy();
    this.setDx(0);
    this.setDy(0);

    final double deltaVelocity =
        Math.min(Math.sqrt(Math.pow(dx, 2) + Math.pow(dy, 2)), acceleration);
    if (deltaVelocity != 0) {
      double newVelocity = this.getVelocity() + deltaVelocity;
      this.setVelocity(newVelocity);
    } else {
      final double newVelocity = Math.max(0, this.getVelocity() - deceleration);
      this.setVelocity(newVelocity);
      dx = GeometricUtilities.getDeltaX(this.moveAngle);
      dy = GeometricUtilities.getDeltaY(this.moveAngle);
    }

    if (this.getVelocity() == 0) {
      this.moveAngle = 0;
      return;
    }

    // actually move entity
    this.moveEntity(dx, dy);
}
}
```
```java
class de.gurkenlabs.litiengine.graphics.animation.AnimationController {
public void detach() {
    Game.loop().detach(this);
}public void attach() {
    Game.loop().attach(this);
}
}
```
```java
class de.gurkenlabs.litiengine.graphics.Camera {
@Override
  public void setZoom(final float targetZoom, final int delay) {
    if (delay == 0) {

      this.zoom = targetZoom;
      this.targetZoom = 0;
      this.zoomDelay = 0;
      this.zoomTick = 0;
      this.zoomStep = 0;

      final ZoomChangedEvent event = new ZoomChangedEvent(this, targetZoom);
      for (final ZoomChangedListener listener : this.zoomListeners) {
        listener.zoomChanged(event);
      }
    } else {
      this.zoomTick = Game.time().now();
      this.targetZoom = targetZoom;
      this.zoomDelay = delay;

      final double tickduration = 1000 / (double) Game.loop().getTickRate();
      final double tickAmount = delay / tickduration;
      final float totalDelta = this.targetZoom - this.zoom;
      this.zoomStep = tickAmount > 0 ? (float) (totalDelta / tickAmount) : totalDelta;
    }
}
}
```
```java
class de.gurkenlabs.litiengine.Game {
public static synchronized void init(String... args) {
    if (initialized) {
      log().log(Level.INFO, "The game has already been initialized.");
      return;
    }

    log.init();
    handleCommandLineArguments(args);

    config().load();
    Locale.setDefault(new Locale(config().client().getCountry(), config().client().getLanguage()));

    gameLoop = new GameLoop("Main Update Loop", config().client().getMaxFps());
    loop().attach(physics());
    loop().attach(world());

    // setup default exception handling for render and update loop
    setUncaughtExceptionHandler(
        new DefaultUncaughtExceptionHandler(config().client().exitOnError()));

    screenManager = new ScreenManager();
    gameWindow = new GameWindow();

    // initialize  the game window
    window().init();
    world.setCamera(new Camera());

    for (GameListener listener : gameListeners) {
      listener.initialized(args);
    }

    if (!isInNoGUIMode()) {
      window().getRenderComponent().onRendered(g -> metrics().render(g));

      graphics()
          .addEntityRenderedListener(
              e -> DebugRenderer.renderEntityDebugInfo(e.getGraphics(), e.getEntity()));

      window().getRenderComponent().onFpsChanged(fps -> metrics().setFramesPerSecond(fps));
      window()
          .setIcons(
              Arrays.asList(
                  Resources.images().get("liti-logo-x16.png"),
                  Resources.images().get("liti-logo-x20.png"),
                  Resources.images().get("liti-logo-x32.png"),
                  Resources.images().get("liti-logo-x48.png")));

      Input.keyboard()
          .onKeyTyped(
              KeyEvent.VK_PRINTSCREEN,
              key -> {
                // don't take a screenshot if a modifier is active
                if (key.getModifiers() != 0) {
                  return;
                }

                window().getRenderComponent().takeScreenshot();
              });
    }

    Runtime.getRuntime().addShutdownHook(new Thread(Game::terminate, "Shutdown"));

    initialized = true;
}
}
```
```java
class de.gurkenlabs.litiengine.entities.Creature {
protected void updateAnimationController() {
    IEntityAnimationController<?> controller = this.createAnimationController();
    this.getControllers().addController(controller);
    if (Game.world().environment() != null && Game.world().environment().isLoaded()) {
      Game.loop().attach(controller);
    }
}@Override
  public float getTickVelocity() {
    // pixels per ms multiplied by the passed ms
    // ensure that entities don't travel too far in case of lag
    return Math.min(Game.loop().getDeltaTime(), GameLoop.TICK_DELTATIME_LAG)
        * 0.001F
        * this.getVelocity().get()
        * Game.loop().getTimeScale();
}
}
```
Depth: 2
```java
class de.gurkenlabs.litiengine.environment.GameWorld {
public void clear() {
    this.unloadEnvironment();
    this.environments.clear();
    this.setCamera(null);
    Game.physics().clear();

    this.environmentListeners.clear();
    this.environmentLoadedListeners.clear();
    this.environmentUnloadedListeners.clear();

    this.listeners.clear();
    this.loadedListeners.clear();
    this.unloadedListeners.clear();
}@Nullable
  public Environment loadEnvironment(IMap map) {
    Environment env = this.getEnvironment(map);
    this.loadEnvironment(env);
    return env;
}@Nullable
  public Environment loadEnvironment(String mapName) {
    Environment env = this.getEnvironment(mapName);
    this.loadEnvironment(env);
    return env;
}
}
```
```java
class de.gurkenlabs.litiengine.GameWindow {
GameWindow() {
    this.hostControl = new JFrame();

    this.resolutionChangedListeners = new CopyOnWriteArrayList<>();

    this.renderCanvas = new RenderComponent(Game.config().graphics().getResolution());
    this.cursor = new MouseCursor();
    if (!Game.isInNoGUIMode()) {
      this.hostControl.setBackground(Color.BLACK);
      this.hostControl.add(this.renderCanvas);

      this.initializeEventListeners();

      this.hostControl.setTitle(Game.info().getTitle());
      this.hostControl.setDefaultCloseOperation(WindowConstants.DO_NOTHING_ON_CLOSE);
      initializeWindowEventListeners(this.hostControl);
    }
}
}
```
```java
class de.gurkenlabs.litiengine.GameTime {
public long sinceEnvironmentLoad() {
    return this.since(this.environmentLoaded);
}public long since(final long tick) {
    return toMilliseconds(Game.loop().getTicks() - tick);
}public long sinceGameStart() {
    return this.toMilliseconds(Game.loop().getTicks());
}
}
```
```java
class de.gurkenlabs.litiengine.abilities.effects.Effect {
protected void cease(final EffectApplication appliance) {
    // 1. cease the effect for all affected entities
    for (final ICombatEntity entity : appliance.getAffectedEntities()) {
      this.cease(entity);
    }

    // 2. apply follow up effects
    this.getFollowUpEffects().forEach(followUp -> followUp.apply(appliance.getImpactArea()));
}protected boolean hasEnded(final EffectApplication appliance) {
    final long effectDuration = Game.time().since(appliance.getAppliedTicks());
    return effectDuration > this.getDuration();
}
}
```
```java
class de.gurkenlabs.litiengine.abilities.effects.EffectApplication {
protected EffectApplication(final List<ICombatEntity> affectedEntities, final Shape impactArea) {
    this.applied = Game.time().now();
    this.affectedEntities = affectedEntities;
    this.impactArea = impactArea;
}
}
```
```java
class de.gurkenlabs.litiengine.entities.CombatEntity {
@Override
  public boolean wasHit(int timeSpan) {
    return Game.time().since(this.lastHit) < timeSpan;
}@Override
  public void hit(final int damage, @Nullable final Ability ability) {
    if (this.isDead()) {
      return;
    }

    if (!this.isIndestructible()) {
      this.getHitPoints().modifyBaseValue(new AttributeModifier<>(Modification.SUBTRACT, damage));
    }

    final EntityHitEvent event = new EntityHitEvent(this, ability, damage, this.isDead());

    for (final CombatEntityListener listener : this.listeners) {
      listener.hit(event);
    }

    for (final CombatEntityHitListener listener : this.hitListeners) {
      listener.hit(event);
    }

    if (this.isDead()) {
      this.fireDeathEvent();
      this.setCollision(false);
    }

    this.lastHit = Game.time().now();
}
}
```
```java
class de.gurkenlabs.litiengine.graphics.ImageEffect {
protected ImageEffect(final int ttl, final String name) {
    this.ttl = ttl;
    this.name = name;
    this.aliveTick = Game.time().now();
}@Override
  public long getAliveTime() {
    return Game.time().since(this.aliveTick);
}
}
```
```java
class de.gurkenlabs.litiengine.abilities.AbilityExecution {
AbilityExecution(final Ability ability) {
    this.appliedEffects = new CopyOnWriteArrayList<>();
    this.ability = ability;
    this.executionTicks = Game.time().now();
    this.impactArea = ability.calculateImpactArea();
    this.castLocation = ability.getExecutor().getCenter();
    Game.loop().attach(this);
}@Override
  public void update() {
    // if there a no effects to apply -> unregister this instance and we're done
    if (this.getAbility().getEffects().isEmpty()
        || this.getAbility().getEffects().size() == this.getAppliedEffects().size()) {
      Game.loop().detach(this);
      return;
    }

    // handle all effects from the ability that were not applied yet
    for (final Effect effect : this.getAbility().getEffects()) {
      // if the ability was not executed yet or the delay of the effect is not
      // yet reached
      if (this.getAppliedEffects().contains(effect)
          || Game.time().since(this.getExecutionTicks()) < effect.getDelay()) {
        continue;
      }

      effect.apply(this.getExecutionImpactArea());
      this.getAppliedEffects().add(effect);
    }
}
}
```
```java
class de.gurkenlabs.litiengine.tweening.TweenEngine {
@Override
  public void update() {
    for (final Tweenable target : this.getTweens().keySet()) {
      for (final Tween tween : this.getTweens().get(target).values()) {
        if (tween.hasStopped()) {
          continue;
        }
        final long elapsed = Game.time().since(tween.getStartTime());
        if (elapsed >= tween.getDuration()) {
          tween.stop();
          continue;
        }
        final float[] currentValues = new float[tween.getTargetValues().length];
        for (int i = 0; i < tween.getTargetValues().length; i++) {
          currentValues[i] =
              tween.getStartValues()[i]
                  + tween.getEquation().compute(elapsed / (float) tween.getDuration())
                      * (tween.getTargetValues()[i] - tween.getStartValues()[i]);
        }
        tween.getTarget().setTweenValues(tween.getType(), currentValues);
      }
    }
}
}
```
```java
class de.gurkenlabs.litiengine.gui.SpeechBubble {
public static SpeechBubble create(
      final IEntity entity, final String text, SpeechBubbleAppearance appearance, Font font) {
    return new SpeechBubble(entity, text, appearance, font);
}public static SpeechBubble create(final IEntity entity, final Font font, final String text) {
    SpeechBubbleAppearance app =
        new SpeechBubbleAppearance(
            DEFAULT_APPEARANCE.getForeColor(),
            DEFAULT_APPEARANCE.getBackgroundColor1(),
            DEFAULT_APPEARANCE.getBorderColor(),
            DEFAULT_APPEARANCE.getPadding());
    return new SpeechBubble(entity, text, app, font);
}public static SpeechBubble create(final IEntity entity, final String text) {
    return new SpeechBubble(entity, text, null, GuiProperties.getDefaultFont());
}@Override
  public void update() {
    if (this.currentText == null) {
      this.hide();
      return;
    }

    this.entityCenter = Game.world().camera().getViewportLocation(this.getEntity().getCenter());

    // old text was displayed long enough
    if (this.lastTextDisplay != 0
        && Game.time().since(this.lastTextDisplay) > this.currentTextDisplayTime) {
      this.currentText = null;
      this.lastTextDisplay = 0;
      return;
    }

    // display new text
    if (this.textIndex < this.currentText.length()
        && Game.time().since(this.lastCharPoll) > LETTER_WRITE_DELAY) {
      this.textIndex++;
      this.lastCharPoll = Game.time().now();
      if (this.typeSound != null) {
        Game.audio().playSound(this.typeSound, this.getEntity());
      }
    }

    // continue displaying currently displayed text
}private SpeechBubble(
      final IEntity entity,
      final String text,
      final Sound typeSound,
      SpeechBubbleAppearance appearance,
      Font font) {
    this(entity, text, appearance, font);
    this.typeSound = typeSound;
}private SpeechBubble(
      final IEntity entity,
      final String text,
      @Nullable SpeechBubbleAppearance appearance,
      @Nullable Font font) {
    if (appearance == null) {
      this.appearance = DEFAULT_APPEARANCE;
    } else {
      this.appearance = appearance;
    }

    final SpeechBubble active = activeSpeechBubbles.get(entity);
    if (active != null) {
      active.hide();
    }
    this.setFont(font);

    this.textBoxWidth = (float) (entity.getWidth() * 4);
    this.entity = entity;

    this.currentText = text;
    this.currentTextDisplayTime = DISPLAYTIME_MIN + text.length() * DISPLAYTIME_PER_LETTER;

    this.lastTextDisplay = Game.time().now();
    this.createBubbleImage();
    entity.getEnvironment().add(this, RenderType.UI);
    Game.loop().attach(this);
    activeSpeechBubbles.put(entity, this);
}
}
```
```java
class de.gurkenlabs.litiengine.gui.TextFieldComponent {
@Override
  public void render(final Graphics2D g) {
    super.render(g);
    g.setFont(this.getFont());
    final FontMetrics fm = g.getFontMetrics();

    if (this.isSelected() && Game.time().since(this.lastToggled) > this.flickerDelay) {
      this.cursorVisible = !this.cursorVisible;
      this.lastToggled = Game.time().now();
    }
    if (this.isSelected() && this.cursorVisible) {
      final Rectangle2D cursor =
          new Rectangle2D.Double(
              this.getX() + this.getTextX() + fm.stringWidth(this.getTextToRender(g)),
              this.getY() + this.getTextY(),
              this.getFont().getSize2D() * 3 / 5,
              this.getFont().getSize2D() * 1 / 5);
      g.setColor(this.getAppearance().getForeColor());
      g.fill(cursor);
    }
}
}
```
```java
class de.gurkenlabs.litiengine.entities.Prop {
public Prop(
      final Point2D location, @Nullable final String spritesheetName, final Material material) {
    super();
    this.rotation = Rotation.NONE;
    this.spritesheetName = spritesheetName;
    this.material = material;
    this.setLocation(location);
    this.updateAnimationController();
}public void setSpritesheetName(@Nullable final String spriteName) {
    this.spritesheetName = spriteName;
    this.updateAnimationController();
}
}
```
```java
class de.gurkenlabs.litiengine.tweening.Tween {
public Tween begin() {
    this.started = Game.time().now();
    this.stopped = false;
    return this;
}
}
```
```java
class de.gurkenlabs.litiengine.graphics.emitters.particles.Particle {
public void update(final Point2D emitterOrigin, final float updateRatio) {
    if (this.aliveTick == 0) {
      this.aliveTick = Game.time().now();
    }

    this.aliveTime = Game.time().since(this.aliveTick);
    if (this.timeToLiveReached()) {
      return;
    }

    if (this.colliding) {
      return;
    }

    if (this.getDeltaWidth() != 0) {
      this.width += this.getDeltaWidth() * updateRatio;
    }

    if (this.getDeltaHeight() != 0) {
      this.height += this.getDeltaHeight() * updateRatio;
    }

    if (this.getDeltaAngle() != 0) {
      this.angle += this.getDeltaAngle() * updateRatio;
    }

    // test for ray cast collision
    final float targetX = this.x + this.getVelocityX() * updateRatio;
    final float targetY = this.y + this.getVelocityY() * updateRatio;

    if (targetX == this.x && targetY == this.y) {
      return;
    }

    if (this.checkForCollision(emitterOrigin, targetX, targetY)) {
      return;
    }

    if (this.getVelocityX() != 0) {
      this.x = targetX;
    }

    if (this.getVelocityY() != 0) {
      this.y = targetY;
    }

    if (this.getAccelerationX() != 0) {
      this.velocityX += this.getAccelerationX() * updateRatio;
    }

    if (this.getAccelerationY() != 0) {
      this.velocityY += this.getAccelerationY() * updateRatio;
    }
}
}
```
```java
class de.gurkenlabs.litiengine.graphics.animation.Animation {
@Override
  public void start() {
    this.playing = true;
    if (this.getKeyframes().isEmpty()) {
      return;
    }

    this.restart();
}@Override
  public void update() {
    // do nothing if the animation is not playing or the current keyframe is not finished
    if (!this.isPlaying()
        || Game.time().since(this.lastFrameUpdate) < this.getCurrentKeyFrame().getDuration()) {
      return;
    }

    // if we are not looping and the last keyframe is finished, we terminate the animation
    if (!this.isLooping() && this.isLastKeyFrame()) {
      this.terminate();
      return;
    }

    // make sure, we stay inside the keyframe list
    final int newFrameIndex =
        (this.getKeyframes().indexOf(this.currentFrame) + 1) % this.getKeyframes().size();
    final KeyFrame previousFrame = this.currentFrame;
    this.currentFrame = this.getKeyframes().get(newFrameIndex);

    for (KeyFrameListener listener : this.listeners) {
      listener.currentFrameChanged(previousFrame, this.currentFrame);
    }

    this.lastFrameUpdate = Game.loop().getTicks();
}
}
```
```java
class de.gurkenlabs.litiengine.graphics.animation.AnimationController {
@Override
  public void update() {
    for (final Animation animation : this.getAll()) {
      animation.update();
    }

    if (this.getCurrent() != null && this.getCurrent().isPaused()) {
      return;
    }

    final boolean playbackFinished = this.getCurrent() != null && !this.getCurrent().isPlaying();
    if (playbackFinished) {
      for (final AnimationListener listener : this.listeners) {
        listener.finished(this.getCurrent());
      }
    }

    if (this.getCurrent() == null || playbackFinished) {
      if (this.getDefault() != null) {
        this.play(this.getDefault().getName());
      } else {
        this.currentAnimation = null;
      }
    }
}
}
```
```java
class de.gurkenlabs.litiengine.graphics.RenderComponent {
private void handleFade() {
    if (this.fadeOutStart != -1) {
      final long timePassed = Game.time().since(this.fadeOutStart);
      this.currentAlpha = MathUtilities.clamp(1 - timePassed / (float) this.fadeOutTime, 0, 1);
      if (this.currentAlpha == 0f) {
        this.fadeOutStart = -1;
        this.fadeOutTime = -1;
      }

      return;
    }

    if (this.fadeInStart != -1) {
      final long timePassed = Game.time().since(this.fadeInStart);
      this.currentAlpha = MathUtilities.clamp(timePassed / (float) this.fadeInTime, 0, 1);
      if (this.currentAlpha == 1f) {
        this.fadeInStart = -1;
        this.fadeInTime = -1;
        this.currentAlpha = Float.NaN;
      }
    }
}public void fadeOut(final int ms) {
    this.fadeInStart = -1;
    this.fadeInTime = -1;
    this.fadeOutStart = Game.time().now();
    this.fadeOutTime = ms;
}public void fadeIn(final int ms) {
    this.fadeOutStart = -1;
    this.fadeOutTime = -1;
    this.fadeInStart = Game.time().now();
    this.fadeInTime = ms;
}
}
```
```java
class de.gurkenlabs.litiengine.entities.Trigger {
private boolean activate(final IEntity activator, final int tar) {
    if (!this.isLoaded()
        || this.isOneTimeTrigger && this.isActivated
        || this.getActivationType() == TriggerActivation.COLLISION
            && activator != null
            && this.collisionActivated.contains(activator)) {
      return false;
    }

    if (this.getCooldown() > 0 && Game.time().since(this.lastActivation) < this.getCooldown()) {
      return false;
    }

    List<Integer> triggerTargets = this.getTargets(tar);

    final TriggerEvent te = new TriggerEvent(this, activator, triggerTargets);

    if (!this.checkActivationPredicates(te)) {
      return false;
    }

    this.isActivated = true;
    if (activator != null) {
      this.collisionActivated.add(activator);
    }

    // if we actually have a trigger target, we send the message to the target
    for (final int target : triggerTargets) {
      final IEntity entity = this.getEnvironment().get(target);
      if (entity == null) {
        log.log(
            Level.WARNING,
            "trigger [{0}] was activated, but the trigger target [{1}] could not be found on the environment",
            new Object[] {this, target});
        continue;
      }

      entity.sendMessage(this, this.message);
    }

    // also send the trigger event to all registered consumers
    for (final TriggerActivatedListener listener : this.activatedListeners) {
      listener.activated(te);
    }

    if (this.isOneTimeTrigger) {
      this.getEnvironment().remove(this);
    }

    this.lastActivation = Game.time().now();
    return true;
}
}
```
```java
class de.gurkenlabs.litiengine.graphics.Camera {
private boolean isShakeEffectActive() {
    return this.getShakeTick() != 0
        && Game.time().since(this.getShakeTick()) < this.getShakeDuration();
}@Override
  public void update() {
    if (Game.world().camera() != null && !Game.world().camera().equals(this)) {
      return;
    }

    if (this.targetZoom > 0) {
      if (Game.time().since(this.zoomTick) >= this.zoomDelay) {
        this.zoom = this.targetZoom;
        this.targetZoom = 0;
        this.zoomDelay = 0;
        this.zoomTick = 0;
        this.zoomStep = 0;
      } else {
        this.zoom += this.zoomStep;
      }

      final ZoomChangedEvent event = new ZoomChangedEvent(this, this.getZoom());
      for (final ZoomChangedListener listener : this.zoomListeners) {
        listener.zoomChanged(event);
      }
    }

    if (this.panTime > 0) {
      if (--this.panTime <= 0) {
        this.setFocus(this.targetFocus);
        this.targetFocus = null;
      } else {
        double diff = this.panTime / (this.panTime + 1.0);
        this.focus =
            new Point2D.Double(
                this.focus.getX() * diff + this.targetFocus.getX() * (1.0 - diff),
                this.focus.getY() * diff + this.targetFocus.getY() * (1.0 - diff));
      }
    }

    if (!this.isShakeEffectActive()) {
      this.shakeOffsetX = 0;
      this.shakeOffsetY = 0;
      return;
    }

    if (Game.time().since(this.lastShake) > this.shakeDelay) {
      this.shakeOffsetX = this.getShakeIntensity() * ThreadLocalRandom.current().nextGaussian();
      this.shakeOffsetY = this.getShakeIntensity() * ThreadLocalRandom.current().nextGaussian();
      this.lastShake = Game.time().now();
    }
}@Override
  public void setZoom(final float targetZoom, final int delay) {
    if (delay == 0) {

      this.zoom = targetZoom;
      this.targetZoom = 0;
      this.zoomDelay = 0;
      this.zoomTick = 0;
      this.zoomStep = 0;

      final ZoomChangedEvent event = new ZoomChangedEvent(this, targetZoom);
      for (final ZoomChangedListener listener : this.zoomListeners) {
        listener.zoomChanged(event);
      }
    } else {
      this.zoomTick = Game.time().now();
      this.targetZoom = targetZoom;
      this.zoomDelay = delay;

      final double tickduration = 1000 / (double) Game.loop().getTickRate();
      final double tickAmount = delay / tickduration;
      final float totalDelta = this.targetZoom - this.zoom;
      this.zoomStep = tickAmount > 0 ? (float) (totalDelta / tickAmount) : totalDelta;
    }
}@Override
  public void shake(final double intensity, final int delay, final int shakeDuration) {
    this.shakeTick = Game.time().now();
    this.shakeDelay = delay;
    this.shakeIntensity = intensity;
    this.shakeDuration = shakeDuration;
}
}
```
```java
class de.gurkenlabs.litiengine.entities.Creature {
public void setSpritesheetName(String spritesheetName) {
    if (this.spritesheetName != null && this.spritesheetName.equals(spritesheetName)) {
      return;
    }

    this.spritesheetName = spritesheetName;
    this.updateAnimationController();
}public boolean isIdle() {
    return Game.time().since(this.lastMoved) > IDLE_DELAY;
}@Override
  public void setLocation(final Point2D position) {
    if (this.isDead() || position == null) {
      return;
    }

    final Point2D oldLocation = this.getLocation();
    super.setLocation(position);

    if (Game.hasStarted() && this.isLoaded()) {
      this.lastMoved = Game.time().now();
      this.fireMovedEvent(
          new EntityMovedEvent(
              this, this.getX() - oldLocation.getX(), this.getY() - oldLocation.getY()));
    }
}
}
```
```java
class de.gurkenlabs.litiengine.gui.screens.ScreenManager {
public void display(final String screenName) {
    if (this.current() != null && this.current().getName().equalsIgnoreCase(screenName)) {
      log.log(
          Level.INFO,
          "Skipping displaying of screen {0} because it is already the current screen.",
          screenName);
      return;
    }

    if (this.screens.stream()
        .noneMatch(element -> element.getName().equalsIgnoreCase(screenName))) {
      log.log(
          Level.WARNING,
          "Could not display the screen {0} because there is no screen with the specified name.",
          screenName);
      return;
    }

    Screen screen = this.get(screenName);
    if (screen == null) {
      return;
    }

    this.display(screen);
}public void add(final Screen screen) {
    screen.setWidth(Game.window().getWidth());
    screen.setHeight(Game.window().getHeight());
    this.screens.add(screen);

    if (this.current() == null) {
      this.display(screen);
    }
}public void remove(Screen screen) {
    this.screens.remove(screen);
    if (this.current() == screen) {
      if (!this.screens.isEmpty()) {
        this.display(this.screens.get(0));
      } else {
        this.display((Screen) null);
      }
    }
}public void display(@Nullable final Screen screen) {
    if (Game.hasStarted() && Game.time().since(this.lastScreenChange) < this.getChangeCooldown()) {
      log.log(
          Level.INFO,
          "Skipping displaying of screen {0} because screen changing is currently on cooldown.",
          screen != null ? screen.getName() : "");
      return;
    }

    final Screen previous = this.current();
    if (previous != null) {
      previous.suspend();
    }

    if (screen != null && !this.screens.contains(screen)) {
      this.screens.add(screen);
    }

    this.currentScreen = screen;
    if (!Game.isInNoGUIMode() && this.current() != null) {
      this.current().prepare();
    }

    this.lastScreenChange = Game.loop().getTicks();

    final ScreenChangedEvent event = new ScreenChangedEvent(this.current(), previous);
    for (final ScreenChangedListener listener : this.screenChangedListeners) {
      listener.changed(event);
    }
}
}
```
```java
class de.gurkenlabs.litiengine.abilities.Ability {
public boolean isOnCooldown() {
    return (this.getCurrentExecution() != null
        && this.getCurrentExecution().getExecutionTicks() > 0
        && Game.time().since(this.getCurrentExecution().getExecutionTicks())
            < this.getAttributes().cooldown().get());
}public boolean isActive() {
    return this.getCurrentExecution() != null
        && Game.time().since(this.getCurrentExecution().getExecutionTicks())
            < this.getAttributes().duration().get();
}@Nullable
  public AbilityExecution cast() {
    if (!this.canCast()) {
      return null;
    }
    this.currentExecution = new AbilityExecution(this);

    for (final AbilityCastListener listener : this.abilityCastListeners) {
      listener.abilityCast(this.currentExecution);
    }

    return this.getCurrentExecution();
}public float getRemainingCooldownInSeconds() {
    if (this.getCurrentExecution() == null
        || this.getExecutor() == null
        || this.getExecutor().isDead()) {
      return 0;
    }

    // calculate cooldown in seconds
    return (float)
        (!this.canCast()
            ? (this.getAttributes().cooldown().get()
                    - Game.time().since(this.getCurrentExecution().getExecutionTicks()))
                * 0.001
            : 0);
}
}
```
```java
class de.gurkenlabs.litiengine.entities.EntityHitEvent {
EntityHitEvent(
      final ICombatEntity hitEntity,
      @Nullable final Ability ability,
      final int damage,
      final boolean kill) {
    super(hitEntity);
    this.executor = ability != null ? ability.getExecutor() : null;
    this.hitEntity = hitEntity;
    this.ability = ability;
    this.damage = damage;
    this.kill = kill;
    this.time = Game.time().now();
}
}
```
```java
class de.gurkenlabs.litiengine.graphics.emitters.Emitter {
public void delete() {
    this.deactivate();
    if (Game.world().environment() != null) {
      Game.world().environment().remove(this);
    }
}public void activate() {
    if (this.activated) {
      return;
    }

    this.activated = true;
    this.activationTick = Game.time().now();
    Game.loop().attach(this);
}@Override
  public void update() {
    if (this.isPaused()) {
      return;
    }

    // clear particles if the effect time to life is reached
    if (this.isFinished()) {
      for (EmitterFinishedListener listener : this.finishedListeners) {
        listener.finished(this);
      }

      this.delete();
      return;
    }

    final float updateRatio = (float) this.data().getUpdateRate() / Game.loop().getTickRate();
    for (final Particle p : this.getParticles().stream().collect(Collectors.toList())) {
      if (this.particleCanBeRemoved(p)) {
        // remove dead particles
        this.particles.remove(p);
        continue;
      }

      p.update(this.getOrigin(), updateRatio);
    }

    this.aliveTime = Game.time().since(this.activationTick);
    if ((this.data().getSpawnRate() == 0
        || Game.time().since(this.lastSpawn) >= this.data().getSpawnRate())) {
      this.lastSpawn = Game.time().now();
      this.spawnParticle();
    }
}
}
```
```java
class de.gurkenlabs.litiengine.GameLoop {
@Override
  public int perform(int delay, Runnable action) {
    final long d = Game.time().toTicks(delay);

    TimedAction a = new TimedAction(this.getTicks() + d, action);
    this.actions.add(a);

    return a.getId();
}
}
```
```java
class de.gurkenlabs.litiengine.environment.EntitySpawner {
protected boolean shouldSpawn() {
    return this.lastSpawnWave == 0
        || Game.time().since(this.lastSpawnWave) >= this.getSpawnInterval();
}@Override
  public void update() {
    if (!this.shouldSpawn()) {
      return;
    }

    this.spawnNewEntities();
    this.lastSpawnWave = Game.time().now();
}
}
```
```java
class de.gurkenlabs.litiengine.graphics.FreeFlightCamera {
@Override
  public void update() {
    this.handleFreeFlightCamera();
}public FreeFlightCamera(double x, double y) {
    this(new Point2D.Double(x, y));
}
}
```
```java
class de.gurkenlabs.litiengine.environment.Environment {
public void unload() {
    if (!this.loaded) {
      return;
    }

    // unregister all updatable entities from the current environment
    for (final IEntity entity : this.allEntities.values()) {
      this.unload(entity);
    }

    this.loaded = false;
    this.fireEvent(l -> l.unloaded(this));
}private static void loadUpdatableOrEmitterEntity(IEntity entity) {
    if (entity instanceof Emitter) {
      final Emitter emitter = (Emitter) entity;
      if (emitter.isActivateOnInit()) {
        emitter.activate();
      }
    } else if (entity instanceof IUpdateable) {
      Game.loop().attach((IUpdateable) entity);
    }
}public void clear() {
    Game.physics().clear();

    this.combatEntities.clear();
    this.mobileEntities.clear();
    this.gravityForces.clear();
    this.layerEntities.clear();
    this.entitiesByTag.clear();
    this.allEntities.clear();

    for (RenderType renderType : RenderType.values()) {
      this.miscEntities.get(renderType).clear();
      this.renderListeners.get(renderType).clear();
      this.renderables.get(renderType).clear();
    }

    dispose(this.allEntities.values());
    dispose(this.triggers);
    this.emitters.clear();
    this.colliders.clear();
    this.props.clear();
    this.creatures.clear();
    this.staticShadows.clear();
    this.combatEntities.clear();
    this.mobileEntities.clear();
    this.lightSources.clear();
    this.spawnPoints.clear();
    this.soundSources.clear();
    this.mapAreas.clear();
    this.triggers.clear();

    this.ambientLight = null;
    this.staticShadowLayer = null;

    for (Map<Integer, IEntity> type : this.miscEntities.values()) {
      type.clear();
    }

    this.initialized = false;

    this.fireEvent(l -> l.cleared(this));
}private void load(final IEntity entity) {
    // an entity can only exist on one environment at a time, so remove it from the current one
    if (entity.getEnvironment() != null) {
      entity.getEnvironment().remove(entity);
    }

    // 1. add to physics engine
    loadPhysicsEntity(entity);

    // 2. register for update or activate
    loadUpdatableOrEmitterEntity(entity);

    // 3. if a gravity is defined, add a gravity force to the entity
    if (entity instanceof IMobileEntity && this.getGravity() != 0) {
      this.addGravityForce((IMobileEntity) entity);
    }

    // 4. attach all controllers
    entity.attachControllers();

    if (this.loaded && (entity instanceof LightSource || entity instanceof StaticShadow)) {
      this.updateLighting(entity);
    }

    entity.loaded(this);
}private void unload(final IEntity entity) {
    // 1. remove from physics engine
    if (entity instanceof ICollisionEntity) {
      Game.physics().remove((ICollisionEntity) entity);
    }

    // 2. unregister from update
    if (entity instanceof IUpdateable) {
      Game.loop().detach((IUpdateable) entity);
    }

    if (entity instanceof IMobileEntity) {
      this.removeGravity((IMobileEntity) entity);
    }

    // 3. detach all controllers
    entity.detachControllers();

    if (entity instanceof Emitter) {
      Emitter em = (Emitter) entity;
      em.deactivate();
    }

    if (this.loaded && (entity instanceof LightSource || entity instanceof StaticShadow)) {
      this.updateLighting(entity);
    }

    entity.removed(this);
}public void remove(final IEntity entity) {
    if (entity == null) {
      return;
    }

    this.allEntities.remove(entity.getMapId());
    Iterator<List<IEntity>> iter = this.layerEntities.values().iterator();
    while (iter.hasNext()) {
      List<IEntity> layer = iter.next();
      if (layer.remove(entity) && layer.isEmpty()) {
        iter.remove();
      }
    }
    if (this.miscEntities.get(entity.getRenderType()) != null) {
      this.miscEntities.get(entity.getRenderType()).values().remove(entity);
    }

    for (String tag : entity.getTags()) {
      if (this.getEntitiesByTag().containsKey(tag)) {
        this.getEntitiesByTag().get(tag).remove(entity);

        if (this.getEntitiesByTag().get(tag).isEmpty()) {
          this.getEntitiesByTag().remove(tag);
        }
      }
    }

    if (entity instanceof Emitter) {
      Emitter emitter = (Emitter) entity;
      this.removeEmitter(emitter);
    }

    if (entity instanceof MapArea) {
      this.mapAreas.remove(entity);
    }

    if (entity instanceof Prop) {
      this.props.remove(entity);
    }

    if (entity instanceof Creature) {
      this.creatures.remove(entity);
    }

    if (entity instanceof CollisionBox) {
      this.colliders.remove(entity);
      this.staticShadows.removeIf(x -> x.getOrigin() != null && x.getOrigin().equals(entity));
    }

    if (entity instanceof LightSource) {
      this.lightSources.remove(entity);
      this.updateLighting(entity);
    }

    if (entity instanceof Trigger) {
      this.triggers.remove(entity);
    }

    if (entity instanceof Spawnpoint) {
      this.spawnPoints.remove(entity);
    }
    if (entity instanceof SoundSource) {
      this.soundSources.remove(entity);
    }

    if (entity instanceof StaticShadow) {
      this.staticShadows.remove(entity);
      this.updateLighting(entity);
    }

    if (entity instanceof IMobileEntity) {
      this.mobileEntities.values().remove(entity);
    }

    if (entity instanceof ICombatEntity) {
      this.combatEntities.values().remove(entity);
    }

    this.unload(entity);

    this.fireEntityEvent(l -> l.entityRemoved(entity));
}
}
```
```java
class de.gurkenlabs.litiengine.physics.MovementController {
@Override
  public void update() {
    this.handleForces();
    this.handleMovement();
}
}
```
```java
class de.gurkenlabs.litiengine.Game {
static synchronized void terminate() {
    if (!initialized) {
      return;
    }

    hasStarted = false;
    initialized = false;

    config().save();
    gameLoop.terminate();
    tweenEngine.terminate();
    soundEngine.terminate();

    world().clear();

    for (final GameListener listener : gameListeners) {
      try {
        listener.terminated();
      } catch (Exception e) {
        log().log(Level.WARNING, "game listener threw an exception during shutdown", e);
      }
    }

    gameLoop = null;
    screenManager = null;
    gameWindow = null;
}public static synchronized void start() {
    if (!initialized) {
      throw new IllegalStateException(
          "The game cannot be started without being first initialized. Call Game.init(...) before Game.start().");
    }

    gameLoop.start();
    tweenEngine.start();
    soundEngine.start();

    for (final GameListener listener : gameListeners) {
      listener.started();
    }

    hasStarted = true;
}public static synchronized void init(String... args) {
    if (initialized) {
      log().log(Level.INFO, "The game has already been initialized.");
      return;
    }

    log.init();
    handleCommandLineArguments(args);

    config().load();
    Locale.setDefault(new Locale(config().client().getCountry(), config().client().getLanguage()));

    gameLoop = new GameLoop("Main Update Loop", config().client().getMaxFps());
    loop().attach(physics());
    loop().attach(world());

    // setup default exception handling for render and update loop
    setUncaughtExceptionHandler(
        new DefaultUncaughtExceptionHandler(config().client().exitOnError()));

    screenManager = new ScreenManager();
    gameWindow = new GameWindow();

    // initialize  the game window
    window().init();
    world.setCamera(new Camera());

    for (GameListener listener : gameListeners) {
      listener.initialized(args);
    }

    if (!isInNoGUIMode()) {
      window().getRenderComponent().onRendered(g -> metrics().render(g));

      graphics()
          .addEntityRenderedListener(
              e -> DebugRenderer.renderEntityDebugInfo(e.getGraphics(), e.getEntity()));

      window().getRenderComponent().onFpsChanged(fps -> metrics().setFramesPerSecond(fps));
      window()
          .setIcons(
              Arrays.asList(
                  Resources.images().get("liti-logo-x16.png"),
                  Resources.images().get("liti-logo-x20.png"),
                  Resources.images().get("liti-logo-x32.png"),
                  Resources.images().get("liti-logo-x48.png")));

      Input.keyboard()
          .onKeyTyped(
              KeyEvent.VK_PRINTSCREEN,
              key -> {
                // don't take a screenshot if a modifier is active
                if (key.getModifiers() != 0) {
                  return;
                }

                window().getRenderComponent().takeScreenshot();
              });
    }

    Runtime.getRuntime().addShutdownHook(new Thread(Game::terminate, "Shutdown"));

    initialized = true;
}
}
```


Response Format:
Provide the answer in **XML format** as follows:

#### If the method **cannot** return `null` at the specific call site:
```xml
<response>
  <reason><![CDATA[EXPLAIN WHY THE INVOCATION Game.loop() RESULT CANNOT BE NULL.]]></reason>
  <value>NO</value>
</response>

#### If the method can return null at the specific call site:
<response>
  <reason><![CDATA[EXPLAIN WHY THE INVOCATION Game.loop() RESULT CAN BE NULL.]]></reason>
  <value>YES</value>
</response>

#### If you are unsure or If there are any methods that directly or indirectly affect the return value and are not fully disclosed, request their declarations first, in the following format:
<response>
  <reason><![CDATA[EXPLAIN WHY THIS METHOD DECLARATION IS NECESSARY AND WHY YOU CANNOT MAKE A CONFIDENT DECISION WITHOUT IT]]></reason>
  <success>false</success>
  <methods>
    <method>methodName</method>
  </methods>
</response>

Additional Notes:
Be precise in your reasoning.
If a method’s return value depends on another method not provided, request its declaration before making a conclusion.
If the method can return null in this case but not in others, explain why it happens specifically for this call.

---ChatGPT.sendRequestToOpenAI---
Retrieving response from cache
---Response.<init>---
Creating Response:
```xml
<response>
  <reason><![CDATA[The method `Game.loop()` returns the static field `gameLoop`, which is initialized in the `Game.init(String... args)` method. In this method, a new `GameLoop` object is instantiated and assigned to `gameLoop`. Since `init()` must be called before `start()`, which is implied by the requirement of initializing the game, the `gameLoop` is guaranteed to be non-null during the lifetime of the game execution where `Game.loop()` is called. The absence of any code that could set `gameLoop` to null after its initialization ensures that `Game.loop()` cannot return null.]]></reason>
  <value>NO</value>
</response>
```
---Response.<init>---
Response created:
Disagreement: The method `Game.loop()` returns the static field `gameLoop`, which is initialized in the `Game.init(String... args)` method. In this method, a new `GameLoop` object is instantiated and assigned to `gameLoop`. Since `init()` must be called before `start()`, which is implied by the requirement of initializing the game, the `gameLoop` is guaranteed to be non-null during the lifetime of the game execution where `Game.loop()` is called. The absence of any code that could set `gameLoop` to null after its initialization ensures that `Game.loop()` cannot return null.
---AdvancedNullAwayCodeFix.resolveMethodDereferenceError---
Method is not returning nullable on call site. Injecting suppression annotation.
---AdvancedNullAwayCodeFix.constructCastToNonnullChange---
Constructing cast to nonnull change for reason: The method `Game.loop()` returns the static field `gameLoop`, which is initialized in the `Game.init(String... args)` method. In this method, a new `GameLoop` object is instantiated and assigned to `gameLoop`. Since `init()` must be called before `start()`, which is implied by the requirement of initializing the game, the `gameLoop` is guaranteed to be non-null during the lifetime of the game execution where `Game.loop()` is called. The absence of any code that could set `gameLoop` to null after its initialization ensures that `Game.loop()` cannot return null.
---ChatGPT.ask---
Asking ChatGPT:
For the reason you mentioned earlier:

"The method `Game.loop()` returns the static field `gameLoop`, which is initialized in the `Game.init(String... args)` method. In this method, a new `GameLoop` object is instantiated and assigned to `gameLoop`. Since `init()` must be called before `start()`, which is implied by the requirement of initializing the game, the `gameLoop` is guaranteed to be non-null during the lifetime of the game execution where `Game.loop()` is called. The absence of any code that could set `gameLoop` to null after its initialization ensures that `Game.loop()` cannot return null."

in the method below, the expression Game.loop() is not nullable at the point it is used.

```java
public default void attach() {
    Game.loop().attach(this);
}
```
Please Summarize the reason in max 5 words and rewrite the method so that at the line "    Game.loop().attach(this);", at the occurrence of: "Game.loop()" is replaced with `NullabilityUtil.castToNonnull(Game.loop(), summary of reason)`
Replace "REASON" with the exact reason summary I provide to you (maximum 5 words), not with a generic explanation like "checked to be nonnull".
see the example below, for expression `foo.getBar()`, to wrap it with `NullabilityUtil.castToNonnull(foo.getBar(), "reason")`.

```java
public t(){
    String l = foo.getBar();
}
```

will be:
```java
public t(){
    String l = NullabilityUtil.castToNonnull(foo.getBar(), "checked to be nonnull");
}
```

### Instructions:

Do not import any additional classes.

Do not add Java comments.

Only modify relevant lines as required.

Return only the modified method wrapped in the XML format shown below.

Place the Java code inside the <code> tag using a CDATA block with ```java formatting.

Just give me the fixed code snippet in XML format in <response> tag like the example below. I will apply the fix to my codebase. Do not import any additional libraries or classes or add java comments. If you can provide the fixed code snippet, please provide it in the following format and place the code snippet in the <code> tag within ```java block.
<response>
  <success>true</success>
  <code><![CDATA[
  ```java
  Your fixed code snippet here
  ```
    ]]>
  </code>
</response>

---ChatGPT.sendRequestToOpenAI---
Sending request to OpenAI...
---ChatGPT.sendRequestToOpenAI---
Response received from OpenAI.
---Response.<init>---
Creating Response:
<response>  
  <success>true</success>  
  <code><![CDATA[  
  ```java
  public default void attach() {
      NullabilityUtil.castToNonnull(Game.loop(), "initialized in init method").attach(this);
  }
  ```
  ]]>
  </code>  
</response>
---Response.<init>---
Response created:
public default void attach() {
      NullabilityUtil.castToNonnull(Game.loop(), "initialized in init method").attach(this);
  }
---ChatGPT.fixDereferenceByAddingCastToNonnull---
Fixing the error by adding castToNonnull
---AdvancedNullAwayCodeFix.fixTriggeredErrorsForLocation---
Resolving unresolvable error for triggered error: Type='DEREFERENCE_NULLABLE', message='dereferenced expression Game.loop() is @Nullable'
/home/nima/Developer/nullness-benchmarks/litiengine/src/de/gurkenlabs/litiengine/graphics/emitters/Emitter.java:159
    Game.loop().detach(this);
---AdvancedNullAwayCodeFix.fix---
Fixing error: Type='DEREFERENCE_NULLABLE', message='dereferenced expression Game.loop() is @Nullable'
/home/nima/Developer/nullness-benchmarks/litiengine/src/de/gurkenlabs/litiengine/graphics/emitters/Emitter.java:159
    Game.loop().detach(this);
---AdvancedNullAwayCodeFix.resolveDereferenceError---
Resolving dereference error: Type='DEREFERENCE_NULLABLE', message='dereferenced expression Game.loop() is @Nullable'
/home/nima/Developer/nullness-benchmarks/litiengine/src/de/gurkenlabs/litiengine/graphics/emitters/Emitter.java:159
    Game.loop().detach(this);
---AdvancedNullAwayCodeFix.resolveDereferenceError---
Checking nullability possibility at error point
---ChatGPT.checkNullabilityPossibilityAtErrorPoint---
Asking if the expression can be null at error point point
---ChatGPT.ask---
Asking ChatGPT:
In the method below, is there a possibility that the expression "Game.loop()" at line "Game.loop().detach(this);" is null?
public void deactivate() {
    if (!this.activated) {
      return;
    }

    this.activated = false;
    this.getParticles().clear();
    this.aliveTime = 0;
    this.activationTick = 0;
    this.lastSpawn = 0;
    Game.loop().detach(this);
}
Give a single-word answer in XML format. If it is possible for the expression to be null, respond with:
```xml
<response>
    <reason><![CDATA[YOUR REASON]]></reason>
    <value>YES</value>
</response>
```
If it is not possible for the expression to be null, respond with:
```xml
<response>
    <reason><![CDATA[YOUR REASON]]></reason>
    <value>NO</value>
</response>
```
If you are unsure or need more information, respond with where you can ask for more details or what specific information you need.

If additional information is required, list each request inside a `<request>` tag. If no additional information is needed, omit the `<requests>` section.

Respond with:
```xml
<response>
    <reason><![CDATA[YOUR REASON]]></reason>
    <value>UNKNOWN</value>
    <!-- Include <requests> only if additional information is needed -->
    <requests>
        <request><![CDATA[YOUR REQUEST 1]]></request>
        <request><![CDATA[YOUR REQUEST 2]]></request>
    </requests>
</response>
```
---ChatGPT.sendRequestToOpenAI---
Sending request to OpenAI...
---ChatGPT.sendRequestToOpenAI---
Response received from OpenAI.
---Response.<init>---
Creating Response:
```xml
<response>
    <reason><![CDATA[Without contextual information about the implementation of the Game.loop() method, it's unclear whether it can be null.]]></reason>
    <value>UNKNOWN</value>
    <requests>
        <request><![CDATA[Is it possible for the Game.loop() method to return null in any situations?]]></request>
        <request><![CDATA[Can the Game object or its loop() method be null?]]></request>
    </requests>
</response>
```
---Response.<init>---
Response created:
Unknown: Without contextual information about the implementation of the Game.loop() method, it's unclear whether it can be null.
---AdvancedNullAwayCodeFix.resolveMethodDereferenceError---
Resolving method dereference error.
---AdvancedNullAwayCodeFix.resolveMethodDereferenceError---
Method is in annotated package. Checking if the method is returning nullable.
---AdvancedNullAwayCodeFix.investigateMethodReturnNullability---
Checking if the method is returning nullable.
---ChatGPT.checkIfMethodIsReturningNullable---
Asking if the method is returning nullable: loop()
---ChatGPT.ask---
Asking ChatGPT:
In the method below, is there a possibility that the method returns null based only on its body? Consider the following points:

- The method may have multiple return paths; consider all return statements.
- If the method calls another method, do not assume its return value unless its full declaration is provided. Request its declaration if needed.
- The method may throw an exception instead of returning null. An exception path should not be considered a null return.
- Ensure you request the declarations of any methods whose return values directly or indirectly impact this method’s return value before making a conclusion.
- Carefully analyze all conditions and prior operations that may guarantee a non-null return value.

@Nullable public static IGameLoop loop() {
    return gameLoop;
}

Here are the method definitions in addition to the method inquired:

Depth: 0
```java
class de.gurkenlabs.litiengine.Game {
@Nullable public static IGameLoop loop() {
    return gameLoop;
}
}
```


Response Format:
Provide the answer in **XML format** as follows:

#### If the method **cannot** return `null`:
```xml
<response>
  <reason><![CDATA[EXPLAIN WHY THE METHOD CANNOT RETURN NULL]]></reason>
  <value>NO</value>
</response>
```

#### If the method can return null:
```xml
<response>
  <reason><![CDATA[EXPLAIN WHY THE METHOD CAN RETURN NULL]]></reason>
  <value>YES</value>
</response>
```

#### If you are unsure or need more information, respond with where you can ask for more details or what specific information you need.

#### If you are unsure or If there are any methods that directly or indirectly affect the return value and are not fully disclosed, request their declarations first, in the following format:
<response>
  <reason><![CDATA[YOUR REASON]]></reason>
  <value>UNKNOWN</value>
  <methods>
    <method>methodName</method>
  </methods>
</response>

If additional information is required other than method declaration, list each request inside a `<request>` tag. If no additional information is needed, omit the `<requests>` section.

Respond with:
```xml
<response>
    <reason><![CDATA[YOUR REASON]]></reason>
    <value>UNKNOWN</value>
    <!-- Include <requests> only if additional information is needed -->
    <requests>
        <request><![CDATA[YOUR REQUEST 1]]></request>
        <request><![CDATA[YOUR REQUEST 2]]></request>
    </requests>
</response>
```

Additional Notes:
Be precise in your reasoning.
If a method’s return value depends on another method not provided, request its declaration before making a conclusion.
If the method can return null in some cases but not others, explain under what conditions it can happen.

---ChatGPT.sendRequestToOpenAI---
Retrieving response from cache
---Response.<init>---
Creating Response:
```xml
<response>
  <reason><![CDATA[The method `loop` returns the variable `gameLoop`. Without the initialization or assignment details of `gameLoop`, it's unclear whether it can be null. The possibility of `gameLoop` being uninitialized or set to null elsewhere in the program means `loop` could potentially return null. Further information on `gameLoop` is required.]]></reason>
  <value>UNKNOWN</value>
  <requests>
    <request><![CDATA[Please provide the declaration and initialization of the variable `gameLoop` in the class `de.gurkenlabs.litiengine.Game`.]]></request>
  </requests>
</response>
```
---Response.<init>---
Response created:
Unknown: The method `loop` returns the variable `gameLoop`. Without the initialization or assignment details of `gameLoop`, it's unclear whether it can be null. The possibility of `gameLoop` being uninitialized or set to null elsewhere in the program means `loop` could potentially return null. Further information on `gameLoop` is required.
---AdvancedNullAwayCodeFix.investigateMethodReturnNullability---
Could not determine the nullability and model did not ask for any method.
---ChatGPT.checkIfMethodIsReturningNullableOnCallSite---
Asking if the method is returning nullable on the call site: Game.loop()
---ChatGPT.ask---
Asking ChatGPT:
In the method below, is there a possibility that the method returns null at the given call site?

```java
@Nullable public static IGameLoop loop() {
    return gameLoop;
}
```

## Guidelines:
- The method may have multiple return paths; consider all return statements.
- If the method calls another method, do not assume its return value unless its full declaration is provided. Request its declaration if needed.
- The method may throw an exception instead of returning null. An exception path should not be considered a null return.
- Ensure you request the declarations of any methods whose return values directly or indirectly impact this method’s return value before making a conclusion.
- If the method returns a value that is determined by a parameter, evaluate based on the actual argument at the given call site.
- Analyze based only on the specific invocation provided. Do not generalize to all possible inputs.- If the return value is guaranteed to be non-null at the call site, the answer should be a definitive NO.
- Do not generalize based on all possible inputs—your answer must be based only on the given invocation.
- Focus only on the given call site, not all possible invocations.

### call site:
Game.loop()

Here are the method definitions and the call chain for this method, showing the sequence of calls from the method to its callers at each depth level:

Depth: 0
```java
class de.gurkenlabs.litiengine.Game {
@Nullable public static IGameLoop loop() {
    return gameLoop;
}
}
```
Depth: 1
```java
class de.gurkenlabs.litiengine.environment.GameWorld {
public void loadEnvironment(@Nullable final Environment env) {
    Lock lock = Game.loop().getLock();
    lock.lock();
    try {
      unloadEnvironment();
      this.environment = env;
      if (env != null) {
        this.addEnvironment(env);

        if (env.getGravity() == 0 && this.gravity() != 0) {
          env.setGravity(this.gravity());
        }

        env.load();
        for (final EnvironmentLoadedListener listener : this.loadedListeners) {
          listener.loaded(env);
        }

        // call map specific listeners
        String mapName = getMapName(env);
        if (mapName != null && this.environmentLoadedListeners.containsKey(mapName)) {

          // for the default camera we center the camera on the environment
          if (this.camera().getClass().equals(Camera.class)) {
            camera().setFocus(env.getCenter());
          }

          for (EnvironmentLoadedListener listener : this.environmentLoadedListeners.get(mapName)) {
            listener.loaded(env);
          }
        }
      }
    } finally {
      lock.unlock();
    }
}public void setCamera(@Nullable final ICamera cam) {
    if (this.camera() != null) {
      Game.loop().detach(camera);
    }

    camera = cam;

    if (cam != null && !Game.isInNoGUIMode()) {
      Game.loop().attach(cam);
      cam.updateFocus();
    }
}
}
```
```java
class de.gurkenlabs.litiengine.entities.behavior.EntityNavigator {
public EntityNavigator(final IMobileEntity entity, final PathFinder pathFinder) {
    this.cancelNavigationConditions = new CopyOnWriteArrayList<>();
    this.listeners = new CopyOnWriteArrayList<>();
    this.entity = entity;
    this.pathFinder = pathFinder;
    this.setAcceptableError(DEFAULT_ACCEPTABLE_ERROR);
    Game.loop().attach(this);
}
}
```
```java
class de.gurkenlabs.litiengine.GameWindow {
private static void initializeWindowEventListeners(Window window) {

    window.addWindowStateListener(
        e -> {
          if (e.getNewState() == Frame.ICONIFIED) {
            Game.loop().setTickRate(ICONIFIED_MAX_FPS);
          } else {
            Game.loop().setTickRate(Game.config().client().getMaxFps());
          }
        });

    window.addWindowFocusListener(
        new WindowFocusListener() {
          @Override
          public void windowLostFocus(WindowEvent e) {
            if (Game.config().graphics().reduceFramesWhenNotFocused()) {
              Game.loop().setTickRate(NONE_FOCUS_MAX_FPS);
            }
          }

          @Override
          public void windowGainedFocus(WindowEvent e) {
            Game.loop().setTickRate(Game.config().client().getMaxFps());
          }
        });

    window.addWindowListener(
        new WindowAdapter() {
          @Override
          public void windowClosing(final WindowEvent event) {
            Game.exit();
          }
        });
}
}
```
```java
class de.gurkenlabs.litiengine.gui.screens.ScreenManager {
public void display(@Nullable final Screen screen) {
    if (Game.hasStarted() && Game.time().since(this.lastScreenChange) < this.getChangeCooldown()) {
      log.log(
          Level.INFO,
          "Skipping displaying of screen {0} because screen changing is currently on cooldown.",
          screen != null ? screen.getName() : "");
      return;
    }

    final Screen previous = this.current();
    if (previous != null) {
      previous.suspend();
    }

    if (screen != null && !this.screens.contains(screen)) {
      this.screens.add(screen);
    }

    this.currentScreen = screen;
    if (!Game.isInNoGUIMode() && this.current() != null) {
      this.current().prepare();
    }

    this.lastScreenChange = Game.loop().getTicks();

    final ScreenChangedEvent event = new ScreenChangedEvent(this.current(), previous);
    for (final ScreenChangedListener listener : this.screenChangedListeners) {
      listener.changed(event);
    }
}
}
```
```java
class de.gurkenlabs.litiengine.abilities.effects.Effect {
@Override
  public void update() {

    for (final Iterator<EffectApplication> iterator = this.getActiveAppliances().iterator();
        iterator.hasNext(); ) {
      final EffectApplication appliance = iterator.next();
      // if the effect duration is reached
      if (this.hasEnded(appliance)) {

        iterator.remove();
        this.cease(appliance);
      }
    }

    // 4. unregister if all appliances are finished
    if (this.getActiveAppliances().isEmpty()) {
      Game.loop().detach(this);
    }
}public void apply(final Shape impactArea) {
    final List<ICombatEntity> affected = this.lookForAffectedEntities(impactArea);
    for (final ICombatEntity affectedEntity : affected) {
      this.apply(affectedEntity);
    }

    this.appliances.add(new EffectApplication(affected, impactArea));

    // if it is the first appliance -> register for update
    if (this.appliances.size() == 1) {
      Game.loop().attach(this);
    }
}
}
```
```java
class de.gurkenlabs.litiengine.GameTime {
public long toTicks(final int milliseconds) {
    return this.toTicks(milliseconds, Game.loop().getTickRate());
}public long since(final long tick) {
    return toMilliseconds(Game.loop().getTicks() - tick);
}public long now() {
    return Game.loop().getTicks();
}public long sinceGameStart() {
    return this.toMilliseconds(Game.loop().getTicks());
}@Override
  public void loaded(Environment environment) {
    environmentLoaded = Game.loop().getTicks();
}public long toMilliseconds(final long ticks) {
    return this.toMilliseconds(ticks, Game.loop().getTickRate());
}
}
```
```java
class de.gurkenlabs.litiengine.GameMetrics {
@Override
  public void render(final Graphics2D g) {
    this.updateMetrics();

    if (!Game.config().client().showGameMetrics()) {
      return;
    }

    this.currentOffsetY = 0;

    g.setColor(this.renderColor);

    // render client metrics
    this.drawTitle(g, "[client]");
    this.drawMetric(g, "fps       : " + this.getFramesPerSecond());
    this.drawMetric(g, "max fps   : " + this.maxFramesPerSecond);
    this.drawMetric(g, "updatables: " + Game.loop().getUpdatableCount());

    // render jvm metrics if debug is enabled
    if (Game.config().debug().isDebugEnabled()) {
      this.drawTitle(g, "[jvm]");
      this.drawMetric(g, "java      : " + this.javaVersion);
      this.drawMetric(g, "memory    : " + String.format("%-5.5s", this.usedMemory) + " MB");
      this.drawMetric(g, "threads   : " + Thread.activeCount());
    }

    // render rendering metrics
    if (!this.renderMetrics.isEmpty()) {
      this.drawTitle(g, "[update]");

      for (RenderMetrics metric : this.renderMetrics) {
        this.drawMetric(g, metric.toString());
      }

      this.renderMetrics.clear();
    }
}
}
```
```java
class de.gurkenlabs.litiengine.graphics.emitters.Emitter {
public void deactivate() {
    if (!this.activated) {
      return;
    }

    this.activated = false;
    this.getParticles().clear();
    this.aliveTime = 0;
    this.activationTick = 0;
    this.lastSpawn = 0;
    Game.loop().detach(this);
}public void activate() {
    if (this.activated) {
      return;
    }

    this.activated = true;
    this.activationTick = Game.time().now();
    Game.loop().attach(this);
}@Override
  public void update() {
    if (this.isPaused()) {
      return;
    }

    // clear particles if the effect time to life is reached
    if (this.isFinished()) {
      for (EmitterFinishedListener listener : this.finishedListeners) {
        listener.finished(this);
      }

      this.delete();
      return;
    }

    final float updateRatio = (float) this.data().getUpdateRate() / Game.loop().getTickRate();
    for (final Particle p : this.getParticles().stream().collect(Collectors.toList())) {
      if (this.particleCanBeRemoved(p)) {
        // remove dead particles
        this.particles.remove(p);
        continue;
      }

      p.update(this.getOrigin(), updateRatio);
    }

    this.aliveTime = Game.time().since(this.activationTick);
    if ((this.data().getSpawnRate() == 0
        || Game.time().since(this.lastSpawn) >= this.data().getSpawnRate())) {
      this.lastSpawn = Game.time().now();
      this.spawnParticle();
    }
}
}
```
```java
class de.gurkenlabs.litiengine.entities.behavior.IBehaviorController {
public default void attach() {
    Game.loop().attach(this);
}public default void detach() {
    Game.loop().detach(this);
}
}
```
```java
class de.gurkenlabs.litiengine.abilities.AbilityExecution {
AbilityExecution(final Ability ability) {
    this.appliedEffects = new CopyOnWriteArrayList<>();
    this.ability = ability;
    this.executionTicks = Game.time().now();
    this.impactArea = ability.calculateImpactArea();
    this.castLocation = ability.getExecutor().getCenter();
    Game.loop().attach(this);
}@Override
  public void update() {
    // if there a no effects to apply -> unregister this instance and we're done
    if (this.getAbility().getEffects().isEmpty()
        || this.getAbility().getEffects().size() == this.getAppliedEffects().size()) {
      Game.loop().detach(this);
      return;
    }

    // handle all effects from the ability that were not applied yet
    for (final Effect effect : this.getAbility().getEffects()) {
      // if the ability was not executed yet or the delay of the effect is not
      // yet reached
      if (this.getAppliedEffects().contains(effect)
          || Game.time().since(this.getExecutionTicks()) < effect.getDelay()) {
        continue;
      }

      effect.apply(this.getExecutionImpactArea());
      this.getAppliedEffects().add(effect);
    }
}
}
```
```java
class de.gurkenlabs.litiengine.GameWindow$3 {
@Override
          public void windowGainedFocus(WindowEvent e) {
            Game.loop().setTickRate(Game.config().client().getMaxFps());
}@Override
          public void windowLostFocus(WindowEvent e) {
            if (Game.config().graphics().reduceFramesWhenNotFocused()) {
              Game.loop().setTickRate(NONE_FOCUS_MAX_FPS);
            }
}
}
```
```java
class de.gurkenlabs.litiengine.environment.EntitySpawner {
protected void spawnNewEntities() {
    if (this.getSpawnMode() != SpawnMode.CUSTOMSPAWNPOINTS && this.getSpawnPoints().isEmpty()) {
      return;
    }

    switch (this.getSpawnMode()) {
      case ALLSPAWNPOINTS:
        for (int i = 0; i < this.getSpawnPoints().size(); i++) {
          final int index = i;
          Game.loop()
              .perform(
                  this.getSpawnDelay() + this.getSpawnDelay() * i,
                  () -> this.spawn(this.getSpawnPoints().get(index), this.getSpawnAmount()));
        }
        break;
      case ONERANDOMSPAWNPOINT:
        this.spawn(Game.random().choose(this.getSpawnPoints()), this.getSpawnAmount());
        break;
      case RANDOMSPAWNPOINTS:
        for (int i = 0; i < this.getSpawnAmount(); i++) {
          Game.loop()
              .perform(
                  this.getSpawnDelay() + this.getSpawnDelay() * i,
                  () -> this.spawn(Game.random().choose(this.getSpawnPoints()), 1));
        }
        break;
      case CUSTOMSPAWNPOINTS:
        List<Spawnpoint> spawnPoints =
            this.customSpawnpoints != null
                ? this.customSpawnpoints.apply(this)
                : this.getCustomSpawnpoints();

        int index = 0;
        for (Spawnpoint spawn : spawnPoints) {
          Game.loop()
              .perform(
                  this.getSpawnDelay() + this.getSpawnDelay() * index, () -> this.spawn(spawn, 1));
          index++;
        }
        break;
      default:
        break;
    }
}
}
```
```java
class de.gurkenlabs.litiengine.tweening.TweenEngine {
@Override
  public void start() {
    Game.loop().attach(this);
}@Override
  public void terminate() {
    Game.loop().detach(this);
}
}
```
```java
class de.gurkenlabs.litiengine.gui.SpeechBubble {
public void hide() {
    Game.world().environment().removeRenderable(this);
    Game.loop().detach(this);
    if (activeSpeechBubbles.get(this.getEntity()) != null
        && activeSpeechBubbles.remove(this.getEntity()).equals(this)) {
      activeSpeechBubbles.remove(this.getEntity());
    }

    for (SpeechBubbleListener listener : this.listeners) {
      listener.hidden();
    }
}private SpeechBubble(
      final IEntity entity,
      final String text,
      @Nullable SpeechBubbleAppearance appearance,
      @Nullable Font font) {
    if (appearance == null) {
      this.appearance = DEFAULT_APPEARANCE;
    } else {
      this.appearance = appearance;
    }

    final SpeechBubble active = activeSpeechBubbles.get(entity);
    if (active != null) {
      active.hide();
    }
    this.setFont(font);

    this.textBoxWidth = (float) (entity.getWidth() * 4);
    this.entity = entity;

    this.currentText = text;
    this.currentTextDisplayTime = DISPLAYTIME_MIN + text.length() * DISPLAYTIME_PER_LETTER;

    this.lastTextDisplay = Game.time().now();
    this.createBubbleImage();
    entity.getEnvironment().add(this, RenderType.UI);
    Game.loop().attach(this);
    activeSpeechBubbles.put(entity, this);
}
}
```
```java
class de.gurkenlabs.litiengine.entities.Prop {
private void updateAnimationController() {
    IEntityAnimationController<?> controller = this.createAnimationController();
    this.getControllers().addController(controller);
    if (Game.world().environment() != null && Game.world().environment().isLoaded()) {
      Game.loop().attach(controller);
    }
}
}
```
```java
class de.gurkenlabs.litiengine.graphics.FreeFlightCamera {
public FreeFlightCamera(final Point2D focus) {
    this.setFocus(focus);
    this.velocity = DEFAULT_SCROLL_PIXELS_PER_SECOND;
    this.scrollPadding = DEFAULT_SCROLL_PADDING;
    this.setClampToMap(true);

    Game.loop().attach(this);
}private void handleFreeFlightCamera() {
    if (Game.world().environment() == null || Game.world().environment().getMap() == null) {
      return;
    }

    final Point2D mouseLocation = Input.mouse().getLocation();

    final double scrollSpeed =
        this.getVelocity()
            / (double) Game.loop().getTickRate()
            * Game.config().input().getMouseSensitivity();

    double x = this.getFocus().getX();
    double y = this.getFocus().getY();

    double deltaX = 0;
    if (mouseLocation.getX() < this.getScrollPadding()) {
      deltaX -= scrollSpeed;
    } else if (Game.window().getResolution().getWidth() - mouseLocation.getX()
        < this.getScrollPadding()) {
      deltaX += scrollSpeed;
    }

    double deltaY = 0;
    if (mouseLocation.getY() < this.getScrollPadding()) {
      deltaY -= scrollSpeed;
    } else if (Game.window().getResolution().getHeight() - mouseLocation.getY()
        < this.getScrollPadding()) {
      deltaY += scrollSpeed;
    }

    x += deltaX;
    y += deltaY;

    this.setFocus(new Point2D.Double(x, y));
}
}
```
```java
class de.gurkenlabs.litiengine.environment.Environment {
private static void dispose(final Collection<? extends IEntity> entities) {
    for (final IEntity entity : entities) {
      if (entity instanceof IUpdateable) {
        Game.loop().detach((IUpdateable) entity);
      }

      entity.detachControllers();
    }
}private static void loadUpdatableOrEmitterEntity(IEntity entity) {
    if (entity instanceof Emitter) {
      final Emitter emitter = (Emitter) entity;
      if (emitter.isActivateOnInit()) {
        emitter.activate();
      }
    } else if (entity instanceof IUpdateable) {
      Game.loop().attach((IUpdateable) entity);
    }
}private void unload(final IEntity entity) {
    // 1. remove from physics engine
    if (entity instanceof ICollisionEntity) {
      Game.physics().remove((ICollisionEntity) entity);
    }

    // 2. unregister from update
    if (entity instanceof IUpdateable) {
      Game.loop().detach((IUpdateable) entity);
    }

    if (entity instanceof IMobileEntity) {
      this.removeGravity((IMobileEntity) entity);
    }

    // 3. detach all controllers
    entity.detachControllers();

    if (entity instanceof Emitter) {
      Emitter em = (Emitter) entity;
      em.deactivate();
    }

    if (this.loaded && (entity instanceof LightSource || entity instanceof StaticShadow)) {
      this.updateLighting(entity);
    }

    entity.removed(this);
}
}
```
```java
class de.gurkenlabs.litiengine.graphics.animation.Animation {
@Override
  public void update() {
    // do nothing if the animation is not playing or the current keyframe is not finished
    if (!this.isPlaying()
        || Game.time().since(this.lastFrameUpdate) < this.getCurrentKeyFrame().getDuration()) {
      return;
    }

    // if we are not looping and the last keyframe is finished, we terminate the animation
    if (!this.isLooping() && this.isLastKeyFrame()) {
      this.terminate();
      return;
    }

    // make sure, we stay inside the keyframe list
    final int newFrameIndex =
        (this.getKeyframes().indexOf(this.currentFrame) + 1) % this.getKeyframes().size();
    final KeyFrame previousFrame = this.currentFrame;
    this.currentFrame = this.getKeyframes().get(newFrameIndex);

    for (KeyFrameListener listener : this.listeners) {
      listener.currentFrameChanged(previousFrame, this.currentFrame);
    }

    this.lastFrameUpdate = Game.loop().getTicks();
}public void restart() {
    this.currentFrame = this.firstFrame;
    this.lastFrameUpdate = Game.loop().getTicks();
}
}
```
```java
class de.gurkenlabs.litiengine.physics.MovementController {
@Override
  public void attach() {
    Game.loop().attach(this);
}private void handleForces() {
    // clean up forces
    this.activeForces.forEach(
        x -> {
          if (x.hasEnded()) {
            this.activeForces.remove(x);
          }
        });

    if (this.activeForces.isEmpty()) {
      return;
    }

    // disable turn-on-move for force handling
    boolean turn = this.getEntity().turnOnMove();
    this.getEntity().setTurnOnMove(false);
    try {
      double deltaX = 0;
      double deltaY = 0;
      for (final Force force : this.activeForces) {
        if (force.cancelOnReached() && force.hasReached(this.getEntity())) {
          force.end();
          continue;
        }

        final Point2D collisionBoxCenter = this.getEntity().getCollisionBoxCenter();
        final double angle =
            GeometricUtilities.calcRotationAngleInDegrees(collisionBoxCenter, force.getLocation());
        final double strength =
            Game.loop().getDeltaTime() * 0.001f * force.getStrength() * Game.loop().getTimeScale();
        deltaX += GeometricUtilities.getDeltaX(angle, strength);
        deltaY += GeometricUtilities.getDeltaY(angle, strength);
      }

      final Point2D target =
          new Point2D.Double(this.getEntity().getX() + deltaX, this.getEntity().getY() + deltaY);
      final boolean success = Game.physics().move(this.getEntity(), target);
      if (!success) {
        for (final Force force : this.activeForces) {
          if (force.cancelOnCollision()) {
            force.end();
          }
        }
      }
    } finally {
      this.getEntity().setTurnOnMove(turn);
    }
}@Override
  public void detach() {
    Game.loop().detach(this);
}public void handleMovement() {
    if (!this.isMovementAllowed()) {
      this.velocity = 0;
      return;
    }

    // max distance an entity can travel within one tick
    final double maxPixelsPerTick = this.getEntity().getTickVelocity();
    final double deltaTime = Game.loop().getDeltaTime() * Game.loop().getTimeScale();

    final double acceleration =
        this.getEntity().getAcceleration() == 0
            ? maxPixelsPerTick
            : deltaTime / this.getEntity().getAcceleration() * maxPixelsPerTick;
    final double deceleration =
        this.getEntity().getDeceleration() == 0
            ? this.getVelocity()
            : deltaTime / this.getEntity().getDeceleration() * maxPixelsPerTick;

    double dx = this.getDx();
    double dy = this.getDy();
    this.setDx(0);
    this.setDy(0);

    final double deltaVelocity =
        Math.min(Math.sqrt(Math.pow(dx, 2) + Math.pow(dy, 2)), acceleration);
    if (deltaVelocity != 0) {
      double newVelocity = this.getVelocity() + deltaVelocity;
      this.setVelocity(newVelocity);
    } else {
      final double newVelocity = Math.max(0, this.getVelocity() - deceleration);
      this.setVelocity(newVelocity);
      dx = GeometricUtilities.getDeltaX(this.moveAngle);
      dy = GeometricUtilities.getDeltaY(this.moveAngle);
    }

    if (this.getVelocity() == 0) {
      this.moveAngle = 0;
      return;
    }

    // actually move entity
    this.moveEntity(dx, dy);
}
}
```
```java
class de.gurkenlabs.litiengine.graphics.animation.AnimationController {
public void detach() {
    Game.loop().detach(this);
}public void attach() {
    Game.loop().attach(this);
}
}
```
```java
class de.gurkenlabs.litiengine.graphics.Camera {
@Override
  public void setZoom(final float targetZoom, final int delay) {
    if (delay == 0) {

      this.zoom = targetZoom;
      this.targetZoom = 0;
      this.zoomDelay = 0;
      this.zoomTick = 0;
      this.zoomStep = 0;

      final ZoomChangedEvent event = new ZoomChangedEvent(this, targetZoom);
      for (final ZoomChangedListener listener : this.zoomListeners) {
        listener.zoomChanged(event);
      }
    } else {
      this.zoomTick = Game.time().now();
      this.targetZoom = targetZoom;
      this.zoomDelay = delay;

      final double tickduration = 1000 / (double) Game.loop().getTickRate();
      final double tickAmount = delay / tickduration;
      final float totalDelta = this.targetZoom - this.zoom;
      this.zoomStep = tickAmount > 0 ? (float) (totalDelta / tickAmount) : totalDelta;
    }
}
}
```
```java
class de.gurkenlabs.litiengine.Game {
public static synchronized void init(String... args) {
    if (initialized) {
      log().log(Level.INFO, "The game has already been initialized.");
      return;
    }

    log.init();
    handleCommandLineArguments(args);

    config().load();
    Locale.setDefault(new Locale(config().client().getCountry(), config().client().getLanguage()));

    gameLoop = new GameLoop("Main Update Loop", config().client().getMaxFps());
    loop().attach(physics());
    loop().attach(world());

    // setup default exception handling for render and update loop
    setUncaughtExceptionHandler(
        new DefaultUncaughtExceptionHandler(config().client().exitOnError()));

    screenManager = new ScreenManager();
    gameWindow = new GameWindow();

    // initialize  the game window
    window().init();
    world.setCamera(new Camera());

    for (GameListener listener : gameListeners) {
      listener.initialized(args);
    }

    if (!isInNoGUIMode()) {
      window().getRenderComponent().onRendered(g -> metrics().render(g));

      graphics()
          .addEntityRenderedListener(
              e -> DebugRenderer.renderEntityDebugInfo(e.getGraphics(), e.getEntity()));

      window().getRenderComponent().onFpsChanged(fps -> metrics().setFramesPerSecond(fps));
      window()
          .setIcons(
              Arrays.asList(
                  Resources.images().get("liti-logo-x16.png"),
                  Resources.images().get("liti-logo-x20.png"),
                  Resources.images().get("liti-logo-x32.png"),
                  Resources.images().get("liti-logo-x48.png")));

      Input.keyboard()
          .onKeyTyped(
              KeyEvent.VK_PRINTSCREEN,
              key -> {
                // don't take a screenshot if a modifier is active
                if (key.getModifiers() != 0) {
                  return;
                }

                window().getRenderComponent().takeScreenshot();
              });
    }

    Runtime.getRuntime().addShutdownHook(new Thread(Game::terminate, "Shutdown"));

    initialized = true;
}
}
```
```java
class de.gurkenlabs.litiengine.entities.Creature {
protected void updateAnimationController() {
    IEntityAnimationController<?> controller = this.createAnimationController();
    this.getControllers().addController(controller);
    if (Game.world().environment() != null && Game.world().environment().isLoaded()) {
      Game.loop().attach(controller);
    }
}@Override
  public float getTickVelocity() {
    // pixels per ms multiplied by the passed ms
    // ensure that entities don't travel too far in case of lag
    return Math.min(Game.loop().getDeltaTime(), GameLoop.TICK_DELTATIME_LAG)
        * 0.001F
        * this.getVelocity().get()
        * Game.loop().getTimeScale();
}
}
```
Depth: 2
```java
class de.gurkenlabs.litiengine.environment.GameWorld {
public void clear() {
    this.unloadEnvironment();
    this.environments.clear();
    this.setCamera(null);
    Game.physics().clear();

    this.environmentListeners.clear();
    this.environmentLoadedListeners.clear();
    this.environmentUnloadedListeners.clear();

    this.listeners.clear();
    this.loadedListeners.clear();
    this.unloadedListeners.clear();
}@Nullable
  public Environment loadEnvironment(IMap map) {
    Environment env = this.getEnvironment(map);
    this.loadEnvironment(env);
    return env;
}@Nullable
  public Environment loadEnvironment(String mapName) {
    Environment env = this.getEnvironment(mapName);
    this.loadEnvironment(env);
    return env;
}
}
```
```java
class de.gurkenlabs.litiengine.GameWindow {
GameWindow() {
    this.hostControl = new JFrame();

    this.resolutionChangedListeners = new CopyOnWriteArrayList<>();

    this.renderCanvas = new RenderComponent(Game.config().graphics().getResolution());
    this.cursor = new MouseCursor();
    if (!Game.isInNoGUIMode()) {
      this.hostControl.setBackground(Color.BLACK);
      this.hostControl.add(this.renderCanvas);

      this.initializeEventListeners();

      this.hostControl.setTitle(Game.info().getTitle());
      this.hostControl.setDefaultCloseOperation(WindowConstants.DO_NOTHING_ON_CLOSE);
      initializeWindowEventListeners(this.hostControl);
    }
}
}
```
```java
class de.gurkenlabs.litiengine.GameTime {
public long sinceEnvironmentLoad() {
    return this.since(this.environmentLoaded);
}public long since(final long tick) {
    return toMilliseconds(Game.loop().getTicks() - tick);
}public long sinceGameStart() {
    return this.toMilliseconds(Game.loop().getTicks());
}
}
```
```java
class de.gurkenlabs.litiengine.abilities.effects.Effect {
protected void cease(final EffectApplication appliance) {
    // 1. cease the effect for all affected entities
    for (final ICombatEntity entity : appliance.getAffectedEntities()) {
      this.cease(entity);
    }

    // 2. apply follow up effects
    this.getFollowUpEffects().forEach(followUp -> followUp.apply(appliance.getImpactArea()));
}protected boolean hasEnded(final EffectApplication appliance) {
    final long effectDuration = Game.time().since(appliance.getAppliedTicks());
    return effectDuration > this.getDuration();
}
}
```
```java
class de.gurkenlabs.litiengine.abilities.effects.EffectApplication {
protected EffectApplication(final List<ICombatEntity> affectedEntities, final Shape impactArea) {
    this.applied = Game.time().now();
    this.affectedEntities = affectedEntities;
    this.impactArea = impactArea;
}
}
```
```java
class de.gurkenlabs.litiengine.entities.CombatEntity {
@Override
  public boolean wasHit(int timeSpan) {
    return Game.time().since(this.lastHit) < timeSpan;
}@Override
  public void hit(final int damage, @Nullable final Ability ability) {
    if (this.isDead()) {
      return;
    }

    if (!this.isIndestructible()) {
      this.getHitPoints().modifyBaseValue(new AttributeModifier<>(Modification.SUBTRACT, damage));
    }

    final EntityHitEvent event = new EntityHitEvent(this, ability, damage, this.isDead());

    for (final CombatEntityListener listener : this.listeners) {
      listener.hit(event);
    }

    for (final CombatEntityHitListener listener : this.hitListeners) {
      listener.hit(event);
    }

    if (this.isDead()) {
      this.fireDeathEvent();
      this.setCollision(false);
    }

    this.lastHit = Game.time().now();
}
}
```
```java
class de.gurkenlabs.litiengine.graphics.ImageEffect {
protected ImageEffect(final int ttl, final String name) {
    this.ttl = ttl;
    this.name = name;
    this.aliveTick = Game.time().now();
}@Override
  public long getAliveTime() {
    return Game.time().since(this.aliveTick);
}
}
```
```java
class de.gurkenlabs.litiengine.abilities.AbilityExecution {
AbilityExecution(final Ability ability) {
    this.appliedEffects = new CopyOnWriteArrayList<>();
    this.ability = ability;
    this.executionTicks = Game.time().now();
    this.impactArea = ability.calculateImpactArea();
    this.castLocation = ability.getExecutor().getCenter();
    Game.loop().attach(this);
}@Override
  public void update() {
    // if there a no effects to apply -> unregister this instance and we're done
    if (this.getAbility().getEffects().isEmpty()
        || this.getAbility().getEffects().size() == this.getAppliedEffects().size()) {
      Game.loop().detach(this);
      return;
    }

    // handle all effects from the ability that were not applied yet
    for (final Effect effect : this.getAbility().getEffects()) {
      // if the ability was not executed yet or the delay of the effect is not
      // yet reached
      if (this.getAppliedEffects().contains(effect)
          || Game.time().since(this.getExecutionTicks()) < effect.getDelay()) {
        continue;
      }

      effect.apply(this.getExecutionImpactArea());
      this.getAppliedEffects().add(effect);
    }
}
}
```
```java
class de.gurkenlabs.litiengine.tweening.TweenEngine {
@Override
  public void update() {
    for (final Tweenable target : this.getTweens().keySet()) {
      for (final Tween tween : this.getTweens().get(target).values()) {
        if (tween.hasStopped()) {
          continue;
        }
        final long elapsed = Game.time().since(tween.getStartTime());
        if (elapsed >= tween.getDuration()) {
          tween.stop();
          continue;
        }
        final float[] currentValues = new float[tween.getTargetValues().length];
        for (int i = 0; i < tween.getTargetValues().length; i++) {
          currentValues[i] =
              tween.getStartValues()[i]
                  + tween.getEquation().compute(elapsed / (float) tween.getDuration())
                      * (tween.getTargetValues()[i] - tween.getStartValues()[i]);
        }
        tween.getTarget().setTweenValues(tween.getType(), currentValues);
      }
    }
}
}
```
```java
class de.gurkenlabs.litiengine.gui.SpeechBubble {
public static SpeechBubble create(
      final IEntity entity, final String text, SpeechBubbleAppearance appearance, Font font) {
    return new SpeechBubble(entity, text, appearance, font);
}public static SpeechBubble create(final IEntity entity, final Font font, final String text) {
    SpeechBubbleAppearance app =
        new SpeechBubbleAppearance(
            DEFAULT_APPEARANCE.getForeColor(),
            DEFAULT_APPEARANCE.getBackgroundColor1(),
            DEFAULT_APPEARANCE.getBorderColor(),
            DEFAULT_APPEARANCE.getPadding());
    return new SpeechBubble(entity, text, app, font);
}public static SpeechBubble create(final IEntity entity, final String text) {
    return new SpeechBubble(entity, text, null, GuiProperties.getDefaultFont());
}@Override
  public void update() {
    if (this.currentText == null) {
      this.hide();
      return;
    }

    this.entityCenter = Game.world().camera().getViewportLocation(this.getEntity().getCenter());

    // old text was displayed long enough
    if (this.lastTextDisplay != 0
        && Game.time().since(this.lastTextDisplay) > this.currentTextDisplayTime) {
      this.currentText = null;
      this.lastTextDisplay = 0;
      return;
    }

    // display new text
    if (this.textIndex < this.currentText.length()
        && Game.time().since(this.lastCharPoll) > LETTER_WRITE_DELAY) {
      this.textIndex++;
      this.lastCharPoll = Game.time().now();
      if (this.typeSound != null) {
        Game.audio().playSound(this.typeSound, this.getEntity());
      }
    }

    // continue displaying currently displayed text
}private SpeechBubble(
      final IEntity entity,
      final String text,
      final Sound typeSound,
      SpeechBubbleAppearance appearance,
      Font font) {
    this(entity, text, appearance, font);
    this.typeSound = typeSound;
}private SpeechBubble(
      final IEntity entity,
      final String text,
      @Nullable SpeechBubbleAppearance appearance,
      @Nullable Font font) {
    if (appearance == null) {
      this.appearance = DEFAULT_APPEARANCE;
    } else {
      this.appearance = appearance;
    }

    final SpeechBubble active = activeSpeechBubbles.get(entity);
    if (active != null) {
      active.hide();
    }
    this.setFont(font);

    this.textBoxWidth = (float) (entity.getWidth() * 4);
    this.entity = entity;

    this.currentText = text;
    this.currentTextDisplayTime = DISPLAYTIME_MIN + text.length() * DISPLAYTIME_PER_LETTER;

    this.lastTextDisplay = Game.time().now();
    this.createBubbleImage();
    entity.getEnvironment().add(this, RenderType.UI);
    Game.loop().attach(this);
    activeSpeechBubbles.put(entity, this);
}
}
```
```java
class de.gurkenlabs.litiengine.gui.TextFieldComponent {
@Override
  public void render(final Graphics2D g) {
    super.render(g);
    g.setFont(this.getFont());
    final FontMetrics fm = g.getFontMetrics();

    if (this.isSelected() && Game.time().since(this.lastToggled) > this.flickerDelay) {
      this.cursorVisible = !this.cursorVisible;
      this.lastToggled = Game.time().now();
    }
    if (this.isSelected() && this.cursorVisible) {
      final Rectangle2D cursor =
          new Rectangle2D.Double(
              this.getX() + this.getTextX() + fm.stringWidth(this.getTextToRender(g)),
              this.getY() + this.getTextY(),
              this.getFont().getSize2D() * 3 / 5,
              this.getFont().getSize2D() * 1 / 5);
      g.setColor(this.getAppearance().getForeColor());
      g.fill(cursor);
    }
}
}
```
```java
class de.gurkenlabs.litiengine.entities.Prop {
public Prop(
      final Point2D location, @Nullable final String spritesheetName, final Material material) {
    super();
    this.rotation = Rotation.NONE;
    this.spritesheetName = spritesheetName;
    this.material = material;
    this.setLocation(location);
    this.updateAnimationController();
}public void setSpritesheetName(@Nullable final String spriteName) {
    this.spritesheetName = spriteName;
    this.updateAnimationController();
}
}
```
```java
class de.gurkenlabs.litiengine.tweening.Tween {
public Tween begin() {
    this.started = Game.time().now();
    this.stopped = false;
    return this;
}
}
```
```java
class de.gurkenlabs.litiengine.graphics.emitters.particles.Particle {
public void update(final Point2D emitterOrigin, final float updateRatio) {
    if (this.aliveTick == 0) {
      this.aliveTick = Game.time().now();
    }

    this.aliveTime = Game.time().since(this.aliveTick);
    if (this.timeToLiveReached()) {
      return;
    }

    if (this.colliding) {
      return;
    }

    if (this.getDeltaWidth() != 0) {
      this.width += this.getDeltaWidth() * updateRatio;
    }

    if (this.getDeltaHeight() != 0) {
      this.height += this.getDeltaHeight() * updateRatio;
    }

    if (this.getDeltaAngle() != 0) {
      this.angle += this.getDeltaAngle() * updateRatio;
    }

    // test for ray cast collision
    final float targetX = this.x + this.getVelocityX() * updateRatio;
    final float targetY = this.y + this.getVelocityY() * updateRatio;

    if (targetX == this.x && targetY == this.y) {
      return;
    }

    if (this.checkForCollision(emitterOrigin, targetX, targetY)) {
      return;
    }

    if (this.getVelocityX() != 0) {
      this.x = targetX;
    }

    if (this.getVelocityY() != 0) {
      this.y = targetY;
    }

    if (this.getAccelerationX() != 0) {
      this.velocityX += this.getAccelerationX() * updateRatio;
    }

    if (this.getAccelerationY() != 0) {
      this.velocityY += this.getAccelerationY() * updateRatio;
    }
}
}
```
```java
class de.gurkenlabs.litiengine.graphics.animation.Animation {
@Override
  public void start() {
    this.playing = true;
    if (this.getKeyframes().isEmpty()) {
      return;
    }

    this.restart();
}@Override
  public void update() {
    // do nothing if the animation is not playing or the current keyframe is not finished
    if (!this.isPlaying()
        || Game.time().since(this.lastFrameUpdate) < this.getCurrentKeyFrame().getDuration()) {
      return;
    }

    // if we are not looping and the last keyframe is finished, we terminate the animation
    if (!this.isLooping() && this.isLastKeyFrame()) {
      this.terminate();
      return;
    }

    // make sure, we stay inside the keyframe list
    final int newFrameIndex =
        (this.getKeyframes().indexOf(this.currentFrame) + 1) % this.getKeyframes().size();
    final KeyFrame previousFrame = this.currentFrame;
    this.currentFrame = this.getKeyframes().get(newFrameIndex);

    for (KeyFrameListener listener : this.listeners) {
      listener.currentFrameChanged(previousFrame, this.currentFrame);
    }

    this.lastFrameUpdate = Game.loop().getTicks();
}
}
```
```java
class de.gurkenlabs.litiengine.graphics.animation.AnimationController {
@Override
  public void update() {
    for (final Animation animation : this.getAll()) {
      animation.update();
    }

    if (this.getCurrent() != null && this.getCurrent().isPaused()) {
      return;
    }

    final boolean playbackFinished = this.getCurrent() != null && !this.getCurrent().isPlaying();
    if (playbackFinished) {
      for (final AnimationListener listener : this.listeners) {
        listener.finished(this.getCurrent());
      }
    }

    if (this.getCurrent() == null || playbackFinished) {
      if (this.getDefault() != null) {
        this.play(this.getDefault().getName());
      } else {
        this.currentAnimation = null;
      }
    }
}
}
```
```java
class de.gurkenlabs.litiengine.graphics.RenderComponent {
private void handleFade() {
    if (this.fadeOutStart != -1) {
      final long timePassed = Game.time().since(this.fadeOutStart);
      this.currentAlpha = MathUtilities.clamp(1 - timePassed / (float) this.fadeOutTime, 0, 1);
      if (this.currentAlpha == 0f) {
        this.fadeOutStart = -1;
        this.fadeOutTime = -1;
      }

      return;
    }

    if (this.fadeInStart != -1) {
      final long timePassed = Game.time().since(this.fadeInStart);
      this.currentAlpha = MathUtilities.clamp(timePassed / (float) this.fadeInTime, 0, 1);
      if (this.currentAlpha == 1f) {
        this.fadeInStart = -1;
        this.fadeInTime = -1;
        this.currentAlpha = Float.NaN;
      }
    }
}public void fadeOut(final int ms) {
    this.fadeInStart = -1;
    this.fadeInTime = -1;
    this.fadeOutStart = Game.time().now();
    this.fadeOutTime = ms;
}public void fadeIn(final int ms) {
    this.fadeOutStart = -1;
    this.fadeOutTime = -1;
    this.fadeInStart = Game.time().now();
    this.fadeInTime = ms;
}
}
```
```java
class de.gurkenlabs.litiengine.entities.Trigger {
private boolean activate(final IEntity activator, final int tar) {
    if (!this.isLoaded()
        || this.isOneTimeTrigger && this.isActivated
        || this.getActivationType() == TriggerActivation.COLLISION
            && activator != null
            && this.collisionActivated.contains(activator)) {
      return false;
    }

    if (this.getCooldown() > 0 && Game.time().since(this.lastActivation) < this.getCooldown()) {
      return false;
    }

    List<Integer> triggerTargets = this.getTargets(tar);

    final TriggerEvent te = new TriggerEvent(this, activator, triggerTargets);

    if (!this.checkActivationPredicates(te)) {
      return false;
    }

    this.isActivated = true;
    if (activator != null) {
      this.collisionActivated.add(activator);
    }

    // if we actually have a trigger target, we send the message to the target
    for (final int target : triggerTargets) {
      final IEntity entity = this.getEnvironment().get(target);
      if (entity == null) {
        log.log(
            Level.WARNING,
            "trigger [{0}] was activated, but the trigger target [{1}] could not be found on the environment",
            new Object[] {this, target});
        continue;
      }

      entity.sendMessage(this, this.message);
    }

    // also send the trigger event to all registered consumers
    for (final TriggerActivatedListener listener : this.activatedListeners) {
      listener.activated(te);
    }

    if (this.isOneTimeTrigger) {
      this.getEnvironment().remove(this);
    }

    this.lastActivation = Game.time().now();
    return true;
}
}
```
```java
class de.gurkenlabs.litiengine.graphics.Camera {
private boolean isShakeEffectActive() {
    return this.getShakeTick() != 0
        && Game.time().since(this.getShakeTick()) < this.getShakeDuration();
}@Override
  public void update() {
    if (Game.world().camera() != null && !Game.world().camera().equals(this)) {
      return;
    }

    if (this.targetZoom > 0) {
      if (Game.time().since(this.zoomTick) >= this.zoomDelay) {
        this.zoom = this.targetZoom;
        this.targetZoom = 0;
        this.zoomDelay = 0;
        this.zoomTick = 0;
        this.zoomStep = 0;
      } else {
        this.zoom += this.zoomStep;
      }

      final ZoomChangedEvent event = new ZoomChangedEvent(this, this.getZoom());
      for (final ZoomChangedListener listener : this.zoomListeners) {
        listener.zoomChanged(event);
      }
    }

    if (this.panTime > 0) {
      if (--this.panTime <= 0) {
        this.setFocus(this.targetFocus);
        this.targetFocus = null;
      } else {
        double diff = this.panTime / (this.panTime + 1.0);
        this.focus =
            new Point2D.Double(
                this.focus.getX() * diff + this.targetFocus.getX() * (1.0 - diff),
                this.focus.getY() * diff + this.targetFocus.getY() * (1.0 - diff));
      }
    }

    if (!this.isShakeEffectActive()) {
      this.shakeOffsetX = 0;
      this.shakeOffsetY = 0;
      return;
    }

    if (Game.time().since(this.lastShake) > this.shakeDelay) {
      this.shakeOffsetX = this.getShakeIntensity() * ThreadLocalRandom.current().nextGaussian();
      this.shakeOffsetY = this.getShakeIntensity() * ThreadLocalRandom.current().nextGaussian();
      this.lastShake = Game.time().now();
    }
}@Override
  public void setZoom(final float targetZoom, final int delay) {
    if (delay == 0) {

      this.zoom = targetZoom;
      this.targetZoom = 0;
      this.zoomDelay = 0;
      this.zoomTick = 0;
      this.zoomStep = 0;

      final ZoomChangedEvent event = new ZoomChangedEvent(this, targetZoom);
      for (final ZoomChangedListener listener : this.zoomListeners) {
        listener.zoomChanged(event);
      }
    } else {
      this.zoomTick = Game.time().now();
      this.targetZoom = targetZoom;
      this.zoomDelay = delay;

      final double tickduration = 1000 / (double) Game.loop().getTickRate();
      final double tickAmount = delay / tickduration;
      final float totalDelta = this.targetZoom - this.zoom;
      this.zoomStep = tickAmount > 0 ? (float) (totalDelta / tickAmount) : totalDelta;
    }
}@Override
  public void shake(final double intensity, final int delay, final int shakeDuration) {
    this.shakeTick = Game.time().now();
    this.shakeDelay = delay;
    this.shakeIntensity = intensity;
    this.shakeDuration = shakeDuration;
}
}
```
```java
class de.gurkenlabs.litiengine.entities.Creature {
public void setSpritesheetName(String spritesheetName) {
    if (this.spritesheetName != null && this.spritesheetName.equals(spritesheetName)) {
      return;
    }

    this.spritesheetName = spritesheetName;
    this.updateAnimationController();
}public boolean isIdle() {
    return Game.time().since(this.lastMoved) > IDLE_DELAY;
}@Override
  public void setLocation(final Point2D position) {
    if (this.isDead() || position == null) {
      return;
    }

    final Point2D oldLocation = this.getLocation();
    super.setLocation(position);

    if (Game.hasStarted() && this.isLoaded()) {
      this.lastMoved = Game.time().now();
      this.fireMovedEvent(
          new EntityMovedEvent(
              this, this.getX() - oldLocation.getX(), this.getY() - oldLocation.getY()));
    }
}
}
```
```java
class de.gurkenlabs.litiengine.gui.screens.ScreenManager {
public void display(final String screenName) {
    if (this.current() != null && this.current().getName().equalsIgnoreCase(screenName)) {
      log.log(
          Level.INFO,
          "Skipping displaying of screen {0} because it is already the current screen.",
          screenName);
      return;
    }

    if (this.screens.stream()
        .noneMatch(element -> element.getName().equalsIgnoreCase(screenName))) {
      log.log(
          Level.WARNING,
          "Could not display the screen {0} because there is no screen with the specified name.",
          screenName);
      return;
    }

    Screen screen = this.get(screenName);
    if (screen == null) {
      return;
    }

    this.display(screen);
}public void add(final Screen screen) {
    screen.setWidth(Game.window().getWidth());
    screen.setHeight(Game.window().getHeight());
    this.screens.add(screen);

    if (this.current() == null) {
      this.display(screen);
    }
}public void remove(Screen screen) {
    this.screens.remove(screen);
    if (this.current() == screen) {
      if (!this.screens.isEmpty()) {
        this.display(this.screens.get(0));
      } else {
        this.display((Screen) null);
      }
    }
}public void display(@Nullable final Screen screen) {
    if (Game.hasStarted() && Game.time().since(this.lastScreenChange) < this.getChangeCooldown()) {
      log.log(
          Level.INFO,
          "Skipping displaying of screen {0} because screen changing is currently on cooldown.",
          screen != null ? screen.getName() : "");
      return;
    }

    final Screen previous = this.current();
    if (previous != null) {
      previous.suspend();
    }

    if (screen != null && !this.screens.contains(screen)) {
      this.screens.add(screen);
    }

    this.currentScreen = screen;
    if (!Game.isInNoGUIMode() && this.current() != null) {
      this.current().prepare();
    }

    this.lastScreenChange = Game.loop().getTicks();

    final ScreenChangedEvent event = new ScreenChangedEvent(this.current(), previous);
    for (final ScreenChangedListener listener : this.screenChangedListeners) {
      listener.changed(event);
    }
}
}
```
```java
class de.gurkenlabs.litiengine.abilities.Ability {
public boolean isOnCooldown() {
    return (this.getCurrentExecution() != null
        && this.getCurrentExecution().getExecutionTicks() > 0
        && Game.time().since(this.getCurrentExecution().getExecutionTicks())
            < this.getAttributes().cooldown().get());
}public boolean isActive() {
    return this.getCurrentExecution() != null
        && Game.time().since(this.getCurrentExecution().getExecutionTicks())
            < this.getAttributes().duration().get();
}@Nullable
  public AbilityExecution cast() {
    if (!this.canCast()) {
      return null;
    }
    this.currentExecution = new AbilityExecution(this);

    for (final AbilityCastListener listener : this.abilityCastListeners) {
      listener.abilityCast(this.currentExecution);
    }

    return this.getCurrentExecution();
}public float getRemainingCooldownInSeconds() {
    if (this.getCurrentExecution() == null
        || this.getExecutor() == null
        || this.getExecutor().isDead()) {
      return 0;
    }

    // calculate cooldown in seconds
    return (float)
        (!this.canCast()
            ? (this.getAttributes().cooldown().get()
                    - Game.time().since(this.getCurrentExecution().getExecutionTicks()))
                * 0.001
            : 0);
}
}
```
```java
class de.gurkenlabs.litiengine.entities.EntityHitEvent {
EntityHitEvent(
      final ICombatEntity hitEntity,
      @Nullable final Ability ability,
      final int damage,
      final boolean kill) {
    super(hitEntity);
    this.executor = ability != null ? ability.getExecutor() : null;
    this.hitEntity = hitEntity;
    this.ability = ability;
    this.damage = damage;
    this.kill = kill;
    this.time = Game.time().now();
}
}
```
```java
class de.gurkenlabs.litiengine.graphics.emitters.Emitter {
public void delete() {
    this.deactivate();
    if (Game.world().environment() != null) {
      Game.world().environment().remove(this);
    }
}public void activate() {
    if (this.activated) {
      return;
    }

    this.activated = true;
    this.activationTick = Game.time().now();
    Game.loop().attach(this);
}@Override
  public void update() {
    if (this.isPaused()) {
      return;
    }

    // clear particles if the effect time to life is reached
    if (this.isFinished()) {
      for (EmitterFinishedListener listener : this.finishedListeners) {
        listener.finished(this);
      }

      this.delete();
      return;
    }

    final float updateRatio = (float) this.data().getUpdateRate() / Game.loop().getTickRate();
    for (final Particle p : this.getParticles().stream().collect(Collectors.toList())) {
      if (this.particleCanBeRemoved(p)) {
        // remove dead particles
        this.particles.remove(p);
        continue;
      }

      p.update(this.getOrigin(), updateRatio);
    }

    this.aliveTime = Game.time().since(this.activationTick);
    if ((this.data().getSpawnRate() == 0
        || Game.time().since(this.lastSpawn) >= this.data().getSpawnRate())) {
      this.lastSpawn = Game.time().now();
      this.spawnParticle();
    }
}
}
```
```java
class de.gurkenlabs.litiengine.GameLoop {
@Override
  public int perform(int delay, Runnable action) {
    final long d = Game.time().toTicks(delay);

    TimedAction a = new TimedAction(this.getTicks() + d, action);
    this.actions.add(a);

    return a.getId();
}
}
```
```java
class de.gurkenlabs.litiengine.environment.EntitySpawner {
protected boolean shouldSpawn() {
    return this.lastSpawnWave == 0
        || Game.time().since(this.lastSpawnWave) >= this.getSpawnInterval();
}@Override
  public void update() {
    if (!this.shouldSpawn()) {
      return;
    }

    this.spawnNewEntities();
    this.lastSpawnWave = Game.time().now();
}
}
```
```java
class de.gurkenlabs.litiengine.graphics.FreeFlightCamera {
@Override
  public void update() {
    this.handleFreeFlightCamera();
}public FreeFlightCamera(double x, double y) {
    this(new Point2D.Double(x, y));
}
}
```
```java
class de.gurkenlabs.litiengine.environment.Environment {
public void unload() {
    if (!this.loaded) {
      return;
    }

    // unregister all updatable entities from the current environment
    for (final IEntity entity : this.allEntities.values()) {
      this.unload(entity);
    }

    this.loaded = false;
    this.fireEvent(l -> l.unloaded(this));
}private static void loadUpdatableOrEmitterEntity(IEntity entity) {
    if (entity instanceof Emitter) {
      final Emitter emitter = (Emitter) entity;
      if (emitter.isActivateOnInit()) {
        emitter.activate();
      }
    } else if (entity instanceof IUpdateable) {
      Game.loop().attach((IUpdateable) entity);
    }
}public void clear() {
    Game.physics().clear();

    this.combatEntities.clear();
    this.mobileEntities.clear();
    this.gravityForces.clear();
    this.layerEntities.clear();
    this.entitiesByTag.clear();
    this.allEntities.clear();

    for (RenderType renderType : RenderType.values()) {
      this.miscEntities.get(renderType).clear();
      this.renderListeners.get(renderType).clear();
      this.renderables.get(renderType).clear();
    }

    dispose(this.allEntities.values());
    dispose(this.triggers);
    this.emitters.clear();
    this.colliders.clear();
    this.props.clear();
    this.creatures.clear();
    this.staticShadows.clear();
    this.combatEntities.clear();
    this.mobileEntities.clear();
    this.lightSources.clear();
    this.spawnPoints.clear();
    this.soundSources.clear();
    this.mapAreas.clear();
    this.triggers.clear();

    this.ambientLight = null;
    this.staticShadowLayer = null;

    for (Map<Integer, IEntity> type : this.miscEntities.values()) {
      type.clear();
    }

    this.initialized = false;

    this.fireEvent(l -> l.cleared(this));
}private void load(final IEntity entity) {
    // an entity can only exist on one environment at a time, so remove it from the current one
    if (entity.getEnvironment() != null) {
      entity.getEnvironment().remove(entity);
    }

    // 1. add to physics engine
    loadPhysicsEntity(entity);

    // 2. register for update or activate
    loadUpdatableOrEmitterEntity(entity);

    // 3. if a gravity is defined, add a gravity force to the entity
    if (entity instanceof IMobileEntity && this.getGravity() != 0) {
      this.addGravityForce((IMobileEntity) entity);
    }

    // 4. attach all controllers
    entity.attachControllers();

    if (this.loaded && (entity instanceof LightSource || entity instanceof StaticShadow)) {
      this.updateLighting(entity);
    }

    entity.loaded(this);
}private void unload(final IEntity entity) {
    // 1. remove from physics engine
    if (entity instanceof ICollisionEntity) {
      Game.physics().remove((ICollisionEntity) entity);
    }

    // 2. unregister from update
    if (entity instanceof IUpdateable) {
      Game.loop().detach((IUpdateable) entity);
    }

    if (entity instanceof IMobileEntity) {
      this.removeGravity((IMobileEntity) entity);
    }

    // 3. detach all controllers
    entity.detachControllers();

    if (entity instanceof Emitter) {
      Emitter em = (Emitter) entity;
      em.deactivate();
    }

    if (this.loaded && (entity instanceof LightSource || entity instanceof StaticShadow)) {
      this.updateLighting(entity);
    }

    entity.removed(this);
}public void remove(final IEntity entity) {
    if (entity == null) {
      return;
    }

    this.allEntities.remove(entity.getMapId());
    Iterator<List<IEntity>> iter = this.layerEntities.values().iterator();
    while (iter.hasNext()) {
      List<IEntity> layer = iter.next();
      if (layer.remove(entity) && layer.isEmpty()) {
        iter.remove();
      }
    }
    if (this.miscEntities.get(entity.getRenderType()) != null) {
      this.miscEntities.get(entity.getRenderType()).values().remove(entity);
    }

    for (String tag : entity.getTags()) {
      if (this.getEntitiesByTag().containsKey(tag)) {
        this.getEntitiesByTag().get(tag).remove(entity);

        if (this.getEntitiesByTag().get(tag).isEmpty()) {
          this.getEntitiesByTag().remove(tag);
        }
      }
    }

    if (entity instanceof Emitter) {
      Emitter emitter = (Emitter) entity;
      this.removeEmitter(emitter);
    }

    if (entity instanceof MapArea) {
      this.mapAreas.remove(entity);
    }

    if (entity instanceof Prop) {
      this.props.remove(entity);
    }

    if (entity instanceof Creature) {
      this.creatures.remove(entity);
    }

    if (entity instanceof CollisionBox) {
      this.colliders.remove(entity);
      this.staticShadows.removeIf(x -> x.getOrigin() != null && x.getOrigin().equals(entity));
    }

    if (entity instanceof LightSource) {
      this.lightSources.remove(entity);
      this.updateLighting(entity);
    }

    if (entity instanceof Trigger) {
      this.triggers.remove(entity);
    }

    if (entity instanceof Spawnpoint) {
      this.spawnPoints.remove(entity);
    }
    if (entity instanceof SoundSource) {
      this.soundSources.remove(entity);
    }

    if (entity instanceof StaticShadow) {
      this.staticShadows.remove(entity);
      this.updateLighting(entity);
    }

    if (entity instanceof IMobileEntity) {
      this.mobileEntities.values().remove(entity);
    }

    if (entity instanceof ICombatEntity) {
      this.combatEntities.values().remove(entity);
    }

    this.unload(entity);

    this.fireEntityEvent(l -> l.entityRemoved(entity));
}
}
```
```java
class de.gurkenlabs.litiengine.physics.MovementController {
@Override
  public void update() {
    this.handleForces();
    this.handleMovement();
}
}
```
```java
class de.gurkenlabs.litiengine.Game {
static synchronized void terminate() {
    if (!initialized) {
      return;
    }

    hasStarted = false;
    initialized = false;

    config().save();
    gameLoop.terminate();
    tweenEngine.terminate();
    soundEngine.terminate();

    world().clear();

    for (final GameListener listener : gameListeners) {
      try {
        listener.terminated();
      } catch (Exception e) {
        log().log(Level.WARNING, "game listener threw an exception during shutdown", e);
      }
    }

    gameLoop = null;
    screenManager = null;
    gameWindow = null;
}public static synchronized void start() {
    if (!initialized) {
      throw new IllegalStateException(
          "The game cannot be started without being first initialized. Call Game.init(...) before Game.start().");
    }

    gameLoop.start();
    tweenEngine.start();
    soundEngine.start();

    for (final GameListener listener : gameListeners) {
      listener.started();
    }

    hasStarted = true;
}public static synchronized void init(String... args) {
    if (initialized) {
      log().log(Level.INFO, "The game has already been initialized.");
      return;
    }

    log.init();
    handleCommandLineArguments(args);

    config().load();
    Locale.setDefault(new Locale(config().client().getCountry(), config().client().getLanguage()));

    gameLoop = new GameLoop("Main Update Loop", config().client().getMaxFps());
    loop().attach(physics());
    loop().attach(world());

    // setup default exception handling for render and update loop
    setUncaughtExceptionHandler(
        new DefaultUncaughtExceptionHandler(config().client().exitOnError()));

    screenManager = new ScreenManager();
    gameWindow = new GameWindow();

    // initialize  the game window
    window().init();
    world.setCamera(new Camera());

    for (GameListener listener : gameListeners) {
      listener.initialized(args);
    }

    if (!isInNoGUIMode()) {
      window().getRenderComponent().onRendered(g -> metrics().render(g));

      graphics()
          .addEntityRenderedListener(
              e -> DebugRenderer.renderEntityDebugInfo(e.getGraphics(), e.getEntity()));

      window().getRenderComponent().onFpsChanged(fps -> metrics().setFramesPerSecond(fps));
      window()
          .setIcons(
              Arrays.asList(
                  Resources.images().get("liti-logo-x16.png"),
                  Resources.images().get("liti-logo-x20.png"),
                  Resources.images().get("liti-logo-x32.png"),
                  Resources.images().get("liti-logo-x48.png")));

      Input.keyboard()
          .onKeyTyped(
              KeyEvent.VK_PRINTSCREEN,
              key -> {
                // don't take a screenshot if a modifier is active
                if (key.getModifiers() != 0) {
                  return;
                }

                window().getRenderComponent().takeScreenshot();
              });
    }

    Runtime.getRuntime().addShutdownHook(new Thread(Game::terminate, "Shutdown"));

    initialized = true;
}
}
```


Response Format:
Provide the answer in **XML format** as follows:

#### If the method **cannot** return `null` at the specific call site:
```xml
<response>
  <reason><![CDATA[EXPLAIN WHY THE INVOCATION Game.loop() RESULT CANNOT BE NULL.]]></reason>
  <value>NO</value>
</response>

#### If the method can return null at the specific call site:
<response>
  <reason><![CDATA[EXPLAIN WHY THE INVOCATION Game.loop() RESULT CAN BE NULL.]]></reason>
  <value>YES</value>
</response>

#### If you are unsure or If there are any methods that directly or indirectly affect the return value and are not fully disclosed, request their declarations first, in the following format:
<response>
  <reason><![CDATA[EXPLAIN WHY THIS METHOD DECLARATION IS NECESSARY AND WHY YOU CANNOT MAKE A CONFIDENT DECISION WITHOUT IT]]></reason>
  <success>false</success>
  <methods>
    <method>methodName</method>
  </methods>
</response>

Additional Notes:
Be precise in your reasoning.
If a method’s return value depends on another method not provided, request its declaration before making a conclusion.
If the method can return null in this case but not in others, explain why it happens specifically for this call.

---ChatGPT.sendRequestToOpenAI---
Retrieving response from cache
---Response.<init>---
Creating Response:
```xml
<response>
  <reason><![CDATA[The method `Game.loop()` returns the static field `gameLoop`, which is initialized in the `Game.init(String... args)` method. In this method, a new `GameLoop` object is instantiated and assigned to `gameLoop`. Since `init()` must be called before `start()`, which is implied by the requirement of initializing the game, the `gameLoop` is guaranteed to be non-null during the lifetime of the game execution where `Game.loop()` is called. The absence of any code that could set `gameLoop` to null after its initialization ensures that `Game.loop()` cannot return null.]]></reason>
  <value>NO</value>
</response>
```
---Response.<init>---
Response created:
Disagreement: The method `Game.loop()` returns the static field `gameLoop`, which is initialized in the `Game.init(String... args)` method. In this method, a new `GameLoop` object is instantiated and assigned to `gameLoop`. Since `init()` must be called before `start()`, which is implied by the requirement of initializing the game, the `gameLoop` is guaranteed to be non-null during the lifetime of the game execution where `Game.loop()` is called. The absence of any code that could set `gameLoop` to null after its initialization ensures that `Game.loop()` cannot return null.
---AdvancedNullAwayCodeFix.resolveMethodDereferenceError---
Method is not returning nullable on call site. Injecting suppression annotation.
---AdvancedNullAwayCodeFix.constructCastToNonnullChange---
Constructing cast to nonnull change for reason: The method `Game.loop()` returns the static field `gameLoop`, which is initialized in the `Game.init(String... args)` method. In this method, a new `GameLoop` object is instantiated and assigned to `gameLoop`. Since `init()` must be called before `start()`, which is implied by the requirement of initializing the game, the `gameLoop` is guaranteed to be non-null during the lifetime of the game execution where `Game.loop()` is called. The absence of any code that could set `gameLoop` to null after its initialization ensures that `Game.loop()` cannot return null.
---ChatGPT.ask---
Asking ChatGPT:
For the reason you mentioned earlier:

"The method `Game.loop()` returns the static field `gameLoop`, which is initialized in the `Game.init(String... args)` method. In this method, a new `GameLoop` object is instantiated and assigned to `gameLoop`. Since `init()` must be called before `start()`, which is implied by the requirement of initializing the game, the `gameLoop` is guaranteed to be non-null during the lifetime of the game execution where `Game.loop()` is called. The absence of any code that could set `gameLoop` to null after its initialization ensures that `Game.loop()` cannot return null."

in the method below, the expression Game.loop() is not nullable at the point it is used.

```java
public void deactivate() {
    if (!this.activated) {
      return;
    }

    this.activated = false;
    this.getParticles().clear();
    this.aliveTime = 0;
    this.activationTick = 0;
    this.lastSpawn = 0;
    Game.loop().detach(this);
}
```
Please Summarize the reason in max 5 words and rewrite the method so that at the line "    Game.loop().detach(this);", at the occurrence of: "Game.loop()" is replaced with `NullabilityUtil.castToNonnull(Game.loop(), summary of reason)`
Replace "REASON" with the exact reason summary I provide to you (maximum 5 words), not with a generic explanation like "checked to be nonnull".
see the example below, for expression `foo.getBar()`, to wrap it with `NullabilityUtil.castToNonnull(foo.getBar(), "reason")`.

```java
public t(){
    String l = foo.getBar();
}
```

will be:
```java
public t(){
    String l = NullabilityUtil.castToNonnull(foo.getBar(), "checked to be nonnull");
}
```

### Instructions:

Do not import any additional classes.

Do not add Java comments.

Only modify relevant lines as required.

Return only the modified method wrapped in the XML format shown below.

Place the Java code inside the <code> tag using a CDATA block with ```java formatting.

Just give me the fixed code snippet in XML format in <response> tag like the example below. I will apply the fix to my codebase. Do not import any additional libraries or classes or add java comments. If you can provide the fixed code snippet, please provide it in the following format and place the code snippet in the <code> tag within ```java block.
<response>
  <success>true</success>
  <code><![CDATA[
  ```java
  Your fixed code snippet here
  ```
    ]]>
  </code>
</response>

---ChatGPT.sendRequestToOpenAI---
Sending request to OpenAI...
---ChatGPT.sendRequestToOpenAI---
Response received from OpenAI.
---Response.<init>---
Creating Response:
<response>
  <success>true</success>
  <code><![CDATA[
  ```java
  public void deactivate() {
      if (!this.activated) {
        return;
      }

      this.activated = false;
      this.getParticles().clear();
      this.aliveTime = 0;
      this.activationTick = 0;
      this.lastSpawn = 0;
      NullabilityUtil.castToNonnull(Game.loop(), "initialization guarantees non-null").detach(this);
  }
  ```
    ]]>
  </code>
</response>
---Response.<init>---
Response created:
public void deactivate() {
      if (!this.activated) {
        return;
      }

      this.activated = false;
      this.getParticles().clear();
      this.aliveTime = 0;
      this.activationTick = 0;
      this.lastSpawn = 0;
      NullabilityUtil.castToNonnull(Game.loop(), "initialization guarantees non-null").detach(this);
  }
---ChatGPT.fixDereferenceByAddingCastToNonnull---
Fixing the error by adding castToNonnull
---AdvancedNullAwayCodeFix.fixTriggeredErrorsForLocation---
Resolving unresolvable error for triggered error: Type='DEREFERENCE_NULLABLE', message='dereferenced expression Game.loop() is @Nullable'
/home/nima/Developer/nullness-benchmarks/litiengine/src/de/gurkenlabs/litiengine/graphics/animation/Animation.java:339
    this.lastFrameUpdate = Game.loop().getTicks();
---AdvancedNullAwayCodeFix.fix---
Fixing error: Type='DEREFERENCE_NULLABLE', message='dereferenced expression Game.loop() is @Nullable'
/home/nima/Developer/nullness-benchmarks/litiengine/src/de/gurkenlabs/litiengine/graphics/animation/Animation.java:339
    this.lastFrameUpdate = Game.loop().getTicks();
---AdvancedNullAwayCodeFix.resolveDereferenceError---
Resolving dereference error: Type='DEREFERENCE_NULLABLE', message='dereferenced expression Game.loop() is @Nullable'
/home/nima/Developer/nullness-benchmarks/litiengine/src/de/gurkenlabs/litiengine/graphics/animation/Animation.java:339
    this.lastFrameUpdate = Game.loop().getTicks();
---AdvancedNullAwayCodeFix.resolveDereferenceError---
Checking nullability possibility at error point
---ChatGPT.checkNullabilityPossibilityAtErrorPoint---
Asking if the expression can be null at error point point
---ChatGPT.ask---
Asking ChatGPT:
In the method below, is there a possibility that the expression "Game.loop()" at line "this.lastFrameUpdate = Game.loop().getTicks();" is null?
@Override
  public void update() {
    // do nothing if the animation is not playing or the current keyframe is not finished
    if (!this.isPlaying()
        || Game.time().since(this.lastFrameUpdate) < this.getCurrentKeyFrame().getDuration()) {
      return;
    }

    // if we are not looping and the last keyframe is finished, we terminate the animation
    if (!this.isLooping() && this.isLastKeyFrame()) {
      this.terminate();
      return;
    }

    // make sure, we stay inside the keyframe list
    final int newFrameIndex =
        (this.getKeyframes().indexOf(this.currentFrame) + 1) % this.getKeyframes().size();
    final KeyFrame previousFrame = this.currentFrame;
    this.currentFrame = this.getKeyframes().get(newFrameIndex);

    for (KeyFrameListener listener : this.listeners) {
      listener.currentFrameChanged(previousFrame, this.currentFrame);
    }

    this.lastFrameUpdate = Game.loop().getTicks();
}
Give a single-word answer in XML format. If it is possible for the expression to be null, respond with:
```xml
<response>
    <reason><![CDATA[YOUR REASON]]></reason>
    <value>YES</value>
</response>
```
If it is not possible for the expression to be null, respond with:
```xml
<response>
    <reason><![CDATA[YOUR REASON]]></reason>
    <value>NO</value>
</response>
```
If you are unsure or need more information, respond with where you can ask for more details or what specific information you need.

If additional information is required, list each request inside a `<request>` tag. If no additional information is needed, omit the `<requests>` section.

Respond with:
```xml
<response>
    <reason><![CDATA[YOUR REASON]]></reason>
    <value>UNKNOWN</value>
    <!-- Include <requests> only if additional information is needed -->
    <requests>
        <request><![CDATA[YOUR REQUEST 1]]></request>
        <request><![CDATA[YOUR REQUEST 2]]></request>
    </requests>
</response>
```
---ChatGPT.sendRequestToOpenAI---
Sending request to OpenAI...
---ChatGPT.sendRequestToOpenAI---
Response received from OpenAI.
---Response.<init>---
Creating Response:
```xml
<response>
    <reason><![CDATA[The possibility of "Game.loop()" being null depends on the implementation details of the Game class, which is not provided in the given context. Without knowing if the "loop()" method guarantees a non-null return value, it's not possible to make a definitive determination.]]></reason>
    <value>UNKNOWN</value>
    <requests>
        <request><![CDATA[Please provide the implementation of the Game class, specifically the loop() method.]]></request>
        <request><![CDATA[Information about any safeguards or conditions that ensure "Game.loop()" cannot return null.]]></request>
    </requests>
</response>
```
---Response.<init>---
Response created:
Unknown: The possibility of "Game.loop()" being null depends on the implementation details of the Game class, which is not provided in the given context. Without knowing if the "loop()" method guarantees a non-null return value, it's not possible to make a definitive determination.
---AdvancedNullAwayCodeFix.resolveMethodDereferenceError---
Resolving method dereference error.
---AdvancedNullAwayCodeFix.resolveMethodDereferenceError---
Method is in annotated package. Checking if the method is returning nullable.
---AdvancedNullAwayCodeFix.investigateMethodReturnNullability---
Checking if the method is returning nullable.
---ChatGPT.checkIfMethodIsReturningNullable---
Asking if the method is returning nullable: loop()
---ChatGPT.ask---
Asking ChatGPT:
In the method below, is there a possibility that the method returns null based only on its body? Consider the following points:

- The method may have multiple return paths; consider all return statements.
- If the method calls another method, do not assume its return value unless its full declaration is provided. Request its declaration if needed.
- The method may throw an exception instead of returning null. An exception path should not be considered a null return.
- Ensure you request the declarations of any methods whose return values directly or indirectly impact this method’s return value before making a conclusion.
- Carefully analyze all conditions and prior operations that may guarantee a non-null return value.

@Nullable public static IGameLoop loop() {
    return gameLoop;
}

Here are the method definitions in addition to the method inquired:

Depth: 0
```java
class de.gurkenlabs.litiengine.Game {
@Nullable public static IGameLoop loop() {
    return gameLoop;
}
}
```


Response Format:
Provide the answer in **XML format** as follows:

#### If the method **cannot** return `null`:
```xml
<response>
  <reason><![CDATA[EXPLAIN WHY THE METHOD CANNOT RETURN NULL]]></reason>
  <value>NO</value>
</response>
```

#### If the method can return null:
```xml
<response>
  <reason><![CDATA[EXPLAIN WHY THE METHOD CAN RETURN NULL]]></reason>
  <value>YES</value>
</response>
```

#### If you are unsure or need more information, respond with where you can ask for more details or what specific information you need.

#### If you are unsure or If there are any methods that directly or indirectly affect the return value and are not fully disclosed, request their declarations first, in the following format:
<response>
  <reason><![CDATA[YOUR REASON]]></reason>
  <value>UNKNOWN</value>
  <methods>
    <method>methodName</method>
  </methods>
</response>

If additional information is required other than method declaration, list each request inside a `<request>` tag. If no additional information is needed, omit the `<requests>` section.

Respond with:
```xml
<response>
    <reason><![CDATA[YOUR REASON]]></reason>
    <value>UNKNOWN</value>
    <!-- Include <requests> only if additional information is needed -->
    <requests>
        <request><![CDATA[YOUR REQUEST 1]]></request>
        <request><![CDATA[YOUR REQUEST 2]]></request>
    </requests>
</response>
```

Additional Notes:
Be precise in your reasoning.
If a method’s return value depends on another method not provided, request its declaration before making a conclusion.
If the method can return null in some cases but not others, explain under what conditions it can happen.

---ChatGPT.sendRequestToOpenAI---
Retrieving response from cache
---Response.<init>---
Creating Response:
```xml
<response>
  <reason><![CDATA[The method `loop` returns the variable `gameLoop`. Without the initialization or assignment details of `gameLoop`, it's unclear whether it can be null. The possibility of `gameLoop` being uninitialized or set to null elsewhere in the program means `loop` could potentially return null. Further information on `gameLoop` is required.]]></reason>
  <value>UNKNOWN</value>
  <requests>
    <request><![CDATA[Please provide the declaration and initialization of the variable `gameLoop` in the class `de.gurkenlabs.litiengine.Game`.]]></request>
  </requests>
</response>
```
---Response.<init>---
Response created:
Unknown: The method `loop` returns the variable `gameLoop`. Without the initialization or assignment details of `gameLoop`, it's unclear whether it can be null. The possibility of `gameLoop` being uninitialized or set to null elsewhere in the program means `loop` could potentially return null. Further information on `gameLoop` is required.
---AdvancedNullAwayCodeFix.investigateMethodReturnNullability---
Could not determine the nullability and model did not ask for any method.
---ChatGPT.checkIfMethodIsReturningNullableOnCallSite---
Asking if the method is returning nullable on the call site: Game.loop()
---ChatGPT.ask---
Asking ChatGPT:
In the method below, is there a possibility that the method returns null at the given call site?

```java
@Nullable public static IGameLoop loop() {
    return gameLoop;
}
```

## Guidelines:
- The method may have multiple return paths; consider all return statements.
- If the method calls another method, do not assume its return value unless its full declaration is provided. Request its declaration if needed.
- The method may throw an exception instead of returning null. An exception path should not be considered a null return.
- Ensure you request the declarations of any methods whose return values directly or indirectly impact this method’s return value before making a conclusion.
- If the method returns a value that is determined by a parameter, evaluate based on the actual argument at the given call site.
- Analyze based only on the specific invocation provided. Do not generalize to all possible inputs.- If the return value is guaranteed to be non-null at the call site, the answer should be a definitive NO.
- Do not generalize based on all possible inputs—your answer must be based only on the given invocation.
- Focus only on the given call site, not all possible invocations.

### call site:
Game.loop()

Here are the method definitions and the call chain for this method, showing the sequence of calls from the method to its callers at each depth level:

Depth: 0
```java
class de.gurkenlabs.litiengine.Game {
@Nullable public static IGameLoop loop() {
    return gameLoop;
}
}
```
Depth: 1
```java
class de.gurkenlabs.litiengine.environment.GameWorld {
public void loadEnvironment(@Nullable final Environment env) {
    Lock lock = Game.loop().getLock();
    lock.lock();
    try {
      unloadEnvironment();
      this.environment = env;
      if (env != null) {
        this.addEnvironment(env);

        if (env.getGravity() == 0 && this.gravity() != 0) {
          env.setGravity(this.gravity());
        }

        env.load();
        for (final EnvironmentLoadedListener listener : this.loadedListeners) {
          listener.loaded(env);
        }

        // call map specific listeners
        String mapName = getMapName(env);
        if (mapName != null && this.environmentLoadedListeners.containsKey(mapName)) {

          // for the default camera we center the camera on the environment
          if (this.camera().getClass().equals(Camera.class)) {
            camera().setFocus(env.getCenter());
          }

          for (EnvironmentLoadedListener listener : this.environmentLoadedListeners.get(mapName)) {
            listener.loaded(env);
          }
        }
      }
    } finally {
      lock.unlock();
    }
}public void setCamera(@Nullable final ICamera cam) {
    if (this.camera() != null) {
      Game.loop().detach(camera);
    }

    camera = cam;

    if (cam != null && !Game.isInNoGUIMode()) {
      Game.loop().attach(cam);
      cam.updateFocus();
    }
}
}
```
```java
class de.gurkenlabs.litiengine.entities.behavior.EntityNavigator {
public EntityNavigator(final IMobileEntity entity, final PathFinder pathFinder) {
    this.cancelNavigationConditions = new CopyOnWriteArrayList<>();
    this.listeners = new CopyOnWriteArrayList<>();
    this.entity = entity;
    this.pathFinder = pathFinder;
    this.setAcceptableError(DEFAULT_ACCEPTABLE_ERROR);
    Game.loop().attach(this);
}
}
```
```java
class de.gurkenlabs.litiengine.GameWindow {
private static void initializeWindowEventListeners(Window window) {

    window.addWindowStateListener(
        e -> {
          if (e.getNewState() == Frame.ICONIFIED) {
            Game.loop().setTickRate(ICONIFIED_MAX_FPS);
          } else {
            Game.loop().setTickRate(Game.config().client().getMaxFps());
          }
        });

    window.addWindowFocusListener(
        new WindowFocusListener() {
          @Override
          public void windowLostFocus(WindowEvent e) {
            if (Game.config().graphics().reduceFramesWhenNotFocused()) {
              Game.loop().setTickRate(NONE_FOCUS_MAX_FPS);
            }
          }

          @Override
          public void windowGainedFocus(WindowEvent e) {
            Game.loop().setTickRate(Game.config().client().getMaxFps());
          }
        });

    window.addWindowListener(
        new WindowAdapter() {
          @Override
          public void windowClosing(final WindowEvent event) {
            Game.exit();
          }
        });
}
}
```
```java
class de.gurkenlabs.litiengine.gui.screens.ScreenManager {
public void display(@Nullable final Screen screen) {
    if (Game.hasStarted() && Game.time().since(this.lastScreenChange) < this.getChangeCooldown()) {
      log.log(
          Level.INFO,
          "Skipping displaying of screen {0} because screen changing is currently on cooldown.",
          screen != null ? screen.getName() : "");
      return;
    }

    final Screen previous = this.current();
    if (previous != null) {
      previous.suspend();
    }

    if (screen != null && !this.screens.contains(screen)) {
      this.screens.add(screen);
    }

    this.currentScreen = screen;
    if (!Game.isInNoGUIMode() && this.current() != null) {
      this.current().prepare();
    }

    this.lastScreenChange = Game.loop().getTicks();

    final ScreenChangedEvent event = new ScreenChangedEvent(this.current(), previous);
    for (final ScreenChangedListener listener : this.screenChangedListeners) {
      listener.changed(event);
    }
}
}
```
```java
class de.gurkenlabs.litiengine.abilities.effects.Effect {
@Override
  public void update() {

    for (final Iterator<EffectApplication> iterator = this.getActiveAppliances().iterator();
        iterator.hasNext(); ) {
      final EffectApplication appliance = iterator.next();
      // if the effect duration is reached
      if (this.hasEnded(appliance)) {

        iterator.remove();
        this.cease(appliance);
      }
    }

    // 4. unregister if all appliances are finished
    if (this.getActiveAppliances().isEmpty()) {
      Game.loop().detach(this);
    }
}public void apply(final Shape impactArea) {
    final List<ICombatEntity> affected = this.lookForAffectedEntities(impactArea);
    for (final ICombatEntity affectedEntity : affected) {
      this.apply(affectedEntity);
    }

    this.appliances.add(new EffectApplication(affected, impactArea));

    // if it is the first appliance -> register for update
    if (this.appliances.size() == 1) {
      Game.loop().attach(this);
    }
}
}
```
```java
class de.gurkenlabs.litiengine.GameTime {
public long toTicks(final int milliseconds) {
    return this.toTicks(milliseconds, Game.loop().getTickRate());
}public long since(final long tick) {
    return toMilliseconds(Game.loop().getTicks() - tick);
}public long now() {
    return Game.loop().getTicks();
}public long sinceGameStart() {
    return this.toMilliseconds(Game.loop().getTicks());
}@Override
  public void loaded(Environment environment) {
    environmentLoaded = Game.loop().getTicks();
}public long toMilliseconds(final long ticks) {
    return this.toMilliseconds(ticks, Game.loop().getTickRate());
}
}
```
```java
class de.gurkenlabs.litiengine.GameMetrics {
@Override
  public void render(final Graphics2D g) {
    this.updateMetrics();

    if (!Game.config().client().showGameMetrics()) {
      return;
    }

    this.currentOffsetY = 0;

    g.setColor(this.renderColor);

    // render client metrics
    this.drawTitle(g, "[client]");
    this.drawMetric(g, "fps       : " + this.getFramesPerSecond());
    this.drawMetric(g, "max fps   : " + this.maxFramesPerSecond);
    this.drawMetric(g, "updatables: " + Game.loop().getUpdatableCount());

    // render jvm metrics if debug is enabled
    if (Game.config().debug().isDebugEnabled()) {
      this.drawTitle(g, "[jvm]");
      this.drawMetric(g, "java      : " + this.javaVersion);
      this.drawMetric(g, "memory    : " + String.format("%-5.5s", this.usedMemory) + " MB");
      this.drawMetric(g, "threads   : " + Thread.activeCount());
    }

    // render rendering metrics
    if (!this.renderMetrics.isEmpty()) {
      this.drawTitle(g, "[update]");

      for (RenderMetrics metric : this.renderMetrics) {
        this.drawMetric(g, metric.toString());
      }

      this.renderMetrics.clear();
    }
}
}
```
```java
class de.gurkenlabs.litiengine.graphics.emitters.Emitter {
public void deactivate() {
    if (!this.activated) {
      return;
    }

    this.activated = false;
    this.getParticles().clear();
    this.aliveTime = 0;
    this.activationTick = 0;
    this.lastSpawn = 0;
    Game.loop().detach(this);
}public void activate() {
    if (this.activated) {
      return;
    }

    this.activated = true;
    this.activationTick = Game.time().now();
    Game.loop().attach(this);
}@Override
  public void update() {
    if (this.isPaused()) {
      return;
    }

    // clear particles if the effect time to life is reached
    if (this.isFinished()) {
      for (EmitterFinishedListener listener : this.finishedListeners) {
        listener.finished(this);
      }

      this.delete();
      return;
    }

    final float updateRatio = (float) this.data().getUpdateRate() / Game.loop().getTickRate();
    for (final Particle p : this.getParticles().stream().collect(Collectors.toList())) {
      if (this.particleCanBeRemoved(p)) {
        // remove dead particles
        this.particles.remove(p);
        continue;
      }

      p.update(this.getOrigin(), updateRatio);
    }

    this.aliveTime = Game.time().since(this.activationTick);
    if ((this.data().getSpawnRate() == 0
        || Game.time().since(this.lastSpawn) >= this.data().getSpawnRate())) {
      this.lastSpawn = Game.time().now();
      this.spawnParticle();
    }
}
}
```
```java
class de.gurkenlabs.litiengine.entities.behavior.IBehaviorController {
public default void attach() {
    Game.loop().attach(this);
}public default void detach() {
    Game.loop().detach(this);
}
}
```
```java
class de.gurkenlabs.litiengine.abilities.AbilityExecution {
AbilityExecution(final Ability ability) {
    this.appliedEffects = new CopyOnWriteArrayList<>();
    this.ability = ability;
    this.executionTicks = Game.time().now();
    this.impactArea = ability.calculateImpactArea();
    this.castLocation = ability.getExecutor().getCenter();
    Game.loop().attach(this);
}@Override
  public void update() {
    // if there a no effects to apply -> unregister this instance and we're done
    if (this.getAbility().getEffects().isEmpty()
        || this.getAbility().getEffects().size() == this.getAppliedEffects().size()) {
      Game.loop().detach(this);
      return;
    }

    // handle all effects from the ability that were not applied yet
    for (final Effect effect : this.getAbility().getEffects()) {
      // if the ability was not executed yet or the delay of the effect is not
      // yet reached
      if (this.getAppliedEffects().contains(effect)
          || Game.time().since(this.getExecutionTicks()) < effect.getDelay()) {
        continue;
      }

      effect.apply(this.getExecutionImpactArea());
      this.getAppliedEffects().add(effect);
    }
}
}
```
```java
class de.gurkenlabs.litiengine.GameWindow$3 {
@Override
          public void windowGainedFocus(WindowEvent e) {
            Game.loop().setTickRate(Game.config().client().getMaxFps());
}@Override
          public void windowLostFocus(WindowEvent e) {
            if (Game.config().graphics().reduceFramesWhenNotFocused()) {
              Game.loop().setTickRate(NONE_FOCUS_MAX_FPS);
            }
}
}
```
```java
class de.gurkenlabs.litiengine.environment.EntitySpawner {
protected void spawnNewEntities() {
    if (this.getSpawnMode() != SpawnMode.CUSTOMSPAWNPOINTS && this.getSpawnPoints().isEmpty()) {
      return;
    }

    switch (this.getSpawnMode()) {
      case ALLSPAWNPOINTS:
        for (int i = 0; i < this.getSpawnPoints().size(); i++) {
          final int index = i;
          Game.loop()
              .perform(
                  this.getSpawnDelay() + this.getSpawnDelay() * i,
                  () -> this.spawn(this.getSpawnPoints().get(index), this.getSpawnAmount()));
        }
        break;
      case ONERANDOMSPAWNPOINT:
        this.spawn(Game.random().choose(this.getSpawnPoints()), this.getSpawnAmount());
        break;
      case RANDOMSPAWNPOINTS:
        for (int i = 0; i < this.getSpawnAmount(); i++) {
          Game.loop()
              .perform(
                  this.getSpawnDelay() + this.getSpawnDelay() * i,
                  () -> this.spawn(Game.random().choose(this.getSpawnPoints()), 1));
        }
        break;
      case CUSTOMSPAWNPOINTS:
        List<Spawnpoint> spawnPoints =
            this.customSpawnpoints != null
                ? this.customSpawnpoints.apply(this)
                : this.getCustomSpawnpoints();

        int index = 0;
        for (Spawnpoint spawn : spawnPoints) {
          Game.loop()
              .perform(
                  this.getSpawnDelay() + this.getSpawnDelay() * index, () -> this.spawn(spawn, 1));
          index++;
        }
        break;
      default:
        break;
    }
}
}
```
```java
class de.gurkenlabs.litiengine.tweening.TweenEngine {
@Override
  public void start() {
    Game.loop().attach(this);
}@Override
  public void terminate() {
    Game.loop().detach(this);
}
}
```
```java
class de.gurkenlabs.litiengine.gui.SpeechBubble {
public void hide() {
    Game.world().environment().removeRenderable(this);
    Game.loop().detach(this);
    if (activeSpeechBubbles.get(this.getEntity()) != null
        && activeSpeechBubbles.remove(this.getEntity()).equals(this)) {
      activeSpeechBubbles.remove(this.getEntity());
    }

    for (SpeechBubbleListener listener : this.listeners) {
      listener.hidden();
    }
}private SpeechBubble(
      final IEntity entity,
      final String text,
      @Nullable SpeechBubbleAppearance appearance,
      @Nullable Font font) {
    if (appearance == null) {
      this.appearance = DEFAULT_APPEARANCE;
    } else {
      this.appearance = appearance;
    }

    final SpeechBubble active = activeSpeechBubbles.get(entity);
    if (active != null) {
      active.hide();
    }
    this.setFont(font);

    this.textBoxWidth = (float) (entity.getWidth() * 4);
    this.entity = entity;

    this.currentText = text;
    this.currentTextDisplayTime = DISPLAYTIME_MIN + text.length() * DISPLAYTIME_PER_LETTER;

    this.lastTextDisplay = Game.time().now();
    this.createBubbleImage();
    entity.getEnvironment().add(this, RenderType.UI);
    Game.loop().attach(this);
    activeSpeechBubbles.put(entity, this);
}
}
```
```java
class de.gurkenlabs.litiengine.entities.Prop {
private void updateAnimationController() {
    IEntityAnimationController<?> controller = this.createAnimationController();
    this.getControllers().addController(controller);
    if (Game.world().environment() != null && Game.world().environment().isLoaded()) {
      Game.loop().attach(controller);
    }
}
}
```
```java
class de.gurkenlabs.litiengine.graphics.FreeFlightCamera {
public FreeFlightCamera(final Point2D focus) {
    this.setFocus(focus);
    this.velocity = DEFAULT_SCROLL_PIXELS_PER_SECOND;
    this.scrollPadding = DEFAULT_SCROLL_PADDING;
    this.setClampToMap(true);

    Game.loop().attach(this);
}private void handleFreeFlightCamera() {
    if (Game.world().environment() == null || Game.world().environment().getMap() == null) {
      return;
    }

    final Point2D mouseLocation = Input.mouse().getLocation();

    final double scrollSpeed =
        this.getVelocity()
            / (double) Game.loop().getTickRate()
            * Game.config().input().getMouseSensitivity();

    double x = this.getFocus().getX();
    double y = this.getFocus().getY();

    double deltaX = 0;
    if (mouseLocation.getX() < this.getScrollPadding()) {
      deltaX -= scrollSpeed;
    } else if (Game.window().getResolution().getWidth() - mouseLocation.getX()
        < this.getScrollPadding()) {
      deltaX += scrollSpeed;
    }

    double deltaY = 0;
    if (mouseLocation.getY() < this.getScrollPadding()) {
      deltaY -= scrollSpeed;
    } else if (Game.window().getResolution().getHeight() - mouseLocation.getY()
        < this.getScrollPadding()) {
      deltaY += scrollSpeed;
    }

    x += deltaX;
    y += deltaY;

    this.setFocus(new Point2D.Double(x, y));
}
}
```
```java
class de.gurkenlabs.litiengine.environment.Environment {
private static void dispose(final Collection<? extends IEntity> entities) {
    for (final IEntity entity : entities) {
      if (entity instanceof IUpdateable) {
        Game.loop().detach((IUpdateable) entity);
      }

      entity.detachControllers();
    }
}private static void loadUpdatableOrEmitterEntity(IEntity entity) {
    if (entity instanceof Emitter) {
      final Emitter emitter = (Emitter) entity;
      if (emitter.isActivateOnInit()) {
        emitter.activate();
      }
    } else if (entity instanceof IUpdateable) {
      Game.loop().attach((IUpdateable) entity);
    }
}private void unload(final IEntity entity) {
    // 1. remove from physics engine
    if (entity instanceof ICollisionEntity) {
      Game.physics().remove((ICollisionEntity) entity);
    }

    // 2. unregister from update
    if (entity instanceof IUpdateable) {
      Game.loop().detach((IUpdateable) entity);
    }

    if (entity instanceof IMobileEntity) {
      this.removeGravity((IMobileEntity) entity);
    }

    // 3. detach all controllers
    entity.detachControllers();

    if (entity instanceof Emitter) {
      Emitter em = (Emitter) entity;
      em.deactivate();
    }

    if (this.loaded && (entity instanceof LightSource || entity instanceof StaticShadow)) {
      this.updateLighting(entity);
    }

    entity.removed(this);
}
}
```
```java
class de.gurkenlabs.litiengine.graphics.animation.Animation {
@Override
  public void update() {
    // do nothing if the animation is not playing or the current keyframe is not finished
    if (!this.isPlaying()
        || Game.time().since(this.lastFrameUpdate) < this.getCurrentKeyFrame().getDuration()) {
      return;
    }

    // if we are not looping and the last keyframe is finished, we terminate the animation
    if (!this.isLooping() && this.isLastKeyFrame()) {
      this.terminate();
      return;
    }

    // make sure, we stay inside the keyframe list
    final int newFrameIndex =
        (this.getKeyframes().indexOf(this.currentFrame) + 1) % this.getKeyframes().size();
    final KeyFrame previousFrame = this.currentFrame;
    this.currentFrame = this.getKeyframes().get(newFrameIndex);

    for (KeyFrameListener listener : this.listeners) {
      listener.currentFrameChanged(previousFrame, this.currentFrame);
    }

    this.lastFrameUpdate = Game.loop().getTicks();
}public void restart() {
    this.currentFrame = this.firstFrame;
    this.lastFrameUpdate = Game.loop().getTicks();
}
}
```
```java
class de.gurkenlabs.litiengine.physics.MovementController {
@Override
  public void attach() {
    Game.loop().attach(this);
}private void handleForces() {
    // clean up forces
    this.activeForces.forEach(
        x -> {
          if (x.hasEnded()) {
            this.activeForces.remove(x);
          }
        });

    if (this.activeForces.isEmpty()) {
      return;
    }

    // disable turn-on-move for force handling
    boolean turn = this.getEntity().turnOnMove();
    this.getEntity().setTurnOnMove(false);
    try {
      double deltaX = 0;
      double deltaY = 0;
      for (final Force force : this.activeForces) {
        if (force.cancelOnReached() && force.hasReached(this.getEntity())) {
          force.end();
          continue;
        }

        final Point2D collisionBoxCenter = this.getEntity().getCollisionBoxCenter();
        final double angle =
            GeometricUtilities.calcRotationAngleInDegrees(collisionBoxCenter, force.getLocation());
        final double strength =
            Game.loop().getDeltaTime() * 0.001f * force.getStrength() * Game.loop().getTimeScale();
        deltaX += GeometricUtilities.getDeltaX(angle, strength);
        deltaY += GeometricUtilities.getDeltaY(angle, strength);
      }

      final Point2D target =
          new Point2D.Double(this.getEntity().getX() + deltaX, this.getEntity().getY() + deltaY);
      final boolean success = Game.physics().move(this.getEntity(), target);
      if (!success) {
        for (final Force force : this.activeForces) {
          if (force.cancelOnCollision()) {
            force.end();
          }
        }
      }
    } finally {
      this.getEntity().setTurnOnMove(turn);
    }
}@Override
  public void detach() {
    Game.loop().detach(this);
}public void handleMovement() {
    if (!this.isMovementAllowed()) {
      this.velocity = 0;
      return;
    }

    // max distance an entity can travel within one tick
    final double maxPixelsPerTick = this.getEntity().getTickVelocity();
    final double deltaTime = Game.loop().getDeltaTime() * Game.loop().getTimeScale();

    final double acceleration =
        this.getEntity().getAcceleration() == 0
            ? maxPixelsPerTick
            : deltaTime / this.getEntity().getAcceleration() * maxPixelsPerTick;
    final double deceleration =
        this.getEntity().getDeceleration() == 0
            ? this.getVelocity()
            : deltaTime / this.getEntity().getDeceleration() * maxPixelsPerTick;

    double dx = this.getDx();
    double dy = this.getDy();
    this.setDx(0);
    this.setDy(0);

    final double deltaVelocity =
        Math.min(Math.sqrt(Math.pow(dx, 2) + Math.pow(dy, 2)), acceleration);
    if (deltaVelocity != 0) {
      double newVelocity = this.getVelocity() + deltaVelocity;
      this.setVelocity(newVelocity);
    } else {
      final double newVelocity = Math.max(0, this.getVelocity() - deceleration);
      this.setVelocity(newVelocity);
      dx = GeometricUtilities.getDeltaX(this.moveAngle);
      dy = GeometricUtilities.getDeltaY(this.moveAngle);
    }

    if (this.getVelocity() == 0) {
      this.moveAngle = 0;
      return;
    }

    // actually move entity
    this.moveEntity(dx, dy);
}
}
```
```java
class de.gurkenlabs.litiengine.graphics.animation.AnimationController {
public void detach() {
    Game.loop().detach(this);
}public void attach() {
    Game.loop().attach(this);
}
}
```
```java
class de.gurkenlabs.litiengine.graphics.Camera {
@Override
  public void setZoom(final float targetZoom, final int delay) {
    if (delay == 0) {

      this.zoom = targetZoom;
      this.targetZoom = 0;
      this.zoomDelay = 0;
      this.zoomTick = 0;
      this.zoomStep = 0;

      final ZoomChangedEvent event = new ZoomChangedEvent(this, targetZoom);
      for (final ZoomChangedListener listener : this.zoomListeners) {
        listener.zoomChanged(event);
      }
    } else {
      this.zoomTick = Game.time().now();
      this.targetZoom = targetZoom;
      this.zoomDelay = delay;

      final double tickduration = 1000 / (double) Game.loop().getTickRate();
      final double tickAmount = delay / tickduration;
      final float totalDelta = this.targetZoom - this.zoom;
      this.zoomStep = tickAmount > 0 ? (float) (totalDelta / tickAmount) : totalDelta;
    }
}
}
```
```java
class de.gurkenlabs.litiengine.Game {
public static synchronized void init(String... args) {
    if (initialized) {
      log().log(Level.INFO, "The game has already been initialized.");
      return;
    }

    log.init();
    handleCommandLineArguments(args);

    config().load();
    Locale.setDefault(new Locale(config().client().getCountry(), config().client().getLanguage()));

    gameLoop = new GameLoop("Main Update Loop", config().client().getMaxFps());
    loop().attach(physics());
    loop().attach(world());

    // setup default exception handling for render and update loop
    setUncaughtExceptionHandler(
        new DefaultUncaughtExceptionHandler(config().client().exitOnError()));

    screenManager = new ScreenManager();
    gameWindow = new GameWindow();

    // initialize  the game window
    window().init();
    world.setCamera(new Camera());

    for (GameListener listener : gameListeners) {
      listener.initialized(args);
    }

    if (!isInNoGUIMode()) {
      window().getRenderComponent().onRendered(g -> metrics().render(g));

      graphics()
          .addEntityRenderedListener(
              e -> DebugRenderer.renderEntityDebugInfo(e.getGraphics(), e.getEntity()));

      window().getRenderComponent().onFpsChanged(fps -> metrics().setFramesPerSecond(fps));
      window()
          .setIcons(
              Arrays.asList(
                  Resources.images().get("liti-logo-x16.png"),
                  Resources.images().get("liti-logo-x20.png"),
                  Resources.images().get("liti-logo-x32.png"),
                  Resources.images().get("liti-logo-x48.png")));

      Input.keyboard()
          .onKeyTyped(
              KeyEvent.VK_PRINTSCREEN,
              key -> {
                // don't take a screenshot if a modifier is active
                if (key.getModifiers() != 0) {
                  return;
                }

                window().getRenderComponent().takeScreenshot();
              });
    }

    Runtime.getRuntime().addShutdownHook(new Thread(Game::terminate, "Shutdown"));

    initialized = true;
}
}
```
```java
class de.gurkenlabs.litiengine.entities.Creature {
protected void updateAnimationController() {
    IEntityAnimationController<?> controller = this.createAnimationController();
    this.getControllers().addController(controller);
    if (Game.world().environment() != null && Game.world().environment().isLoaded()) {
      Game.loop().attach(controller);
    }
}@Override
  public float getTickVelocity() {
    // pixels per ms multiplied by the passed ms
    // ensure that entities don't travel too far in case of lag
    return Math.min(Game.loop().getDeltaTime(), GameLoop.TICK_DELTATIME_LAG)
        * 0.001F
        * this.getVelocity().get()
        * Game.loop().getTimeScale();
}
}
```
Depth: 2
```java
class de.gurkenlabs.litiengine.environment.GameWorld {
public void clear() {
    this.unloadEnvironment();
    this.environments.clear();
    this.setCamera(null);
    Game.physics().clear();

    this.environmentListeners.clear();
    this.environmentLoadedListeners.clear();
    this.environmentUnloadedListeners.clear();

    this.listeners.clear();
    this.loadedListeners.clear();
    this.unloadedListeners.clear();
}@Nullable
  public Environment loadEnvironment(IMap map) {
    Environment env = this.getEnvironment(map);
    this.loadEnvironment(env);
    return env;
}@Nullable
  public Environment loadEnvironment(String mapName) {
    Environment env = this.getEnvironment(mapName);
    this.loadEnvironment(env);
    return env;
}
}
```
```java
class de.gurkenlabs.litiengine.GameWindow {
GameWindow() {
    this.hostControl = new JFrame();

    this.resolutionChangedListeners = new CopyOnWriteArrayList<>();

    this.renderCanvas = new RenderComponent(Game.config().graphics().getResolution());
    this.cursor = new MouseCursor();
    if (!Game.isInNoGUIMode()) {
      this.hostControl.setBackground(Color.BLACK);
      this.hostControl.add(this.renderCanvas);

      this.initializeEventListeners();

      this.hostControl.setTitle(Game.info().getTitle());
      this.hostControl.setDefaultCloseOperation(WindowConstants.DO_NOTHING_ON_CLOSE);
      initializeWindowEventListeners(this.hostControl);
    }
}
}
```
```java
class de.gurkenlabs.litiengine.GameTime {
public long sinceEnvironmentLoad() {
    return this.since(this.environmentLoaded);
}public long since(final long tick) {
    return toMilliseconds(Game.loop().getTicks() - tick);
}public long sinceGameStart() {
    return this.toMilliseconds(Game.loop().getTicks());
}
}
```
```java
class de.gurkenlabs.litiengine.abilities.effects.Effect {
protected void cease(final EffectApplication appliance) {
    // 1. cease the effect for all affected entities
    for (final ICombatEntity entity : appliance.getAffectedEntities()) {
      this.cease(entity);
    }

    // 2. apply follow up effects
    this.getFollowUpEffects().forEach(followUp -> followUp.apply(appliance.getImpactArea()));
}protected boolean hasEnded(final EffectApplication appliance) {
    final long effectDuration = Game.time().since(appliance.getAppliedTicks());
    return effectDuration > this.getDuration();
}
}
```
```java
class de.gurkenlabs.litiengine.abilities.effects.EffectApplication {
protected EffectApplication(final List<ICombatEntity> affectedEntities, final Shape impactArea) {
    this.applied = Game.time().now();
    this.affectedEntities = affectedEntities;
    this.impactArea = impactArea;
}
}
```
```java
class de.gurkenlabs.litiengine.entities.CombatEntity {
@Override
  public boolean wasHit(int timeSpan) {
    return Game.time().since(this.lastHit) < timeSpan;
}@Override
  public void hit(final int damage, @Nullable final Ability ability) {
    if (this.isDead()) {
      return;
    }

    if (!this.isIndestructible()) {
      this.getHitPoints().modifyBaseValue(new AttributeModifier<>(Modification.SUBTRACT, damage));
    }

    final EntityHitEvent event = new EntityHitEvent(this, ability, damage, this.isDead());

    for (final CombatEntityListener listener : this.listeners) {
      listener.hit(event);
    }

    for (final CombatEntityHitListener listener : this.hitListeners) {
      listener.hit(event);
    }

    if (this.isDead()) {
      this.fireDeathEvent();
      this.setCollision(false);
    }

    this.lastHit = Game.time().now();
}
}
```
```java
class de.gurkenlabs.litiengine.graphics.ImageEffect {
protected ImageEffect(final int ttl, final String name) {
    this.ttl = ttl;
    this.name = name;
    this.aliveTick = Game.time().now();
}@Override
  public long getAliveTime() {
    return Game.time().since(this.aliveTick);
}
}
```
```java
class de.gurkenlabs.litiengine.abilities.AbilityExecution {
AbilityExecution(final Ability ability) {
    this.appliedEffects = new CopyOnWriteArrayList<>();
    this.ability = ability;
    this.executionTicks = Game.time().now();
    this.impactArea = ability.calculateImpactArea();
    this.castLocation = ability.getExecutor().getCenter();
    Game.loop().attach(this);
}@Override
  public void update() {
    // if there a no effects to apply -> unregister this instance and we're done
    if (this.getAbility().getEffects().isEmpty()
        || this.getAbility().getEffects().size() == this.getAppliedEffects().size()) {
      Game.loop().detach(this);
      return;
    }

    // handle all effects from the ability that were not applied yet
    for (final Effect effect : this.getAbility().getEffects()) {
      // if the ability was not executed yet or the delay of the effect is not
      // yet reached
      if (this.getAppliedEffects().contains(effect)
          || Game.time().since(this.getExecutionTicks()) < effect.getDelay()) {
        continue;
      }

      effect.apply(this.getExecutionImpactArea());
      this.getAppliedEffects().add(effect);
    }
}
}
```
```java
class de.gurkenlabs.litiengine.tweening.TweenEngine {
@Override
  public void update() {
    for (final Tweenable target : this.getTweens().keySet()) {
      for (final Tween tween : this.getTweens().get(target).values()) {
        if (tween.hasStopped()) {
          continue;
        }
        final long elapsed = Game.time().since(tween.getStartTime());
        if (elapsed >= tween.getDuration()) {
          tween.stop();
          continue;
        }
        final float[] currentValues = new float[tween.getTargetValues().length];
        for (int i = 0; i < tween.getTargetValues().length; i++) {
          currentValues[i] =
              tween.getStartValues()[i]
                  + tween.getEquation().compute(elapsed / (float) tween.getDuration())
                      * (tween.getTargetValues()[i] - tween.getStartValues()[i]);
        }
        tween.getTarget().setTweenValues(tween.getType(), currentValues);
      }
    }
}
}
```
```java
class de.gurkenlabs.litiengine.gui.SpeechBubble {
public static SpeechBubble create(
      final IEntity entity, final String text, SpeechBubbleAppearance appearance, Font font) {
    return new SpeechBubble(entity, text, appearance, font);
}public static SpeechBubble create(final IEntity entity, final Font font, final String text) {
    SpeechBubbleAppearance app =
        new SpeechBubbleAppearance(
            DEFAULT_APPEARANCE.getForeColor(),
            DEFAULT_APPEARANCE.getBackgroundColor1(),
            DEFAULT_APPEARANCE.getBorderColor(),
            DEFAULT_APPEARANCE.getPadding());
    return new SpeechBubble(entity, text, app, font);
}public static SpeechBubble create(final IEntity entity, final String text) {
    return new SpeechBubble(entity, text, null, GuiProperties.getDefaultFont());
}@Override
  public void update() {
    if (this.currentText == null) {
      this.hide();
      return;
    }

    this.entityCenter = Game.world().camera().getViewportLocation(this.getEntity().getCenter());

    // old text was displayed long enough
    if (this.lastTextDisplay != 0
        && Game.time().since(this.lastTextDisplay) > this.currentTextDisplayTime) {
      this.currentText = null;
      this.lastTextDisplay = 0;
      return;
    }

    // display new text
    if (this.textIndex < this.currentText.length()
        && Game.time().since(this.lastCharPoll) > LETTER_WRITE_DELAY) {
      this.textIndex++;
      this.lastCharPoll = Game.time().now();
      if (this.typeSound != null) {
        Game.audio().playSound(this.typeSound, this.getEntity());
      }
    }

    // continue displaying currently displayed text
}private SpeechBubble(
      final IEntity entity,
      final String text,
      final Sound typeSound,
      SpeechBubbleAppearance appearance,
      Font font) {
    this(entity, text, appearance, font);
    this.typeSound = typeSound;
}private SpeechBubble(
      final IEntity entity,
      final String text,
      @Nullable SpeechBubbleAppearance appearance,
      @Nullable Font font) {
    if (appearance == null) {
      this.appearance = DEFAULT_APPEARANCE;
    } else {
      this.appearance = appearance;
    }

    final SpeechBubble active = activeSpeechBubbles.get(entity);
    if (active != null) {
      active.hide();
    }
    this.setFont(font);

    this.textBoxWidth = (float) (entity.getWidth() * 4);
    this.entity = entity;

    this.currentText = text;
    this.currentTextDisplayTime = DISPLAYTIME_MIN + text.length() * DISPLAYTIME_PER_LETTER;

    this.lastTextDisplay = Game.time().now();
    this.createBubbleImage();
    entity.getEnvironment().add(this, RenderType.UI);
    Game.loop().attach(this);
    activeSpeechBubbles.put(entity, this);
}
}
```
```java
class de.gurkenlabs.litiengine.gui.TextFieldComponent {
@Override
  public void render(final Graphics2D g) {
    super.render(g);
    g.setFont(this.getFont());
    final FontMetrics fm = g.getFontMetrics();

    if (this.isSelected() && Game.time().since(this.lastToggled) > this.flickerDelay) {
      this.cursorVisible = !this.cursorVisible;
      this.lastToggled = Game.time().now();
    }
    if (this.isSelected() && this.cursorVisible) {
      final Rectangle2D cursor =
          new Rectangle2D.Double(
              this.getX() + this.getTextX() + fm.stringWidth(this.getTextToRender(g)),
              this.getY() + this.getTextY(),
              this.getFont().getSize2D() * 3 / 5,
              this.getFont().getSize2D() * 1 / 5);
      g.setColor(this.getAppearance().getForeColor());
      g.fill(cursor);
    }
}
}
```
```java
class de.gurkenlabs.litiengine.entities.Prop {
public Prop(
      final Point2D location, @Nullable final String spritesheetName, final Material material) {
    super();
    this.rotation = Rotation.NONE;
    this.spritesheetName = spritesheetName;
    this.material = material;
    this.setLocation(location);
    this.updateAnimationController();
}public void setSpritesheetName(@Nullable final String spriteName) {
    this.spritesheetName = spriteName;
    this.updateAnimationController();
}
}
```
```java
class de.gurkenlabs.litiengine.tweening.Tween {
public Tween begin() {
    this.started = Game.time().now();
    this.stopped = false;
    return this;
}
}
```
```java
class de.gurkenlabs.litiengine.graphics.emitters.particles.Particle {
public void update(final Point2D emitterOrigin, final float updateRatio) {
    if (this.aliveTick == 0) {
      this.aliveTick = Game.time().now();
    }

    this.aliveTime = Game.time().since(this.aliveTick);
    if (this.timeToLiveReached()) {
      return;
    }

    if (this.colliding) {
      return;
    }

    if (this.getDeltaWidth() != 0) {
      this.width += this.getDeltaWidth() * updateRatio;
    }

    if (this.getDeltaHeight() != 0) {
      this.height += this.getDeltaHeight() * updateRatio;
    }

    if (this.getDeltaAngle() != 0) {
      this.angle += this.getDeltaAngle() * updateRatio;
    }

    // test for ray cast collision
    final float targetX = this.x + this.getVelocityX() * updateRatio;
    final float targetY = this.y + this.getVelocityY() * updateRatio;

    if (targetX == this.x && targetY == this.y) {
      return;
    }

    if (this.checkForCollision(emitterOrigin, targetX, targetY)) {
      return;
    }

    if (this.getVelocityX() != 0) {
      this.x = targetX;
    }

    if (this.getVelocityY() != 0) {
      this.y = targetY;
    }

    if (this.getAccelerationX() != 0) {
      this.velocityX += this.getAccelerationX() * updateRatio;
    }

    if (this.getAccelerationY() != 0) {
      this.velocityY += this.getAccelerationY() * updateRatio;
    }
}
}
```
```java
class de.gurkenlabs.litiengine.graphics.animation.Animation {
@Override
  public void start() {
    this.playing = true;
    if (this.getKeyframes().isEmpty()) {
      return;
    }

    this.restart();
}@Override
  public void update() {
    // do nothing if the animation is not playing or the current keyframe is not finished
    if (!this.isPlaying()
        || Game.time().since(this.lastFrameUpdate) < this.getCurrentKeyFrame().getDuration()) {
      return;
    }

    // if we are not looping and the last keyframe is finished, we terminate the animation
    if (!this.isLooping() && this.isLastKeyFrame()) {
      this.terminate();
      return;
    }

    // make sure, we stay inside the keyframe list
    final int newFrameIndex =
        (this.getKeyframes().indexOf(this.currentFrame) + 1) % this.getKeyframes().size();
    final KeyFrame previousFrame = this.currentFrame;
    this.currentFrame = this.getKeyframes().get(newFrameIndex);

    for (KeyFrameListener listener : this.listeners) {
      listener.currentFrameChanged(previousFrame, this.currentFrame);
    }

    this.lastFrameUpdate = Game.loop().getTicks();
}
}
```
```java
class de.gurkenlabs.litiengine.graphics.animation.AnimationController {
@Override
  public void update() {
    for (final Animation animation : this.getAll()) {
      animation.update();
    }

    if (this.getCurrent() != null && this.getCurrent().isPaused()) {
      return;
    }

    final boolean playbackFinished = this.getCurrent() != null && !this.getCurrent().isPlaying();
    if (playbackFinished) {
      for (final AnimationListener listener : this.listeners) {
        listener.finished(this.getCurrent());
      }
    }

    if (this.getCurrent() == null || playbackFinished) {
      if (this.getDefault() != null) {
        this.play(this.getDefault().getName());
      } else {
        this.currentAnimation = null;
      }
    }
}
}
```
```java
class de.gurkenlabs.litiengine.graphics.RenderComponent {
private void handleFade() {
    if (this.fadeOutStart != -1) {
      final long timePassed = Game.time().since(this.fadeOutStart);
      this.currentAlpha = MathUtilities.clamp(1 - timePassed / (float) this.fadeOutTime, 0, 1);
      if (this.currentAlpha == 0f) {
        this.fadeOutStart = -1;
        this.fadeOutTime = -1;
      }

      return;
    }

    if (this.fadeInStart != -1) {
      final long timePassed = Game.time().since(this.fadeInStart);
      this.currentAlpha = MathUtilities.clamp(timePassed / (float) this.fadeInTime, 0, 1);
      if (this.currentAlpha == 1f) {
        this.fadeInStart = -1;
        this.fadeInTime = -1;
        this.currentAlpha = Float.NaN;
      }
    }
}public void fadeOut(final int ms) {
    this.fadeInStart = -1;
    this.fadeInTime = -1;
    this.fadeOutStart = Game.time().now();
    this.fadeOutTime = ms;
}public void fadeIn(final int ms) {
    this.fadeOutStart = -1;
    this.fadeOutTime = -1;
    this.fadeInStart = Game.time().now();
    this.fadeInTime = ms;
}
}
```
```java
class de.gurkenlabs.litiengine.entities.Trigger {
private boolean activate(final IEntity activator, final int tar) {
    if (!this.isLoaded()
        || this.isOneTimeTrigger && this.isActivated
        || this.getActivationType() == TriggerActivation.COLLISION
            && activator != null
            && this.collisionActivated.contains(activator)) {
      return false;
    }

    if (this.getCooldown() > 0 && Game.time().since(this.lastActivation) < this.getCooldown()) {
      return false;
    }

    List<Integer> triggerTargets = this.getTargets(tar);

    final TriggerEvent te = new TriggerEvent(this, activator, triggerTargets);

    if (!this.checkActivationPredicates(te)) {
      return false;
    }

    this.isActivated = true;
    if (activator != null) {
      this.collisionActivated.add(activator);
    }

    // if we actually have a trigger target, we send the message to the target
    for (final int target : triggerTargets) {
      final IEntity entity = this.getEnvironment().get(target);
      if (entity == null) {
        log.log(
            Level.WARNING,
            "trigger [{0}] was activated, but the trigger target [{1}] could not be found on the environment",
            new Object[] {this, target});
        continue;
      }

      entity.sendMessage(this, this.message);
    }

    // also send the trigger event to all registered consumers
    for (final TriggerActivatedListener listener : this.activatedListeners) {
      listener.activated(te);
    }

    if (this.isOneTimeTrigger) {
      this.getEnvironment().remove(this);
    }

    this.lastActivation = Game.time().now();
    return true;
}
}
```
```java
class de.gurkenlabs.litiengine.graphics.Camera {
private boolean isShakeEffectActive() {
    return this.getShakeTick() != 0
        && Game.time().since(this.getShakeTick()) < this.getShakeDuration();
}@Override
  public void update() {
    if (Game.world().camera() != null && !Game.world().camera().equals(this)) {
      return;
    }

    if (this.targetZoom > 0) {
      if (Game.time().since(this.zoomTick) >= this.zoomDelay) {
        this.zoom = this.targetZoom;
        this.targetZoom = 0;
        this.zoomDelay = 0;
        this.zoomTick = 0;
        this.zoomStep = 0;
      } else {
        this.zoom += this.zoomStep;
      }

      final ZoomChangedEvent event = new ZoomChangedEvent(this, this.getZoom());
      for (final ZoomChangedListener listener : this.zoomListeners) {
        listener.zoomChanged(event);
      }
    }

    if (this.panTime > 0) {
      if (--this.panTime <= 0) {
        this.setFocus(this.targetFocus);
        this.targetFocus = null;
      } else {
        double diff = this.panTime / (this.panTime + 1.0);
        this.focus =
            new Point2D.Double(
                this.focus.getX() * diff + this.targetFocus.getX() * (1.0 - diff),
                this.focus.getY() * diff + this.targetFocus.getY() * (1.0 - diff));
      }
    }

    if (!this.isShakeEffectActive()) {
      this.shakeOffsetX = 0;
      this.shakeOffsetY = 0;
      return;
    }

    if (Game.time().since(this.lastShake) > this.shakeDelay) {
      this.shakeOffsetX = this.getShakeIntensity() * ThreadLocalRandom.current().nextGaussian();
      this.shakeOffsetY = this.getShakeIntensity() * ThreadLocalRandom.current().nextGaussian();
      this.lastShake = Game.time().now();
    }
}@Override
  public void setZoom(final float targetZoom, final int delay) {
    if (delay == 0) {

      this.zoom = targetZoom;
      this.targetZoom = 0;
      this.zoomDelay = 0;
      this.zoomTick = 0;
      this.zoomStep = 0;

      final ZoomChangedEvent event = new ZoomChangedEvent(this, targetZoom);
      for (final ZoomChangedListener listener : this.zoomListeners) {
        listener.zoomChanged(event);
      }
    } else {
      this.zoomTick = Game.time().now();
      this.targetZoom = targetZoom;
      this.zoomDelay = delay;

      final double tickduration = 1000 / (double) Game.loop().getTickRate();
      final double tickAmount = delay / tickduration;
      final float totalDelta = this.targetZoom - this.zoom;
      this.zoomStep = tickAmount > 0 ? (float) (totalDelta / tickAmount) : totalDelta;
    }
}@Override
  public void shake(final double intensity, final int delay, final int shakeDuration) {
    this.shakeTick = Game.time().now();
    this.shakeDelay = delay;
    this.shakeIntensity = intensity;
    this.shakeDuration = shakeDuration;
}
}
```
```java
class de.gurkenlabs.litiengine.entities.Creature {
public void setSpritesheetName(String spritesheetName) {
    if (this.spritesheetName != null && this.spritesheetName.equals(spritesheetName)) {
      return;
    }

    this.spritesheetName = spritesheetName;
    this.updateAnimationController();
}public boolean isIdle() {
    return Game.time().since(this.lastMoved) > IDLE_DELAY;
}@Override
  public void setLocation(final Point2D position) {
    if (this.isDead() || position == null) {
      return;
    }

    final Point2D oldLocation = this.getLocation();
    super.setLocation(position);

    if (Game.hasStarted() && this.isLoaded()) {
      this.lastMoved = Game.time().now();
      this.fireMovedEvent(
          new EntityMovedEvent(
              this, this.getX() - oldLocation.getX(), this.getY() - oldLocation.getY()));
    }
}
}
```
```java
class de.gurkenlabs.litiengine.gui.screens.ScreenManager {
public void display(final String screenName) {
    if (this.current() != null && this.current().getName().equalsIgnoreCase(screenName)) {
      log.log(
          Level.INFO,
          "Skipping displaying of screen {0} because it is already the current screen.",
          screenName);
      return;
    }

    if (this.screens.stream()
        .noneMatch(element -> element.getName().equalsIgnoreCase(screenName))) {
      log.log(
          Level.WARNING,
          "Could not display the screen {0} because there is no screen with the specified name.",
          screenName);
      return;
    }

    Screen screen = this.get(screenName);
    if (screen == null) {
      return;
    }

    this.display(screen);
}public void add(final Screen screen) {
    screen.setWidth(Game.window().getWidth());
    screen.setHeight(Game.window().getHeight());
    this.screens.add(screen);

    if (this.current() == null) {
      this.display(screen);
    }
}public void remove(Screen screen) {
    this.screens.remove(screen);
    if (this.current() == screen) {
      if (!this.screens.isEmpty()) {
        this.display(this.screens.get(0));
      } else {
        this.display((Screen) null);
      }
    }
}public void display(@Nullable final Screen screen) {
    if (Game.hasStarted() && Game.time().since(this.lastScreenChange) < this.getChangeCooldown()) {
      log.log(
          Level.INFO,
          "Skipping displaying of screen {0} because screen changing is currently on cooldown.",
          screen != null ? screen.getName() : "");
      return;
    }

    final Screen previous = this.current();
    if (previous != null) {
      previous.suspend();
    }

    if (screen != null && !this.screens.contains(screen)) {
      this.screens.add(screen);
    }

    this.currentScreen = screen;
    if (!Game.isInNoGUIMode() && this.current() != null) {
      this.current().prepare();
    }

    this.lastScreenChange = Game.loop().getTicks();

    final ScreenChangedEvent event = new ScreenChangedEvent(this.current(), previous);
    for (final ScreenChangedListener listener : this.screenChangedListeners) {
      listener.changed(event);
    }
}
}
```
```java
class de.gurkenlabs.litiengine.abilities.Ability {
public boolean isOnCooldown() {
    return (this.getCurrentExecution() != null
        && this.getCurrentExecution().getExecutionTicks() > 0
        && Game.time().since(this.getCurrentExecution().getExecutionTicks())
            < this.getAttributes().cooldown().get());
}public boolean isActive() {
    return this.getCurrentExecution() != null
        && Game.time().since(this.getCurrentExecution().getExecutionTicks())
            < this.getAttributes().duration().get();
}@Nullable
  public AbilityExecution cast() {
    if (!this.canCast()) {
      return null;
    }
    this.currentExecution = new AbilityExecution(this);

    for (final AbilityCastListener listener : this.abilityCastListeners) {
      listener.abilityCast(this.currentExecution);
    }

    return this.getCurrentExecution();
}public float getRemainingCooldownInSeconds() {
    if (this.getCurrentExecution() == null
        || this.getExecutor() == null
        || this.getExecutor().isDead()) {
      return 0;
    }

    // calculate cooldown in seconds
    return (float)
        (!this.canCast()
            ? (this.getAttributes().cooldown().get()
                    - Game.time().since(this.getCurrentExecution().getExecutionTicks()))
                * 0.001
            : 0);
}
}
```
```java
class de.gurkenlabs.litiengine.entities.EntityHitEvent {
EntityHitEvent(
      final ICombatEntity hitEntity,
      @Nullable final Ability ability,
      final int damage,
      final boolean kill) {
    super(hitEntity);
    this.executor = ability != null ? ability.getExecutor() : null;
    this.hitEntity = hitEntity;
    this.ability = ability;
    this.damage = damage;
    this.kill = kill;
    this.time = Game.time().now();
}
}
```
```java
class de.gurkenlabs.litiengine.graphics.emitters.Emitter {
public void delete() {
    this.deactivate();
    if (Game.world().environment() != null) {
      Game.world().environment().remove(this);
    }
}public void activate() {
    if (this.activated) {
      return;
    }

    this.activated = true;
    this.activationTick = Game.time().now();
    Game.loop().attach(this);
}@Override
  public void update() {
    if (this.isPaused()) {
      return;
    }

    // clear particles if the effect time to life is reached
    if (this.isFinished()) {
      for (EmitterFinishedListener listener : this.finishedListeners) {
        listener.finished(this);
      }

      this.delete();
      return;
    }

    final float updateRatio = (float) this.data().getUpdateRate() / Game.loop().getTickRate();
    for (final Particle p : this.getParticles().stream().collect(Collectors.toList())) {
      if (this.particleCanBeRemoved(p)) {
        // remove dead particles
        this.particles.remove(p);
        continue;
      }

      p.update(this.getOrigin(), updateRatio);
    }

    this.aliveTime = Game.time().since(this.activationTick);
    if ((this.data().getSpawnRate() == 0
        || Game.time().since(this.lastSpawn) >= this.data().getSpawnRate())) {
      this.lastSpawn = Game.time().now();
      this.spawnParticle();
    }
}
}
```
```java
class de.gurkenlabs.litiengine.GameLoop {
@Override
  public int perform(int delay, Runnable action) {
    final long d = Game.time().toTicks(delay);

    TimedAction a = new TimedAction(this.getTicks() + d, action);
    this.actions.add(a);

    return a.getId();
}
}
```
```java
class de.gurkenlabs.litiengine.environment.EntitySpawner {
protected boolean shouldSpawn() {
    return this.lastSpawnWave == 0
        || Game.time().since(this.lastSpawnWave) >= this.getSpawnInterval();
}@Override
  public void update() {
    if (!this.shouldSpawn()) {
      return;
    }

    this.spawnNewEntities();
    this.lastSpawnWave = Game.time().now();
}
}
```
```java
class de.gurkenlabs.litiengine.graphics.FreeFlightCamera {
@Override
  public void update() {
    this.handleFreeFlightCamera();
}public FreeFlightCamera(double x, double y) {
    this(new Point2D.Double(x, y));
}
}
```
```java
class de.gurkenlabs.litiengine.environment.Environment {
public void unload() {
    if (!this.loaded) {
      return;
    }

    // unregister all updatable entities from the current environment
    for (final IEntity entity : this.allEntities.values()) {
      this.unload(entity);
    }

    this.loaded = false;
    this.fireEvent(l -> l.unloaded(this));
}private static void loadUpdatableOrEmitterEntity(IEntity entity) {
    if (entity instanceof Emitter) {
      final Emitter emitter = (Emitter) entity;
      if (emitter.isActivateOnInit()) {
        emitter.activate();
      }
    } else if (entity instanceof IUpdateable) {
      Game.loop().attach((IUpdateable) entity);
    }
}public void clear() {
    Game.physics().clear();

    this.combatEntities.clear();
    this.mobileEntities.clear();
    this.gravityForces.clear();
    this.layerEntities.clear();
    this.entitiesByTag.clear();
    this.allEntities.clear();

    for (RenderType renderType : RenderType.values()) {
      this.miscEntities.get(renderType).clear();
      this.renderListeners.get(renderType).clear();
      this.renderables.get(renderType).clear();
    }

    dispose(this.allEntities.values());
    dispose(this.triggers);
    this.emitters.clear();
    this.colliders.clear();
    this.props.clear();
    this.creatures.clear();
    this.staticShadows.clear();
    this.combatEntities.clear();
    this.mobileEntities.clear();
    this.lightSources.clear();
    this.spawnPoints.clear();
    this.soundSources.clear();
    this.mapAreas.clear();
    this.triggers.clear();

    this.ambientLight = null;
    this.staticShadowLayer = null;

    for (Map<Integer, IEntity> type : this.miscEntities.values()) {
      type.clear();
    }

    this.initialized = false;

    this.fireEvent(l -> l.cleared(this));
}private void load(final IEntity entity) {
    // an entity can only exist on one environment at a time, so remove it from the current one
    if (entity.getEnvironment() != null) {
      entity.getEnvironment().remove(entity);
    }

    // 1. add to physics engine
    loadPhysicsEntity(entity);

    // 2. register for update or activate
    loadUpdatableOrEmitterEntity(entity);

    // 3. if a gravity is defined, add a gravity force to the entity
    if (entity instanceof IMobileEntity && this.getGravity() != 0) {
      this.addGravityForce((IMobileEntity) entity);
    }

    // 4. attach all controllers
    entity.attachControllers();

    if (this.loaded && (entity instanceof LightSource || entity instanceof StaticShadow)) {
      this.updateLighting(entity);
    }

    entity.loaded(this);
}private void unload(final IEntity entity) {
    // 1. remove from physics engine
    if (entity instanceof ICollisionEntity) {
      Game.physics().remove((ICollisionEntity) entity);
    }

    // 2. unregister from update
    if (entity instanceof IUpdateable) {
      Game.loop().detach((IUpdateable) entity);
    }

    if (entity instanceof IMobileEntity) {
      this.removeGravity((IMobileEntity) entity);
    }

    // 3. detach all controllers
    entity.detachControllers();

    if (entity instanceof Emitter) {
      Emitter em = (Emitter) entity;
      em.deactivate();
    }

    if (this.loaded && (entity instanceof LightSource || entity instanceof StaticShadow)) {
      this.updateLighting(entity);
    }

    entity.removed(this);
}public void remove(final IEntity entity) {
    if (entity == null) {
      return;
    }

    this.allEntities.remove(entity.getMapId());
    Iterator<List<IEntity>> iter = this.layerEntities.values().iterator();
    while (iter.hasNext()) {
      List<IEntity> layer = iter.next();
      if (layer.remove(entity) && layer.isEmpty()) {
        iter.remove();
      }
    }
    if (this.miscEntities.get(entity.getRenderType()) != null) {
      this.miscEntities.get(entity.getRenderType()).values().remove(entity);
    }

    for (String tag : entity.getTags()) {
      if (this.getEntitiesByTag().containsKey(tag)) {
        this.getEntitiesByTag().get(tag).remove(entity);

        if (this.getEntitiesByTag().get(tag).isEmpty()) {
          this.getEntitiesByTag().remove(tag);
        }
      }
    }

    if (entity instanceof Emitter) {
      Emitter emitter = (Emitter) entity;
      this.removeEmitter(emitter);
    }

    if (entity instanceof MapArea) {
      this.mapAreas.remove(entity);
    }

    if (entity instanceof Prop) {
      this.props.remove(entity);
    }

    if (entity instanceof Creature) {
      this.creatures.remove(entity);
    }

    if (entity instanceof CollisionBox) {
      this.colliders.remove(entity);
      this.staticShadows.removeIf(x -> x.getOrigin() != null && x.getOrigin().equals(entity));
    }

    if (entity instanceof LightSource) {
      this.lightSources.remove(entity);
      this.updateLighting(entity);
    }

    if (entity instanceof Trigger) {
      this.triggers.remove(entity);
    }

    if (entity instanceof Spawnpoint) {
      this.spawnPoints.remove(entity);
    }
    if (entity instanceof SoundSource) {
      this.soundSources.remove(entity);
    }

    if (entity instanceof StaticShadow) {
      this.staticShadows.remove(entity);
      this.updateLighting(entity);
    }

    if (entity instanceof IMobileEntity) {
      this.mobileEntities.values().remove(entity);
    }

    if (entity instanceof ICombatEntity) {
      this.combatEntities.values().remove(entity);
    }

    this.unload(entity);

    this.fireEntityEvent(l -> l.entityRemoved(entity));
}
}
```
```java
class de.gurkenlabs.litiengine.physics.MovementController {
@Override
  public void update() {
    this.handleForces();
    this.handleMovement();
}
}
```
```java
class de.gurkenlabs.litiengine.Game {
static synchronized void terminate() {
    if (!initialized) {
      return;
    }

    hasStarted = false;
    initialized = false;

    config().save();
    gameLoop.terminate();
    tweenEngine.terminate();
    soundEngine.terminate();

    world().clear();

    for (final GameListener listener : gameListeners) {
      try {
        listener.terminated();
      } catch (Exception e) {
        log().log(Level.WARNING, "game listener threw an exception during shutdown", e);
      }
    }

    gameLoop = null;
    screenManager = null;
    gameWindow = null;
}public static synchronized void start() {
    if (!initialized) {
      throw new IllegalStateException(
          "The game cannot be started without being first initialized. Call Game.init(...) before Game.start().");
    }

    gameLoop.start();
    tweenEngine.start();
    soundEngine.start();

    for (final GameListener listener : gameListeners) {
      listener.started();
    }

    hasStarted = true;
}public static synchronized void init(String... args) {
    if (initialized) {
      log().log(Level.INFO, "The game has already been initialized.");
      return;
    }

    log.init();
    handleCommandLineArguments(args);

    config().load();
    Locale.setDefault(new Locale(config().client().getCountry(), config().client().getLanguage()));

    gameLoop = new GameLoop("Main Update Loop", config().client().getMaxFps());
    loop().attach(physics());
    loop().attach(world());

    // setup default exception handling for render and update loop
    setUncaughtExceptionHandler(
        new DefaultUncaughtExceptionHandler(config().client().exitOnError()));

    screenManager = new ScreenManager();
    gameWindow = new GameWindow();

    // initialize  the game window
    window().init();
    world.setCamera(new Camera());

    for (GameListener listener : gameListeners) {
      listener.initialized(args);
    }

    if (!isInNoGUIMode()) {
      window().getRenderComponent().onRendered(g -> metrics().render(g));

      graphics()
          .addEntityRenderedListener(
              e -> DebugRenderer.renderEntityDebugInfo(e.getGraphics(), e.getEntity()));

      window().getRenderComponent().onFpsChanged(fps -> metrics().setFramesPerSecond(fps));
      window()
          .setIcons(
              Arrays.asList(
                  Resources.images().get("liti-logo-x16.png"),
                  Resources.images().get("liti-logo-x20.png"),
                  Resources.images().get("liti-logo-x32.png"),
                  Resources.images().get("liti-logo-x48.png")));

      Input.keyboard()
          .onKeyTyped(
              KeyEvent.VK_PRINTSCREEN,
              key -> {
                // don't take a screenshot if a modifier is active
                if (key.getModifiers() != 0) {
                  return;
                }

                window().getRenderComponent().takeScreenshot();
              });
    }

    Runtime.getRuntime().addShutdownHook(new Thread(Game::terminate, "Shutdown"));

    initialized = true;
}
}
```


Response Format:
Provide the answer in **XML format** as follows:

#### If the method **cannot** return `null` at the specific call site:
```xml
<response>
  <reason><![CDATA[EXPLAIN WHY THE INVOCATION Game.loop() RESULT CANNOT BE NULL.]]></reason>
  <value>NO</value>
</response>

#### If the method can return null at the specific call site:
<response>
  <reason><![CDATA[EXPLAIN WHY THE INVOCATION Game.loop() RESULT CAN BE NULL.]]></reason>
  <value>YES</value>
</response>

#### If you are unsure or If there are any methods that directly or indirectly affect the return value and are not fully disclosed, request their declarations first, in the following format:
<response>
  <reason><![CDATA[EXPLAIN WHY THIS METHOD DECLARATION IS NECESSARY AND WHY YOU CANNOT MAKE A CONFIDENT DECISION WITHOUT IT]]></reason>
  <success>false</success>
  <methods>
    <method>methodName</method>
  </methods>
</response>

Additional Notes:
Be precise in your reasoning.
If a method’s return value depends on another method not provided, request its declaration before making a conclusion.
If the method can return null in this case but not in others, explain why it happens specifically for this call.

---ChatGPT.sendRequestToOpenAI---
Retrieving response from cache
---Response.<init>---
Creating Response:
```xml
<response>
  <reason><![CDATA[The method `Game.loop()` returns the static field `gameLoop`, which is initialized in the `Game.init(String... args)` method. In this method, a new `GameLoop` object is instantiated and assigned to `gameLoop`. Since `init()` must be called before `start()`, which is implied by the requirement of initializing the game, the `gameLoop` is guaranteed to be non-null during the lifetime of the game execution where `Game.loop()` is called. The absence of any code that could set `gameLoop` to null after its initialization ensures that `Game.loop()` cannot return null.]]></reason>
  <value>NO</value>
</response>
```
---Response.<init>---
Response created:
Disagreement: The method `Game.loop()` returns the static field `gameLoop`, which is initialized in the `Game.init(String... args)` method. In this method, a new `GameLoop` object is instantiated and assigned to `gameLoop`. Since `init()` must be called before `start()`, which is implied by the requirement of initializing the game, the `gameLoop` is guaranteed to be non-null during the lifetime of the game execution where `Game.loop()` is called. The absence of any code that could set `gameLoop` to null after its initialization ensures that `Game.loop()` cannot return null.
---AdvancedNullAwayCodeFix.resolveMethodDereferenceError---
Method is not returning nullable on call site. Injecting suppression annotation.
---AdvancedNullAwayCodeFix.constructCastToNonnullChange---
Constructing cast to nonnull change for reason: The method `Game.loop()` returns the static field `gameLoop`, which is initialized in the `Game.init(String... args)` method. In this method, a new `GameLoop` object is instantiated and assigned to `gameLoop`. Since `init()` must be called before `start()`, which is implied by the requirement of initializing the game, the `gameLoop` is guaranteed to be non-null during the lifetime of the game execution where `Game.loop()` is called. The absence of any code that could set `gameLoop` to null after its initialization ensures that `Game.loop()` cannot return null.
---ChatGPT.ask---
Asking ChatGPT:
For the reason you mentioned earlier:

"The method `Game.loop()` returns the static field `gameLoop`, which is initialized in the `Game.init(String... args)` method. In this method, a new `GameLoop` object is instantiated and assigned to `gameLoop`. Since `init()` must be called before `start()`, which is implied by the requirement of initializing the game, the `gameLoop` is guaranteed to be non-null during the lifetime of the game execution where `Game.loop()` is called. The absence of any code that could set `gameLoop` to null after its initialization ensures that `Game.loop()` cannot return null."

in the method below, the expression Game.loop() is not nullable at the point it is used.

```java
@Override
  public void update() {
    // do nothing if the animation is not playing or the current keyframe is not finished
    if (!this.isPlaying()
        || Game.time().since(this.lastFrameUpdate) < this.getCurrentKeyFrame().getDuration()) {
      return;
    }

    // if we are not looping and the last keyframe is finished, we terminate the animation
    if (!this.isLooping() && this.isLastKeyFrame()) {
      this.terminate();
      return;
    }

    // make sure, we stay inside the keyframe list
    final int newFrameIndex =
        (this.getKeyframes().indexOf(this.currentFrame) + 1) % this.getKeyframes().size();
    final KeyFrame previousFrame = this.currentFrame;
    this.currentFrame = this.getKeyframes().get(newFrameIndex);

    for (KeyFrameListener listener : this.listeners) {
      listener.currentFrameChanged(previousFrame, this.currentFrame);
    }

    this.lastFrameUpdate = Game.loop().getTicks();
}
```
Please Summarize the reason in max 5 words and rewrite the method so that at the line "    this.lastFrameUpdate = Game.loop().getTicks();", at the occurrence of: "Game.loop()" is replaced with `NullabilityUtil.castToNonnull(Game.loop(), summary of reason)`
Replace "REASON" with the exact reason summary I provide to you (maximum 5 words), not with a generic explanation like "checked to be nonnull".
see the example below, for expression `foo.getBar()`, to wrap it with `NullabilityUtil.castToNonnull(foo.getBar(), "reason")`.

```java
public t(){
    String l = foo.getBar();
}
```

will be:
```java
public t(){
    String l = NullabilityUtil.castToNonnull(foo.getBar(), "checked to be nonnull");
}
```

### Instructions:

Do not import any additional classes.

Do not add Java comments.

Only modify relevant lines as required.

Return only the modified method wrapped in the XML format shown below.

Place the Java code inside the <code> tag using a CDATA block with ```java formatting.

Just give me the fixed code snippet in XML format in <response> tag like the example below. I will apply the fix to my codebase. Do not import any additional libraries or classes or add java comments. If you can provide the fixed code snippet, please provide it in the following format and place the code snippet in the <code> tag within ```java block.
<response>
  <success>true</success>
  <code><![CDATA[
  ```java
  Your fixed code snippet here
  ```
    ]]>
  </code>
</response>

---ChatGPT.sendRequestToOpenAI---
Sending request to OpenAI...
---ChatGPT.sendRequestToOpenAI---
Response received from OpenAI.
---Response.<init>---
Creating Response:
<response>
  <success>true</success>
  <code><![CDATA[
  ```java
  @Override
  public void update() {
    if (!this.isPlaying()
        || Game.time().since(this.lastFrameUpdate) < this.getCurrentKeyFrame().getDuration()) {
      return;
    }

    if (!this.isLooping() && this.isLastKeyFrame()) {
      this.terminate();
      return;
    }

    final int newFrameIndex =
        (this.getKeyframes().indexOf(this.currentFrame) + 1) % this.getKeyframes().size();
    final KeyFrame previousFrame = this.currentFrame;
    this.currentFrame = this.getKeyframes().get(newFrameIndex);

    for (KeyFrameListener listener : this.listeners) {
      listener.currentFrameChanged(previousFrame, this.currentFrame);
    }

    this.lastFrameUpdate = NullabilityUtil.castToNonnull(Game.loop(), "guaranteed non-null").getTicks();
  }
  ```
  ]]>
  </code>
</response>
---Response.<init>---
Response created:
@Override
  public void update() {
    if (!this.isPlaying()
        || Game.time().since(this.lastFrameUpdate) < this.getCurrentKeyFrame().getDuration()) {
      return;
    }

    if (!this.isLooping() && this.isLastKeyFrame()) {
      this.terminate();
      return;
    }

    final int newFrameIndex =
        (this.getKeyframes().indexOf(this.currentFrame) + 1) % this.getKeyframes().size();
    final KeyFrame previousFrame = this.currentFrame;
    this.currentFrame = this.getKeyframes().get(newFrameIndex);

    for (KeyFrameListener listener : this.listeners) {
      listener.currentFrameChanged(previousFrame, this.currentFrame);
    }

    this.lastFrameUpdate = NullabilityUtil.castToNonnull(Game.loop(), "guaranteed non-null").getTicks();
  }
---ChatGPT.fixDereferenceByAddingCastToNonnull---
Fixing the error by adding castToNonnull
---AdvancedNullAwayCodeFix.fixTriggeredErrorsForLocation---
Resolving unresolvable error for triggered error: Type='DEREFERENCE_NULLABLE', message='dereferenced expression Game.loop() is @Nullable'
/home/nima/Developer/nullness-benchmarks/litiengine/src/de/gurkenlabs/litiengine/tweening/TweenEngine.java:110
    Game.loop().attach(this);
---AdvancedNullAwayCodeFix.fix---
Fixing error: Type='DEREFERENCE_NULLABLE', message='dereferenced expression Game.loop() is @Nullable'
/home/nima/Developer/nullness-benchmarks/litiengine/src/de/gurkenlabs/litiengine/tweening/TweenEngine.java:110
    Game.loop().attach(this);
---AdvancedNullAwayCodeFix.resolveDereferenceError---
Resolving dereference error: Type='DEREFERENCE_NULLABLE', message='dereferenced expression Game.loop() is @Nullable'
/home/nima/Developer/nullness-benchmarks/litiengine/src/de/gurkenlabs/litiengine/tweening/TweenEngine.java:110
    Game.loop().attach(this);
---AdvancedNullAwayCodeFix.resolveDereferenceError---
Checking nullability possibility at error point
---ChatGPT.checkNullabilityPossibilityAtErrorPoint---
Asking if the expression can be null at error point point
---ChatGPT.ask---
Asking ChatGPT:
In the method below, is there a possibility that the expression "Game.loop()" at line "Game.loop().attach(this);" is null?
@Override
  public void start() {
    Game.loop().attach(this);
}
Give a single-word answer in XML format. If it is possible for the expression to be null, respond with:
```xml
<response>
    <reason><![CDATA[YOUR REASON]]></reason>
    <value>YES</value>
</response>
```
If it is not possible for the expression to be null, respond with:
```xml
<response>
    <reason><![CDATA[YOUR REASON]]></reason>
    <value>NO</value>
</response>
```
If you are unsure or need more information, respond with where you can ask for more details or what specific information you need.

If additional information is required, list each request inside a `<request>` tag. If no additional information is needed, omit the `<requests>` section.

Respond with:
```xml
<response>
    <reason><![CDATA[YOUR REASON]]></reason>
    <value>UNKNOWN</value>
    <!-- Include <requests> only if additional information is needed -->
    <requests>
        <request><![CDATA[YOUR REQUEST 1]]></request>
        <request><![CDATA[YOUR REQUEST 2]]></request>
    </requests>
</response>
```
---ChatGPT.sendRequestToOpenAI---
Sending request to OpenAI...
---ChatGPT.sendRequestToOpenAI---
Response received from OpenAI.
---Response.<init>---
Creating Response:
```xml
<response>
    <reason><![CDATA[The possibility of Game.loop() being null depends on the implementation details of the Game class, which are not provided here.]]></reason>
    <value>UNKNOWN</value>
    <requests>
        <request><![CDATA[Please provide the implementation details of the Game.loop() method.]]></request>
    </requests>
</response>
```
---Response.<init>---
Response created:
Unknown: The possibility of Game.loop() being null depends on the implementation details of the Game class, which are not provided here.
---AdvancedNullAwayCodeFix.resolveMethodDereferenceError---
Resolving method dereference error.
---AdvancedNullAwayCodeFix.resolveMethodDereferenceError---
Method is in annotated package. Checking if the method is returning nullable.
---AdvancedNullAwayCodeFix.investigateMethodReturnNullability---
Checking if the method is returning nullable.
---ChatGPT.checkIfMethodIsReturningNullable---
Asking if the method is returning nullable: loop()
---ChatGPT.ask---
Asking ChatGPT:
In the method below, is there a possibility that the method returns null based only on its body? Consider the following points:

- The method may have multiple return paths; consider all return statements.
- If the method calls another method, do not assume its return value unless its full declaration is provided. Request its declaration if needed.
- The method may throw an exception instead of returning null. An exception path should not be considered a null return.
- Ensure you request the declarations of any methods whose return values directly or indirectly impact this method’s return value before making a conclusion.
- Carefully analyze all conditions and prior operations that may guarantee a non-null return value.

@Nullable public static IGameLoop loop() {
    return gameLoop;
}

Here are the method definitions in addition to the method inquired:

Depth: 0
```java
class de.gurkenlabs.litiengine.Game {
@Nullable public static IGameLoop loop() {
    return gameLoop;
}
}
```


Response Format:
Provide the answer in **XML format** as follows:

#### If the method **cannot** return `null`:
```xml
<response>
  <reason><![CDATA[EXPLAIN WHY THE METHOD CANNOT RETURN NULL]]></reason>
  <value>NO</value>
</response>
```

#### If the method can return null:
```xml
<response>
  <reason><![CDATA[EXPLAIN WHY THE METHOD CAN RETURN NULL]]></reason>
  <value>YES</value>
</response>
```

#### If you are unsure or need more information, respond with where you can ask for more details or what specific information you need.

#### If you are unsure or If there are any methods that directly or indirectly affect the return value and are not fully disclosed, request their declarations first, in the following format:
<response>
  <reason><![CDATA[YOUR REASON]]></reason>
  <value>UNKNOWN</value>
  <methods>
    <method>methodName</method>
  </methods>
</response>

If additional information is required other than method declaration, list each request inside a `<request>` tag. If no additional information is needed, omit the `<requests>` section.

Respond with:
```xml
<response>
    <reason><![CDATA[YOUR REASON]]></reason>
    <value>UNKNOWN</value>
    <!-- Include <requests> only if additional information is needed -->
    <requests>
        <request><![CDATA[YOUR REQUEST 1]]></request>
        <request><![CDATA[YOUR REQUEST 2]]></request>
    </requests>
</response>
```

Additional Notes:
Be precise in your reasoning.
If a method’s return value depends on another method not provided, request its declaration before making a conclusion.
If the method can return null in some cases but not others, explain under what conditions it can happen.

---ChatGPT.sendRequestToOpenAI---
Retrieving response from cache
---Response.<init>---
Creating Response:
```xml
<response>
  <reason><![CDATA[The method `loop` returns the variable `gameLoop`. Without the initialization or assignment details of `gameLoop`, it's unclear whether it can be null. The possibility of `gameLoop` being uninitialized or set to null elsewhere in the program means `loop` could potentially return null. Further information on `gameLoop` is required.]]></reason>
  <value>UNKNOWN</value>
  <requests>
    <request><![CDATA[Please provide the declaration and initialization of the variable `gameLoop` in the class `de.gurkenlabs.litiengine.Game`.]]></request>
  </requests>
</response>
```
---Response.<init>---
Response created:
Unknown: The method `loop` returns the variable `gameLoop`. Without the initialization or assignment details of `gameLoop`, it's unclear whether it can be null. The possibility of `gameLoop` being uninitialized or set to null elsewhere in the program means `loop` could potentially return null. Further information on `gameLoop` is required.
---AdvancedNullAwayCodeFix.investigateMethodReturnNullability---
Could not determine the nullability and model did not ask for any method.
---ChatGPT.checkIfMethodIsReturningNullableOnCallSite---
Asking if the method is returning nullable on the call site: Game.loop()
---ChatGPT.ask---
Asking ChatGPT:
In the method below, is there a possibility that the method returns null at the given call site?

```java
@Nullable public static IGameLoop loop() {
    return gameLoop;
}
```

## Guidelines:
- The method may have multiple return paths; consider all return statements.
- If the method calls another method, do not assume its return value unless its full declaration is provided. Request its declaration if needed.
- The method may throw an exception instead of returning null. An exception path should not be considered a null return.
- Ensure you request the declarations of any methods whose return values directly or indirectly impact this method’s return value before making a conclusion.
- If the method returns a value that is determined by a parameter, evaluate based on the actual argument at the given call site.
- Analyze based only on the specific invocation provided. Do not generalize to all possible inputs.- If the return value is guaranteed to be non-null at the call site, the answer should be a definitive NO.
- Do not generalize based on all possible inputs—your answer must be based only on the given invocation.
- Focus only on the given call site, not all possible invocations.

### call site:
Game.loop()

Here are the method definitions and the call chain for this method, showing the sequence of calls from the method to its callers at each depth level:

Depth: 0
```java
class de.gurkenlabs.litiengine.Game {
@Nullable public static IGameLoop loop() {
    return gameLoop;
}
}
```
Depth: 1
```java
class de.gurkenlabs.litiengine.environment.GameWorld {
public void loadEnvironment(@Nullable final Environment env) {
    Lock lock = Game.loop().getLock();
    lock.lock();
    try {
      unloadEnvironment();
      this.environment = env;
      if (env != null) {
        this.addEnvironment(env);

        if (env.getGravity() == 0 && this.gravity() != 0) {
          env.setGravity(this.gravity());
        }

        env.load();
        for (final EnvironmentLoadedListener listener : this.loadedListeners) {
          listener.loaded(env);
        }

        // call map specific listeners
        String mapName = getMapName(env);
        if (mapName != null && this.environmentLoadedListeners.containsKey(mapName)) {

          // for the default camera we center the camera on the environment
          if (this.camera().getClass().equals(Camera.class)) {
            camera().setFocus(env.getCenter());
          }

          for (EnvironmentLoadedListener listener : this.environmentLoadedListeners.get(mapName)) {
            listener.loaded(env);
          }
        }
      }
    } finally {
      lock.unlock();
    }
}public void setCamera(@Nullable final ICamera cam) {
    if (this.camera() != null) {
      Game.loop().detach(camera);
    }

    camera = cam;

    if (cam != null && !Game.isInNoGUIMode()) {
      Game.loop().attach(cam);
      cam.updateFocus();
    }
}
}
```
```java
class de.gurkenlabs.litiengine.entities.behavior.EntityNavigator {
public EntityNavigator(final IMobileEntity entity, final PathFinder pathFinder) {
    this.cancelNavigationConditions = new CopyOnWriteArrayList<>();
    this.listeners = new CopyOnWriteArrayList<>();
    this.entity = entity;
    this.pathFinder = pathFinder;
    this.setAcceptableError(DEFAULT_ACCEPTABLE_ERROR);
    Game.loop().attach(this);
}
}
```
```java
class de.gurkenlabs.litiengine.GameWindow {
private static void initializeWindowEventListeners(Window window) {

    window.addWindowStateListener(
        e -> {
          if (e.getNewState() == Frame.ICONIFIED) {
            Game.loop().setTickRate(ICONIFIED_MAX_FPS);
          } else {
            Game.loop().setTickRate(Game.config().client().getMaxFps());
          }
        });

    window.addWindowFocusListener(
        new WindowFocusListener() {
          @Override
          public void windowLostFocus(WindowEvent e) {
            if (Game.config().graphics().reduceFramesWhenNotFocused()) {
              Game.loop().setTickRate(NONE_FOCUS_MAX_FPS);
            }
          }

          @Override
          public void windowGainedFocus(WindowEvent e) {
            Game.loop().setTickRate(Game.config().client().getMaxFps());
          }
        });

    window.addWindowListener(
        new WindowAdapter() {
          @Override
          public void windowClosing(final WindowEvent event) {
            Game.exit();
          }
        });
}
}
```
```java
class de.gurkenlabs.litiengine.gui.screens.ScreenManager {
public void display(@Nullable final Screen screen) {
    if (Game.hasStarted() && Game.time().since(this.lastScreenChange) < this.getChangeCooldown()) {
      log.log(
          Level.INFO,
          "Skipping displaying of screen {0} because screen changing is currently on cooldown.",
          screen != null ? screen.getName() : "");
      return;
    }

    final Screen previous = this.current();
    if (previous != null) {
      previous.suspend();
    }

    if (screen != null && !this.screens.contains(screen)) {
      this.screens.add(screen);
    }

    this.currentScreen = screen;
    if (!Game.isInNoGUIMode() && this.current() != null) {
      this.current().prepare();
    }

    this.lastScreenChange = Game.loop().getTicks();

    final ScreenChangedEvent event = new ScreenChangedEvent(this.current(), previous);
    for (final ScreenChangedListener listener : this.screenChangedListeners) {
      listener.changed(event);
    }
}
}
```
```java
class de.gurkenlabs.litiengine.abilities.effects.Effect {
@Override
  public void update() {

    for (final Iterator<EffectApplication> iterator = this.getActiveAppliances().iterator();
        iterator.hasNext(); ) {
      final EffectApplication appliance = iterator.next();
      // if the effect duration is reached
      if (this.hasEnded(appliance)) {

        iterator.remove();
        this.cease(appliance);
      }
    }

    // 4. unregister if all appliances are finished
    if (this.getActiveAppliances().isEmpty()) {
      Game.loop().detach(this);
    }
}public void apply(final Shape impactArea) {
    final List<ICombatEntity> affected = this.lookForAffectedEntities(impactArea);
    for (final ICombatEntity affectedEntity : affected) {
      this.apply(affectedEntity);
    }

    this.appliances.add(new EffectApplication(affected, impactArea));

    // if it is the first appliance -> register for update
    if (this.appliances.size() == 1) {
      Game.loop().attach(this);
    }
}
}
```
```java
class de.gurkenlabs.litiengine.GameTime {
public long toTicks(final int milliseconds) {
    return this.toTicks(milliseconds, Game.loop().getTickRate());
}public long since(final long tick) {
    return toMilliseconds(Game.loop().getTicks() - tick);
}public long now() {
    return Game.loop().getTicks();
}public long sinceGameStart() {
    return this.toMilliseconds(Game.loop().getTicks());
}@Override
  public void loaded(Environment environment) {
    environmentLoaded = Game.loop().getTicks();
}public long toMilliseconds(final long ticks) {
    return this.toMilliseconds(ticks, Game.loop().getTickRate());
}
}
```
```java
class de.gurkenlabs.litiengine.GameMetrics {
@Override
  public void render(final Graphics2D g) {
    this.updateMetrics();

    if (!Game.config().client().showGameMetrics()) {
      return;
    }

    this.currentOffsetY = 0;

    g.setColor(this.renderColor);

    // render client metrics
    this.drawTitle(g, "[client]");
    this.drawMetric(g, "fps       : " + this.getFramesPerSecond());
    this.drawMetric(g, "max fps   : " + this.maxFramesPerSecond);
    this.drawMetric(g, "updatables: " + Game.loop().getUpdatableCount());

    // render jvm metrics if debug is enabled
    if (Game.config().debug().isDebugEnabled()) {
      this.drawTitle(g, "[jvm]");
      this.drawMetric(g, "java      : " + this.javaVersion);
      this.drawMetric(g, "memory    : " + String.format("%-5.5s", this.usedMemory) + " MB");
      this.drawMetric(g, "threads   : " + Thread.activeCount());
    }

    // render rendering metrics
    if (!this.renderMetrics.isEmpty()) {
      this.drawTitle(g, "[update]");

      for (RenderMetrics metric : this.renderMetrics) {
        this.drawMetric(g, metric.toString());
      }

      this.renderMetrics.clear();
    }
}
}
```
```java
class de.gurkenlabs.litiengine.graphics.emitters.Emitter {
public void deactivate() {
    if (!this.activated) {
      return;
    }

    this.activated = false;
    this.getParticles().clear();
    this.aliveTime = 0;
    this.activationTick = 0;
    this.lastSpawn = 0;
    Game.loop().detach(this);
}public void activate() {
    if (this.activated) {
      return;
    }

    this.activated = true;
    this.activationTick = Game.time().now();
    Game.loop().attach(this);
}@Override
  public void update() {
    if (this.isPaused()) {
      return;
    }

    // clear particles if the effect time to life is reached
    if (this.isFinished()) {
      for (EmitterFinishedListener listener : this.finishedListeners) {
        listener.finished(this);
      }

      this.delete();
      return;
    }

    final float updateRatio = (float) this.data().getUpdateRate() / Game.loop().getTickRate();
    for (final Particle p : this.getParticles().stream().collect(Collectors.toList())) {
      if (this.particleCanBeRemoved(p)) {
        // remove dead particles
        this.particles.remove(p);
        continue;
      }

      p.update(this.getOrigin(), updateRatio);
    }

    this.aliveTime = Game.time().since(this.activationTick);
    if ((this.data().getSpawnRate() == 0
        || Game.time().since(this.lastSpawn) >= this.data().getSpawnRate())) {
      this.lastSpawn = Game.time().now();
      this.spawnParticle();
    }
}
}
```
```java
class de.gurkenlabs.litiengine.entities.behavior.IBehaviorController {
public default void attach() {
    Game.loop().attach(this);
}public default void detach() {
    Game.loop().detach(this);
}
}
```
```java
class de.gurkenlabs.litiengine.abilities.AbilityExecution {
AbilityExecution(final Ability ability) {
    this.appliedEffects = new CopyOnWriteArrayList<>();
    this.ability = ability;
    this.executionTicks = Game.time().now();
    this.impactArea = ability.calculateImpactArea();
    this.castLocation = ability.getExecutor().getCenter();
    Game.loop().attach(this);
}@Override
  public void update() {
    // if there a no effects to apply -> unregister this instance and we're done
    if (this.getAbility().getEffects().isEmpty()
        || this.getAbility().getEffects().size() == this.getAppliedEffects().size()) {
      Game.loop().detach(this);
      return;
    }

    // handle all effects from the ability that were not applied yet
    for (final Effect effect : this.getAbility().getEffects()) {
      // if the ability was not executed yet or the delay of the effect is not
      // yet reached
      if (this.getAppliedEffects().contains(effect)
          || Game.time().since(this.getExecutionTicks()) < effect.getDelay()) {
        continue;
      }

      effect.apply(this.getExecutionImpactArea());
      this.getAppliedEffects().add(effect);
    }
}
}
```
```java
class de.gurkenlabs.litiengine.GameWindow$3 {
@Override
          public void windowGainedFocus(WindowEvent e) {
            Game.loop().setTickRate(Game.config().client().getMaxFps());
}@Override
          public void windowLostFocus(WindowEvent e) {
            if (Game.config().graphics().reduceFramesWhenNotFocused()) {
              Game.loop().setTickRate(NONE_FOCUS_MAX_FPS);
            }
}
}
```
```java
class de.gurkenlabs.litiengine.environment.EntitySpawner {
protected void spawnNewEntities() {
    if (this.getSpawnMode() != SpawnMode.CUSTOMSPAWNPOINTS && this.getSpawnPoints().isEmpty()) {
      return;
    }

    switch (this.getSpawnMode()) {
      case ALLSPAWNPOINTS:
        for (int i = 0; i < this.getSpawnPoints().size(); i++) {
          final int index = i;
          Game.loop()
              .perform(
                  this.getSpawnDelay() + this.getSpawnDelay() * i,
                  () -> this.spawn(this.getSpawnPoints().get(index), this.getSpawnAmount()));
        }
        break;
      case ONERANDOMSPAWNPOINT:
        this.spawn(Game.random().choose(this.getSpawnPoints()), this.getSpawnAmount());
        break;
      case RANDOMSPAWNPOINTS:
        for (int i = 0; i < this.getSpawnAmount(); i++) {
          Game.loop()
              .perform(
                  this.getSpawnDelay() + this.getSpawnDelay() * i,
                  () -> this.spawn(Game.random().choose(this.getSpawnPoints()), 1));
        }
        break;
      case CUSTOMSPAWNPOINTS:
        List<Spawnpoint> spawnPoints =
            this.customSpawnpoints != null
                ? this.customSpawnpoints.apply(this)
                : this.getCustomSpawnpoints();

        int index = 0;
        for (Spawnpoint spawn : spawnPoints) {
          Game.loop()
              .perform(
                  this.getSpawnDelay() + this.getSpawnDelay() * index, () -> this.spawn(spawn, 1));
          index++;
        }
        break;
      default:
        break;
    }
}
}
```
```java
class de.gurkenlabs.litiengine.tweening.TweenEngine {
@Override
  public void start() {
    Game.loop().attach(this);
}@Override
  public void terminate() {
    Game.loop().detach(this);
}
}
```
```java
class de.gurkenlabs.litiengine.gui.SpeechBubble {
public void hide() {
    Game.world().environment().removeRenderable(this);
    Game.loop().detach(this);
    if (activeSpeechBubbles.get(this.getEntity()) != null
        && activeSpeechBubbles.remove(this.getEntity()).equals(this)) {
      activeSpeechBubbles.remove(this.getEntity());
    }

    for (SpeechBubbleListener listener : this.listeners) {
      listener.hidden();
    }
}private SpeechBubble(
      final IEntity entity,
      final String text,
      @Nullable SpeechBubbleAppearance appearance,
      @Nullable Font font) {
    if (appearance == null) {
      this.appearance = DEFAULT_APPEARANCE;
    } else {
      this.appearance = appearance;
    }

    final SpeechBubble active = activeSpeechBubbles.get(entity);
    if (active != null) {
      active.hide();
    }
    this.setFont(font);

    this.textBoxWidth = (float) (entity.getWidth() * 4);
    this.entity = entity;

    this.currentText = text;
    this.currentTextDisplayTime = DISPLAYTIME_MIN + text.length() * DISPLAYTIME_PER_LETTER;

    this.lastTextDisplay = Game.time().now();
    this.createBubbleImage();
    entity.getEnvironment().add(this, RenderType.UI);
    Game.loop().attach(this);
    activeSpeechBubbles.put(entity, this);
}
}
```
```java
class de.gurkenlabs.litiengine.entities.Prop {
private void updateAnimationController() {
    IEntityAnimationController<?> controller = this.createAnimationController();
    this.getControllers().addController(controller);
    if (Game.world().environment() != null && Game.world().environment().isLoaded()) {
      Game.loop().attach(controller);
    }
}
}
```
```java
class de.gurkenlabs.litiengine.graphics.FreeFlightCamera {
public FreeFlightCamera(final Point2D focus) {
    this.setFocus(focus);
    this.velocity = DEFAULT_SCROLL_PIXELS_PER_SECOND;
    this.scrollPadding = DEFAULT_SCROLL_PADDING;
    this.setClampToMap(true);

    Game.loop().attach(this);
}private void handleFreeFlightCamera() {
    if (Game.world().environment() == null || Game.world().environment().getMap() == null) {
      return;
    }

    final Point2D mouseLocation = Input.mouse().getLocation();

    final double scrollSpeed =
        this.getVelocity()
            / (double) Game.loop().getTickRate()
            * Game.config().input().getMouseSensitivity();

    double x = this.getFocus().getX();
    double y = this.getFocus().getY();

    double deltaX = 0;
    if (mouseLocation.getX() < this.getScrollPadding()) {
      deltaX -= scrollSpeed;
    } else if (Game.window().getResolution().getWidth() - mouseLocation.getX()
        < this.getScrollPadding()) {
      deltaX += scrollSpeed;
    }

    double deltaY = 0;
    if (mouseLocation.getY() < this.getScrollPadding()) {
      deltaY -= scrollSpeed;
    } else if (Game.window().getResolution().getHeight() - mouseLocation.getY()
        < this.getScrollPadding()) {
      deltaY += scrollSpeed;
    }

    x += deltaX;
    y += deltaY;

    this.setFocus(new Point2D.Double(x, y));
}
}
```
```java
class de.gurkenlabs.litiengine.environment.Environment {
private static void dispose(final Collection<? extends IEntity> entities) {
    for (final IEntity entity : entities) {
      if (entity instanceof IUpdateable) {
        Game.loop().detach((IUpdateable) entity);
      }

      entity.detachControllers();
    }
}private static void loadUpdatableOrEmitterEntity(IEntity entity) {
    if (entity instanceof Emitter) {
      final Emitter emitter = (Emitter) entity;
      if (emitter.isActivateOnInit()) {
        emitter.activate();
      }
    } else if (entity instanceof IUpdateable) {
      Game.loop().attach((IUpdateable) entity);
    }
}private void unload(final IEntity entity) {
    // 1. remove from physics engine
    if (entity instanceof ICollisionEntity) {
      Game.physics().remove((ICollisionEntity) entity);
    }

    // 2. unregister from update
    if (entity instanceof IUpdateable) {
      Game.loop().detach((IUpdateable) entity);
    }

    if (entity instanceof IMobileEntity) {
      this.removeGravity((IMobileEntity) entity);
    }

    // 3. detach all controllers
    entity.detachControllers();

    if (entity instanceof Emitter) {
      Emitter em = (Emitter) entity;
      em.deactivate();
    }

    if (this.loaded && (entity instanceof LightSource || entity instanceof StaticShadow)) {
      this.updateLighting(entity);
    }

    entity.removed(this);
}
}
```
```java
class de.gurkenlabs.litiengine.graphics.animation.Animation {
@Override
  public void update() {
    // do nothing if the animation is not playing or the current keyframe is not finished
    if (!this.isPlaying()
        || Game.time().since(this.lastFrameUpdate) < this.getCurrentKeyFrame().getDuration()) {
      return;
    }

    // if we are not looping and the last keyframe is finished, we terminate the animation
    if (!this.isLooping() && this.isLastKeyFrame()) {
      this.terminate();
      return;
    }

    // make sure, we stay inside the keyframe list
    final int newFrameIndex =
        (this.getKeyframes().indexOf(this.currentFrame) + 1) % this.getKeyframes().size();
    final KeyFrame previousFrame = this.currentFrame;
    this.currentFrame = this.getKeyframes().get(newFrameIndex);

    for (KeyFrameListener listener : this.listeners) {
      listener.currentFrameChanged(previousFrame, this.currentFrame);
    }

    this.lastFrameUpdate = Game.loop().getTicks();
}public void restart() {
    this.currentFrame = this.firstFrame;
    this.lastFrameUpdate = Game.loop().getTicks();
}
}
```
```java
class de.gurkenlabs.litiengine.physics.MovementController {
@Override
  public void attach() {
    Game.loop().attach(this);
}private void handleForces() {
    // clean up forces
    this.activeForces.forEach(
        x -> {
          if (x.hasEnded()) {
            this.activeForces.remove(x);
          }
        });

    if (this.activeForces.isEmpty()) {
      return;
    }

    // disable turn-on-move for force handling
    boolean turn = this.getEntity().turnOnMove();
    this.getEntity().setTurnOnMove(false);
    try {
      double deltaX = 0;
      double deltaY = 0;
      for (final Force force : this.activeForces) {
        if (force.cancelOnReached() && force.hasReached(this.getEntity())) {
          force.end();
          continue;
        }

        final Point2D collisionBoxCenter = this.getEntity().getCollisionBoxCenter();
        final double angle =
            GeometricUtilities.calcRotationAngleInDegrees(collisionBoxCenter, force.getLocation());
        final double strength =
            Game.loop().getDeltaTime() * 0.001f * force.getStrength() * Game.loop().getTimeScale();
        deltaX += GeometricUtilities.getDeltaX(angle, strength);
        deltaY += GeometricUtilities.getDeltaY(angle, strength);
      }

      final Point2D target =
          new Point2D.Double(this.getEntity().getX() + deltaX, this.getEntity().getY() + deltaY);
      final boolean success = Game.physics().move(this.getEntity(), target);
      if (!success) {
        for (final Force force : this.activeForces) {
          if (force.cancelOnCollision()) {
            force.end();
          }
        }
      }
    } finally {
      this.getEntity().setTurnOnMove(turn);
    }
}@Override
  public void detach() {
    Game.loop().detach(this);
}public void handleMovement() {
    if (!this.isMovementAllowed()) {
      this.velocity = 0;
      return;
    }

    // max distance an entity can travel within one tick
    final double maxPixelsPerTick = this.getEntity().getTickVelocity();
    final double deltaTime = Game.loop().getDeltaTime() * Game.loop().getTimeScale();

    final double acceleration =
        this.getEntity().getAcceleration() == 0
            ? maxPixelsPerTick
            : deltaTime / this.getEntity().getAcceleration() * maxPixelsPerTick;
    final double deceleration =
        this.getEntity().getDeceleration() == 0
            ? this.getVelocity()
            : deltaTime / this.getEntity().getDeceleration() * maxPixelsPerTick;

    double dx = this.getDx();
    double dy = this.getDy();
    this.setDx(0);
    this.setDy(0);

    final double deltaVelocity =
        Math.min(Math.sqrt(Math.pow(dx, 2) + Math.pow(dy, 2)), acceleration);
    if (deltaVelocity != 0) {
      double newVelocity = this.getVelocity() + deltaVelocity;
      this.setVelocity(newVelocity);
    } else {
      final double newVelocity = Math.max(0, this.getVelocity() - deceleration);
      this.setVelocity(newVelocity);
      dx = GeometricUtilities.getDeltaX(this.moveAngle);
      dy = GeometricUtilities.getDeltaY(this.moveAngle);
    }

    if (this.getVelocity() == 0) {
      this.moveAngle = 0;
      return;
    }

    // actually move entity
    this.moveEntity(dx, dy);
}
}
```
```java
class de.gurkenlabs.litiengine.graphics.animation.AnimationController {
public void detach() {
    Game.loop().detach(this);
}public void attach() {
    Game.loop().attach(this);
}
}
```
```java
class de.gurkenlabs.litiengine.graphics.Camera {
@Override
  public void setZoom(final float targetZoom, final int delay) {
    if (delay == 0) {

      this.zoom = targetZoom;
      this.targetZoom = 0;
      this.zoomDelay = 0;
      this.zoomTick = 0;
      this.zoomStep = 0;

      final ZoomChangedEvent event = new ZoomChangedEvent(this, targetZoom);
      for (final ZoomChangedListener listener : this.zoomListeners) {
        listener.zoomChanged(event);
      }
    } else {
      this.zoomTick = Game.time().now();
      this.targetZoom = targetZoom;
      this.zoomDelay = delay;

      final double tickduration = 1000 / (double) Game.loop().getTickRate();
      final double tickAmount = delay / tickduration;
      final float totalDelta = this.targetZoom - this.zoom;
      this.zoomStep = tickAmount > 0 ? (float) (totalDelta / tickAmount) : totalDelta;
    }
}
}
```
```java
class de.gurkenlabs.litiengine.Game {
public static synchronized void init(String... args) {
    if (initialized) {
      log().log(Level.INFO, "The game has already been initialized.");
      return;
    }

    log.init();
    handleCommandLineArguments(args);

    config().load();
    Locale.setDefault(new Locale(config().client().getCountry(), config().client().getLanguage()));

    gameLoop = new GameLoop("Main Update Loop", config().client().getMaxFps());
    loop().attach(physics());
    loop().attach(world());

    // setup default exception handling for render and update loop
    setUncaughtExceptionHandler(
        new DefaultUncaughtExceptionHandler(config().client().exitOnError()));

    screenManager = new ScreenManager();
    gameWindow = new GameWindow();

    // initialize  the game window
    window().init();
    world.setCamera(new Camera());

    for (GameListener listener : gameListeners) {
      listener.initialized(args);
    }

    if (!isInNoGUIMode()) {
      window().getRenderComponent().onRendered(g -> metrics().render(g));

      graphics()
          .addEntityRenderedListener(
              e -> DebugRenderer.renderEntityDebugInfo(e.getGraphics(), e.getEntity()));

      window().getRenderComponent().onFpsChanged(fps -> metrics().setFramesPerSecond(fps));
      window()
          .setIcons(
              Arrays.asList(
                  Resources.images().get("liti-logo-x16.png"),
                  Resources.images().get("liti-logo-x20.png"),
                  Resources.images().get("liti-logo-x32.png"),
                  Resources.images().get("liti-logo-x48.png")));

      Input.keyboard()
          .onKeyTyped(
              KeyEvent.VK_PRINTSCREEN,
              key -> {
                // don't take a screenshot if a modifier is active
                if (key.getModifiers() != 0) {
                  return;
                }

                window().getRenderComponent().takeScreenshot();
              });
    }

    Runtime.getRuntime().addShutdownHook(new Thread(Game::terminate, "Shutdown"));

    initialized = true;
}
}
```
```java
class de.gurkenlabs.litiengine.entities.Creature {
protected void updateAnimationController() {
    IEntityAnimationController<?> controller = this.createAnimationController();
    this.getControllers().addController(controller);
    if (Game.world().environment() != null && Game.world().environment().isLoaded()) {
      Game.loop().attach(controller);
    }
}@Override
  public float getTickVelocity() {
    // pixels per ms multiplied by the passed ms
    // ensure that entities don't travel too far in case of lag
    return Math.min(Game.loop().getDeltaTime(), GameLoop.TICK_DELTATIME_LAG)
        * 0.001F
        * this.getVelocity().get()
        * Game.loop().getTimeScale();
}
}
```
Depth: 2
```java
class de.gurkenlabs.litiengine.environment.GameWorld {
public void clear() {
    this.unloadEnvironment();
    this.environments.clear();
    this.setCamera(null);
    Game.physics().clear();

    this.environmentListeners.clear();
    this.environmentLoadedListeners.clear();
    this.environmentUnloadedListeners.clear();

    this.listeners.clear();
    this.loadedListeners.clear();
    this.unloadedListeners.clear();
}@Nullable
  public Environment loadEnvironment(IMap map) {
    Environment env = this.getEnvironment(map);
    this.loadEnvironment(env);
    return env;
}@Nullable
  public Environment loadEnvironment(String mapName) {
    Environment env = this.getEnvironment(mapName);
    this.loadEnvironment(env);
    return env;
}
}
```
```java
class de.gurkenlabs.litiengine.GameWindow {
GameWindow() {
    this.hostControl = new JFrame();

    this.resolutionChangedListeners = new CopyOnWriteArrayList<>();

    this.renderCanvas = new RenderComponent(Game.config().graphics().getResolution());
    this.cursor = new MouseCursor();
    if (!Game.isInNoGUIMode()) {
      this.hostControl.setBackground(Color.BLACK);
      this.hostControl.add(this.renderCanvas);

      this.initializeEventListeners();

      this.hostControl.setTitle(Game.info().getTitle());
      this.hostControl.setDefaultCloseOperation(WindowConstants.DO_NOTHING_ON_CLOSE);
      initializeWindowEventListeners(this.hostControl);
    }
}
}
```
```java
class de.gurkenlabs.litiengine.GameTime {
public long sinceEnvironmentLoad() {
    return this.since(this.environmentLoaded);
}public long since(final long tick) {
    return toMilliseconds(Game.loop().getTicks() - tick);
}public long sinceGameStart() {
    return this.toMilliseconds(Game.loop().getTicks());
}
}
```
```java
class de.gurkenlabs.litiengine.abilities.effects.Effect {
protected void cease(final EffectApplication appliance) {
    // 1. cease the effect for all affected entities
    for (final ICombatEntity entity : appliance.getAffectedEntities()) {
      this.cease(entity);
    }

    // 2. apply follow up effects
    this.getFollowUpEffects().forEach(followUp -> followUp.apply(appliance.getImpactArea()));
}protected boolean hasEnded(final EffectApplication appliance) {
    final long effectDuration = Game.time().since(appliance.getAppliedTicks());
    return effectDuration > this.getDuration();
}
}
```
```java
class de.gurkenlabs.litiengine.abilities.effects.EffectApplication {
protected EffectApplication(final List<ICombatEntity> affectedEntities, final Shape impactArea) {
    this.applied = Game.time().now();
    this.affectedEntities = affectedEntities;
    this.impactArea = impactArea;
}
}
```
```java
class de.gurkenlabs.litiengine.entities.CombatEntity {
@Override
  public boolean wasHit(int timeSpan) {
    return Game.time().since(this.lastHit) < timeSpan;
}@Override
  public void hit(final int damage, @Nullable final Ability ability) {
    if (this.isDead()) {
      return;
    }

    if (!this.isIndestructible()) {
      this.getHitPoints().modifyBaseValue(new AttributeModifier<>(Modification.SUBTRACT, damage));
    }

    final EntityHitEvent event = new EntityHitEvent(this, ability, damage, this.isDead());

    for (final CombatEntityListener listener : this.listeners) {
      listener.hit(event);
    }

    for (final CombatEntityHitListener listener : this.hitListeners) {
      listener.hit(event);
    }

    if (this.isDead()) {
      this.fireDeathEvent();
      this.setCollision(false);
    }

    this.lastHit = Game.time().now();
}
}
```
```java
class de.gurkenlabs.litiengine.graphics.ImageEffect {
protected ImageEffect(final int ttl, final String name) {
    this.ttl = ttl;
    this.name = name;
    this.aliveTick = Game.time().now();
}@Override
  public long getAliveTime() {
    return Game.time().since(this.aliveTick);
}
}
```
```java
class de.gurkenlabs.litiengine.abilities.AbilityExecution {
AbilityExecution(final Ability ability) {
    this.appliedEffects = new CopyOnWriteArrayList<>();
    this.ability = ability;
    this.executionTicks = Game.time().now();
    this.impactArea = ability.calculateImpactArea();
    this.castLocation = ability.getExecutor().getCenter();
    Game.loop().attach(this);
}@Override
  public void update() {
    // if there a no effects to apply -> unregister this instance and we're done
    if (this.getAbility().getEffects().isEmpty()
        || this.getAbility().getEffects().size() == this.getAppliedEffects().size()) {
      Game.loop().detach(this);
      return;
    }

    // handle all effects from the ability that were not applied yet
    for (final Effect effect : this.getAbility().getEffects()) {
      // if the ability was not executed yet or the delay of the effect is not
      // yet reached
      if (this.getAppliedEffects().contains(effect)
          || Game.time().since(this.getExecutionTicks()) < effect.getDelay()) {
        continue;
      }

      effect.apply(this.getExecutionImpactArea());
      this.getAppliedEffects().add(effect);
    }
}
}
```
```java
class de.gurkenlabs.litiengine.tweening.TweenEngine {
@Override
  public void update() {
    for (final Tweenable target : this.getTweens().keySet()) {
      for (final Tween tween : this.getTweens().get(target).values()) {
        if (tween.hasStopped()) {
          continue;
        }
        final long elapsed = Game.time().since(tween.getStartTime());
        if (elapsed >= tween.getDuration()) {
          tween.stop();
          continue;
        }
        final float[] currentValues = new float[tween.getTargetValues().length];
        for (int i = 0; i < tween.getTargetValues().length; i++) {
          currentValues[i] =
              tween.getStartValues()[i]
                  + tween.getEquation().compute(elapsed / (float) tween.getDuration())
                      * (tween.getTargetValues()[i] - tween.getStartValues()[i]);
        }
        tween.getTarget().setTweenValues(tween.getType(), currentValues);
      }
    }
}
}
```
```java
class de.gurkenlabs.litiengine.gui.SpeechBubble {
public static SpeechBubble create(
      final IEntity entity, final String text, SpeechBubbleAppearance appearance, Font font) {
    return new SpeechBubble(entity, text, appearance, font);
}public static SpeechBubble create(final IEntity entity, final Font font, final String text) {
    SpeechBubbleAppearance app =
        new SpeechBubbleAppearance(
            DEFAULT_APPEARANCE.getForeColor(),
            DEFAULT_APPEARANCE.getBackgroundColor1(),
            DEFAULT_APPEARANCE.getBorderColor(),
            DEFAULT_APPEARANCE.getPadding());
    return new SpeechBubble(entity, text, app, font);
}public static SpeechBubble create(final IEntity entity, final String text) {
    return new SpeechBubble(entity, text, null, GuiProperties.getDefaultFont());
}@Override
  public void update() {
    if (this.currentText == null) {
      this.hide();
      return;
    }

    this.entityCenter = Game.world().camera().getViewportLocation(this.getEntity().getCenter());

    // old text was displayed long enough
    if (this.lastTextDisplay != 0
        && Game.time().since(this.lastTextDisplay) > this.currentTextDisplayTime) {
      this.currentText = null;
      this.lastTextDisplay = 0;
      return;
    }

    // display new text
    if (this.textIndex < this.currentText.length()
        && Game.time().since(this.lastCharPoll) > LETTER_WRITE_DELAY) {
      this.textIndex++;
      this.lastCharPoll = Game.time().now();
      if (this.typeSound != null) {
        Game.audio().playSound(this.typeSound, this.getEntity());
      }
    }

    // continue displaying currently displayed text
}private SpeechBubble(
      final IEntity entity,
      final String text,
      final Sound typeSound,
      SpeechBubbleAppearance appearance,
      Font font) {
    this(entity, text, appearance, font);
    this.typeSound = typeSound;
}private SpeechBubble(
      final IEntity entity,
      final String text,
      @Nullable SpeechBubbleAppearance appearance,
      @Nullable Font font) {
    if (appearance == null) {
      this.appearance = DEFAULT_APPEARANCE;
    } else {
      this.appearance = appearance;
    }

    final SpeechBubble active = activeSpeechBubbles.get(entity);
    if (active != null) {
      active.hide();
    }
    this.setFont(font);

    this.textBoxWidth = (float) (entity.getWidth() * 4);
    this.entity = entity;

    this.currentText = text;
    this.currentTextDisplayTime = DISPLAYTIME_MIN + text.length() * DISPLAYTIME_PER_LETTER;

    this.lastTextDisplay = Game.time().now();
    this.createBubbleImage();
    entity.getEnvironment().add(this, RenderType.UI);
    Game.loop().attach(this);
    activeSpeechBubbles.put(entity, this);
}
}
```
```java
class de.gurkenlabs.litiengine.gui.TextFieldComponent {
@Override
  public void render(final Graphics2D g) {
    super.render(g);
    g.setFont(this.getFont());
    final FontMetrics fm = g.getFontMetrics();

    if (this.isSelected() && Game.time().since(this.lastToggled) > this.flickerDelay) {
      this.cursorVisible = !this.cursorVisible;
      this.lastToggled = Game.time().now();
    }
    if (this.isSelected() && this.cursorVisible) {
      final Rectangle2D cursor =
          new Rectangle2D.Double(
              this.getX() + this.getTextX() + fm.stringWidth(this.getTextToRender(g)),
              this.getY() + this.getTextY(),
              this.getFont().getSize2D() * 3 / 5,
              this.getFont().getSize2D() * 1 / 5);
      g.setColor(this.getAppearance().getForeColor());
      g.fill(cursor);
    }
}
}
```
```java
class de.gurkenlabs.litiengine.entities.Prop {
public Prop(
      final Point2D location, @Nullable final String spritesheetName, final Material material) {
    super();
    this.rotation = Rotation.NONE;
    this.spritesheetName = spritesheetName;
    this.material = material;
    this.setLocation(location);
    this.updateAnimationController();
}public void setSpritesheetName(@Nullable final String spriteName) {
    this.spritesheetName = spriteName;
    this.updateAnimationController();
}
}
```
```java
class de.gurkenlabs.litiengine.tweening.Tween {
public Tween begin() {
    this.started = Game.time().now();
    this.stopped = false;
    return this;
}
}
```
```java
class de.gurkenlabs.litiengine.graphics.emitters.particles.Particle {
public void update(final Point2D emitterOrigin, final float updateRatio) {
    if (this.aliveTick == 0) {
      this.aliveTick = Game.time().now();
    }

    this.aliveTime = Game.time().since(this.aliveTick);
    if (this.timeToLiveReached()) {
      return;
    }

    if (this.colliding) {
      return;
    }

    if (this.getDeltaWidth() != 0) {
      this.width += this.getDeltaWidth() * updateRatio;
    }

    if (this.getDeltaHeight() != 0) {
      this.height += this.getDeltaHeight() * updateRatio;
    }

    if (this.getDeltaAngle() != 0) {
      this.angle += this.getDeltaAngle() * updateRatio;
    }

    // test for ray cast collision
    final float targetX = this.x + this.getVelocityX() * updateRatio;
    final float targetY = this.y + this.getVelocityY() * updateRatio;

    if (targetX == this.x && targetY == this.y) {
      return;
    }

    if (this.checkForCollision(emitterOrigin, targetX, targetY)) {
      return;
    }

    if (this.getVelocityX() != 0) {
      this.x = targetX;
    }

    if (this.getVelocityY() != 0) {
      this.y = targetY;
    }

    if (this.getAccelerationX() != 0) {
      this.velocityX += this.getAccelerationX() * updateRatio;
    }

    if (this.getAccelerationY() != 0) {
      this.velocityY += this.getAccelerationY() * updateRatio;
    }
}
}
```
```java
class de.gurkenlabs.litiengine.graphics.animation.Animation {
@Override
  public void start() {
    this.playing = true;
    if (this.getKeyframes().isEmpty()) {
      return;
    }

    this.restart();
}@Override
  public void update() {
    // do nothing if the animation is not playing or the current keyframe is not finished
    if (!this.isPlaying()
        || Game.time().since(this.lastFrameUpdate) < this.getCurrentKeyFrame().getDuration()) {
      return;
    }

    // if we are not looping and the last keyframe is finished, we terminate the animation
    if (!this.isLooping() && this.isLastKeyFrame()) {
      this.terminate();
      return;
    }

    // make sure, we stay inside the keyframe list
    final int newFrameIndex =
        (this.getKeyframes().indexOf(this.currentFrame) + 1) % this.getKeyframes().size();
    final KeyFrame previousFrame = this.currentFrame;
    this.currentFrame = this.getKeyframes().get(newFrameIndex);

    for (KeyFrameListener listener : this.listeners) {
      listener.currentFrameChanged(previousFrame, this.currentFrame);
    }

    this.lastFrameUpdate = Game.loop().getTicks();
}
}
```
```java
class de.gurkenlabs.litiengine.graphics.animation.AnimationController {
@Override
  public void update() {
    for (final Animation animation : this.getAll()) {
      animation.update();
    }

    if (this.getCurrent() != null && this.getCurrent().isPaused()) {
      return;
    }

    final boolean playbackFinished = this.getCurrent() != null && !this.getCurrent().isPlaying();
    if (playbackFinished) {
      for (final AnimationListener listener : this.listeners) {
        listener.finished(this.getCurrent());
      }
    }

    if (this.getCurrent() == null || playbackFinished) {
      if (this.getDefault() != null) {
        this.play(this.getDefault().getName());
      } else {
        this.currentAnimation = null;
      }
    }
}
}
```
```java
class de.gurkenlabs.litiengine.graphics.RenderComponent {
private void handleFade() {
    if (this.fadeOutStart != -1) {
      final long timePassed = Game.time().since(this.fadeOutStart);
      this.currentAlpha = MathUtilities.clamp(1 - timePassed / (float) this.fadeOutTime, 0, 1);
      if (this.currentAlpha == 0f) {
        this.fadeOutStart = -1;
        this.fadeOutTime = -1;
      }

      return;
    }

    if (this.fadeInStart != -1) {
      final long timePassed = Game.time().since(this.fadeInStart);
      this.currentAlpha = MathUtilities.clamp(timePassed / (float) this.fadeInTime, 0, 1);
      if (this.currentAlpha == 1f) {
        this.fadeInStart = -1;
        this.fadeInTime = -1;
        this.currentAlpha = Float.NaN;
      }
    }
}public void fadeOut(final int ms) {
    this.fadeInStart = -1;
    this.fadeInTime = -1;
    this.fadeOutStart = Game.time().now();
    this.fadeOutTime = ms;
}public void fadeIn(final int ms) {
    this.fadeOutStart = -1;
    this.fadeOutTime = -1;
    this.fadeInStart = Game.time().now();
    this.fadeInTime = ms;
}
}
```
```java
class de.gurkenlabs.litiengine.entities.Trigger {
private boolean activate(final IEntity activator, final int tar) {
    if (!this.isLoaded()
        || this.isOneTimeTrigger && this.isActivated
        || this.getActivationType() == TriggerActivation.COLLISION
            && activator != null
            && this.collisionActivated.contains(activator)) {
      return false;
    }

    if (this.getCooldown() > 0 && Game.time().since(this.lastActivation) < this.getCooldown()) {
      return false;
    }

    List<Integer> triggerTargets = this.getTargets(tar);

    final TriggerEvent te = new TriggerEvent(this, activator, triggerTargets);

    if (!this.checkActivationPredicates(te)) {
      return false;
    }

    this.isActivated = true;
    if (activator != null) {
      this.collisionActivated.add(activator);
    }

    // if we actually have a trigger target, we send the message to the target
    for (final int target : triggerTargets) {
      final IEntity entity = this.getEnvironment().get(target);
      if (entity == null) {
        log.log(
            Level.WARNING,
            "trigger [{0}] was activated, but the trigger target [{1}] could not be found on the environment",
            new Object[] {this, target});
        continue;
      }

      entity.sendMessage(this, this.message);
    }

    // also send the trigger event to all registered consumers
    for (final TriggerActivatedListener listener : this.activatedListeners) {
      listener.activated(te);
    }

    if (this.isOneTimeTrigger) {
      this.getEnvironment().remove(this);
    }

    this.lastActivation = Game.time().now();
    return true;
}
}
```
```java
class de.gurkenlabs.litiengine.graphics.Camera {
private boolean isShakeEffectActive() {
    return this.getShakeTick() != 0
        && Game.time().since(this.getShakeTick()) < this.getShakeDuration();
}@Override
  public void update() {
    if (Game.world().camera() != null && !Game.world().camera().equals(this)) {
      return;
    }

    if (this.targetZoom > 0) {
      if (Game.time().since(this.zoomTick) >= this.zoomDelay) {
        this.zoom = this.targetZoom;
        this.targetZoom = 0;
        this.zoomDelay = 0;
        this.zoomTick = 0;
        this.zoomStep = 0;
      } else {
        this.zoom += this.zoomStep;
      }

      final ZoomChangedEvent event = new ZoomChangedEvent(this, this.getZoom());
      for (final ZoomChangedListener listener : this.zoomListeners) {
        listener.zoomChanged(event);
      }
    }

    if (this.panTime > 0) {
      if (--this.panTime <= 0) {
        this.setFocus(this.targetFocus);
        this.targetFocus = null;
      } else {
        double diff = this.panTime / (this.panTime + 1.0);
        this.focus =
            new Point2D.Double(
                this.focus.getX() * diff + this.targetFocus.getX() * (1.0 - diff),
                this.focus.getY() * diff + this.targetFocus.getY() * (1.0 - diff));
      }
    }

    if (!this.isShakeEffectActive()) {
      this.shakeOffsetX = 0;
      this.shakeOffsetY = 0;
      return;
    }

    if (Game.time().since(this.lastShake) > this.shakeDelay) {
      this.shakeOffsetX = this.getShakeIntensity() * ThreadLocalRandom.current().nextGaussian();
      this.shakeOffsetY = this.getShakeIntensity() * ThreadLocalRandom.current().nextGaussian();
      this.lastShake = Game.time().now();
    }
}@Override
  public void setZoom(final float targetZoom, final int delay) {
    if (delay == 0) {

      this.zoom = targetZoom;
      this.targetZoom = 0;
      this.zoomDelay = 0;
      this.zoomTick = 0;
      this.zoomStep = 0;

      final ZoomChangedEvent event = new ZoomChangedEvent(this, targetZoom);
      for (final ZoomChangedListener listener : this.zoomListeners) {
        listener.zoomChanged(event);
      }
    } else {
      this.zoomTick = Game.time().now();
      this.targetZoom = targetZoom;
      this.zoomDelay = delay;

      final double tickduration = 1000 / (double) Game.loop().getTickRate();
      final double tickAmount = delay / tickduration;
      final float totalDelta = this.targetZoom - this.zoom;
      this.zoomStep = tickAmount > 0 ? (float) (totalDelta / tickAmount) : totalDelta;
    }
}@Override
  public void shake(final double intensity, final int delay, final int shakeDuration) {
    this.shakeTick = Game.time().now();
    this.shakeDelay = delay;
    this.shakeIntensity = intensity;
    this.shakeDuration = shakeDuration;
}
}
```
```java
class de.gurkenlabs.litiengine.entities.Creature {
public void setSpritesheetName(String spritesheetName) {
    if (this.spritesheetName != null && this.spritesheetName.equals(spritesheetName)) {
      return;
    }

    this.spritesheetName = spritesheetName;
    this.updateAnimationController();
}public boolean isIdle() {
    return Game.time().since(this.lastMoved) > IDLE_DELAY;
}@Override
  public void setLocation(final Point2D position) {
    if (this.isDead() || position == null) {
      return;
    }

    final Point2D oldLocation = this.getLocation();
    super.setLocation(position);

    if (Game.hasStarted() && this.isLoaded()) {
      this.lastMoved = Game.time().now();
      this.fireMovedEvent(
          new EntityMovedEvent(
              this, this.getX() - oldLocation.getX(), this.getY() - oldLocation.getY()));
    }
}
}
```
```java
class de.gurkenlabs.litiengine.gui.screens.ScreenManager {
public void display(final String screenName) {
    if (this.current() != null && this.current().getName().equalsIgnoreCase(screenName)) {
      log.log(
          Level.INFO,
          "Skipping displaying of screen {0} because it is already the current screen.",
          screenName);
      return;
    }

    if (this.screens.stream()
        .noneMatch(element -> element.getName().equalsIgnoreCase(screenName))) {
      log.log(
          Level.WARNING,
          "Could not display the screen {0} because there is no screen with the specified name.",
          screenName);
      return;
    }

    Screen screen = this.get(screenName);
    if (screen == null) {
      return;
    }

    this.display(screen);
}public void add(final Screen screen) {
    screen.setWidth(Game.window().getWidth());
    screen.setHeight(Game.window().getHeight());
    this.screens.add(screen);

    if (this.current() == null) {
      this.display(screen);
    }
}public void remove(Screen screen) {
    this.screens.remove(screen);
    if (this.current() == screen) {
      if (!this.screens.isEmpty()) {
        this.display(this.screens.get(0));
      } else {
        this.display((Screen) null);
      }
    }
}public void display(@Nullable final Screen screen) {
    if (Game.hasStarted() && Game.time().since(this.lastScreenChange) < this.getChangeCooldown()) {
      log.log(
          Level.INFO,
          "Skipping displaying of screen {0} because screen changing is currently on cooldown.",
          screen != null ? screen.getName() : "");
      return;
    }

    final Screen previous = this.current();
    if (previous != null) {
      previous.suspend();
    }

    if (screen != null && !this.screens.contains(screen)) {
      this.screens.add(screen);
    }

    this.currentScreen = screen;
    if (!Game.isInNoGUIMode() && this.current() != null) {
      this.current().prepare();
    }

    this.lastScreenChange = Game.loop().getTicks();

    final ScreenChangedEvent event = new ScreenChangedEvent(this.current(), previous);
    for (final ScreenChangedListener listener : this.screenChangedListeners) {
      listener.changed(event);
    }
}
}
```
```java
class de.gurkenlabs.litiengine.abilities.Ability {
public boolean isOnCooldown() {
    return (this.getCurrentExecution() != null
        && this.getCurrentExecution().getExecutionTicks() > 0
        && Game.time().since(this.getCurrentExecution().getExecutionTicks())
            < this.getAttributes().cooldown().get());
}public boolean isActive() {
    return this.getCurrentExecution() != null
        && Game.time().since(this.getCurrentExecution().getExecutionTicks())
            < this.getAttributes().duration().get();
}@Nullable
  public AbilityExecution cast() {
    if (!this.canCast()) {
      return null;
    }
    this.currentExecution = new AbilityExecution(this);

    for (final AbilityCastListener listener : this.abilityCastListeners) {
      listener.abilityCast(this.currentExecution);
    }

    return this.getCurrentExecution();
}public float getRemainingCooldownInSeconds() {
    if (this.getCurrentExecution() == null
        || this.getExecutor() == null
        || this.getExecutor().isDead()) {
      return 0;
    }

    // calculate cooldown in seconds
    return (float)
        (!this.canCast()
            ? (this.getAttributes().cooldown().get()
                    - Game.time().since(this.getCurrentExecution().getExecutionTicks()))
                * 0.001
            : 0);
}
}
```
```java
class de.gurkenlabs.litiengine.entities.EntityHitEvent {
EntityHitEvent(
      final ICombatEntity hitEntity,
      @Nullable final Ability ability,
      final int damage,
      final boolean kill) {
    super(hitEntity);
    this.executor = ability != null ? ability.getExecutor() : null;
    this.hitEntity = hitEntity;
    this.ability = ability;
    this.damage = damage;
    this.kill = kill;
    this.time = Game.time().now();
}
}
```
```java
class de.gurkenlabs.litiengine.graphics.emitters.Emitter {
public void delete() {
    this.deactivate();
    if (Game.world().environment() != null) {
      Game.world().environment().remove(this);
    }
}public void activate() {
    if (this.activated) {
      return;
    }

    this.activated = true;
    this.activationTick = Game.time().now();
    Game.loop().attach(this);
}@Override
  public void update() {
    if (this.isPaused()) {
      return;
    }

    // clear particles if the effect time to life is reached
    if (this.isFinished()) {
      for (EmitterFinishedListener listener : this.finishedListeners) {
        listener.finished(this);
      }

      this.delete();
      return;
    }

    final float updateRatio = (float) this.data().getUpdateRate() / Game.loop().getTickRate();
    for (final Particle p : this.getParticles().stream().collect(Collectors.toList())) {
      if (this.particleCanBeRemoved(p)) {
        // remove dead particles
        this.particles.remove(p);
        continue;
      }

      p.update(this.getOrigin(), updateRatio);
    }

    this.aliveTime = Game.time().since(this.activationTick);
    if ((this.data().getSpawnRate() == 0
        || Game.time().since(this.lastSpawn) >= this.data().getSpawnRate())) {
      this.lastSpawn = Game.time().now();
      this.spawnParticle();
    }
}
}
```
```java
class de.gurkenlabs.litiengine.GameLoop {
@Override
  public int perform(int delay, Runnable action) {
    final long d = Game.time().toTicks(delay);

    TimedAction a = new TimedAction(this.getTicks() + d, action);
    this.actions.add(a);

    return a.getId();
}
}
```
```java
class de.gurkenlabs.litiengine.environment.EntitySpawner {
protected boolean shouldSpawn() {
    return this.lastSpawnWave == 0
        || Game.time().since(this.lastSpawnWave) >= this.getSpawnInterval();
}@Override
  public void update() {
    if (!this.shouldSpawn()) {
      return;
    }

    this.spawnNewEntities();
    this.lastSpawnWave = Game.time().now();
}
}
```
```java
class de.gurkenlabs.litiengine.graphics.FreeFlightCamera {
@Override
  public void update() {
    this.handleFreeFlightCamera();
}public FreeFlightCamera(double x, double y) {
    this(new Point2D.Double(x, y));
}
}
```
```java
class de.gurkenlabs.litiengine.environment.Environment {
public void unload() {
    if (!this.loaded) {
      return;
    }

    // unregister all updatable entities from the current environment
    for (final IEntity entity : this.allEntities.values()) {
      this.unload(entity);
    }

    this.loaded = false;
    this.fireEvent(l -> l.unloaded(this));
}private static void loadUpdatableOrEmitterEntity(IEntity entity) {
    if (entity instanceof Emitter) {
      final Emitter emitter = (Emitter) entity;
      if (emitter.isActivateOnInit()) {
        emitter.activate();
      }
    } else if (entity instanceof IUpdateable) {
      Game.loop().attach((IUpdateable) entity);
    }
}public void clear() {
    Game.physics().clear();

    this.combatEntities.clear();
    this.mobileEntities.clear();
    this.gravityForces.clear();
    this.layerEntities.clear();
    this.entitiesByTag.clear();
    this.allEntities.clear();

    for (RenderType renderType : RenderType.values()) {
      this.miscEntities.get(renderType).clear();
      this.renderListeners.get(renderType).clear();
      this.renderables.get(renderType).clear();
    }

    dispose(this.allEntities.values());
    dispose(this.triggers);
    this.emitters.clear();
    this.colliders.clear();
    this.props.clear();
    this.creatures.clear();
    this.staticShadows.clear();
    this.combatEntities.clear();
    this.mobileEntities.clear();
    this.lightSources.clear();
    this.spawnPoints.clear();
    this.soundSources.clear();
    this.mapAreas.clear();
    this.triggers.clear();

    this.ambientLight = null;
    this.staticShadowLayer = null;

    for (Map<Integer, IEntity> type : this.miscEntities.values()) {
      type.clear();
    }

    this.initialized = false;

    this.fireEvent(l -> l.cleared(this));
}private void load(final IEntity entity) {
    // an entity can only exist on one environment at a time, so remove it from the current one
    if (entity.getEnvironment() != null) {
      entity.getEnvironment().remove(entity);
    }

    // 1. add to physics engine
    loadPhysicsEntity(entity);

    // 2. register for update or activate
    loadUpdatableOrEmitterEntity(entity);

    // 3. if a gravity is defined, add a gravity force to the entity
    if (entity instanceof IMobileEntity && this.getGravity() != 0) {
      this.addGravityForce((IMobileEntity) entity);
    }

    // 4. attach all controllers
    entity.attachControllers();

    if (this.loaded && (entity instanceof LightSource || entity instanceof StaticShadow)) {
      this.updateLighting(entity);
    }

    entity.loaded(this);
}private void unload(final IEntity entity) {
    // 1. remove from physics engine
    if (entity instanceof ICollisionEntity) {
      Game.physics().remove((ICollisionEntity) entity);
    }

    // 2. unregister from update
    if (entity instanceof IUpdateable) {
      Game.loop().detach((IUpdateable) entity);
    }

    if (entity instanceof IMobileEntity) {
      this.removeGravity((IMobileEntity) entity);
    }

    // 3. detach all controllers
    entity.detachControllers();

    if (entity instanceof Emitter) {
      Emitter em = (Emitter) entity;
      em.deactivate();
    }

    if (this.loaded && (entity instanceof LightSource || entity instanceof StaticShadow)) {
      this.updateLighting(entity);
    }

    entity.removed(this);
}public void remove(final IEntity entity) {
    if (entity == null) {
      return;
    }

    this.allEntities.remove(entity.getMapId());
    Iterator<List<IEntity>> iter = this.layerEntities.values().iterator();
    while (iter.hasNext()) {
      List<IEntity> layer = iter.next();
      if (layer.remove(entity) && layer.isEmpty()) {
        iter.remove();
      }
    }
    if (this.miscEntities.get(entity.getRenderType()) != null) {
      this.miscEntities.get(entity.getRenderType()).values().remove(entity);
    }

    for (String tag : entity.getTags()) {
      if (this.getEntitiesByTag().containsKey(tag)) {
        this.getEntitiesByTag().get(tag).remove(entity);

        if (this.getEntitiesByTag().get(tag).isEmpty()) {
          this.getEntitiesByTag().remove(tag);
        }
      }
    }

    if (entity instanceof Emitter) {
      Emitter emitter = (Emitter) entity;
      this.removeEmitter(emitter);
    }

    if (entity instanceof MapArea) {
      this.mapAreas.remove(entity);
    }

    if (entity instanceof Prop) {
      this.props.remove(entity);
    }

    if (entity instanceof Creature) {
      this.creatures.remove(entity);
    }

    if (entity instanceof CollisionBox) {
      this.colliders.remove(entity);
      this.staticShadows.removeIf(x -> x.getOrigin() != null && x.getOrigin().equals(entity));
    }

    if (entity instanceof LightSource) {
      this.lightSources.remove(entity);
      this.updateLighting(entity);
    }

    if (entity instanceof Trigger) {
      this.triggers.remove(entity);
    }

    if (entity instanceof Spawnpoint) {
      this.spawnPoints.remove(entity);
    }
    if (entity instanceof SoundSource) {
      this.soundSources.remove(entity);
    }

    if (entity instanceof StaticShadow) {
      this.staticShadows.remove(entity);
      this.updateLighting(entity);
    }

    if (entity instanceof IMobileEntity) {
      this.mobileEntities.values().remove(entity);
    }

    if (entity instanceof ICombatEntity) {
      this.combatEntities.values().remove(entity);
    }

    this.unload(entity);

    this.fireEntityEvent(l -> l.entityRemoved(entity));
}
}
```
```java
class de.gurkenlabs.litiengine.physics.MovementController {
@Override
  public void update() {
    this.handleForces();
    this.handleMovement();
}
}
```
```java
class de.gurkenlabs.litiengine.Game {
static synchronized void terminate() {
    if (!initialized) {
      return;
    }

    hasStarted = false;
    initialized = false;

    config().save();
    gameLoop.terminate();
    tweenEngine.terminate();
    soundEngine.terminate();

    world().clear();

    for (final GameListener listener : gameListeners) {
      try {
        listener.terminated();
      } catch (Exception e) {
        log().log(Level.WARNING, "game listener threw an exception during shutdown", e);
      }
    }

    gameLoop = null;
    screenManager = null;
    gameWindow = null;
}public static synchronized void start() {
    if (!initialized) {
      throw new IllegalStateException(
          "The game cannot be started without being first initialized. Call Game.init(...) before Game.start().");
    }

    gameLoop.start();
    tweenEngine.start();
    soundEngine.start();

    for (final GameListener listener : gameListeners) {
      listener.started();
    }

    hasStarted = true;
}public static synchronized void init(String... args) {
    if (initialized) {
      log().log(Level.INFO, "The game has already been initialized.");
      return;
    }

    log.init();
    handleCommandLineArguments(args);

    config().load();
    Locale.setDefault(new Locale(config().client().getCountry(), config().client().getLanguage()));

    gameLoop = new GameLoop("Main Update Loop", config().client().getMaxFps());
    loop().attach(physics());
    loop().attach(world());

    // setup default exception handling for render and update loop
    setUncaughtExceptionHandler(
        new DefaultUncaughtExceptionHandler(config().client().exitOnError()));

    screenManager = new ScreenManager();
    gameWindow = new GameWindow();

    // initialize  the game window
    window().init();
    world.setCamera(new Camera());

    for (GameListener listener : gameListeners) {
      listener.initialized(args);
    }

    if (!isInNoGUIMode()) {
      window().getRenderComponent().onRendered(g -> metrics().render(g));

      graphics()
          .addEntityRenderedListener(
              e -> DebugRenderer.renderEntityDebugInfo(e.getGraphics(), e.getEntity()));

      window().getRenderComponent().onFpsChanged(fps -> metrics().setFramesPerSecond(fps));
      window()
          .setIcons(
              Arrays.asList(
                  Resources.images().get("liti-logo-x16.png"),
                  Resources.images().get("liti-logo-x20.png"),
                  Resources.images().get("liti-logo-x32.png"),
                  Resources.images().get("liti-logo-x48.png")));

      Input.keyboard()
          .onKeyTyped(
              KeyEvent.VK_PRINTSCREEN,
              key -> {
                // don't take a screenshot if a modifier is active
                if (key.getModifiers() != 0) {
                  return;
                }

                window().getRenderComponent().takeScreenshot();
              });
    }

    Runtime.getRuntime().addShutdownHook(new Thread(Game::terminate, "Shutdown"));

    initialized = true;
}
}
```


Response Format:
Provide the answer in **XML format** as follows:

#### If the method **cannot** return `null` at the specific call site:
```xml
<response>
  <reason><![CDATA[EXPLAIN WHY THE INVOCATION Game.loop() RESULT CANNOT BE NULL.]]></reason>
  <value>NO</value>
</response>

#### If the method can return null at the specific call site:
<response>
  <reason><![CDATA[EXPLAIN WHY THE INVOCATION Game.loop() RESULT CAN BE NULL.]]></reason>
  <value>YES</value>
</response>

#### If you are unsure or If there are any methods that directly or indirectly affect the return value and are not fully disclosed, request their declarations first, in the following format:
<response>
  <reason><![CDATA[EXPLAIN WHY THIS METHOD DECLARATION IS NECESSARY AND WHY YOU CANNOT MAKE A CONFIDENT DECISION WITHOUT IT]]></reason>
  <success>false</success>
  <methods>
    <method>methodName</method>
  </methods>
</response>

Additional Notes:
Be precise in your reasoning.
If a method’s return value depends on another method not provided, request its declaration before making a conclusion.
If the method can return null in this case but not in others, explain why it happens specifically for this call.

---ChatGPT.sendRequestToOpenAI---
Retrieving response from cache
---Response.<init>---
Creating Response:
```xml
<response>
  <reason><![CDATA[The method `Game.loop()` returns the static field `gameLoop`, which is initialized in the `Game.init(String... args)` method. In this method, a new `GameLoop` object is instantiated and assigned to `gameLoop`. Since `init()` must be called before `start()`, which is implied by the requirement of initializing the game, the `gameLoop` is guaranteed to be non-null during the lifetime of the game execution where `Game.loop()` is called. The absence of any code that could set `gameLoop` to null after its initialization ensures that `Game.loop()` cannot return null.]]></reason>
  <value>NO</value>
</response>
```
---Response.<init>---
Response created:
Disagreement: The method `Game.loop()` returns the static field `gameLoop`, which is initialized in the `Game.init(String... args)` method. In this method, a new `GameLoop` object is instantiated and assigned to `gameLoop`. Since `init()` must be called before `start()`, which is implied by the requirement of initializing the game, the `gameLoop` is guaranteed to be non-null during the lifetime of the game execution where `Game.loop()` is called. The absence of any code that could set `gameLoop` to null after its initialization ensures that `Game.loop()` cannot return null.
---AdvancedNullAwayCodeFix.resolveMethodDereferenceError---
Method is not returning nullable on call site. Injecting suppression annotation.
---AdvancedNullAwayCodeFix.constructCastToNonnullChange---
Constructing cast to nonnull change for reason: The method `Game.loop()` returns the static field `gameLoop`, which is initialized in the `Game.init(String... args)` method. In this method, a new `GameLoop` object is instantiated and assigned to `gameLoop`. Since `init()` must be called before `start()`, which is implied by the requirement of initializing the game, the `gameLoop` is guaranteed to be non-null during the lifetime of the game execution where `Game.loop()` is called. The absence of any code that could set `gameLoop` to null after its initialization ensures that `Game.loop()` cannot return null.
---ChatGPT.ask---
Asking ChatGPT:
For the reason you mentioned earlier:

"The method `Game.loop()` returns the static field `gameLoop`, which is initialized in the `Game.init(String... args)` method. In this method, a new `GameLoop` object is instantiated and assigned to `gameLoop`. Since `init()` must be called before `start()`, which is implied by the requirement of initializing the game, the `gameLoop` is guaranteed to be non-null during the lifetime of the game execution where `Game.loop()` is called. The absence of any code that could set `gameLoop` to null after its initialization ensures that `Game.loop()` cannot return null."

in the method below, the expression Game.loop() is not nullable at the point it is used.

```java
@Override
  public void start() {
    Game.loop().attach(this);
}
```
Please Summarize the reason in max 5 words and rewrite the method so that at the line "    Game.loop().attach(this);", at the occurrence of: "Game.loop()" is replaced with `NullabilityUtil.castToNonnull(Game.loop(), summary of reason)`
Replace "REASON" with the exact reason summary I provide to you (maximum 5 words), not with a generic explanation like "checked to be nonnull".
see the example below, for expression `foo.getBar()`, to wrap it with `NullabilityUtil.castToNonnull(foo.getBar(), "reason")`.

```java
public t(){
    String l = foo.getBar();
}
```

will be:
```java
public t(){
    String l = NullabilityUtil.castToNonnull(foo.getBar(), "checked to be nonnull");
}
```

### Instructions:

Do not import any additional classes.

Do not add Java comments.

Only modify relevant lines as required.

Return only the modified method wrapped in the XML format shown below.

Place the Java code inside the <code> tag using a CDATA block with ```java formatting.

Just give me the fixed code snippet in XML format in <response> tag like the example below. I will apply the fix to my codebase. Do not import any additional libraries or classes or add java comments. If you can provide the fixed code snippet, please provide it in the following format and place the code snippet in the <code> tag within ```java block.
<response>
  <success>true</success>
  <code><![CDATA[
  ```java
  Your fixed code snippet here
  ```
    ]]>
  </code>
</response>

---ChatGPT.sendRequestToOpenAI---
Sending request to OpenAI...
---ChatGPT.sendRequestToOpenAI---
Response received from OpenAI.
---Response.<init>---
Creating Response:
```xml
<response>
  <success>true</success>
  <code><![CDATA[
  ```java
@Override
  public void start() {
    NullabilityUtil.castToNonnull(Game.loop(), "initialized before usage").attach(this);
}
  ```
    ]]>
  </code>
</response>
```
---Response.<init>---
Response created:
@Override
  public void start() {
    NullabilityUtil.castToNonnull(Game.loop(), "initialized before usage").attach(this);
}
---ChatGPT.fixDereferenceByAddingCastToNonnull---
Fixing the error by adding castToNonnull
---AdvancedNullAwayCodeFix.fixTriggeredErrorsForLocation---
Resolving unresolvable error for triggered error: Type='DEREFERENCE_NULLABLE', message='dereferenced expression Game.loop() is @Nullable'
/home/nima/Developer/nullness-benchmarks/litiengine/src/de/gurkenlabs/litiengine/gui/SpeechBubble.java:245
    Game.loop().detach(this);
---AdvancedNullAwayCodeFix.fix---
Fixing error: Type='DEREFERENCE_NULLABLE', message='dereferenced expression Game.loop() is @Nullable'
/home/nima/Developer/nullness-benchmarks/litiengine/src/de/gurkenlabs/litiengine/gui/SpeechBubble.java:245
    Game.loop().detach(this);
---AdvancedNullAwayCodeFix.resolveDereferenceError---
Resolving dereference error: Type='DEREFERENCE_NULLABLE', message='dereferenced expression Game.loop() is @Nullable'
/home/nima/Developer/nullness-benchmarks/litiengine/src/de/gurkenlabs/litiengine/gui/SpeechBubble.java:245
    Game.loop().detach(this);
---AdvancedNullAwayCodeFix.resolveDereferenceError---
Checking nullability possibility at error point
---ChatGPT.checkNullabilityPossibilityAtErrorPoint---
Asking if the expression can be null at error point point
---ChatGPT.ask---
Asking ChatGPT:
In the method below, is there a possibility that the expression "Game.loop()" at line "Game.loop().detach(this);" is null?
public void hide() {
    Game.world().environment().removeRenderable(this);
    Game.loop().detach(this);
    if (activeSpeechBubbles.get(this.getEntity()) != null
        && activeSpeechBubbles.remove(this.getEntity()).equals(this)) {
      activeSpeechBubbles.remove(this.getEntity());
    }

    for (SpeechBubbleListener listener : this.listeners) {
      listener.hidden();
    }
}
Give a single-word answer in XML format. If it is possible for the expression to be null, respond with:
```xml
<response>
    <reason><![CDATA[YOUR REASON]]></reason>
    <value>YES</value>
</response>
```
If it is not possible for the expression to be null, respond with:
```xml
<response>
    <reason><![CDATA[YOUR REASON]]></reason>
    <value>NO</value>
</response>
```
If you are unsure or need more information, respond with where you can ask for more details or what specific information you need.

If additional information is required, list each request inside a `<request>` tag. If no additional information is needed, omit the `<requests>` section.

Respond with:
```xml
<response>
    <reason><![CDATA[YOUR REASON]]></reason>
    <value>UNKNOWN</value>
    <!-- Include <requests> only if additional information is needed -->
    <requests>
        <request><![CDATA[YOUR REQUEST 1]]></request>
        <request><![CDATA[YOUR REQUEST 2]]></request>
    </requests>
</response>
```
---ChatGPT.sendRequestToOpenAI---
Sending request to OpenAI...
---ChatGPT.sendRequestToOpenAI---
Response received from OpenAI.
---Response.<init>---
Creating Response:
```xml
<response>
    <reason><![CDATA[The code snippet does not provide enough context about the implementation of the Game and Game.loop() methods. Without knowing whether Game or its loop() method handles null scenarios or ensures a singleton pattern, it's uncertain if Game.loop() can return null.]]></reason>
    <value>UNKNOWN</value>
    <requests>
        <request><![CDATA[Provide the implementation details or documentation of the Game class, particularly the loop() method.]]></request>
        <request><![CDATA[Clarify the lifecycle management of the Game instance to determine if and when it might return null.]]></request>
    </requests>
</response>
```
---Response.<init>---
Response created:
Unknown: The code snippet does not provide enough context about the implementation of the Game and Game.loop() methods. Without knowing whether Game or its loop() method handles null scenarios or ensures a singleton pattern, it's uncertain if Game.loop() can return null.
---AdvancedNullAwayCodeFix.resolveMethodDereferenceError---
Resolving method dereference error.
---AdvancedNullAwayCodeFix.resolveMethodDereferenceError---
Method is in annotated package. Checking if the method is returning nullable.
---AdvancedNullAwayCodeFix.investigateMethodReturnNullability---
Checking if the method is returning nullable.
---ChatGPT.checkIfMethodIsReturningNullable---
Asking if the method is returning nullable: loop()
---ChatGPT.ask---
Asking ChatGPT:
In the method below, is there a possibility that the method returns null based only on its body? Consider the following points:

- The method may have multiple return paths; consider all return statements.
- If the method calls another method, do not assume its return value unless its full declaration is provided. Request its declaration if needed.
- The method may throw an exception instead of returning null. An exception path should not be considered a null return.
- Ensure you request the declarations of any methods whose return values directly or indirectly impact this method’s return value before making a conclusion.
- Carefully analyze all conditions and prior operations that may guarantee a non-null return value.

@Nullable public static IGameLoop loop() {
    return gameLoop;
}

Here are the method definitions in addition to the method inquired:

Depth: 0
```java
class de.gurkenlabs.litiengine.Game {
@Nullable public static IGameLoop loop() {
    return gameLoop;
}
}
```


Response Format:
Provide the answer in **XML format** as follows:

#### If the method **cannot** return `null`:
```xml
<response>
  <reason><![CDATA[EXPLAIN WHY THE METHOD CANNOT RETURN NULL]]></reason>
  <value>NO</value>
</response>
```

#### If the method can return null:
```xml
<response>
  <reason><![CDATA[EXPLAIN WHY THE METHOD CAN RETURN NULL]]></reason>
  <value>YES</value>
</response>
```

#### If you are unsure or need more information, respond with where you can ask for more details or what specific information you need.

#### If you are unsure or If there are any methods that directly or indirectly affect the return value and are not fully disclosed, request their declarations first, in the following format:
<response>
  <reason><![CDATA[YOUR REASON]]></reason>
  <value>UNKNOWN</value>
  <methods>
    <method>methodName</method>
  </methods>
</response>

If additional information is required other than method declaration, list each request inside a `<request>` tag. If no additional information is needed, omit the `<requests>` section.

Respond with:
```xml
<response>
    <reason><![CDATA[YOUR REASON]]></reason>
    <value>UNKNOWN</value>
    <!-- Include <requests> only if additional information is needed -->
    <requests>
        <request><![CDATA[YOUR REQUEST 1]]></request>
        <request><![CDATA[YOUR REQUEST 2]]></request>
    </requests>
</response>
```

Additional Notes:
Be precise in your reasoning.
If a method’s return value depends on another method not provided, request its declaration before making a conclusion.
If the method can return null in some cases but not others, explain under what conditions it can happen.

---ChatGPT.sendRequestToOpenAI---
Retrieving response from cache
---Response.<init>---
Creating Response:
```xml
<response>
  <reason><![CDATA[The method `loop` returns the variable `gameLoop`. Without the initialization or assignment details of `gameLoop`, it's unclear whether it can be null. The possibility of `gameLoop` being uninitialized or set to null elsewhere in the program means `loop` could potentially return null. Further information on `gameLoop` is required.]]></reason>
  <value>UNKNOWN</value>
  <requests>
    <request><![CDATA[Please provide the declaration and initialization of the variable `gameLoop` in the class `de.gurkenlabs.litiengine.Game`.]]></request>
  </requests>
</response>
```
---Response.<init>---
Response created:
Unknown: The method `loop` returns the variable `gameLoop`. Without the initialization or assignment details of `gameLoop`, it's unclear whether it can be null. The possibility of `gameLoop` being uninitialized or set to null elsewhere in the program means `loop` could potentially return null. Further information on `gameLoop` is required.
---AdvancedNullAwayCodeFix.investigateMethodReturnNullability---
Could not determine the nullability and model did not ask for any method.
---ChatGPT.checkIfMethodIsReturningNullableOnCallSite---
Asking if the method is returning nullable on the call site: Game.loop()
---ChatGPT.ask---
Asking ChatGPT:
In the method below, is there a possibility that the method returns null at the given call site?

```java
@Nullable public static IGameLoop loop() {
    return gameLoop;
}
```

## Guidelines:
- The method may have multiple return paths; consider all return statements.
- If the method calls another method, do not assume its return value unless its full declaration is provided. Request its declaration if needed.
- The method may throw an exception instead of returning null. An exception path should not be considered a null return.
- Ensure you request the declarations of any methods whose return values directly or indirectly impact this method’s return value before making a conclusion.
- If the method returns a value that is determined by a parameter, evaluate based on the actual argument at the given call site.
- Analyze based only on the specific invocation provided. Do not generalize to all possible inputs.- If the return value is guaranteed to be non-null at the call site, the answer should be a definitive NO.
- Do not generalize based on all possible inputs—your answer must be based only on the given invocation.
- Focus only on the given call site, not all possible invocations.

### call site:
Game.loop()

Here are the method definitions and the call chain for this method, showing the sequence of calls from the method to its callers at each depth level:

Depth: 0
```java
class de.gurkenlabs.litiengine.Game {
@Nullable public static IGameLoop loop() {
    return gameLoop;
}
}
```
Depth: 1
```java
class de.gurkenlabs.litiengine.environment.GameWorld {
public void loadEnvironment(@Nullable final Environment env) {
    Lock lock = Game.loop().getLock();
    lock.lock();
    try {
      unloadEnvironment();
      this.environment = env;
      if (env != null) {
        this.addEnvironment(env);

        if (env.getGravity() == 0 && this.gravity() != 0) {
          env.setGravity(this.gravity());
        }

        env.load();
        for (final EnvironmentLoadedListener listener : this.loadedListeners) {
          listener.loaded(env);
        }

        // call map specific listeners
        String mapName = getMapName(env);
        if (mapName != null && this.environmentLoadedListeners.containsKey(mapName)) {

          // for the default camera we center the camera on the environment
          if (this.camera().getClass().equals(Camera.class)) {
            camera().setFocus(env.getCenter());
          }

          for (EnvironmentLoadedListener listener : this.environmentLoadedListeners.get(mapName)) {
            listener.loaded(env);
          }
        }
      }
    } finally {
      lock.unlock();
    }
}public void setCamera(@Nullable final ICamera cam) {
    if (this.camera() != null) {
      Game.loop().detach(camera);
    }

    camera = cam;

    if (cam != null && !Game.isInNoGUIMode()) {
      Game.loop().attach(cam);
      cam.updateFocus();
    }
}
}
```
```java
class de.gurkenlabs.litiengine.entities.behavior.EntityNavigator {
public EntityNavigator(final IMobileEntity entity, final PathFinder pathFinder) {
    this.cancelNavigationConditions = new CopyOnWriteArrayList<>();
    this.listeners = new CopyOnWriteArrayList<>();
    this.entity = entity;
    this.pathFinder = pathFinder;
    this.setAcceptableError(DEFAULT_ACCEPTABLE_ERROR);
    Game.loop().attach(this);
}
}
```
```java
class de.gurkenlabs.litiengine.GameWindow {
private static void initializeWindowEventListeners(Window window) {

    window.addWindowStateListener(
        e -> {
          if (e.getNewState() == Frame.ICONIFIED) {
            Game.loop().setTickRate(ICONIFIED_MAX_FPS);
          } else {
            Game.loop().setTickRate(Game.config().client().getMaxFps());
          }
        });

    window.addWindowFocusListener(
        new WindowFocusListener() {
          @Override
          public void windowLostFocus(WindowEvent e) {
            if (Game.config().graphics().reduceFramesWhenNotFocused()) {
              Game.loop().setTickRate(NONE_FOCUS_MAX_FPS);
            }
          }

          @Override
          public void windowGainedFocus(WindowEvent e) {
            Game.loop().setTickRate(Game.config().client().getMaxFps());
          }
        });

    window.addWindowListener(
        new WindowAdapter() {
          @Override
          public void windowClosing(final WindowEvent event) {
            Game.exit();
          }
        });
}
}
```
```java
class de.gurkenlabs.litiengine.gui.screens.ScreenManager {
public void display(@Nullable final Screen screen) {
    if (Game.hasStarted() && Game.time().since(this.lastScreenChange) < this.getChangeCooldown()) {
      log.log(
          Level.INFO,
          "Skipping displaying of screen {0} because screen changing is currently on cooldown.",
          screen != null ? screen.getName() : "");
      return;
    }

    final Screen previous = this.current();
    if (previous != null) {
      previous.suspend();
    }

    if (screen != null && !this.screens.contains(screen)) {
      this.screens.add(screen);
    }

    this.currentScreen = screen;
    if (!Game.isInNoGUIMode() && this.current() != null) {
      this.current().prepare();
    }

    this.lastScreenChange = Game.loop().getTicks();

    final ScreenChangedEvent event = new ScreenChangedEvent(this.current(), previous);
    for (final ScreenChangedListener listener : this.screenChangedListeners) {
      listener.changed(event);
    }
}
}
```
```java
class de.gurkenlabs.litiengine.abilities.effects.Effect {
@Override
  public void update() {

    for (final Iterator<EffectApplication> iterator = this.getActiveAppliances().iterator();
        iterator.hasNext(); ) {
      final EffectApplication appliance = iterator.next();
      // if the effect duration is reached
      if (this.hasEnded(appliance)) {

        iterator.remove();
        this.cease(appliance);
      }
    }

    // 4. unregister if all appliances are finished
    if (this.getActiveAppliances().isEmpty()) {
      Game.loop().detach(this);
    }
}public void apply(final Shape impactArea) {
    final List<ICombatEntity> affected = this.lookForAffectedEntities(impactArea);
    for (final ICombatEntity affectedEntity : affected) {
      this.apply(affectedEntity);
    }

    this.appliances.add(new EffectApplication(affected, impactArea));

    // if it is the first appliance -> register for update
    if (this.appliances.size() == 1) {
      Game.loop().attach(this);
    }
}
}
```
```java
class de.gurkenlabs.litiengine.GameTime {
public long toTicks(final int milliseconds) {
    return this.toTicks(milliseconds, Game.loop().getTickRate());
}public long since(final long tick) {
    return toMilliseconds(Game.loop().getTicks() - tick);
}public long now() {
    return Game.loop().getTicks();
}public long sinceGameStart() {
    return this.toMilliseconds(Game.loop().getTicks());
}@Override
  public void loaded(Environment environment) {
    environmentLoaded = Game.loop().getTicks();
}public long toMilliseconds(final long ticks) {
    return this.toMilliseconds(ticks, Game.loop().getTickRate());
}
}
```
```java
class de.gurkenlabs.litiengine.GameMetrics {
@Override
  public void render(final Graphics2D g) {
    this.updateMetrics();

    if (!Game.config().client().showGameMetrics()) {
      return;
    }

    this.currentOffsetY = 0;

    g.setColor(this.renderColor);

    // render client metrics
    this.drawTitle(g, "[client]");
    this.drawMetric(g, "fps       : " + this.getFramesPerSecond());
    this.drawMetric(g, "max fps   : " + this.maxFramesPerSecond);
    this.drawMetric(g, "updatables: " + Game.loop().getUpdatableCount());

    // render jvm metrics if debug is enabled
    if (Game.config().debug().isDebugEnabled()) {
      this.drawTitle(g, "[jvm]");
      this.drawMetric(g, "java      : " + this.javaVersion);
      this.drawMetric(g, "memory    : " + String.format("%-5.5s", this.usedMemory) + " MB");
      this.drawMetric(g, "threads   : " + Thread.activeCount());
    }

    // render rendering metrics
    if (!this.renderMetrics.isEmpty()) {
      this.drawTitle(g, "[update]");

      for (RenderMetrics metric : this.renderMetrics) {
        this.drawMetric(g, metric.toString());
      }

      this.renderMetrics.clear();
    }
}
}
```
```java
class de.gurkenlabs.litiengine.graphics.emitters.Emitter {
public void deactivate() {
    if (!this.activated) {
      return;
    }

    this.activated = false;
    this.getParticles().clear();
    this.aliveTime = 0;
    this.activationTick = 0;
    this.lastSpawn = 0;
    Game.loop().detach(this);
}public void activate() {
    if (this.activated) {
      return;
    }

    this.activated = true;
    this.activationTick = Game.time().now();
    Game.loop().attach(this);
}@Override
  public void update() {
    if (this.isPaused()) {
      return;
    }

    // clear particles if the effect time to life is reached
    if (this.isFinished()) {
      for (EmitterFinishedListener listener : this.finishedListeners) {
        listener.finished(this);
      }

      this.delete();
      return;
    }

    final float updateRatio = (float) this.data().getUpdateRate() / Game.loop().getTickRate();
    for (final Particle p : this.getParticles().stream().collect(Collectors.toList())) {
      if (this.particleCanBeRemoved(p)) {
        // remove dead particles
        this.particles.remove(p);
        continue;
      }

      p.update(this.getOrigin(), updateRatio);
    }

    this.aliveTime = Game.time().since(this.activationTick);
    if ((this.data().getSpawnRate() == 0
        || Game.time().since(this.lastSpawn) >= this.data().getSpawnRate())) {
      this.lastSpawn = Game.time().now();
      this.spawnParticle();
    }
}
}
```
```java
class de.gurkenlabs.litiengine.entities.behavior.IBehaviorController {
public default void attach() {
    Game.loop().attach(this);
}public default void detach() {
    Game.loop().detach(this);
}
}
```
```java
class de.gurkenlabs.litiengine.abilities.AbilityExecution {
AbilityExecution(final Ability ability) {
    this.appliedEffects = new CopyOnWriteArrayList<>();
    this.ability = ability;
    this.executionTicks = Game.time().now();
    this.impactArea = ability.calculateImpactArea();
    this.castLocation = ability.getExecutor().getCenter();
    Game.loop().attach(this);
}@Override
  public void update() {
    // if there a no effects to apply -> unregister this instance and we're done
    if (this.getAbility().getEffects().isEmpty()
        || this.getAbility().getEffects().size() == this.getAppliedEffects().size()) {
      Game.loop().detach(this);
      return;
    }

    // handle all effects from the ability that were not applied yet
    for (final Effect effect : this.getAbility().getEffects()) {
      // if the ability was not executed yet or the delay of the effect is not
      // yet reached
      if (this.getAppliedEffects().contains(effect)
          || Game.time().since(this.getExecutionTicks()) < effect.getDelay()) {
        continue;
      }

      effect.apply(this.getExecutionImpactArea());
      this.getAppliedEffects().add(effect);
    }
}
}
```
```java
class de.gurkenlabs.litiengine.GameWindow$3 {
@Override
          public void windowGainedFocus(WindowEvent e) {
            Game.loop().setTickRate(Game.config().client().getMaxFps());
}@Override
          public void windowLostFocus(WindowEvent e) {
            if (Game.config().graphics().reduceFramesWhenNotFocused()) {
              Game.loop().setTickRate(NONE_FOCUS_MAX_FPS);
            }
}
}
```
```java
class de.gurkenlabs.litiengine.environment.EntitySpawner {
protected void spawnNewEntities() {
    if (this.getSpawnMode() != SpawnMode.CUSTOMSPAWNPOINTS && this.getSpawnPoints().isEmpty()) {
      return;
    }

    switch (this.getSpawnMode()) {
      case ALLSPAWNPOINTS:
        for (int i = 0; i < this.getSpawnPoints().size(); i++) {
          final int index = i;
          Game.loop()
              .perform(
                  this.getSpawnDelay() + this.getSpawnDelay() * i,
                  () -> this.spawn(this.getSpawnPoints().get(index), this.getSpawnAmount()));
        }
        break;
      case ONERANDOMSPAWNPOINT:
        this.spawn(Game.random().choose(this.getSpawnPoints()), this.getSpawnAmount());
        break;
      case RANDOMSPAWNPOINTS:
        for (int i = 0; i < this.getSpawnAmount(); i++) {
          Game.loop()
              .perform(
                  this.getSpawnDelay() + this.getSpawnDelay() * i,
                  () -> this.spawn(Game.random().choose(this.getSpawnPoints()), 1));
        }
        break;
      case CUSTOMSPAWNPOINTS:
        List<Spawnpoint> spawnPoints =
            this.customSpawnpoints != null
                ? this.customSpawnpoints.apply(this)
                : this.getCustomSpawnpoints();

        int index = 0;
        for (Spawnpoint spawn : spawnPoints) {
          Game.loop()
              .perform(
                  this.getSpawnDelay() + this.getSpawnDelay() * index, () -> this.spawn(spawn, 1));
          index++;
        }
        break;
      default:
        break;
    }
}
}
```
```java
class de.gurkenlabs.litiengine.tweening.TweenEngine {
@Override
  public void start() {
    Game.loop().attach(this);
}@Override
  public void terminate() {
    Game.loop().detach(this);
}
}
```
```java
class de.gurkenlabs.litiengine.gui.SpeechBubble {
public void hide() {
    Game.world().environment().removeRenderable(this);
    Game.loop().detach(this);
    if (activeSpeechBubbles.get(this.getEntity()) != null
        && activeSpeechBubbles.remove(this.getEntity()).equals(this)) {
      activeSpeechBubbles.remove(this.getEntity());
    }

    for (SpeechBubbleListener listener : this.listeners) {
      listener.hidden();
    }
}private SpeechBubble(
      final IEntity entity,
      final String text,
      @Nullable SpeechBubbleAppearance appearance,
      @Nullable Font font) {
    if (appearance == null) {
      this.appearance = DEFAULT_APPEARANCE;
    } else {
      this.appearance = appearance;
    }

    final SpeechBubble active = activeSpeechBubbles.get(entity);
    if (active != null) {
      active.hide();
    }
    this.setFont(font);

    this.textBoxWidth = (float) (entity.getWidth() * 4);
    this.entity = entity;

    this.currentText = text;
    this.currentTextDisplayTime = DISPLAYTIME_MIN + text.length() * DISPLAYTIME_PER_LETTER;

    this.lastTextDisplay = Game.time().now();
    this.createBubbleImage();
    entity.getEnvironment().add(this, RenderType.UI);
    Game.loop().attach(this);
    activeSpeechBubbles.put(entity, this);
}
}
```
```java
class de.gurkenlabs.litiengine.entities.Prop {
private void updateAnimationController() {
    IEntityAnimationController<?> controller = this.createAnimationController();
    this.getControllers().addController(controller);
    if (Game.world().environment() != null && Game.world().environment().isLoaded()) {
      Game.loop().attach(controller);
    }
}
}
```
```java
class de.gurkenlabs.litiengine.graphics.FreeFlightCamera {
public FreeFlightCamera(final Point2D focus) {
    this.setFocus(focus);
    this.velocity = DEFAULT_SCROLL_PIXELS_PER_SECOND;
    this.scrollPadding = DEFAULT_SCROLL_PADDING;
    this.setClampToMap(true);

    Game.loop().attach(this);
}private void handleFreeFlightCamera() {
    if (Game.world().environment() == null || Game.world().environment().getMap() == null) {
      return;
    }

    final Point2D mouseLocation = Input.mouse().getLocation();

    final double scrollSpeed =
        this.getVelocity()
            / (double) Game.loop().getTickRate()
            * Game.config().input().getMouseSensitivity();

    double x = this.getFocus().getX();
    double y = this.getFocus().getY();

    double deltaX = 0;
    if (mouseLocation.getX() < this.getScrollPadding()) {
      deltaX -= scrollSpeed;
    } else if (Game.window().getResolution().getWidth() - mouseLocation.getX()
        < this.getScrollPadding()) {
      deltaX += scrollSpeed;
    }

    double deltaY = 0;
    if (mouseLocation.getY() < this.getScrollPadding()) {
      deltaY -= scrollSpeed;
    } else if (Game.window().getResolution().getHeight() - mouseLocation.getY()
        < this.getScrollPadding()) {
      deltaY += scrollSpeed;
    }

    x += deltaX;
    y += deltaY;

    this.setFocus(new Point2D.Double(x, y));
}
}
```
```java
class de.gurkenlabs.litiengine.environment.Environment {
private static void dispose(final Collection<? extends IEntity> entities) {
    for (final IEntity entity : entities) {
      if (entity instanceof IUpdateable) {
        Game.loop().detach((IUpdateable) entity);
      }

      entity.detachControllers();
    }
}private static void loadUpdatableOrEmitterEntity(IEntity entity) {
    if (entity instanceof Emitter) {
      final Emitter emitter = (Emitter) entity;
      if (emitter.isActivateOnInit()) {
        emitter.activate();
      }
    } else if (entity instanceof IUpdateable) {
      Game.loop().attach((IUpdateable) entity);
    }
}private void unload(final IEntity entity) {
    // 1. remove from physics engine
    if (entity instanceof ICollisionEntity) {
      Game.physics().remove((ICollisionEntity) entity);
    }

    // 2. unregister from update
    if (entity instanceof IUpdateable) {
      Game.loop().detach((IUpdateable) entity);
    }

    if (entity instanceof IMobileEntity) {
      this.removeGravity((IMobileEntity) entity);
    }

    // 3. detach all controllers
    entity.detachControllers();

    if (entity instanceof Emitter) {
      Emitter em = (Emitter) entity;
      em.deactivate();
    }

    if (this.loaded && (entity instanceof LightSource || entity instanceof StaticShadow)) {
      this.updateLighting(entity);
    }

    entity.removed(this);
}
}
```
```java
class de.gurkenlabs.litiengine.graphics.animation.Animation {
@Override
  public void update() {
    // do nothing if the animation is not playing or the current keyframe is not finished
    if (!this.isPlaying()
        || Game.time().since(this.lastFrameUpdate) < this.getCurrentKeyFrame().getDuration()) {
      return;
    }

    // if we are not looping and the last keyframe is finished, we terminate the animation
    if (!this.isLooping() && this.isLastKeyFrame()) {
      this.terminate();
      return;
    }

    // make sure, we stay inside the keyframe list
    final int newFrameIndex =
        (this.getKeyframes().indexOf(this.currentFrame) + 1) % this.getKeyframes().size();
    final KeyFrame previousFrame = this.currentFrame;
    this.currentFrame = this.getKeyframes().get(newFrameIndex);

    for (KeyFrameListener listener : this.listeners) {
      listener.currentFrameChanged(previousFrame, this.currentFrame);
    }

    this.lastFrameUpdate = Game.loop().getTicks();
}public void restart() {
    this.currentFrame = this.firstFrame;
    this.lastFrameUpdate = Game.loop().getTicks();
}
}
```
```java
class de.gurkenlabs.litiengine.physics.MovementController {
@Override
  public void attach() {
    Game.loop().attach(this);
}private void handleForces() {
    // clean up forces
    this.activeForces.forEach(
        x -> {
          if (x.hasEnded()) {
            this.activeForces.remove(x);
          }
        });

    if (this.activeForces.isEmpty()) {
      return;
    }

    // disable turn-on-move for force handling
    boolean turn = this.getEntity().turnOnMove();
    this.getEntity().setTurnOnMove(false);
    try {
      double deltaX = 0;
      double deltaY = 0;
      for (final Force force : this.activeForces) {
        if (force.cancelOnReached() && force.hasReached(this.getEntity())) {
          force.end();
          continue;
        }

        final Point2D collisionBoxCenter = this.getEntity().getCollisionBoxCenter();
        final double angle =
            GeometricUtilities.calcRotationAngleInDegrees(collisionBoxCenter, force.getLocation());
        final double strength =
            Game.loop().getDeltaTime() * 0.001f * force.getStrength() * Game.loop().getTimeScale();
        deltaX += GeometricUtilities.getDeltaX(angle, strength);
        deltaY += GeometricUtilities.getDeltaY(angle, strength);
      }

      final Point2D target =
          new Point2D.Double(this.getEntity().getX() + deltaX, this.getEntity().getY() + deltaY);
      final boolean success = Game.physics().move(this.getEntity(), target);
      if (!success) {
        for (final Force force : this.activeForces) {
          if (force.cancelOnCollision()) {
            force.end();
          }
        }
      }
    } finally {
      this.getEntity().setTurnOnMove(turn);
    }
}@Override
  public void detach() {
    Game.loop().detach(this);
}public void handleMovement() {
    if (!this.isMovementAllowed()) {
      this.velocity = 0;
      return;
    }

    // max distance an entity can travel within one tick
    final double maxPixelsPerTick = this.getEntity().getTickVelocity();
    final double deltaTime = Game.loop().getDeltaTime() * Game.loop().getTimeScale();

    final double acceleration =
        this.getEntity().getAcceleration() == 0
            ? maxPixelsPerTick
            : deltaTime / this.getEntity().getAcceleration() * maxPixelsPerTick;
    final double deceleration =
        this.getEntity().getDeceleration() == 0
            ? this.getVelocity()
            : deltaTime / this.getEntity().getDeceleration() * maxPixelsPerTick;

    double dx = this.getDx();
    double dy = this.getDy();
    this.setDx(0);
    this.setDy(0);

    final double deltaVelocity =
        Math.min(Math.sqrt(Math.pow(dx, 2) + Math.pow(dy, 2)), acceleration);
    if (deltaVelocity != 0) {
      double newVelocity = this.getVelocity() + deltaVelocity;
      this.setVelocity(newVelocity);
    } else {
      final double newVelocity = Math.max(0, this.getVelocity() - deceleration);
      this.setVelocity(newVelocity);
      dx = GeometricUtilities.getDeltaX(this.moveAngle);
      dy = GeometricUtilities.getDeltaY(this.moveAngle);
    }

    if (this.getVelocity() == 0) {
      this.moveAngle = 0;
      return;
    }

    // actually move entity
    this.moveEntity(dx, dy);
}
}
```
```java
class de.gurkenlabs.litiengine.graphics.animation.AnimationController {
public void detach() {
    Game.loop().detach(this);
}public void attach() {
    Game.loop().attach(this);
}
}
```
```java
class de.gurkenlabs.litiengine.graphics.Camera {
@Override
  public void setZoom(final float targetZoom, final int delay) {
    if (delay == 0) {

      this.zoom = targetZoom;
      this.targetZoom = 0;
      this.zoomDelay = 0;
      this.zoomTick = 0;
      this.zoomStep = 0;

      final ZoomChangedEvent event = new ZoomChangedEvent(this, targetZoom);
      for (final ZoomChangedListener listener : this.zoomListeners) {
        listener.zoomChanged(event);
      }
    } else {
      this.zoomTick = Game.time().now();
      this.targetZoom = targetZoom;
      this.zoomDelay = delay;

      final double tickduration = 1000 / (double) Game.loop().getTickRate();
      final double tickAmount = delay / tickduration;
      final float totalDelta = this.targetZoom - this.zoom;
      this.zoomStep = tickAmount > 0 ? (float) (totalDelta / tickAmount) : totalDelta;
    }
}
}
```
```java
class de.gurkenlabs.litiengine.Game {
public static synchronized void init(String... args) {
    if (initialized) {
      log().log(Level.INFO, "The game has already been initialized.");
      return;
    }

    log.init();
    handleCommandLineArguments(args);

    config().load();
    Locale.setDefault(new Locale(config().client().getCountry(), config().client().getLanguage()));

    gameLoop = new GameLoop("Main Update Loop", config().client().getMaxFps());
    loop().attach(physics());
    loop().attach(world());

    // setup default exception handling for render and update loop
    setUncaughtExceptionHandler(
        new DefaultUncaughtExceptionHandler(config().client().exitOnError()));

    screenManager = new ScreenManager();
    gameWindow = new GameWindow();

    // initialize  the game window
    window().init();
    world.setCamera(new Camera());

    for (GameListener listener : gameListeners) {
      listener.initialized(args);
    }

    if (!isInNoGUIMode()) {
      window().getRenderComponent().onRendered(g -> metrics().render(g));

      graphics()
          .addEntityRenderedListener(
              e -> DebugRenderer.renderEntityDebugInfo(e.getGraphics(), e.getEntity()));

      window().getRenderComponent().onFpsChanged(fps -> metrics().setFramesPerSecond(fps));
      window()
          .setIcons(
              Arrays.asList(
                  Resources.images().get("liti-logo-x16.png"),
                  Resources.images().get("liti-logo-x20.png"),
                  Resources.images().get("liti-logo-x32.png"),
                  Resources.images().get("liti-logo-x48.png")));

      Input.keyboard()
          .onKeyTyped(
              KeyEvent.VK_PRINTSCREEN,
              key -> {
                // don't take a screenshot if a modifier is active
                if (key.getModifiers() != 0) {
                  return;
                }

                window().getRenderComponent().takeScreenshot();
              });
    }

    Runtime.getRuntime().addShutdownHook(new Thread(Game::terminate, "Shutdown"));

    initialized = true;
}
}
```
```java
class de.gurkenlabs.litiengine.entities.Creature {
protected void updateAnimationController() {
    IEntityAnimationController<?> controller = this.createAnimationController();
    this.getControllers().addController(controller);
    if (Game.world().environment() != null && Game.world().environment().isLoaded()) {
      Game.loop().attach(controller);
    }
}@Override
  public float getTickVelocity() {
    // pixels per ms multiplied by the passed ms
    // ensure that entities don't travel too far in case of lag
    return Math.min(Game.loop().getDeltaTime(), GameLoop.TICK_DELTATIME_LAG)
        * 0.001F
        * this.getVelocity().get()
        * Game.loop().getTimeScale();
}
}
```
Depth: 2
```java
class de.gurkenlabs.litiengine.environment.GameWorld {
public void clear() {
    this.unloadEnvironment();
    this.environments.clear();
    this.setCamera(null);
    Game.physics().clear();

    this.environmentListeners.clear();
    this.environmentLoadedListeners.clear();
    this.environmentUnloadedListeners.clear();

    this.listeners.clear();
    this.loadedListeners.clear();
    this.unloadedListeners.clear();
}@Nullable
  public Environment loadEnvironment(IMap map) {
    Environment env = this.getEnvironment(map);
    this.loadEnvironment(env);
    return env;
}@Nullable
  public Environment loadEnvironment(String mapName) {
    Environment env = this.getEnvironment(mapName);
    this.loadEnvironment(env);
    return env;
}
}
```
```java
class de.gurkenlabs.litiengine.GameWindow {
GameWindow() {
    this.hostControl = new JFrame();

    this.resolutionChangedListeners = new CopyOnWriteArrayList<>();

    this.renderCanvas = new RenderComponent(Game.config().graphics().getResolution());
    this.cursor = new MouseCursor();
    if (!Game.isInNoGUIMode()) {
      this.hostControl.setBackground(Color.BLACK);
      this.hostControl.add(this.renderCanvas);

      this.initializeEventListeners();

      this.hostControl.setTitle(Game.info().getTitle());
      this.hostControl.setDefaultCloseOperation(WindowConstants.DO_NOTHING_ON_CLOSE);
      initializeWindowEventListeners(this.hostControl);
    }
}
}
```
```java
class de.gurkenlabs.litiengine.GameTime {
public long sinceEnvironmentLoad() {
    return this.since(this.environmentLoaded);
}public long since(final long tick) {
    return toMilliseconds(Game.loop().getTicks() - tick);
}public long sinceGameStart() {
    return this.toMilliseconds(Game.loop().getTicks());
}
}
```
```java
class de.gurkenlabs.litiengine.abilities.effects.Effect {
protected void cease(final EffectApplication appliance) {
    // 1. cease the effect for all affected entities
    for (final ICombatEntity entity : appliance.getAffectedEntities()) {
      this.cease(entity);
    }

    // 2. apply follow up effects
    this.getFollowUpEffects().forEach(followUp -> followUp.apply(appliance.getImpactArea()));
}protected boolean hasEnded(final EffectApplication appliance) {
    final long effectDuration = Game.time().since(appliance.getAppliedTicks());
    return effectDuration > this.getDuration();
}
}
```
```java
class de.gurkenlabs.litiengine.abilities.effects.EffectApplication {
protected EffectApplication(final List<ICombatEntity> affectedEntities, final Shape impactArea) {
    this.applied = Game.time().now();
    this.affectedEntities = affectedEntities;
    this.impactArea = impactArea;
}
}
```
```java
class de.gurkenlabs.litiengine.entities.CombatEntity {
@Override
  public boolean wasHit(int timeSpan) {
    return Game.time().since(this.lastHit) < timeSpan;
}@Override
  public void hit(final int damage, @Nullable final Ability ability) {
    if (this.isDead()) {
      return;
    }

    if (!this.isIndestructible()) {
      this.getHitPoints().modifyBaseValue(new AttributeModifier<>(Modification.SUBTRACT, damage));
    }

    final EntityHitEvent event = new EntityHitEvent(this, ability, damage, this.isDead());

    for (final CombatEntityListener listener : this.listeners) {
      listener.hit(event);
    }

    for (final CombatEntityHitListener listener : this.hitListeners) {
      listener.hit(event);
    }

    if (this.isDead()) {
      this.fireDeathEvent();
      this.setCollision(false);
    }

    this.lastHit = Game.time().now();
}
}
```
```java
class de.gurkenlabs.litiengine.graphics.ImageEffect {
protected ImageEffect(final int ttl, final String name) {
    this.ttl = ttl;
    this.name = name;
    this.aliveTick = Game.time().now();
}@Override
  public long getAliveTime() {
    return Game.time().since(this.aliveTick);
}
}
```
```java
class de.gurkenlabs.litiengine.abilities.AbilityExecution {
AbilityExecution(final Ability ability) {
    this.appliedEffects = new CopyOnWriteArrayList<>();
    this.ability = ability;
    this.executionTicks = Game.time().now();
    this.impactArea = ability.calculateImpactArea();
    this.castLocation = ability.getExecutor().getCenter();
    Game.loop().attach(this);
}@Override
  public void update() {
    // if there a no effects to apply -> unregister this instance and we're done
    if (this.getAbility().getEffects().isEmpty()
        || this.getAbility().getEffects().size() == this.getAppliedEffects().size()) {
      Game.loop().detach(this);
      return;
    }

    // handle all effects from the ability that were not applied yet
    for (final Effect effect : this.getAbility().getEffects()) {
      // if the ability was not executed yet or the delay of the effect is not
      // yet reached
      if (this.getAppliedEffects().contains(effect)
          || Game.time().since(this.getExecutionTicks()) < effect.getDelay()) {
        continue;
      }

      effect.apply(this.getExecutionImpactArea());
      this.getAppliedEffects().add(effect);
    }
}
}
```
```java
class de.gurkenlabs.litiengine.tweening.TweenEngine {
@Override
  public void update() {
    for (final Tweenable target : this.getTweens().keySet()) {
      for (final Tween tween : this.getTweens().get(target).values()) {
        if (tween.hasStopped()) {
          continue;
        }
        final long elapsed = Game.time().since(tween.getStartTime());
        if (elapsed >= tween.getDuration()) {
          tween.stop();
          continue;
        }
        final float[] currentValues = new float[tween.getTargetValues().length];
        for (int i = 0; i < tween.getTargetValues().length; i++) {
          currentValues[i] =
              tween.getStartValues()[i]
                  + tween.getEquation().compute(elapsed / (float) tween.getDuration())
                      * (tween.getTargetValues()[i] - tween.getStartValues()[i]);
        }
        tween.getTarget().setTweenValues(tween.getType(), currentValues);
      }
    }
}
}
```
```java
class de.gurkenlabs.litiengine.gui.SpeechBubble {
public static SpeechBubble create(
      final IEntity entity, final String text, SpeechBubbleAppearance appearance, Font font) {
    return new SpeechBubble(entity, text, appearance, font);
}public static SpeechBubble create(final IEntity entity, final Font font, final String text) {
    SpeechBubbleAppearance app =
        new SpeechBubbleAppearance(
            DEFAULT_APPEARANCE.getForeColor(),
            DEFAULT_APPEARANCE.getBackgroundColor1(),
            DEFAULT_APPEARANCE.getBorderColor(),
            DEFAULT_APPEARANCE.getPadding());
    return new SpeechBubble(entity, text, app, font);
}public static SpeechBubble create(final IEntity entity, final String text) {
    return new SpeechBubble(entity, text, null, GuiProperties.getDefaultFont());
}@Override
  public void update() {
    if (this.currentText == null) {
      this.hide();
      return;
    }

    this.entityCenter = Game.world().camera().getViewportLocation(this.getEntity().getCenter());

    // old text was displayed long enough
    if (this.lastTextDisplay != 0
        && Game.time().since(this.lastTextDisplay) > this.currentTextDisplayTime) {
      this.currentText = null;
      this.lastTextDisplay = 0;
      return;
    }

    // display new text
    if (this.textIndex < this.currentText.length()
        && Game.time().since(this.lastCharPoll) > LETTER_WRITE_DELAY) {
      this.textIndex++;
      this.lastCharPoll = Game.time().now();
      if (this.typeSound != null) {
        Game.audio().playSound(this.typeSound, this.getEntity());
      }
    }

    // continue displaying currently displayed text
}private SpeechBubble(
      final IEntity entity,
      final String text,
      final Sound typeSound,
      SpeechBubbleAppearance appearance,
      Font font) {
    this(entity, text, appearance, font);
    this.typeSound = typeSound;
}private SpeechBubble(
      final IEntity entity,
      final String text,
      @Nullable SpeechBubbleAppearance appearance,
      @Nullable Font font) {
    if (appearance == null) {
      this.appearance = DEFAULT_APPEARANCE;
    } else {
      this.appearance = appearance;
    }

    final SpeechBubble active = activeSpeechBubbles.get(entity);
    if (active != null) {
      active.hide();
    }
    this.setFont(font);

    this.textBoxWidth = (float) (entity.getWidth() * 4);
    this.entity = entity;

    this.currentText = text;
    this.currentTextDisplayTime = DISPLAYTIME_MIN + text.length() * DISPLAYTIME_PER_LETTER;

    this.lastTextDisplay = Game.time().now();
    this.createBubbleImage();
    entity.getEnvironment().add(this, RenderType.UI);
    Game.loop().attach(this);
    activeSpeechBubbles.put(entity, this);
}
}
```
```java
class de.gurkenlabs.litiengine.gui.TextFieldComponent {
@Override
  public void render(final Graphics2D g) {
    super.render(g);
    g.setFont(this.getFont());
    final FontMetrics fm = g.getFontMetrics();

    if (this.isSelected() && Game.time().since(this.lastToggled) > this.flickerDelay) {
      this.cursorVisible = !this.cursorVisible;
      this.lastToggled = Game.time().now();
    }
    if (this.isSelected() && this.cursorVisible) {
      final Rectangle2D cursor =
          new Rectangle2D.Double(
              this.getX() + this.getTextX() + fm.stringWidth(this.getTextToRender(g)),
              this.getY() + this.getTextY(),
              this.getFont().getSize2D() * 3 / 5,
              this.getFont().getSize2D() * 1 / 5);
      g.setColor(this.getAppearance().getForeColor());
      g.fill(cursor);
    }
}
}
```
```java
class de.gurkenlabs.litiengine.entities.Prop {
public Prop(
      final Point2D location, @Nullable final String spritesheetName, final Material material) {
    super();
    this.rotation = Rotation.NONE;
    this.spritesheetName = spritesheetName;
    this.material = material;
    this.setLocation(location);
    this.updateAnimationController();
}public void setSpritesheetName(@Nullable final String spriteName) {
    this.spritesheetName = spriteName;
    this.updateAnimationController();
}
}
```
```java
class de.gurkenlabs.litiengine.tweening.Tween {
public Tween begin() {
    this.started = Game.time().now();
    this.stopped = false;
    return this;
}
}
```
```java
class de.gurkenlabs.litiengine.graphics.emitters.particles.Particle {
public void update(final Point2D emitterOrigin, final float updateRatio) {
    if (this.aliveTick == 0) {
      this.aliveTick = Game.time().now();
    }

    this.aliveTime = Game.time().since(this.aliveTick);
    if (this.timeToLiveReached()) {
      return;
    }

    if (this.colliding) {
      return;
    }

    if (this.getDeltaWidth() != 0) {
      this.width += this.getDeltaWidth() * updateRatio;
    }

    if (this.getDeltaHeight() != 0) {
      this.height += this.getDeltaHeight() * updateRatio;
    }

    if (this.getDeltaAngle() != 0) {
      this.angle += this.getDeltaAngle() * updateRatio;
    }

    // test for ray cast collision
    final float targetX = this.x + this.getVelocityX() * updateRatio;
    final float targetY = this.y + this.getVelocityY() * updateRatio;

    if (targetX == this.x && targetY == this.y) {
      return;
    }

    if (this.checkForCollision(emitterOrigin, targetX, targetY)) {
      return;
    }

    if (this.getVelocityX() != 0) {
      this.x = targetX;
    }

    if (this.getVelocityY() != 0) {
      this.y = targetY;
    }

    if (this.getAccelerationX() != 0) {
      this.velocityX += this.getAccelerationX() * updateRatio;
    }

    if (this.getAccelerationY() != 0) {
      this.velocityY += this.getAccelerationY() * updateRatio;
    }
}
}
```
```java
class de.gurkenlabs.litiengine.graphics.animation.Animation {
@Override
  public void start() {
    this.playing = true;
    if (this.getKeyframes().isEmpty()) {
      return;
    }

    this.restart();
}@Override
  public void update() {
    // do nothing if the animation is not playing or the current keyframe is not finished
    if (!this.isPlaying()
        || Game.time().since(this.lastFrameUpdate) < this.getCurrentKeyFrame().getDuration()) {
      return;
    }

    // if we are not looping and the last keyframe is finished, we terminate the animation
    if (!this.isLooping() && this.isLastKeyFrame()) {
      this.terminate();
      return;
    }

    // make sure, we stay inside the keyframe list
    final int newFrameIndex =
        (this.getKeyframes().indexOf(this.currentFrame) + 1) % this.getKeyframes().size();
    final KeyFrame previousFrame = this.currentFrame;
    this.currentFrame = this.getKeyframes().get(newFrameIndex);

    for (KeyFrameListener listener : this.listeners) {
      listener.currentFrameChanged(previousFrame, this.currentFrame);
    }

    this.lastFrameUpdate = Game.loop().getTicks();
}
}
```
```java
class de.gurkenlabs.litiengine.graphics.animation.AnimationController {
@Override
  public void update() {
    for (final Animation animation : this.getAll()) {
      animation.update();
    }

    if (this.getCurrent() != null && this.getCurrent().isPaused()) {
      return;
    }

    final boolean playbackFinished = this.getCurrent() != null && !this.getCurrent().isPlaying();
    if (playbackFinished) {
      for (final AnimationListener listener : this.listeners) {
        listener.finished(this.getCurrent());
      }
    }

    if (this.getCurrent() == null || playbackFinished) {
      if (this.getDefault() != null) {
        this.play(this.getDefault().getName());
      } else {
        this.currentAnimation = null;
      }
    }
}
}
```
```java
class de.gurkenlabs.litiengine.graphics.RenderComponent {
private void handleFade() {
    if (this.fadeOutStart != -1) {
      final long timePassed = Game.time().since(this.fadeOutStart);
      this.currentAlpha = MathUtilities.clamp(1 - timePassed / (float) this.fadeOutTime, 0, 1);
      if (this.currentAlpha == 0f) {
        this.fadeOutStart = -1;
        this.fadeOutTime = -1;
      }

      return;
    }

    if (this.fadeInStart != -1) {
      final long timePassed = Game.time().since(this.fadeInStart);
      this.currentAlpha = MathUtilities.clamp(timePassed / (float) this.fadeInTime, 0, 1);
      if (this.currentAlpha == 1f) {
        this.fadeInStart = -1;
        this.fadeInTime = -1;
        this.currentAlpha = Float.NaN;
      }
    }
}public void fadeOut(final int ms) {
    this.fadeInStart = -1;
    this.fadeInTime = -1;
    this.fadeOutStart = Game.time().now();
    this.fadeOutTime = ms;
}public void fadeIn(final int ms) {
    this.fadeOutStart = -1;
    this.fadeOutTime = -1;
    this.fadeInStart = Game.time().now();
    this.fadeInTime = ms;
}
}
```
```java
class de.gurkenlabs.litiengine.entities.Trigger {
private boolean activate(final IEntity activator, final int tar) {
    if (!this.isLoaded()
        || this.isOneTimeTrigger && this.isActivated
        || this.getActivationType() == TriggerActivation.COLLISION
            && activator != null
            && this.collisionActivated.contains(activator)) {
      return false;
    }

    if (this.getCooldown() > 0 && Game.time().since(this.lastActivation) < this.getCooldown()) {
      return false;
    }

    List<Integer> triggerTargets = this.getTargets(tar);

    final TriggerEvent te = new TriggerEvent(this, activator, triggerTargets);

    if (!this.checkActivationPredicates(te)) {
      return false;
    }

    this.isActivated = true;
    if (activator != null) {
      this.collisionActivated.add(activator);
    }

    // if we actually have a trigger target, we send the message to the target
    for (final int target : triggerTargets) {
      final IEntity entity = this.getEnvironment().get(target);
      if (entity == null) {
        log.log(
            Level.WARNING,
            "trigger [{0}] was activated, but the trigger target [{1}] could not be found on the environment",
            new Object[] {this, target});
        continue;
      }

      entity.sendMessage(this, this.message);
    }

    // also send the trigger event to all registered consumers
    for (final TriggerActivatedListener listener : this.activatedListeners) {
      listener.activated(te);
    }

    if (this.isOneTimeTrigger) {
      this.getEnvironment().remove(this);
    }

    this.lastActivation = Game.time().now();
    return true;
}
}
```
```java
class de.gurkenlabs.litiengine.graphics.Camera {
private boolean isShakeEffectActive() {
    return this.getShakeTick() != 0
        && Game.time().since(this.getShakeTick()) < this.getShakeDuration();
}@Override
  public void update() {
    if (Game.world().camera() != null && !Game.world().camera().equals(this)) {
      return;
    }

    if (this.targetZoom > 0) {
      if (Game.time().since(this.zoomTick) >= this.zoomDelay) {
        this.zoom = this.targetZoom;
        this.targetZoom = 0;
        this.zoomDelay = 0;
        this.zoomTick = 0;
        this.zoomStep = 0;
      } else {
        this.zoom += this.zoomStep;
      }

      final ZoomChangedEvent event = new ZoomChangedEvent(this, this.getZoom());
      for (final ZoomChangedListener listener : this.zoomListeners) {
        listener.zoomChanged(event);
      }
    }

    if (this.panTime > 0) {
      if (--this.panTime <= 0) {
        this.setFocus(this.targetFocus);
        this.targetFocus = null;
      } else {
        double diff = this.panTime / (this.panTime + 1.0);
        this.focus =
            new Point2D.Double(
                this.focus.getX() * diff + this.targetFocus.getX() * (1.0 - diff),
                this.focus.getY() * diff + this.targetFocus.getY() * (1.0 - diff));
      }
    }

    if (!this.isShakeEffectActive()) {
      this.shakeOffsetX = 0;
      this.shakeOffsetY = 0;
      return;
    }

    if (Game.time().since(this.lastShake) > this.shakeDelay) {
      this.shakeOffsetX = this.getShakeIntensity() * ThreadLocalRandom.current().nextGaussian();
      this.shakeOffsetY = this.getShakeIntensity() * ThreadLocalRandom.current().nextGaussian();
      this.lastShake = Game.time().now();
    }
}@Override
  public void setZoom(final float targetZoom, final int delay) {
    if (delay == 0) {

      this.zoom = targetZoom;
      this.targetZoom = 0;
      this.zoomDelay = 0;
      this.zoomTick = 0;
      this.zoomStep = 0;

      final ZoomChangedEvent event = new ZoomChangedEvent(this, targetZoom);
      for (final ZoomChangedListener listener : this.zoomListeners) {
        listener.zoomChanged(event);
      }
    } else {
      this.zoomTick = Game.time().now();
      this.targetZoom = targetZoom;
      this.zoomDelay = delay;

      final double tickduration = 1000 / (double) Game.loop().getTickRate();
      final double tickAmount = delay / tickduration;
      final float totalDelta = this.targetZoom - this.zoom;
      this.zoomStep = tickAmount > 0 ? (float) (totalDelta / tickAmount) : totalDelta;
    }
}@Override
  public void shake(final double intensity, final int delay, final int shakeDuration) {
    this.shakeTick = Game.time().now();
    this.shakeDelay = delay;
    this.shakeIntensity = intensity;
    this.shakeDuration = shakeDuration;
}
}
```
```java
class de.gurkenlabs.litiengine.entities.Creature {
public void setSpritesheetName(String spritesheetName) {
    if (this.spritesheetName != null && this.spritesheetName.equals(spritesheetName)) {
      return;
    }

    this.spritesheetName = spritesheetName;
    this.updateAnimationController();
}public boolean isIdle() {
    return Game.time().since(this.lastMoved) > IDLE_DELAY;
}@Override
  public void setLocation(final Point2D position) {
    if (this.isDead() || position == null) {
      return;
    }

    final Point2D oldLocation = this.getLocation();
    super.setLocation(position);

    if (Game.hasStarted() && this.isLoaded()) {
      this.lastMoved = Game.time().now();
      this.fireMovedEvent(
          new EntityMovedEvent(
              this, this.getX() - oldLocation.getX(), this.getY() - oldLocation.getY()));
    }
}
}
```
```java
class de.gurkenlabs.litiengine.gui.screens.ScreenManager {
public void display(final String screenName) {
    if (this.current() != null && this.current().getName().equalsIgnoreCase(screenName)) {
      log.log(
          Level.INFO,
          "Skipping displaying of screen {0} because it is already the current screen.",
          screenName);
      return;
    }

    if (this.screens.stream()
        .noneMatch(element -> element.getName().equalsIgnoreCase(screenName))) {
      log.log(
          Level.WARNING,
          "Could not display the screen {0} because there is no screen with the specified name.",
          screenName);
      return;
    }

    Screen screen = this.get(screenName);
    if (screen == null) {
      return;
    }

    this.display(screen);
}public void add(final Screen screen) {
    screen.setWidth(Game.window().getWidth());
    screen.setHeight(Game.window().getHeight());
    this.screens.add(screen);

    if (this.current() == null) {
      this.display(screen);
    }
}public void remove(Screen screen) {
    this.screens.remove(screen);
    if (this.current() == screen) {
      if (!this.screens.isEmpty()) {
        this.display(this.screens.get(0));
      } else {
        this.display((Screen) null);
      }
    }
}public void display(@Nullable final Screen screen) {
    if (Game.hasStarted() && Game.time().since(this.lastScreenChange) < this.getChangeCooldown()) {
      log.log(
          Level.INFO,
          "Skipping displaying of screen {0} because screen changing is currently on cooldown.",
          screen != null ? screen.getName() : "");
      return;
    }

    final Screen previous = this.current();
    if (previous != null) {
      previous.suspend();
    }

    if (screen != null && !this.screens.contains(screen)) {
      this.screens.add(screen);
    }

    this.currentScreen = screen;
    if (!Game.isInNoGUIMode() && this.current() != null) {
      this.current().prepare();
    }

    this.lastScreenChange = Game.loop().getTicks();

    final ScreenChangedEvent event = new ScreenChangedEvent(this.current(), previous);
    for (final ScreenChangedListener listener : this.screenChangedListeners) {
      listener.changed(event);
    }
}
}
```
```java
class de.gurkenlabs.litiengine.abilities.Ability {
public boolean isOnCooldown() {
    return (this.getCurrentExecution() != null
        && this.getCurrentExecution().getExecutionTicks() > 0
        && Game.time().since(this.getCurrentExecution().getExecutionTicks())
            < this.getAttributes().cooldown().get());
}public boolean isActive() {
    return this.getCurrentExecution() != null
        && Game.time().since(this.getCurrentExecution().getExecutionTicks())
            < this.getAttributes().duration().get();
}@Nullable
  public AbilityExecution cast() {
    if (!this.canCast()) {
      return null;
    }
    this.currentExecution = new AbilityExecution(this);

    for (final AbilityCastListener listener : this.abilityCastListeners) {
      listener.abilityCast(this.currentExecution);
    }

    return this.getCurrentExecution();
}public float getRemainingCooldownInSeconds() {
    if (this.getCurrentExecution() == null
        || this.getExecutor() == null
        || this.getExecutor().isDead()) {
      return 0;
    }

    // calculate cooldown in seconds
    return (float)
        (!this.canCast()
            ? (this.getAttributes().cooldown().get()
                    - Game.time().since(this.getCurrentExecution().getExecutionTicks()))
                * 0.001
            : 0);
}
}
```
```java
class de.gurkenlabs.litiengine.entities.EntityHitEvent {
EntityHitEvent(
      final ICombatEntity hitEntity,
      @Nullable final Ability ability,
      final int damage,
      final boolean kill) {
    super(hitEntity);
    this.executor = ability != null ? ability.getExecutor() : null;
    this.hitEntity = hitEntity;
    this.ability = ability;
    this.damage = damage;
    this.kill = kill;
    this.time = Game.time().now();
}
}
```
```java
class de.gurkenlabs.litiengine.graphics.emitters.Emitter {
public void delete() {
    this.deactivate();
    if (Game.world().environment() != null) {
      Game.world().environment().remove(this);
    }
}public void activate() {
    if (this.activated) {
      return;
    }

    this.activated = true;
    this.activationTick = Game.time().now();
    Game.loop().attach(this);
}@Override
  public void update() {
    if (this.isPaused()) {
      return;
    }

    // clear particles if the effect time to life is reached
    if (this.isFinished()) {
      for (EmitterFinishedListener listener : this.finishedListeners) {
        listener.finished(this);
      }

      this.delete();
      return;
    }

    final float updateRatio = (float) this.data().getUpdateRate() / Game.loop().getTickRate();
    for (final Particle p : this.getParticles().stream().collect(Collectors.toList())) {
      if (this.particleCanBeRemoved(p)) {
        // remove dead particles
        this.particles.remove(p);
        continue;
      }

      p.update(this.getOrigin(), updateRatio);
    }

    this.aliveTime = Game.time().since(this.activationTick);
    if ((this.data().getSpawnRate() == 0
        || Game.time().since(this.lastSpawn) >= this.data().getSpawnRate())) {
      this.lastSpawn = Game.time().now();
      this.spawnParticle();
    }
}
}
```
```java
class de.gurkenlabs.litiengine.GameLoop {
@Override
  public int perform(int delay, Runnable action) {
    final long d = Game.time().toTicks(delay);

    TimedAction a = new TimedAction(this.getTicks() + d, action);
    this.actions.add(a);

    return a.getId();
}
}
```
```java
class de.gurkenlabs.litiengine.environment.EntitySpawner {
protected boolean shouldSpawn() {
    return this.lastSpawnWave == 0
        || Game.time().since(this.lastSpawnWave) >= this.getSpawnInterval();
}@Override
  public void update() {
    if (!this.shouldSpawn()) {
      return;
    }

    this.spawnNewEntities();
    this.lastSpawnWave = Game.time().now();
}
}
```
```java
class de.gurkenlabs.litiengine.graphics.FreeFlightCamera {
@Override
  public void update() {
    this.handleFreeFlightCamera();
}public FreeFlightCamera(double x, double y) {
    this(new Point2D.Double(x, y));
}
}
```
```java
class de.gurkenlabs.litiengine.environment.Environment {
public void unload() {
    if (!this.loaded) {
      return;
    }

    // unregister all updatable entities from the current environment
    for (final IEntity entity : this.allEntities.values()) {
      this.unload(entity);
    }

    this.loaded = false;
    this.fireEvent(l -> l.unloaded(this));
}private static void loadUpdatableOrEmitterEntity(IEntity entity) {
    if (entity instanceof Emitter) {
      final Emitter emitter = (Emitter) entity;
      if (emitter.isActivateOnInit()) {
        emitter.activate();
      }
    } else if (entity instanceof IUpdateable) {
      Game.loop().attach((IUpdateable) entity);
    }
}public void clear() {
    Game.physics().clear();

    this.combatEntities.clear();
    this.mobileEntities.clear();
    this.gravityForces.clear();
    this.layerEntities.clear();
    this.entitiesByTag.clear();
    this.allEntities.clear();

    for (RenderType renderType : RenderType.values()) {
      this.miscEntities.get(renderType).clear();
      this.renderListeners.get(renderType).clear();
      this.renderables.get(renderType).clear();
    }

    dispose(this.allEntities.values());
    dispose(this.triggers);
    this.emitters.clear();
    this.colliders.clear();
    this.props.clear();
    this.creatures.clear();
    this.staticShadows.clear();
    this.combatEntities.clear();
    this.mobileEntities.clear();
    this.lightSources.clear();
    this.spawnPoints.clear();
    this.soundSources.clear();
    this.mapAreas.clear();
    this.triggers.clear();

    this.ambientLight = null;
    this.staticShadowLayer = null;

    for (Map<Integer, IEntity> type : this.miscEntities.values()) {
      type.clear();
    }

    this.initialized = false;

    this.fireEvent(l -> l.cleared(this));
}private void load(final IEntity entity) {
    // an entity can only exist on one environment at a time, so remove it from the current one
    if (entity.getEnvironment() != null) {
      entity.getEnvironment().remove(entity);
    }

    // 1. add to physics engine
    loadPhysicsEntity(entity);

    // 2. register for update or activate
    loadUpdatableOrEmitterEntity(entity);

    // 3. if a gravity is defined, add a gravity force to the entity
    if (entity instanceof IMobileEntity && this.getGravity() != 0) {
      this.addGravityForce((IMobileEntity) entity);
    }

    // 4. attach all controllers
    entity.attachControllers();

    if (this.loaded && (entity instanceof LightSource || entity instanceof StaticShadow)) {
      this.updateLighting(entity);
    }

    entity.loaded(this);
}private void unload(final IEntity entity) {
    // 1. remove from physics engine
    if (entity instanceof ICollisionEntity) {
      Game.physics().remove((ICollisionEntity) entity);
    }

    // 2. unregister from update
    if (entity instanceof IUpdateable) {
      Game.loop().detach((IUpdateable) entity);
    }

    if (entity instanceof IMobileEntity) {
      this.removeGravity((IMobileEntity) entity);
    }

    // 3. detach all controllers
    entity.detachControllers();

    if (entity instanceof Emitter) {
      Emitter em = (Emitter) entity;
      em.deactivate();
    }

    if (this.loaded && (entity instanceof LightSource || entity instanceof StaticShadow)) {
      this.updateLighting(entity);
    }

    entity.removed(this);
}public void remove(final IEntity entity) {
    if (entity == null) {
      return;
    }

    this.allEntities.remove(entity.getMapId());
    Iterator<List<IEntity>> iter = this.layerEntities.values().iterator();
    while (iter.hasNext()) {
      List<IEntity> layer = iter.next();
      if (layer.remove(entity) && layer.isEmpty()) {
        iter.remove();
      }
    }
    if (this.miscEntities.get(entity.getRenderType()) != null) {
      this.miscEntities.get(entity.getRenderType()).values().remove(entity);
    }

    for (String tag : entity.getTags()) {
      if (this.getEntitiesByTag().containsKey(tag)) {
        this.getEntitiesByTag().get(tag).remove(entity);

        if (this.getEntitiesByTag().get(tag).isEmpty()) {
          this.getEntitiesByTag().remove(tag);
        }
      }
    }

    if (entity instanceof Emitter) {
      Emitter emitter = (Emitter) entity;
      this.removeEmitter(emitter);
    }

    if (entity instanceof MapArea) {
      this.mapAreas.remove(entity);
    }

    if (entity instanceof Prop) {
      this.props.remove(entity);
    }

    if (entity instanceof Creature) {
      this.creatures.remove(entity);
    }

    if (entity instanceof CollisionBox) {
      this.colliders.remove(entity);
      this.staticShadows.removeIf(x -> x.getOrigin() != null && x.getOrigin().equals(entity));
    }

    if (entity instanceof LightSource) {
      this.lightSources.remove(entity);
      this.updateLighting(entity);
    }

    if (entity instanceof Trigger) {
      this.triggers.remove(entity);
    }

    if (entity instanceof Spawnpoint) {
      this.spawnPoints.remove(entity);
    }
    if (entity instanceof SoundSource) {
      this.soundSources.remove(entity);
    }

    if (entity instanceof StaticShadow) {
      this.staticShadows.remove(entity);
      this.updateLighting(entity);
    }

    if (entity instanceof IMobileEntity) {
      this.mobileEntities.values().remove(entity);
    }

    if (entity instanceof ICombatEntity) {
      this.combatEntities.values().remove(entity);
    }

    this.unload(entity);

    this.fireEntityEvent(l -> l.entityRemoved(entity));
}
}
```
```java
class de.gurkenlabs.litiengine.physics.MovementController {
@Override
  public void update() {
    this.handleForces();
    this.handleMovement();
}
}
```
```java
class de.gurkenlabs.litiengine.Game {
static synchronized void terminate() {
    if (!initialized) {
      return;
    }

    hasStarted = false;
    initialized = false;

    config().save();
    gameLoop.terminate();
    tweenEngine.terminate();
    soundEngine.terminate();

    world().clear();

    for (final GameListener listener : gameListeners) {
      try {
        listener.terminated();
      } catch (Exception e) {
        log().log(Level.WARNING, "game listener threw an exception during shutdown", e);
      }
    }

    gameLoop = null;
    screenManager = null;
    gameWindow = null;
}public static synchronized void start() {
    if (!initialized) {
      throw new IllegalStateException(
          "The game cannot be started without being first initialized. Call Game.init(...) before Game.start().");
    }

    gameLoop.start();
    tweenEngine.start();
    soundEngine.start();

    for (final GameListener listener : gameListeners) {
      listener.started();
    }

    hasStarted = true;
}public static synchronized void init(String... args) {
    if (initialized) {
      log().log(Level.INFO, "The game has already been initialized.");
      return;
    }

    log.init();
    handleCommandLineArguments(args);

    config().load();
    Locale.setDefault(new Locale(config().client().getCountry(), config().client().getLanguage()));

    gameLoop = new GameLoop("Main Update Loop", config().client().getMaxFps());
    loop().attach(physics());
    loop().attach(world());

    // setup default exception handling for render and update loop
    setUncaughtExceptionHandler(
        new DefaultUncaughtExceptionHandler(config().client().exitOnError()));

    screenManager = new ScreenManager();
    gameWindow = new GameWindow();

    // initialize  the game window
    window().init();
    world.setCamera(new Camera());

    for (GameListener listener : gameListeners) {
      listener.initialized(args);
    }

    if (!isInNoGUIMode()) {
      window().getRenderComponent().onRendered(g -> metrics().render(g));

      graphics()
          .addEntityRenderedListener(
              e -> DebugRenderer.renderEntityDebugInfo(e.getGraphics(), e.getEntity()));

      window().getRenderComponent().onFpsChanged(fps -> metrics().setFramesPerSecond(fps));
      window()
          .setIcons(
              Arrays.asList(
                  Resources.images().get("liti-logo-x16.png"),
                  Resources.images().get("liti-logo-x20.png"),
                  Resources.images().get("liti-logo-x32.png"),
                  Resources.images().get("liti-logo-x48.png")));

      Input.keyboard()
          .onKeyTyped(
              KeyEvent.VK_PRINTSCREEN,
              key -> {
                // don't take a screenshot if a modifier is active
                if (key.getModifiers() != 0) {
                  return;
                }

                window().getRenderComponent().takeScreenshot();
              });
    }

    Runtime.getRuntime().addShutdownHook(new Thread(Game::terminate, "Shutdown"));

    initialized = true;
}
}
```


Response Format:
Provide the answer in **XML format** as follows:

#### If the method **cannot** return `null` at the specific call site:
```xml
<response>
  <reason><![CDATA[EXPLAIN WHY THE INVOCATION Game.loop() RESULT CANNOT BE NULL.]]></reason>
  <value>NO</value>
</response>

#### If the method can return null at the specific call site:
<response>
  <reason><![CDATA[EXPLAIN WHY THE INVOCATION Game.loop() RESULT CAN BE NULL.]]></reason>
  <value>YES</value>
</response>

#### If you are unsure or If there are any methods that directly or indirectly affect the return value and are not fully disclosed, request their declarations first, in the following format:
<response>
  <reason><![CDATA[EXPLAIN WHY THIS METHOD DECLARATION IS NECESSARY AND WHY YOU CANNOT MAKE A CONFIDENT DECISION WITHOUT IT]]></reason>
  <success>false</success>
  <methods>
    <method>methodName</method>
  </methods>
</response>

Additional Notes:
Be precise in your reasoning.
If a method’s return value depends on another method not provided, request its declaration before making a conclusion.
If the method can return null in this case but not in others, explain why it happens specifically for this call.

---ChatGPT.sendRequestToOpenAI---
Retrieving response from cache
---Response.<init>---
Creating Response:
```xml
<response>
  <reason><![CDATA[The method `Game.loop()` returns the static field `gameLoop`, which is initialized in the `Game.init(String... args)` method. In this method, a new `GameLoop` object is instantiated and assigned to `gameLoop`. Since `init()` must be called before `start()`, which is implied by the requirement of initializing the game, the `gameLoop` is guaranteed to be non-null during the lifetime of the game execution where `Game.loop()` is called. The absence of any code that could set `gameLoop` to null after its initialization ensures that `Game.loop()` cannot return null.]]></reason>
  <value>NO</value>
</response>
```
---Response.<init>---
Response created:
Disagreement: The method `Game.loop()` returns the static field `gameLoop`, which is initialized in the `Game.init(String... args)` method. In this method, a new `GameLoop` object is instantiated and assigned to `gameLoop`. Since `init()` must be called before `start()`, which is implied by the requirement of initializing the game, the `gameLoop` is guaranteed to be non-null during the lifetime of the game execution where `Game.loop()` is called. The absence of any code that could set `gameLoop` to null after its initialization ensures that `Game.loop()` cannot return null.
---AdvancedNullAwayCodeFix.resolveMethodDereferenceError---
Method is not returning nullable on call site. Injecting suppression annotation.
---AdvancedNullAwayCodeFix.constructCastToNonnullChange---
Constructing cast to nonnull change for reason: The method `Game.loop()` returns the static field `gameLoop`, which is initialized in the `Game.init(String... args)` method. In this method, a new `GameLoop` object is instantiated and assigned to `gameLoop`. Since `init()` must be called before `start()`, which is implied by the requirement of initializing the game, the `gameLoop` is guaranteed to be non-null during the lifetime of the game execution where `Game.loop()` is called. The absence of any code that could set `gameLoop` to null after its initialization ensures that `Game.loop()` cannot return null.
---ChatGPT.ask---
Asking ChatGPT:
For the reason you mentioned earlier:

"The method `Game.loop()` returns the static field `gameLoop`, which is initialized in the `Game.init(String... args)` method. In this method, a new `GameLoop` object is instantiated and assigned to `gameLoop`. Since `init()` must be called before `start()`, which is implied by the requirement of initializing the game, the `gameLoop` is guaranteed to be non-null during the lifetime of the game execution where `Game.loop()` is called. The absence of any code that could set `gameLoop` to null after its initialization ensures that `Game.loop()` cannot return null."

in the method below, the expression Game.loop() is not nullable at the point it is used.

```java
public void hide() {
    Game.world().environment().removeRenderable(this);
    Game.loop().detach(this);
    if (activeSpeechBubbles.get(this.getEntity()) != null
        && activeSpeechBubbles.remove(this.getEntity()).equals(this)) {
      activeSpeechBubbles.remove(this.getEntity());
    }

    for (SpeechBubbleListener listener : this.listeners) {
      listener.hidden();
    }
}
```
Please Summarize the reason in max 5 words and rewrite the method so that at the line "    Game.loop().detach(this);", at the occurrence of: "Game.loop()" is replaced with `NullabilityUtil.castToNonnull(Game.loop(), summary of reason)`
Replace "REASON" with the exact reason summary I provide to you (maximum 5 words), not with a generic explanation like "checked to be nonnull".
see the example below, for expression `foo.getBar()`, to wrap it with `NullabilityUtil.castToNonnull(foo.getBar(), "reason")`.

```java
public t(){
    String l = foo.getBar();
}
```

will be:
```java
public t(){
    String l = NullabilityUtil.castToNonnull(foo.getBar(), "checked to be nonnull");
}
```

### Instructions:

Do not import any additional classes.

Do not add Java comments.

Only modify relevant lines as required.

Return only the modified method wrapped in the XML format shown below.

Place the Java code inside the <code> tag using a CDATA block with ```java formatting.

Just give me the fixed code snippet in XML format in <response> tag like the example below. I will apply the fix to my codebase. Do not import any additional libraries or classes or add java comments. If you can provide the fixed code snippet, please provide it in the following format and place the code snippet in the <code> tag within ```java block.
<response>
  <success>true</success>
  <code><![CDATA[
  ```java
  Your fixed code snippet here
  ```
    ]]>
  </code>
</response>

---ChatGPT.sendRequestToOpenAI---
Sending request to OpenAI...
---ChatGPT.sendRequestToOpenAI---
Response received from OpenAI.
---Response.<init>---
Creating Response:
<response>
  <success>true</success>
  <code><![CDATA[
  ```java
public void hide() {
    Game.world().environment().removeRenderable(this);
    NullabilityUtil.castToNonnull(Game.loop(), "guaranteed non-null").detach(this);
    if (activeSpeechBubbles.get(this.getEntity()) != null
        && activeSpeechBubbles.remove(this.getEntity()).equals(this)) {
      activeSpeechBubbles.remove(this.getEntity());
    }

    for (SpeechBubbleListener listener : this.listeners) {
      listener.hidden();
    }
}
  ```
    ]]>
  </code>
</response>
---Response.<init>---
Response created:
public void hide() {
    Game.world().environment().removeRenderable(this);
    NullabilityUtil.castToNonnull(Game.loop(), "guaranteed non-null").detach(this);
    if (activeSpeechBubbles.get(this.getEntity()) != null
        && activeSpeechBubbles.remove(this.getEntity()).equals(this)) {
      activeSpeechBubbles.remove(this.getEntity());
    }

    for (SpeechBubbleListener listener : this.listeners) {
      listener.hidden();
    }
}
---ChatGPT.fixDereferenceByAddingCastToNonnull---
Fixing the error by adding castToNonnull
---AdvancedNullAwayCodeFix.fixTriggeredErrorsForLocation---
Resolving unresolvable error for triggered error: Type='DEREFERENCE_NULLABLE', message='dereferenced expression Game.loop() is @Nullable'
/home/nima/Developer/nullness-benchmarks/litiengine/src/de/gurkenlabs/litiengine/abilities/AbilityExecution.java:56
      Game.loop().detach(this);
---AdvancedNullAwayCodeFix.fix---
Fixing error: Type='DEREFERENCE_NULLABLE', message='dereferenced expression Game.loop() is @Nullable'
/home/nima/Developer/nullness-benchmarks/litiengine/src/de/gurkenlabs/litiengine/abilities/AbilityExecution.java:56
      Game.loop().detach(this);
---AdvancedNullAwayCodeFix.resolveDereferenceError---
Resolving dereference error: Type='DEREFERENCE_NULLABLE', message='dereferenced expression Game.loop() is @Nullable'
/home/nima/Developer/nullness-benchmarks/litiengine/src/de/gurkenlabs/litiengine/abilities/AbilityExecution.java:56
      Game.loop().detach(this);
---AdvancedNullAwayCodeFix.resolveDereferenceError---
Checking nullability possibility at error point
---ChatGPT.checkNullabilityPossibilityAtErrorPoint---
Asking if the expression can be null at error point point
---ChatGPT.ask---
Asking ChatGPT:
In the method below, is there a possibility that the expression "Game.loop()" at line "Game.loop().detach(this);" is null?
@Override
  public void update() {
    // if there a no effects to apply -> unregister this instance and we're done
    if (this.getAbility().getEffects().isEmpty()
        || this.getAbility().getEffects().size() == this.getAppliedEffects().size()) {
      Game.loop().detach(this);
      return;
    }

    // handle all effects from the ability that were not applied yet
    for (final Effect effect : this.getAbility().getEffects()) {
      // if the ability was not executed yet or the delay of the effect is not
      // yet reached
      if (this.getAppliedEffects().contains(effect)
          || Game.time().since(this.getExecutionTicks()) < effect.getDelay()) {
        continue;
      }

      effect.apply(this.getExecutionImpactArea());
      this.getAppliedEffects().add(effect);
    }
}
Give a single-word answer in XML format. If it is possible for the expression to be null, respond with:
```xml
<response>
    <reason><![CDATA[YOUR REASON]]></reason>
    <value>YES</value>
</response>
```
If it is not possible for the expression to be null, respond with:
```xml
<response>
    <reason><![CDATA[YOUR REASON]]></reason>
    <value>NO</value>
</response>
```
If you are unsure or need more information, respond with where you can ask for more details or what specific information you need.

If additional information is required, list each request inside a `<request>` tag. If no additional information is needed, omit the `<requests>` section.

Respond with:
```xml
<response>
    <reason><![CDATA[YOUR REASON]]></reason>
    <value>UNKNOWN</value>
    <!-- Include <requests> only if additional information is needed -->
    <requests>
        <request><![CDATA[YOUR REQUEST 1]]></request>
        <request><![CDATA[YOUR REQUEST 2]]></request>
    </requests>
</response>
```
---ChatGPT.sendRequestToOpenAI---
Sending request to OpenAI...
---ChatGPT.sendRequestToOpenAI---
Response received from OpenAI.
---Response.<init>---
Creating Response:
```xml
<response>
    <reason><![CDATA[Without more information about the implementation of the method Game.loop(), it is unclear if it can return null. This depends on how Game.loop() is implemented.]]></reason>
    <value>UNKNOWN</value>
    <requests>
        <request><![CDATA[Provide the implementation or documentation of the Game.loop() method.]]></request>
    </requests>
</response>
```
---Response.<init>---
Response created:
Unknown: Without more information about the implementation of the method Game.loop(), it is unclear if it can return null. This depends on how Game.loop() is implemented.
---AdvancedNullAwayCodeFix.resolveMethodDereferenceError---
Resolving method dereference error.
---AdvancedNullAwayCodeFix.resolveMethodDereferenceError---
Method is in annotated package. Checking if the method is returning nullable.
---AdvancedNullAwayCodeFix.investigateMethodReturnNullability---
Checking if the method is returning nullable.
---ChatGPT.checkIfMethodIsReturningNullable---
Asking if the method is returning nullable: loop()
---ChatGPT.ask---
Asking ChatGPT:
In the method below, is there a possibility that the method returns null based only on its body? Consider the following points:

- The method may have multiple return paths; consider all return statements.
- If the method calls another method, do not assume its return value unless its full declaration is provided. Request its declaration if needed.
- The method may throw an exception instead of returning null. An exception path should not be considered a null return.
- Ensure you request the declarations of any methods whose return values directly or indirectly impact this method’s return value before making a conclusion.
- Carefully analyze all conditions and prior operations that may guarantee a non-null return value.

@Nullable public static IGameLoop loop() {
    return gameLoop;
}

Here are the method definitions in addition to the method inquired:

Depth: 0
```java
class de.gurkenlabs.litiengine.Game {
@Nullable public static IGameLoop loop() {
    return gameLoop;
}
}
```


Response Format:
Provide the answer in **XML format** as follows:

#### If the method **cannot** return `null`:
```xml
<response>
  <reason><![CDATA[EXPLAIN WHY THE METHOD CANNOT RETURN NULL]]></reason>
  <value>NO</value>
</response>
```

#### If the method can return null:
```xml
<response>
  <reason><![CDATA[EXPLAIN WHY THE METHOD CAN RETURN NULL]]></reason>
  <value>YES</value>
</response>
```

#### If you are unsure or need more information, respond with where you can ask for more details or what specific information you need.

#### If you are unsure or If there are any methods that directly or indirectly affect the return value and are not fully disclosed, request their declarations first, in the following format:
<response>
  <reason><![CDATA[YOUR REASON]]></reason>
  <value>UNKNOWN</value>
  <methods>
    <method>methodName</method>
  </methods>
</response>

If additional information is required other than method declaration, list each request inside a `<request>` tag. If no additional information is needed, omit the `<requests>` section.

Respond with:
```xml
<response>
    <reason><![CDATA[YOUR REASON]]></reason>
    <value>UNKNOWN</value>
    <!-- Include <requests> only if additional information is needed -->
    <requests>
        <request><![CDATA[YOUR REQUEST 1]]></request>
        <request><![CDATA[YOUR REQUEST 2]]></request>
    </requests>
</response>
```

Additional Notes:
Be precise in your reasoning.
If a method’s return value depends on another method not provided, request its declaration before making a conclusion.
If the method can return null in some cases but not others, explain under what conditions it can happen.

---ChatGPT.sendRequestToOpenAI---
Retrieving response from cache
---Response.<init>---
Creating Response:
```xml
<response>
  <reason><![CDATA[The method `loop` returns the variable `gameLoop`. Without the initialization or assignment details of `gameLoop`, it's unclear whether it can be null. The possibility of `gameLoop` being uninitialized or set to null elsewhere in the program means `loop` could potentially return null. Further information on `gameLoop` is required.]]></reason>
  <value>UNKNOWN</value>
  <requests>
    <request><![CDATA[Please provide the declaration and initialization of the variable `gameLoop` in the class `de.gurkenlabs.litiengine.Game`.]]></request>
  </requests>
</response>
```
---Response.<init>---
Response created:
Unknown: The method `loop` returns the variable `gameLoop`. Without the initialization or assignment details of `gameLoop`, it's unclear whether it can be null. The possibility of `gameLoop` being uninitialized or set to null elsewhere in the program means `loop` could potentially return null. Further information on `gameLoop` is required.
---AdvancedNullAwayCodeFix.investigateMethodReturnNullability---
Could not determine the nullability and model did not ask for any method.
---ChatGPT.checkIfMethodIsReturningNullableOnCallSite---
Asking if the method is returning nullable on the call site: Game.loop()
---ChatGPT.ask---
Asking ChatGPT:
In the method below, is there a possibility that the method returns null at the given call site?

```java
@Nullable public static IGameLoop loop() {
    return gameLoop;
}
```

## Guidelines:
- The method may have multiple return paths; consider all return statements.
- If the method calls another method, do not assume its return value unless its full declaration is provided. Request its declaration if needed.
- The method may throw an exception instead of returning null. An exception path should not be considered a null return.
- Ensure you request the declarations of any methods whose return values directly or indirectly impact this method’s return value before making a conclusion.
- If the method returns a value that is determined by a parameter, evaluate based on the actual argument at the given call site.
- Analyze based only on the specific invocation provided. Do not generalize to all possible inputs.- If the return value is guaranteed to be non-null at the call site, the answer should be a definitive NO.
- Do not generalize based on all possible inputs—your answer must be based only on the given invocation.
- Focus only on the given call site, not all possible invocations.

### call site:
Game.loop()

Here are the method definitions and the call chain for this method, showing the sequence of calls from the method to its callers at each depth level:

Depth: 0
```java
class de.gurkenlabs.litiengine.Game {
@Nullable public static IGameLoop loop() {
    return gameLoop;
}
}
```
Depth: 1
```java
class de.gurkenlabs.litiengine.environment.GameWorld {
public void loadEnvironment(@Nullable final Environment env) {
    Lock lock = Game.loop().getLock();
    lock.lock();
    try {
      unloadEnvironment();
      this.environment = env;
      if (env != null) {
        this.addEnvironment(env);

        if (env.getGravity() == 0 && this.gravity() != 0) {
          env.setGravity(this.gravity());
        }

        env.load();
        for (final EnvironmentLoadedListener listener : this.loadedListeners) {
          listener.loaded(env);
        }

        // call map specific listeners
        String mapName = getMapName(env);
        if (mapName != null && this.environmentLoadedListeners.containsKey(mapName)) {

          // for the default camera we center the camera on the environment
          if (this.camera().getClass().equals(Camera.class)) {
            camera().setFocus(env.getCenter());
          }

          for (EnvironmentLoadedListener listener : this.environmentLoadedListeners.get(mapName)) {
            listener.loaded(env);
          }
        }
      }
    } finally {
      lock.unlock();
    }
}public void setCamera(@Nullable final ICamera cam) {
    if (this.camera() != null) {
      Game.loop().detach(camera);
    }

    camera = cam;

    if (cam != null && !Game.isInNoGUIMode()) {
      Game.loop().attach(cam);
      cam.updateFocus();
    }
}
}
```
```java
class de.gurkenlabs.litiengine.entities.behavior.EntityNavigator {
public EntityNavigator(final IMobileEntity entity, final PathFinder pathFinder) {
    this.cancelNavigationConditions = new CopyOnWriteArrayList<>();
    this.listeners = new CopyOnWriteArrayList<>();
    this.entity = entity;
    this.pathFinder = pathFinder;
    this.setAcceptableError(DEFAULT_ACCEPTABLE_ERROR);
    Game.loop().attach(this);
}
}
```
```java
class de.gurkenlabs.litiengine.GameWindow {
private static void initializeWindowEventListeners(Window window) {

    window.addWindowStateListener(
        e -> {
          if (e.getNewState() == Frame.ICONIFIED) {
            Game.loop().setTickRate(ICONIFIED_MAX_FPS);
          } else {
            Game.loop().setTickRate(Game.config().client().getMaxFps());
          }
        });

    window.addWindowFocusListener(
        new WindowFocusListener() {
          @Override
          public void windowLostFocus(WindowEvent e) {
            if (Game.config().graphics().reduceFramesWhenNotFocused()) {
              Game.loop().setTickRate(NONE_FOCUS_MAX_FPS);
            }
          }

          @Override
          public void windowGainedFocus(WindowEvent e) {
            Game.loop().setTickRate(Game.config().client().getMaxFps());
          }
        });

    window.addWindowListener(
        new WindowAdapter() {
          @Override
          public void windowClosing(final WindowEvent event) {
            Game.exit();
          }
        });
}
}
```
```java
class de.gurkenlabs.litiengine.gui.screens.ScreenManager {
public void display(@Nullable final Screen screen) {
    if (Game.hasStarted() && Game.time().since(this.lastScreenChange) < this.getChangeCooldown()) {
      log.log(
          Level.INFO,
          "Skipping displaying of screen {0} because screen changing is currently on cooldown.",
          screen != null ? screen.getName() : "");
      return;
    }

    final Screen previous = this.current();
    if (previous != null) {
      previous.suspend();
    }

    if (screen != null && !this.screens.contains(screen)) {
      this.screens.add(screen);
    }

    this.currentScreen = screen;
    if (!Game.isInNoGUIMode() && this.current() != null) {
      this.current().prepare();
    }

    this.lastScreenChange = Game.loop().getTicks();

    final ScreenChangedEvent event = new ScreenChangedEvent(this.current(), previous);
    for (final ScreenChangedListener listener : this.screenChangedListeners) {
      listener.changed(event);
    }
}
}
```
```java
class de.gurkenlabs.litiengine.abilities.effects.Effect {
@Override
  public void update() {

    for (final Iterator<EffectApplication> iterator = this.getActiveAppliances().iterator();
        iterator.hasNext(); ) {
      final EffectApplication appliance = iterator.next();
      // if the effect duration is reached
      if (this.hasEnded(appliance)) {

        iterator.remove();
        this.cease(appliance);
      }
    }

    // 4. unregister if all appliances are finished
    if (this.getActiveAppliances().isEmpty()) {
      Game.loop().detach(this);
    }
}public void apply(final Shape impactArea) {
    final List<ICombatEntity> affected = this.lookForAffectedEntities(impactArea);
    for (final ICombatEntity affectedEntity : affected) {
      this.apply(affectedEntity);
    }

    this.appliances.add(new EffectApplication(affected, impactArea));

    // if it is the first appliance -> register for update
    if (this.appliances.size() == 1) {
      Game.loop().attach(this);
    }
}
}
```
```java
class de.gurkenlabs.litiengine.GameTime {
public long toTicks(final int milliseconds) {
    return this.toTicks(milliseconds, Game.loop().getTickRate());
}public long since(final long tick) {
    return toMilliseconds(Game.loop().getTicks() - tick);
}public long now() {
    return Game.loop().getTicks();
}public long sinceGameStart() {
    return this.toMilliseconds(Game.loop().getTicks());
}@Override
  public void loaded(Environment environment) {
    environmentLoaded = Game.loop().getTicks();
}public long toMilliseconds(final long ticks) {
    return this.toMilliseconds(ticks, Game.loop().getTickRate());
}
}
```
```java
class de.gurkenlabs.litiengine.GameMetrics {
@Override
  public void render(final Graphics2D g) {
    this.updateMetrics();

    if (!Game.config().client().showGameMetrics()) {
      return;
    }

    this.currentOffsetY = 0;

    g.setColor(this.renderColor);

    // render client metrics
    this.drawTitle(g, "[client]");
    this.drawMetric(g, "fps       : " + this.getFramesPerSecond());
    this.drawMetric(g, "max fps   : " + this.maxFramesPerSecond);
    this.drawMetric(g, "updatables: " + Game.loop().getUpdatableCount());

    // render jvm metrics if debug is enabled
    if (Game.config().debug().isDebugEnabled()) {
      this.drawTitle(g, "[jvm]");
      this.drawMetric(g, "java      : " + this.javaVersion);
      this.drawMetric(g, "memory    : " + String.format("%-5.5s", this.usedMemory) + " MB");
      this.drawMetric(g, "threads   : " + Thread.activeCount());
    }

    // render rendering metrics
    if (!this.renderMetrics.isEmpty()) {
      this.drawTitle(g, "[update]");

      for (RenderMetrics metric : this.renderMetrics) {
        this.drawMetric(g, metric.toString());
      }

      this.renderMetrics.clear();
    }
}
}
```
```java
class de.gurkenlabs.litiengine.graphics.emitters.Emitter {
public void deactivate() {
    if (!this.activated) {
      return;
    }

    this.activated = false;
    this.getParticles().clear();
    this.aliveTime = 0;
    this.activationTick = 0;
    this.lastSpawn = 0;
    Game.loop().detach(this);
}public void activate() {
    if (this.activated) {
      return;
    }

    this.activated = true;
    this.activationTick = Game.time().now();
    Game.loop().attach(this);
}@Override
  public void update() {
    if (this.isPaused()) {
      return;
    }

    // clear particles if the effect time to life is reached
    if (this.isFinished()) {
      for (EmitterFinishedListener listener : this.finishedListeners) {
        listener.finished(this);
      }

      this.delete();
      return;
    }

    final float updateRatio = (float) this.data().getUpdateRate() / Game.loop().getTickRate();
    for (final Particle p : this.getParticles().stream().collect(Collectors.toList())) {
      if (this.particleCanBeRemoved(p)) {
        // remove dead particles
        this.particles.remove(p);
        continue;
      }

      p.update(this.getOrigin(), updateRatio);
    }

    this.aliveTime = Game.time().since(this.activationTick);
    if ((this.data().getSpawnRate() == 0
        || Game.time().since(this.lastSpawn) >= this.data().getSpawnRate())) {
      this.lastSpawn = Game.time().now();
      this.spawnParticle();
    }
}
}
```
```java
class de.gurkenlabs.litiengine.entities.behavior.IBehaviorController {
public default void attach() {
    Game.loop().attach(this);
}public default void detach() {
    Game.loop().detach(this);
}
}
```
```java
class de.gurkenlabs.litiengine.abilities.AbilityExecution {
AbilityExecution(final Ability ability) {
    this.appliedEffects = new CopyOnWriteArrayList<>();
    this.ability = ability;
    this.executionTicks = Game.time().now();
    this.impactArea = ability.calculateImpactArea();
    this.castLocation = ability.getExecutor().getCenter();
    Game.loop().attach(this);
}@Override
  public void update() {
    // if there a no effects to apply -> unregister this instance and we're done
    if (this.getAbility().getEffects().isEmpty()
        || this.getAbility().getEffects().size() == this.getAppliedEffects().size()) {
      Game.loop().detach(this);
      return;
    }

    // handle all effects from the ability that were not applied yet
    for (final Effect effect : this.getAbility().getEffects()) {
      // if the ability was not executed yet or the delay of the effect is not
      // yet reached
      if (this.getAppliedEffects().contains(effect)
          || Game.time().since(this.getExecutionTicks()) < effect.getDelay()) {
        continue;
      }

      effect.apply(this.getExecutionImpactArea());
      this.getAppliedEffects().add(effect);
    }
}
}
```
```java
class de.gurkenlabs.litiengine.GameWindow$3 {
@Override
          public void windowGainedFocus(WindowEvent e) {
            Game.loop().setTickRate(Game.config().client().getMaxFps());
}@Override
          public void windowLostFocus(WindowEvent e) {
            if (Game.config().graphics().reduceFramesWhenNotFocused()) {
              Game.loop().setTickRate(NONE_FOCUS_MAX_FPS);
            }
}
}
```
```java
class de.gurkenlabs.litiengine.environment.EntitySpawner {
protected void spawnNewEntities() {
    if (this.getSpawnMode() != SpawnMode.CUSTOMSPAWNPOINTS && this.getSpawnPoints().isEmpty()) {
      return;
    }

    switch (this.getSpawnMode()) {
      case ALLSPAWNPOINTS:
        for (int i = 0; i < this.getSpawnPoints().size(); i++) {
          final int index = i;
          Game.loop()
              .perform(
                  this.getSpawnDelay() + this.getSpawnDelay() * i,
                  () -> this.spawn(this.getSpawnPoints().get(index), this.getSpawnAmount()));
        }
        break;
      case ONERANDOMSPAWNPOINT:
        this.spawn(Game.random().choose(this.getSpawnPoints()), this.getSpawnAmount());
        break;
      case RANDOMSPAWNPOINTS:
        for (int i = 0; i < this.getSpawnAmount(); i++) {
          Game.loop()
              .perform(
                  this.getSpawnDelay() + this.getSpawnDelay() * i,
                  () -> this.spawn(Game.random().choose(this.getSpawnPoints()), 1));
        }
        break;
      case CUSTOMSPAWNPOINTS:
        List<Spawnpoint> spawnPoints =
            this.customSpawnpoints != null
                ? this.customSpawnpoints.apply(this)
                : this.getCustomSpawnpoints();

        int index = 0;
        for (Spawnpoint spawn : spawnPoints) {
          Game.loop()
              .perform(
                  this.getSpawnDelay() + this.getSpawnDelay() * index, () -> this.spawn(spawn, 1));
          index++;
        }
        break;
      default:
        break;
    }
}
}
```
```java
class de.gurkenlabs.litiengine.tweening.TweenEngine {
@Override
  public void start() {
    Game.loop().attach(this);
}@Override
  public void terminate() {
    Game.loop().detach(this);
}
}
```
```java
class de.gurkenlabs.litiengine.gui.SpeechBubble {
public void hide() {
    Game.world().environment().removeRenderable(this);
    Game.loop().detach(this);
    if (activeSpeechBubbles.get(this.getEntity()) != null
        && activeSpeechBubbles.remove(this.getEntity()).equals(this)) {
      activeSpeechBubbles.remove(this.getEntity());
    }

    for (SpeechBubbleListener listener : this.listeners) {
      listener.hidden();
    }
}private SpeechBubble(
      final IEntity entity,
      final String text,
      @Nullable SpeechBubbleAppearance appearance,
      @Nullable Font font) {
    if (appearance == null) {
      this.appearance = DEFAULT_APPEARANCE;
    } else {
      this.appearance = appearance;
    }

    final SpeechBubble active = activeSpeechBubbles.get(entity);
    if (active != null) {
      active.hide();
    }
    this.setFont(font);

    this.textBoxWidth = (float) (entity.getWidth() * 4);
    this.entity = entity;

    this.currentText = text;
    this.currentTextDisplayTime = DISPLAYTIME_MIN + text.length() * DISPLAYTIME_PER_LETTER;

    this.lastTextDisplay = Game.time().now();
    this.createBubbleImage();
    entity.getEnvironment().add(this, RenderType.UI);
    Game.loop().attach(this);
    activeSpeechBubbles.put(entity, this);
}
}
```
```java
class de.gurkenlabs.litiengine.entities.Prop {
private void updateAnimationController() {
    IEntityAnimationController<?> controller = this.createAnimationController();
    this.getControllers().addController(controller);
    if (Game.world().environment() != null && Game.world().environment().isLoaded()) {
      Game.loop().attach(controller);
    }
}
}
```
```java
class de.gurkenlabs.litiengine.graphics.FreeFlightCamera {
public FreeFlightCamera(final Point2D focus) {
    this.setFocus(focus);
    this.velocity = DEFAULT_SCROLL_PIXELS_PER_SECOND;
    this.scrollPadding = DEFAULT_SCROLL_PADDING;
    this.setClampToMap(true);

    Game.loop().attach(this);
}private void handleFreeFlightCamera() {
    if (Game.world().environment() == null || Game.world().environment().getMap() == null) {
      return;
    }

    final Point2D mouseLocation = Input.mouse().getLocation();

    final double scrollSpeed =
        this.getVelocity()
            / (double) Game.loop().getTickRate()
            * Game.config().input().getMouseSensitivity();

    double x = this.getFocus().getX();
    double y = this.getFocus().getY();

    double deltaX = 0;
    if (mouseLocation.getX() < this.getScrollPadding()) {
      deltaX -= scrollSpeed;
    } else if (Game.window().getResolution().getWidth() - mouseLocation.getX()
        < this.getScrollPadding()) {
      deltaX += scrollSpeed;
    }

    double deltaY = 0;
    if (mouseLocation.getY() < this.getScrollPadding()) {
      deltaY -= scrollSpeed;
    } else if (Game.window().getResolution().getHeight() - mouseLocation.getY()
        < this.getScrollPadding()) {
      deltaY += scrollSpeed;
    }

    x += deltaX;
    y += deltaY;

    this.setFocus(new Point2D.Double(x, y));
}
}
```
```java
class de.gurkenlabs.litiengine.environment.Environment {
private static void dispose(final Collection<? extends IEntity> entities) {
    for (final IEntity entity : entities) {
      if (entity instanceof IUpdateable) {
        Game.loop().detach((IUpdateable) entity);
      }

      entity.detachControllers();
    }
}private static void loadUpdatableOrEmitterEntity(IEntity entity) {
    if (entity instanceof Emitter) {
      final Emitter emitter = (Emitter) entity;
      if (emitter.isActivateOnInit()) {
        emitter.activate();
      }
    } else if (entity instanceof IUpdateable) {
      Game.loop().attach((IUpdateable) entity);
    }
}private void unload(final IEntity entity) {
    // 1. remove from physics engine
    if (entity instanceof ICollisionEntity) {
      Game.physics().remove((ICollisionEntity) entity);
    }

    // 2. unregister from update
    if (entity instanceof IUpdateable) {
      Game.loop().detach((IUpdateable) entity);
    }

    if (entity instanceof IMobileEntity) {
      this.removeGravity((IMobileEntity) entity);
    }

    // 3. detach all controllers
    entity.detachControllers();

    if (entity instanceof Emitter) {
      Emitter em = (Emitter) entity;
      em.deactivate();
    }

    if (this.loaded && (entity instanceof LightSource || entity instanceof StaticShadow)) {
      this.updateLighting(entity);
    }

    entity.removed(this);
}
}
```
```java
class de.gurkenlabs.litiengine.graphics.animation.Animation {
@Override
  public void update() {
    // do nothing if the animation is not playing or the current keyframe is not finished
    if (!this.isPlaying()
        || Game.time().since(this.lastFrameUpdate) < this.getCurrentKeyFrame().getDuration()) {
      return;
    }

    // if we are not looping and the last keyframe is finished, we terminate the animation
    if (!this.isLooping() && this.isLastKeyFrame()) {
      this.terminate();
      return;
    }

    // make sure, we stay inside the keyframe list
    final int newFrameIndex =
        (this.getKeyframes().indexOf(this.currentFrame) + 1) % this.getKeyframes().size();
    final KeyFrame previousFrame = this.currentFrame;
    this.currentFrame = this.getKeyframes().get(newFrameIndex);

    for (KeyFrameListener listener : this.listeners) {
      listener.currentFrameChanged(previousFrame, this.currentFrame);
    }

    this.lastFrameUpdate = Game.loop().getTicks();
}public void restart() {
    this.currentFrame = this.firstFrame;
    this.lastFrameUpdate = Game.loop().getTicks();
}
}
```
```java
class de.gurkenlabs.litiengine.physics.MovementController {
@Override
  public void attach() {
    Game.loop().attach(this);
}private void handleForces() {
    // clean up forces
    this.activeForces.forEach(
        x -> {
          if (x.hasEnded()) {
            this.activeForces.remove(x);
          }
        });

    if (this.activeForces.isEmpty()) {
      return;
    }

    // disable turn-on-move for force handling
    boolean turn = this.getEntity().turnOnMove();
    this.getEntity().setTurnOnMove(false);
    try {
      double deltaX = 0;
      double deltaY = 0;
      for (final Force force : this.activeForces) {
        if (force.cancelOnReached() && force.hasReached(this.getEntity())) {
          force.end();
          continue;
        }

        final Point2D collisionBoxCenter = this.getEntity().getCollisionBoxCenter();
        final double angle =
            GeometricUtilities.calcRotationAngleInDegrees(collisionBoxCenter, force.getLocation());
        final double strength =
            Game.loop().getDeltaTime() * 0.001f * force.getStrength() * Game.loop().getTimeScale();
        deltaX += GeometricUtilities.getDeltaX(angle, strength);
        deltaY += GeometricUtilities.getDeltaY(angle, strength);
      }

      final Point2D target =
          new Point2D.Double(this.getEntity().getX() + deltaX, this.getEntity().getY() + deltaY);
      final boolean success = Game.physics().move(this.getEntity(), target);
      if (!success) {
        for (final Force force : this.activeForces) {
          if (force.cancelOnCollision()) {
            force.end();
          }
        }
      }
    } finally {
      this.getEntity().setTurnOnMove(turn);
    }
}@Override
  public void detach() {
    Game.loop().detach(this);
}public void handleMovement() {
    if (!this.isMovementAllowed()) {
      this.velocity = 0;
      return;
    }

    // max distance an entity can travel within one tick
    final double maxPixelsPerTick = this.getEntity().getTickVelocity();
    final double deltaTime = Game.loop().getDeltaTime() * Game.loop().getTimeScale();

    final double acceleration =
        this.getEntity().getAcceleration() == 0
            ? maxPixelsPerTick
            : deltaTime / this.getEntity().getAcceleration() * maxPixelsPerTick;
    final double deceleration =
        this.getEntity().getDeceleration() == 0
            ? this.getVelocity()
            : deltaTime / this.getEntity().getDeceleration() * maxPixelsPerTick;

    double dx = this.getDx();
    double dy = this.getDy();
    this.setDx(0);
    this.setDy(0);

    final double deltaVelocity =
        Math.min(Math.sqrt(Math.pow(dx, 2) + Math.pow(dy, 2)), acceleration);
    if (deltaVelocity != 0) {
      double newVelocity = this.getVelocity() + deltaVelocity;
      this.setVelocity(newVelocity);
    } else {
      final double newVelocity = Math.max(0, this.getVelocity() - deceleration);
      this.setVelocity(newVelocity);
      dx = GeometricUtilities.getDeltaX(this.moveAngle);
      dy = GeometricUtilities.getDeltaY(this.moveAngle);
    }

    if (this.getVelocity() == 0) {
      this.moveAngle = 0;
      return;
    }

    // actually move entity
    this.moveEntity(dx, dy);
}
}
```
```java
class de.gurkenlabs.litiengine.graphics.animation.AnimationController {
public void detach() {
    Game.loop().detach(this);
}public void attach() {
    Game.loop().attach(this);
}
}
```
```java
class de.gurkenlabs.litiengine.graphics.Camera {
@Override
  public void setZoom(final float targetZoom, final int delay) {
    if (delay == 0) {

      this.zoom = targetZoom;
      this.targetZoom = 0;
      this.zoomDelay = 0;
      this.zoomTick = 0;
      this.zoomStep = 0;

      final ZoomChangedEvent event = new ZoomChangedEvent(this, targetZoom);
      for (final ZoomChangedListener listener : this.zoomListeners) {
        listener.zoomChanged(event);
      }
    } else {
      this.zoomTick = Game.time().now();
      this.targetZoom = targetZoom;
      this.zoomDelay = delay;

      final double tickduration = 1000 / (double) Game.loop().getTickRate();
      final double tickAmount = delay / tickduration;
      final float totalDelta = this.targetZoom - this.zoom;
      this.zoomStep = tickAmount > 0 ? (float) (totalDelta / tickAmount) : totalDelta;
    }
}
}
```
```java
class de.gurkenlabs.litiengine.Game {
public static synchronized void init(String... args) {
    if (initialized) {
      log().log(Level.INFO, "The game has already been initialized.");
      return;
    }

    log.init();
    handleCommandLineArguments(args);

    config().load();
    Locale.setDefault(new Locale(config().client().getCountry(), config().client().getLanguage()));

    gameLoop = new GameLoop("Main Update Loop", config().client().getMaxFps());
    loop().attach(physics());
    loop().attach(world());

    // setup default exception handling for render and update loop
    setUncaughtExceptionHandler(
        new DefaultUncaughtExceptionHandler(config().client().exitOnError()));

    screenManager = new ScreenManager();
    gameWindow = new GameWindow();

    // initialize  the game window
    window().init();
    world.setCamera(new Camera());

    for (GameListener listener : gameListeners) {
      listener.initialized(args);
    }

    if (!isInNoGUIMode()) {
      window().getRenderComponent().onRendered(g -> metrics().render(g));

      graphics()
          .addEntityRenderedListener(
              e -> DebugRenderer.renderEntityDebugInfo(e.getGraphics(), e.getEntity()));

      window().getRenderComponent().onFpsChanged(fps -> metrics().setFramesPerSecond(fps));
      window()
          .setIcons(
              Arrays.asList(
                  Resources.images().get("liti-logo-x16.png"),
                  Resources.images().get("liti-logo-x20.png"),
                  Resources.images().get("liti-logo-x32.png"),
                  Resources.images().get("liti-logo-x48.png")));

      Input.keyboard()
          .onKeyTyped(
              KeyEvent.VK_PRINTSCREEN,
              key -> {
                // don't take a screenshot if a modifier is active
                if (key.getModifiers() != 0) {
                  return;
                }

                window().getRenderComponent().takeScreenshot();
              });
    }

    Runtime.getRuntime().addShutdownHook(new Thread(Game::terminate, "Shutdown"));

    initialized = true;
}
}
```
```java
class de.gurkenlabs.litiengine.entities.Creature {
protected void updateAnimationController() {
    IEntityAnimationController<?> controller = this.createAnimationController();
    this.getControllers().addController(controller);
    if (Game.world().environment() != null && Game.world().environment().isLoaded()) {
      Game.loop().attach(controller);
    }
}@Override
  public float getTickVelocity() {
    // pixels per ms multiplied by the passed ms
    // ensure that entities don't travel too far in case of lag
    return Math.min(Game.loop().getDeltaTime(), GameLoop.TICK_DELTATIME_LAG)
        * 0.001F
        * this.getVelocity().get()
        * Game.loop().getTimeScale();
}
}
```
Depth: 2
```java
class de.gurkenlabs.litiengine.environment.GameWorld {
public void clear() {
    this.unloadEnvironment();
    this.environments.clear();
    this.setCamera(null);
    Game.physics().clear();

    this.environmentListeners.clear();
    this.environmentLoadedListeners.clear();
    this.environmentUnloadedListeners.clear();

    this.listeners.clear();
    this.loadedListeners.clear();
    this.unloadedListeners.clear();
}@Nullable
  public Environment loadEnvironment(IMap map) {
    Environment env = this.getEnvironment(map);
    this.loadEnvironment(env);
    return env;
}@Nullable
  public Environment loadEnvironment(String mapName) {
    Environment env = this.getEnvironment(mapName);
    this.loadEnvironment(env);
    return env;
}
}
```
```java
class de.gurkenlabs.litiengine.GameWindow {
GameWindow() {
    this.hostControl = new JFrame();

    this.resolutionChangedListeners = new CopyOnWriteArrayList<>();

    this.renderCanvas = new RenderComponent(Game.config().graphics().getResolution());
    this.cursor = new MouseCursor();
    if (!Game.isInNoGUIMode()) {
      this.hostControl.setBackground(Color.BLACK);
      this.hostControl.add(this.renderCanvas);

      this.initializeEventListeners();

      this.hostControl.setTitle(Game.info().getTitle());
      this.hostControl.setDefaultCloseOperation(WindowConstants.DO_NOTHING_ON_CLOSE);
      initializeWindowEventListeners(this.hostControl);
    }
}
}
```
```java
class de.gurkenlabs.litiengine.GameTime {
public long sinceEnvironmentLoad() {
    return this.since(this.environmentLoaded);
}public long since(final long tick) {
    return toMilliseconds(Game.loop().getTicks() - tick);
}public long sinceGameStart() {
    return this.toMilliseconds(Game.loop().getTicks());
}
}
```
```java
class de.gurkenlabs.litiengine.abilities.effects.Effect {
protected void cease(final EffectApplication appliance) {
    // 1. cease the effect for all affected entities
    for (final ICombatEntity entity : appliance.getAffectedEntities()) {
      this.cease(entity);
    }

    // 2. apply follow up effects
    this.getFollowUpEffects().forEach(followUp -> followUp.apply(appliance.getImpactArea()));
}protected boolean hasEnded(final EffectApplication appliance) {
    final long effectDuration = Game.time().since(appliance.getAppliedTicks());
    return effectDuration > this.getDuration();
}
}
```
```java
class de.gurkenlabs.litiengine.abilities.effects.EffectApplication {
protected EffectApplication(final List<ICombatEntity> affectedEntities, final Shape impactArea) {
    this.applied = Game.time().now();
    this.affectedEntities = affectedEntities;
    this.impactArea = impactArea;
}
}
```
```java
class de.gurkenlabs.litiengine.entities.CombatEntity {
@Override
  public boolean wasHit(int timeSpan) {
    return Game.time().since(this.lastHit) < timeSpan;
}@Override
  public void hit(final int damage, @Nullable final Ability ability) {
    if (this.isDead()) {
      return;
    }

    if (!this.isIndestructible()) {
      this.getHitPoints().modifyBaseValue(new AttributeModifier<>(Modification.SUBTRACT, damage));
    }

    final EntityHitEvent event = new EntityHitEvent(this, ability, damage, this.isDead());

    for (final CombatEntityListener listener : this.listeners) {
      listener.hit(event);
    }

    for (final CombatEntityHitListener listener : this.hitListeners) {
      listener.hit(event);
    }

    if (this.isDead()) {
      this.fireDeathEvent();
      this.setCollision(false);
    }

    this.lastHit = Game.time().now();
}
}
```
```java
class de.gurkenlabs.litiengine.graphics.ImageEffect {
protected ImageEffect(final int ttl, final String name) {
    this.ttl = ttl;
    this.name = name;
    this.aliveTick = Game.time().now();
}@Override
  public long getAliveTime() {
    return Game.time().since(this.aliveTick);
}
}
```
```java
class de.gurkenlabs.litiengine.abilities.AbilityExecution {
AbilityExecution(final Ability ability) {
    this.appliedEffects = new CopyOnWriteArrayList<>();
    this.ability = ability;
    this.executionTicks = Game.time().now();
    this.impactArea = ability.calculateImpactArea();
    this.castLocation = ability.getExecutor().getCenter();
    Game.loop().attach(this);
}@Override
  public void update() {
    // if there a no effects to apply -> unregister this instance and we're done
    if (this.getAbility().getEffects().isEmpty()
        || this.getAbility().getEffects().size() == this.getAppliedEffects().size()) {
      Game.loop().detach(this);
      return;
    }

    // handle all effects from the ability that were not applied yet
    for (final Effect effect : this.getAbility().getEffects()) {
      // if the ability was not executed yet or the delay of the effect is not
      // yet reached
      if (this.getAppliedEffects().contains(effect)
          || Game.time().since(this.getExecutionTicks()) < effect.getDelay()) {
        continue;
      }

      effect.apply(this.getExecutionImpactArea());
      this.getAppliedEffects().add(effect);
    }
}
}
```
```java
class de.gurkenlabs.litiengine.tweening.TweenEngine {
@Override
  public void update() {
    for (final Tweenable target : this.getTweens().keySet()) {
      for (final Tween tween : this.getTweens().get(target).values()) {
        if (tween.hasStopped()) {
          continue;
        }
        final long elapsed = Game.time().since(tween.getStartTime());
        if (elapsed >= tween.getDuration()) {
          tween.stop();
          continue;
        }
        final float[] currentValues = new float[tween.getTargetValues().length];
        for (int i = 0; i < tween.getTargetValues().length; i++) {
          currentValues[i] =
              tween.getStartValues()[i]
                  + tween.getEquation().compute(elapsed / (float) tween.getDuration())
                      * (tween.getTargetValues()[i] - tween.getStartValues()[i]);
        }
        tween.getTarget().setTweenValues(tween.getType(), currentValues);
      }
    }
}
}
```
```java
class de.gurkenlabs.litiengine.gui.SpeechBubble {
public static SpeechBubble create(
      final IEntity entity, final String text, SpeechBubbleAppearance appearance, Font font) {
    return new SpeechBubble(entity, text, appearance, font);
}public static SpeechBubble create(final IEntity entity, final Font font, final String text) {
    SpeechBubbleAppearance app =
        new SpeechBubbleAppearance(
            DEFAULT_APPEARANCE.getForeColor(),
            DEFAULT_APPEARANCE.getBackgroundColor1(),
            DEFAULT_APPEARANCE.getBorderColor(),
            DEFAULT_APPEARANCE.getPadding());
    return new SpeechBubble(entity, text, app, font);
}public static SpeechBubble create(final IEntity entity, final String text) {
    return new SpeechBubble(entity, text, null, GuiProperties.getDefaultFont());
}@Override
  public void update() {
    if (this.currentText == null) {
      this.hide();
      return;
    }

    this.entityCenter = Game.world().camera().getViewportLocation(this.getEntity().getCenter());

    // old text was displayed long enough
    if (this.lastTextDisplay != 0
        && Game.time().since(this.lastTextDisplay) > this.currentTextDisplayTime) {
      this.currentText = null;
      this.lastTextDisplay = 0;
      return;
    }

    // display new text
    if (this.textIndex < this.currentText.length()
        && Game.time().since(this.lastCharPoll) > LETTER_WRITE_DELAY) {
      this.textIndex++;
      this.lastCharPoll = Game.time().now();
      if (this.typeSound != null) {
        Game.audio().playSound(this.typeSound, this.getEntity());
      }
    }

    // continue displaying currently displayed text
}private SpeechBubble(
      final IEntity entity,
      final String text,
      final Sound typeSound,
      SpeechBubbleAppearance appearance,
      Font font) {
    this(entity, text, appearance, font);
    this.typeSound = typeSound;
}private SpeechBubble(
      final IEntity entity,
      final String text,
      @Nullable SpeechBubbleAppearance appearance,
      @Nullable Font font) {
    if (appearance == null) {
      this.appearance = DEFAULT_APPEARANCE;
    } else {
      this.appearance = appearance;
    }

    final SpeechBubble active = activeSpeechBubbles.get(entity);
    if (active != null) {
      active.hide();
    }
    this.setFont(font);

    this.textBoxWidth = (float) (entity.getWidth() * 4);
    this.entity = entity;

    this.currentText = text;
    this.currentTextDisplayTime = DISPLAYTIME_MIN + text.length() * DISPLAYTIME_PER_LETTER;

    this.lastTextDisplay = Game.time().now();
    this.createBubbleImage();
    entity.getEnvironment().add(this, RenderType.UI);
    Game.loop().attach(this);
    activeSpeechBubbles.put(entity, this);
}
}
```
```java
class de.gurkenlabs.litiengine.gui.TextFieldComponent {
@Override
  public void render(final Graphics2D g) {
    super.render(g);
    g.setFont(this.getFont());
    final FontMetrics fm = g.getFontMetrics();

    if (this.isSelected() && Game.time().since(this.lastToggled) > this.flickerDelay) {
      this.cursorVisible = !this.cursorVisible;
      this.lastToggled = Game.time().now();
    }
    if (this.isSelected() && this.cursorVisible) {
      final Rectangle2D cursor =
          new Rectangle2D.Double(
              this.getX() + this.getTextX() + fm.stringWidth(this.getTextToRender(g)),
              this.getY() + this.getTextY(),
              this.getFont().getSize2D() * 3 / 5,
              this.getFont().getSize2D() * 1 / 5);
      g.setColor(this.getAppearance().getForeColor());
      g.fill(cursor);
    }
}
}
```
```java
class de.gurkenlabs.litiengine.entities.Prop {
public Prop(
      final Point2D location, @Nullable final String spritesheetName, final Material material) {
    super();
    this.rotation = Rotation.NONE;
    this.spritesheetName = spritesheetName;
    this.material = material;
    this.setLocation(location);
    this.updateAnimationController();
}public void setSpritesheetName(@Nullable final String spriteName) {
    this.spritesheetName = spriteName;
    this.updateAnimationController();
}
}
```
```java
class de.gurkenlabs.litiengine.tweening.Tween {
public Tween begin() {
    this.started = Game.time().now();
    this.stopped = false;
    return this;
}
}
```
```java
class de.gurkenlabs.litiengine.graphics.emitters.particles.Particle {
public void update(final Point2D emitterOrigin, final float updateRatio) {
    if (this.aliveTick == 0) {
      this.aliveTick = Game.time().now();
    }

    this.aliveTime = Game.time().since(this.aliveTick);
    if (this.timeToLiveReached()) {
      return;
    }

    if (this.colliding) {
      return;
    }

    if (this.getDeltaWidth() != 0) {
      this.width += this.getDeltaWidth() * updateRatio;
    }

    if (this.getDeltaHeight() != 0) {
      this.height += this.getDeltaHeight() * updateRatio;
    }

    if (this.getDeltaAngle() != 0) {
      this.angle += this.getDeltaAngle() * updateRatio;
    }

    // test for ray cast collision
    final float targetX = this.x + this.getVelocityX() * updateRatio;
    final float targetY = this.y + this.getVelocityY() * updateRatio;

    if (targetX == this.x && targetY == this.y) {
      return;
    }

    if (this.checkForCollision(emitterOrigin, targetX, targetY)) {
      return;
    }

    if (this.getVelocityX() != 0) {
      this.x = targetX;
    }

    if (this.getVelocityY() != 0) {
      this.y = targetY;
    }

    if (this.getAccelerationX() != 0) {
      this.velocityX += this.getAccelerationX() * updateRatio;
    }

    if (this.getAccelerationY() != 0) {
      this.velocityY += this.getAccelerationY() * updateRatio;
    }
}
}
```
```java
class de.gurkenlabs.litiengine.graphics.animation.Animation {
@Override
  public void start() {
    this.playing = true;
    if (this.getKeyframes().isEmpty()) {
      return;
    }

    this.restart();
}@Override
  public void update() {
    // do nothing if the animation is not playing or the current keyframe is not finished
    if (!this.isPlaying()
        || Game.time().since(this.lastFrameUpdate) < this.getCurrentKeyFrame().getDuration()) {
      return;
    }

    // if we are not looping and the last keyframe is finished, we terminate the animation
    if (!this.isLooping() && this.isLastKeyFrame()) {
      this.terminate();
      return;
    }

    // make sure, we stay inside the keyframe list
    final int newFrameIndex =
        (this.getKeyframes().indexOf(this.currentFrame) + 1) % this.getKeyframes().size();
    final KeyFrame previousFrame = this.currentFrame;
    this.currentFrame = this.getKeyframes().get(newFrameIndex);

    for (KeyFrameListener listener : this.listeners) {
      listener.currentFrameChanged(previousFrame, this.currentFrame);
    }

    this.lastFrameUpdate = Game.loop().getTicks();
}
}
```
```java
class de.gurkenlabs.litiengine.graphics.animation.AnimationController {
@Override
  public void update() {
    for (final Animation animation : this.getAll()) {
      animation.update();
    }

    if (this.getCurrent() != null && this.getCurrent().isPaused()) {
      return;
    }

    final boolean playbackFinished = this.getCurrent() != null && !this.getCurrent().isPlaying();
    if (playbackFinished) {
      for (final AnimationListener listener : this.listeners) {
        listener.finished(this.getCurrent());
      }
    }

    if (this.getCurrent() == null || playbackFinished) {
      if (this.getDefault() != null) {
        this.play(this.getDefault().getName());
      } else {
        this.currentAnimation = null;
      }
    }
}
}
```
```java
class de.gurkenlabs.litiengine.graphics.RenderComponent {
private void handleFade() {
    if (this.fadeOutStart != -1) {
      final long timePassed = Game.time().since(this.fadeOutStart);
      this.currentAlpha = MathUtilities.clamp(1 - timePassed / (float) this.fadeOutTime, 0, 1);
      if (this.currentAlpha == 0f) {
        this.fadeOutStart = -1;
        this.fadeOutTime = -1;
      }

      return;
    }

    if (this.fadeInStart != -1) {
      final long timePassed = Game.time().since(this.fadeInStart);
      this.currentAlpha = MathUtilities.clamp(timePassed / (float) this.fadeInTime, 0, 1);
      if (this.currentAlpha == 1f) {
        this.fadeInStart = -1;
        this.fadeInTime = -1;
        this.currentAlpha = Float.NaN;
      }
    }
}public void fadeOut(final int ms) {
    this.fadeInStart = -1;
    this.fadeInTime = -1;
    this.fadeOutStart = Game.time().now();
    this.fadeOutTime = ms;
}public void fadeIn(final int ms) {
    this.fadeOutStart = -1;
    this.fadeOutTime = -1;
    this.fadeInStart = Game.time().now();
    this.fadeInTime = ms;
}
}
```
```java
class de.gurkenlabs.litiengine.entities.Trigger {
private boolean activate(final IEntity activator, final int tar) {
    if (!this.isLoaded()
        || this.isOneTimeTrigger && this.isActivated
        || this.getActivationType() == TriggerActivation.COLLISION
            && activator != null
            && this.collisionActivated.contains(activator)) {
      return false;
    }

    if (this.getCooldown() > 0 && Game.time().since(this.lastActivation) < this.getCooldown()) {
      return false;
    }

    List<Integer> triggerTargets = this.getTargets(tar);

    final TriggerEvent te = new TriggerEvent(this, activator, triggerTargets);

    if (!this.checkActivationPredicates(te)) {
      return false;
    }

    this.isActivated = true;
    if (activator != null) {
      this.collisionActivated.add(activator);
    }

    // if we actually have a trigger target, we send the message to the target
    for (final int target : triggerTargets) {
      final IEntity entity = this.getEnvironment().get(target);
      if (entity == null) {
        log.log(
            Level.WARNING,
            "trigger [{0}] was activated, but the trigger target [{1}] could not be found on the environment",
            new Object[] {this, target});
        continue;
      }

      entity.sendMessage(this, this.message);
    }

    // also send the trigger event to all registered consumers
    for (final TriggerActivatedListener listener : this.activatedListeners) {
      listener.activated(te);
    }

    if (this.isOneTimeTrigger) {
      this.getEnvironment().remove(this);
    }

    this.lastActivation = Game.time().now();
    return true;
}
}
```
```java
class de.gurkenlabs.litiengine.graphics.Camera {
private boolean isShakeEffectActive() {
    return this.getShakeTick() != 0
        && Game.time().since(this.getShakeTick()) < this.getShakeDuration();
}@Override
  public void update() {
    if (Game.world().camera() != null && !Game.world().camera().equals(this)) {
      return;
    }

    if (this.targetZoom > 0) {
      if (Game.time().since(this.zoomTick) >= this.zoomDelay) {
        this.zoom = this.targetZoom;
        this.targetZoom = 0;
        this.zoomDelay = 0;
        this.zoomTick = 0;
        this.zoomStep = 0;
      } else {
        this.zoom += this.zoomStep;
      }

      final ZoomChangedEvent event = new ZoomChangedEvent(this, this.getZoom());
      for (final ZoomChangedListener listener : this.zoomListeners) {
        listener.zoomChanged(event);
      }
    }

    if (this.panTime > 0) {
      if (--this.panTime <= 0) {
        this.setFocus(this.targetFocus);
        this.targetFocus = null;
      } else {
        double diff = this.panTime / (this.panTime + 1.0);
        this.focus =
            new Point2D.Double(
                this.focus.getX() * diff + this.targetFocus.getX() * (1.0 - diff),
                this.focus.getY() * diff + this.targetFocus.getY() * (1.0 - diff));
      }
    }

    if (!this.isShakeEffectActive()) {
      this.shakeOffsetX = 0;
      this.shakeOffsetY = 0;
      return;
    }

    if (Game.time().since(this.lastShake) > this.shakeDelay) {
      this.shakeOffsetX = this.getShakeIntensity() * ThreadLocalRandom.current().nextGaussian();
      this.shakeOffsetY = this.getShakeIntensity() * ThreadLocalRandom.current().nextGaussian();
      this.lastShake = Game.time().now();
    }
}@Override
  public void setZoom(final float targetZoom, final int delay) {
    if (delay == 0) {

      this.zoom = targetZoom;
      this.targetZoom = 0;
      this.zoomDelay = 0;
      this.zoomTick = 0;
      this.zoomStep = 0;

      final ZoomChangedEvent event = new ZoomChangedEvent(this, targetZoom);
      for (final ZoomChangedListener listener : this.zoomListeners) {
        listener.zoomChanged(event);
      }
    } else {
      this.zoomTick = Game.time().now();
      this.targetZoom = targetZoom;
      this.zoomDelay = delay;

      final double tickduration = 1000 / (double) Game.loop().getTickRate();
      final double tickAmount = delay / tickduration;
      final float totalDelta = this.targetZoom - this.zoom;
      this.zoomStep = tickAmount > 0 ? (float) (totalDelta / tickAmount) : totalDelta;
    }
}@Override
  public void shake(final double intensity, final int delay, final int shakeDuration) {
    this.shakeTick = Game.time().now();
    this.shakeDelay = delay;
    this.shakeIntensity = intensity;
    this.shakeDuration = shakeDuration;
}
}
```
```java
class de.gurkenlabs.litiengine.entities.Creature {
public void setSpritesheetName(String spritesheetName) {
    if (this.spritesheetName != null && this.spritesheetName.equals(spritesheetName)) {
      return;
    }

    this.spritesheetName = spritesheetName;
    this.updateAnimationController();
}public boolean isIdle() {
    return Game.time().since(this.lastMoved) > IDLE_DELAY;
}@Override
  public void setLocation(final Point2D position) {
    if (this.isDead() || position == null) {
      return;
    }

    final Point2D oldLocation = this.getLocation();
    super.setLocation(position);

    if (Game.hasStarted() && this.isLoaded()) {
      this.lastMoved = Game.time().now();
      this.fireMovedEvent(
          new EntityMovedEvent(
              this, this.getX() - oldLocation.getX(), this.getY() - oldLocation.getY()));
    }
}
}
```
```java
class de.gurkenlabs.litiengine.gui.screens.ScreenManager {
public void display(final String screenName) {
    if (this.current() != null && this.current().getName().equalsIgnoreCase(screenName)) {
      log.log(
          Level.INFO,
          "Skipping displaying of screen {0} because it is already the current screen.",
          screenName);
      return;
    }

    if (this.screens.stream()
        .noneMatch(element -> element.getName().equalsIgnoreCase(screenName))) {
      log.log(
          Level.WARNING,
          "Could not display the screen {0} because there is no screen with the specified name.",
          screenName);
      return;
    }

    Screen screen = this.get(screenName);
    if (screen == null) {
      return;
    }

    this.display(screen);
}public void add(final Screen screen) {
    screen.setWidth(Game.window().getWidth());
    screen.setHeight(Game.window().getHeight());
    this.screens.add(screen);

    if (this.current() == null) {
      this.display(screen);
    }
}public void remove(Screen screen) {
    this.screens.remove(screen);
    if (this.current() == screen) {
      if (!this.screens.isEmpty()) {
        this.display(this.screens.get(0));
      } else {
        this.display((Screen) null);
      }
    }
}public void display(@Nullable final Screen screen) {
    if (Game.hasStarted() && Game.time().since(this.lastScreenChange) < this.getChangeCooldown()) {
      log.log(
          Level.INFO,
          "Skipping displaying of screen {0} because screen changing is currently on cooldown.",
          screen != null ? screen.getName() : "");
      return;
    }

    final Screen previous = this.current();
    if (previous != null) {
      previous.suspend();
    }

    if (screen != null && !this.screens.contains(screen)) {
      this.screens.add(screen);
    }

    this.currentScreen = screen;
    if (!Game.isInNoGUIMode() && this.current() != null) {
      this.current().prepare();
    }

    this.lastScreenChange = Game.loop().getTicks();

    final ScreenChangedEvent event = new ScreenChangedEvent(this.current(), previous);
    for (final ScreenChangedListener listener : this.screenChangedListeners) {
      listener.changed(event);
    }
}
}
```
```java
class de.gurkenlabs.litiengine.abilities.Ability {
public boolean isOnCooldown() {
    return (this.getCurrentExecution() != null
        && this.getCurrentExecution().getExecutionTicks() > 0
        && Game.time().since(this.getCurrentExecution().getExecutionTicks())
            < this.getAttributes().cooldown().get());
}public boolean isActive() {
    return this.getCurrentExecution() != null
        && Game.time().since(this.getCurrentExecution().getExecutionTicks())
            < this.getAttributes().duration().get();
}@Nullable
  public AbilityExecution cast() {
    if (!this.canCast()) {
      return null;
    }
    this.currentExecution = new AbilityExecution(this);

    for (final AbilityCastListener listener : this.abilityCastListeners) {
      listener.abilityCast(this.currentExecution);
    }

    return this.getCurrentExecution();
}public float getRemainingCooldownInSeconds() {
    if (this.getCurrentExecution() == null
        || this.getExecutor() == null
        || this.getExecutor().isDead()) {
      return 0;
    }

    // calculate cooldown in seconds
    return (float)
        (!this.canCast()
            ? (this.getAttributes().cooldown().get()
                    - Game.time().since(this.getCurrentExecution().getExecutionTicks()))
                * 0.001
            : 0);
}
}
```
```java
class de.gurkenlabs.litiengine.entities.EntityHitEvent {
EntityHitEvent(
      final ICombatEntity hitEntity,
      @Nullable final Ability ability,
      final int damage,
      final boolean kill) {
    super(hitEntity);
    this.executor = ability != null ? ability.getExecutor() : null;
    this.hitEntity = hitEntity;
    this.ability = ability;
    this.damage = damage;
    this.kill = kill;
    this.time = Game.time().now();
}
}
```
```java
class de.gurkenlabs.litiengine.graphics.emitters.Emitter {
public void delete() {
    this.deactivate();
    if (Game.world().environment() != null) {
      Game.world().environment().remove(this);
    }
}public void activate() {
    if (this.activated) {
      return;
    }

    this.activated = true;
    this.activationTick = Game.time().now();
    Game.loop().attach(this);
}@Override
  public void update() {
    if (this.isPaused()) {
      return;
    }

    // clear particles if the effect time to life is reached
    if (this.isFinished()) {
      for (EmitterFinishedListener listener : this.finishedListeners) {
        listener.finished(this);
      }

      this.delete();
      return;
    }

    final float updateRatio = (float) this.data().getUpdateRate() / Game.loop().getTickRate();
    for (final Particle p : this.getParticles().stream().collect(Collectors.toList())) {
      if (this.particleCanBeRemoved(p)) {
        // remove dead particles
        this.particles.remove(p);
        continue;
      }

      p.update(this.getOrigin(), updateRatio);
    }

    this.aliveTime = Game.time().since(this.activationTick);
    if ((this.data().getSpawnRate() == 0
        || Game.time().since(this.lastSpawn) >= this.data().getSpawnRate())) {
      this.lastSpawn = Game.time().now();
      this.spawnParticle();
    }
}
}
```
```java
class de.gurkenlabs.litiengine.GameLoop {
@Override
  public int perform(int delay, Runnable action) {
    final long d = Game.time().toTicks(delay);

    TimedAction a = new TimedAction(this.getTicks() + d, action);
    this.actions.add(a);

    return a.getId();
}
}
```
```java
class de.gurkenlabs.litiengine.environment.EntitySpawner {
protected boolean shouldSpawn() {
    return this.lastSpawnWave == 0
        || Game.time().since(this.lastSpawnWave) >= this.getSpawnInterval();
}@Override
  public void update() {
    if (!this.shouldSpawn()) {
      return;
    }

    this.spawnNewEntities();
    this.lastSpawnWave = Game.time().now();
}
}
```
```java
class de.gurkenlabs.litiengine.graphics.FreeFlightCamera {
@Override
  public void update() {
    this.handleFreeFlightCamera();
}public FreeFlightCamera(double x, double y) {
    this(new Point2D.Double(x, y));
}
}
```
```java
class de.gurkenlabs.litiengine.environment.Environment {
public void unload() {
    if (!this.loaded) {
      return;
    }

    // unregister all updatable entities from the current environment
    for (final IEntity entity : this.allEntities.values()) {
      this.unload(entity);
    }

    this.loaded = false;
    this.fireEvent(l -> l.unloaded(this));
}private static void loadUpdatableOrEmitterEntity(IEntity entity) {
    if (entity instanceof Emitter) {
      final Emitter emitter = (Emitter) entity;
      if (emitter.isActivateOnInit()) {
        emitter.activate();
      }
    } else if (entity instanceof IUpdateable) {
      Game.loop().attach((IUpdateable) entity);
    }
}public void clear() {
    Game.physics().clear();

    this.combatEntities.clear();
    this.mobileEntities.clear();
    this.gravityForces.clear();
    this.layerEntities.clear();
    this.entitiesByTag.clear();
    this.allEntities.clear();

    for (RenderType renderType : RenderType.values()) {
      this.miscEntities.get(renderType).clear();
      this.renderListeners.get(renderType).clear();
      this.renderables.get(renderType).clear();
    }

    dispose(this.allEntities.values());
    dispose(this.triggers);
    this.emitters.clear();
    this.colliders.clear();
    this.props.clear();
    this.creatures.clear();
    this.staticShadows.clear();
    this.combatEntities.clear();
    this.mobileEntities.clear();
    this.lightSources.clear();
    this.spawnPoints.clear();
    this.soundSources.clear();
    this.mapAreas.clear();
    this.triggers.clear();

    this.ambientLight = null;
    this.staticShadowLayer = null;

    for (Map<Integer, IEntity> type : this.miscEntities.values()) {
      type.clear();
    }

    this.initialized = false;

    this.fireEvent(l -> l.cleared(this));
}private void load(final IEntity entity) {
    // an entity can only exist on one environment at a time, so remove it from the current one
    if (entity.getEnvironment() != null) {
      entity.getEnvironment().remove(entity);
    }

    // 1. add to physics engine
    loadPhysicsEntity(entity);

    // 2. register for update or activate
    loadUpdatableOrEmitterEntity(entity);

    // 3. if a gravity is defined, add a gravity force to the entity
    if (entity instanceof IMobileEntity && this.getGravity() != 0) {
      this.addGravityForce((IMobileEntity) entity);
    }

    // 4. attach all controllers
    entity.attachControllers();

    if (this.loaded && (entity instanceof LightSource || entity instanceof StaticShadow)) {
      this.updateLighting(entity);
    }

    entity.loaded(this);
}private void unload(final IEntity entity) {
    // 1. remove from physics engine
    if (entity instanceof ICollisionEntity) {
      Game.physics().remove((ICollisionEntity) entity);
    }

    // 2. unregister from update
    if (entity instanceof IUpdateable) {
      Game.loop().detach((IUpdateable) entity);
    }

    if (entity instanceof IMobileEntity) {
      this.removeGravity((IMobileEntity) entity);
    }

    // 3. detach all controllers
    entity.detachControllers();

    if (entity instanceof Emitter) {
      Emitter em = (Emitter) entity;
      em.deactivate();
    }

    if (this.loaded && (entity instanceof LightSource || entity instanceof StaticShadow)) {
      this.updateLighting(entity);
    }

    entity.removed(this);
}public void remove(final IEntity entity) {
    if (entity == null) {
      return;
    }

    this.allEntities.remove(entity.getMapId());
    Iterator<List<IEntity>> iter = this.layerEntities.values().iterator();
    while (iter.hasNext()) {
      List<IEntity> layer = iter.next();
      if (layer.remove(entity) && layer.isEmpty()) {
        iter.remove();
      }
    }
    if (this.miscEntities.get(entity.getRenderType()) != null) {
      this.miscEntities.get(entity.getRenderType()).values().remove(entity);
    }

    for (String tag : entity.getTags()) {
      if (this.getEntitiesByTag().containsKey(tag)) {
        this.getEntitiesByTag().get(tag).remove(entity);

        if (this.getEntitiesByTag().get(tag).isEmpty()) {
          this.getEntitiesByTag().remove(tag);
        }
      }
    }

    if (entity instanceof Emitter) {
      Emitter emitter = (Emitter) entity;
      this.removeEmitter(emitter);
    }

    if (entity instanceof MapArea) {
      this.mapAreas.remove(entity);
    }

    if (entity instanceof Prop) {
      this.props.remove(entity);
    }

    if (entity instanceof Creature) {
      this.creatures.remove(entity);
    }

    if (entity instanceof CollisionBox) {
      this.colliders.remove(entity);
      this.staticShadows.removeIf(x -> x.getOrigin() != null && x.getOrigin().equals(entity));
    }

    if (entity instanceof LightSource) {
      this.lightSources.remove(entity);
      this.updateLighting(entity);
    }

    if (entity instanceof Trigger) {
      this.triggers.remove(entity);
    }

    if (entity instanceof Spawnpoint) {
      this.spawnPoints.remove(entity);
    }
    if (entity instanceof SoundSource) {
      this.soundSources.remove(entity);
    }

    if (entity instanceof StaticShadow) {
      this.staticShadows.remove(entity);
      this.updateLighting(entity);
    }

    if (entity instanceof IMobileEntity) {
      this.mobileEntities.values().remove(entity);
    }

    if (entity instanceof ICombatEntity) {
      this.combatEntities.values().remove(entity);
    }

    this.unload(entity);

    this.fireEntityEvent(l -> l.entityRemoved(entity));
}
}
```
```java
class de.gurkenlabs.litiengine.physics.MovementController {
@Override
  public void update() {
    this.handleForces();
    this.handleMovement();
}
}
```
```java
class de.gurkenlabs.litiengine.Game {
static synchronized void terminate() {
    if (!initialized) {
      return;
    }

    hasStarted = false;
    initialized = false;

    config().save();
    gameLoop.terminate();
    tweenEngine.terminate();
    soundEngine.terminate();

    world().clear();

    for (final GameListener listener : gameListeners) {
      try {
        listener.terminated();
      } catch (Exception e) {
        log().log(Level.WARNING, "game listener threw an exception during shutdown", e);
      }
    }

    gameLoop = null;
    screenManager = null;
    gameWindow = null;
}public static synchronized void start() {
    if (!initialized) {
      throw new IllegalStateException(
          "The game cannot be started without being first initialized. Call Game.init(...) before Game.start().");
    }

    gameLoop.start();
    tweenEngine.start();
    soundEngine.start();

    for (final GameListener listener : gameListeners) {
      listener.started();
    }

    hasStarted = true;
}public static synchronized void init(String... args) {
    if (initialized) {
      log().log(Level.INFO, "The game has already been initialized.");
      return;
    }

    log.init();
    handleCommandLineArguments(args);

    config().load();
    Locale.setDefault(new Locale(config().client().getCountry(), config().client().getLanguage()));

    gameLoop = new GameLoop("Main Update Loop", config().client().getMaxFps());
    loop().attach(physics());
    loop().attach(world());

    // setup default exception handling for render and update loop
    setUncaughtExceptionHandler(
        new DefaultUncaughtExceptionHandler(config().client().exitOnError()));

    screenManager = new ScreenManager();
    gameWindow = new GameWindow();

    // initialize  the game window
    window().init();
    world.setCamera(new Camera());

    for (GameListener listener : gameListeners) {
      listener.initialized(args);
    }

    if (!isInNoGUIMode()) {
      window().getRenderComponent().onRendered(g -> metrics().render(g));

      graphics()
          .addEntityRenderedListener(
              e -> DebugRenderer.renderEntityDebugInfo(e.getGraphics(), e.getEntity()));

      window().getRenderComponent().onFpsChanged(fps -> metrics().setFramesPerSecond(fps));
      window()
          .setIcons(
              Arrays.asList(
                  Resources.images().get("liti-logo-x16.png"),
                  Resources.images().get("liti-logo-x20.png"),
                  Resources.images().get("liti-logo-x32.png"),
                  Resources.images().get("liti-logo-x48.png")));

      Input.keyboard()
          .onKeyTyped(
              KeyEvent.VK_PRINTSCREEN,
              key -> {
                // don't take a screenshot if a modifier is active
                if (key.getModifiers() != 0) {
                  return;
                }

                window().getRenderComponent().takeScreenshot();
              });
    }

    Runtime.getRuntime().addShutdownHook(new Thread(Game::terminate, "Shutdown"));

    initialized = true;
}
}
```


Response Format:
Provide the answer in **XML format** as follows:

#### If the method **cannot** return `null` at the specific call site:
```xml
<response>
  <reason><![CDATA[EXPLAIN WHY THE INVOCATION Game.loop() RESULT CANNOT BE NULL.]]></reason>
  <value>NO</value>
</response>

#### If the method can return null at the specific call site:
<response>
  <reason><![CDATA[EXPLAIN WHY THE INVOCATION Game.loop() RESULT CAN BE NULL.]]></reason>
  <value>YES</value>
</response>

#### If you are unsure or If there are any methods that directly or indirectly affect the return value and are not fully disclosed, request their declarations first, in the following format:
<response>
  <reason><![CDATA[EXPLAIN WHY THIS METHOD DECLARATION IS NECESSARY AND WHY YOU CANNOT MAKE A CONFIDENT DECISION WITHOUT IT]]></reason>
  <success>false</success>
  <methods>
    <method>methodName</method>
  </methods>
</response>

Additional Notes:
Be precise in your reasoning.
If a method’s return value depends on another method not provided, request its declaration before making a conclusion.
If the method can return null in this case but not in others, explain why it happens specifically for this call.

---ChatGPT.sendRequestToOpenAI---
Retrieving response from cache
---Response.<init>---
Creating Response:
```xml
<response>
  <reason><![CDATA[The method `Game.loop()` returns the static field `gameLoop`, which is initialized in the `Game.init(String... args)` method. In this method, a new `GameLoop` object is instantiated and assigned to `gameLoop`. Since `init()` must be called before `start()`, which is implied by the requirement of initializing the game, the `gameLoop` is guaranteed to be non-null during the lifetime of the game execution where `Game.loop()` is called. The absence of any code that could set `gameLoop` to null after its initialization ensures that `Game.loop()` cannot return null.]]></reason>
  <value>NO</value>
</response>
```
---Response.<init>---
Response created:
Disagreement: The method `Game.loop()` returns the static field `gameLoop`, which is initialized in the `Game.init(String... args)` method. In this method, a new `GameLoop` object is instantiated and assigned to `gameLoop`. Since `init()` must be called before `start()`, which is implied by the requirement of initializing the game, the `gameLoop` is guaranteed to be non-null during the lifetime of the game execution where `Game.loop()` is called. The absence of any code that could set `gameLoop` to null after its initialization ensures that `Game.loop()` cannot return null.
---AdvancedNullAwayCodeFix.resolveMethodDereferenceError---
Method is not returning nullable on call site. Injecting suppression annotation.
---AdvancedNullAwayCodeFix.constructCastToNonnullChange---
Constructing cast to nonnull change for reason: The method `Game.loop()` returns the static field `gameLoop`, which is initialized in the `Game.init(String... args)` method. In this method, a new `GameLoop` object is instantiated and assigned to `gameLoop`. Since `init()` must be called before `start()`, which is implied by the requirement of initializing the game, the `gameLoop` is guaranteed to be non-null during the lifetime of the game execution where `Game.loop()` is called. The absence of any code that could set `gameLoop` to null after its initialization ensures that `Game.loop()` cannot return null.
---ChatGPT.ask---
Asking ChatGPT:
For the reason you mentioned earlier:

"The method `Game.loop()` returns the static field `gameLoop`, which is initialized in the `Game.init(String... args)` method. In this method, a new `GameLoop` object is instantiated and assigned to `gameLoop`. Since `init()` must be called before `start()`, which is implied by the requirement of initializing the game, the `gameLoop` is guaranteed to be non-null during the lifetime of the game execution where `Game.loop()` is called. The absence of any code that could set `gameLoop` to null after its initialization ensures that `Game.loop()` cannot return null."

in the method below, the expression Game.loop() is not nullable at the point it is used.

```java
@Override
  public void update() {
    // if there a no effects to apply -> unregister this instance and we're done
    if (this.getAbility().getEffects().isEmpty()
        || this.getAbility().getEffects().size() == this.getAppliedEffects().size()) {
      Game.loop().detach(this);
      return;
    }

    // handle all effects from the ability that were not applied yet
    for (final Effect effect : this.getAbility().getEffects()) {
      // if the ability was not executed yet or the delay of the effect is not
      // yet reached
      if (this.getAppliedEffects().contains(effect)
          || Game.time().since(this.getExecutionTicks()) < effect.getDelay()) {
        continue;
      }

      effect.apply(this.getExecutionImpactArea());
      this.getAppliedEffects().add(effect);
    }
}
```
Please Summarize the reason in max 5 words and rewrite the method so that at the line "      Game.loop().detach(this);", at the occurrence of: "Game.loop()" is replaced with `NullabilityUtil.castToNonnull(Game.loop(), summary of reason)`
Replace "REASON" with the exact reason summary I provide to you (maximum 5 words), not with a generic explanation like "checked to be nonnull".
see the example below, for expression `foo.getBar()`, to wrap it with `NullabilityUtil.castToNonnull(foo.getBar(), "reason")`.

```java
public t(){
    String l = foo.getBar();
}
```

will be:
```java
public t(){
    String l = NullabilityUtil.castToNonnull(foo.getBar(), "checked to be nonnull");
}
```

### Instructions:

Do not import any additional classes.

Do not add Java comments.

Only modify relevant lines as required.

Return only the modified method wrapped in the XML format shown below.

Place the Java code inside the <code> tag using a CDATA block with ```java formatting.

Just give me the fixed code snippet in XML format in <response> tag like the example below. I will apply the fix to my codebase. Do not import any additional libraries or classes or add java comments. If you can provide the fixed code snippet, please provide it in the following format and place the code snippet in the <code> tag within ```java block.
<response>
  <success>true</success>
  <code><![CDATA[
  ```java
  Your fixed code snippet here
  ```
    ]]>
  </code>
</response>

---ChatGPT.sendRequestToOpenAI---
Sending request to OpenAI...
---ChatGPT.sendRequestToOpenAI---
Response received from OpenAI.
---Response.<init>---
Creating Response:
<response>
  <success>true</success>
  <code><![CDATA[
  ```java
@Override
  public void update() {
    if (this.getAbility().getEffects().isEmpty()
        || this.getAbility().getEffects().size() == this.getAppliedEffects().size()) {
      NullabilityUtil.castToNonnull(Game.loop(), "cannot return null").detach(this);
      return;
    }

    for (final Effect effect : this.getAbility().getEffects()) {
      if (this.getAppliedEffects().contains(effect)
          || Game.time().since(this.getExecutionTicks()) < effect.getDelay()) {
        continue;
      }

      effect.apply(this.getExecutionImpactArea());
      this.getAppliedEffects().add(effect);
    }
}
  ```
    ]]>
  </code>
</response>
---Response.<init>---
Response created:
@Override
  public void update() {
    if (this.getAbility().getEffects().isEmpty()
        || this.getAbility().getEffects().size() == this.getAppliedEffects().size()) {
      NullabilityUtil.castToNonnull(Game.loop(), "cannot return null").detach(this);
      return;
    }

    for (final Effect effect : this.getAbility().getEffects()) {
      if (this.getAppliedEffects().contains(effect)
          || Game.time().since(this.getExecutionTicks()) < effect.getDelay()) {
        continue;
      }

      effect.apply(this.getExecutionImpactArea());
      this.getAppliedEffects().add(effect);
    }
}
---ChatGPT.fixDereferenceByAddingCastToNonnull---
Fixing the error by adding castToNonnull
---AdvancedNullAwayCodeFix.fixTriggeredErrorsForLocation---
Resolving unresolvable error for triggered error: Type='DEREFERENCE_NULLABLE', message='dereferenced expression Game.loop() is @Nullable'
/home/nima/Developer/nullness-benchmarks/litiengine/src/de/gurkenlabs/litiengine/physics/MovementController.java:97
    final double deltaTime = Game.loop().getDeltaTime() * Game.loop().getTimeScale();
---AdvancedNullAwayCodeFix.fix---
Fixing error: Type='DEREFERENCE_NULLABLE', message='dereferenced expression Game.loop() is @Nullable'
/home/nima/Developer/nullness-benchmarks/litiengine/src/de/gurkenlabs/litiengine/physics/MovementController.java:97
    final double deltaTime = Game.loop().getDeltaTime() * Game.loop().getTimeScale();
---AdvancedNullAwayCodeFix.resolveDereferenceError---
Resolving dereference error: Type='DEREFERENCE_NULLABLE', message='dereferenced expression Game.loop() is @Nullable'
/home/nima/Developer/nullness-benchmarks/litiengine/src/de/gurkenlabs/litiengine/physics/MovementController.java:97
    final double deltaTime = Game.loop().getDeltaTime() * Game.loop().getTimeScale();
---AdvancedNullAwayCodeFix.resolveDereferenceError---
Checking nullability possibility at error point
---ChatGPT.checkNullabilityPossibilityAtErrorPoint---
Asking if the expression can be null at error point point
---ChatGPT.ask---
Asking ChatGPT:
In the method below, is there a possibility that the expression "Game.loop()" at line "final double deltaTime = Game.loop().getDeltaTime() * Game.loop().getTimeScale();" is null?
public void handleMovement() {
    if (!this.isMovementAllowed()) {
      this.velocity = 0;
      return;
    }

    // max distance an entity can travel within one tick
    final double maxPixelsPerTick = this.getEntity().getTickVelocity();
    final double deltaTime = Game.loop().getDeltaTime() * Game.loop().getTimeScale();

    final double acceleration =
        this.getEntity().getAcceleration() == 0
            ? maxPixelsPerTick
            : deltaTime / this.getEntity().getAcceleration() * maxPixelsPerTick;
    final double deceleration =
        this.getEntity().getDeceleration() == 0
            ? this.getVelocity()
            : deltaTime / this.getEntity().getDeceleration() * maxPixelsPerTick;

    double dx = this.getDx();
    double dy = this.getDy();
    this.setDx(0);
    this.setDy(0);

    final double deltaVelocity =
        Math.min(Math.sqrt(Math.pow(dx, 2) + Math.pow(dy, 2)), acceleration);
    if (deltaVelocity != 0) {
      double newVelocity = this.getVelocity() + deltaVelocity;
      this.setVelocity(newVelocity);
    } else {
      final double newVelocity = Math.max(0, this.getVelocity() - deceleration);
      this.setVelocity(newVelocity);
      dx = GeometricUtilities.getDeltaX(this.moveAngle);
      dy = GeometricUtilities.getDeltaY(this.moveAngle);
    }

    if (this.getVelocity() == 0) {
      this.moveAngle = 0;
      return;
    }

    // actually move entity
    this.moveEntity(dx, dy);
}
Give a single-word answer in XML format. If it is possible for the expression to be null, respond with:
```xml
<response>
    <reason><![CDATA[YOUR REASON]]></reason>
    <value>YES</value>
</response>
```
If it is not possible for the expression to be null, respond with:
```xml
<response>
    <reason><![CDATA[YOUR REASON]]></reason>
    <value>NO</value>
</response>
```
If you are unsure or need more information, respond with where you can ask for more details or what specific information you need.

If additional information is required, list each request inside a `<request>` tag. If no additional information is needed, omit the `<requests>` section.

Respond with:
```xml
<response>
    <reason><![CDATA[YOUR REASON]]></reason>
    <value>UNKNOWN</value>
    <!-- Include <requests> only if additional information is needed -->
    <requests>
        <request><![CDATA[YOUR REQUEST 1]]></request>
        <request><![CDATA[YOUR REQUEST 2]]></request>
    </requests>
</response>
```
---ChatGPT.sendRequestToOpenAI---
Sending request to OpenAI...
---ChatGPT.sendRequestToOpenAI---
Response received from OpenAI.
---Response.<init>---
Creating Response:
```xml
<response>
    <reason><![CDATA[Without additional context or details about the implementation of the `Game.loop()` method, it is unclear whether it could return a null value, which would determine if `getDeltaTime()` and `getTimeScale()` can be called safely.]]></reason>
    <value>UNKNOWN</value>
    <requests>
        <request><![CDATA[Provide the implementation or specification of the `Game.loop()` method.]]></request>
        <request><![CDATA[Clarify if there are any conditions or checks ensuring that `Game.loop()` never returns null.]]></request>
    </requests>
</response>
```
---Response.<init>---
Response created:
Unknown: Without additional context or details about the implementation of the `Game.loop()` method, it is unclear whether it could return a null value, which would determine if `getDeltaTime()` and `getTimeScale()` can be called safely.
---AdvancedNullAwayCodeFix.resolveMethodDereferenceError---
Resolving method dereference error.
---AdvancedNullAwayCodeFix.resolveMethodDereferenceError---
Method is in annotated package. Checking if the method is returning nullable.
---AdvancedNullAwayCodeFix.investigateMethodReturnNullability---
Checking if the method is returning nullable.
---ChatGPT.checkIfMethodIsReturningNullable---
Asking if the method is returning nullable: loop()
---ChatGPT.ask---
Asking ChatGPT:
In the method below, is there a possibility that the method returns null based only on its body? Consider the following points:

- The method may have multiple return paths; consider all return statements.
- If the method calls another method, do not assume its return value unless its full declaration is provided. Request its declaration if needed.
- The method may throw an exception instead of returning null. An exception path should not be considered a null return.
- Ensure you request the declarations of any methods whose return values directly or indirectly impact this method’s return value before making a conclusion.
- Carefully analyze all conditions and prior operations that may guarantee a non-null return value.

@Nullable public static IGameLoop loop() {
    return gameLoop;
}

Here are the method definitions in addition to the method inquired:

Depth: 0
```java
class de.gurkenlabs.litiengine.Game {
@Nullable public static IGameLoop loop() {
    return gameLoop;
}
}
```


Response Format:
Provide the answer in **XML format** as follows:

#### If the method **cannot** return `null`:
```xml
<response>
  <reason><![CDATA[EXPLAIN WHY THE METHOD CANNOT RETURN NULL]]></reason>
  <value>NO</value>
</response>
```

#### If the method can return null:
```xml
<response>
  <reason><![CDATA[EXPLAIN WHY THE METHOD CAN RETURN NULL]]></reason>
  <value>YES</value>
</response>
```

#### If you are unsure or need more information, respond with where you can ask for more details or what specific information you need.

#### If you are unsure or If there are any methods that directly or indirectly affect the return value and are not fully disclosed, request their declarations first, in the following format:
<response>
  <reason><![CDATA[YOUR REASON]]></reason>
  <value>UNKNOWN</value>
  <methods>
    <method>methodName</method>
  </methods>
</response>

If additional information is required other than method declaration, list each request inside a `<request>` tag. If no additional information is needed, omit the `<requests>` section.

Respond with:
```xml
<response>
    <reason><![CDATA[YOUR REASON]]></reason>
    <value>UNKNOWN</value>
    <!-- Include <requests> only if additional information is needed -->
    <requests>
        <request><![CDATA[YOUR REQUEST 1]]></request>
        <request><![CDATA[YOUR REQUEST 2]]></request>
    </requests>
</response>
```

Additional Notes:
Be precise in your reasoning.
If a method’s return value depends on another method not provided, request its declaration before making a conclusion.
If the method can return null in some cases but not others, explain under what conditions it can happen.

---ChatGPT.sendRequestToOpenAI---
Retrieving response from cache
---Response.<init>---
Creating Response:
```xml
<response>
  <reason><![CDATA[The method `loop` returns the variable `gameLoop`. Without the initialization or assignment details of `gameLoop`, it's unclear whether it can be null. The possibility of `gameLoop` being uninitialized or set to null elsewhere in the program means `loop` could potentially return null. Further information on `gameLoop` is required.]]></reason>
  <value>UNKNOWN</value>
  <requests>
    <request><![CDATA[Please provide the declaration and initialization of the variable `gameLoop` in the class `de.gurkenlabs.litiengine.Game`.]]></request>
  </requests>
</response>
```
---Response.<init>---
Response created:
Unknown: The method `loop` returns the variable `gameLoop`. Without the initialization or assignment details of `gameLoop`, it's unclear whether it can be null. The possibility of `gameLoop` being uninitialized or set to null elsewhere in the program means `loop` could potentially return null. Further information on `gameLoop` is required.
---AdvancedNullAwayCodeFix.investigateMethodReturnNullability---
Could not determine the nullability and model did not ask for any method.
---ChatGPT.checkIfMethodIsReturningNullableOnCallSite---
Asking if the method is returning nullable on the call site: Game.loop()
---ChatGPT.ask---
Asking ChatGPT:
In the method below, is there a possibility that the method returns null at the given call site?

```java
@Nullable public static IGameLoop loop() {
    return gameLoop;
}
```

## Guidelines:
- The method may have multiple return paths; consider all return statements.
- If the method calls another method, do not assume its return value unless its full declaration is provided. Request its declaration if needed.
- The method may throw an exception instead of returning null. An exception path should not be considered a null return.
- Ensure you request the declarations of any methods whose return values directly or indirectly impact this method’s return value before making a conclusion.
- If the method returns a value that is determined by a parameter, evaluate based on the actual argument at the given call site.
- Analyze based only on the specific invocation provided. Do not generalize to all possible inputs.- If the return value is guaranteed to be non-null at the call site, the answer should be a definitive NO.
- Do not generalize based on all possible inputs—your answer must be based only on the given invocation.
- Focus only on the given call site, not all possible invocations.

### call site:
Game.loop()

Here are the method definitions and the call chain for this method, showing the sequence of calls from the method to its callers at each depth level:

Depth: 0
```java
class de.gurkenlabs.litiengine.Game {
@Nullable public static IGameLoop loop() {
    return gameLoop;
}
}
```
Depth: 1
```java
class de.gurkenlabs.litiengine.environment.GameWorld {
public void loadEnvironment(@Nullable final Environment env) {
    Lock lock = Game.loop().getLock();
    lock.lock();
    try {
      unloadEnvironment();
      this.environment = env;
      if (env != null) {
        this.addEnvironment(env);

        if (env.getGravity() == 0 && this.gravity() != 0) {
          env.setGravity(this.gravity());
        }

        env.load();
        for (final EnvironmentLoadedListener listener : this.loadedListeners) {
          listener.loaded(env);
        }

        // call map specific listeners
        String mapName = getMapName(env);
        if (mapName != null && this.environmentLoadedListeners.containsKey(mapName)) {

          // for the default camera we center the camera on the environment
          if (this.camera().getClass().equals(Camera.class)) {
            camera().setFocus(env.getCenter());
          }

          for (EnvironmentLoadedListener listener : this.environmentLoadedListeners.get(mapName)) {
            listener.loaded(env);
          }
        }
      }
    } finally {
      lock.unlock();
    }
}public void setCamera(@Nullable final ICamera cam) {
    if (this.camera() != null) {
      Game.loop().detach(camera);
    }

    camera = cam;

    if (cam != null && !Game.isInNoGUIMode()) {
      Game.loop().attach(cam);
      cam.updateFocus();
    }
}
}
```
```java
class de.gurkenlabs.litiengine.entities.behavior.EntityNavigator {
public EntityNavigator(final IMobileEntity entity, final PathFinder pathFinder) {
    this.cancelNavigationConditions = new CopyOnWriteArrayList<>();
    this.listeners = new CopyOnWriteArrayList<>();
    this.entity = entity;
    this.pathFinder = pathFinder;
    this.setAcceptableError(DEFAULT_ACCEPTABLE_ERROR);
    Game.loop().attach(this);
}
}
```
```java
class de.gurkenlabs.litiengine.GameWindow {
private static void initializeWindowEventListeners(Window window) {

    window.addWindowStateListener(
        e -> {
          if (e.getNewState() == Frame.ICONIFIED) {
            Game.loop().setTickRate(ICONIFIED_MAX_FPS);
          } else {
            Game.loop().setTickRate(Game.config().client().getMaxFps());
          }
        });

    window.addWindowFocusListener(
        new WindowFocusListener() {
          @Override
          public void windowLostFocus(WindowEvent e) {
            if (Game.config().graphics().reduceFramesWhenNotFocused()) {
              Game.loop().setTickRate(NONE_FOCUS_MAX_FPS);
            }
          }

          @Override
          public void windowGainedFocus(WindowEvent e) {
            Game.loop().setTickRate(Game.config().client().getMaxFps());
          }
        });

    window.addWindowListener(
        new WindowAdapter() {
          @Override
          public void windowClosing(final WindowEvent event) {
            Game.exit();
          }
        });
}
}
```
```java
class de.gurkenlabs.litiengine.gui.screens.ScreenManager {
public void display(@Nullable final Screen screen) {
    if (Game.hasStarted() && Game.time().since(this.lastScreenChange) < this.getChangeCooldown()) {
      log.log(
          Level.INFO,
          "Skipping displaying of screen {0} because screen changing is currently on cooldown.",
          screen != null ? screen.getName() : "");
      return;
    }

    final Screen previous = this.current();
    if (previous != null) {
      previous.suspend();
    }

    if (screen != null && !this.screens.contains(screen)) {
      this.screens.add(screen);
    }

    this.currentScreen = screen;
    if (!Game.isInNoGUIMode() && this.current() != null) {
      this.current().prepare();
    }

    this.lastScreenChange = Game.loop().getTicks();

    final ScreenChangedEvent event = new ScreenChangedEvent(this.current(), previous);
    for (final ScreenChangedListener listener : this.screenChangedListeners) {
      listener.changed(event);
    }
}
}
```
```java
class de.gurkenlabs.litiengine.abilities.effects.Effect {
@Override
  public void update() {

    for (final Iterator<EffectApplication> iterator = this.getActiveAppliances().iterator();
        iterator.hasNext(); ) {
      final EffectApplication appliance = iterator.next();
      // if the effect duration is reached
      if (this.hasEnded(appliance)) {

        iterator.remove();
        this.cease(appliance);
      }
    }

    // 4. unregister if all appliances are finished
    if (this.getActiveAppliances().isEmpty()) {
      Game.loop().detach(this);
    }
}public void apply(final Shape impactArea) {
    final List<ICombatEntity> affected = this.lookForAffectedEntities(impactArea);
    for (final ICombatEntity affectedEntity : affected) {
      this.apply(affectedEntity);
    }

    this.appliances.add(new EffectApplication(affected, impactArea));

    // if it is the first appliance -> register for update
    if (this.appliances.size() == 1) {
      Game.loop().attach(this);
    }
}
}
```
```java
class de.gurkenlabs.litiengine.GameTime {
public long toTicks(final int milliseconds) {
    return this.toTicks(milliseconds, Game.loop().getTickRate());
}public long since(final long tick) {
    return toMilliseconds(Game.loop().getTicks() - tick);
}public long now() {
    return Game.loop().getTicks();
}public long sinceGameStart() {
    return this.toMilliseconds(Game.loop().getTicks());
}@Override
  public void loaded(Environment environment) {
    environmentLoaded = Game.loop().getTicks();
}public long toMilliseconds(final long ticks) {
    return this.toMilliseconds(ticks, Game.loop().getTickRate());
}
}
```
```java
class de.gurkenlabs.litiengine.GameMetrics {
@Override
  public void render(final Graphics2D g) {
    this.updateMetrics();

    if (!Game.config().client().showGameMetrics()) {
      return;
    }

    this.currentOffsetY = 0;

    g.setColor(this.renderColor);

    // render client metrics
    this.drawTitle(g, "[client]");
    this.drawMetric(g, "fps       : " + this.getFramesPerSecond());
    this.drawMetric(g, "max fps   : " + this.maxFramesPerSecond);
    this.drawMetric(g, "updatables: " + Game.loop().getUpdatableCount());

    // render jvm metrics if debug is enabled
    if (Game.config().debug().isDebugEnabled()) {
      this.drawTitle(g, "[jvm]");
      this.drawMetric(g, "java      : " + this.javaVersion);
      this.drawMetric(g, "memory    : " + String.format("%-5.5s", this.usedMemory) + " MB");
      this.drawMetric(g, "threads   : " + Thread.activeCount());
    }

    // render rendering metrics
    if (!this.renderMetrics.isEmpty()) {
      this.drawTitle(g, "[update]");

      for (RenderMetrics metric : this.renderMetrics) {
        this.drawMetric(g, metric.toString());
      }

      this.renderMetrics.clear();
    }
}
}
```
```java
class de.gurkenlabs.litiengine.graphics.emitters.Emitter {
public void deactivate() {
    if (!this.activated) {
      return;
    }

    this.activated = false;
    this.getParticles().clear();
    this.aliveTime = 0;
    this.activationTick = 0;
    this.lastSpawn = 0;
    Game.loop().detach(this);
}public void activate() {
    if (this.activated) {
      return;
    }

    this.activated = true;
    this.activationTick = Game.time().now();
    Game.loop().attach(this);
}@Override
  public void update() {
    if (this.isPaused()) {
      return;
    }

    // clear particles if the effect time to life is reached
    if (this.isFinished()) {
      for (EmitterFinishedListener listener : this.finishedListeners) {
        listener.finished(this);
      }

      this.delete();
      return;
    }

    final float updateRatio = (float) this.data().getUpdateRate() / Game.loop().getTickRate();
    for (final Particle p : this.getParticles().stream().collect(Collectors.toList())) {
      if (this.particleCanBeRemoved(p)) {
        // remove dead particles
        this.particles.remove(p);
        continue;
      }

      p.update(this.getOrigin(), updateRatio);
    }

    this.aliveTime = Game.time().since(this.activationTick);
    if ((this.data().getSpawnRate() == 0
        || Game.time().since(this.lastSpawn) >= this.data().getSpawnRate())) {
      this.lastSpawn = Game.time().now();
      this.spawnParticle();
    }
}
}
```
```java
class de.gurkenlabs.litiengine.entities.behavior.IBehaviorController {
public default void attach() {
    Game.loop().attach(this);
}public default void detach() {
    Game.loop().detach(this);
}
}
```
```java
class de.gurkenlabs.litiengine.abilities.AbilityExecution {
AbilityExecution(final Ability ability) {
    this.appliedEffects = new CopyOnWriteArrayList<>();
    this.ability = ability;
    this.executionTicks = Game.time().now();
    this.impactArea = ability.calculateImpactArea();
    this.castLocation = ability.getExecutor().getCenter();
    Game.loop().attach(this);
}@Override
  public void update() {
    // if there a no effects to apply -> unregister this instance and we're done
    if (this.getAbility().getEffects().isEmpty()
        || this.getAbility().getEffects().size() == this.getAppliedEffects().size()) {
      Game.loop().detach(this);
      return;
    }

    // handle all effects from the ability that were not applied yet
    for (final Effect effect : this.getAbility().getEffects()) {
      // if the ability was not executed yet or the delay of the effect is not
      // yet reached
      if (this.getAppliedEffects().contains(effect)
          || Game.time().since(this.getExecutionTicks()) < effect.getDelay()) {
        continue;
      }

      effect.apply(this.getExecutionImpactArea());
      this.getAppliedEffects().add(effect);
    }
}
}
```
```java
class de.gurkenlabs.litiengine.GameWindow$3 {
@Override
          public void windowGainedFocus(WindowEvent e) {
            Game.loop().setTickRate(Game.config().client().getMaxFps());
}@Override
          public void windowLostFocus(WindowEvent e) {
            if (Game.config().graphics().reduceFramesWhenNotFocused()) {
              Game.loop().setTickRate(NONE_FOCUS_MAX_FPS);
            }
}
}
```
```java
class de.gurkenlabs.litiengine.environment.EntitySpawner {
protected void spawnNewEntities() {
    if (this.getSpawnMode() != SpawnMode.CUSTOMSPAWNPOINTS && this.getSpawnPoints().isEmpty()) {
      return;
    }

    switch (this.getSpawnMode()) {
      case ALLSPAWNPOINTS:
        for (int i = 0; i < this.getSpawnPoints().size(); i++) {
          final int index = i;
          Game.loop()
              .perform(
                  this.getSpawnDelay() + this.getSpawnDelay() * i,
                  () -> this.spawn(this.getSpawnPoints().get(index), this.getSpawnAmount()));
        }
        break;
      case ONERANDOMSPAWNPOINT:
        this.spawn(Game.random().choose(this.getSpawnPoints()), this.getSpawnAmount());
        break;
      case RANDOMSPAWNPOINTS:
        for (int i = 0; i < this.getSpawnAmount(); i++) {
          Game.loop()
              .perform(
                  this.getSpawnDelay() + this.getSpawnDelay() * i,
                  () -> this.spawn(Game.random().choose(this.getSpawnPoints()), 1));
        }
        break;
      case CUSTOMSPAWNPOINTS:
        List<Spawnpoint> spawnPoints =
            this.customSpawnpoints != null
                ? this.customSpawnpoints.apply(this)
                : this.getCustomSpawnpoints();

        int index = 0;
        for (Spawnpoint spawn : spawnPoints) {
          Game.loop()
              .perform(
                  this.getSpawnDelay() + this.getSpawnDelay() * index, () -> this.spawn(spawn, 1));
          index++;
        }
        break;
      default:
        break;
    }
}
}
```
```java
class de.gurkenlabs.litiengine.tweening.TweenEngine {
@Override
  public void start() {
    Game.loop().attach(this);
}@Override
  public void terminate() {
    Game.loop().detach(this);
}
}
```
```java
class de.gurkenlabs.litiengine.gui.SpeechBubble {
public void hide() {
    Game.world().environment().removeRenderable(this);
    Game.loop().detach(this);
    if (activeSpeechBubbles.get(this.getEntity()) != null
        && activeSpeechBubbles.remove(this.getEntity()).equals(this)) {
      activeSpeechBubbles.remove(this.getEntity());
    }

    for (SpeechBubbleListener listener : this.listeners) {
      listener.hidden();
    }
}private SpeechBubble(
      final IEntity entity,
      final String text,
      @Nullable SpeechBubbleAppearance appearance,
      @Nullable Font font) {
    if (appearance == null) {
      this.appearance = DEFAULT_APPEARANCE;
    } else {
      this.appearance = appearance;
    }

    final SpeechBubble active = activeSpeechBubbles.get(entity);
    if (active != null) {
      active.hide();
    }
    this.setFont(font);

    this.textBoxWidth = (float) (entity.getWidth() * 4);
    this.entity = entity;

    this.currentText = text;
    this.currentTextDisplayTime = DISPLAYTIME_MIN + text.length() * DISPLAYTIME_PER_LETTER;

    this.lastTextDisplay = Game.time().now();
    this.createBubbleImage();
    entity.getEnvironment().add(this, RenderType.UI);
    Game.loop().attach(this);
    activeSpeechBubbles.put(entity, this);
}
}
```
```java
class de.gurkenlabs.litiengine.entities.Prop {
private void updateAnimationController() {
    IEntityAnimationController<?> controller = this.createAnimationController();
    this.getControllers().addController(controller);
    if (Game.world().environment() != null && Game.world().environment().isLoaded()) {
      Game.loop().attach(controller);
    }
}
}
```
```java
class de.gurkenlabs.litiengine.graphics.FreeFlightCamera {
public FreeFlightCamera(final Point2D focus) {
    this.setFocus(focus);
    this.velocity = DEFAULT_SCROLL_PIXELS_PER_SECOND;
    this.scrollPadding = DEFAULT_SCROLL_PADDING;
    this.setClampToMap(true);

    Game.loop().attach(this);
}private void handleFreeFlightCamera() {
    if (Game.world().environment() == null || Game.world().environment().getMap() == null) {
      return;
    }

    final Point2D mouseLocation = Input.mouse().getLocation();

    final double scrollSpeed =
        this.getVelocity()
            / (double) Game.loop().getTickRate()
            * Game.config().input().getMouseSensitivity();

    double x = this.getFocus().getX();
    double y = this.getFocus().getY();

    double deltaX = 0;
    if (mouseLocation.getX() < this.getScrollPadding()) {
      deltaX -= scrollSpeed;
    } else if (Game.window().getResolution().getWidth() - mouseLocation.getX()
        < this.getScrollPadding()) {
      deltaX += scrollSpeed;
    }

    double deltaY = 0;
    if (mouseLocation.getY() < this.getScrollPadding()) {
      deltaY -= scrollSpeed;
    } else if (Game.window().getResolution().getHeight() - mouseLocation.getY()
        < this.getScrollPadding()) {
      deltaY += scrollSpeed;
    }

    x += deltaX;
    y += deltaY;

    this.setFocus(new Point2D.Double(x, y));
}
}
```
```java
class de.gurkenlabs.litiengine.environment.Environment {
private static void dispose(final Collection<? extends IEntity> entities) {
    for (final IEntity entity : entities) {
      if (entity instanceof IUpdateable) {
        Game.loop().detach((IUpdateable) entity);
      }

      entity.detachControllers();
    }
}private static void loadUpdatableOrEmitterEntity(IEntity entity) {
    if (entity instanceof Emitter) {
      final Emitter emitter = (Emitter) entity;
      if (emitter.isActivateOnInit()) {
        emitter.activate();
      }
    } else if (entity instanceof IUpdateable) {
      Game.loop().attach((IUpdateable) entity);
    }
}private void unload(final IEntity entity) {
    // 1. remove from physics engine
    if (entity instanceof ICollisionEntity) {
      Game.physics().remove((ICollisionEntity) entity);
    }

    // 2. unregister from update
    if (entity instanceof IUpdateable) {
      Game.loop().detach((IUpdateable) entity);
    }

    if (entity instanceof IMobileEntity) {
      this.removeGravity((IMobileEntity) entity);
    }

    // 3. detach all controllers
    entity.detachControllers();

    if (entity instanceof Emitter) {
      Emitter em = (Emitter) entity;
      em.deactivate();
    }

    if (this.loaded && (entity instanceof LightSource || entity instanceof StaticShadow)) {
      this.updateLighting(entity);
    }

    entity.removed(this);
}
}
```
```java
class de.gurkenlabs.litiengine.graphics.animation.Animation {
@Override
  public void update() {
    // do nothing if the animation is not playing or the current keyframe is not finished
    if (!this.isPlaying()
        || Game.time().since(this.lastFrameUpdate) < this.getCurrentKeyFrame().getDuration()) {
      return;
    }

    // if we are not looping and the last keyframe is finished, we terminate the animation
    if (!this.isLooping() && this.isLastKeyFrame()) {
      this.terminate();
      return;
    }

    // make sure, we stay inside the keyframe list
    final int newFrameIndex =
        (this.getKeyframes().indexOf(this.currentFrame) + 1) % this.getKeyframes().size();
    final KeyFrame previousFrame = this.currentFrame;
    this.currentFrame = this.getKeyframes().get(newFrameIndex);

    for (KeyFrameListener listener : this.listeners) {
      listener.currentFrameChanged(previousFrame, this.currentFrame);
    }

    this.lastFrameUpdate = Game.loop().getTicks();
}public void restart() {
    this.currentFrame = this.firstFrame;
    this.lastFrameUpdate = Game.loop().getTicks();
}
}
```
```java
class de.gurkenlabs.litiengine.physics.MovementController {
@Override
  public void attach() {
    Game.loop().attach(this);
}private void handleForces() {
    // clean up forces
    this.activeForces.forEach(
        x -> {
          if (x.hasEnded()) {
            this.activeForces.remove(x);
          }
        });

    if (this.activeForces.isEmpty()) {
      return;
    }

    // disable turn-on-move for force handling
    boolean turn = this.getEntity().turnOnMove();
    this.getEntity().setTurnOnMove(false);
    try {
      double deltaX = 0;
      double deltaY = 0;
      for (final Force force : this.activeForces) {
        if (force.cancelOnReached() && force.hasReached(this.getEntity())) {
          force.end();
          continue;
        }

        final Point2D collisionBoxCenter = this.getEntity().getCollisionBoxCenter();
        final double angle =
            GeometricUtilities.calcRotationAngleInDegrees(collisionBoxCenter, force.getLocation());
        final double strength =
            Game.loop().getDeltaTime() * 0.001f * force.getStrength() * Game.loop().getTimeScale();
        deltaX += GeometricUtilities.getDeltaX(angle, strength);
        deltaY += GeometricUtilities.getDeltaY(angle, strength);
      }

      final Point2D target =
          new Point2D.Double(this.getEntity().getX() + deltaX, this.getEntity().getY() + deltaY);
      final boolean success = Game.physics().move(this.getEntity(), target);
      if (!success) {
        for (final Force force : this.activeForces) {
          if (force.cancelOnCollision()) {
            force.end();
          }
        }
      }
    } finally {
      this.getEntity().setTurnOnMove(turn);
    }
}@Override
  public void detach() {
    Game.loop().detach(this);
}public void handleMovement() {
    if (!this.isMovementAllowed()) {
      this.velocity = 0;
      return;
    }

    // max distance an entity can travel within one tick
    final double maxPixelsPerTick = this.getEntity().getTickVelocity();
    final double deltaTime = Game.loop().getDeltaTime() * Game.loop().getTimeScale();

    final double acceleration =
        this.getEntity().getAcceleration() == 0
            ? maxPixelsPerTick
            : deltaTime / this.getEntity().getAcceleration() * maxPixelsPerTick;
    final double deceleration =
        this.getEntity().getDeceleration() == 0
            ? this.getVelocity()
            : deltaTime / this.getEntity().getDeceleration() * maxPixelsPerTick;

    double dx = this.getDx();
    double dy = this.getDy();
    this.setDx(0);
    this.setDy(0);

    final double deltaVelocity =
        Math.min(Math.sqrt(Math.pow(dx, 2) + Math.pow(dy, 2)), acceleration);
    if (deltaVelocity != 0) {
      double newVelocity = this.getVelocity() + deltaVelocity;
      this.setVelocity(newVelocity);
    } else {
      final double newVelocity = Math.max(0, this.getVelocity() - deceleration);
      this.setVelocity(newVelocity);
      dx = GeometricUtilities.getDeltaX(this.moveAngle);
      dy = GeometricUtilities.getDeltaY(this.moveAngle);
    }

    if (this.getVelocity() == 0) {
      this.moveAngle = 0;
      return;
    }

    // actually move entity
    this.moveEntity(dx, dy);
}
}
```
```java
class de.gurkenlabs.litiengine.graphics.animation.AnimationController {
public void detach() {
    Game.loop().detach(this);
}public void attach() {
    Game.loop().attach(this);
}
}
```
```java
class de.gurkenlabs.litiengine.graphics.Camera {
@Override
  public void setZoom(final float targetZoom, final int delay) {
    if (delay == 0) {

      this.zoom = targetZoom;
      this.targetZoom = 0;
      this.zoomDelay = 0;
      this.zoomTick = 0;
      this.zoomStep = 0;

      final ZoomChangedEvent event = new ZoomChangedEvent(this, targetZoom);
      for (final ZoomChangedListener listener : this.zoomListeners) {
        listener.zoomChanged(event);
      }
    } else {
      this.zoomTick = Game.time().now();
      this.targetZoom = targetZoom;
      this.zoomDelay = delay;

      final double tickduration = 1000 / (double) Game.loop().getTickRate();
      final double tickAmount = delay / tickduration;
      final float totalDelta = this.targetZoom - this.zoom;
      this.zoomStep = tickAmount > 0 ? (float) (totalDelta / tickAmount) : totalDelta;
    }
}
}
```
```java
class de.gurkenlabs.litiengine.Game {
public static synchronized void init(String... args) {
    if (initialized) {
      log().log(Level.INFO, "The game has already been initialized.");
      return;
    }

    log.init();
    handleCommandLineArguments(args);

    config().load();
    Locale.setDefault(new Locale(config().client().getCountry(), config().client().getLanguage()));

    gameLoop = new GameLoop("Main Update Loop", config().client().getMaxFps());
    loop().attach(physics());
    loop().attach(world());

    // setup default exception handling for render and update loop
    setUncaughtExceptionHandler(
        new DefaultUncaughtExceptionHandler(config().client().exitOnError()));

    screenManager = new ScreenManager();
    gameWindow = new GameWindow();

    // initialize  the game window
    window().init();
    world.setCamera(new Camera());

    for (GameListener listener : gameListeners) {
      listener.initialized(args);
    }

    if (!isInNoGUIMode()) {
      window().getRenderComponent().onRendered(g -> metrics().render(g));

      graphics()
          .addEntityRenderedListener(
              e -> DebugRenderer.renderEntityDebugInfo(e.getGraphics(), e.getEntity()));

      window().getRenderComponent().onFpsChanged(fps -> metrics().setFramesPerSecond(fps));
      window()
          .setIcons(
              Arrays.asList(
                  Resources.images().get("liti-logo-x16.png"),
                  Resources.images().get("liti-logo-x20.png"),
                  Resources.images().get("liti-logo-x32.png"),
                  Resources.images().get("liti-logo-x48.png")));

      Input.keyboard()
          .onKeyTyped(
              KeyEvent.VK_PRINTSCREEN,
              key -> {
                // don't take a screenshot if a modifier is active
                if (key.getModifiers() != 0) {
                  return;
                }

                window().getRenderComponent().takeScreenshot();
              });
    }

    Runtime.getRuntime().addShutdownHook(new Thread(Game::terminate, "Shutdown"));

    initialized = true;
}
}
```
```java
class de.gurkenlabs.litiengine.entities.Creature {
protected void updateAnimationController() {
    IEntityAnimationController<?> controller = this.createAnimationController();
    this.getControllers().addController(controller);
    if (Game.world().environment() != null && Game.world().environment().isLoaded()) {
      Game.loop().attach(controller);
    }
}@Override
  public float getTickVelocity() {
    // pixels per ms multiplied by the passed ms
    // ensure that entities don't travel too far in case of lag
    return Math.min(Game.loop().getDeltaTime(), GameLoop.TICK_DELTATIME_LAG)
        * 0.001F
        * this.getVelocity().get()
        * Game.loop().getTimeScale();
}
}
```
Depth: 2
```java
class de.gurkenlabs.litiengine.environment.GameWorld {
public void clear() {
    this.unloadEnvironment();
    this.environments.clear();
    this.setCamera(null);
    Game.physics().clear();

    this.environmentListeners.clear();
    this.environmentLoadedListeners.clear();
    this.environmentUnloadedListeners.clear();

    this.listeners.clear();
    this.loadedListeners.clear();
    this.unloadedListeners.clear();
}@Nullable
  public Environment loadEnvironment(IMap map) {
    Environment env = this.getEnvironment(map);
    this.loadEnvironment(env);
    return env;
}@Nullable
  public Environment loadEnvironment(String mapName) {
    Environment env = this.getEnvironment(mapName);
    this.loadEnvironment(env);
    return env;
}
}
```
```java
class de.gurkenlabs.litiengine.GameWindow {
GameWindow() {
    this.hostControl = new JFrame();

    this.resolutionChangedListeners = new CopyOnWriteArrayList<>();

    this.renderCanvas = new RenderComponent(Game.config().graphics().getResolution());
    this.cursor = new MouseCursor();
    if (!Game.isInNoGUIMode()) {
      this.hostControl.setBackground(Color.BLACK);
      this.hostControl.add(this.renderCanvas);

      this.initializeEventListeners();

      this.hostControl.setTitle(Game.info().getTitle());
      this.hostControl.setDefaultCloseOperation(WindowConstants.DO_NOTHING_ON_CLOSE);
      initializeWindowEventListeners(this.hostControl);
    }
}
}
```
```java
class de.gurkenlabs.litiengine.GameTime {
public long sinceEnvironmentLoad() {
    return this.since(this.environmentLoaded);
}public long since(final long tick) {
    return toMilliseconds(Game.loop().getTicks() - tick);
}public long sinceGameStart() {
    return this.toMilliseconds(Game.loop().getTicks());
}
}
```
```java
class de.gurkenlabs.litiengine.abilities.effects.Effect {
protected void cease(final EffectApplication appliance) {
    // 1. cease the effect for all affected entities
    for (final ICombatEntity entity : appliance.getAffectedEntities()) {
      this.cease(entity);
    }

    // 2. apply follow up effects
    this.getFollowUpEffects().forEach(followUp -> followUp.apply(appliance.getImpactArea()));
}protected boolean hasEnded(final EffectApplication appliance) {
    final long effectDuration = Game.time().since(appliance.getAppliedTicks());
    return effectDuration > this.getDuration();
}
}
```
```java
class de.gurkenlabs.litiengine.abilities.effects.EffectApplication {
protected EffectApplication(final List<ICombatEntity> affectedEntities, final Shape impactArea) {
    this.applied = Game.time().now();
    this.affectedEntities = affectedEntities;
    this.impactArea = impactArea;
}
}
```
```java
class de.gurkenlabs.litiengine.entities.CombatEntity {
@Override
  public boolean wasHit(int timeSpan) {
    return Game.time().since(this.lastHit) < timeSpan;
}@Override
  public void hit(final int damage, @Nullable final Ability ability) {
    if (this.isDead()) {
      return;
    }

    if (!this.isIndestructible()) {
      this.getHitPoints().modifyBaseValue(new AttributeModifier<>(Modification.SUBTRACT, damage));
    }

    final EntityHitEvent event = new EntityHitEvent(this, ability, damage, this.isDead());

    for (final CombatEntityListener listener : this.listeners) {
      listener.hit(event);
    }

    for (final CombatEntityHitListener listener : this.hitListeners) {
      listener.hit(event);
    }

    if (this.isDead()) {
      this.fireDeathEvent();
      this.setCollision(false);
    }

    this.lastHit = Game.time().now();
}
}
```
```java
class de.gurkenlabs.litiengine.graphics.ImageEffect {
protected ImageEffect(final int ttl, final String name) {
    this.ttl = ttl;
    this.name = name;
    this.aliveTick = Game.time().now();
}@Override
  public long getAliveTime() {
    return Game.time().since(this.aliveTick);
}
}
```
```java
class de.gurkenlabs.litiengine.abilities.AbilityExecution {
AbilityExecution(final Ability ability) {
    this.appliedEffects = new CopyOnWriteArrayList<>();
    this.ability = ability;
    this.executionTicks = Game.time().now();
    this.impactArea = ability.calculateImpactArea();
    this.castLocation = ability.getExecutor().getCenter();
    Game.loop().attach(this);
}@Override
  public void update() {
    // if there a no effects to apply -> unregister this instance and we're done
    if (this.getAbility().getEffects().isEmpty()
        || this.getAbility().getEffects().size() == this.getAppliedEffects().size()) {
      Game.loop().detach(this);
      return;
    }

    // handle all effects from the ability that were not applied yet
    for (final Effect effect : this.getAbility().getEffects()) {
      // if the ability was not executed yet or the delay of the effect is not
      // yet reached
      if (this.getAppliedEffects().contains(effect)
          || Game.time().since(this.getExecutionTicks()) < effect.getDelay()) {
        continue;
      }

      effect.apply(this.getExecutionImpactArea());
      this.getAppliedEffects().add(effect);
    }
}
}
```
```java
class de.gurkenlabs.litiengine.tweening.TweenEngine {
@Override
  public void update() {
    for (final Tweenable target : this.getTweens().keySet()) {
      for (final Tween tween : this.getTweens().get(target).values()) {
        if (tween.hasStopped()) {
          continue;
        }
        final long elapsed = Game.time().since(tween.getStartTime());
        if (elapsed >= tween.getDuration()) {
          tween.stop();
          continue;
        }
        final float[] currentValues = new float[tween.getTargetValues().length];
        for (int i = 0; i < tween.getTargetValues().length; i++) {
          currentValues[i] =
              tween.getStartValues()[i]
                  + tween.getEquation().compute(elapsed / (float) tween.getDuration())
                      * (tween.getTargetValues()[i] - tween.getStartValues()[i]);
        }
        tween.getTarget().setTweenValues(tween.getType(), currentValues);
      }
    }
}
}
```
```java
class de.gurkenlabs.litiengine.gui.SpeechBubble {
public static SpeechBubble create(
      final IEntity entity, final String text, SpeechBubbleAppearance appearance, Font font) {
    return new SpeechBubble(entity, text, appearance, font);
}public static SpeechBubble create(final IEntity entity, final Font font, final String text) {
    SpeechBubbleAppearance app =
        new SpeechBubbleAppearance(
            DEFAULT_APPEARANCE.getForeColor(),
            DEFAULT_APPEARANCE.getBackgroundColor1(),
            DEFAULT_APPEARANCE.getBorderColor(),
            DEFAULT_APPEARANCE.getPadding());
    return new SpeechBubble(entity, text, app, font);
}public static SpeechBubble create(final IEntity entity, final String text) {
    return new SpeechBubble(entity, text, null, GuiProperties.getDefaultFont());
}@Override
  public void update() {
    if (this.currentText == null) {
      this.hide();
      return;
    }

    this.entityCenter = Game.world().camera().getViewportLocation(this.getEntity().getCenter());

    // old text was displayed long enough
    if (this.lastTextDisplay != 0
        && Game.time().since(this.lastTextDisplay) > this.currentTextDisplayTime) {
      this.currentText = null;
      this.lastTextDisplay = 0;
      return;
    }

    // display new text
    if (this.textIndex < this.currentText.length()
        && Game.time().since(this.lastCharPoll) > LETTER_WRITE_DELAY) {
      this.textIndex++;
      this.lastCharPoll = Game.time().now();
      if (this.typeSound != null) {
        Game.audio().playSound(this.typeSound, this.getEntity());
      }
    }

    // continue displaying currently displayed text
}private SpeechBubble(
      final IEntity entity,
      final String text,
      final Sound typeSound,
      SpeechBubbleAppearance appearance,
      Font font) {
    this(entity, text, appearance, font);
    this.typeSound = typeSound;
}private SpeechBubble(
      final IEntity entity,
      final String text,
      @Nullable SpeechBubbleAppearance appearance,
      @Nullable Font font) {
    if (appearance == null) {
      this.appearance = DEFAULT_APPEARANCE;
    } else {
      this.appearance = appearance;
    }

    final SpeechBubble active = activeSpeechBubbles.get(entity);
    if (active != null) {
      active.hide();
    }
    this.setFont(font);

    this.textBoxWidth = (float) (entity.getWidth() * 4);
    this.entity = entity;

    this.currentText = text;
    this.currentTextDisplayTime = DISPLAYTIME_MIN + text.length() * DISPLAYTIME_PER_LETTER;

    this.lastTextDisplay = Game.time().now();
    this.createBubbleImage();
    entity.getEnvironment().add(this, RenderType.UI);
    Game.loop().attach(this);
    activeSpeechBubbles.put(entity, this);
}
}
```
```java
class de.gurkenlabs.litiengine.gui.TextFieldComponent {
@Override
  public void render(final Graphics2D g) {
    super.render(g);
    g.setFont(this.getFont());
    final FontMetrics fm = g.getFontMetrics();

    if (this.isSelected() && Game.time().since(this.lastToggled) > this.flickerDelay) {
      this.cursorVisible = !this.cursorVisible;
      this.lastToggled = Game.time().now();
    }
    if (this.isSelected() && this.cursorVisible) {
      final Rectangle2D cursor =
          new Rectangle2D.Double(
              this.getX() + this.getTextX() + fm.stringWidth(this.getTextToRender(g)),
              this.getY() + this.getTextY(),
              this.getFont().getSize2D() * 3 / 5,
              this.getFont().getSize2D() * 1 / 5);
      g.setColor(this.getAppearance().getForeColor());
      g.fill(cursor);
    }
}
}
```
```java
class de.gurkenlabs.litiengine.entities.Prop {
public Prop(
      final Point2D location, @Nullable final String spritesheetName, final Material material) {
    super();
    this.rotation = Rotation.NONE;
    this.spritesheetName = spritesheetName;
    this.material = material;
    this.setLocation(location);
    this.updateAnimationController();
}public void setSpritesheetName(@Nullable final String spriteName) {
    this.spritesheetName = spriteName;
    this.updateAnimationController();
}
}
```
```java
class de.gurkenlabs.litiengine.tweening.Tween {
public Tween begin() {
    this.started = Game.time().now();
    this.stopped = false;
    return this;
}
}
```
```java
class de.gurkenlabs.litiengine.graphics.emitters.particles.Particle {
public void update(final Point2D emitterOrigin, final float updateRatio) {
    if (this.aliveTick == 0) {
      this.aliveTick = Game.time().now();
    }

    this.aliveTime = Game.time().since(this.aliveTick);
    if (this.timeToLiveReached()) {
      return;
    }

    if (this.colliding) {
      return;
    }

    if (this.getDeltaWidth() != 0) {
      this.width += this.getDeltaWidth() * updateRatio;
    }

    if (this.getDeltaHeight() != 0) {
      this.height += this.getDeltaHeight() * updateRatio;
    }

    if (this.getDeltaAngle() != 0) {
      this.angle += this.getDeltaAngle() * updateRatio;
    }

    // test for ray cast collision
    final float targetX = this.x + this.getVelocityX() * updateRatio;
    final float targetY = this.y + this.getVelocityY() * updateRatio;

    if (targetX == this.x && targetY == this.y) {
      return;
    }

    if (this.checkForCollision(emitterOrigin, targetX, targetY)) {
      return;
    }

    if (this.getVelocityX() != 0) {
      this.x = targetX;
    }

    if (this.getVelocityY() != 0) {
      this.y = targetY;
    }

    if (this.getAccelerationX() != 0) {
      this.velocityX += this.getAccelerationX() * updateRatio;
    }

    if (this.getAccelerationY() != 0) {
      this.velocityY += this.getAccelerationY() * updateRatio;
    }
}
}
```
```java
class de.gurkenlabs.litiengine.graphics.animation.Animation {
@Override
  public void start() {
    this.playing = true;
    if (this.getKeyframes().isEmpty()) {
      return;
    }

    this.restart();
}@Override
  public void update() {
    // do nothing if the animation is not playing or the current keyframe is not finished
    if (!this.isPlaying()
        || Game.time().since(this.lastFrameUpdate) < this.getCurrentKeyFrame().getDuration()) {
      return;
    }

    // if we are not looping and the last keyframe is finished, we terminate the animation
    if (!this.isLooping() && this.isLastKeyFrame()) {
      this.terminate();
      return;
    }

    // make sure, we stay inside the keyframe list
    final int newFrameIndex =
        (this.getKeyframes().indexOf(this.currentFrame) + 1) % this.getKeyframes().size();
    final KeyFrame previousFrame = this.currentFrame;
    this.currentFrame = this.getKeyframes().get(newFrameIndex);

    for (KeyFrameListener listener : this.listeners) {
      listener.currentFrameChanged(previousFrame, this.currentFrame);
    }

    this.lastFrameUpdate = Game.loop().getTicks();
}
}
```
```java
class de.gurkenlabs.litiengine.graphics.animation.AnimationController {
@Override
  public void update() {
    for (final Animation animation : this.getAll()) {
      animation.update();
    }

    if (this.getCurrent() != null && this.getCurrent().isPaused()) {
      return;
    }

    final boolean playbackFinished = this.getCurrent() != null && !this.getCurrent().isPlaying();
    if (playbackFinished) {
      for (final AnimationListener listener : this.listeners) {
        listener.finished(this.getCurrent());
      }
    }

    if (this.getCurrent() == null || playbackFinished) {
      if (this.getDefault() != null) {
        this.play(this.getDefault().getName());
      } else {
        this.currentAnimation = null;
      }
    }
}
}
```
```java
class de.gurkenlabs.litiengine.graphics.RenderComponent {
private void handleFade() {
    if (this.fadeOutStart != -1) {
      final long timePassed = Game.time().since(this.fadeOutStart);
      this.currentAlpha = MathUtilities.clamp(1 - timePassed / (float) this.fadeOutTime, 0, 1);
      if (this.currentAlpha == 0f) {
        this.fadeOutStart = -1;
        this.fadeOutTime = -1;
      }

      return;
    }

    if (this.fadeInStart != -1) {
      final long timePassed = Game.time().since(this.fadeInStart);
      this.currentAlpha = MathUtilities.clamp(timePassed / (float) this.fadeInTime, 0, 1);
      if (this.currentAlpha == 1f) {
        this.fadeInStart = -1;
        this.fadeInTime = -1;
        this.currentAlpha = Float.NaN;
      }
    }
}public void fadeOut(final int ms) {
    this.fadeInStart = -1;
    this.fadeInTime = -1;
    this.fadeOutStart = Game.time().now();
    this.fadeOutTime = ms;
}public void fadeIn(final int ms) {
    this.fadeOutStart = -1;
    this.fadeOutTime = -1;
    this.fadeInStart = Game.time().now();
    this.fadeInTime = ms;
}
}
```
```java
class de.gurkenlabs.litiengine.entities.Trigger {
private boolean activate(final IEntity activator, final int tar) {
    if (!this.isLoaded()
        || this.isOneTimeTrigger && this.isActivated
        || this.getActivationType() == TriggerActivation.COLLISION
            && activator != null
            && this.collisionActivated.contains(activator)) {
      return false;
    }

    if (this.getCooldown() > 0 && Game.time().since(this.lastActivation) < this.getCooldown()) {
      return false;
    }

    List<Integer> triggerTargets = this.getTargets(tar);

    final TriggerEvent te = new TriggerEvent(this, activator, triggerTargets);

    if (!this.checkActivationPredicates(te)) {
      return false;
    }

    this.isActivated = true;
    if (activator != null) {
      this.collisionActivated.add(activator);
    }

    // if we actually have a trigger target, we send the message to the target
    for (final int target : triggerTargets) {
      final IEntity entity = this.getEnvironment().get(target);
      if (entity == null) {
        log.log(
            Level.WARNING,
            "trigger [{0}] was activated, but the trigger target [{1}] could not be found on the environment",
            new Object[] {this, target});
        continue;
      }

      entity.sendMessage(this, this.message);
    }

    // also send the trigger event to all registered consumers
    for (final TriggerActivatedListener listener : this.activatedListeners) {
      listener.activated(te);
    }

    if (this.isOneTimeTrigger) {
      this.getEnvironment().remove(this);
    }

    this.lastActivation = Game.time().now();
    return true;
}
}
```
```java
class de.gurkenlabs.litiengine.graphics.Camera {
private boolean isShakeEffectActive() {
    return this.getShakeTick() != 0
        && Game.time().since(this.getShakeTick()) < this.getShakeDuration();
}@Override
  public void update() {
    if (Game.world().camera() != null && !Game.world().camera().equals(this)) {
      return;
    }

    if (this.targetZoom > 0) {
      if (Game.time().since(this.zoomTick) >= this.zoomDelay) {
        this.zoom = this.targetZoom;
        this.targetZoom = 0;
        this.zoomDelay = 0;
        this.zoomTick = 0;
        this.zoomStep = 0;
      } else {
        this.zoom += this.zoomStep;
      }

      final ZoomChangedEvent event = new ZoomChangedEvent(this, this.getZoom());
      for (final ZoomChangedListener listener : this.zoomListeners) {
        listener.zoomChanged(event);
      }
    }

    if (this.panTime > 0) {
      if (--this.panTime <= 0) {
        this.setFocus(this.targetFocus);
        this.targetFocus = null;
      } else {
        double diff = this.panTime / (this.panTime + 1.0);
        this.focus =
            new Point2D.Double(
                this.focus.getX() * diff + this.targetFocus.getX() * (1.0 - diff),
                this.focus.getY() * diff + this.targetFocus.getY() * (1.0 - diff));
      }
    }

    if (!this.isShakeEffectActive()) {
      this.shakeOffsetX = 0;
      this.shakeOffsetY = 0;
      return;
    }

    if (Game.time().since(this.lastShake) > this.shakeDelay) {
      this.shakeOffsetX = this.getShakeIntensity() * ThreadLocalRandom.current().nextGaussian();
      this.shakeOffsetY = this.getShakeIntensity() * ThreadLocalRandom.current().nextGaussian();
      this.lastShake = Game.time().now();
    }
}@Override
  public void setZoom(final float targetZoom, final int delay) {
    if (delay == 0) {

      this.zoom = targetZoom;
      this.targetZoom = 0;
      this.zoomDelay = 0;
      this.zoomTick = 0;
      this.zoomStep = 0;

      final ZoomChangedEvent event = new ZoomChangedEvent(this, targetZoom);
      for (final ZoomChangedListener listener : this.zoomListeners) {
        listener.zoomChanged(event);
      }
    } else {
      this.zoomTick = Game.time().now();
      this.targetZoom = targetZoom;
      this.zoomDelay = delay;

      final double tickduration = 1000 / (double) Game.loop().getTickRate();
      final double tickAmount = delay / tickduration;
      final float totalDelta = this.targetZoom - this.zoom;
      this.zoomStep = tickAmount > 0 ? (float) (totalDelta / tickAmount) : totalDelta;
    }
}@Override
  public void shake(final double intensity, final int delay, final int shakeDuration) {
    this.shakeTick = Game.time().now();
    this.shakeDelay = delay;
    this.shakeIntensity = intensity;
    this.shakeDuration = shakeDuration;
}
}
```
```java
class de.gurkenlabs.litiengine.entities.Creature {
public void setSpritesheetName(String spritesheetName) {
    if (this.spritesheetName != null && this.spritesheetName.equals(spritesheetName)) {
      return;
    }

    this.spritesheetName = spritesheetName;
    this.updateAnimationController();
}public boolean isIdle() {
    return Game.time().since(this.lastMoved) > IDLE_DELAY;
}@Override
  public void setLocation(final Point2D position) {
    if (this.isDead() || position == null) {
      return;
    }

    final Point2D oldLocation = this.getLocation();
    super.setLocation(position);

    if (Game.hasStarted() && this.isLoaded()) {
      this.lastMoved = Game.time().now();
      this.fireMovedEvent(
          new EntityMovedEvent(
              this, this.getX() - oldLocation.getX(), this.getY() - oldLocation.getY()));
    }
}
}
```
```java
class de.gurkenlabs.litiengine.gui.screens.ScreenManager {
public void display(final String screenName) {
    if (this.current() != null && this.current().getName().equalsIgnoreCase(screenName)) {
      log.log(
          Level.INFO,
          "Skipping displaying of screen {0} because it is already the current screen.",
          screenName);
      return;
    }

    if (this.screens.stream()
        .noneMatch(element -> element.getName().equalsIgnoreCase(screenName))) {
      log.log(
          Level.WARNING,
          "Could not display the screen {0} because there is no screen with the specified name.",
          screenName);
      return;
    }

    Screen screen = this.get(screenName);
    if (screen == null) {
      return;
    }

    this.display(screen);
}public void add(final Screen screen) {
    screen.setWidth(Game.window().getWidth());
    screen.setHeight(Game.window().getHeight());
    this.screens.add(screen);

    if (this.current() == null) {
      this.display(screen);
    }
}public void remove(Screen screen) {
    this.screens.remove(screen);
    if (this.current() == screen) {
      if (!this.screens.isEmpty()) {
        this.display(this.screens.get(0));
      } else {
        this.display((Screen) null);
      }
    }
}public void display(@Nullable final Screen screen) {
    if (Game.hasStarted() && Game.time().since(this.lastScreenChange) < this.getChangeCooldown()) {
      log.log(
          Level.INFO,
          "Skipping displaying of screen {0} because screen changing is currently on cooldown.",
          screen != null ? screen.getName() : "");
      return;
    }

    final Screen previous = this.current();
    if (previous != null) {
      previous.suspend();
    }

    if (screen != null && !this.screens.contains(screen)) {
      this.screens.add(screen);
    }

    this.currentScreen = screen;
    if (!Game.isInNoGUIMode() && this.current() != null) {
      this.current().prepare();
    }

    this.lastScreenChange = Game.loop().getTicks();

    final ScreenChangedEvent event = new ScreenChangedEvent(this.current(), previous);
    for (final ScreenChangedListener listener : this.screenChangedListeners) {
      listener.changed(event);
    }
}
}
```
```java
class de.gurkenlabs.litiengine.abilities.Ability {
public boolean isOnCooldown() {
    return (this.getCurrentExecution() != null
        && this.getCurrentExecution().getExecutionTicks() > 0
        && Game.time().since(this.getCurrentExecution().getExecutionTicks())
            < this.getAttributes().cooldown().get());
}public boolean isActive() {
    return this.getCurrentExecution() != null
        && Game.time().since(this.getCurrentExecution().getExecutionTicks())
            < this.getAttributes().duration().get();
}@Nullable
  public AbilityExecution cast() {
    if (!this.canCast()) {
      return null;
    }
    this.currentExecution = new AbilityExecution(this);

    for (final AbilityCastListener listener : this.abilityCastListeners) {
      listener.abilityCast(this.currentExecution);
    }

    return this.getCurrentExecution();
}public float getRemainingCooldownInSeconds() {
    if (this.getCurrentExecution() == null
        || this.getExecutor() == null
        || this.getExecutor().isDead()) {
      return 0;
    }

    // calculate cooldown in seconds
    return (float)
        (!this.canCast()
            ? (this.getAttributes().cooldown().get()
                    - Game.time().since(this.getCurrentExecution().getExecutionTicks()))
                * 0.001
            : 0);
}
}
```
```java
class de.gurkenlabs.litiengine.entities.EntityHitEvent {
EntityHitEvent(
      final ICombatEntity hitEntity,
      @Nullable final Ability ability,
      final int damage,
      final boolean kill) {
    super(hitEntity);
    this.executor = ability != null ? ability.getExecutor() : null;
    this.hitEntity = hitEntity;
    this.ability = ability;
    this.damage = damage;
    this.kill = kill;
    this.time = Game.time().now();
}
}
```
```java
class de.gurkenlabs.litiengine.graphics.emitters.Emitter {
public void delete() {
    this.deactivate();
    if (Game.world().environment() != null) {
      Game.world().environment().remove(this);
    }
}public void activate() {
    if (this.activated) {
      return;
    }

    this.activated = true;
    this.activationTick = Game.time().now();
    Game.loop().attach(this);
}@Override
  public void update() {
    if (this.isPaused()) {
      return;
    }

    // clear particles if the effect time to life is reached
    if (this.isFinished()) {
      for (EmitterFinishedListener listener : this.finishedListeners) {
        listener.finished(this);
      }

      this.delete();
      return;
    }

    final float updateRatio = (float) this.data().getUpdateRate() / Game.loop().getTickRate();
    for (final Particle p : this.getParticles().stream().collect(Collectors.toList())) {
      if (this.particleCanBeRemoved(p)) {
        // remove dead particles
        this.particles.remove(p);
        continue;
      }

      p.update(this.getOrigin(), updateRatio);
    }

    this.aliveTime = Game.time().since(this.activationTick);
    if ((this.data().getSpawnRate() == 0
        || Game.time().since(this.lastSpawn) >= this.data().getSpawnRate())) {
      this.lastSpawn = Game.time().now();
      this.spawnParticle();
    }
}
}
```
```java
class de.gurkenlabs.litiengine.GameLoop {
@Override
  public int perform(int delay, Runnable action) {
    final long d = Game.time().toTicks(delay);

    TimedAction a = new TimedAction(this.getTicks() + d, action);
    this.actions.add(a);

    return a.getId();
}
}
```
```java
class de.gurkenlabs.litiengine.environment.EntitySpawner {
protected boolean shouldSpawn() {
    return this.lastSpawnWave == 0
        || Game.time().since(this.lastSpawnWave) >= this.getSpawnInterval();
}@Override
  public void update() {
    if (!this.shouldSpawn()) {
      return;
    }

    this.spawnNewEntities();
    this.lastSpawnWave = Game.time().now();
}
}
```
```java
class de.gurkenlabs.litiengine.graphics.FreeFlightCamera {
@Override
  public void update() {
    this.handleFreeFlightCamera();
}public FreeFlightCamera(double x, double y) {
    this(new Point2D.Double(x, y));
}
}
```
```java
class de.gurkenlabs.litiengine.environment.Environment {
public void unload() {
    if (!this.loaded) {
      return;
    }

    // unregister all updatable entities from the current environment
    for (final IEntity entity : this.allEntities.values()) {
      this.unload(entity);
    }

    this.loaded = false;
    this.fireEvent(l -> l.unloaded(this));
}private static void loadUpdatableOrEmitterEntity(IEntity entity) {
    if (entity instanceof Emitter) {
      final Emitter emitter = (Emitter) entity;
      if (emitter.isActivateOnInit()) {
        emitter.activate();
      }
    } else if (entity instanceof IUpdateable) {
      Game.loop().attach((IUpdateable) entity);
    }
}public void clear() {
    Game.physics().clear();

    this.combatEntities.clear();
    this.mobileEntities.clear();
    this.gravityForces.clear();
    this.layerEntities.clear();
    this.entitiesByTag.clear();
    this.allEntities.clear();

    for (RenderType renderType : RenderType.values()) {
      this.miscEntities.get(renderType).clear();
      this.renderListeners.get(renderType).clear();
      this.renderables.get(renderType).clear();
    }

    dispose(this.allEntities.values());
    dispose(this.triggers);
    this.emitters.clear();
    this.colliders.clear();
    this.props.clear();
    this.creatures.clear();
    this.staticShadows.clear();
    this.combatEntities.clear();
    this.mobileEntities.clear();
    this.lightSources.clear();
    this.spawnPoints.clear();
    this.soundSources.clear();
    this.mapAreas.clear();
    this.triggers.clear();

    this.ambientLight = null;
    this.staticShadowLayer = null;

    for (Map<Integer, IEntity> type : this.miscEntities.values()) {
      type.clear();
    }

    this.initialized = false;

    this.fireEvent(l -> l.cleared(this));
}private void load(final IEntity entity) {
    // an entity can only exist on one environment at a time, so remove it from the current one
    if (entity.getEnvironment() != null) {
      entity.getEnvironment().remove(entity);
    }

    // 1. add to physics engine
    loadPhysicsEntity(entity);

    // 2. register for update or activate
    loadUpdatableOrEmitterEntity(entity);

    // 3. if a gravity is defined, add a gravity force to the entity
    if (entity instanceof IMobileEntity && this.getGravity() != 0) {
      this.addGravityForce((IMobileEntity) entity);
    }

    // 4. attach all controllers
    entity.attachControllers();

    if (this.loaded && (entity instanceof LightSource || entity instanceof StaticShadow)) {
      this.updateLighting(entity);
    }

    entity.loaded(this);
}private void unload(final IEntity entity) {
    // 1. remove from physics engine
    if (entity instanceof ICollisionEntity) {
      Game.physics().remove((ICollisionEntity) entity);
    }

    // 2. unregister from update
    if (entity instanceof IUpdateable) {
      Game.loop().detach((IUpdateable) entity);
    }

    if (entity instanceof IMobileEntity) {
      this.removeGravity((IMobileEntity) entity);
    }

    // 3. detach all controllers
    entity.detachControllers();

    if (entity instanceof Emitter) {
      Emitter em = (Emitter) entity;
      em.deactivate();
    }

    if (this.loaded && (entity instanceof LightSource || entity instanceof StaticShadow)) {
      this.updateLighting(entity);
    }

    entity.removed(this);
}public void remove(final IEntity entity) {
    if (entity == null) {
      return;
    }

    this.allEntities.remove(entity.getMapId());
    Iterator<List<IEntity>> iter = this.layerEntities.values().iterator();
    while (iter.hasNext()) {
      List<IEntity> layer = iter.next();
      if (layer.remove(entity) && layer.isEmpty()) {
        iter.remove();
      }
    }
    if (this.miscEntities.get(entity.getRenderType()) != null) {
      this.miscEntities.get(entity.getRenderType()).values().remove(entity);
    }

    for (String tag : entity.getTags()) {
      if (this.getEntitiesByTag().containsKey(tag)) {
        this.getEntitiesByTag().get(tag).remove(entity);

        if (this.getEntitiesByTag().get(tag).isEmpty()) {
          this.getEntitiesByTag().remove(tag);
        }
      }
    }

    if (entity instanceof Emitter) {
      Emitter emitter = (Emitter) entity;
      this.removeEmitter(emitter);
    }

    if (entity instanceof MapArea) {
      this.mapAreas.remove(entity);
    }

    if (entity instanceof Prop) {
      this.props.remove(entity);
    }

    if (entity instanceof Creature) {
      this.creatures.remove(entity);
    }

    if (entity instanceof CollisionBox) {
      this.colliders.remove(entity);
      this.staticShadows.removeIf(x -> x.getOrigin() != null && x.getOrigin().equals(entity));
    }

    if (entity instanceof LightSource) {
      this.lightSources.remove(entity);
      this.updateLighting(entity);
    }

    if (entity instanceof Trigger) {
      this.triggers.remove(entity);
    }

    if (entity instanceof Spawnpoint) {
      this.spawnPoints.remove(entity);
    }
    if (entity instanceof SoundSource) {
      this.soundSources.remove(entity);
    }

    if (entity instanceof StaticShadow) {
      this.staticShadows.remove(entity);
      this.updateLighting(entity);
    }

    if (entity instanceof IMobileEntity) {
      this.mobileEntities.values().remove(entity);
    }

    if (entity instanceof ICombatEntity) {
      this.combatEntities.values().remove(entity);
    }

    this.unload(entity);

    this.fireEntityEvent(l -> l.entityRemoved(entity));
}
}
```
```java
class de.gurkenlabs.litiengine.physics.MovementController {
@Override
  public void update() {
    this.handleForces();
    this.handleMovement();
}
}
```
```java
class de.gurkenlabs.litiengine.Game {
static synchronized void terminate() {
    if (!initialized) {
      return;
    }

    hasStarted = false;
    initialized = false;

    config().save();
    gameLoop.terminate();
    tweenEngine.terminate();
    soundEngine.terminate();

    world().clear();

    for (final GameListener listener : gameListeners) {
      try {
        listener.terminated();
      } catch (Exception e) {
        log().log(Level.WARNING, "game listener threw an exception during shutdown", e);
      }
    }

    gameLoop = null;
    screenManager = null;
    gameWindow = null;
}public static synchronized void start() {
    if (!initialized) {
      throw new IllegalStateException(
          "The game cannot be started without being first initialized. Call Game.init(...) before Game.start().");
    }

    gameLoop.start();
    tweenEngine.start();
    soundEngine.start();

    for (final GameListener listener : gameListeners) {
      listener.started();
    }

    hasStarted = true;
}public static synchronized void init(String... args) {
    if (initialized) {
      log().log(Level.INFO, "The game has already been initialized.");
      return;
    }

    log.init();
    handleCommandLineArguments(args);

    config().load();
    Locale.setDefault(new Locale(config().client().getCountry(), config().client().getLanguage()));

    gameLoop = new GameLoop("Main Update Loop", config().client().getMaxFps());
    loop().attach(physics());
    loop().attach(world());

    // setup default exception handling for render and update loop
    setUncaughtExceptionHandler(
        new DefaultUncaughtExceptionHandler(config().client().exitOnError()));

    screenManager = new ScreenManager();
    gameWindow = new GameWindow();

    // initialize  the game window
    window().init();
    world.setCamera(new Camera());

    for (GameListener listener : gameListeners) {
      listener.initialized(args);
    }

    if (!isInNoGUIMode()) {
      window().getRenderComponent().onRendered(g -> metrics().render(g));

      graphics()
          .addEntityRenderedListener(
              e -> DebugRenderer.renderEntityDebugInfo(e.getGraphics(), e.getEntity()));

      window().getRenderComponent().onFpsChanged(fps -> metrics().setFramesPerSecond(fps));
      window()
          .setIcons(
              Arrays.asList(
                  Resources.images().get("liti-logo-x16.png"),
                  Resources.images().get("liti-logo-x20.png"),
                  Resources.images().get("liti-logo-x32.png"),
                  Resources.images().get("liti-logo-x48.png")));

      Input.keyboard()
          .onKeyTyped(
              KeyEvent.VK_PRINTSCREEN,
              key -> {
                // don't take a screenshot if a modifier is active
                if (key.getModifiers() != 0) {
                  return;
                }

                window().getRenderComponent().takeScreenshot();
              });
    }

    Runtime.getRuntime().addShutdownHook(new Thread(Game::terminate, "Shutdown"));

    initialized = true;
}
}
```


Response Format:
Provide the answer in **XML format** as follows:

#### If the method **cannot** return `null` at the specific call site:
```xml
<response>
  <reason><![CDATA[EXPLAIN WHY THE INVOCATION Game.loop() RESULT CANNOT BE NULL.]]></reason>
  <value>NO</value>
</response>

#### If the method can return null at the specific call site:
<response>
  <reason><![CDATA[EXPLAIN WHY THE INVOCATION Game.loop() RESULT CAN BE NULL.]]></reason>
  <value>YES</value>
</response>

#### If you are unsure or If there are any methods that directly or indirectly affect the return value and are not fully disclosed, request their declarations first, in the following format:
<response>
  <reason><![CDATA[EXPLAIN WHY THIS METHOD DECLARATION IS NECESSARY AND WHY YOU CANNOT MAKE A CONFIDENT DECISION WITHOUT IT]]></reason>
  <success>false</success>
  <methods>
    <method>methodName</method>
  </methods>
</response>

Additional Notes:
Be precise in your reasoning.
If a method’s return value depends on another method not provided, request its declaration before making a conclusion.
If the method can return null in this case but not in others, explain why it happens specifically for this call.

---ChatGPT.sendRequestToOpenAI---
Retrieving response from cache
---Response.<init>---
Creating Response:
```xml
<response>
  <reason><![CDATA[The method `Game.loop()` returns the static field `gameLoop`, which is initialized in the `Game.init(String... args)` method. In this method, a new `GameLoop` object is instantiated and assigned to `gameLoop`. Since `init()` must be called before `start()`, which is implied by the requirement of initializing the game, the `gameLoop` is guaranteed to be non-null during the lifetime of the game execution where `Game.loop()` is called. The absence of any code that could set `gameLoop` to null after its initialization ensures that `Game.loop()` cannot return null.]]></reason>
  <value>NO</value>
</response>
```
---Response.<init>---
Response created:
Disagreement: The method `Game.loop()` returns the static field `gameLoop`, which is initialized in the `Game.init(String... args)` method. In this method, a new `GameLoop` object is instantiated and assigned to `gameLoop`. Since `init()` must be called before `start()`, which is implied by the requirement of initializing the game, the `gameLoop` is guaranteed to be non-null during the lifetime of the game execution where `Game.loop()` is called. The absence of any code that could set `gameLoop` to null after its initialization ensures that `Game.loop()` cannot return null.
---AdvancedNullAwayCodeFix.resolveMethodDereferenceError---
Method is not returning nullable on call site. Injecting suppression annotation.
---AdvancedNullAwayCodeFix.constructCastToNonnullChange---
Constructing cast to nonnull change for reason: The method `Game.loop()` returns the static field `gameLoop`, which is initialized in the `Game.init(String... args)` method. In this method, a new `GameLoop` object is instantiated and assigned to `gameLoop`. Since `init()` must be called before `start()`, which is implied by the requirement of initializing the game, the `gameLoop` is guaranteed to be non-null during the lifetime of the game execution where `Game.loop()` is called. The absence of any code that could set `gameLoop` to null after its initialization ensures that `Game.loop()` cannot return null.
---ChatGPT.ask---
Asking ChatGPT:
For the reason you mentioned earlier:

"The method `Game.loop()` returns the static field `gameLoop`, which is initialized in the `Game.init(String... args)` method. In this method, a new `GameLoop` object is instantiated and assigned to `gameLoop`. Since `init()` must be called before `start()`, which is implied by the requirement of initializing the game, the `gameLoop` is guaranteed to be non-null during the lifetime of the game execution where `Game.loop()` is called. The absence of any code that could set `gameLoop` to null after its initialization ensures that `Game.loop()` cannot return null."

in the method below, the expression Game.loop() is not nullable at the point it is used.

```java
public void handleMovement() {
    if (!this.isMovementAllowed()) {
      this.velocity = 0;
      return;
    }

    // max distance an entity can travel within one tick
    final double maxPixelsPerTick = this.getEntity().getTickVelocity();
    final double deltaTime = Game.loop().getDeltaTime() * Game.loop().getTimeScale();

    final double acceleration =
        this.getEntity().getAcceleration() == 0
            ? maxPixelsPerTick
            : deltaTime / this.getEntity().getAcceleration() * maxPixelsPerTick;
    final double deceleration =
        this.getEntity().getDeceleration() == 0
            ? this.getVelocity()
            : deltaTime / this.getEntity().getDeceleration() * maxPixelsPerTick;

    double dx = this.getDx();
    double dy = this.getDy();
    this.setDx(0);
    this.setDy(0);

    final double deltaVelocity =
        Math.min(Math.sqrt(Math.pow(dx, 2) + Math.pow(dy, 2)), acceleration);
    if (deltaVelocity != 0) {
      double newVelocity = this.getVelocity() + deltaVelocity;
      this.setVelocity(newVelocity);
    } else {
      final double newVelocity = Math.max(0, this.getVelocity() - deceleration);
      this.setVelocity(newVelocity);
      dx = GeometricUtilities.getDeltaX(this.moveAngle);
      dy = GeometricUtilities.getDeltaY(this.moveAngle);
    }

    if (this.getVelocity() == 0) {
      this.moveAngle = 0;
      return;
    }

    // actually move entity
    this.moveEntity(dx, dy);
}
```
Please Summarize the reason in max 5 words and rewrite the method so that at the line "    final double deltaTime = Game.loop().getDeltaTime() * Game.loop().getTimeScale();", at the occurrence of: "Game.loop()" is replaced with `NullabilityUtil.castToNonnull(Game.loop(), summary of reason)`
Replace "REASON" with the exact reason summary I provide to you (maximum 5 words), not with a generic explanation like "checked to be nonnull".
see the example below, for expression `foo.getBar()`, to wrap it with `NullabilityUtil.castToNonnull(foo.getBar(), "reason")`.

```java
public t(){
    String l = foo.getBar();
}
```

will be:
```java
public t(){
    String l = NullabilityUtil.castToNonnull(foo.getBar(), "checked to be nonnull");
}
```

### Instructions:

Do not import any additional classes.

Do not add Java comments.

Only modify relevant lines as required.

Return only the modified method wrapped in the XML format shown below.

Place the Java code inside the <code> tag using a CDATA block with ```java formatting.

Just give me the fixed code snippet in XML format in <response> tag like the example below. I will apply the fix to my codebase. Do not import any additional libraries or classes or add java comments. If you can provide the fixed code snippet, please provide it in the following format and place the code snippet in the <code> tag within ```java block.
<response>
  <success>true</success>
  <code><![CDATA[
  ```java
  Your fixed code snippet here
  ```
    ]]>
  </code>
</response>

---ChatGPT.sendRequestToOpenAI---
Sending request to OpenAI...
---ChatGPT.sendRequestToOpenAI---
Response received from OpenAI.
---Response.<init>---
Creating Response:
```xml
<response>
  <success>true</success>
  <code><![CDATA[
  ```java
public void handleMovement() {
    if (!this.isMovementAllowed()) {
      this.velocity = 0;
      return;
    }

    final double maxPixelsPerTick = this.getEntity().getTickVelocity();
    final double deltaTime = NullabilityUtil.castToNonnull(Game.loop(), "initialized before use").getDeltaTime() * NullabilityUtil.castToNonnull(Game.loop(), "initialized before use").getTimeScale();

    final double acceleration =
        this.getEntity().getAcceleration() == 0
            ? maxPixelsPerTick
            : deltaTime / this.getEntity().getAcceleration() * maxPixelsPerTick;
    final double deceleration =
        this.getEntity().getDeceleration() == 0
            ? this.getVelocity()
            : deltaTime / this.getEntity().getDeceleration() * maxPixelsPerTick;

    double dx = this.getDx();
    double dy = this.getDy();
    this.setDx(0);
    this.setDy(0);

    final double deltaVelocity =
        Math.min(Math.sqrt(Math.pow(dx, 2) + Math.pow(dy, 2)), acceleration);
    if (deltaVelocity != 0) {
      double newVelocity = this.getVelocity() + deltaVelocity;
      this.setVelocity(newVelocity);
    } else {
      final double newVelocity = Math.max(0, this.getVelocity() - deceleration);
      this.setVelocity(newVelocity);
      dx = GeometricUtilities.getDeltaX(this.moveAngle);
      dy = GeometricUtilities.getDeltaY(this.moveAngle);
    }

    if (this.getVelocity() == 0) {
      this.moveAngle = 0;
      return;
    }

    this.moveEntity(dx, dy);
}
  ```
    ]]>
  </code>
</response>
```
---Response.<init>---
Response created:
public void handleMovement() {
    if (!this.isMovementAllowed()) {
      this.velocity = 0;
      return;
    }

    final double maxPixelsPerTick = this.getEntity().getTickVelocity();
    final double deltaTime = NullabilityUtil.castToNonnull(Game.loop(), "initialized before use").getDeltaTime() * NullabilityUtil.castToNonnull(Game.loop(), "initialized before use").getTimeScale();

    final double acceleration =
        this.getEntity().getAcceleration() == 0
            ? maxPixelsPerTick
            : deltaTime / this.getEntity().getAcceleration() * maxPixelsPerTick;
    final double deceleration =
        this.getEntity().getDeceleration() == 0
            ? this.getVelocity()
            : deltaTime / this.getEntity().getDeceleration() * maxPixelsPerTick;

    double dx = this.getDx();
    double dy = this.getDy();
    this.setDx(0);
    this.setDy(0);

    final double deltaVelocity =
        Math.min(Math.sqrt(Math.pow(dx, 2) + Math.pow(dy, 2)), acceleration);
    if (deltaVelocity != 0) {
      double newVelocity = this.getVelocity() + deltaVelocity;
      this.setVelocity(newVelocity);
    } else {
      final double newVelocity = Math.max(0, this.getVelocity() - deceleration);
      this.setVelocity(newVelocity);
      dx = GeometricUtilities.getDeltaX(this.moveAngle);
      dy = GeometricUtilities.getDeltaY(this.moveAngle);
    }

    if (this.getVelocity() == 0) {
      this.moveAngle = 0;
      return;
    }

    this.moveEntity(dx, dy);
}
---ChatGPT.fixDereferenceByAddingCastToNonnull---
Fixing the error by adding castToNonnull
---AdvancedNullAwayCodeFix.fixTriggeredErrorsForLocation---
Resolving unresolvable error for triggered error: Type='DEREFERENCE_NULLABLE', message='dereferenced expression Game.loop() is @Nullable'
/home/nima/Developer/nullness-benchmarks/litiengine/src/de/gurkenlabs/litiengine/graphics/FreeFlightCamera.java:41
    Game.loop().attach(this);
---AdvancedNullAwayCodeFix.fix---
Fixing error: Type='DEREFERENCE_NULLABLE', message='dereferenced expression Game.loop() is @Nullable'
/home/nima/Developer/nullness-benchmarks/litiengine/src/de/gurkenlabs/litiengine/graphics/FreeFlightCamera.java:41
    Game.loop().attach(this);
---AdvancedNullAwayCodeFix.resolveDereferenceError---
Resolving dereference error: Type='DEREFERENCE_NULLABLE', message='dereferenced expression Game.loop() is @Nullable'
/home/nima/Developer/nullness-benchmarks/litiengine/src/de/gurkenlabs/litiengine/graphics/FreeFlightCamera.java:41
    Game.loop().attach(this);
---AdvancedNullAwayCodeFix.resolveDereferenceError---
Checking nullability possibility at error point
---ChatGPT.checkNullabilityPossibilityAtErrorPoint---
Asking if the expression can be null at error point point
---ChatGPT.ask---
Asking ChatGPT:
In the method below, is there a possibility that the expression "Game.loop()" at line "Game.loop().attach(this);" is null?
public FreeFlightCamera(final Point2D focus) {
    this.setFocus(focus);
    this.velocity = DEFAULT_SCROLL_PIXELS_PER_SECOND;
    this.scrollPadding = DEFAULT_SCROLL_PADDING;
    this.setClampToMap(true);

    Game.loop().attach(this);
}
Give a single-word answer in XML format. If it is possible for the expression to be null, respond with:
```xml
<response>
    <reason><![CDATA[YOUR REASON]]></reason>
    <value>YES</value>
</response>
```
If it is not possible for the expression to be null, respond with:
```xml
<response>
    <reason><![CDATA[YOUR REASON]]></reason>
    <value>NO</value>
</response>
```
If you are unsure or need more information, respond with where you can ask for more details or what specific information you need.

If additional information is required, list each request inside a `<request>` tag. If no additional information is needed, omit the `<requests>` section.

Respond with:
```xml
<response>
    <reason><![CDATA[YOUR REASON]]></reason>
    <value>UNKNOWN</value>
    <!-- Include <requests> only if additional information is needed -->
    <requests>
        <request><![CDATA[YOUR REQUEST 1]]></request>
        <request><![CDATA[YOUR REQUEST 2]]></request>
    </requests>
</response>
```
---ChatGPT.sendRequestToOpenAI---
Sending request to OpenAI...
---ChatGPT.sendRequestToOpenAI---
Response received from OpenAI.
---Response.<init>---
Creating Response:
```xml
<response>
    <reason><![CDATA[The possibility of Game.loop() being null largely depends on how the Game.loop() method is implemented. Without additional information about the implementation of the Game class and its loop() method, specifically whether null can be returned, it is not possible to definitively determine the result.]]></reason>
    <value>UNKNOWN</value>
    <requests>
        <request><![CDATA[Details about the Game class and its loop() method implementation.]]></request>
        <request><![CDATA[Information on whether the Game class has been properly initialized before the FreeFlightCamera constructor is called.]]></request>
    </requests>
</response>
```
---Response.<init>---
Response created:
Unknown: The possibility of Game.loop() being null largely depends on how the Game.loop() method is implemented. Without additional information about the implementation of the Game class and its loop() method, specifically whether null can be returned, it is not possible to definitively determine the result.
---AdvancedNullAwayCodeFix.resolveMethodDereferenceError---
Resolving method dereference error.
---AdvancedNullAwayCodeFix.resolveMethodDereferenceError---
Method is in annotated package. Checking if the method is returning nullable.
---AdvancedNullAwayCodeFix.investigateMethodReturnNullability---
Checking if the method is returning nullable.
---ChatGPT.checkIfMethodIsReturningNullable---
Asking if the method is returning nullable: loop()
---ChatGPT.ask---
Asking ChatGPT:
In the method below, is there a possibility that the method returns null based only on its body? Consider the following points:

- The method may have multiple return paths; consider all return statements.
- If the method calls another method, do not assume its return value unless its full declaration is provided. Request its declaration if needed.
- The method may throw an exception instead of returning null. An exception path should not be considered a null return.
- Ensure you request the declarations of any methods whose return values directly or indirectly impact this method’s return value before making a conclusion.
- Carefully analyze all conditions and prior operations that may guarantee a non-null return value.

@Nullable public static IGameLoop loop() {
    return gameLoop;
}

Here are the method definitions in addition to the method inquired:

Depth: 0
```java
class de.gurkenlabs.litiengine.Game {
@Nullable public static IGameLoop loop() {
    return gameLoop;
}
}
```


Response Format:
Provide the answer in **XML format** as follows:

#### If the method **cannot** return `null`:
```xml
<response>
  <reason><![CDATA[EXPLAIN WHY THE METHOD CANNOT RETURN NULL]]></reason>
  <value>NO</value>
</response>
```

#### If the method can return null:
```xml
<response>
  <reason><![CDATA[EXPLAIN WHY THE METHOD CAN RETURN NULL]]></reason>
  <value>YES</value>
</response>
```

#### If you are unsure or need more information, respond with where you can ask for more details or what specific information you need.

#### If you are unsure or If there are any methods that directly or indirectly affect the return value and are not fully disclosed, request their declarations first, in the following format:
<response>
  <reason><![CDATA[YOUR REASON]]></reason>
  <value>UNKNOWN</value>
  <methods>
    <method>methodName</method>
  </methods>
</response>

If additional information is required other than method declaration, list each request inside a `<request>` tag. If no additional information is needed, omit the `<requests>` section.

Respond with:
```xml
<response>
    <reason><![CDATA[YOUR REASON]]></reason>
    <value>UNKNOWN</value>
    <!-- Include <requests> only if additional information is needed -->
    <requests>
        <request><![CDATA[YOUR REQUEST 1]]></request>
        <request><![CDATA[YOUR REQUEST 2]]></request>
    </requests>
</response>
```

Additional Notes:
Be precise in your reasoning.
If a method’s return value depends on another method not provided, request its declaration before making a conclusion.
If the method can return null in some cases but not others, explain under what conditions it can happen.

---ChatGPT.sendRequestToOpenAI---
Retrieving response from cache
---Response.<init>---
Creating Response:
```xml
<response>
  <reason><![CDATA[The method `loop` returns the variable `gameLoop`. Without the initialization or assignment details of `gameLoop`, it's unclear whether it can be null. The possibility of `gameLoop` being uninitialized or set to null elsewhere in the program means `loop` could potentially return null. Further information on `gameLoop` is required.]]></reason>
  <value>UNKNOWN</value>
  <requests>
    <request><![CDATA[Please provide the declaration and initialization of the variable `gameLoop` in the class `de.gurkenlabs.litiengine.Game`.]]></request>
  </requests>
</response>
```
---Response.<init>---
Response created:
Unknown: The method `loop` returns the variable `gameLoop`. Without the initialization or assignment details of `gameLoop`, it's unclear whether it can be null. The possibility of `gameLoop` being uninitialized or set to null elsewhere in the program means `loop` could potentially return null. Further information on `gameLoop` is required.
---AdvancedNullAwayCodeFix.investigateMethodReturnNullability---
Could not determine the nullability and model did not ask for any method.
---ChatGPT.checkIfMethodIsReturningNullableOnCallSite---
Asking if the method is returning nullable on the call site: Game.loop()
---ChatGPT.ask---
Asking ChatGPT:
In the method below, is there a possibility that the method returns null at the given call site?

```java
@Nullable public static IGameLoop loop() {
    return gameLoop;
}
```

## Guidelines:
- The method may have multiple return paths; consider all return statements.
- If the method calls another method, do not assume its return value unless its full declaration is provided. Request its declaration if needed.
- The method may throw an exception instead of returning null. An exception path should not be considered a null return.
- Ensure you request the declarations of any methods whose return values directly or indirectly impact this method’s return value before making a conclusion.
- If the method returns a value that is determined by a parameter, evaluate based on the actual argument at the given call site.
- Analyze based only on the specific invocation provided. Do not generalize to all possible inputs.- If the return value is guaranteed to be non-null at the call site, the answer should be a definitive NO.
- Do not generalize based on all possible inputs—your answer must be based only on the given invocation.
- Focus only on the given call site, not all possible invocations.

### call site:
Game.loop()

Here are the method definitions and the call chain for this method, showing the sequence of calls from the method to its callers at each depth level:

Depth: 0
```java
class de.gurkenlabs.litiengine.Game {
@Nullable public static IGameLoop loop() {
    return gameLoop;
}
}
```
Depth: 1
```java
class de.gurkenlabs.litiengine.environment.GameWorld {
public void loadEnvironment(@Nullable final Environment env) {
    Lock lock = Game.loop().getLock();
    lock.lock();
    try {
      unloadEnvironment();
      this.environment = env;
      if (env != null) {
        this.addEnvironment(env);

        if (env.getGravity() == 0 && this.gravity() != 0) {
          env.setGravity(this.gravity());
        }

        env.load();
        for (final EnvironmentLoadedListener listener : this.loadedListeners) {
          listener.loaded(env);
        }

        // call map specific listeners
        String mapName = getMapName(env);
        if (mapName != null && this.environmentLoadedListeners.containsKey(mapName)) {

          // for the default camera we center the camera on the environment
          if (this.camera().getClass().equals(Camera.class)) {
            camera().setFocus(env.getCenter());
          }

          for (EnvironmentLoadedListener listener : this.environmentLoadedListeners.get(mapName)) {
            listener.loaded(env);
          }
        }
      }
    } finally {
      lock.unlock();
    }
}public void setCamera(@Nullable final ICamera cam) {
    if (this.camera() != null) {
      Game.loop().detach(camera);
    }

    camera = cam;

    if (cam != null && !Game.isInNoGUIMode()) {
      Game.loop().attach(cam);
      cam.updateFocus();
    }
}
}
```
```java
class de.gurkenlabs.litiengine.entities.behavior.EntityNavigator {
public EntityNavigator(final IMobileEntity entity, final PathFinder pathFinder) {
    this.cancelNavigationConditions = new CopyOnWriteArrayList<>();
    this.listeners = new CopyOnWriteArrayList<>();
    this.entity = entity;
    this.pathFinder = pathFinder;
    this.setAcceptableError(DEFAULT_ACCEPTABLE_ERROR);
    Game.loop().attach(this);
}
}
```
```java
class de.gurkenlabs.litiengine.GameWindow {
private static void initializeWindowEventListeners(Window window) {

    window.addWindowStateListener(
        e -> {
          if (e.getNewState() == Frame.ICONIFIED) {
            Game.loop().setTickRate(ICONIFIED_MAX_FPS);
          } else {
            Game.loop().setTickRate(Game.config().client().getMaxFps());
          }
        });

    window.addWindowFocusListener(
        new WindowFocusListener() {
          @Override
          public void windowLostFocus(WindowEvent e) {
            if (Game.config().graphics().reduceFramesWhenNotFocused()) {
              Game.loop().setTickRate(NONE_FOCUS_MAX_FPS);
            }
          }

          @Override
          public void windowGainedFocus(WindowEvent e) {
            Game.loop().setTickRate(Game.config().client().getMaxFps());
          }
        });

    window.addWindowListener(
        new WindowAdapter() {
          @Override
          public void windowClosing(final WindowEvent event) {
            Game.exit();
          }
        });
}
}
```
```java
class de.gurkenlabs.litiengine.gui.screens.ScreenManager {
public void display(@Nullable final Screen screen) {
    if (Game.hasStarted() && Game.time().since(this.lastScreenChange) < this.getChangeCooldown()) {
      log.log(
          Level.INFO,
          "Skipping displaying of screen {0} because screen changing is currently on cooldown.",
          screen != null ? screen.getName() : "");
      return;
    }

    final Screen previous = this.current();
    if (previous != null) {
      previous.suspend();
    }

    if (screen != null && !this.screens.contains(screen)) {
      this.screens.add(screen);
    }

    this.currentScreen = screen;
    if (!Game.isInNoGUIMode() && this.current() != null) {
      this.current().prepare();
    }

    this.lastScreenChange = Game.loop().getTicks();

    final ScreenChangedEvent event = new ScreenChangedEvent(this.current(), previous);
    for (final ScreenChangedListener listener : this.screenChangedListeners) {
      listener.changed(event);
    }
}
}
```
```java
class de.gurkenlabs.litiengine.abilities.effects.Effect {
@Override
  public void update() {

    for (final Iterator<EffectApplication> iterator = this.getActiveAppliances().iterator();
        iterator.hasNext(); ) {
      final EffectApplication appliance = iterator.next();
      // if the effect duration is reached
      if (this.hasEnded(appliance)) {

        iterator.remove();
        this.cease(appliance);
      }
    }

    // 4. unregister if all appliances are finished
    if (this.getActiveAppliances().isEmpty()) {
      Game.loop().detach(this);
    }
}public void apply(final Shape impactArea) {
    final List<ICombatEntity> affected = this.lookForAffectedEntities(impactArea);
    for (final ICombatEntity affectedEntity : affected) {
      this.apply(affectedEntity);
    }

    this.appliances.add(new EffectApplication(affected, impactArea));

    // if it is the first appliance -> register for update
    if (this.appliances.size() == 1) {
      Game.loop().attach(this);
    }
}
}
```
```java
class de.gurkenlabs.litiengine.GameTime {
public long toTicks(final int milliseconds) {
    return this.toTicks(milliseconds, Game.loop().getTickRate());
}public long since(final long tick) {
    return toMilliseconds(Game.loop().getTicks() - tick);
}public long now() {
    return Game.loop().getTicks();
}public long sinceGameStart() {
    return this.toMilliseconds(Game.loop().getTicks());
}@Override
  public void loaded(Environment environment) {
    environmentLoaded = Game.loop().getTicks();
}public long toMilliseconds(final long ticks) {
    return this.toMilliseconds(ticks, Game.loop().getTickRate());
}
}
```
```java
class de.gurkenlabs.litiengine.GameMetrics {
@Override
  public void render(final Graphics2D g) {
    this.updateMetrics();

    if (!Game.config().client().showGameMetrics()) {
      return;
    }

    this.currentOffsetY = 0;

    g.setColor(this.renderColor);

    // render client metrics
    this.drawTitle(g, "[client]");
    this.drawMetric(g, "fps       : " + this.getFramesPerSecond());
    this.drawMetric(g, "max fps   : " + this.maxFramesPerSecond);
    this.drawMetric(g, "updatables: " + Game.loop().getUpdatableCount());

    // render jvm metrics if debug is enabled
    if (Game.config().debug().isDebugEnabled()) {
      this.drawTitle(g, "[jvm]");
      this.drawMetric(g, "java      : " + this.javaVersion);
      this.drawMetric(g, "memory    : " + String.format("%-5.5s", this.usedMemory) + " MB");
      this.drawMetric(g, "threads   : " + Thread.activeCount());
    }

    // render rendering metrics
    if (!this.renderMetrics.isEmpty()) {
      this.drawTitle(g, "[update]");

      for (RenderMetrics metric : this.renderMetrics) {
        this.drawMetric(g, metric.toString());
      }

      this.renderMetrics.clear();
    }
}
}
```
```java
class de.gurkenlabs.litiengine.graphics.emitters.Emitter {
public void deactivate() {
    if (!this.activated) {
      return;
    }

    this.activated = false;
    this.getParticles().clear();
    this.aliveTime = 0;
    this.activationTick = 0;
    this.lastSpawn = 0;
    Game.loop().detach(this);
}public void activate() {
    if (this.activated) {
      return;
    }

    this.activated = true;
    this.activationTick = Game.time().now();
    Game.loop().attach(this);
}@Override
  public void update() {
    if (this.isPaused()) {
      return;
    }

    // clear particles if the effect time to life is reached
    if (this.isFinished()) {
      for (EmitterFinishedListener listener : this.finishedListeners) {
        listener.finished(this);
      }

      this.delete();
      return;
    }

    final float updateRatio = (float) this.data().getUpdateRate() / Game.loop().getTickRate();
    for (final Particle p : this.getParticles().stream().collect(Collectors.toList())) {
      if (this.particleCanBeRemoved(p)) {
        // remove dead particles
        this.particles.remove(p);
        continue;
      }

      p.update(this.getOrigin(), updateRatio);
    }

    this.aliveTime = Game.time().since(this.activationTick);
    if ((this.data().getSpawnRate() == 0
        || Game.time().since(this.lastSpawn) >= this.data().getSpawnRate())) {
      this.lastSpawn = Game.time().now();
      this.spawnParticle();
    }
}
}
```
```java
class de.gurkenlabs.litiengine.entities.behavior.IBehaviorController {
public default void attach() {
    Game.loop().attach(this);
}public default void detach() {
    Game.loop().detach(this);
}
}
```
```java
class de.gurkenlabs.litiengine.abilities.AbilityExecution {
AbilityExecution(final Ability ability) {
    this.appliedEffects = new CopyOnWriteArrayList<>();
    this.ability = ability;
    this.executionTicks = Game.time().now();
    this.impactArea = ability.calculateImpactArea();
    this.castLocation = ability.getExecutor().getCenter();
    Game.loop().attach(this);
}@Override
  public void update() {
    // if there a no effects to apply -> unregister this instance and we're done
    if (this.getAbility().getEffects().isEmpty()
        || this.getAbility().getEffects().size() == this.getAppliedEffects().size()) {
      Game.loop().detach(this);
      return;
    }

    // handle all effects from the ability that were not applied yet
    for (final Effect effect : this.getAbility().getEffects()) {
      // if the ability was not executed yet or the delay of the effect is not
      // yet reached
      if (this.getAppliedEffects().contains(effect)
          || Game.time().since(this.getExecutionTicks()) < effect.getDelay()) {
        continue;
      }

      effect.apply(this.getExecutionImpactArea());
      this.getAppliedEffects().add(effect);
    }
}
}
```
```java
class de.gurkenlabs.litiengine.GameWindow$3 {
@Override
          public void windowGainedFocus(WindowEvent e) {
            Game.loop().setTickRate(Game.config().client().getMaxFps());
}@Override
          public void windowLostFocus(WindowEvent e) {
            if (Game.config().graphics().reduceFramesWhenNotFocused()) {
              Game.loop().setTickRate(NONE_FOCUS_MAX_FPS);
            }
}
}
```
```java
class de.gurkenlabs.litiengine.environment.EntitySpawner {
protected void spawnNewEntities() {
    if (this.getSpawnMode() != SpawnMode.CUSTOMSPAWNPOINTS && this.getSpawnPoints().isEmpty()) {
      return;
    }

    switch (this.getSpawnMode()) {
      case ALLSPAWNPOINTS:
        for (int i = 0; i < this.getSpawnPoints().size(); i++) {
          final int index = i;
          Game.loop()
              .perform(
                  this.getSpawnDelay() + this.getSpawnDelay() * i,
                  () -> this.spawn(this.getSpawnPoints().get(index), this.getSpawnAmount()));
        }
        break;
      case ONERANDOMSPAWNPOINT:
        this.spawn(Game.random().choose(this.getSpawnPoints()), this.getSpawnAmount());
        break;
      case RANDOMSPAWNPOINTS:
        for (int i = 0; i < this.getSpawnAmount(); i++) {
          Game.loop()
              .perform(
                  this.getSpawnDelay() + this.getSpawnDelay() * i,
                  () -> this.spawn(Game.random().choose(this.getSpawnPoints()), 1));
        }
        break;
      case CUSTOMSPAWNPOINTS:
        List<Spawnpoint> spawnPoints =
            this.customSpawnpoints != null
                ? this.customSpawnpoints.apply(this)
                : this.getCustomSpawnpoints();

        int index = 0;
        for (Spawnpoint spawn : spawnPoints) {
          Game.loop()
              .perform(
                  this.getSpawnDelay() + this.getSpawnDelay() * index, () -> this.spawn(spawn, 1));
          index++;
        }
        break;
      default:
        break;
    }
}
}
```
```java
class de.gurkenlabs.litiengine.tweening.TweenEngine {
@Override
  public void start() {
    Game.loop().attach(this);
}@Override
  public void terminate() {
    Game.loop().detach(this);
}
}
```
```java
class de.gurkenlabs.litiengine.gui.SpeechBubble {
public void hide() {
    Game.world().environment().removeRenderable(this);
    Game.loop().detach(this);
    if (activeSpeechBubbles.get(this.getEntity()) != null
        && activeSpeechBubbles.remove(this.getEntity()).equals(this)) {
      activeSpeechBubbles.remove(this.getEntity());
    }

    for (SpeechBubbleListener listener : this.listeners) {
      listener.hidden();
    }
}private SpeechBubble(
      final IEntity entity,
      final String text,
      @Nullable SpeechBubbleAppearance appearance,
      @Nullable Font font) {
    if (appearance == null) {
      this.appearance = DEFAULT_APPEARANCE;
    } else {
      this.appearance = appearance;
    }

    final SpeechBubble active = activeSpeechBubbles.get(entity);
    if (active != null) {
      active.hide();
    }
    this.setFont(font);

    this.textBoxWidth = (float) (entity.getWidth() * 4);
    this.entity = entity;

    this.currentText = text;
    this.currentTextDisplayTime = DISPLAYTIME_MIN + text.length() * DISPLAYTIME_PER_LETTER;

    this.lastTextDisplay = Game.time().now();
    this.createBubbleImage();
    entity.getEnvironment().add(this, RenderType.UI);
    Game.loop().attach(this);
    activeSpeechBubbles.put(entity, this);
}
}
```
```java
class de.gurkenlabs.litiengine.entities.Prop {
private void updateAnimationController() {
    IEntityAnimationController<?> controller = this.createAnimationController();
    this.getControllers().addController(controller);
    if (Game.world().environment() != null && Game.world().environment().isLoaded()) {
      Game.loop().attach(controller);
    }
}
}
```
```java
class de.gurkenlabs.litiengine.graphics.FreeFlightCamera {
public FreeFlightCamera(final Point2D focus) {
    this.setFocus(focus);
    this.velocity = DEFAULT_SCROLL_PIXELS_PER_SECOND;
    this.scrollPadding = DEFAULT_SCROLL_PADDING;
    this.setClampToMap(true);

    Game.loop().attach(this);
}private void handleFreeFlightCamera() {
    if (Game.world().environment() == null || Game.world().environment().getMap() == null) {
      return;
    }

    final Point2D mouseLocation = Input.mouse().getLocation();

    final double scrollSpeed =
        this.getVelocity()
            / (double) Game.loop().getTickRate()
            * Game.config().input().getMouseSensitivity();

    double x = this.getFocus().getX();
    double y = this.getFocus().getY();

    double deltaX = 0;
    if (mouseLocation.getX() < this.getScrollPadding()) {
      deltaX -= scrollSpeed;
    } else if (Game.window().getResolution().getWidth() - mouseLocation.getX()
        < this.getScrollPadding()) {
      deltaX += scrollSpeed;
    }

    double deltaY = 0;
    if (mouseLocation.getY() < this.getScrollPadding()) {
      deltaY -= scrollSpeed;
    } else if (Game.window().getResolution().getHeight() - mouseLocation.getY()
        < this.getScrollPadding()) {
      deltaY += scrollSpeed;
    }

    x += deltaX;
    y += deltaY;

    this.setFocus(new Point2D.Double(x, y));
}
}
```
```java
class de.gurkenlabs.litiengine.environment.Environment {
private static void dispose(final Collection<? extends IEntity> entities) {
    for (final IEntity entity : entities) {
      if (entity instanceof IUpdateable) {
        Game.loop().detach((IUpdateable) entity);
      }

      entity.detachControllers();
    }
}private static void loadUpdatableOrEmitterEntity(IEntity entity) {
    if (entity instanceof Emitter) {
      final Emitter emitter = (Emitter) entity;
      if (emitter.isActivateOnInit()) {
        emitter.activate();
      }
    } else if (entity instanceof IUpdateable) {
      Game.loop().attach((IUpdateable) entity);
    }
}private void unload(final IEntity entity) {
    // 1. remove from physics engine
    if (entity instanceof ICollisionEntity) {
      Game.physics().remove((ICollisionEntity) entity);
    }

    // 2. unregister from update
    if (entity instanceof IUpdateable) {
      Game.loop().detach((IUpdateable) entity);
    }

    if (entity instanceof IMobileEntity) {
      this.removeGravity((IMobileEntity) entity);
    }

    // 3. detach all controllers
    entity.detachControllers();

    if (entity instanceof Emitter) {
      Emitter em = (Emitter) entity;
      em.deactivate();
    }

    if (this.loaded && (entity instanceof LightSource || entity instanceof StaticShadow)) {
      this.updateLighting(entity);
    }

    entity.removed(this);
}
}
```
```java
class de.gurkenlabs.litiengine.graphics.animation.Animation {
@Override
  public void update() {
    // do nothing if the animation is not playing or the current keyframe is not finished
    if (!this.isPlaying()
        || Game.time().since(this.lastFrameUpdate) < this.getCurrentKeyFrame().getDuration()) {
      return;
    }

    // if we are not looping and the last keyframe is finished, we terminate the animation
    if (!this.isLooping() && this.isLastKeyFrame()) {
      this.terminate();
      return;
    }

    // make sure, we stay inside the keyframe list
    final int newFrameIndex =
        (this.getKeyframes().indexOf(this.currentFrame) + 1) % this.getKeyframes().size();
    final KeyFrame previousFrame = this.currentFrame;
    this.currentFrame = this.getKeyframes().get(newFrameIndex);

    for (KeyFrameListener listener : this.listeners) {
      listener.currentFrameChanged(previousFrame, this.currentFrame);
    }

    this.lastFrameUpdate = Game.loop().getTicks();
}public void restart() {
    this.currentFrame = this.firstFrame;
    this.lastFrameUpdate = Game.loop().getTicks();
}
}
```
```java
class de.gurkenlabs.litiengine.physics.MovementController {
@Override
  public void attach() {
    Game.loop().attach(this);
}private void handleForces() {
    // clean up forces
    this.activeForces.forEach(
        x -> {
          if (x.hasEnded()) {
            this.activeForces.remove(x);
          }
        });

    if (this.activeForces.isEmpty()) {
      return;
    }

    // disable turn-on-move for force handling
    boolean turn = this.getEntity().turnOnMove();
    this.getEntity().setTurnOnMove(false);
    try {
      double deltaX = 0;
      double deltaY = 0;
      for (final Force force : this.activeForces) {
        if (force.cancelOnReached() && force.hasReached(this.getEntity())) {
          force.end();
          continue;
        }

        final Point2D collisionBoxCenter = this.getEntity().getCollisionBoxCenter();
        final double angle =
            GeometricUtilities.calcRotationAngleInDegrees(collisionBoxCenter, force.getLocation());
        final double strength =
            Game.loop().getDeltaTime() * 0.001f * force.getStrength() * Game.loop().getTimeScale();
        deltaX += GeometricUtilities.getDeltaX(angle, strength);
        deltaY += GeometricUtilities.getDeltaY(angle, strength);
      }

      final Point2D target =
          new Point2D.Double(this.getEntity().getX() + deltaX, this.getEntity().getY() + deltaY);
      final boolean success = Game.physics().move(this.getEntity(), target);
      if (!success) {
        for (final Force force : this.activeForces) {
          if (force.cancelOnCollision()) {
            force.end();
          }
        }
      }
    } finally {
      this.getEntity().setTurnOnMove(turn);
    }
}@Override
  public void detach() {
    Game.loop().detach(this);
}public void handleMovement() {
    if (!this.isMovementAllowed()) {
      this.velocity = 0;
      return;
    }

    // max distance an entity can travel within one tick
    final double maxPixelsPerTick = this.getEntity().getTickVelocity();
    final double deltaTime = Game.loop().getDeltaTime() * Game.loop().getTimeScale();

    final double acceleration =
        this.getEntity().getAcceleration() == 0
            ? maxPixelsPerTick
            : deltaTime / this.getEntity().getAcceleration() * maxPixelsPerTick;
    final double deceleration =
        this.getEntity().getDeceleration() == 0
            ? this.getVelocity()
            : deltaTime / this.getEntity().getDeceleration() * maxPixelsPerTick;

    double dx = this.getDx();
    double dy = this.getDy();
    this.setDx(0);
    this.setDy(0);

    final double deltaVelocity =
        Math.min(Math.sqrt(Math.pow(dx, 2) + Math.pow(dy, 2)), acceleration);
    if (deltaVelocity != 0) {
      double newVelocity = this.getVelocity() + deltaVelocity;
      this.setVelocity(newVelocity);
    } else {
      final double newVelocity = Math.max(0, this.getVelocity() - deceleration);
      this.setVelocity(newVelocity);
      dx = GeometricUtilities.getDeltaX(this.moveAngle);
      dy = GeometricUtilities.getDeltaY(this.moveAngle);
    }

    if (this.getVelocity() == 0) {
      this.moveAngle = 0;
      return;
    }

    // actually move entity
    this.moveEntity(dx, dy);
}
}
```
```java
class de.gurkenlabs.litiengine.graphics.animation.AnimationController {
public void detach() {
    Game.loop().detach(this);
}public void attach() {
    Game.loop().attach(this);
}
}
```
```java
class de.gurkenlabs.litiengine.graphics.Camera {
@Override
  public void setZoom(final float targetZoom, final int delay) {
    if (delay == 0) {

      this.zoom = targetZoom;
      this.targetZoom = 0;
      this.zoomDelay = 0;
      this.zoomTick = 0;
      this.zoomStep = 0;

      final ZoomChangedEvent event = new ZoomChangedEvent(this, targetZoom);
      for (final ZoomChangedListener listener : this.zoomListeners) {
        listener.zoomChanged(event);
      }
    } else {
      this.zoomTick = Game.time().now();
      this.targetZoom = targetZoom;
      this.zoomDelay = delay;

      final double tickduration = 1000 / (double) Game.loop().getTickRate();
      final double tickAmount = delay / tickduration;
      final float totalDelta = this.targetZoom - this.zoom;
      this.zoomStep = tickAmount > 0 ? (float) (totalDelta / tickAmount) : totalDelta;
    }
}
}
```
```java
class de.gurkenlabs.litiengine.Game {
public static synchronized void init(String... args) {
    if (initialized) {
      log().log(Level.INFO, "The game has already been initialized.");
      return;
    }

    log.init();
    handleCommandLineArguments(args);

    config().load();
    Locale.setDefault(new Locale(config().client().getCountry(), config().client().getLanguage()));

    gameLoop = new GameLoop("Main Update Loop", config().client().getMaxFps());
    loop().attach(physics());
    loop().attach(world());

    // setup default exception handling for render and update loop
    setUncaughtExceptionHandler(
        new DefaultUncaughtExceptionHandler(config().client().exitOnError()));

    screenManager = new ScreenManager();
    gameWindow = new GameWindow();

    // initialize  the game window
    window().init();
    world.setCamera(new Camera());

    for (GameListener listener : gameListeners) {
      listener.initialized(args);
    }

    if (!isInNoGUIMode()) {
      window().getRenderComponent().onRendered(g -> metrics().render(g));

      graphics()
          .addEntityRenderedListener(
              e -> DebugRenderer.renderEntityDebugInfo(e.getGraphics(), e.getEntity()));

      window().getRenderComponent().onFpsChanged(fps -> metrics().setFramesPerSecond(fps));
      window()
          .setIcons(
              Arrays.asList(
                  Resources.images().get("liti-logo-x16.png"),
                  Resources.images().get("liti-logo-x20.png"),
                  Resources.images().get("liti-logo-x32.png"),
                  Resources.images().get("liti-logo-x48.png")));

      Input.keyboard()
          .onKeyTyped(
              KeyEvent.VK_PRINTSCREEN,
              key -> {
                // don't take a screenshot if a modifier is active
                if (key.getModifiers() != 0) {
                  return;
                }

                window().getRenderComponent().takeScreenshot();
              });
    }

    Runtime.getRuntime().addShutdownHook(new Thread(Game::terminate, "Shutdown"));

    initialized = true;
}
}
```
```java
class de.gurkenlabs.litiengine.entities.Creature {
protected void updateAnimationController() {
    IEntityAnimationController<?> controller = this.createAnimationController();
    this.getControllers().addController(controller);
    if (Game.world().environment() != null && Game.world().environment().isLoaded()) {
      Game.loop().attach(controller);
    }
}@Override
  public float getTickVelocity() {
    // pixels per ms multiplied by the passed ms
    // ensure that entities don't travel too far in case of lag
    return Math.min(Game.loop().getDeltaTime(), GameLoop.TICK_DELTATIME_LAG)
        * 0.001F
        * this.getVelocity().get()
        * Game.loop().getTimeScale();
}
}
```
Depth: 2
```java
class de.gurkenlabs.litiengine.environment.GameWorld {
public void clear() {
    this.unloadEnvironment();
    this.environments.clear();
    this.setCamera(null);
    Game.physics().clear();

    this.environmentListeners.clear();
    this.environmentLoadedListeners.clear();
    this.environmentUnloadedListeners.clear();

    this.listeners.clear();
    this.loadedListeners.clear();
    this.unloadedListeners.clear();
}@Nullable
  public Environment loadEnvironment(IMap map) {
    Environment env = this.getEnvironment(map);
    this.loadEnvironment(env);
    return env;
}@Nullable
  public Environment loadEnvironment(String mapName) {
    Environment env = this.getEnvironment(mapName);
    this.loadEnvironment(env);
    return env;
}
}
```
```java
class de.gurkenlabs.litiengine.GameWindow {
GameWindow() {
    this.hostControl = new JFrame();

    this.resolutionChangedListeners = new CopyOnWriteArrayList<>();

    this.renderCanvas = new RenderComponent(Game.config().graphics().getResolution());
    this.cursor = new MouseCursor();
    if (!Game.isInNoGUIMode()) {
      this.hostControl.setBackground(Color.BLACK);
      this.hostControl.add(this.renderCanvas);

      this.initializeEventListeners();

      this.hostControl.setTitle(Game.info().getTitle());
      this.hostControl.setDefaultCloseOperation(WindowConstants.DO_NOTHING_ON_CLOSE);
      initializeWindowEventListeners(this.hostControl);
    }
}
}
```
```java
class de.gurkenlabs.litiengine.GameTime {
public long sinceEnvironmentLoad() {
    return this.since(this.environmentLoaded);
}public long since(final long tick) {
    return toMilliseconds(Game.loop().getTicks() - tick);
}public long sinceGameStart() {
    return this.toMilliseconds(Game.loop().getTicks());
}
}
```
```java
class de.gurkenlabs.litiengine.abilities.effects.Effect {
protected void cease(final EffectApplication appliance) {
    // 1. cease the effect for all affected entities
    for (final ICombatEntity entity : appliance.getAffectedEntities()) {
      this.cease(entity);
    }

    // 2. apply follow up effects
    this.getFollowUpEffects().forEach(followUp -> followUp.apply(appliance.getImpactArea()));
}protected boolean hasEnded(final EffectApplication appliance) {
    final long effectDuration = Game.time().since(appliance.getAppliedTicks());
    return effectDuration > this.getDuration();
}
}
```
```java
class de.gurkenlabs.litiengine.abilities.effects.EffectApplication {
protected EffectApplication(final List<ICombatEntity> affectedEntities, final Shape impactArea) {
    this.applied = Game.time().now();
    this.affectedEntities = affectedEntities;
    this.impactArea = impactArea;
}
}
```
```java
class de.gurkenlabs.litiengine.entities.CombatEntity {
@Override
  public boolean wasHit(int timeSpan) {
    return Game.time().since(this.lastHit) < timeSpan;
}@Override
  public void hit(final int damage, @Nullable final Ability ability) {
    if (this.isDead()) {
      return;
    }

    if (!this.isIndestructible()) {
      this.getHitPoints().modifyBaseValue(new AttributeModifier<>(Modification.SUBTRACT, damage));
    }

    final EntityHitEvent event = new EntityHitEvent(this, ability, damage, this.isDead());

    for (final CombatEntityListener listener : this.listeners) {
      listener.hit(event);
    }

    for (final CombatEntityHitListener listener : this.hitListeners) {
      listener.hit(event);
    }

    if (this.isDead()) {
      this.fireDeathEvent();
      this.setCollision(false);
    }

    this.lastHit = Game.time().now();
}
}
```
```java
class de.gurkenlabs.litiengine.graphics.ImageEffect {
protected ImageEffect(final int ttl, final String name) {
    this.ttl = ttl;
    this.name = name;
    this.aliveTick = Game.time().now();
}@Override
  public long getAliveTime() {
    return Game.time().since(this.aliveTick);
}
}
```
```java
class de.gurkenlabs.litiengine.abilities.AbilityExecution {
AbilityExecution(final Ability ability) {
    this.appliedEffects = new CopyOnWriteArrayList<>();
    this.ability = ability;
    this.executionTicks = Game.time().now();
    this.impactArea = ability.calculateImpactArea();
    this.castLocation = ability.getExecutor().getCenter();
    Game.loop().attach(this);
}@Override
  public void update() {
    // if there a no effects to apply -> unregister this instance and we're done
    if (this.getAbility().getEffects().isEmpty()
        || this.getAbility().getEffects().size() == this.getAppliedEffects().size()) {
      Game.loop().detach(this);
      return;
    }

    // handle all effects from the ability that were not applied yet
    for (final Effect effect : this.getAbility().getEffects()) {
      // if the ability was not executed yet or the delay of the effect is not
      // yet reached
      if (this.getAppliedEffects().contains(effect)
          || Game.time().since(this.getExecutionTicks()) < effect.getDelay()) {
        continue;
      }

      effect.apply(this.getExecutionImpactArea());
      this.getAppliedEffects().add(effect);
    }
}
}
```
```java
class de.gurkenlabs.litiengine.tweening.TweenEngine {
@Override
  public void update() {
    for (final Tweenable target : this.getTweens().keySet()) {
      for (final Tween tween : this.getTweens().get(target).values()) {
        if (tween.hasStopped()) {
          continue;
        }
        final long elapsed = Game.time().since(tween.getStartTime());
        if (elapsed >= tween.getDuration()) {
          tween.stop();
          continue;
        }
        final float[] currentValues = new float[tween.getTargetValues().length];
        for (int i = 0; i < tween.getTargetValues().length; i++) {
          currentValues[i] =
              tween.getStartValues()[i]
                  + tween.getEquation().compute(elapsed / (float) tween.getDuration())
                      * (tween.getTargetValues()[i] - tween.getStartValues()[i]);
        }
        tween.getTarget().setTweenValues(tween.getType(), currentValues);
      }
    }
}
}
```
```java
class de.gurkenlabs.litiengine.gui.SpeechBubble {
public static SpeechBubble create(
      final IEntity entity, final String text, SpeechBubbleAppearance appearance, Font font) {
    return new SpeechBubble(entity, text, appearance, font);
}public static SpeechBubble create(final IEntity entity, final Font font, final String text) {
    SpeechBubbleAppearance app =
        new SpeechBubbleAppearance(
            DEFAULT_APPEARANCE.getForeColor(),
            DEFAULT_APPEARANCE.getBackgroundColor1(),
            DEFAULT_APPEARANCE.getBorderColor(),
            DEFAULT_APPEARANCE.getPadding());
    return new SpeechBubble(entity, text, app, font);
}public static SpeechBubble create(final IEntity entity, final String text) {
    return new SpeechBubble(entity, text, null, GuiProperties.getDefaultFont());
}@Override
  public void update() {
    if (this.currentText == null) {
      this.hide();
      return;
    }

    this.entityCenter = Game.world().camera().getViewportLocation(this.getEntity().getCenter());

    // old text was displayed long enough
    if (this.lastTextDisplay != 0
        && Game.time().since(this.lastTextDisplay) > this.currentTextDisplayTime) {
      this.currentText = null;
      this.lastTextDisplay = 0;
      return;
    }

    // display new text
    if (this.textIndex < this.currentText.length()
        && Game.time().since(this.lastCharPoll) > LETTER_WRITE_DELAY) {
      this.textIndex++;
      this.lastCharPoll = Game.time().now();
      if (this.typeSound != null) {
        Game.audio().playSound(this.typeSound, this.getEntity());
      }
    }

    // continue displaying currently displayed text
}private SpeechBubble(
      final IEntity entity,
      final String text,
      final Sound typeSound,
      SpeechBubbleAppearance appearance,
      Font font) {
    this(entity, text, appearance, font);
    this.typeSound = typeSound;
}private SpeechBubble(
      final IEntity entity,
      final String text,
      @Nullable SpeechBubbleAppearance appearance,
      @Nullable Font font) {
    if (appearance == null) {
      this.appearance = DEFAULT_APPEARANCE;
    } else {
      this.appearance = appearance;
    }

    final SpeechBubble active = activeSpeechBubbles.get(entity);
    if (active != null) {
      active.hide();
    }
    this.setFont(font);

    this.textBoxWidth = (float) (entity.getWidth() * 4);
    this.entity = entity;

    this.currentText = text;
    this.currentTextDisplayTime = DISPLAYTIME_MIN + text.length() * DISPLAYTIME_PER_LETTER;

    this.lastTextDisplay = Game.time().now();
    this.createBubbleImage();
    entity.getEnvironment().add(this, RenderType.UI);
    Game.loop().attach(this);
    activeSpeechBubbles.put(entity, this);
}
}
```
```java
class de.gurkenlabs.litiengine.gui.TextFieldComponent {
@Override
  public void render(final Graphics2D g) {
    super.render(g);
    g.setFont(this.getFont());
    final FontMetrics fm = g.getFontMetrics();

    if (this.isSelected() && Game.time().since(this.lastToggled) > this.flickerDelay) {
      this.cursorVisible = !this.cursorVisible;
      this.lastToggled = Game.time().now();
    }
    if (this.isSelected() && this.cursorVisible) {
      final Rectangle2D cursor =
          new Rectangle2D.Double(
              this.getX() + this.getTextX() + fm.stringWidth(this.getTextToRender(g)),
              this.getY() + this.getTextY(),
              this.getFont().getSize2D() * 3 / 5,
              this.getFont().getSize2D() * 1 / 5);
      g.setColor(this.getAppearance().getForeColor());
      g.fill(cursor);
    }
}
}
```
```java
class de.gurkenlabs.litiengine.entities.Prop {
public Prop(
      final Point2D location, @Nullable final String spritesheetName, final Material material) {
    super();
    this.rotation = Rotation.NONE;
    this.spritesheetName = spritesheetName;
    this.material = material;
    this.setLocation(location);
    this.updateAnimationController();
}public void setSpritesheetName(@Nullable final String spriteName) {
    this.spritesheetName = spriteName;
    this.updateAnimationController();
}
}
```
```java
class de.gurkenlabs.litiengine.tweening.Tween {
public Tween begin() {
    this.started = Game.time().now();
    this.stopped = false;
    return this;
}
}
```
```java
class de.gurkenlabs.litiengine.graphics.emitters.particles.Particle {
public void update(final Point2D emitterOrigin, final float updateRatio) {
    if (this.aliveTick == 0) {
      this.aliveTick = Game.time().now();
    }

    this.aliveTime = Game.time().since(this.aliveTick);
    if (this.timeToLiveReached()) {
      return;
    }

    if (this.colliding) {
      return;
    }

    if (this.getDeltaWidth() != 0) {
      this.width += this.getDeltaWidth() * updateRatio;
    }

    if (this.getDeltaHeight() != 0) {
      this.height += this.getDeltaHeight() * updateRatio;
    }

    if (this.getDeltaAngle() != 0) {
      this.angle += this.getDeltaAngle() * updateRatio;
    }

    // test for ray cast collision
    final float targetX = this.x + this.getVelocityX() * updateRatio;
    final float targetY = this.y + this.getVelocityY() * updateRatio;

    if (targetX == this.x && targetY == this.y) {
      return;
    }

    if (this.checkForCollision(emitterOrigin, targetX, targetY)) {
      return;
    }

    if (this.getVelocityX() != 0) {
      this.x = targetX;
    }

    if (this.getVelocityY() != 0) {
      this.y = targetY;
    }

    if (this.getAccelerationX() != 0) {
      this.velocityX += this.getAccelerationX() * updateRatio;
    }

    if (this.getAccelerationY() != 0) {
      this.velocityY += this.getAccelerationY() * updateRatio;
    }
}
}
```
```java
class de.gurkenlabs.litiengine.graphics.animation.Animation {
@Override
  public void start() {
    this.playing = true;
    if (this.getKeyframes().isEmpty()) {
      return;
    }

    this.restart();
}@Override
  public void update() {
    // do nothing if the animation is not playing or the current keyframe is not finished
    if (!this.isPlaying()
        || Game.time().since(this.lastFrameUpdate) < this.getCurrentKeyFrame().getDuration()) {
      return;
    }

    // if we are not looping and the last keyframe is finished, we terminate the animation
    if (!this.isLooping() && this.isLastKeyFrame()) {
      this.terminate();
      return;
    }

    // make sure, we stay inside the keyframe list
    final int newFrameIndex =
        (this.getKeyframes().indexOf(this.currentFrame) + 1) % this.getKeyframes().size();
    final KeyFrame previousFrame = this.currentFrame;
    this.currentFrame = this.getKeyframes().get(newFrameIndex);

    for (KeyFrameListener listener : this.listeners) {
      listener.currentFrameChanged(previousFrame, this.currentFrame);
    }

    this.lastFrameUpdate = Game.loop().getTicks();
}
}
```
```java
class de.gurkenlabs.litiengine.graphics.animation.AnimationController {
@Override
  public void update() {
    for (final Animation animation : this.getAll()) {
      animation.update();
    }

    if (this.getCurrent() != null && this.getCurrent().isPaused()) {
      return;
    }

    final boolean playbackFinished = this.getCurrent() != null && !this.getCurrent().isPlaying();
    if (playbackFinished) {
      for (final AnimationListener listener : this.listeners) {
        listener.finished(this.getCurrent());
      }
    }

    if (this.getCurrent() == null || playbackFinished) {
      if (this.getDefault() != null) {
        this.play(this.getDefault().getName());
      } else {
        this.currentAnimation = null;
      }
    }
}
}
```
```java
class de.gurkenlabs.litiengine.graphics.RenderComponent {
private void handleFade() {
    if (this.fadeOutStart != -1) {
      final long timePassed = Game.time().since(this.fadeOutStart);
      this.currentAlpha = MathUtilities.clamp(1 - timePassed / (float) this.fadeOutTime, 0, 1);
      if (this.currentAlpha == 0f) {
        this.fadeOutStart = -1;
        this.fadeOutTime = -1;
      }

      return;
    }

    if (this.fadeInStart != -1) {
      final long timePassed = Game.time().since(this.fadeInStart);
      this.currentAlpha = MathUtilities.clamp(timePassed / (float) this.fadeInTime, 0, 1);
      if (this.currentAlpha == 1f) {
        this.fadeInStart = -1;
        this.fadeInTime = -1;
        this.currentAlpha = Float.NaN;
      }
    }
}public void fadeOut(final int ms) {
    this.fadeInStart = -1;
    this.fadeInTime = -1;
    this.fadeOutStart = Game.time().now();
    this.fadeOutTime = ms;
}public void fadeIn(final int ms) {
    this.fadeOutStart = -1;
    this.fadeOutTime = -1;
    this.fadeInStart = Game.time().now();
    this.fadeInTime = ms;
}
}
```
```java
class de.gurkenlabs.litiengine.entities.Trigger {
private boolean activate(final IEntity activator, final int tar) {
    if (!this.isLoaded()
        || this.isOneTimeTrigger && this.isActivated
        || this.getActivationType() == TriggerActivation.COLLISION
            && activator != null
            && this.collisionActivated.contains(activator)) {
      return false;
    }

    if (this.getCooldown() > 0 && Game.time().since(this.lastActivation) < this.getCooldown()) {
      return false;
    }

    List<Integer> triggerTargets = this.getTargets(tar);

    final TriggerEvent te = new TriggerEvent(this, activator, triggerTargets);

    if (!this.checkActivationPredicates(te)) {
      return false;
    }

    this.isActivated = true;
    if (activator != null) {
      this.collisionActivated.add(activator);
    }

    // if we actually have a trigger target, we send the message to the target
    for (final int target : triggerTargets) {
      final IEntity entity = this.getEnvironment().get(target);
      if (entity == null) {
        log.log(
            Level.WARNING,
            "trigger [{0}] was activated, but the trigger target [{1}] could not be found on the environment",
            new Object[] {this, target});
        continue;
      }

      entity.sendMessage(this, this.message);
    }

    // also send the trigger event to all registered consumers
    for (final TriggerActivatedListener listener : this.activatedListeners) {
      listener.activated(te);
    }

    if (this.isOneTimeTrigger) {
      this.getEnvironment().remove(this);
    }

    this.lastActivation = Game.time().now();
    return true;
}
}
```
```java
class de.gurkenlabs.litiengine.graphics.Camera {
private boolean isShakeEffectActive() {
    return this.getShakeTick() != 0
        && Game.time().since(this.getShakeTick()) < this.getShakeDuration();
}@Override
  public void update() {
    if (Game.world().camera() != null && !Game.world().camera().equals(this)) {
      return;
    }

    if (this.targetZoom > 0) {
      if (Game.time().since(this.zoomTick) >= this.zoomDelay) {
        this.zoom = this.targetZoom;
        this.targetZoom = 0;
        this.zoomDelay = 0;
        this.zoomTick = 0;
        this.zoomStep = 0;
      } else {
        this.zoom += this.zoomStep;
      }

      final ZoomChangedEvent event = new ZoomChangedEvent(this, this.getZoom());
      for (final ZoomChangedListener listener : this.zoomListeners) {
        listener.zoomChanged(event);
      }
    }

    if (this.panTime > 0) {
      if (--this.panTime <= 0) {
        this.setFocus(this.targetFocus);
        this.targetFocus = null;
      } else {
        double diff = this.panTime / (this.panTime + 1.0);
        this.focus =
            new Point2D.Double(
                this.focus.getX() * diff + this.targetFocus.getX() * (1.0 - diff),
                this.focus.getY() * diff + this.targetFocus.getY() * (1.0 - diff));
      }
    }

    if (!this.isShakeEffectActive()) {
      this.shakeOffsetX = 0;
      this.shakeOffsetY = 0;
      return;
    }

    if (Game.time().since(this.lastShake) > this.shakeDelay) {
      this.shakeOffsetX = this.getShakeIntensity() * ThreadLocalRandom.current().nextGaussian();
      this.shakeOffsetY = this.getShakeIntensity() * ThreadLocalRandom.current().nextGaussian();
      this.lastShake = Game.time().now();
    }
}@Override
  public void setZoom(final float targetZoom, final int delay) {
    if (delay == 0) {

      this.zoom = targetZoom;
      this.targetZoom = 0;
      this.zoomDelay = 0;
      this.zoomTick = 0;
      this.zoomStep = 0;

      final ZoomChangedEvent event = new ZoomChangedEvent(this, targetZoom);
      for (final ZoomChangedListener listener : this.zoomListeners) {
        listener.zoomChanged(event);
      }
    } else {
      this.zoomTick = Game.time().now();
      this.targetZoom = targetZoom;
      this.zoomDelay = delay;

      final double tickduration = 1000 / (double) Game.loop().getTickRate();
      final double tickAmount = delay / tickduration;
      final float totalDelta = this.targetZoom - this.zoom;
      this.zoomStep = tickAmount > 0 ? (float) (totalDelta / tickAmount) : totalDelta;
    }
}@Override
  public void shake(final double intensity, final int delay, final int shakeDuration) {
    this.shakeTick = Game.time().now();
    this.shakeDelay = delay;
    this.shakeIntensity = intensity;
    this.shakeDuration = shakeDuration;
}
}
```
```java
class de.gurkenlabs.litiengine.entities.Creature {
public void setSpritesheetName(String spritesheetName) {
    if (this.spritesheetName != null && this.spritesheetName.equals(spritesheetName)) {
      return;
    }

    this.spritesheetName = spritesheetName;
    this.updateAnimationController();
}public boolean isIdle() {
    return Game.time().since(this.lastMoved) > IDLE_DELAY;
}@Override
  public void setLocation(final Point2D position) {
    if (this.isDead() || position == null) {
      return;
    }

    final Point2D oldLocation = this.getLocation();
    super.setLocation(position);

    if (Game.hasStarted() && this.isLoaded()) {
      this.lastMoved = Game.time().now();
      this.fireMovedEvent(
          new EntityMovedEvent(
              this, this.getX() - oldLocation.getX(), this.getY() - oldLocation.getY()));
    }
}
}
```
```java
class de.gurkenlabs.litiengine.gui.screens.ScreenManager {
public void display(final String screenName) {
    if (this.current() != null && this.current().getName().equalsIgnoreCase(screenName)) {
      log.log(
          Level.INFO,
          "Skipping displaying of screen {0} because it is already the current screen.",
          screenName);
      return;
    }

    if (this.screens.stream()
        .noneMatch(element -> element.getName().equalsIgnoreCase(screenName))) {
      log.log(
          Level.WARNING,
          "Could not display the screen {0} because there is no screen with the specified name.",
          screenName);
      return;
    }

    Screen screen = this.get(screenName);
    if (screen == null) {
      return;
    }

    this.display(screen);
}public void add(final Screen screen) {
    screen.setWidth(Game.window().getWidth());
    screen.setHeight(Game.window().getHeight());
    this.screens.add(screen);

    if (this.current() == null) {
      this.display(screen);
    }
}public void remove(Screen screen) {
    this.screens.remove(screen);
    if (this.current() == screen) {
      if (!this.screens.isEmpty()) {
        this.display(this.screens.get(0));
      } else {
        this.display((Screen) null);
      }
    }
}public void display(@Nullable final Screen screen) {
    if (Game.hasStarted() && Game.time().since(this.lastScreenChange) < this.getChangeCooldown()) {
      log.log(
          Level.INFO,
          "Skipping displaying of screen {0} because screen changing is currently on cooldown.",
          screen != null ? screen.getName() : "");
      return;
    }

    final Screen previous = this.current();
    if (previous != null) {
      previous.suspend();
    }

    if (screen != null && !this.screens.contains(screen)) {
      this.screens.add(screen);
    }

    this.currentScreen = screen;
    if (!Game.isInNoGUIMode() && this.current() != null) {
      this.current().prepare();
    }

    this.lastScreenChange = Game.loop().getTicks();

    final ScreenChangedEvent event = new ScreenChangedEvent(this.current(), previous);
    for (final ScreenChangedListener listener : this.screenChangedListeners) {
      listener.changed(event);
    }
}
}
```
```java
class de.gurkenlabs.litiengine.abilities.Ability {
public boolean isOnCooldown() {
    return (this.getCurrentExecution() != null
        && this.getCurrentExecution().getExecutionTicks() > 0
        && Game.time().since(this.getCurrentExecution().getExecutionTicks())
            < this.getAttributes().cooldown().get());
}public boolean isActive() {
    return this.getCurrentExecution() != null
        && Game.time().since(this.getCurrentExecution().getExecutionTicks())
            < this.getAttributes().duration().get();
}@Nullable
  public AbilityExecution cast() {
    if (!this.canCast()) {
      return null;
    }
    this.currentExecution = new AbilityExecution(this);

    for (final AbilityCastListener listener : this.abilityCastListeners) {
      listener.abilityCast(this.currentExecution);
    }

    return this.getCurrentExecution();
}public float getRemainingCooldownInSeconds() {
    if (this.getCurrentExecution() == null
        || this.getExecutor() == null
        || this.getExecutor().isDead()) {
      return 0;
    }

    // calculate cooldown in seconds
    return (float)
        (!this.canCast()
            ? (this.getAttributes().cooldown().get()
                    - Game.time().since(this.getCurrentExecution().getExecutionTicks()))
                * 0.001
            : 0);
}
}
```
```java
class de.gurkenlabs.litiengine.entities.EntityHitEvent {
EntityHitEvent(
      final ICombatEntity hitEntity,
      @Nullable final Ability ability,
      final int damage,
      final boolean kill) {
    super(hitEntity);
    this.executor = ability != null ? ability.getExecutor() : null;
    this.hitEntity = hitEntity;
    this.ability = ability;
    this.damage = damage;
    this.kill = kill;
    this.time = Game.time().now();
}
}
```
```java
class de.gurkenlabs.litiengine.graphics.emitters.Emitter {
public void delete() {
    this.deactivate();
    if (Game.world().environment() != null) {
      Game.world().environment().remove(this);
    }
}public void activate() {
    if (this.activated) {
      return;
    }

    this.activated = true;
    this.activationTick = Game.time().now();
    Game.loop().attach(this);
}@Override
  public void update() {
    if (this.isPaused()) {
      return;
    }

    // clear particles if the effect time to life is reached
    if (this.isFinished()) {
      for (EmitterFinishedListener listener : this.finishedListeners) {
        listener.finished(this);
      }

      this.delete();
      return;
    }

    final float updateRatio = (float) this.data().getUpdateRate() / Game.loop().getTickRate();
    for (final Particle p : this.getParticles().stream().collect(Collectors.toList())) {
      if (this.particleCanBeRemoved(p)) {
        // remove dead particles
        this.particles.remove(p);
        continue;
      }

      p.update(this.getOrigin(), updateRatio);
    }

    this.aliveTime = Game.time().since(this.activationTick);
    if ((this.data().getSpawnRate() == 0
        || Game.time().since(this.lastSpawn) >= this.data().getSpawnRate())) {
      this.lastSpawn = Game.time().now();
      this.spawnParticle();
    }
}
}
```
```java
class de.gurkenlabs.litiengine.GameLoop {
@Override
  public int perform(int delay, Runnable action) {
    final long d = Game.time().toTicks(delay);

    TimedAction a = new TimedAction(this.getTicks() + d, action);
    this.actions.add(a);

    return a.getId();
}
}
```
```java
class de.gurkenlabs.litiengine.environment.EntitySpawner {
protected boolean shouldSpawn() {
    return this.lastSpawnWave == 0
        || Game.time().since(this.lastSpawnWave) >= this.getSpawnInterval();
}@Override
  public void update() {
    if (!this.shouldSpawn()) {
      return;
    }

    this.spawnNewEntities();
    this.lastSpawnWave = Game.time().now();
}
}
```
```java
class de.gurkenlabs.litiengine.graphics.FreeFlightCamera {
@Override
  public void update() {
    this.handleFreeFlightCamera();
}public FreeFlightCamera(double x, double y) {
    this(new Point2D.Double(x, y));
}
}
```
```java
class de.gurkenlabs.litiengine.environment.Environment {
public void unload() {
    if (!this.loaded) {
      return;
    }

    // unregister all updatable entities from the current environment
    for (final IEntity entity : this.allEntities.values()) {
      this.unload(entity);
    }

    this.loaded = false;
    this.fireEvent(l -> l.unloaded(this));
}private static void loadUpdatableOrEmitterEntity(IEntity entity) {
    if (entity instanceof Emitter) {
      final Emitter emitter = (Emitter) entity;
      if (emitter.isActivateOnInit()) {
        emitter.activate();
      }
    } else if (entity instanceof IUpdateable) {
      Game.loop().attach((IUpdateable) entity);
    }
}public void clear() {
    Game.physics().clear();

    this.combatEntities.clear();
    this.mobileEntities.clear();
    this.gravityForces.clear();
    this.layerEntities.clear();
    this.entitiesByTag.clear();
    this.allEntities.clear();

    for (RenderType renderType : RenderType.values()) {
      this.miscEntities.get(renderType).clear();
      this.renderListeners.get(renderType).clear();
      this.renderables.get(renderType).clear();
    }

    dispose(this.allEntities.values());
    dispose(this.triggers);
    this.emitters.clear();
    this.colliders.clear();
    this.props.clear();
    this.creatures.clear();
    this.staticShadows.clear();
    this.combatEntities.clear();
    this.mobileEntities.clear();
    this.lightSources.clear();
    this.spawnPoints.clear();
    this.soundSources.clear();
    this.mapAreas.clear();
    this.triggers.clear();

    this.ambientLight = null;
    this.staticShadowLayer = null;

    for (Map<Integer, IEntity> type : this.miscEntities.values()) {
      type.clear();
    }

    this.initialized = false;

    this.fireEvent(l -> l.cleared(this));
}private void load(final IEntity entity) {
    // an entity can only exist on one environment at a time, so remove it from the current one
    if (entity.getEnvironment() != null) {
      entity.getEnvironment().remove(entity);
    }

    // 1. add to physics engine
    loadPhysicsEntity(entity);

    // 2. register for update or activate
    loadUpdatableOrEmitterEntity(entity);

    // 3. if a gravity is defined, add a gravity force to the entity
    if (entity instanceof IMobileEntity && this.getGravity() != 0) {
      this.addGravityForce((IMobileEntity) entity);
    }

    // 4. attach all controllers
    entity.attachControllers();

    if (this.loaded && (entity instanceof LightSource || entity instanceof StaticShadow)) {
      this.updateLighting(entity);
    }

    entity.loaded(this);
}private void unload(final IEntity entity) {
    // 1. remove from physics engine
    if (entity instanceof ICollisionEntity) {
      Game.physics().remove((ICollisionEntity) entity);
    }

    // 2. unregister from update
    if (entity instanceof IUpdateable) {
      Game.loop().detach((IUpdateable) entity);
    }

    if (entity instanceof IMobileEntity) {
      this.removeGravity((IMobileEntity) entity);
    }

    // 3. detach all controllers
    entity.detachControllers();

    if (entity instanceof Emitter) {
      Emitter em = (Emitter) entity;
      em.deactivate();
    }

    if (this.loaded && (entity instanceof LightSource || entity instanceof StaticShadow)) {
      this.updateLighting(entity);
    }

    entity.removed(this);
}public void remove(final IEntity entity) {
    if (entity == null) {
      return;
    }

    this.allEntities.remove(entity.getMapId());
    Iterator<List<IEntity>> iter = this.layerEntities.values().iterator();
    while (iter.hasNext()) {
      List<IEntity> layer = iter.next();
      if (layer.remove(entity) && layer.isEmpty()) {
        iter.remove();
      }
    }
    if (this.miscEntities.get(entity.getRenderType()) != null) {
      this.miscEntities.get(entity.getRenderType()).values().remove(entity);
    }

    for (String tag : entity.getTags()) {
      if (this.getEntitiesByTag().containsKey(tag)) {
        this.getEntitiesByTag().get(tag).remove(entity);

        if (this.getEntitiesByTag().get(tag).isEmpty()) {
          this.getEntitiesByTag().remove(tag);
        }
      }
    }

    if (entity instanceof Emitter) {
      Emitter emitter = (Emitter) entity;
      this.removeEmitter(emitter);
    }

    if (entity instanceof MapArea) {
      this.mapAreas.remove(entity);
    }

    if (entity instanceof Prop) {
      this.props.remove(entity);
    }

    if (entity instanceof Creature) {
      this.creatures.remove(entity);
    }

    if (entity instanceof CollisionBox) {
      this.colliders.remove(entity);
      this.staticShadows.removeIf(x -> x.getOrigin() != null && x.getOrigin().equals(entity));
    }

    if (entity instanceof LightSource) {
      this.lightSources.remove(entity);
      this.updateLighting(entity);
    }

    if (entity instanceof Trigger) {
      this.triggers.remove(entity);
    }

    if (entity instanceof Spawnpoint) {
      this.spawnPoints.remove(entity);
    }
    if (entity instanceof SoundSource) {
      this.soundSources.remove(entity);
    }

    if (entity instanceof StaticShadow) {
      this.staticShadows.remove(entity);
      this.updateLighting(entity);
    }

    if (entity instanceof IMobileEntity) {
      this.mobileEntities.values().remove(entity);
    }

    if (entity instanceof ICombatEntity) {
      this.combatEntities.values().remove(entity);
    }

    this.unload(entity);

    this.fireEntityEvent(l -> l.entityRemoved(entity));
}
}
```
```java
class de.gurkenlabs.litiengine.physics.MovementController {
@Override
  public void update() {
    this.handleForces();
    this.handleMovement();
}
}
```
```java
class de.gurkenlabs.litiengine.Game {
static synchronized void terminate() {
    if (!initialized) {
      return;
    }

    hasStarted = false;
    initialized = false;

    config().save();
    gameLoop.terminate();
    tweenEngine.terminate();
    soundEngine.terminate();

    world().clear();

    for (final GameListener listener : gameListeners) {
      try {
        listener.terminated();
      } catch (Exception e) {
        log().log(Level.WARNING, "game listener threw an exception during shutdown", e);
      }
    }

    gameLoop = null;
    screenManager = null;
    gameWindow = null;
}public static synchronized void start() {
    if (!initialized) {
      throw new IllegalStateException(
          "The game cannot be started without being first initialized. Call Game.init(...) before Game.start().");
    }

    gameLoop.start();
    tweenEngine.start();
    soundEngine.start();

    for (final GameListener listener : gameListeners) {
      listener.started();
    }

    hasStarted = true;
}public static synchronized void init(String... args) {
    if (initialized) {
      log().log(Level.INFO, "The game has already been initialized.");
      return;
    }

    log.init();
    handleCommandLineArguments(args);

    config().load();
    Locale.setDefault(new Locale(config().client().getCountry(), config().client().getLanguage()));

    gameLoop = new GameLoop("Main Update Loop", config().client().getMaxFps());
    loop().attach(physics());
    loop().attach(world());

    // setup default exception handling for render and update loop
    setUncaughtExceptionHandler(
        new DefaultUncaughtExceptionHandler(config().client().exitOnError()));

    screenManager = new ScreenManager();
    gameWindow = new GameWindow();

    // initialize  the game window
    window().init();
    world.setCamera(new Camera());

    for (GameListener listener : gameListeners) {
      listener.initialized(args);
    }

    if (!isInNoGUIMode()) {
      window().getRenderComponent().onRendered(g -> metrics().render(g));

      graphics()
          .addEntityRenderedListener(
              e -> DebugRenderer.renderEntityDebugInfo(e.getGraphics(), e.getEntity()));

      window().getRenderComponent().onFpsChanged(fps -> metrics().setFramesPerSecond(fps));
      window()
          .setIcons(
              Arrays.asList(
                  Resources.images().get("liti-logo-x16.png"),
                  Resources.images().get("liti-logo-x20.png"),
                  Resources.images().get("liti-logo-x32.png"),
                  Resources.images().get("liti-logo-x48.png")));

      Input.keyboard()
          .onKeyTyped(
              KeyEvent.VK_PRINTSCREEN,
              key -> {
                // don't take a screenshot if a modifier is active
                if (key.getModifiers() != 0) {
                  return;
                }

                window().getRenderComponent().takeScreenshot();
              });
    }

    Runtime.getRuntime().addShutdownHook(new Thread(Game::terminate, "Shutdown"));

    initialized = true;
}
}
```


Response Format:
Provide the answer in **XML format** as follows:

#### If the method **cannot** return `null` at the specific call site:
```xml
<response>
  <reason><![CDATA[EXPLAIN WHY THE INVOCATION Game.loop() RESULT CANNOT BE NULL.]]></reason>
  <value>NO</value>
</response>

#### If the method can return null at the specific call site:
<response>
  <reason><![CDATA[EXPLAIN WHY THE INVOCATION Game.loop() RESULT CAN BE NULL.]]></reason>
  <value>YES</value>
</response>

#### If you are unsure or If there are any methods that directly or indirectly affect the return value and are not fully disclosed, request their declarations first, in the following format:
<response>
  <reason><![CDATA[EXPLAIN WHY THIS METHOD DECLARATION IS NECESSARY AND WHY YOU CANNOT MAKE A CONFIDENT DECISION WITHOUT IT]]></reason>
  <success>false</success>
  <methods>
    <method>methodName</method>
  </methods>
</response>

Additional Notes:
Be precise in your reasoning.
If a method’s return value depends on another method not provided, request its declaration before making a conclusion.
If the method can return null in this case but not in others, explain why it happens specifically for this call.

---ChatGPT.sendRequestToOpenAI---
Retrieving response from cache
---Response.<init>---
Creating Response:
```xml
<response>
  <reason><![CDATA[The method `Game.loop()` returns the static field `gameLoop`, which is initialized in the `Game.init(String... args)` method. In this method, a new `GameLoop` object is instantiated and assigned to `gameLoop`. Since `init()` must be called before `start()`, which is implied by the requirement of initializing the game, the `gameLoop` is guaranteed to be non-null during the lifetime of the game execution where `Game.loop()` is called. The absence of any code that could set `gameLoop` to null after its initialization ensures that `Game.loop()` cannot return null.]]></reason>
  <value>NO</value>
</response>
```
---Response.<init>---
Response created:
Disagreement: The method `Game.loop()` returns the static field `gameLoop`, which is initialized in the `Game.init(String... args)` method. In this method, a new `GameLoop` object is instantiated and assigned to `gameLoop`. Since `init()` must be called before `start()`, which is implied by the requirement of initializing the game, the `gameLoop` is guaranteed to be non-null during the lifetime of the game execution where `Game.loop()` is called. The absence of any code that could set `gameLoop` to null after its initialization ensures that `Game.loop()` cannot return null.
---AdvancedNullAwayCodeFix.resolveMethodDereferenceError---
Method is not returning nullable on call site. Injecting suppression annotation.
---AdvancedNullAwayCodeFix.constructCastToNonnullChange---
Constructing cast to nonnull change for reason: The method `Game.loop()` returns the static field `gameLoop`, which is initialized in the `Game.init(String... args)` method. In this method, a new `GameLoop` object is instantiated and assigned to `gameLoop`. Since `init()` must be called before `start()`, which is implied by the requirement of initializing the game, the `gameLoop` is guaranteed to be non-null during the lifetime of the game execution where `Game.loop()` is called. The absence of any code that could set `gameLoop` to null after its initialization ensures that `Game.loop()` cannot return null.
---ChatGPT.ask---
Asking ChatGPT:
For the reason you mentioned earlier:

"The method `Game.loop()` returns the static field `gameLoop`, which is initialized in the `Game.init(String... args)` method. In this method, a new `GameLoop` object is instantiated and assigned to `gameLoop`. Since `init()` must be called before `start()`, which is implied by the requirement of initializing the game, the `gameLoop` is guaranteed to be non-null during the lifetime of the game execution where `Game.loop()` is called. The absence of any code that could set `gameLoop` to null after its initialization ensures that `Game.loop()` cannot return null."

in the method below, the expression Game.loop() is not nullable at the point it is used.

```java
public FreeFlightCamera(final Point2D focus) {
    this.setFocus(focus);
    this.velocity = DEFAULT_SCROLL_PIXELS_PER_SECOND;
    this.scrollPadding = DEFAULT_SCROLL_PADDING;
    this.setClampToMap(true);

    Game.loop().attach(this);
}
```
Please Summarize the reason in max 5 words and rewrite the method so that at the line "    Game.loop().attach(this);", at the occurrence of: "Game.loop()" is replaced with `NullabilityUtil.castToNonnull(Game.loop(), summary of reason)`
Replace "REASON" with the exact reason summary I provide to you (maximum 5 words), not with a generic explanation like "checked to be nonnull".
see the example below, for expression `foo.getBar()`, to wrap it with `NullabilityUtil.castToNonnull(foo.getBar(), "reason")`.

```java
public t(){
    String l = foo.getBar();
}
```

will be:
```java
public t(){
    String l = NullabilityUtil.castToNonnull(foo.getBar(), "checked to be nonnull");
}
```

### Instructions:

Do not import any additional classes.

Do not add Java comments.

Only modify relevant lines as required.

Return only the modified method wrapped in the XML format shown below.

Place the Java code inside the <code> tag using a CDATA block with ```java formatting.

Just give me the fixed code snippet in XML format in <response> tag like the example below. I will apply the fix to my codebase. Do not import any additional libraries or classes or add java comments. If you can provide the fixed code snippet, please provide it in the following format and place the code snippet in the <code> tag within ```java block.
<response>
  <success>true</success>
  <code><![CDATA[
  ```java
  Your fixed code snippet here
  ```
    ]]>
  </code>
</response>

---ChatGPT.sendRequestToOpenAI---
Sending request to OpenAI...
---ChatGPT.sendRequestToOpenAI---
Response received from OpenAI.
---Response.<init>---
Creating Response:
<response>
  <success>true</success>
  <code><![CDATA[
  ```java
public FreeFlightCamera(final Point2D focus) {
    this.setFocus(focus);
    this.velocity = DEFAULT_SCROLL_PIXELS_PER_SECOND;
    this.scrollPadding = DEFAULT_SCROLL_PADDING;
    this.setClampToMap(true);

    NullabilityUtil.castToNonnull(Game.loop(), "initialized in init").attach(this);
}
  ```
    ]]>
  </code>
</response>
---Response.<init>---
Response created:
public FreeFlightCamera(final Point2D focus) {
    this.setFocus(focus);
    this.velocity = DEFAULT_SCROLL_PIXELS_PER_SECOND;
    this.scrollPadding = DEFAULT_SCROLL_PADDING;
    this.setClampToMap(true);

    NullabilityUtil.castToNonnull(Game.loop(), "initialized in init").attach(this);
}
---ChatGPT.fixDereferenceByAddingCastToNonnull---
Fixing the error by adding castToNonnull
---AdvancedNullAwayCodeFix.fixTriggeredErrorsForLocation---
Resolving unresolvable error for triggered error: Type='DEREFERENCE_NULLABLE', message='dereferenced expression Game.loop() is @Nullable'
/home/nima/Developer/nullness-benchmarks/litiengine/src/de/gurkenlabs/litiengine/environment/EntitySpawner.java:162
          Game.loop()
---AdvancedNullAwayCodeFix.fix---
Fixing error: Type='DEREFERENCE_NULLABLE', message='dereferenced expression Game.loop() is @Nullable'
/home/nima/Developer/nullness-benchmarks/litiengine/src/de/gurkenlabs/litiengine/environment/EntitySpawner.java:162
          Game.loop()
---AdvancedNullAwayCodeFix.resolveDereferenceError---
Resolving dereference error: Type='DEREFERENCE_NULLABLE', message='dereferenced expression Game.loop() is @Nullable'
/home/nima/Developer/nullness-benchmarks/litiengine/src/de/gurkenlabs/litiengine/environment/EntitySpawner.java:162
          Game.loop()
---AdvancedNullAwayCodeFix.resolveDereferenceError---
Checking nullability possibility at error point
---ChatGPT.checkNullabilityPossibilityAtErrorPoint---
Asking if the expression can be null at error point point
---ChatGPT.ask---
Asking ChatGPT:
In the method below, is there a possibility that the expression "Game.loop()" at line "Game.loop()" is null?
protected void spawnNewEntities() {
    if (this.getSpawnMode() != SpawnMode.CUSTOMSPAWNPOINTS && this.getSpawnPoints().isEmpty()) {
      return;
    }

    switch (this.getSpawnMode()) {
      case ALLSPAWNPOINTS:
        for (int i = 0; i < this.getSpawnPoints().size(); i++) {
          final int index = i;
          Game.loop()
              .perform(
                  this.getSpawnDelay() + this.getSpawnDelay() * i,
                  () -> this.spawn(this.getSpawnPoints().get(index), this.getSpawnAmount()));
        }
        break;
      case ONERANDOMSPAWNPOINT:
        this.spawn(Game.random().choose(this.getSpawnPoints()), this.getSpawnAmount());
        break;
      case RANDOMSPAWNPOINTS:
        for (int i = 0; i < this.getSpawnAmount(); i++) {
          Game.loop()
              .perform(
                  this.getSpawnDelay() + this.getSpawnDelay() * i,
                  () -> this.spawn(Game.random().choose(this.getSpawnPoints()), 1));
        }
        break;
      case CUSTOMSPAWNPOINTS:
        List<Spawnpoint> spawnPoints =
            this.customSpawnpoints != null
                ? this.customSpawnpoints.apply(this)
                : this.getCustomSpawnpoints();

        int index = 0;
        for (Spawnpoint spawn : spawnPoints) {
          Game.loop()
              .perform(
                  this.getSpawnDelay() + this.getSpawnDelay() * index, () -> this.spawn(spawn, 1));
          index++;
        }
        break;
      default:
        break;
    }
}
Give a single-word answer in XML format. If it is possible for the expression to be null, respond with:
```xml
<response>
    <reason><![CDATA[YOUR REASON]]></reason>
    <value>YES</value>
</response>
```
If it is not possible for the expression to be null, respond with:
```xml
<response>
    <reason><![CDATA[YOUR REASON]]></reason>
    <value>NO</value>
</response>
```
If you are unsure or need more information, respond with where you can ask for more details or what specific information you need.

If additional information is required, list each request inside a `<request>` tag. If no additional information is needed, omit the `<requests>` section.

Respond with:
```xml
<response>
    <reason><![CDATA[YOUR REASON]]></reason>
    <value>UNKNOWN</value>
    <!-- Include <requests> only if additional information is needed -->
    <requests>
        <request><![CDATA[YOUR REQUEST 1]]></request>
        <request><![CDATA[YOUR REQUEST 2]]></request>
    </requests>
</response>
```
---ChatGPT.sendRequestToOpenAI---
Retrieving response from cache
---Response.<init>---
Creating Response:
```xml
<response>
    <reason><![CDATA[The possibility of "Game.loop()" being null depends on how it is implemented and initialized elsewhere in the code. Without access to the implementation details or specifications of the Game class, it is uncertain if "Game.loop()" could be null.]]></reason>
    <value>UNKNOWN</value>
    <requests>
        <request><![CDATA[Provide the implementation or initialization details of the "Game.loop()" method.]]></request>
        <request><![CDATA[Clarify if there are any guarantees or constraints regarding the non-null status of "Game.loop()".]]></request>
    </requests>
</response>
```
---Response.<init>---
Response created:
Unknown: The possibility of "Game.loop()" being null depends on how it is implemented and initialized elsewhere in the code. Without access to the implementation details or specifications of the Game class, it is uncertain if "Game.loop()" could be null.
---AdvancedNullAwayCodeFix.resolveMethodDereferenceError---
Resolving method dereference error.
---AdvancedNullAwayCodeFix.resolveMethodDereferenceError---
Method is in annotated package. Checking if the method is returning nullable.
---AdvancedNullAwayCodeFix.investigateMethodReturnNullability---
Checking if the method is returning nullable.
---ChatGPT.checkIfMethodIsReturningNullable---
Asking if the method is returning nullable: loop()
---ChatGPT.ask---
Asking ChatGPT:
In the method below, is there a possibility that the method returns null based only on its body? Consider the following points:

- The method may have multiple return paths; consider all return statements.
- If the method calls another method, do not assume its return value unless its full declaration is provided. Request its declaration if needed.
- The method may throw an exception instead of returning null. An exception path should not be considered a null return.
- Ensure you request the declarations of any methods whose return values directly or indirectly impact this method’s return value before making a conclusion.
- Carefully analyze all conditions and prior operations that may guarantee a non-null return value.

@Nullable public static IGameLoop loop() {
    return gameLoop;
}

Here are the method definitions in addition to the method inquired:

Depth: 0
```java
class de.gurkenlabs.litiengine.Game {
@Nullable public static IGameLoop loop() {
    return gameLoop;
}
}
```


Response Format:
Provide the answer in **XML format** as follows:

#### If the method **cannot** return `null`:
```xml
<response>
  <reason><![CDATA[EXPLAIN WHY THE METHOD CANNOT RETURN NULL]]></reason>
  <value>NO</value>
</response>
```

#### If the method can return null:
```xml
<response>
  <reason><![CDATA[EXPLAIN WHY THE METHOD CAN RETURN NULL]]></reason>
  <value>YES</value>
</response>
```

#### If you are unsure or need more information, respond with where you can ask for more details or what specific information you need.

#### If you are unsure or If there are any methods that directly or indirectly affect the return value and are not fully disclosed, request their declarations first, in the following format:
<response>
  <reason><![CDATA[YOUR REASON]]></reason>
  <value>UNKNOWN</value>
  <methods>
    <method>methodName</method>
  </methods>
</response>

If additional information is required other than method declaration, list each request inside a `<request>` tag. If no additional information is needed, omit the `<requests>` section.

Respond with:
```xml
<response>
    <reason><![CDATA[YOUR REASON]]></reason>
    <value>UNKNOWN</value>
    <!-- Include <requests> only if additional information is needed -->
    <requests>
        <request><![CDATA[YOUR REQUEST 1]]></request>
        <request><![CDATA[YOUR REQUEST 2]]></request>
    </requests>
</response>
```

Additional Notes:
Be precise in your reasoning.
If a method’s return value depends on another method not provided, request its declaration before making a conclusion.
If the method can return null in some cases but not others, explain under what conditions it can happen.

---ChatGPT.sendRequestToOpenAI---
Retrieving response from cache
---Response.<init>---
Creating Response:
```xml
<response>
  <reason><![CDATA[The method `loop` returns the variable `gameLoop`. Without the initialization or assignment details of `gameLoop`, it's unclear whether it can be null. The possibility of `gameLoop` being uninitialized or set to null elsewhere in the program means `loop` could potentially return null. Further information on `gameLoop` is required.]]></reason>
  <value>UNKNOWN</value>
  <requests>
    <request><![CDATA[Please provide the declaration and initialization of the variable `gameLoop` in the class `de.gurkenlabs.litiengine.Game`.]]></request>
  </requests>
</response>
```
---Response.<init>---
Response created:
Unknown: The method `loop` returns the variable `gameLoop`. Without the initialization or assignment details of `gameLoop`, it's unclear whether it can be null. The possibility of `gameLoop` being uninitialized or set to null elsewhere in the program means `loop` could potentially return null. Further information on `gameLoop` is required.
---AdvancedNullAwayCodeFix.investigateMethodReturnNullability---
Could not determine the nullability and model did not ask for any method.
---ChatGPT.checkIfMethodIsReturningNullableOnCallSite---
Asking if the method is returning nullable on the call site: Game.loop()
---ChatGPT.ask---
Asking ChatGPT:
In the method below, is there a possibility that the method returns null at the given call site?

```java
@Nullable public static IGameLoop loop() {
    return gameLoop;
}
```

## Guidelines:
- The method may have multiple return paths; consider all return statements.
- If the method calls another method, do not assume its return value unless its full declaration is provided. Request its declaration if needed.
- The method may throw an exception instead of returning null. An exception path should not be considered a null return.
- Ensure you request the declarations of any methods whose return values directly or indirectly impact this method’s return value before making a conclusion.
- If the method returns a value that is determined by a parameter, evaluate based on the actual argument at the given call site.
- Analyze based only on the specific invocation provided. Do not generalize to all possible inputs.- If the return value is guaranteed to be non-null at the call site, the answer should be a definitive NO.
- Do not generalize based on all possible inputs—your answer must be based only on the given invocation.
- Focus only on the given call site, not all possible invocations.

### call site:
Game.loop()

Here are the method definitions and the call chain for this method, showing the sequence of calls from the method to its callers at each depth level:

Depth: 0
```java
class de.gurkenlabs.litiengine.Game {
@Nullable public static IGameLoop loop() {
    return gameLoop;
}
}
```
Depth: 1
```java
class de.gurkenlabs.litiengine.environment.GameWorld {
public void loadEnvironment(@Nullable final Environment env) {
    Lock lock = Game.loop().getLock();
    lock.lock();
    try {
      unloadEnvironment();
      this.environment = env;
      if (env != null) {
        this.addEnvironment(env);

        if (env.getGravity() == 0 && this.gravity() != 0) {
          env.setGravity(this.gravity());
        }

        env.load();
        for (final EnvironmentLoadedListener listener : this.loadedListeners) {
          listener.loaded(env);
        }

        // call map specific listeners
        String mapName = getMapName(env);
        if (mapName != null && this.environmentLoadedListeners.containsKey(mapName)) {

          // for the default camera we center the camera on the environment
          if (this.camera().getClass().equals(Camera.class)) {
            camera().setFocus(env.getCenter());
          }

          for (EnvironmentLoadedListener listener : this.environmentLoadedListeners.get(mapName)) {
            listener.loaded(env);
          }
        }
      }
    } finally {
      lock.unlock();
    }
}public void setCamera(@Nullable final ICamera cam) {
    if (this.camera() != null) {
      Game.loop().detach(camera);
    }

    camera = cam;

    if (cam != null && !Game.isInNoGUIMode()) {
      Game.loop().attach(cam);
      cam.updateFocus();
    }
}
}
```
```java
class de.gurkenlabs.litiengine.entities.behavior.EntityNavigator {
public EntityNavigator(final IMobileEntity entity, final PathFinder pathFinder) {
    this.cancelNavigationConditions = new CopyOnWriteArrayList<>();
    this.listeners = new CopyOnWriteArrayList<>();
    this.entity = entity;
    this.pathFinder = pathFinder;
    this.setAcceptableError(DEFAULT_ACCEPTABLE_ERROR);
    Game.loop().attach(this);
}
}
```
```java
class de.gurkenlabs.litiengine.GameWindow {
private static void initializeWindowEventListeners(Window window) {

    window.addWindowStateListener(
        e -> {
          if (e.getNewState() == Frame.ICONIFIED) {
            Game.loop().setTickRate(ICONIFIED_MAX_FPS);
          } else {
            Game.loop().setTickRate(Game.config().client().getMaxFps());
          }
        });

    window.addWindowFocusListener(
        new WindowFocusListener() {
          @Override
          public void windowLostFocus(WindowEvent e) {
            if (Game.config().graphics().reduceFramesWhenNotFocused()) {
              Game.loop().setTickRate(NONE_FOCUS_MAX_FPS);
            }
          }

          @Override
          public void windowGainedFocus(WindowEvent e) {
            Game.loop().setTickRate(Game.config().client().getMaxFps());
          }
        });

    window.addWindowListener(
        new WindowAdapter() {
          @Override
          public void windowClosing(final WindowEvent event) {
            Game.exit();
          }
        });
}
}
```
```java
class de.gurkenlabs.litiengine.gui.screens.ScreenManager {
public void display(@Nullable final Screen screen) {
    if (Game.hasStarted() && Game.time().since(this.lastScreenChange) < this.getChangeCooldown()) {
      log.log(
          Level.INFO,
          "Skipping displaying of screen {0} because screen changing is currently on cooldown.",
          screen != null ? screen.getName() : "");
      return;
    }

    final Screen previous = this.current();
    if (previous != null) {
      previous.suspend();
    }

    if (screen != null && !this.screens.contains(screen)) {
      this.screens.add(screen);
    }

    this.currentScreen = screen;
    if (!Game.isInNoGUIMode() && this.current() != null) {
      this.current().prepare();
    }

    this.lastScreenChange = Game.loop().getTicks();

    final ScreenChangedEvent event = new ScreenChangedEvent(this.current(), previous);
    for (final ScreenChangedListener listener : this.screenChangedListeners) {
      listener.changed(event);
    }
}
}
```
```java
class de.gurkenlabs.litiengine.abilities.effects.Effect {
@Override
  public void update() {

    for (final Iterator<EffectApplication> iterator = this.getActiveAppliances().iterator();
        iterator.hasNext(); ) {
      final EffectApplication appliance = iterator.next();
      // if the effect duration is reached
      if (this.hasEnded(appliance)) {

        iterator.remove();
        this.cease(appliance);
      }
    }

    // 4. unregister if all appliances are finished
    if (this.getActiveAppliances().isEmpty()) {
      Game.loop().detach(this);
    }
}public void apply(final Shape impactArea) {
    final List<ICombatEntity> affected = this.lookForAffectedEntities(impactArea);
    for (final ICombatEntity affectedEntity : affected) {
      this.apply(affectedEntity);
    }

    this.appliances.add(new EffectApplication(affected, impactArea));

    // if it is the first appliance -> register for update
    if (this.appliances.size() == 1) {
      Game.loop().attach(this);
    }
}
}
```
```java
class de.gurkenlabs.litiengine.GameTime {
public long toTicks(final int milliseconds) {
    return this.toTicks(milliseconds, Game.loop().getTickRate());
}public long since(final long tick) {
    return toMilliseconds(Game.loop().getTicks() - tick);
}public long now() {
    return Game.loop().getTicks();
}public long sinceGameStart() {
    return this.toMilliseconds(Game.loop().getTicks());
}@Override
  public void loaded(Environment environment) {
    environmentLoaded = Game.loop().getTicks();
}public long toMilliseconds(final long ticks) {
    return this.toMilliseconds(ticks, Game.loop().getTickRate());
}
}
```
```java
class de.gurkenlabs.litiengine.GameMetrics {
@Override
  public void render(final Graphics2D g) {
    this.updateMetrics();

    if (!Game.config().client().showGameMetrics()) {
      return;
    }

    this.currentOffsetY = 0;

    g.setColor(this.renderColor);

    // render client metrics
    this.drawTitle(g, "[client]");
    this.drawMetric(g, "fps       : " + this.getFramesPerSecond());
    this.drawMetric(g, "max fps   : " + this.maxFramesPerSecond);
    this.drawMetric(g, "updatables: " + Game.loop().getUpdatableCount());

    // render jvm metrics if debug is enabled
    if (Game.config().debug().isDebugEnabled()) {
      this.drawTitle(g, "[jvm]");
      this.drawMetric(g, "java      : " + this.javaVersion);
      this.drawMetric(g, "memory    : " + String.format("%-5.5s", this.usedMemory) + " MB");
      this.drawMetric(g, "threads   : " + Thread.activeCount());
    }

    // render rendering metrics
    if (!this.renderMetrics.isEmpty()) {
      this.drawTitle(g, "[update]");

      for (RenderMetrics metric : this.renderMetrics) {
        this.drawMetric(g, metric.toString());
      }

      this.renderMetrics.clear();
    }
}
}
```
```java
class de.gurkenlabs.litiengine.graphics.emitters.Emitter {
public void deactivate() {
    if (!this.activated) {
      return;
    }

    this.activated = false;
    this.getParticles().clear();
    this.aliveTime = 0;
    this.activationTick = 0;
    this.lastSpawn = 0;
    Game.loop().detach(this);
}public void activate() {
    if (this.activated) {
      return;
    }

    this.activated = true;
    this.activationTick = Game.time().now();
    Game.loop().attach(this);
}@Override
  public void update() {
    if (this.isPaused()) {
      return;
    }

    // clear particles if the effect time to life is reached
    if (this.isFinished()) {
      for (EmitterFinishedListener listener : this.finishedListeners) {
        listener.finished(this);
      }

      this.delete();
      return;
    }

    final float updateRatio = (float) this.data().getUpdateRate() / Game.loop().getTickRate();
    for (final Particle p : this.getParticles().stream().collect(Collectors.toList())) {
      if (this.particleCanBeRemoved(p)) {
        // remove dead particles
        this.particles.remove(p);
        continue;
      }

      p.update(this.getOrigin(), updateRatio);
    }

    this.aliveTime = Game.time().since(this.activationTick);
    if ((this.data().getSpawnRate() == 0
        || Game.time().since(this.lastSpawn) >= this.data().getSpawnRate())) {
      this.lastSpawn = Game.time().now();
      this.spawnParticle();
    }
}
}
```
```java
class de.gurkenlabs.litiengine.entities.behavior.IBehaviorController {
public default void attach() {
    Game.loop().attach(this);
}public default void detach() {
    Game.loop().detach(this);
}
}
```
```java
class de.gurkenlabs.litiengine.abilities.AbilityExecution {
AbilityExecution(final Ability ability) {
    this.appliedEffects = new CopyOnWriteArrayList<>();
    this.ability = ability;
    this.executionTicks = Game.time().now();
    this.impactArea = ability.calculateImpactArea();
    this.castLocation = ability.getExecutor().getCenter();
    Game.loop().attach(this);
}@Override
  public void update() {
    // if there a no effects to apply -> unregister this instance and we're done
    if (this.getAbility().getEffects().isEmpty()
        || this.getAbility().getEffects().size() == this.getAppliedEffects().size()) {
      Game.loop().detach(this);
      return;
    }

    // handle all effects from the ability that were not applied yet
    for (final Effect effect : this.getAbility().getEffects()) {
      // if the ability was not executed yet or the delay of the effect is not
      // yet reached
      if (this.getAppliedEffects().contains(effect)
          || Game.time().since(this.getExecutionTicks()) < effect.getDelay()) {
        continue;
      }

      effect.apply(this.getExecutionImpactArea());
      this.getAppliedEffects().add(effect);
    }
}
}
```
```java
class de.gurkenlabs.litiengine.GameWindow$3 {
@Override
          public void windowGainedFocus(WindowEvent e) {
            Game.loop().setTickRate(Game.config().client().getMaxFps());
}@Override
          public void windowLostFocus(WindowEvent e) {
            if (Game.config().graphics().reduceFramesWhenNotFocused()) {
              Game.loop().setTickRate(NONE_FOCUS_MAX_FPS);
            }
}
}
```
```java
class de.gurkenlabs.litiengine.environment.EntitySpawner {
protected void spawnNewEntities() {
    if (this.getSpawnMode() != SpawnMode.CUSTOMSPAWNPOINTS && this.getSpawnPoints().isEmpty()) {
      return;
    }

    switch (this.getSpawnMode()) {
      case ALLSPAWNPOINTS:
        for (int i = 0; i < this.getSpawnPoints().size(); i++) {
          final int index = i;
          Game.loop()
              .perform(
                  this.getSpawnDelay() + this.getSpawnDelay() * i,
                  () -> this.spawn(this.getSpawnPoints().get(index), this.getSpawnAmount()));
        }
        break;
      case ONERANDOMSPAWNPOINT:
        this.spawn(Game.random().choose(this.getSpawnPoints()), this.getSpawnAmount());
        break;
      case RANDOMSPAWNPOINTS:
        for (int i = 0; i < this.getSpawnAmount(); i++) {
          Game.loop()
              .perform(
                  this.getSpawnDelay() + this.getSpawnDelay() * i,
                  () -> this.spawn(Game.random().choose(this.getSpawnPoints()), 1));
        }
        break;
      case CUSTOMSPAWNPOINTS:
        List<Spawnpoint> spawnPoints =
            this.customSpawnpoints != null
                ? this.customSpawnpoints.apply(this)
                : this.getCustomSpawnpoints();

        int index = 0;
        for (Spawnpoint spawn : spawnPoints) {
          Game.loop()
              .perform(
                  this.getSpawnDelay() + this.getSpawnDelay() * index, () -> this.spawn(spawn, 1));
          index++;
        }
        break;
      default:
        break;
    }
}
}
```
```java
class de.gurkenlabs.litiengine.tweening.TweenEngine {
@Override
  public void start() {
    Game.loop().attach(this);
}@Override
  public void terminate() {
    Game.loop().detach(this);
}
}
```
```java
class de.gurkenlabs.litiengine.gui.SpeechBubble {
public void hide() {
    Game.world().environment().removeRenderable(this);
    Game.loop().detach(this);
    if (activeSpeechBubbles.get(this.getEntity()) != null
        && activeSpeechBubbles.remove(this.getEntity()).equals(this)) {
      activeSpeechBubbles.remove(this.getEntity());
    }

    for (SpeechBubbleListener listener : this.listeners) {
      listener.hidden();
    }
}private SpeechBubble(
      final IEntity entity,
      final String text,
      @Nullable SpeechBubbleAppearance appearance,
      @Nullable Font font) {
    if (appearance == null) {
      this.appearance = DEFAULT_APPEARANCE;
    } else {
      this.appearance = appearance;
    }

    final SpeechBubble active = activeSpeechBubbles.get(entity);
    if (active != null) {
      active.hide();
    }
    this.setFont(font);

    this.textBoxWidth = (float) (entity.getWidth() * 4);
    this.entity = entity;

    this.currentText = text;
    this.currentTextDisplayTime = DISPLAYTIME_MIN + text.length() * DISPLAYTIME_PER_LETTER;

    this.lastTextDisplay = Game.time().now();
    this.createBubbleImage();
    entity.getEnvironment().add(this, RenderType.UI);
    Game.loop().attach(this);
    activeSpeechBubbles.put(entity, this);
}
}
```
```java
class de.gurkenlabs.litiengine.entities.Prop {
private void updateAnimationController() {
    IEntityAnimationController<?> controller = this.createAnimationController();
    this.getControllers().addController(controller);
    if (Game.world().environment() != null && Game.world().environment().isLoaded()) {
      Game.loop().attach(controller);
    }
}
}
```
```java
class de.gurkenlabs.litiengine.graphics.FreeFlightCamera {
public FreeFlightCamera(final Point2D focus) {
    this.setFocus(focus);
    this.velocity = DEFAULT_SCROLL_PIXELS_PER_SECOND;
    this.scrollPadding = DEFAULT_SCROLL_PADDING;
    this.setClampToMap(true);

    Game.loop().attach(this);
}private void handleFreeFlightCamera() {
    if (Game.world().environment() == null || Game.world().environment().getMap() == null) {
      return;
    }

    final Point2D mouseLocation = Input.mouse().getLocation();

    final double scrollSpeed =
        this.getVelocity()
            / (double) Game.loop().getTickRate()
            * Game.config().input().getMouseSensitivity();

    double x = this.getFocus().getX();
    double y = this.getFocus().getY();

    double deltaX = 0;
    if (mouseLocation.getX() < this.getScrollPadding()) {
      deltaX -= scrollSpeed;
    } else if (Game.window().getResolution().getWidth() - mouseLocation.getX()
        < this.getScrollPadding()) {
      deltaX += scrollSpeed;
    }

    double deltaY = 0;
    if (mouseLocation.getY() < this.getScrollPadding()) {
      deltaY -= scrollSpeed;
    } else if (Game.window().getResolution().getHeight() - mouseLocation.getY()
        < this.getScrollPadding()) {
      deltaY += scrollSpeed;
    }

    x += deltaX;
    y += deltaY;

    this.setFocus(new Point2D.Double(x, y));
}
}
```
```java
class de.gurkenlabs.litiengine.environment.Environment {
private static void dispose(final Collection<? extends IEntity> entities) {
    for (final IEntity entity : entities) {
      if (entity instanceof IUpdateable) {
        Game.loop().detach((IUpdateable) entity);
      }

      entity.detachControllers();
    }
}private static void loadUpdatableOrEmitterEntity(IEntity entity) {
    if (entity instanceof Emitter) {
      final Emitter emitter = (Emitter) entity;
      if (emitter.isActivateOnInit()) {
        emitter.activate();
      }
    } else if (entity instanceof IUpdateable) {
      Game.loop().attach((IUpdateable) entity);
    }
}private void unload(final IEntity entity) {
    // 1. remove from physics engine
    if (entity instanceof ICollisionEntity) {
      Game.physics().remove((ICollisionEntity) entity);
    }

    // 2. unregister from update
    if (entity instanceof IUpdateable) {
      Game.loop().detach((IUpdateable) entity);
    }

    if (entity instanceof IMobileEntity) {
      this.removeGravity((IMobileEntity) entity);
    }

    // 3. detach all controllers
    entity.detachControllers();

    if (entity instanceof Emitter) {
      Emitter em = (Emitter) entity;
      em.deactivate();
    }

    if (this.loaded && (entity instanceof LightSource || entity instanceof StaticShadow)) {
      this.updateLighting(entity);
    }

    entity.removed(this);
}
}
```
```java
class de.gurkenlabs.litiengine.graphics.animation.Animation {
@Override
  public void update() {
    // do nothing if the animation is not playing or the current keyframe is not finished
    if (!this.isPlaying()
        || Game.time().since(this.lastFrameUpdate) < this.getCurrentKeyFrame().getDuration()) {
      return;
    }

    // if we are not looping and the last keyframe is finished, we terminate the animation
    if (!this.isLooping() && this.isLastKeyFrame()) {
      this.terminate();
      return;
    }

    // make sure, we stay inside the keyframe list
    final int newFrameIndex =
        (this.getKeyframes().indexOf(this.currentFrame) + 1) % this.getKeyframes().size();
    final KeyFrame previousFrame = this.currentFrame;
    this.currentFrame = this.getKeyframes().get(newFrameIndex);

    for (KeyFrameListener listener : this.listeners) {
      listener.currentFrameChanged(previousFrame, this.currentFrame);
    }

    this.lastFrameUpdate = Game.loop().getTicks();
}public void restart() {
    this.currentFrame = this.firstFrame;
    this.lastFrameUpdate = Game.loop().getTicks();
}
}
```
```java
class de.gurkenlabs.litiengine.physics.MovementController {
@Override
  public void attach() {
    Game.loop().attach(this);
}private void handleForces() {
    // clean up forces
    this.activeForces.forEach(
        x -> {
          if (x.hasEnded()) {
            this.activeForces.remove(x);
          }
        });

    if (this.activeForces.isEmpty()) {
      return;
    }

    // disable turn-on-move for force handling
    boolean turn = this.getEntity().turnOnMove();
    this.getEntity().setTurnOnMove(false);
    try {
      double deltaX = 0;
      double deltaY = 0;
      for (final Force force : this.activeForces) {
        if (force.cancelOnReached() && force.hasReached(this.getEntity())) {
          force.end();
          continue;
        }

        final Point2D collisionBoxCenter = this.getEntity().getCollisionBoxCenter();
        final double angle =
            GeometricUtilities.calcRotationAngleInDegrees(collisionBoxCenter, force.getLocation());
        final double strength =
            Game.loop().getDeltaTime() * 0.001f * force.getStrength() * Game.loop().getTimeScale();
        deltaX += GeometricUtilities.getDeltaX(angle, strength);
        deltaY += GeometricUtilities.getDeltaY(angle, strength);
      }

      final Point2D target =
          new Point2D.Double(this.getEntity().getX() + deltaX, this.getEntity().getY() + deltaY);
      final boolean success = Game.physics().move(this.getEntity(), target);
      if (!success) {
        for (final Force force : this.activeForces) {
          if (force.cancelOnCollision()) {
            force.end();
          }
        }
      }
    } finally {
      this.getEntity().setTurnOnMove(turn);
    }
}@Override
  public void detach() {
    Game.loop().detach(this);
}public void handleMovement() {
    if (!this.isMovementAllowed()) {
      this.velocity = 0;
      return;
    }

    // max distance an entity can travel within one tick
    final double maxPixelsPerTick = this.getEntity().getTickVelocity();
    final double deltaTime = Game.loop().getDeltaTime() * Game.loop().getTimeScale();

    final double acceleration =
        this.getEntity().getAcceleration() == 0
            ? maxPixelsPerTick
            : deltaTime / this.getEntity().getAcceleration() * maxPixelsPerTick;
    final double deceleration =
        this.getEntity().getDeceleration() == 0
            ? this.getVelocity()
            : deltaTime / this.getEntity().getDeceleration() * maxPixelsPerTick;

    double dx = this.getDx();
    double dy = this.getDy();
    this.setDx(0);
    this.setDy(0);

    final double deltaVelocity =
        Math.min(Math.sqrt(Math.pow(dx, 2) + Math.pow(dy, 2)), acceleration);
    if (deltaVelocity != 0) {
      double newVelocity = this.getVelocity() + deltaVelocity;
      this.setVelocity(newVelocity);
    } else {
      final double newVelocity = Math.max(0, this.getVelocity() - deceleration);
      this.setVelocity(newVelocity);
      dx = GeometricUtilities.getDeltaX(this.moveAngle);
      dy = GeometricUtilities.getDeltaY(this.moveAngle);
    }

    if (this.getVelocity() == 0) {
      this.moveAngle = 0;
      return;
    }

    // actually move entity
    this.moveEntity(dx, dy);
}
}
```
```java
class de.gurkenlabs.litiengine.graphics.animation.AnimationController {
public void detach() {
    Game.loop().detach(this);
}public void attach() {
    Game.loop().attach(this);
}
}
```
```java
class de.gurkenlabs.litiengine.graphics.Camera {
@Override
  public void setZoom(final float targetZoom, final int delay) {
    if (delay == 0) {

      this.zoom = targetZoom;
      this.targetZoom = 0;
      this.zoomDelay = 0;
      this.zoomTick = 0;
      this.zoomStep = 0;

      final ZoomChangedEvent event = new ZoomChangedEvent(this, targetZoom);
      for (final ZoomChangedListener listener : this.zoomListeners) {
        listener.zoomChanged(event);
      }
    } else {
      this.zoomTick = Game.time().now();
      this.targetZoom = targetZoom;
      this.zoomDelay = delay;

      final double tickduration = 1000 / (double) Game.loop().getTickRate();
      final double tickAmount = delay / tickduration;
      final float totalDelta = this.targetZoom - this.zoom;
      this.zoomStep = tickAmount > 0 ? (float) (totalDelta / tickAmount) : totalDelta;
    }
}
}
```
```java
class de.gurkenlabs.litiengine.Game {
public static synchronized void init(String... args) {
    if (initialized) {
      log().log(Level.INFO, "The game has already been initialized.");
      return;
    }

    log.init();
    handleCommandLineArguments(args);

    config().load();
    Locale.setDefault(new Locale(config().client().getCountry(), config().client().getLanguage()));

    gameLoop = new GameLoop("Main Update Loop", config().client().getMaxFps());
    loop().attach(physics());
    loop().attach(world());

    // setup default exception handling for render and update loop
    setUncaughtExceptionHandler(
        new DefaultUncaughtExceptionHandler(config().client().exitOnError()));

    screenManager = new ScreenManager();
    gameWindow = new GameWindow();

    // initialize  the game window
    window().init();
    world.setCamera(new Camera());

    for (GameListener listener : gameListeners) {
      listener.initialized(args);
    }

    if (!isInNoGUIMode()) {
      window().getRenderComponent().onRendered(g -> metrics().render(g));

      graphics()
          .addEntityRenderedListener(
              e -> DebugRenderer.renderEntityDebugInfo(e.getGraphics(), e.getEntity()));

      window().getRenderComponent().onFpsChanged(fps -> metrics().setFramesPerSecond(fps));
      window()
          .setIcons(
              Arrays.asList(
                  Resources.images().get("liti-logo-x16.png"),
                  Resources.images().get("liti-logo-x20.png"),
                  Resources.images().get("liti-logo-x32.png"),
                  Resources.images().get("liti-logo-x48.png")));

      Input.keyboard()
          .onKeyTyped(
              KeyEvent.VK_PRINTSCREEN,
              key -> {
                // don't take a screenshot if a modifier is active
                if (key.getModifiers() != 0) {
                  return;
                }

                window().getRenderComponent().takeScreenshot();
              });
    }

    Runtime.getRuntime().addShutdownHook(new Thread(Game::terminate, "Shutdown"));

    initialized = true;
}
}
```
```java
class de.gurkenlabs.litiengine.entities.Creature {
protected void updateAnimationController() {
    IEntityAnimationController<?> controller = this.createAnimationController();
    this.getControllers().addController(controller);
    if (Game.world().environment() != null && Game.world().environment().isLoaded()) {
      Game.loop().attach(controller);
    }
}@Override
  public float getTickVelocity() {
    // pixels per ms multiplied by the passed ms
    // ensure that entities don't travel too far in case of lag
    return Math.min(Game.loop().getDeltaTime(), GameLoop.TICK_DELTATIME_LAG)
        * 0.001F
        * this.getVelocity().get()
        * Game.loop().getTimeScale();
}
}
```
Depth: 2
```java
class de.gurkenlabs.litiengine.environment.GameWorld {
public void clear() {
    this.unloadEnvironment();
    this.environments.clear();
    this.setCamera(null);
    Game.physics().clear();

    this.environmentListeners.clear();
    this.environmentLoadedListeners.clear();
    this.environmentUnloadedListeners.clear();

    this.listeners.clear();
    this.loadedListeners.clear();
    this.unloadedListeners.clear();
}@Nullable
  public Environment loadEnvironment(IMap map) {
    Environment env = this.getEnvironment(map);
    this.loadEnvironment(env);
    return env;
}@Nullable
  public Environment loadEnvironment(String mapName) {
    Environment env = this.getEnvironment(mapName);
    this.loadEnvironment(env);
    return env;
}
}
```
```java
class de.gurkenlabs.litiengine.GameWindow {
GameWindow() {
    this.hostControl = new JFrame();

    this.resolutionChangedListeners = new CopyOnWriteArrayList<>();

    this.renderCanvas = new RenderComponent(Game.config().graphics().getResolution());
    this.cursor = new MouseCursor();
    if (!Game.isInNoGUIMode()) {
      this.hostControl.setBackground(Color.BLACK);
      this.hostControl.add(this.renderCanvas);

      this.initializeEventListeners();

      this.hostControl.setTitle(Game.info().getTitle());
      this.hostControl.setDefaultCloseOperation(WindowConstants.DO_NOTHING_ON_CLOSE);
      initializeWindowEventListeners(this.hostControl);
    }
}
}
```
```java
class de.gurkenlabs.litiengine.GameTime {
public long sinceEnvironmentLoad() {
    return this.since(this.environmentLoaded);
}public long since(final long tick) {
    return toMilliseconds(Game.loop().getTicks() - tick);
}public long sinceGameStart() {
    return this.toMilliseconds(Game.loop().getTicks());
}
}
```
```java
class de.gurkenlabs.litiengine.abilities.effects.Effect {
protected void cease(final EffectApplication appliance) {
    // 1. cease the effect for all affected entities
    for (final ICombatEntity entity : appliance.getAffectedEntities()) {
      this.cease(entity);
    }

    // 2. apply follow up effects
    this.getFollowUpEffects().forEach(followUp -> followUp.apply(appliance.getImpactArea()));
}protected boolean hasEnded(final EffectApplication appliance) {
    final long effectDuration = Game.time().since(appliance.getAppliedTicks());
    return effectDuration > this.getDuration();
}
}
```
```java
class de.gurkenlabs.litiengine.abilities.effects.EffectApplication {
protected EffectApplication(final List<ICombatEntity> affectedEntities, final Shape impactArea) {
    this.applied = Game.time().now();
    this.affectedEntities = affectedEntities;
    this.impactArea = impactArea;
}
}
```
```java
class de.gurkenlabs.litiengine.entities.CombatEntity {
@Override
  public boolean wasHit(int timeSpan) {
    return Game.time().since(this.lastHit) < timeSpan;
}@Override
  public void hit(final int damage, @Nullable final Ability ability) {
    if (this.isDead()) {
      return;
    }

    if (!this.isIndestructible()) {
      this.getHitPoints().modifyBaseValue(new AttributeModifier<>(Modification.SUBTRACT, damage));
    }

    final EntityHitEvent event = new EntityHitEvent(this, ability, damage, this.isDead());

    for (final CombatEntityListener listener : this.listeners) {
      listener.hit(event);
    }

    for (final CombatEntityHitListener listener : this.hitListeners) {
      listener.hit(event);
    }

    if (this.isDead()) {
      this.fireDeathEvent();
      this.setCollision(false);
    }

    this.lastHit = Game.time().now();
}
}
```
```java
class de.gurkenlabs.litiengine.graphics.ImageEffect {
protected ImageEffect(final int ttl, final String name) {
    this.ttl = ttl;
    this.name = name;
    this.aliveTick = Game.time().now();
}@Override
  public long getAliveTime() {
    return Game.time().since(this.aliveTick);
}
}
```
```java
class de.gurkenlabs.litiengine.abilities.AbilityExecution {
AbilityExecution(final Ability ability) {
    this.appliedEffects = new CopyOnWriteArrayList<>();
    this.ability = ability;
    this.executionTicks = Game.time().now();
    this.impactArea = ability.calculateImpactArea();
    this.castLocation = ability.getExecutor().getCenter();
    Game.loop().attach(this);
}@Override
  public void update() {
    // if there a no effects to apply -> unregister this instance and we're done
    if (this.getAbility().getEffects().isEmpty()
        || this.getAbility().getEffects().size() == this.getAppliedEffects().size()) {
      Game.loop().detach(this);
      return;
    }

    // handle all effects from the ability that were not applied yet
    for (final Effect effect : this.getAbility().getEffects()) {
      // if the ability was not executed yet or the delay of the effect is not
      // yet reached
      if (this.getAppliedEffects().contains(effect)
          || Game.time().since(this.getExecutionTicks()) < effect.getDelay()) {
        continue;
      }

      effect.apply(this.getExecutionImpactArea());
      this.getAppliedEffects().add(effect);
    }
}
}
```
```java
class de.gurkenlabs.litiengine.tweening.TweenEngine {
@Override
  public void update() {
    for (final Tweenable target : this.getTweens().keySet()) {
      for (final Tween tween : this.getTweens().get(target).values()) {
        if (tween.hasStopped()) {
          continue;
        }
        final long elapsed = Game.time().since(tween.getStartTime());
        if (elapsed >= tween.getDuration()) {
          tween.stop();
          continue;
        }
        final float[] currentValues = new float[tween.getTargetValues().length];
        for (int i = 0; i < tween.getTargetValues().length; i++) {
          currentValues[i] =
              tween.getStartValues()[i]
                  + tween.getEquation().compute(elapsed / (float) tween.getDuration())
                      * (tween.getTargetValues()[i] - tween.getStartValues()[i]);
        }
        tween.getTarget().setTweenValues(tween.getType(), currentValues);
      }
    }
}
}
```
```java
class de.gurkenlabs.litiengine.gui.SpeechBubble {
public static SpeechBubble create(
      final IEntity entity, final String text, SpeechBubbleAppearance appearance, Font font) {
    return new SpeechBubble(entity, text, appearance, font);
}public static SpeechBubble create(final IEntity entity, final Font font, final String text) {
    SpeechBubbleAppearance app =
        new SpeechBubbleAppearance(
            DEFAULT_APPEARANCE.getForeColor(),
            DEFAULT_APPEARANCE.getBackgroundColor1(),
            DEFAULT_APPEARANCE.getBorderColor(),
            DEFAULT_APPEARANCE.getPadding());
    return new SpeechBubble(entity, text, app, font);
}public static SpeechBubble create(final IEntity entity, final String text) {
    return new SpeechBubble(entity, text, null, GuiProperties.getDefaultFont());
}@Override
  public void update() {
    if (this.currentText == null) {
      this.hide();
      return;
    }

    this.entityCenter = Game.world().camera().getViewportLocation(this.getEntity().getCenter());

    // old text was displayed long enough
    if (this.lastTextDisplay != 0
        && Game.time().since(this.lastTextDisplay) > this.currentTextDisplayTime) {
      this.currentText = null;
      this.lastTextDisplay = 0;
      return;
    }

    // display new text
    if (this.textIndex < this.currentText.length()
        && Game.time().since(this.lastCharPoll) > LETTER_WRITE_DELAY) {
      this.textIndex++;
      this.lastCharPoll = Game.time().now();
      if (this.typeSound != null) {
        Game.audio().playSound(this.typeSound, this.getEntity());
      }
    }

    // continue displaying currently displayed text
}private SpeechBubble(
      final IEntity entity,
      final String text,
      final Sound typeSound,
      SpeechBubbleAppearance appearance,
      Font font) {
    this(entity, text, appearance, font);
    this.typeSound = typeSound;
}private SpeechBubble(
      final IEntity entity,
      final String text,
      @Nullable SpeechBubbleAppearance appearance,
      @Nullable Font font) {
    if (appearance == null) {
      this.appearance = DEFAULT_APPEARANCE;
    } else {
      this.appearance = appearance;
    }

    final SpeechBubble active = activeSpeechBubbles.get(entity);
    if (active != null) {
      active.hide();
    }
    this.setFont(font);

    this.textBoxWidth = (float) (entity.getWidth() * 4);
    this.entity = entity;

    this.currentText = text;
    this.currentTextDisplayTime = DISPLAYTIME_MIN + text.length() * DISPLAYTIME_PER_LETTER;

    this.lastTextDisplay = Game.time().now();
    this.createBubbleImage();
    entity.getEnvironment().add(this, RenderType.UI);
    Game.loop().attach(this);
    activeSpeechBubbles.put(entity, this);
}
}
```
```java
class de.gurkenlabs.litiengine.gui.TextFieldComponent {
@Override
  public void render(final Graphics2D g) {
    super.render(g);
    g.setFont(this.getFont());
    final FontMetrics fm = g.getFontMetrics();

    if (this.isSelected() && Game.time().since(this.lastToggled) > this.flickerDelay) {
      this.cursorVisible = !this.cursorVisible;
      this.lastToggled = Game.time().now();
    }
    if (this.isSelected() && this.cursorVisible) {
      final Rectangle2D cursor =
          new Rectangle2D.Double(
              this.getX() + this.getTextX() + fm.stringWidth(this.getTextToRender(g)),
              this.getY() + this.getTextY(),
              this.getFont().getSize2D() * 3 / 5,
              this.getFont().getSize2D() * 1 / 5);
      g.setColor(this.getAppearance().getForeColor());
      g.fill(cursor);
    }
}
}
```
```java
class de.gurkenlabs.litiengine.entities.Prop {
public Prop(
      final Point2D location, @Nullable final String spritesheetName, final Material material) {
    super();
    this.rotation = Rotation.NONE;
    this.spritesheetName = spritesheetName;
    this.material = material;
    this.setLocation(location);
    this.updateAnimationController();
}public void setSpritesheetName(@Nullable final String spriteName) {
    this.spritesheetName = spriteName;
    this.updateAnimationController();
}
}
```
```java
class de.gurkenlabs.litiengine.tweening.Tween {
public Tween begin() {
    this.started = Game.time().now();
    this.stopped = false;
    return this;
}
}
```
```java
class de.gurkenlabs.litiengine.graphics.emitters.particles.Particle {
public void update(final Point2D emitterOrigin, final float updateRatio) {
    if (this.aliveTick == 0) {
      this.aliveTick = Game.time().now();
    }

    this.aliveTime = Game.time().since(this.aliveTick);
    if (this.timeToLiveReached()) {
      return;
    }

    if (this.colliding) {
      return;
    }

    if (this.getDeltaWidth() != 0) {
      this.width += this.getDeltaWidth() * updateRatio;
    }

    if (this.getDeltaHeight() != 0) {
      this.height += this.getDeltaHeight() * updateRatio;
    }

    if (this.getDeltaAngle() != 0) {
      this.angle += this.getDeltaAngle() * updateRatio;
    }

    // test for ray cast collision
    final float targetX = this.x + this.getVelocityX() * updateRatio;
    final float targetY = this.y + this.getVelocityY() * updateRatio;

    if (targetX == this.x && targetY == this.y) {
      return;
    }

    if (this.checkForCollision(emitterOrigin, targetX, targetY)) {
      return;
    }

    if (this.getVelocityX() != 0) {
      this.x = targetX;
    }

    if (this.getVelocityY() != 0) {
      this.y = targetY;
    }

    if (this.getAccelerationX() != 0) {
      this.velocityX += this.getAccelerationX() * updateRatio;
    }

    if (this.getAccelerationY() != 0) {
      this.velocityY += this.getAccelerationY() * updateRatio;
    }
}
}
```
```java
class de.gurkenlabs.litiengine.graphics.animation.Animation {
@Override
  public void start() {
    this.playing = true;
    if (this.getKeyframes().isEmpty()) {
      return;
    }

    this.restart();
}@Override
  public void update() {
    // do nothing if the animation is not playing or the current keyframe is not finished
    if (!this.isPlaying()
        || Game.time().since(this.lastFrameUpdate) < this.getCurrentKeyFrame().getDuration()) {
      return;
    }

    // if we are not looping and the last keyframe is finished, we terminate the animation
    if (!this.isLooping() && this.isLastKeyFrame()) {
      this.terminate();
      return;
    }

    // make sure, we stay inside the keyframe list
    final int newFrameIndex =
        (this.getKeyframes().indexOf(this.currentFrame) + 1) % this.getKeyframes().size();
    final KeyFrame previousFrame = this.currentFrame;
    this.currentFrame = this.getKeyframes().get(newFrameIndex);

    for (KeyFrameListener listener : this.listeners) {
      listener.currentFrameChanged(previousFrame, this.currentFrame);
    }

    this.lastFrameUpdate = Game.loop().getTicks();
}
}
```
```java
class de.gurkenlabs.litiengine.graphics.animation.AnimationController {
@Override
  public void update() {
    for (final Animation animation : this.getAll()) {
      animation.update();
    }

    if (this.getCurrent() != null && this.getCurrent().isPaused()) {
      return;
    }

    final boolean playbackFinished = this.getCurrent() != null && !this.getCurrent().isPlaying();
    if (playbackFinished) {
      for (final AnimationListener listener : this.listeners) {
        listener.finished(this.getCurrent());
      }
    }

    if (this.getCurrent() == null || playbackFinished) {
      if (this.getDefault() != null) {
        this.play(this.getDefault().getName());
      } else {
        this.currentAnimation = null;
      }
    }
}
}
```
```java
class de.gurkenlabs.litiengine.graphics.RenderComponent {
private void handleFade() {
    if (this.fadeOutStart != -1) {
      final long timePassed = Game.time().since(this.fadeOutStart);
      this.currentAlpha = MathUtilities.clamp(1 - timePassed / (float) this.fadeOutTime, 0, 1);
      if (this.currentAlpha == 0f) {
        this.fadeOutStart = -1;
        this.fadeOutTime = -1;
      }

      return;
    }

    if (this.fadeInStart != -1) {
      final long timePassed = Game.time().since(this.fadeInStart);
      this.currentAlpha = MathUtilities.clamp(timePassed / (float) this.fadeInTime, 0, 1);
      if (this.currentAlpha == 1f) {
        this.fadeInStart = -1;
        this.fadeInTime = -1;
        this.currentAlpha = Float.NaN;
      }
    }
}public void fadeOut(final int ms) {
    this.fadeInStart = -1;
    this.fadeInTime = -1;
    this.fadeOutStart = Game.time().now();
    this.fadeOutTime = ms;
}public void fadeIn(final int ms) {
    this.fadeOutStart = -1;
    this.fadeOutTime = -1;
    this.fadeInStart = Game.time().now();
    this.fadeInTime = ms;
}
}
```
```java
class de.gurkenlabs.litiengine.entities.Trigger {
private boolean activate(final IEntity activator, final int tar) {
    if (!this.isLoaded()
        || this.isOneTimeTrigger && this.isActivated
        || this.getActivationType() == TriggerActivation.COLLISION
            && activator != null
            && this.collisionActivated.contains(activator)) {
      return false;
    }

    if (this.getCooldown() > 0 && Game.time().since(this.lastActivation) < this.getCooldown()) {
      return false;
    }

    List<Integer> triggerTargets = this.getTargets(tar);

    final TriggerEvent te = new TriggerEvent(this, activator, triggerTargets);

    if (!this.checkActivationPredicates(te)) {
      return false;
    }

    this.isActivated = true;
    if (activator != null) {
      this.collisionActivated.add(activator);
    }

    // if we actually have a trigger target, we send the message to the target
    for (final int target : triggerTargets) {
      final IEntity entity = this.getEnvironment().get(target);
      if (entity == null) {
        log.log(
            Level.WARNING,
            "trigger [{0}] was activated, but the trigger target [{1}] could not be found on the environment",
            new Object[] {this, target});
        continue;
      }

      entity.sendMessage(this, this.message);
    }

    // also send the trigger event to all registered consumers
    for (final TriggerActivatedListener listener : this.activatedListeners) {
      listener.activated(te);
    }

    if (this.isOneTimeTrigger) {
      this.getEnvironment().remove(this);
    }

    this.lastActivation = Game.time().now();
    return true;
}
}
```
```java
class de.gurkenlabs.litiengine.graphics.Camera {
private boolean isShakeEffectActive() {
    return this.getShakeTick() != 0
        && Game.time().since(this.getShakeTick()) < this.getShakeDuration();
}@Override
  public void update() {
    if (Game.world().camera() != null && !Game.world().camera().equals(this)) {
      return;
    }

    if (this.targetZoom > 0) {
      if (Game.time().since(this.zoomTick) >= this.zoomDelay) {
        this.zoom = this.targetZoom;
        this.targetZoom = 0;
        this.zoomDelay = 0;
        this.zoomTick = 0;
        this.zoomStep = 0;
      } else {
        this.zoom += this.zoomStep;
      }

      final ZoomChangedEvent event = new ZoomChangedEvent(this, this.getZoom());
      for (final ZoomChangedListener listener : this.zoomListeners) {
        listener.zoomChanged(event);
      }
    }

    if (this.panTime > 0) {
      if (--this.panTime <= 0) {
        this.setFocus(this.targetFocus);
        this.targetFocus = null;
      } else {
        double diff = this.panTime / (this.panTime + 1.0);
        this.focus =
            new Point2D.Double(
                this.focus.getX() * diff + this.targetFocus.getX() * (1.0 - diff),
                this.focus.getY() * diff + this.targetFocus.getY() * (1.0 - diff));
      }
    }

    if (!this.isShakeEffectActive()) {
      this.shakeOffsetX = 0;
      this.shakeOffsetY = 0;
      return;
    }

    if (Game.time().since(this.lastShake) > this.shakeDelay) {
      this.shakeOffsetX = this.getShakeIntensity() * ThreadLocalRandom.current().nextGaussian();
      this.shakeOffsetY = this.getShakeIntensity() * ThreadLocalRandom.current().nextGaussian();
      this.lastShake = Game.time().now();
    }
}@Override
  public void setZoom(final float targetZoom, final int delay) {
    if (delay == 0) {

      this.zoom = targetZoom;
      this.targetZoom = 0;
      this.zoomDelay = 0;
      this.zoomTick = 0;
      this.zoomStep = 0;

      final ZoomChangedEvent event = new ZoomChangedEvent(this, targetZoom);
      for (final ZoomChangedListener listener : this.zoomListeners) {
        listener.zoomChanged(event);
      }
    } else {
      this.zoomTick = Game.time().now();
      this.targetZoom = targetZoom;
      this.zoomDelay = delay;

      final double tickduration = 1000 / (double) Game.loop().getTickRate();
      final double tickAmount = delay / tickduration;
      final float totalDelta = this.targetZoom - this.zoom;
      this.zoomStep = tickAmount > 0 ? (float) (totalDelta / tickAmount) : totalDelta;
    }
}@Override
  public void shake(final double intensity, final int delay, final int shakeDuration) {
    this.shakeTick = Game.time().now();
    this.shakeDelay = delay;
    this.shakeIntensity = intensity;
    this.shakeDuration = shakeDuration;
}
}
```
```java
class de.gurkenlabs.litiengine.entities.Creature {
public void setSpritesheetName(String spritesheetName) {
    if (this.spritesheetName != null && this.spritesheetName.equals(spritesheetName)) {
      return;
    }

    this.spritesheetName = spritesheetName;
    this.updateAnimationController();
}public boolean isIdle() {
    return Game.time().since(this.lastMoved) > IDLE_DELAY;
}@Override
  public void setLocation(final Point2D position) {
    if (this.isDead() || position == null) {
      return;
    }

    final Point2D oldLocation = this.getLocation();
    super.setLocation(position);

    if (Game.hasStarted() && this.isLoaded()) {
      this.lastMoved = Game.time().now();
      this.fireMovedEvent(
          new EntityMovedEvent(
              this, this.getX() - oldLocation.getX(), this.getY() - oldLocation.getY()));
    }
}
}
```
```java
class de.gurkenlabs.litiengine.gui.screens.ScreenManager {
public void display(final String screenName) {
    if (this.current() != null && this.current().getName().equalsIgnoreCase(screenName)) {
      log.log(
          Level.INFO,
          "Skipping displaying of screen {0} because it is already the current screen.",
          screenName);
      return;
    }

    if (this.screens.stream()
        .noneMatch(element -> element.getName().equalsIgnoreCase(screenName))) {
      log.log(
          Level.WARNING,
          "Could not display the screen {0} because there is no screen with the specified name.",
          screenName);
      return;
    }

    Screen screen = this.get(screenName);
    if (screen == null) {
      return;
    }

    this.display(screen);
}public void add(final Screen screen) {
    screen.setWidth(Game.window().getWidth());
    screen.setHeight(Game.window().getHeight());
    this.screens.add(screen);

    if (this.current() == null) {
      this.display(screen);
    }
}public void remove(Screen screen) {
    this.screens.remove(screen);
    if (this.current() == screen) {
      if (!this.screens.isEmpty()) {
        this.display(this.screens.get(0));
      } else {
        this.display((Screen) null);
      }
    }
}public void display(@Nullable final Screen screen) {
    if (Game.hasStarted() && Game.time().since(this.lastScreenChange) < this.getChangeCooldown()) {
      log.log(
          Level.INFO,
          "Skipping displaying of screen {0} because screen changing is currently on cooldown.",
          screen != null ? screen.getName() : "");
      return;
    }

    final Screen previous = this.current();
    if (previous != null) {
      previous.suspend();
    }

    if (screen != null && !this.screens.contains(screen)) {
      this.screens.add(screen);
    }

    this.currentScreen = screen;
    if (!Game.isInNoGUIMode() && this.current() != null) {
      this.current().prepare();
    }

    this.lastScreenChange = Game.loop().getTicks();

    final ScreenChangedEvent event = new ScreenChangedEvent(this.current(), previous);
    for (final ScreenChangedListener listener : this.screenChangedListeners) {
      listener.changed(event);
    }
}
}
```
```java
class de.gurkenlabs.litiengine.abilities.Ability {
public boolean isOnCooldown() {
    return (this.getCurrentExecution() != null
        && this.getCurrentExecution().getExecutionTicks() > 0
        && Game.time().since(this.getCurrentExecution().getExecutionTicks())
            < this.getAttributes().cooldown().get());
}public boolean isActive() {
    return this.getCurrentExecution() != null
        && Game.time().since(this.getCurrentExecution().getExecutionTicks())
            < this.getAttributes().duration().get();
}@Nullable
  public AbilityExecution cast() {
    if (!this.canCast()) {
      return null;
    }
    this.currentExecution = new AbilityExecution(this);

    for (final AbilityCastListener listener : this.abilityCastListeners) {
      listener.abilityCast(this.currentExecution);
    }

    return this.getCurrentExecution();
}public float getRemainingCooldownInSeconds() {
    if (this.getCurrentExecution() == null
        || this.getExecutor() == null
        || this.getExecutor().isDead()) {
      return 0;
    }

    // calculate cooldown in seconds
    return (float)
        (!this.canCast()
            ? (this.getAttributes().cooldown().get()
                    - Game.time().since(this.getCurrentExecution().getExecutionTicks()))
                * 0.001
            : 0);
}
}
```
```java
class de.gurkenlabs.litiengine.entities.EntityHitEvent {
EntityHitEvent(
      final ICombatEntity hitEntity,
      @Nullable final Ability ability,
      final int damage,
      final boolean kill) {
    super(hitEntity);
    this.executor = ability != null ? ability.getExecutor() : null;
    this.hitEntity = hitEntity;
    this.ability = ability;
    this.damage = damage;
    this.kill = kill;
    this.time = Game.time().now();
}
}
```
```java
class de.gurkenlabs.litiengine.graphics.emitters.Emitter {
public void delete() {
    this.deactivate();
    if (Game.world().environment() != null) {
      Game.world().environment().remove(this);
    }
}public void activate() {
    if (this.activated) {
      return;
    }

    this.activated = true;
    this.activationTick = Game.time().now();
    Game.loop().attach(this);
}@Override
  public void update() {
    if (this.isPaused()) {
      return;
    }

    // clear particles if the effect time to life is reached
    if (this.isFinished()) {
      for (EmitterFinishedListener listener : this.finishedListeners) {
        listener.finished(this);
      }

      this.delete();
      return;
    }

    final float updateRatio = (float) this.data().getUpdateRate() / Game.loop().getTickRate();
    for (final Particle p : this.getParticles().stream().collect(Collectors.toList())) {
      if (this.particleCanBeRemoved(p)) {
        // remove dead particles
        this.particles.remove(p);
        continue;
      }

      p.update(this.getOrigin(), updateRatio);
    }

    this.aliveTime = Game.time().since(this.activationTick);
    if ((this.data().getSpawnRate() == 0
        || Game.time().since(this.lastSpawn) >= this.data().getSpawnRate())) {
      this.lastSpawn = Game.time().now();
      this.spawnParticle();
    }
}
}
```
```java
class de.gurkenlabs.litiengine.GameLoop {
@Override
  public int perform(int delay, Runnable action) {
    final long d = Game.time().toTicks(delay);

    TimedAction a = new TimedAction(this.getTicks() + d, action);
    this.actions.add(a);

    return a.getId();
}
}
```
```java
class de.gurkenlabs.litiengine.environment.EntitySpawner {
protected boolean shouldSpawn() {
    return this.lastSpawnWave == 0
        || Game.time().since(this.lastSpawnWave) >= this.getSpawnInterval();
}@Override
  public void update() {
    if (!this.shouldSpawn()) {
      return;
    }

    this.spawnNewEntities();
    this.lastSpawnWave = Game.time().now();
}
}
```
```java
class de.gurkenlabs.litiengine.graphics.FreeFlightCamera {
@Override
  public void update() {
    this.handleFreeFlightCamera();
}public FreeFlightCamera(double x, double y) {
    this(new Point2D.Double(x, y));
}
}
```
```java
class de.gurkenlabs.litiengine.environment.Environment {
public void unload() {
    if (!this.loaded) {
      return;
    }

    // unregister all updatable entities from the current environment
    for (final IEntity entity : this.allEntities.values()) {
      this.unload(entity);
    }

    this.loaded = false;
    this.fireEvent(l -> l.unloaded(this));
}private static void loadUpdatableOrEmitterEntity(IEntity entity) {
    if (entity instanceof Emitter) {
      final Emitter emitter = (Emitter) entity;
      if (emitter.isActivateOnInit()) {
        emitter.activate();
      }
    } else if (entity instanceof IUpdateable) {
      Game.loop().attach((IUpdateable) entity);
    }
}public void clear() {
    Game.physics().clear();

    this.combatEntities.clear();
    this.mobileEntities.clear();
    this.gravityForces.clear();
    this.layerEntities.clear();
    this.entitiesByTag.clear();
    this.allEntities.clear();

    for (RenderType renderType : RenderType.values()) {
      this.miscEntities.get(renderType).clear();
      this.renderListeners.get(renderType).clear();
      this.renderables.get(renderType).clear();
    }

    dispose(this.allEntities.values());
    dispose(this.triggers);
    this.emitters.clear();
    this.colliders.clear();
    this.props.clear();
    this.creatures.clear();
    this.staticShadows.clear();
    this.combatEntities.clear();
    this.mobileEntities.clear();
    this.lightSources.clear();
    this.spawnPoints.clear();
    this.soundSources.clear();
    this.mapAreas.clear();
    this.triggers.clear();

    this.ambientLight = null;
    this.staticShadowLayer = null;

    for (Map<Integer, IEntity> type : this.miscEntities.values()) {
      type.clear();
    }

    this.initialized = false;

    this.fireEvent(l -> l.cleared(this));
}private void load(final IEntity entity) {
    // an entity can only exist on one environment at a time, so remove it from the current one
    if (entity.getEnvironment() != null) {
      entity.getEnvironment().remove(entity);
    }

    // 1. add to physics engine
    loadPhysicsEntity(entity);

    // 2. register for update or activate
    loadUpdatableOrEmitterEntity(entity);

    // 3. if a gravity is defined, add a gravity force to the entity
    if (entity instanceof IMobileEntity && this.getGravity() != 0) {
      this.addGravityForce((IMobileEntity) entity);
    }

    // 4. attach all controllers
    entity.attachControllers();

    if (this.loaded && (entity instanceof LightSource || entity instanceof StaticShadow)) {
      this.updateLighting(entity);
    }

    entity.loaded(this);
}private void unload(final IEntity entity) {
    // 1. remove from physics engine
    if (entity instanceof ICollisionEntity) {
      Game.physics().remove((ICollisionEntity) entity);
    }

    // 2. unregister from update
    if (entity instanceof IUpdateable) {
      Game.loop().detach((IUpdateable) entity);
    }

    if (entity instanceof IMobileEntity) {
      this.removeGravity((IMobileEntity) entity);
    }

    // 3. detach all controllers
    entity.detachControllers();

    if (entity instanceof Emitter) {
      Emitter em = (Emitter) entity;
      em.deactivate();
    }

    if (this.loaded && (entity instanceof LightSource || entity instanceof StaticShadow)) {
      this.updateLighting(entity);
    }

    entity.removed(this);
}public void remove(final IEntity entity) {
    if (entity == null) {
      return;
    }

    this.allEntities.remove(entity.getMapId());
    Iterator<List<IEntity>> iter = this.layerEntities.values().iterator();
    while (iter.hasNext()) {
      List<IEntity> layer = iter.next();
      if (layer.remove(entity) && layer.isEmpty()) {
        iter.remove();
      }
    }
    if (this.miscEntities.get(entity.getRenderType()) != null) {
      this.miscEntities.get(entity.getRenderType()).values().remove(entity);
    }

    for (String tag : entity.getTags()) {
      if (this.getEntitiesByTag().containsKey(tag)) {
        this.getEntitiesByTag().get(tag).remove(entity);

        if (this.getEntitiesByTag().get(tag).isEmpty()) {
          this.getEntitiesByTag().remove(tag);
        }
      }
    }

    if (entity instanceof Emitter) {
      Emitter emitter = (Emitter) entity;
      this.removeEmitter(emitter);
    }

    if (entity instanceof MapArea) {
      this.mapAreas.remove(entity);
    }

    if (entity instanceof Prop) {
      this.props.remove(entity);
    }

    if (entity instanceof Creature) {
      this.creatures.remove(entity);
    }

    if (entity instanceof CollisionBox) {
      this.colliders.remove(entity);
      this.staticShadows.removeIf(x -> x.getOrigin() != null && x.getOrigin().equals(entity));
    }

    if (entity instanceof LightSource) {
      this.lightSources.remove(entity);
      this.updateLighting(entity);
    }

    if (entity instanceof Trigger) {
      this.triggers.remove(entity);
    }

    if (entity instanceof Spawnpoint) {
      this.spawnPoints.remove(entity);
    }
    if (entity instanceof SoundSource) {
      this.soundSources.remove(entity);
    }

    if (entity instanceof StaticShadow) {
      this.staticShadows.remove(entity);
      this.updateLighting(entity);
    }

    if (entity instanceof IMobileEntity) {
      this.mobileEntities.values().remove(entity);
    }

    if (entity instanceof ICombatEntity) {
      this.combatEntities.values().remove(entity);
    }

    this.unload(entity);

    this.fireEntityEvent(l -> l.entityRemoved(entity));
}
}
```
```java
class de.gurkenlabs.litiengine.physics.MovementController {
@Override
  public void update() {
    this.handleForces();
    this.handleMovement();
}
}
```
```java
class de.gurkenlabs.litiengine.Game {
static synchronized void terminate() {
    if (!initialized) {
      return;
    }

    hasStarted = false;
    initialized = false;

    config().save();
    gameLoop.terminate();
    tweenEngine.terminate();
    soundEngine.terminate();

    world().clear();

    for (final GameListener listener : gameListeners) {
      try {
        listener.terminated();
      } catch (Exception e) {
        log().log(Level.WARNING, "game listener threw an exception during shutdown", e);
      }
    }

    gameLoop = null;
    screenManager = null;
    gameWindow = null;
}public static synchronized void start() {
    if (!initialized) {
      throw new IllegalStateException(
          "The game cannot be started without being first initialized. Call Game.init(...) before Game.start().");
    }

    gameLoop.start();
    tweenEngine.start();
    soundEngine.start();

    for (final GameListener listener : gameListeners) {
      listener.started();
    }

    hasStarted = true;
}public static synchronized void init(String... args) {
    if (initialized) {
      log().log(Level.INFO, "The game has already been initialized.");
      return;
    }

    log.init();
    handleCommandLineArguments(args);

    config().load();
    Locale.setDefault(new Locale(config().client().getCountry(), config().client().getLanguage()));

    gameLoop = new GameLoop("Main Update Loop", config().client().getMaxFps());
    loop().attach(physics());
    loop().attach(world());

    // setup default exception handling for render and update loop
    setUncaughtExceptionHandler(
        new DefaultUncaughtExceptionHandler(config().client().exitOnError()));

    screenManager = new ScreenManager();
    gameWindow = new GameWindow();

    // initialize  the game window
    window().init();
    world.setCamera(new Camera());

    for (GameListener listener : gameListeners) {
      listener.initialized(args);
    }

    if (!isInNoGUIMode()) {
      window().getRenderComponent().onRendered(g -> metrics().render(g));

      graphics()
          .addEntityRenderedListener(
              e -> DebugRenderer.renderEntityDebugInfo(e.getGraphics(), e.getEntity()));

      window().getRenderComponent().onFpsChanged(fps -> metrics().setFramesPerSecond(fps));
      window()
          .setIcons(
              Arrays.asList(
                  Resources.images().get("liti-logo-x16.png"),
                  Resources.images().get("liti-logo-x20.png"),
                  Resources.images().get("liti-logo-x32.png"),
                  Resources.images().get("liti-logo-x48.png")));

      Input.keyboard()
          .onKeyTyped(
              KeyEvent.VK_PRINTSCREEN,
              key -> {
                // don't take a screenshot if a modifier is active
                if (key.getModifiers() != 0) {
                  return;
                }

                window().getRenderComponent().takeScreenshot();
              });
    }

    Runtime.getRuntime().addShutdownHook(new Thread(Game::terminate, "Shutdown"));

    initialized = true;
}
}
```


Response Format:
Provide the answer in **XML format** as follows:

#### If the method **cannot** return `null` at the specific call site:
```xml
<response>
  <reason><![CDATA[EXPLAIN WHY THE INVOCATION Game.loop() RESULT CANNOT BE NULL.]]></reason>
  <value>NO</value>
</response>

#### If the method can return null at the specific call site:
<response>
  <reason><![CDATA[EXPLAIN WHY THE INVOCATION Game.loop() RESULT CAN BE NULL.]]></reason>
  <value>YES</value>
</response>

#### If you are unsure or If there are any methods that directly or indirectly affect the return value and are not fully disclosed, request their declarations first, in the following format:
<response>
  <reason><![CDATA[EXPLAIN WHY THIS METHOD DECLARATION IS NECESSARY AND WHY YOU CANNOT MAKE A CONFIDENT DECISION WITHOUT IT]]></reason>
  <success>false</success>
  <methods>
    <method>methodName</method>
  </methods>
</response>

Additional Notes:
Be precise in your reasoning.
If a method’s return value depends on another method not provided, request its declaration before making a conclusion.
If the method can return null in this case but not in others, explain why it happens specifically for this call.

---ChatGPT.sendRequestToOpenAI---
Retrieving response from cache
---Response.<init>---
Creating Response:
```xml
<response>
  <reason><![CDATA[The method `Game.loop()` returns the static field `gameLoop`, which is initialized in the `Game.init(String... args)` method. In this method, a new `GameLoop` object is instantiated and assigned to `gameLoop`. Since `init()` must be called before `start()`, which is implied by the requirement of initializing the game, the `gameLoop` is guaranteed to be non-null during the lifetime of the game execution where `Game.loop()` is called. The absence of any code that could set `gameLoop` to null after its initialization ensures that `Game.loop()` cannot return null.]]></reason>
  <value>NO</value>
</response>
```
---Response.<init>---
Response created:
Disagreement: The method `Game.loop()` returns the static field `gameLoop`, which is initialized in the `Game.init(String... args)` method. In this method, a new `GameLoop` object is instantiated and assigned to `gameLoop`. Since `init()` must be called before `start()`, which is implied by the requirement of initializing the game, the `gameLoop` is guaranteed to be non-null during the lifetime of the game execution where `Game.loop()` is called. The absence of any code that could set `gameLoop` to null after its initialization ensures that `Game.loop()` cannot return null.
---AdvancedNullAwayCodeFix.resolveMethodDereferenceError---
Method is not returning nullable on call site. Injecting suppression annotation.
---AdvancedNullAwayCodeFix.constructCastToNonnullChange---
Constructing cast to nonnull change for reason: The method `Game.loop()` returns the static field `gameLoop`, which is initialized in the `Game.init(String... args)` method. In this method, a new `GameLoop` object is instantiated and assigned to `gameLoop`. Since `init()` must be called before `start()`, which is implied by the requirement of initializing the game, the `gameLoop` is guaranteed to be non-null during the lifetime of the game execution where `Game.loop()` is called. The absence of any code that could set `gameLoop` to null after its initialization ensures that `Game.loop()` cannot return null.
---ChatGPT.ask---
Asking ChatGPT:
For the reason you mentioned earlier:

"The method `Game.loop()` returns the static field `gameLoop`, which is initialized in the `Game.init(String... args)` method. In this method, a new `GameLoop` object is instantiated and assigned to `gameLoop`. Since `init()` must be called before `start()`, which is implied by the requirement of initializing the game, the `gameLoop` is guaranteed to be non-null during the lifetime of the game execution where `Game.loop()` is called. The absence of any code that could set `gameLoop` to null after its initialization ensures that `Game.loop()` cannot return null."

in the method below, the expression Game.loop() is not nullable at the point it is used.

```java
protected void spawnNewEntities() {
    if (this.getSpawnMode() != SpawnMode.CUSTOMSPAWNPOINTS && this.getSpawnPoints().isEmpty()) {
      return;
    }

    switch (this.getSpawnMode()) {
      case ALLSPAWNPOINTS:
        for (int i = 0; i < this.getSpawnPoints().size(); i++) {
          final int index = i;
          Game.loop()
              .perform(
                  this.getSpawnDelay() + this.getSpawnDelay() * i,
                  () -> this.spawn(this.getSpawnPoints().get(index), this.getSpawnAmount()));
        }
        break;
      case ONERANDOMSPAWNPOINT:
        this.spawn(Game.random().choose(this.getSpawnPoints()), this.getSpawnAmount());
        break;
      case RANDOMSPAWNPOINTS:
        for (int i = 0; i < this.getSpawnAmount(); i++) {
          Game.loop()
              .perform(
                  this.getSpawnDelay() + this.getSpawnDelay() * i,
                  () -> this.spawn(Game.random().choose(this.getSpawnPoints()), 1));
        }
        break;
      case CUSTOMSPAWNPOINTS:
        List<Spawnpoint> spawnPoints =
            this.customSpawnpoints != null
                ? this.customSpawnpoints.apply(this)
                : this.getCustomSpawnpoints();

        int index = 0;
        for (Spawnpoint spawn : spawnPoints) {
          Game.loop()
              .perform(
                  this.getSpawnDelay() + this.getSpawnDelay() * index, () -> this.spawn(spawn, 1));
          index++;
        }
        break;
      default:
        break;
    }
}
```
Please Summarize the reason in max 5 words and rewrite the method so that at the line "          Game.loop()", at the occurrence of: "Game.loop()" is replaced with `NullabilityUtil.castToNonnull(Game.loop(), summary of reason)`
Replace "REASON" with the exact reason summary I provide to you (maximum 5 words), not with a generic explanation like "checked to be nonnull".
see the example below, for expression `foo.getBar()`, to wrap it with `NullabilityUtil.castToNonnull(foo.getBar(), "reason")`.

```java
public t(){
    String l = foo.getBar();
}
```

will be:
```java
public t(){
    String l = NullabilityUtil.castToNonnull(foo.getBar(), "checked to be nonnull");
}
```

### Instructions:

Do not import any additional classes.

Do not add Java comments.

Only modify relevant lines as required.

Return only the modified method wrapped in the XML format shown below.

Place the Java code inside the <code> tag using a CDATA block with ```java formatting.

Just give me the fixed code snippet in XML format in <response> tag like the example below. I will apply the fix to my codebase. Do not import any additional libraries or classes or add java comments. If you can provide the fixed code snippet, please provide it in the following format and place the code snippet in the <code> tag within ```java block.
<response>
  <success>true</success>
  <code><![CDATA[
  ```java
  Your fixed code snippet here
  ```
    ]]>
  </code>
</response>

---ChatGPT.sendRequestToOpenAI---
Retrieving response from cache
---Response.<init>---
Creating Response:
<response>
  <success>true</success>
  <code><![CDATA[
  ```java
  protected void spawnNewEntities() {
      if (this.getSpawnMode() != SpawnMode.CUSTOMSPAWNPOINTS && this.getSpawnPoints().isEmpty()) {
        return;
      }
  
      switch (this.getSpawnMode()) {
        case ALLSPAWNPOINTS:
          for (int i = 0; i < this.getSpawnPoints().size(); i++) {
            final int index = i;
            NullabilityUtil.castToNonnull(Game.loop(), "guaranteed to be non-null")
                .perform(
                    this.getSpawnDelay() + this.getSpawnDelay() * i,
                    () -> this.spawn(this.getSpawnPoints().get(index), this.getSpawnAmount()));
          }
          break;
        case ONERANDOMSPAWNPOINT:
          this.spawn(Game.random().choose(this.getSpawnPoints()), this.getSpawnAmount());
          break;
        case RANDOMSPAWNPOINTS:
          for (int i = 0; i < this.getSpawnAmount(); i++) {
            NullabilityUtil.castToNonnull(Game.loop(), "guaranteed to be non-null")
                .perform(
                    this.getSpawnDelay() + this.getSpawnDelay() * i,
                    () -> this.spawn(Game.random().choose(this.getSpawnPoints()), 1));
          }
          break;
        case CUSTOMSPAWNPOINTS:
          List<Spawnpoint> spawnPoints =
              this.customSpawnpoints != null
                  ? this.customSpawnpoints.apply(this)
                  : this.getCustomSpawnpoints();
  
          int index = 0;
          for (Spawnpoint spawn : spawnPoints) {
            NullabilityUtil.castToNonnull(Game.loop(), "guaranteed to be non-null")
                .perform(
                    this.getSpawnDelay() + this.getSpawnDelay() * index, () -> this.spawn(spawn, 1));
            index++;
          }
          break;
        default:
          break;
      }
  }
  ```
    ]]>
  </code>
</response>
---Response.<init>---
Response created:
protected void spawnNewEntities() {
      if (this.getSpawnMode() != SpawnMode.CUSTOMSPAWNPOINTS && this.getSpawnPoints().isEmpty()) {
        return;
      }
  
      switch (this.getSpawnMode()) {
        case ALLSPAWNPOINTS:
          for (int i = 0; i < this.getSpawnPoints().size(); i++) {
            final int index = i;
            NullabilityUtil.castToNonnull(Game.loop(), "guaranteed to be non-null")
                .perform(
                    this.getSpawnDelay() + this.getSpawnDelay() * i,
                    () -> this.spawn(this.getSpawnPoints().get(index), this.getSpawnAmount()));
          }
          break;
        case ONERANDOMSPAWNPOINT:
          this.spawn(Game.random().choose(this.getSpawnPoints()), this.getSpawnAmount());
          break;
        case RANDOMSPAWNPOINTS:
          for (int i = 0; i < this.getSpawnAmount(); i++) {
            NullabilityUtil.castToNonnull(Game.loop(), "guaranteed to be non-null")
                .perform(
                    this.getSpawnDelay() + this.getSpawnDelay() * i,
                    () -> this.spawn(Game.random().choose(this.getSpawnPoints()), 1));
          }
          break;
        case CUSTOMSPAWNPOINTS:
          List<Spawnpoint> spawnPoints =
              this.customSpawnpoints != null
                  ? this.customSpawnpoints.apply(this)
                  : this.getCustomSpawnpoints();
  
          int index = 0;
          for (Spawnpoint spawn : spawnPoints) {
            NullabilityUtil.castToNonnull(Game.loop(), "guaranteed to be non-null")
                .perform(
                    this.getSpawnDelay() + this.getSpawnDelay() * index, () -> this.spawn(spawn, 1));
            index++;
          }
          break;
        default:
          break;
      }
  }
---ChatGPT.fixDereferenceByAddingCastToNonnull---
Fixing the error by adding castToNonnull
---AdvancedNullAwayCodeFix.fixTriggeredErrorsForLocation---
Resolving unresolvable error for triggered error: Type='DEREFERENCE_NULLABLE', message='dereferenced expression Game.loop() is @Nullable'
/home/nima/Developer/nullness-benchmarks/litiengine/src/de/gurkenlabs/litiengine/environment/GameWorld.java:349
    Lock lock = Game.loop().getLock();
---AdvancedNullAwayCodeFix.fix---
Fixing error: Type='DEREFERENCE_NULLABLE', message='dereferenced expression Game.loop() is @Nullable'
/home/nima/Developer/nullness-benchmarks/litiengine/src/de/gurkenlabs/litiengine/environment/GameWorld.java:349
    Lock lock = Game.loop().getLock();
---AdvancedNullAwayCodeFix.resolveDereferenceError---
Resolving dereference error: Type='DEREFERENCE_NULLABLE', message='dereferenced expression Game.loop() is @Nullable'
/home/nima/Developer/nullness-benchmarks/litiengine/src/de/gurkenlabs/litiengine/environment/GameWorld.java:349
    Lock lock = Game.loop().getLock();
---AdvancedNullAwayCodeFix.resolveDereferenceError---
Checking nullability possibility at error point
---ChatGPT.checkNullabilityPossibilityAtErrorPoint---
Asking if the expression can be null at error point point
---ChatGPT.ask---
Asking ChatGPT:
In the method below, is there a possibility that the expression "Game.loop()" at line "Lock lock = Game.loop().getLock();" is null?
public void loadEnvironment(@Nullable final Environment env) {
    Lock lock = Game.loop().getLock();
    lock.lock();
    try {
      unloadEnvironment();
      this.environment = env;
      if (env != null) {
        this.addEnvironment(env);

        if (env.getGravity() == 0 && this.gravity() != 0) {
          env.setGravity(this.gravity());
        }

        env.load();
        for (final EnvironmentLoadedListener listener : this.loadedListeners) {
          listener.loaded(env);
        }

        // call map specific listeners
        String mapName = getMapName(env);
        if (mapName != null && this.environmentLoadedListeners.containsKey(mapName)) {

          // for the default camera we center the camera on the environment
          if (this.camera().getClass().equals(Camera.class)) {
            camera().setFocus(env.getCenter());
          }

          for (EnvironmentLoadedListener listener : this.environmentLoadedListeners.get(mapName)) {
            listener.loaded(env);
          }
        }
      }
    } finally {
      lock.unlock();
    }
}
Give a single-word answer in XML format. If it is possible for the expression to be null, respond with:
```xml
<response>
    <reason><![CDATA[YOUR REASON]]></reason>
    <value>YES</value>
</response>
```
If it is not possible for the expression to be null, respond with:
```xml
<response>
    <reason><![CDATA[YOUR REASON]]></reason>
    <value>NO</value>
</response>
```
If you are unsure or need more information, respond with where you can ask for more details or what specific information you need.

If additional information is required, list each request inside a `<request>` tag. If no additional information is needed, omit the `<requests>` section.

Respond with:
```xml
<response>
    <reason><![CDATA[YOUR REASON]]></reason>
    <value>UNKNOWN</value>
    <!-- Include <requests> only if additional information is needed -->
    <requests>
        <request><![CDATA[YOUR REQUEST 1]]></request>
        <request><![CDATA[YOUR REQUEST 2]]></request>
    </requests>
</response>
```
---ChatGPT.sendRequestToOpenAI---
Sending request to OpenAI...
---ChatGPT.sendRequestToOpenAI---
Response received from OpenAI.
---Response.<init>---
Creating Response:
```xml
<response>
    <reason><![CDATA[The possibility of Game.loop() returning null depends on the implementation of the Game class and its loop() method, which is not provided in the code snippet.]]></reason>
    <value>UNKNOWN</value>
    <requests>
        <request><![CDATA[Details about the implementation of the Game class, particularly the loop() method.]]></request>
    </requests>
</response>
```
---Response.<init>---
Response created:
Unknown: The possibility of Game.loop() returning null depends on the implementation of the Game class and its loop() method, which is not provided in the code snippet.
---AdvancedNullAwayCodeFix.resolveMethodDereferenceError---
Resolving method dereference error.
---AdvancedNullAwayCodeFix.resolveMethodDereferenceError---
Method is in annotated package. Checking if the method is returning nullable.
---AdvancedNullAwayCodeFix.investigateMethodReturnNullability---
Checking if the method is returning nullable.
---ChatGPT.checkIfMethodIsReturningNullable---
Asking if the method is returning nullable: loop()
---ChatGPT.ask---
Asking ChatGPT:
In the method below, is there a possibility that the method returns null based only on its body? Consider the following points:

- The method may have multiple return paths; consider all return statements.
- If the method calls another method, do not assume its return value unless its full declaration is provided. Request its declaration if needed.
- The method may throw an exception instead of returning null. An exception path should not be considered a null return.
- Ensure you request the declarations of any methods whose return values directly or indirectly impact this method’s return value before making a conclusion.
- Carefully analyze all conditions and prior operations that may guarantee a non-null return value.

@Nullable public static IGameLoop loop() {
    return gameLoop;
}

Here are the method definitions in addition to the method inquired:

Depth: 0
```java
class de.gurkenlabs.litiengine.Game {
@Nullable public static IGameLoop loop() {
    return gameLoop;
}
}
```


Response Format:
Provide the answer in **XML format** as follows:

#### If the method **cannot** return `null`:
```xml
<response>
  <reason><![CDATA[EXPLAIN WHY THE METHOD CANNOT RETURN NULL]]></reason>
  <value>NO</value>
</response>
```

#### If the method can return null:
```xml
<response>
  <reason><![CDATA[EXPLAIN WHY THE METHOD CAN RETURN NULL]]></reason>
  <value>YES</value>
</response>
```

#### If you are unsure or need more information, respond with where you can ask for more details or what specific information you need.

#### If you are unsure or If there are any methods that directly or indirectly affect the return value and are not fully disclosed, request their declarations first, in the following format:
<response>
  <reason><![CDATA[YOUR REASON]]></reason>
  <value>UNKNOWN</value>
  <methods>
    <method>methodName</method>
  </methods>
</response>

If additional information is required other than method declaration, list each request inside a `<request>` tag. If no additional information is needed, omit the `<requests>` section.

Respond with:
```xml
<response>
    <reason><![CDATA[YOUR REASON]]></reason>
    <value>UNKNOWN</value>
    <!-- Include <requests> only if additional information is needed -->
    <requests>
        <request><![CDATA[YOUR REQUEST 1]]></request>
        <request><![CDATA[YOUR REQUEST 2]]></request>
    </requests>
</response>
```

Additional Notes:
Be precise in your reasoning.
If a method’s return value depends on another method not provided, request its declaration before making a conclusion.
If the method can return null in some cases but not others, explain under what conditions it can happen.

---ChatGPT.sendRequestToOpenAI---
Retrieving response from cache
---Response.<init>---
Creating Response:
```xml
<response>
  <reason><![CDATA[The method `loop` returns the variable `gameLoop`. Without the initialization or assignment details of `gameLoop`, it's unclear whether it can be null. The possibility of `gameLoop` being uninitialized or set to null elsewhere in the program means `loop` could potentially return null. Further information on `gameLoop` is required.]]></reason>
  <value>UNKNOWN</value>
  <requests>
    <request><![CDATA[Please provide the declaration and initialization of the variable `gameLoop` in the class `de.gurkenlabs.litiengine.Game`.]]></request>
  </requests>
</response>
```
---Response.<init>---
Response created:
Unknown: The method `loop` returns the variable `gameLoop`. Without the initialization or assignment details of `gameLoop`, it's unclear whether it can be null. The possibility of `gameLoop` being uninitialized or set to null elsewhere in the program means `loop` could potentially return null. Further information on `gameLoop` is required.
---AdvancedNullAwayCodeFix.investigateMethodReturnNullability---
Could not determine the nullability and model did not ask for any method.
---ChatGPT.checkIfMethodIsReturningNullableOnCallSite---
Asking if the method is returning nullable on the call site: Game.loop()
---ChatGPT.ask---
Asking ChatGPT:
In the method below, is there a possibility that the method returns null at the given call site?

```java
@Nullable public static IGameLoop loop() {
    return gameLoop;
}
```

## Guidelines:
- The method may have multiple return paths; consider all return statements.
- If the method calls another method, do not assume its return value unless its full declaration is provided. Request its declaration if needed.
- The method may throw an exception instead of returning null. An exception path should not be considered a null return.
- Ensure you request the declarations of any methods whose return values directly or indirectly impact this method’s return value before making a conclusion.
- If the method returns a value that is determined by a parameter, evaluate based on the actual argument at the given call site.
- Analyze based only on the specific invocation provided. Do not generalize to all possible inputs.- If the return value is guaranteed to be non-null at the call site, the answer should be a definitive NO.
- Do not generalize based on all possible inputs—your answer must be based only on the given invocation.
- Focus only on the given call site, not all possible invocations.

### call site:
Game.loop()

Here are the method definitions and the call chain for this method, showing the sequence of calls from the method to its callers at each depth level:

Depth: 0
```java
class de.gurkenlabs.litiengine.Game {
@Nullable public static IGameLoop loop() {
    return gameLoop;
}
}
```
Depth: 1
```java
class de.gurkenlabs.litiengine.environment.GameWorld {
public void loadEnvironment(@Nullable final Environment env) {
    Lock lock = Game.loop().getLock();
    lock.lock();
    try {
      unloadEnvironment();
      this.environment = env;
      if (env != null) {
        this.addEnvironment(env);

        if (env.getGravity() == 0 && this.gravity() != 0) {
          env.setGravity(this.gravity());
        }

        env.load();
        for (final EnvironmentLoadedListener listener : this.loadedListeners) {
          listener.loaded(env);
        }

        // call map specific listeners
        String mapName = getMapName(env);
        if (mapName != null && this.environmentLoadedListeners.containsKey(mapName)) {

          // for the default camera we center the camera on the environment
          if (this.camera().getClass().equals(Camera.class)) {
            camera().setFocus(env.getCenter());
          }

          for (EnvironmentLoadedListener listener : this.environmentLoadedListeners.get(mapName)) {
            listener.loaded(env);
          }
        }
      }
    } finally {
      lock.unlock();
    }
}public void setCamera(@Nullable final ICamera cam) {
    if (this.camera() != null) {
      Game.loop().detach(camera);
    }

    camera = cam;

    if (cam != null && !Game.isInNoGUIMode()) {
      Game.loop().attach(cam);
      cam.updateFocus();
    }
}
}
```
```java
class de.gurkenlabs.litiengine.entities.behavior.EntityNavigator {
public EntityNavigator(final IMobileEntity entity, final PathFinder pathFinder) {
    this.cancelNavigationConditions = new CopyOnWriteArrayList<>();
    this.listeners = new CopyOnWriteArrayList<>();
    this.entity = entity;
    this.pathFinder = pathFinder;
    this.setAcceptableError(DEFAULT_ACCEPTABLE_ERROR);
    Game.loop().attach(this);
}
}
```
```java
class de.gurkenlabs.litiengine.GameWindow {
private static void initializeWindowEventListeners(Window window) {

    window.addWindowStateListener(
        e -> {
          if (e.getNewState() == Frame.ICONIFIED) {
            Game.loop().setTickRate(ICONIFIED_MAX_FPS);
          } else {
            Game.loop().setTickRate(Game.config().client().getMaxFps());
          }
        });

    window.addWindowFocusListener(
        new WindowFocusListener() {
          @Override
          public void windowLostFocus(WindowEvent e) {
            if (Game.config().graphics().reduceFramesWhenNotFocused()) {
              Game.loop().setTickRate(NONE_FOCUS_MAX_FPS);
            }
          }

          @Override
          public void windowGainedFocus(WindowEvent e) {
            Game.loop().setTickRate(Game.config().client().getMaxFps());
          }
        });

    window.addWindowListener(
        new WindowAdapter() {
          @Override
          public void windowClosing(final WindowEvent event) {
            Game.exit();
          }
        });
}
}
```
```java
class de.gurkenlabs.litiengine.gui.screens.ScreenManager {
public void display(@Nullable final Screen screen) {
    if (Game.hasStarted() && Game.time().since(this.lastScreenChange) < this.getChangeCooldown()) {
      log.log(
          Level.INFO,
          "Skipping displaying of screen {0} because screen changing is currently on cooldown.",
          screen != null ? screen.getName() : "");
      return;
    }

    final Screen previous = this.current();
    if (previous != null) {
      previous.suspend();
    }

    if (screen != null && !this.screens.contains(screen)) {
      this.screens.add(screen);
    }

    this.currentScreen = screen;
    if (!Game.isInNoGUIMode() && this.current() != null) {
      this.current().prepare();
    }

    this.lastScreenChange = Game.loop().getTicks();

    final ScreenChangedEvent event = new ScreenChangedEvent(this.current(), previous);
    for (final ScreenChangedListener listener : this.screenChangedListeners) {
      listener.changed(event);
    }
}
}
```
```java
class de.gurkenlabs.litiengine.abilities.effects.Effect {
@Override
  public void update() {

    for (final Iterator<EffectApplication> iterator = this.getActiveAppliances().iterator();
        iterator.hasNext(); ) {
      final EffectApplication appliance = iterator.next();
      // if the effect duration is reached
      if (this.hasEnded(appliance)) {

        iterator.remove();
        this.cease(appliance);
      }
    }

    // 4. unregister if all appliances are finished
    if (this.getActiveAppliances().isEmpty()) {
      Game.loop().detach(this);
    }
}public void apply(final Shape impactArea) {
    final List<ICombatEntity> affected = this.lookForAffectedEntities(impactArea);
    for (final ICombatEntity affectedEntity : affected) {
      this.apply(affectedEntity);
    }

    this.appliances.add(new EffectApplication(affected, impactArea));

    // if it is the first appliance -> register for update
    if (this.appliances.size() == 1) {
      Game.loop().attach(this);
    }
}
}
```
```java
class de.gurkenlabs.litiengine.GameTime {
public long toTicks(final int milliseconds) {
    return this.toTicks(milliseconds, Game.loop().getTickRate());
}public long since(final long tick) {
    return toMilliseconds(Game.loop().getTicks() - tick);
}public long now() {
    return Game.loop().getTicks();
}public long sinceGameStart() {
    return this.toMilliseconds(Game.loop().getTicks());
}@Override
  public void loaded(Environment environment) {
    environmentLoaded = Game.loop().getTicks();
}public long toMilliseconds(final long ticks) {
    return this.toMilliseconds(ticks, Game.loop().getTickRate());
}
}
```
```java
class de.gurkenlabs.litiengine.GameMetrics {
@Override
  public void render(final Graphics2D g) {
    this.updateMetrics();

    if (!Game.config().client().showGameMetrics()) {
      return;
    }

    this.currentOffsetY = 0;

    g.setColor(this.renderColor);

    // render client metrics
    this.drawTitle(g, "[client]");
    this.drawMetric(g, "fps       : " + this.getFramesPerSecond());
    this.drawMetric(g, "max fps   : " + this.maxFramesPerSecond);
    this.drawMetric(g, "updatables: " + Game.loop().getUpdatableCount());

    // render jvm metrics if debug is enabled
    if (Game.config().debug().isDebugEnabled()) {
      this.drawTitle(g, "[jvm]");
      this.drawMetric(g, "java      : " + this.javaVersion);
      this.drawMetric(g, "memory    : " + String.format("%-5.5s", this.usedMemory) + " MB");
      this.drawMetric(g, "threads   : " + Thread.activeCount());
    }

    // render rendering metrics
    if (!this.renderMetrics.isEmpty()) {
      this.drawTitle(g, "[update]");

      for (RenderMetrics metric : this.renderMetrics) {
        this.drawMetric(g, metric.toString());
      }

      this.renderMetrics.clear();
    }
}
}
```
```java
class de.gurkenlabs.litiengine.graphics.emitters.Emitter {
public void deactivate() {
    if (!this.activated) {
      return;
    }

    this.activated = false;
    this.getParticles().clear();
    this.aliveTime = 0;
    this.activationTick = 0;
    this.lastSpawn = 0;
    Game.loop().detach(this);
}public void activate() {
    if (this.activated) {
      return;
    }

    this.activated = true;
    this.activationTick = Game.time().now();
    Game.loop().attach(this);
}@Override
  public void update() {
    if (this.isPaused()) {
      return;
    }

    // clear particles if the effect time to life is reached
    if (this.isFinished()) {
      for (EmitterFinishedListener listener : this.finishedListeners) {
        listener.finished(this);
      }

      this.delete();
      return;
    }

    final float updateRatio = (float) this.data().getUpdateRate() / Game.loop().getTickRate();
    for (final Particle p : this.getParticles().stream().collect(Collectors.toList())) {
      if (this.particleCanBeRemoved(p)) {
        // remove dead particles
        this.particles.remove(p);
        continue;
      }

      p.update(this.getOrigin(), updateRatio);
    }

    this.aliveTime = Game.time().since(this.activationTick);
    if ((this.data().getSpawnRate() == 0
        || Game.time().since(this.lastSpawn) >= this.data().getSpawnRate())) {
      this.lastSpawn = Game.time().now();
      this.spawnParticle();
    }
}
}
```
```java
class de.gurkenlabs.litiengine.entities.behavior.IBehaviorController {
public default void attach() {
    Game.loop().attach(this);
}public default void detach() {
    Game.loop().detach(this);
}
}
```
```java
class de.gurkenlabs.litiengine.abilities.AbilityExecution {
AbilityExecution(final Ability ability) {
    this.appliedEffects = new CopyOnWriteArrayList<>();
    this.ability = ability;
    this.executionTicks = Game.time().now();
    this.impactArea = ability.calculateImpactArea();
    this.castLocation = ability.getExecutor().getCenter();
    Game.loop().attach(this);
}@Override
  public void update() {
    // if there a no effects to apply -> unregister this instance and we're done
    if (this.getAbility().getEffects().isEmpty()
        || this.getAbility().getEffects().size() == this.getAppliedEffects().size()) {
      Game.loop().detach(this);
      return;
    }

    // handle all effects from the ability that were not applied yet
    for (final Effect effect : this.getAbility().getEffects()) {
      // if the ability was not executed yet or the delay of the effect is not
      // yet reached
      if (this.getAppliedEffects().contains(effect)
          || Game.time().since(this.getExecutionTicks()) < effect.getDelay()) {
        continue;
      }

      effect.apply(this.getExecutionImpactArea());
      this.getAppliedEffects().add(effect);
    }
}
}
```
```java
class de.gurkenlabs.litiengine.GameWindow$3 {
@Override
          public void windowGainedFocus(WindowEvent e) {
            Game.loop().setTickRate(Game.config().client().getMaxFps());
}@Override
          public void windowLostFocus(WindowEvent e) {
            if (Game.config().graphics().reduceFramesWhenNotFocused()) {
              Game.loop().setTickRate(NONE_FOCUS_MAX_FPS);
            }
}
}
```
```java
class de.gurkenlabs.litiengine.environment.EntitySpawner {
protected void spawnNewEntities() {
    if (this.getSpawnMode() != SpawnMode.CUSTOMSPAWNPOINTS && this.getSpawnPoints().isEmpty()) {
      return;
    }

    switch (this.getSpawnMode()) {
      case ALLSPAWNPOINTS:
        for (int i = 0; i < this.getSpawnPoints().size(); i++) {
          final int index = i;
          Game.loop()
              .perform(
                  this.getSpawnDelay() + this.getSpawnDelay() * i,
                  () -> this.spawn(this.getSpawnPoints().get(index), this.getSpawnAmount()));
        }
        break;
      case ONERANDOMSPAWNPOINT:
        this.spawn(Game.random().choose(this.getSpawnPoints()), this.getSpawnAmount());
        break;
      case RANDOMSPAWNPOINTS:
        for (int i = 0; i < this.getSpawnAmount(); i++) {
          Game.loop()
              .perform(
                  this.getSpawnDelay() + this.getSpawnDelay() * i,
                  () -> this.spawn(Game.random().choose(this.getSpawnPoints()), 1));
        }
        break;
      case CUSTOMSPAWNPOINTS:
        List<Spawnpoint> spawnPoints =
            this.customSpawnpoints != null
                ? this.customSpawnpoints.apply(this)
                : this.getCustomSpawnpoints();

        int index = 0;
        for (Spawnpoint spawn : spawnPoints) {
          Game.loop()
              .perform(
                  this.getSpawnDelay() + this.getSpawnDelay() * index, () -> this.spawn(spawn, 1));
          index++;
        }
        break;
      default:
        break;
    }
}
}
```
```java
class de.gurkenlabs.litiengine.tweening.TweenEngine {
@Override
  public void start() {
    Game.loop().attach(this);
}@Override
  public void terminate() {
    Game.loop().detach(this);
}
}
```
```java
class de.gurkenlabs.litiengine.gui.SpeechBubble {
public void hide() {
    Game.world().environment().removeRenderable(this);
    Game.loop().detach(this);
    if (activeSpeechBubbles.get(this.getEntity()) != null
        && activeSpeechBubbles.remove(this.getEntity()).equals(this)) {
      activeSpeechBubbles.remove(this.getEntity());
    }

    for (SpeechBubbleListener listener : this.listeners) {
      listener.hidden();
    }
}private SpeechBubble(
      final IEntity entity,
      final String text,
      @Nullable SpeechBubbleAppearance appearance,
      @Nullable Font font) {
    if (appearance == null) {
      this.appearance = DEFAULT_APPEARANCE;
    } else {
      this.appearance = appearance;
    }

    final SpeechBubble active = activeSpeechBubbles.get(entity);
    if (active != null) {
      active.hide();
    }
    this.setFont(font);

    this.textBoxWidth = (float) (entity.getWidth() * 4);
    this.entity = entity;

    this.currentText = text;
    this.currentTextDisplayTime = DISPLAYTIME_MIN + text.length() * DISPLAYTIME_PER_LETTER;

    this.lastTextDisplay = Game.time().now();
    this.createBubbleImage();
    entity.getEnvironment().add(this, RenderType.UI);
    Game.loop().attach(this);
    activeSpeechBubbles.put(entity, this);
}
}
```
```java
class de.gurkenlabs.litiengine.entities.Prop {
private void updateAnimationController() {
    IEntityAnimationController<?> controller = this.createAnimationController();
    this.getControllers().addController(controller);
    if (Game.world().environment() != null && Game.world().environment().isLoaded()) {
      Game.loop().attach(controller);
    }
}
}
```
```java
class de.gurkenlabs.litiengine.graphics.FreeFlightCamera {
public FreeFlightCamera(final Point2D focus) {
    this.setFocus(focus);
    this.velocity = DEFAULT_SCROLL_PIXELS_PER_SECOND;
    this.scrollPadding = DEFAULT_SCROLL_PADDING;
    this.setClampToMap(true);

    Game.loop().attach(this);
}private void handleFreeFlightCamera() {
    if (Game.world().environment() == null || Game.world().environment().getMap() == null) {
      return;
    }

    final Point2D mouseLocation = Input.mouse().getLocation();

    final double scrollSpeed =
        this.getVelocity()
            / (double) Game.loop().getTickRate()
            * Game.config().input().getMouseSensitivity();

    double x = this.getFocus().getX();
    double y = this.getFocus().getY();

    double deltaX = 0;
    if (mouseLocation.getX() < this.getScrollPadding()) {
      deltaX -= scrollSpeed;
    } else if (Game.window().getResolution().getWidth() - mouseLocation.getX()
        < this.getScrollPadding()) {
      deltaX += scrollSpeed;
    }

    double deltaY = 0;
    if (mouseLocation.getY() < this.getScrollPadding()) {
      deltaY -= scrollSpeed;
    } else if (Game.window().getResolution().getHeight() - mouseLocation.getY()
        < this.getScrollPadding()) {
      deltaY += scrollSpeed;
    }

    x += deltaX;
    y += deltaY;

    this.setFocus(new Point2D.Double(x, y));
}
}
```
```java
class de.gurkenlabs.litiengine.environment.Environment {
private static void dispose(final Collection<? extends IEntity> entities) {
    for (final IEntity entity : entities) {
      if (entity instanceof IUpdateable) {
        Game.loop().detach((IUpdateable) entity);
      }

      entity.detachControllers();
    }
}private static void loadUpdatableOrEmitterEntity(IEntity entity) {
    if (entity instanceof Emitter) {
      final Emitter emitter = (Emitter) entity;
      if (emitter.isActivateOnInit()) {
        emitter.activate();
      }
    } else if (entity instanceof IUpdateable) {
      Game.loop().attach((IUpdateable) entity);
    }
}private void unload(final IEntity entity) {
    // 1. remove from physics engine
    if (entity instanceof ICollisionEntity) {
      Game.physics().remove((ICollisionEntity) entity);
    }

    // 2. unregister from update
    if (entity instanceof IUpdateable) {
      Game.loop().detach((IUpdateable) entity);
    }

    if (entity instanceof IMobileEntity) {
      this.removeGravity((IMobileEntity) entity);
    }

    // 3. detach all controllers
    entity.detachControllers();

    if (entity instanceof Emitter) {
      Emitter em = (Emitter) entity;
      em.deactivate();
    }

    if (this.loaded && (entity instanceof LightSource || entity instanceof StaticShadow)) {
      this.updateLighting(entity);
    }

    entity.removed(this);
}
}
```
```java
class de.gurkenlabs.litiengine.graphics.animation.Animation {
@Override
  public void update() {
    // do nothing if the animation is not playing or the current keyframe is not finished
    if (!this.isPlaying()
        || Game.time().since(this.lastFrameUpdate) < this.getCurrentKeyFrame().getDuration()) {
      return;
    }

    // if we are not looping and the last keyframe is finished, we terminate the animation
    if (!this.isLooping() && this.isLastKeyFrame()) {
      this.terminate();
      return;
    }

    // make sure, we stay inside the keyframe list
    final int newFrameIndex =
        (this.getKeyframes().indexOf(this.currentFrame) + 1) % this.getKeyframes().size();
    final KeyFrame previousFrame = this.currentFrame;
    this.currentFrame = this.getKeyframes().get(newFrameIndex);

    for (KeyFrameListener listener : this.listeners) {
      listener.currentFrameChanged(previousFrame, this.currentFrame);
    }

    this.lastFrameUpdate = Game.loop().getTicks();
}public void restart() {
    this.currentFrame = this.firstFrame;
    this.lastFrameUpdate = Game.loop().getTicks();
}
}
```
```java
class de.gurkenlabs.litiengine.physics.MovementController {
@Override
  public void attach() {
    Game.loop().attach(this);
}private void handleForces() {
    // clean up forces
    this.activeForces.forEach(
        x -> {
          if (x.hasEnded()) {
            this.activeForces.remove(x);
          }
        });

    if (this.activeForces.isEmpty()) {
      return;
    }

    // disable turn-on-move for force handling
    boolean turn = this.getEntity().turnOnMove();
    this.getEntity().setTurnOnMove(false);
    try {
      double deltaX = 0;
      double deltaY = 0;
      for (final Force force : this.activeForces) {
        if (force.cancelOnReached() && force.hasReached(this.getEntity())) {
          force.end();
          continue;
        }

        final Point2D collisionBoxCenter = this.getEntity().getCollisionBoxCenter();
        final double angle =
            GeometricUtilities.calcRotationAngleInDegrees(collisionBoxCenter, force.getLocation());
        final double strength =
            Game.loop().getDeltaTime() * 0.001f * force.getStrength() * Game.loop().getTimeScale();
        deltaX += GeometricUtilities.getDeltaX(angle, strength);
        deltaY += GeometricUtilities.getDeltaY(angle, strength);
      }

      final Point2D target =
          new Point2D.Double(this.getEntity().getX() + deltaX, this.getEntity().getY() + deltaY);
      final boolean success = Game.physics().move(this.getEntity(), target);
      if (!success) {
        for (final Force force : this.activeForces) {
          if (force.cancelOnCollision()) {
            force.end();
          }
        }
      }
    } finally {
      this.getEntity().setTurnOnMove(turn);
    }
}@Override
  public void detach() {
    Game.loop().detach(this);
}public void handleMovement() {
    if (!this.isMovementAllowed()) {
      this.velocity = 0;
      return;
    }

    // max distance an entity can travel within one tick
    final double maxPixelsPerTick = this.getEntity().getTickVelocity();
    final double deltaTime = Game.loop().getDeltaTime() * Game.loop().getTimeScale();

    final double acceleration =
        this.getEntity().getAcceleration() == 0
            ? maxPixelsPerTick
            : deltaTime / this.getEntity().getAcceleration() * maxPixelsPerTick;
    final double deceleration =
        this.getEntity().getDeceleration() == 0
            ? this.getVelocity()
            : deltaTime / this.getEntity().getDeceleration() * maxPixelsPerTick;

    double dx = this.getDx();
    double dy = this.getDy();
    this.setDx(0);
    this.setDy(0);

    final double deltaVelocity =
        Math.min(Math.sqrt(Math.pow(dx, 2) + Math.pow(dy, 2)), acceleration);
    if (deltaVelocity != 0) {
      double newVelocity = this.getVelocity() + deltaVelocity;
      this.setVelocity(newVelocity);
    } else {
      final double newVelocity = Math.max(0, this.getVelocity() - deceleration);
      this.setVelocity(newVelocity);
      dx = GeometricUtilities.getDeltaX(this.moveAngle);
      dy = GeometricUtilities.getDeltaY(this.moveAngle);
    }

    if (this.getVelocity() == 0) {
      this.moveAngle = 0;
      return;
    }

    // actually move entity
    this.moveEntity(dx, dy);
}
}
```
```java
class de.gurkenlabs.litiengine.graphics.animation.AnimationController {
public void detach() {
    Game.loop().detach(this);
}public void attach() {
    Game.loop().attach(this);
}
}
```
```java
class de.gurkenlabs.litiengine.graphics.Camera {
@Override
  public void setZoom(final float targetZoom, final int delay) {
    if (delay == 0) {

      this.zoom = targetZoom;
      this.targetZoom = 0;
      this.zoomDelay = 0;
      this.zoomTick = 0;
      this.zoomStep = 0;

      final ZoomChangedEvent event = new ZoomChangedEvent(this, targetZoom);
      for (final ZoomChangedListener listener : this.zoomListeners) {
        listener.zoomChanged(event);
      }
    } else {
      this.zoomTick = Game.time().now();
      this.targetZoom = targetZoom;
      this.zoomDelay = delay;

      final double tickduration = 1000 / (double) Game.loop().getTickRate();
      final double tickAmount = delay / tickduration;
      final float totalDelta = this.targetZoom - this.zoom;
      this.zoomStep = tickAmount > 0 ? (float) (totalDelta / tickAmount) : totalDelta;
    }
}
}
```
```java
class de.gurkenlabs.litiengine.Game {
public static synchronized void init(String... args) {
    if (initialized) {
      log().log(Level.INFO, "The game has already been initialized.");
      return;
    }

    log.init();
    handleCommandLineArguments(args);

    config().load();
    Locale.setDefault(new Locale(config().client().getCountry(), config().client().getLanguage()));

    gameLoop = new GameLoop("Main Update Loop", config().client().getMaxFps());
    loop().attach(physics());
    loop().attach(world());

    // setup default exception handling for render and update loop
    setUncaughtExceptionHandler(
        new DefaultUncaughtExceptionHandler(config().client().exitOnError()));

    screenManager = new ScreenManager();
    gameWindow = new GameWindow();

    // initialize  the game window
    window().init();
    world.setCamera(new Camera());

    for (GameListener listener : gameListeners) {
      listener.initialized(args);
    }

    if (!isInNoGUIMode()) {
      window().getRenderComponent().onRendered(g -> metrics().render(g));

      graphics()
          .addEntityRenderedListener(
              e -> DebugRenderer.renderEntityDebugInfo(e.getGraphics(), e.getEntity()));

      window().getRenderComponent().onFpsChanged(fps -> metrics().setFramesPerSecond(fps));
      window()
          .setIcons(
              Arrays.asList(
                  Resources.images().get("liti-logo-x16.png"),
                  Resources.images().get("liti-logo-x20.png"),
                  Resources.images().get("liti-logo-x32.png"),
                  Resources.images().get("liti-logo-x48.png")));

      Input.keyboard()
          .onKeyTyped(
              KeyEvent.VK_PRINTSCREEN,
              key -> {
                // don't take a screenshot if a modifier is active
                if (key.getModifiers() != 0) {
                  return;
                }

                window().getRenderComponent().takeScreenshot();
              });
    }

    Runtime.getRuntime().addShutdownHook(new Thread(Game::terminate, "Shutdown"));

    initialized = true;
}
}
```
```java
class de.gurkenlabs.litiengine.entities.Creature {
protected void updateAnimationController() {
    IEntityAnimationController<?> controller = this.createAnimationController();
    this.getControllers().addController(controller);
    if (Game.world().environment() != null && Game.world().environment().isLoaded()) {
      Game.loop().attach(controller);
    }
}@Override
  public float getTickVelocity() {
    // pixels per ms multiplied by the passed ms
    // ensure that entities don't travel too far in case of lag
    return Math.min(Game.loop().getDeltaTime(), GameLoop.TICK_DELTATIME_LAG)
        * 0.001F
        * this.getVelocity().get()
        * Game.loop().getTimeScale();
}
}
```
Depth: 2
```java
class de.gurkenlabs.litiengine.environment.GameWorld {
public void clear() {
    this.unloadEnvironment();
    this.environments.clear();
    this.setCamera(null);
    Game.physics().clear();

    this.environmentListeners.clear();
    this.environmentLoadedListeners.clear();
    this.environmentUnloadedListeners.clear();

    this.listeners.clear();
    this.loadedListeners.clear();
    this.unloadedListeners.clear();
}@Nullable
  public Environment loadEnvironment(IMap map) {
    Environment env = this.getEnvironment(map);
    this.loadEnvironment(env);
    return env;
}@Nullable
  public Environment loadEnvironment(String mapName) {
    Environment env = this.getEnvironment(mapName);
    this.loadEnvironment(env);
    return env;
}
}
```
```java
class de.gurkenlabs.litiengine.GameWindow {
GameWindow() {
    this.hostControl = new JFrame();

    this.resolutionChangedListeners = new CopyOnWriteArrayList<>();

    this.renderCanvas = new RenderComponent(Game.config().graphics().getResolution());
    this.cursor = new MouseCursor();
    if (!Game.isInNoGUIMode()) {
      this.hostControl.setBackground(Color.BLACK);
      this.hostControl.add(this.renderCanvas);

      this.initializeEventListeners();

      this.hostControl.setTitle(Game.info().getTitle());
      this.hostControl.setDefaultCloseOperation(WindowConstants.DO_NOTHING_ON_CLOSE);
      initializeWindowEventListeners(this.hostControl);
    }
}
}
```
```java
class de.gurkenlabs.litiengine.GameTime {
public long sinceEnvironmentLoad() {
    return this.since(this.environmentLoaded);
}public long since(final long tick) {
    return toMilliseconds(Game.loop().getTicks() - tick);
}public long sinceGameStart() {
    return this.toMilliseconds(Game.loop().getTicks());
}
}
```
```java
class de.gurkenlabs.litiengine.abilities.effects.Effect {
protected void cease(final EffectApplication appliance) {
    // 1. cease the effect for all affected entities
    for (final ICombatEntity entity : appliance.getAffectedEntities()) {
      this.cease(entity);
    }

    // 2. apply follow up effects
    this.getFollowUpEffects().forEach(followUp -> followUp.apply(appliance.getImpactArea()));
}protected boolean hasEnded(final EffectApplication appliance) {
    final long effectDuration = Game.time().since(appliance.getAppliedTicks());
    return effectDuration > this.getDuration();
}
}
```
```java
class de.gurkenlabs.litiengine.abilities.effects.EffectApplication {
protected EffectApplication(final List<ICombatEntity> affectedEntities, final Shape impactArea) {
    this.applied = Game.time().now();
    this.affectedEntities = affectedEntities;
    this.impactArea = impactArea;
}
}
```
```java
class de.gurkenlabs.litiengine.entities.CombatEntity {
@Override
  public boolean wasHit(int timeSpan) {
    return Game.time().since(this.lastHit) < timeSpan;
}@Override
  public void hit(final int damage, @Nullable final Ability ability) {
    if (this.isDead()) {
      return;
    }

    if (!this.isIndestructible()) {
      this.getHitPoints().modifyBaseValue(new AttributeModifier<>(Modification.SUBTRACT, damage));
    }

    final EntityHitEvent event = new EntityHitEvent(this, ability, damage, this.isDead());

    for (final CombatEntityListener listener : this.listeners) {
      listener.hit(event);
    }

    for (final CombatEntityHitListener listener : this.hitListeners) {
      listener.hit(event);
    }

    if (this.isDead()) {
      this.fireDeathEvent();
      this.setCollision(false);
    }

    this.lastHit = Game.time().now();
}
}
```
```java
class de.gurkenlabs.litiengine.graphics.ImageEffect {
protected ImageEffect(final int ttl, final String name) {
    this.ttl = ttl;
    this.name = name;
    this.aliveTick = Game.time().now();
}@Override
  public long getAliveTime() {
    return Game.time().since(this.aliveTick);
}
}
```
```java
class de.gurkenlabs.litiengine.abilities.AbilityExecution {
AbilityExecution(final Ability ability) {
    this.appliedEffects = new CopyOnWriteArrayList<>();
    this.ability = ability;
    this.executionTicks = Game.time().now();
    this.impactArea = ability.calculateImpactArea();
    this.castLocation = ability.getExecutor().getCenter();
    Game.loop().attach(this);
}@Override
  public void update() {
    // if there a no effects to apply -> unregister this instance and we're done
    if (this.getAbility().getEffects().isEmpty()
        || this.getAbility().getEffects().size() == this.getAppliedEffects().size()) {
      Game.loop().detach(this);
      return;
    }

    // handle all effects from the ability that were not applied yet
    for (final Effect effect : this.getAbility().getEffects()) {
      // if the ability was not executed yet or the delay of the effect is not
      // yet reached
      if (this.getAppliedEffects().contains(effect)
          || Game.time().since(this.getExecutionTicks()) < effect.getDelay()) {
        continue;
      }

      effect.apply(this.getExecutionImpactArea());
      this.getAppliedEffects().add(effect);
    }
}
}
```
```java
class de.gurkenlabs.litiengine.tweening.TweenEngine {
@Override
  public void update() {
    for (final Tweenable target : this.getTweens().keySet()) {
      for (final Tween tween : this.getTweens().get(target).values()) {
        if (tween.hasStopped()) {
          continue;
        }
        final long elapsed = Game.time().since(tween.getStartTime());
        if (elapsed >= tween.getDuration()) {
          tween.stop();
          continue;
        }
        final float[] currentValues = new float[tween.getTargetValues().length];
        for (int i = 0; i < tween.getTargetValues().length; i++) {
          currentValues[i] =
              tween.getStartValues()[i]
                  + tween.getEquation().compute(elapsed / (float) tween.getDuration())
                      * (tween.getTargetValues()[i] - tween.getStartValues()[i]);
        }
        tween.getTarget().setTweenValues(tween.getType(), currentValues);
      }
    }
}
}
```
```java
class de.gurkenlabs.litiengine.gui.SpeechBubble {
public static SpeechBubble create(
      final IEntity entity, final String text, SpeechBubbleAppearance appearance, Font font) {
    return new SpeechBubble(entity, text, appearance, font);
}public static SpeechBubble create(final IEntity entity, final Font font, final String text) {
    SpeechBubbleAppearance app =
        new SpeechBubbleAppearance(
            DEFAULT_APPEARANCE.getForeColor(),
            DEFAULT_APPEARANCE.getBackgroundColor1(),
            DEFAULT_APPEARANCE.getBorderColor(),
            DEFAULT_APPEARANCE.getPadding());
    return new SpeechBubble(entity, text, app, font);
}public static SpeechBubble create(final IEntity entity, final String text) {
    return new SpeechBubble(entity, text, null, GuiProperties.getDefaultFont());
}@Override
  public void update() {
    if (this.currentText == null) {
      this.hide();
      return;
    }

    this.entityCenter = Game.world().camera().getViewportLocation(this.getEntity().getCenter());

    // old text was displayed long enough
    if (this.lastTextDisplay != 0
        && Game.time().since(this.lastTextDisplay) > this.currentTextDisplayTime) {
      this.currentText = null;
      this.lastTextDisplay = 0;
      return;
    }

    // display new text
    if (this.textIndex < this.currentText.length()
        && Game.time().since(this.lastCharPoll) > LETTER_WRITE_DELAY) {
      this.textIndex++;
      this.lastCharPoll = Game.time().now();
      if (this.typeSound != null) {
        Game.audio().playSound(this.typeSound, this.getEntity());
      }
    }

    // continue displaying currently displayed text
}private SpeechBubble(
      final IEntity entity,
      final String text,
      final Sound typeSound,
      SpeechBubbleAppearance appearance,
      Font font) {
    this(entity, text, appearance, font);
    this.typeSound = typeSound;
}private SpeechBubble(
      final IEntity entity,
      final String text,
      @Nullable SpeechBubbleAppearance appearance,
      @Nullable Font font) {
    if (appearance == null) {
      this.appearance = DEFAULT_APPEARANCE;
    } else {
      this.appearance = appearance;
    }

    final SpeechBubble active = activeSpeechBubbles.get(entity);
    if (active != null) {
      active.hide();
    }
    this.setFont(font);

    this.textBoxWidth = (float) (entity.getWidth() * 4);
    this.entity = entity;

    this.currentText = text;
    this.currentTextDisplayTime = DISPLAYTIME_MIN + text.length() * DISPLAYTIME_PER_LETTER;

    this.lastTextDisplay = Game.time().now();
    this.createBubbleImage();
    entity.getEnvironment().add(this, RenderType.UI);
    Game.loop().attach(this);
    activeSpeechBubbles.put(entity, this);
}
}
```
```java
class de.gurkenlabs.litiengine.gui.TextFieldComponent {
@Override
  public void render(final Graphics2D g) {
    super.render(g);
    g.setFont(this.getFont());
    final FontMetrics fm = g.getFontMetrics();

    if (this.isSelected() && Game.time().since(this.lastToggled) > this.flickerDelay) {
      this.cursorVisible = !this.cursorVisible;
      this.lastToggled = Game.time().now();
    }
    if (this.isSelected() && this.cursorVisible) {
      final Rectangle2D cursor =
          new Rectangle2D.Double(
              this.getX() + this.getTextX() + fm.stringWidth(this.getTextToRender(g)),
              this.getY() + this.getTextY(),
              this.getFont().getSize2D() * 3 / 5,
              this.getFont().getSize2D() * 1 / 5);
      g.setColor(this.getAppearance().getForeColor());
      g.fill(cursor);
    }
}
}
```
```java
class de.gurkenlabs.litiengine.entities.Prop {
public Prop(
      final Point2D location, @Nullable final String spritesheetName, final Material material) {
    super();
    this.rotation = Rotation.NONE;
    this.spritesheetName = spritesheetName;
    this.material = material;
    this.setLocation(location);
    this.updateAnimationController();
}public void setSpritesheetName(@Nullable final String spriteName) {
    this.spritesheetName = spriteName;
    this.updateAnimationController();
}
}
```
```java
class de.gurkenlabs.litiengine.tweening.Tween {
public Tween begin() {
    this.started = Game.time().now();
    this.stopped = false;
    return this;
}
}
```
```java
class de.gurkenlabs.litiengine.graphics.emitters.particles.Particle {
public void update(final Point2D emitterOrigin, final float updateRatio) {
    if (this.aliveTick == 0) {
      this.aliveTick = Game.time().now();
    }

    this.aliveTime = Game.time().since(this.aliveTick);
    if (this.timeToLiveReached()) {
      return;
    }

    if (this.colliding) {
      return;
    }

    if (this.getDeltaWidth() != 0) {
      this.width += this.getDeltaWidth() * updateRatio;
    }

    if (this.getDeltaHeight() != 0) {
      this.height += this.getDeltaHeight() * updateRatio;
    }

    if (this.getDeltaAngle() != 0) {
      this.angle += this.getDeltaAngle() * updateRatio;
    }

    // test for ray cast collision
    final float targetX = this.x + this.getVelocityX() * updateRatio;
    final float targetY = this.y + this.getVelocityY() * updateRatio;

    if (targetX == this.x && targetY == this.y) {
      return;
    }

    if (this.checkForCollision(emitterOrigin, targetX, targetY)) {
      return;
    }

    if (this.getVelocityX() != 0) {
      this.x = targetX;
    }

    if (this.getVelocityY() != 0) {
      this.y = targetY;
    }

    if (this.getAccelerationX() != 0) {
      this.velocityX += this.getAccelerationX() * updateRatio;
    }

    if (this.getAccelerationY() != 0) {
      this.velocityY += this.getAccelerationY() * updateRatio;
    }
}
}
```
```java
class de.gurkenlabs.litiengine.graphics.animation.Animation {
@Override
  public void start() {
    this.playing = true;
    if (this.getKeyframes().isEmpty()) {
      return;
    }

    this.restart();
}@Override
  public void update() {
    // do nothing if the animation is not playing or the current keyframe is not finished
    if (!this.isPlaying()
        || Game.time().since(this.lastFrameUpdate) < this.getCurrentKeyFrame().getDuration()) {
      return;
    }

    // if we are not looping and the last keyframe is finished, we terminate the animation
    if (!this.isLooping() && this.isLastKeyFrame()) {
      this.terminate();
      return;
    }

    // make sure, we stay inside the keyframe list
    final int newFrameIndex =
        (this.getKeyframes().indexOf(this.currentFrame) + 1) % this.getKeyframes().size();
    final KeyFrame previousFrame = this.currentFrame;
    this.currentFrame = this.getKeyframes().get(newFrameIndex);

    for (KeyFrameListener listener : this.listeners) {
      listener.currentFrameChanged(previousFrame, this.currentFrame);
    }

    this.lastFrameUpdate = Game.loop().getTicks();
}
}
```
```java
class de.gurkenlabs.litiengine.graphics.animation.AnimationController {
@Override
  public void update() {
    for (final Animation animation : this.getAll()) {
      animation.update();
    }

    if (this.getCurrent() != null && this.getCurrent().isPaused()) {
      return;
    }

    final boolean playbackFinished = this.getCurrent() != null && !this.getCurrent().isPlaying();
    if (playbackFinished) {
      for (final AnimationListener listener : this.listeners) {
        listener.finished(this.getCurrent());
      }
    }

    if (this.getCurrent() == null || playbackFinished) {
      if (this.getDefault() != null) {
        this.play(this.getDefault().getName());
      } else {
        this.currentAnimation = null;
      }
    }
}
}
```
```java
class de.gurkenlabs.litiengine.graphics.RenderComponent {
private void handleFade() {
    if (this.fadeOutStart != -1) {
      final long timePassed = Game.time().since(this.fadeOutStart);
      this.currentAlpha = MathUtilities.clamp(1 - timePassed / (float) this.fadeOutTime, 0, 1);
      if (this.currentAlpha == 0f) {
        this.fadeOutStart = -1;
        this.fadeOutTime = -1;
      }

      return;
    }

    if (this.fadeInStart != -1) {
      final long timePassed = Game.time().since(this.fadeInStart);
      this.currentAlpha = MathUtilities.clamp(timePassed / (float) this.fadeInTime, 0, 1);
      if (this.currentAlpha == 1f) {
        this.fadeInStart = -1;
        this.fadeInTime = -1;
        this.currentAlpha = Float.NaN;
      }
    }
}public void fadeOut(final int ms) {
    this.fadeInStart = -1;
    this.fadeInTime = -1;
    this.fadeOutStart = Game.time().now();
    this.fadeOutTime = ms;
}public void fadeIn(final int ms) {
    this.fadeOutStart = -1;
    this.fadeOutTime = -1;
    this.fadeInStart = Game.time().now();
    this.fadeInTime = ms;
}
}
```
```java
class de.gurkenlabs.litiengine.entities.Trigger {
private boolean activate(final IEntity activator, final int tar) {
    if (!this.isLoaded()
        || this.isOneTimeTrigger && this.isActivated
        || this.getActivationType() == TriggerActivation.COLLISION
            && activator != null
            && this.collisionActivated.contains(activator)) {
      return false;
    }

    if (this.getCooldown() > 0 && Game.time().since(this.lastActivation) < this.getCooldown()) {
      return false;
    }

    List<Integer> triggerTargets = this.getTargets(tar);

    final TriggerEvent te = new TriggerEvent(this, activator, triggerTargets);

    if (!this.checkActivationPredicates(te)) {
      return false;
    }

    this.isActivated = true;
    if (activator != null) {
      this.collisionActivated.add(activator);
    }

    // if we actually have a trigger target, we send the message to the target
    for (final int target : triggerTargets) {
      final IEntity entity = this.getEnvironment().get(target);
      if (entity == null) {
        log.log(
            Level.WARNING,
            "trigger [{0}] was activated, but the trigger target [{1}] could not be found on the environment",
            new Object[] {this, target});
        continue;
      }

      entity.sendMessage(this, this.message);
    }

    // also send the trigger event to all registered consumers
    for (final TriggerActivatedListener listener : this.activatedListeners) {
      listener.activated(te);
    }

    if (this.isOneTimeTrigger) {
      this.getEnvironment().remove(this);
    }

    this.lastActivation = Game.time().now();
    return true;
}
}
```
```java
class de.gurkenlabs.litiengine.graphics.Camera {
private boolean isShakeEffectActive() {
    return this.getShakeTick() != 0
        && Game.time().since(this.getShakeTick()) < this.getShakeDuration();
}@Override
  public void update() {
    if (Game.world().camera() != null && !Game.world().camera().equals(this)) {
      return;
    }

    if (this.targetZoom > 0) {
      if (Game.time().since(this.zoomTick) >= this.zoomDelay) {
        this.zoom = this.targetZoom;
        this.targetZoom = 0;
        this.zoomDelay = 0;
        this.zoomTick = 0;
        this.zoomStep = 0;
      } else {
        this.zoom += this.zoomStep;
      }

      final ZoomChangedEvent event = new ZoomChangedEvent(this, this.getZoom());
      for (final ZoomChangedListener listener : this.zoomListeners) {
        listener.zoomChanged(event);
      }
    }

    if (this.panTime > 0) {
      if (--this.panTime <= 0) {
        this.setFocus(this.targetFocus);
        this.targetFocus = null;
      } else {
        double diff = this.panTime / (this.panTime + 1.0);
        this.focus =
            new Point2D.Double(
                this.focus.getX() * diff + this.targetFocus.getX() * (1.0 - diff),
                this.focus.getY() * diff + this.targetFocus.getY() * (1.0 - diff));
      }
    }

    if (!this.isShakeEffectActive()) {
      this.shakeOffsetX = 0;
      this.shakeOffsetY = 0;
      return;
    }

    if (Game.time().since(this.lastShake) > this.shakeDelay) {
      this.shakeOffsetX = this.getShakeIntensity() * ThreadLocalRandom.current().nextGaussian();
      this.shakeOffsetY = this.getShakeIntensity() * ThreadLocalRandom.current().nextGaussian();
      this.lastShake = Game.time().now();
    }
}@Override
  public void setZoom(final float targetZoom, final int delay) {
    if (delay == 0) {

      this.zoom = targetZoom;
      this.targetZoom = 0;
      this.zoomDelay = 0;
      this.zoomTick = 0;
      this.zoomStep = 0;

      final ZoomChangedEvent event = new ZoomChangedEvent(this, targetZoom);
      for (final ZoomChangedListener listener : this.zoomListeners) {
        listener.zoomChanged(event);
      }
    } else {
      this.zoomTick = Game.time().now();
      this.targetZoom = targetZoom;
      this.zoomDelay = delay;

      final double tickduration = 1000 / (double) Game.loop().getTickRate();
      final double tickAmount = delay / tickduration;
      final float totalDelta = this.targetZoom - this.zoom;
      this.zoomStep = tickAmount > 0 ? (float) (totalDelta / tickAmount) : totalDelta;
    }
}@Override
  public void shake(final double intensity, final int delay, final int shakeDuration) {
    this.shakeTick = Game.time().now();
    this.shakeDelay = delay;
    this.shakeIntensity = intensity;
    this.shakeDuration = shakeDuration;
}
}
```
```java
class de.gurkenlabs.litiengine.entities.Creature {
public void setSpritesheetName(String spritesheetName) {
    if (this.spritesheetName != null && this.spritesheetName.equals(spritesheetName)) {
      return;
    }

    this.spritesheetName = spritesheetName;
    this.updateAnimationController();
}public boolean isIdle() {
    return Game.time().since(this.lastMoved) > IDLE_DELAY;
}@Override
  public void setLocation(final Point2D position) {
    if (this.isDead() || position == null) {
      return;
    }

    final Point2D oldLocation = this.getLocation();
    super.setLocation(position);

    if (Game.hasStarted() && this.isLoaded()) {
      this.lastMoved = Game.time().now();
      this.fireMovedEvent(
          new EntityMovedEvent(
              this, this.getX() - oldLocation.getX(), this.getY() - oldLocation.getY()));
    }
}
}
```
```java
class de.gurkenlabs.litiengine.gui.screens.ScreenManager {
public void display(final String screenName) {
    if (this.current() != null && this.current().getName().equalsIgnoreCase(screenName)) {
      log.log(
          Level.INFO,
          "Skipping displaying of screen {0} because it is already the current screen.",
          screenName);
      return;
    }

    if (this.screens.stream()
        .noneMatch(element -> element.getName().equalsIgnoreCase(screenName))) {
      log.log(
          Level.WARNING,
          "Could not display the screen {0} because there is no screen with the specified name.",
          screenName);
      return;
    }

    Screen screen = this.get(screenName);
    if (screen == null) {
      return;
    }

    this.display(screen);
}public void add(final Screen screen) {
    screen.setWidth(Game.window().getWidth());
    screen.setHeight(Game.window().getHeight());
    this.screens.add(screen);

    if (this.current() == null) {
      this.display(screen);
    }
}public void remove(Screen screen) {
    this.screens.remove(screen);
    if (this.current() == screen) {
      if (!this.screens.isEmpty()) {
        this.display(this.screens.get(0));
      } else {
        this.display((Screen) null);
      }
    }
}public void display(@Nullable final Screen screen) {
    if (Game.hasStarted() && Game.time().since(this.lastScreenChange) < this.getChangeCooldown()) {
      log.log(
          Level.INFO,
          "Skipping displaying of screen {0} because screen changing is currently on cooldown.",
          screen != null ? screen.getName() : "");
      return;
    }

    final Screen previous = this.current();
    if (previous != null) {
      previous.suspend();
    }

    if (screen != null && !this.screens.contains(screen)) {
      this.screens.add(screen);
    }

    this.currentScreen = screen;
    if (!Game.isInNoGUIMode() && this.current() != null) {
      this.current().prepare();
    }

    this.lastScreenChange = Game.loop().getTicks();

    final ScreenChangedEvent event = new ScreenChangedEvent(this.current(), previous);
    for (final ScreenChangedListener listener : this.screenChangedListeners) {
      listener.changed(event);
    }
}
}
```
```java
class de.gurkenlabs.litiengine.abilities.Ability {
public boolean isOnCooldown() {
    return (this.getCurrentExecution() != null
        && this.getCurrentExecution().getExecutionTicks() > 0
        && Game.time().since(this.getCurrentExecution().getExecutionTicks())
            < this.getAttributes().cooldown().get());
}public boolean isActive() {
    return this.getCurrentExecution() != null
        && Game.time().since(this.getCurrentExecution().getExecutionTicks())
            < this.getAttributes().duration().get();
}@Nullable
  public AbilityExecution cast() {
    if (!this.canCast()) {
      return null;
    }
    this.currentExecution = new AbilityExecution(this);

    for (final AbilityCastListener listener : this.abilityCastListeners) {
      listener.abilityCast(this.currentExecution);
    }

    return this.getCurrentExecution();
}public float getRemainingCooldownInSeconds() {
    if (this.getCurrentExecution() == null
        || this.getExecutor() == null
        || this.getExecutor().isDead()) {
      return 0;
    }

    // calculate cooldown in seconds
    return (float)
        (!this.canCast()
            ? (this.getAttributes().cooldown().get()
                    - Game.time().since(this.getCurrentExecution().getExecutionTicks()))
                * 0.001
            : 0);
}
}
```
```java
class de.gurkenlabs.litiengine.entities.EntityHitEvent {
EntityHitEvent(
      final ICombatEntity hitEntity,
      @Nullable final Ability ability,
      final int damage,
      final boolean kill) {
    super(hitEntity);
    this.executor = ability != null ? ability.getExecutor() : null;
    this.hitEntity = hitEntity;
    this.ability = ability;
    this.damage = damage;
    this.kill = kill;
    this.time = Game.time().now();
}
}
```
```java
class de.gurkenlabs.litiengine.graphics.emitters.Emitter {
public void delete() {
    this.deactivate();
    if (Game.world().environment() != null) {
      Game.world().environment().remove(this);
    }
}public void activate() {
    if (this.activated) {
      return;
    }

    this.activated = true;
    this.activationTick = Game.time().now();
    Game.loop().attach(this);
}@Override
  public void update() {
    if (this.isPaused()) {
      return;
    }

    // clear particles if the effect time to life is reached
    if (this.isFinished()) {
      for (EmitterFinishedListener listener : this.finishedListeners) {
        listener.finished(this);
      }

      this.delete();
      return;
    }

    final float updateRatio = (float) this.data().getUpdateRate() / Game.loop().getTickRate();
    for (final Particle p : this.getParticles().stream().collect(Collectors.toList())) {
      if (this.particleCanBeRemoved(p)) {
        // remove dead particles
        this.particles.remove(p);
        continue;
      }

      p.update(this.getOrigin(), updateRatio);
    }

    this.aliveTime = Game.time().since(this.activationTick);
    if ((this.data().getSpawnRate() == 0
        || Game.time().since(this.lastSpawn) >= this.data().getSpawnRate())) {
      this.lastSpawn = Game.time().now();
      this.spawnParticle();
    }
}
}
```
```java
class de.gurkenlabs.litiengine.GameLoop {
@Override
  public int perform(int delay, Runnable action) {
    final long d = Game.time().toTicks(delay);

    TimedAction a = new TimedAction(this.getTicks() + d, action);
    this.actions.add(a);

    return a.getId();
}
}
```
```java
class de.gurkenlabs.litiengine.environment.EntitySpawner {
protected boolean shouldSpawn() {
    return this.lastSpawnWave == 0
        || Game.time().since(this.lastSpawnWave) >= this.getSpawnInterval();
}@Override
  public void update() {
    if (!this.shouldSpawn()) {
      return;
    }

    this.spawnNewEntities();
    this.lastSpawnWave = Game.time().now();
}
}
```
```java
class de.gurkenlabs.litiengine.graphics.FreeFlightCamera {
@Override
  public void update() {
    this.handleFreeFlightCamera();
}public FreeFlightCamera(double x, double y) {
    this(new Point2D.Double(x, y));
}
}
```
```java
class de.gurkenlabs.litiengine.environment.Environment {
public void unload() {
    if (!this.loaded) {
      return;
    }

    // unregister all updatable entities from the current environment
    for (final IEntity entity : this.allEntities.values()) {
      this.unload(entity);
    }

    this.loaded = false;
    this.fireEvent(l -> l.unloaded(this));
}private static void loadUpdatableOrEmitterEntity(IEntity entity) {
    if (entity instanceof Emitter) {
      final Emitter emitter = (Emitter) entity;
      if (emitter.isActivateOnInit()) {
        emitter.activate();
      }
    } else if (entity instanceof IUpdateable) {
      Game.loop().attach((IUpdateable) entity);
    }
}public void clear() {
    Game.physics().clear();

    this.combatEntities.clear();
    this.mobileEntities.clear();
    this.gravityForces.clear();
    this.layerEntities.clear();
    this.entitiesByTag.clear();
    this.allEntities.clear();

    for (RenderType renderType : RenderType.values()) {
      this.miscEntities.get(renderType).clear();
      this.renderListeners.get(renderType).clear();
      this.renderables.get(renderType).clear();
    }

    dispose(this.allEntities.values());
    dispose(this.triggers);
    this.emitters.clear();
    this.colliders.clear();
    this.props.clear();
    this.creatures.clear();
    this.staticShadows.clear();
    this.combatEntities.clear();
    this.mobileEntities.clear();
    this.lightSources.clear();
    this.spawnPoints.clear();
    this.soundSources.clear();
    this.mapAreas.clear();
    this.triggers.clear();

    this.ambientLight = null;
    this.staticShadowLayer = null;

    for (Map<Integer, IEntity> type : this.miscEntities.values()) {
      type.clear();
    }

    this.initialized = false;

    this.fireEvent(l -> l.cleared(this));
}private void load(final IEntity entity) {
    // an entity can only exist on one environment at a time, so remove it from the current one
    if (entity.getEnvironment() != null) {
      entity.getEnvironment().remove(entity);
    }

    // 1. add to physics engine
    loadPhysicsEntity(entity);

    // 2. register for update or activate
    loadUpdatableOrEmitterEntity(entity);

    // 3. if a gravity is defined, add a gravity force to the entity
    if (entity instanceof IMobileEntity && this.getGravity() != 0) {
      this.addGravityForce((IMobileEntity) entity);
    }

    // 4. attach all controllers
    entity.attachControllers();

    if (this.loaded && (entity instanceof LightSource || entity instanceof StaticShadow)) {
      this.updateLighting(entity);
    }

    entity.loaded(this);
}private void unload(final IEntity entity) {
    // 1. remove from physics engine
    if (entity instanceof ICollisionEntity) {
      Game.physics().remove((ICollisionEntity) entity);
    }

    // 2. unregister from update
    if (entity instanceof IUpdateable) {
      Game.loop().detach((IUpdateable) entity);
    }

    if (entity instanceof IMobileEntity) {
      this.removeGravity((IMobileEntity) entity);
    }

    // 3. detach all controllers
    entity.detachControllers();

    if (entity instanceof Emitter) {
      Emitter em = (Emitter) entity;
      em.deactivate();
    }

    if (this.loaded && (entity instanceof LightSource || entity instanceof StaticShadow)) {
      this.updateLighting(entity);
    }

    entity.removed(this);
}public void remove(final IEntity entity) {
    if (entity == null) {
      return;
    }

    this.allEntities.remove(entity.getMapId());
    Iterator<List<IEntity>> iter = this.layerEntities.values().iterator();
    while (iter.hasNext()) {
      List<IEntity> layer = iter.next();
      if (layer.remove(entity) && layer.isEmpty()) {
        iter.remove();
      }
    }
    if (this.miscEntities.get(entity.getRenderType()) != null) {
      this.miscEntities.get(entity.getRenderType()).values().remove(entity);
    }

    for (String tag : entity.getTags()) {
      if (this.getEntitiesByTag().containsKey(tag)) {
        this.getEntitiesByTag().get(tag).remove(entity);

        if (this.getEntitiesByTag().get(tag).isEmpty()) {
          this.getEntitiesByTag().remove(tag);
        }
      }
    }

    if (entity instanceof Emitter) {
      Emitter emitter = (Emitter) entity;
      this.removeEmitter(emitter);
    }

    if (entity instanceof MapArea) {
      this.mapAreas.remove(entity);
    }

    if (entity instanceof Prop) {
      this.props.remove(entity);
    }

    if (entity instanceof Creature) {
      this.creatures.remove(entity);
    }

    if (entity instanceof CollisionBox) {
      this.colliders.remove(entity);
      this.staticShadows.removeIf(x -> x.getOrigin() != null && x.getOrigin().equals(entity));
    }

    if (entity instanceof LightSource) {
      this.lightSources.remove(entity);
      this.updateLighting(entity);
    }

    if (entity instanceof Trigger) {
      this.triggers.remove(entity);
    }

    if (entity instanceof Spawnpoint) {
      this.spawnPoints.remove(entity);
    }
    if (entity instanceof SoundSource) {
      this.soundSources.remove(entity);
    }

    if (entity instanceof StaticShadow) {
      this.staticShadows.remove(entity);
      this.updateLighting(entity);
    }

    if (entity instanceof IMobileEntity) {
      this.mobileEntities.values().remove(entity);
    }

    if (entity instanceof ICombatEntity) {
      this.combatEntities.values().remove(entity);
    }

    this.unload(entity);

    this.fireEntityEvent(l -> l.entityRemoved(entity));
}
}
```
```java
class de.gurkenlabs.litiengine.physics.MovementController {
@Override
  public void update() {
    this.handleForces();
    this.handleMovement();
}
}
```
```java
class de.gurkenlabs.litiengine.Game {
static synchronized void terminate() {
    if (!initialized) {
      return;
    }

    hasStarted = false;
    initialized = false;

    config().save();
    gameLoop.terminate();
    tweenEngine.terminate();
    soundEngine.terminate();

    world().clear();

    for (final GameListener listener : gameListeners) {
      try {
        listener.terminated();
      } catch (Exception e) {
        log().log(Level.WARNING, "game listener threw an exception during shutdown", e);
      }
    }

    gameLoop = null;
    screenManager = null;
    gameWindow = null;
}public static synchronized void start() {
    if (!initialized) {
      throw new IllegalStateException(
          "The game cannot be started without being first initialized. Call Game.init(...) before Game.start().");
    }

    gameLoop.start();
    tweenEngine.start();
    soundEngine.start();

    for (final GameListener listener : gameListeners) {
      listener.started();
    }

    hasStarted = true;
}public static synchronized void init(String... args) {
    if (initialized) {
      log().log(Level.INFO, "The game has already been initialized.");
      return;
    }

    log.init();
    handleCommandLineArguments(args);

    config().load();
    Locale.setDefault(new Locale(config().client().getCountry(), config().client().getLanguage()));

    gameLoop = new GameLoop("Main Update Loop", config().client().getMaxFps());
    loop().attach(physics());
    loop().attach(world());

    // setup default exception handling for render and update loop
    setUncaughtExceptionHandler(
        new DefaultUncaughtExceptionHandler(config().client().exitOnError()));

    screenManager = new ScreenManager();
    gameWindow = new GameWindow();

    // initialize  the game window
    window().init();
    world.setCamera(new Camera());

    for (GameListener listener : gameListeners) {
      listener.initialized(args);
    }

    if (!isInNoGUIMode()) {
      window().getRenderComponent().onRendered(g -> metrics().render(g));

      graphics()
          .addEntityRenderedListener(
              e -> DebugRenderer.renderEntityDebugInfo(e.getGraphics(), e.getEntity()));

      window().getRenderComponent().onFpsChanged(fps -> metrics().setFramesPerSecond(fps));
      window()
          .setIcons(
              Arrays.asList(
                  Resources.images().get("liti-logo-x16.png"),
                  Resources.images().get("liti-logo-x20.png"),
                  Resources.images().get("liti-logo-x32.png"),
                  Resources.images().get("liti-logo-x48.png")));

      Input.keyboard()
          .onKeyTyped(
              KeyEvent.VK_PRINTSCREEN,
              key -> {
                // don't take a screenshot if a modifier is active
                if (key.getModifiers() != 0) {
                  return;
                }

                window().getRenderComponent().takeScreenshot();
              });
    }

    Runtime.getRuntime().addShutdownHook(new Thread(Game::terminate, "Shutdown"));

    initialized = true;
}
}
```


Response Format:
Provide the answer in **XML format** as follows:

#### If the method **cannot** return `null` at the specific call site:
```xml
<response>
  <reason><![CDATA[EXPLAIN WHY THE INVOCATION Game.loop() RESULT CANNOT BE NULL.]]></reason>
  <value>NO</value>
</response>

#### If the method can return null at the specific call site:
<response>
  <reason><![CDATA[EXPLAIN WHY THE INVOCATION Game.loop() RESULT CAN BE NULL.]]></reason>
  <value>YES</value>
</response>

#### If you are unsure or If there are any methods that directly or indirectly affect the return value and are not fully disclosed, request their declarations first, in the following format:
<response>
  <reason><![CDATA[EXPLAIN WHY THIS METHOD DECLARATION IS NECESSARY AND WHY YOU CANNOT MAKE A CONFIDENT DECISION WITHOUT IT]]></reason>
  <success>false</success>
  <methods>
    <method>methodName</method>
  </methods>
</response>

Additional Notes:
Be precise in your reasoning.
If a method’s return value depends on another method not provided, request its declaration before making a conclusion.
If the method can return null in this case but not in others, explain why it happens specifically for this call.

---ChatGPT.sendRequestToOpenAI---
Retrieving response from cache
---Response.<init>---
Creating Response:
```xml
<response>
  <reason><![CDATA[The method `Game.loop()` returns the static field `gameLoop`, which is initialized in the `Game.init(String... args)` method. In this method, a new `GameLoop` object is instantiated and assigned to `gameLoop`. Since `init()` must be called before `start()`, which is implied by the requirement of initializing the game, the `gameLoop` is guaranteed to be non-null during the lifetime of the game execution where `Game.loop()` is called. The absence of any code that could set `gameLoop` to null after its initialization ensures that `Game.loop()` cannot return null.]]></reason>
  <value>NO</value>
</response>
```
---Response.<init>---
Response created:
Disagreement: The method `Game.loop()` returns the static field `gameLoop`, which is initialized in the `Game.init(String... args)` method. In this method, a new `GameLoop` object is instantiated and assigned to `gameLoop`. Since `init()` must be called before `start()`, which is implied by the requirement of initializing the game, the `gameLoop` is guaranteed to be non-null during the lifetime of the game execution where `Game.loop()` is called. The absence of any code that could set `gameLoop` to null after its initialization ensures that `Game.loop()` cannot return null.
---AdvancedNullAwayCodeFix.resolveMethodDereferenceError---
Method is not returning nullable on call site. Injecting suppression annotation.
---AdvancedNullAwayCodeFix.constructCastToNonnullChange---
Constructing cast to nonnull change for reason: The method `Game.loop()` returns the static field `gameLoop`, which is initialized in the `Game.init(String... args)` method. In this method, a new `GameLoop` object is instantiated and assigned to `gameLoop`. Since `init()` must be called before `start()`, which is implied by the requirement of initializing the game, the `gameLoop` is guaranteed to be non-null during the lifetime of the game execution where `Game.loop()` is called. The absence of any code that could set `gameLoop` to null after its initialization ensures that `Game.loop()` cannot return null.
---ChatGPT.ask---
Asking ChatGPT:
For the reason you mentioned earlier:

"The method `Game.loop()` returns the static field `gameLoop`, which is initialized in the `Game.init(String... args)` method. In this method, a new `GameLoop` object is instantiated and assigned to `gameLoop`. Since `init()` must be called before `start()`, which is implied by the requirement of initializing the game, the `gameLoop` is guaranteed to be non-null during the lifetime of the game execution where `Game.loop()` is called. The absence of any code that could set `gameLoop` to null after its initialization ensures that `Game.loop()` cannot return null."

in the method below, the expression Game.loop() is not nullable at the point it is used.

```java
public void loadEnvironment(@Nullable final Environment env) {
    Lock lock = Game.loop().getLock();
    lock.lock();
    try {
      unloadEnvironment();
      this.environment = env;
      if (env != null) {
        this.addEnvironment(env);

        if (env.getGravity() == 0 && this.gravity() != 0) {
          env.setGravity(this.gravity());
        }

        env.load();
        for (final EnvironmentLoadedListener listener : this.loadedListeners) {
          listener.loaded(env);
        }

        // call map specific listeners
        String mapName = getMapName(env);
        if (mapName != null && this.environmentLoadedListeners.containsKey(mapName)) {

          // for the default camera we center the camera on the environment
          if (this.camera().getClass().equals(Camera.class)) {
            camera().setFocus(env.getCenter());
          }

          for (EnvironmentLoadedListener listener : this.environmentLoadedListeners.get(mapName)) {
            listener.loaded(env);
          }
        }
      }
    } finally {
      lock.unlock();
    }
}
```
Please Summarize the reason in max 5 words and rewrite the method so that at the line "    Lock lock = Game.loop().getLock();", at the occurrence of: "Game.loop()" is replaced with `NullabilityUtil.castToNonnull(Game.loop(), summary of reason)`
Replace "REASON" with the exact reason summary I provide to you (maximum 5 words), not with a generic explanation like "checked to be nonnull".
see the example below, for expression `foo.getBar()`, to wrap it with `NullabilityUtil.castToNonnull(foo.getBar(), "reason")`.

```java
public t(){
    String l = foo.getBar();
}
```

will be:
```java
public t(){
    String l = NullabilityUtil.castToNonnull(foo.getBar(), "checked to be nonnull");
}
```

### Instructions:

Do not import any additional classes.

Do not add Java comments.

Only modify relevant lines as required.

Return only the modified method wrapped in the XML format shown below.

Place the Java code inside the <code> tag using a CDATA block with ```java formatting.

Just give me the fixed code snippet in XML format in <response> tag like the example below. I will apply the fix to my codebase. Do not import any additional libraries or classes or add java comments. If you can provide the fixed code snippet, please provide it in the following format and place the code snippet in the <code> tag within ```java block.
<response>
  <success>true</success>
  <code><![CDATA[
  ```java
  Your fixed code snippet here
  ```
    ]]>
  </code>
</response>

---ChatGPT.sendRequestToOpenAI---
Sending request to OpenAI...
---ChatGPT.sendRequestToOpenAI---
Response received from OpenAI.
---Response.<init>---
Creating Response:
```xml
<response>
  <success>true</success>
  <code><![CDATA[
  ```java
public void loadEnvironment( final Environment env) {
    Lock lock = NullabilityUtil.castToNonnull(Game.loop(), "initialized during game setup").getLock();
    lock.lock();
    try {
      unloadEnvironment();
      this.environment = env;
      if (env != null) {
        this.addEnvironment(env);

        if (env.getGravity() == 0 && this.gravity() != 0) {
          env.setGravity(this.gravity());
        }

        env.load();
        for (final EnvironmentLoadedListener listener : this.loadedListeners) {
          listener.loaded(env);
        }

        // call map specific listeners
        String mapName = getMapName(env);
        if (mapName != null && this.environmentLoadedListeners.containsKey(mapName)) {

          // for the default camera we center the camera on the environment
          if (this.camera().getClass().equals(Camera.class)) {
            camera().setFocus(env.getCenter());
          }

          for (EnvironmentLoadedListener listener : this.environmentLoadedListeners.get(mapName)) {
            listener.loaded(env);
          }
        }
      }
    } finally {
      lock.unlock();
    }
}
  ```
    ]]>
  </code>
</response>
```
---Response.<init>---
Response created:
public void loadEnvironment( final Environment env) {
    Lock lock = NullabilityUtil.castToNonnull(Game.loop(), "initialized during game setup").getLock();
    lock.lock();
    try {
      unloadEnvironment();
      this.environment = env;
      if (env != null) {
        this.addEnvironment(env);

        if (env.getGravity() == 0 && this.gravity() != 0) {
          env.setGravity(this.gravity());
        }

        env.load();
        for (final EnvironmentLoadedListener listener : this.loadedListeners) {
          listener.loaded(env);
        }

        // call map specific listeners
        String mapName = getMapName(env);
        if (mapName != null && this.environmentLoadedListeners.containsKey(mapName)) {

          // for the default camera we center the camera on the environment
          if (this.camera().getClass().equals(Camera.class)) {
            camera().setFocus(env.getCenter());
          }

          for (EnvironmentLoadedListener listener : this.environmentLoadedListeners.get(mapName)) {
            listener.loaded(env);
          }
        }
      }
    } finally {
      lock.unlock();
    }
}
---ChatGPT.fixDereferenceByAddingCastToNonnull---
Fixing the error by adding castToNonnull
---AdvancedNullAwayCodeFix.fixTriggeredErrorsForLocation---
Resolving unresolvable error for triggered error: Type='DEREFERENCE_NULLABLE', message='dereferenced expression Game.loop() is @Nullable'
/home/nima/Developer/nullness-benchmarks/litiengine/src/de/gurkenlabs/litiengine/GameTime.java:95
    return this.toTicks(milliseconds, Game.loop().getTickRate());
---AdvancedNullAwayCodeFix.fix---
Fixing error: Type='DEREFERENCE_NULLABLE', message='dereferenced expression Game.loop() is @Nullable'
/home/nima/Developer/nullness-benchmarks/litiengine/src/de/gurkenlabs/litiengine/GameTime.java:95
    return this.toTicks(milliseconds, Game.loop().getTickRate());
---AdvancedNullAwayCodeFix.resolveDereferenceError---
Resolving dereference error: Type='DEREFERENCE_NULLABLE', message='dereferenced expression Game.loop() is @Nullable'
/home/nima/Developer/nullness-benchmarks/litiengine/src/de/gurkenlabs/litiengine/GameTime.java:95
    return this.toTicks(milliseconds, Game.loop().getTickRate());
---AdvancedNullAwayCodeFix.resolveDereferenceError---
Checking nullability possibility at error point
---ChatGPT.checkNullabilityPossibilityAtErrorPoint---
Asking if the expression can be null at error point point
---ChatGPT.ask---
Asking ChatGPT:
In the method below, is there a possibility that the expression "Game.loop()" at line "return this.toTicks(milliseconds, Game.loop().getTickRate());" is null?
public long toTicks(final int milliseconds) {
    return this.toTicks(milliseconds, Game.loop().getTickRate());
}
Give a single-word answer in XML format. If it is possible for the expression to be null, respond with:
```xml
<response>
    <reason><![CDATA[YOUR REASON]]></reason>
    <value>YES</value>
</response>
```
If it is not possible for the expression to be null, respond with:
```xml
<response>
    <reason><![CDATA[YOUR REASON]]></reason>
    <value>NO</value>
</response>
```
If you are unsure or need more information, respond with where you can ask for more details or what specific information you need.

If additional information is required, list each request inside a `<request>` tag. If no additional information is needed, omit the `<requests>` section.

Respond with:
```xml
<response>
    <reason><![CDATA[YOUR REASON]]></reason>
    <value>UNKNOWN</value>
    <!-- Include <requests> only if additional information is needed -->
    <requests>
        <request><![CDATA[YOUR REQUEST 1]]></request>
        <request><![CDATA[YOUR REQUEST 2]]></request>
    </requests>
</response>
```
---ChatGPT.sendRequestToOpenAI---
Sending request to OpenAI...
---ChatGPT.sendRequestToOpenAI---
Response received from OpenAI.
---Response.<init>---
Creating Response:
```xml
<response>
    <reason><![CDATA[The possibility of Game.loop() returning null depends on the implementation of the Game class, which is not provided. Without knowing how Game.loop() is implemented, it is impossible to determine if it can return null.]]></reason>
    <value>UNKNOWN</value>
    <requests>
        <request><![CDATA[Please provide details of the Game class implementation, particularly how the loop() method is defined and managed.]]></request>
        <request><![CDATA[Provide any documentation on whether Game.loop() can return a null value.]]></request>
    </requests>
</response>
```
---Response.<init>---
Response created:
Unknown: The possibility of Game.loop() returning null depends on the implementation of the Game class, which is not provided. Without knowing how Game.loop() is implemented, it is impossible to determine if it can return null.
---AdvancedNullAwayCodeFix.resolveMethodDereferenceError---
Resolving method dereference error.
---AdvancedNullAwayCodeFix.resolveMethodDereferenceError---
Method is in annotated package. Checking if the method is returning nullable.
---AdvancedNullAwayCodeFix.investigateMethodReturnNullability---
Checking if the method is returning nullable.
---ChatGPT.checkIfMethodIsReturningNullable---
Asking if the method is returning nullable: loop()
---ChatGPT.ask---
Asking ChatGPT:
In the method below, is there a possibility that the method returns null based only on its body? Consider the following points:

- The method may have multiple return paths; consider all return statements.
- If the method calls another method, do not assume its return value unless its full declaration is provided. Request its declaration if needed.
- The method may throw an exception instead of returning null. An exception path should not be considered a null return.
- Ensure you request the declarations of any methods whose return values directly or indirectly impact this method’s return value before making a conclusion.
- Carefully analyze all conditions and prior operations that may guarantee a non-null return value.

@Nullable public static IGameLoop loop() {
    return gameLoop;
}

Here are the method definitions in addition to the method inquired:

Depth: 0
```java
class de.gurkenlabs.litiengine.Game {
@Nullable public static IGameLoop loop() {
    return gameLoop;
}
}
```


Response Format:
Provide the answer in **XML format** as follows:

#### If the method **cannot** return `null`:
```xml
<response>
  <reason><![CDATA[EXPLAIN WHY THE METHOD CANNOT RETURN NULL]]></reason>
  <value>NO</value>
</response>
```

#### If the method can return null:
```xml
<response>
  <reason><![CDATA[EXPLAIN WHY THE METHOD CAN RETURN NULL]]></reason>
  <value>YES</value>
</response>
```

#### If you are unsure or need more information, respond with where you can ask for more details or what specific information you need.

#### If you are unsure or If there are any methods that directly or indirectly affect the return value and are not fully disclosed, request their declarations first, in the following format:
<response>
  <reason><![CDATA[YOUR REASON]]></reason>
  <value>UNKNOWN</value>
  <methods>
    <method>methodName</method>
  </methods>
</response>

If additional information is required other than method declaration, list each request inside a `<request>` tag. If no additional information is needed, omit the `<requests>` section.

Respond with:
```xml
<response>
    <reason><![CDATA[YOUR REASON]]></reason>
    <value>UNKNOWN</value>
    <!-- Include <requests> only if additional information is needed -->
    <requests>
        <request><![CDATA[YOUR REQUEST 1]]></request>
        <request><![CDATA[YOUR REQUEST 2]]></request>
    </requests>
</response>
```

Additional Notes:
Be precise in your reasoning.
If a method’s return value depends on another method not provided, request its declaration before making a conclusion.
If the method can return null in some cases but not others, explain under what conditions it can happen.

---ChatGPT.sendRequestToOpenAI---
Retrieving response from cache
---Response.<init>---
Creating Response:
```xml
<response>
  <reason><![CDATA[The method `loop` returns the variable `gameLoop`. Without the initialization or assignment details of `gameLoop`, it's unclear whether it can be null. The possibility of `gameLoop` being uninitialized or set to null elsewhere in the program means `loop` could potentially return null. Further information on `gameLoop` is required.]]></reason>
  <value>UNKNOWN</value>
  <requests>
    <request><![CDATA[Please provide the declaration and initialization of the variable `gameLoop` in the class `de.gurkenlabs.litiengine.Game`.]]></request>
  </requests>
</response>
```
---Response.<init>---
Response created:
Unknown: The method `loop` returns the variable `gameLoop`. Without the initialization or assignment details of `gameLoop`, it's unclear whether it can be null. The possibility of `gameLoop` being uninitialized or set to null elsewhere in the program means `loop` could potentially return null. Further information on `gameLoop` is required.
---AdvancedNullAwayCodeFix.investigateMethodReturnNullability---
Could not determine the nullability and model did not ask for any method.
---ChatGPT.checkIfMethodIsReturningNullableOnCallSite---
Asking if the method is returning nullable on the call site: Game.loop()
---ChatGPT.ask---
Asking ChatGPT:
In the method below, is there a possibility that the method returns null at the given call site?

```java
@Nullable public static IGameLoop loop() {
    return gameLoop;
}
```

## Guidelines:
- The method may have multiple return paths; consider all return statements.
- If the method calls another method, do not assume its return value unless its full declaration is provided. Request its declaration if needed.
- The method may throw an exception instead of returning null. An exception path should not be considered a null return.
- Ensure you request the declarations of any methods whose return values directly or indirectly impact this method’s return value before making a conclusion.
- If the method returns a value that is determined by a parameter, evaluate based on the actual argument at the given call site.
- Analyze based only on the specific invocation provided. Do not generalize to all possible inputs.- If the return value is guaranteed to be non-null at the call site, the answer should be a definitive NO.
- Do not generalize based on all possible inputs—your answer must be based only on the given invocation.
- Focus only on the given call site, not all possible invocations.

### call site:
Game.loop()

Here are the method definitions and the call chain for this method, showing the sequence of calls from the method to its callers at each depth level:

Depth: 0
```java
class de.gurkenlabs.litiengine.Game {
@Nullable public static IGameLoop loop() {
    return gameLoop;
}
}
```
Depth: 1
```java
class de.gurkenlabs.litiengine.environment.GameWorld {
public void loadEnvironment(@Nullable final Environment env) {
    Lock lock = Game.loop().getLock();
    lock.lock();
    try {
      unloadEnvironment();
      this.environment = env;
      if (env != null) {
        this.addEnvironment(env);

        if (env.getGravity() == 0 && this.gravity() != 0) {
          env.setGravity(this.gravity());
        }

        env.load();
        for (final EnvironmentLoadedListener listener : this.loadedListeners) {
          listener.loaded(env);
        }

        // call map specific listeners
        String mapName = getMapName(env);
        if (mapName != null && this.environmentLoadedListeners.containsKey(mapName)) {

          // for the default camera we center the camera on the environment
          if (this.camera().getClass().equals(Camera.class)) {
            camera().setFocus(env.getCenter());
          }

          for (EnvironmentLoadedListener listener : this.environmentLoadedListeners.get(mapName)) {
            listener.loaded(env);
          }
        }
      }
    } finally {
      lock.unlock();
    }
}public void setCamera(@Nullable final ICamera cam) {
    if (this.camera() != null) {
      Game.loop().detach(camera);
    }

    camera = cam;

    if (cam != null && !Game.isInNoGUIMode()) {
      Game.loop().attach(cam);
      cam.updateFocus();
    }
}
}
```
```java
class de.gurkenlabs.litiengine.entities.behavior.EntityNavigator {
public EntityNavigator(final IMobileEntity entity, final PathFinder pathFinder) {
    this.cancelNavigationConditions = new CopyOnWriteArrayList<>();
    this.listeners = new CopyOnWriteArrayList<>();
    this.entity = entity;
    this.pathFinder = pathFinder;
    this.setAcceptableError(DEFAULT_ACCEPTABLE_ERROR);
    Game.loop().attach(this);
}
}
```
```java
class de.gurkenlabs.litiengine.GameWindow {
private static void initializeWindowEventListeners(Window window) {

    window.addWindowStateListener(
        e -> {
          if (e.getNewState() == Frame.ICONIFIED) {
            Game.loop().setTickRate(ICONIFIED_MAX_FPS);
          } else {
            Game.loop().setTickRate(Game.config().client().getMaxFps());
          }
        });

    window.addWindowFocusListener(
        new WindowFocusListener() {
          @Override
          public void windowLostFocus(WindowEvent e) {
            if (Game.config().graphics().reduceFramesWhenNotFocused()) {
              Game.loop().setTickRate(NONE_FOCUS_MAX_FPS);
            }
          }

          @Override
          public void windowGainedFocus(WindowEvent e) {
            Game.loop().setTickRate(Game.config().client().getMaxFps());
          }
        });

    window.addWindowListener(
        new WindowAdapter() {
          @Override
          public void windowClosing(final WindowEvent event) {
            Game.exit();
          }
        });
}
}
```
```java
class de.gurkenlabs.litiengine.gui.screens.ScreenManager {
public void display(@Nullable final Screen screen) {
    if (Game.hasStarted() && Game.time().since(this.lastScreenChange) < this.getChangeCooldown()) {
      log.log(
          Level.INFO,
          "Skipping displaying of screen {0} because screen changing is currently on cooldown.",
          screen != null ? screen.getName() : "");
      return;
    }

    final Screen previous = this.current();
    if (previous != null) {
      previous.suspend();
    }

    if (screen != null && !this.screens.contains(screen)) {
      this.screens.add(screen);
    }

    this.currentScreen = screen;
    if (!Game.isInNoGUIMode() && this.current() != null) {
      this.current().prepare();
    }

    this.lastScreenChange = Game.loop().getTicks();

    final ScreenChangedEvent event = new ScreenChangedEvent(this.current(), previous);
    for (final ScreenChangedListener listener : this.screenChangedListeners) {
      listener.changed(event);
    }
}
}
```
```java
class de.gurkenlabs.litiengine.abilities.effects.Effect {
@Override
  public void update() {

    for (final Iterator<EffectApplication> iterator = this.getActiveAppliances().iterator();
        iterator.hasNext(); ) {
      final EffectApplication appliance = iterator.next();
      // if the effect duration is reached
      if (this.hasEnded(appliance)) {

        iterator.remove();
        this.cease(appliance);
      }
    }

    // 4. unregister if all appliances are finished
    if (this.getActiveAppliances().isEmpty()) {
      Game.loop().detach(this);
    }
}public void apply(final Shape impactArea) {
    final List<ICombatEntity> affected = this.lookForAffectedEntities(impactArea);
    for (final ICombatEntity affectedEntity : affected) {
      this.apply(affectedEntity);
    }

    this.appliances.add(new EffectApplication(affected, impactArea));

    // if it is the first appliance -> register for update
    if (this.appliances.size() == 1) {
      Game.loop().attach(this);
    }
}
}
```
```java
class de.gurkenlabs.litiengine.GameTime {
public long toTicks(final int milliseconds) {
    return this.toTicks(milliseconds, Game.loop().getTickRate());
}public long since(final long tick) {
    return toMilliseconds(Game.loop().getTicks() - tick);
}public long now() {
    return Game.loop().getTicks();
}public long sinceGameStart() {
    return this.toMilliseconds(Game.loop().getTicks());
}@Override
  public void loaded(Environment environment) {
    environmentLoaded = Game.loop().getTicks();
}public long toMilliseconds(final long ticks) {
    return this.toMilliseconds(ticks, Game.loop().getTickRate());
}
}
```
```java
class de.gurkenlabs.litiengine.GameMetrics {
@Override
  public void render(final Graphics2D g) {
    this.updateMetrics();

    if (!Game.config().client().showGameMetrics()) {
      return;
    }

    this.currentOffsetY = 0;

    g.setColor(this.renderColor);

    // render client metrics
    this.drawTitle(g, "[client]");
    this.drawMetric(g, "fps       : " + this.getFramesPerSecond());
    this.drawMetric(g, "max fps   : " + this.maxFramesPerSecond);
    this.drawMetric(g, "updatables: " + Game.loop().getUpdatableCount());

    // render jvm metrics if debug is enabled
    if (Game.config().debug().isDebugEnabled()) {
      this.drawTitle(g, "[jvm]");
      this.drawMetric(g, "java      : " + this.javaVersion);
      this.drawMetric(g, "memory    : " + String.format("%-5.5s", this.usedMemory) + " MB");
      this.drawMetric(g, "threads   : " + Thread.activeCount());
    }

    // render rendering metrics
    if (!this.renderMetrics.isEmpty()) {
      this.drawTitle(g, "[update]");

      for (RenderMetrics metric : this.renderMetrics) {
        this.drawMetric(g, metric.toString());
      }

      this.renderMetrics.clear();
    }
}
}
```
```java
class de.gurkenlabs.litiengine.graphics.emitters.Emitter {
public void deactivate() {
    if (!this.activated) {
      return;
    }

    this.activated = false;
    this.getParticles().clear();
    this.aliveTime = 0;
    this.activationTick = 0;
    this.lastSpawn = 0;
    Game.loop().detach(this);
}public void activate() {
    if (this.activated) {
      return;
    }

    this.activated = true;
    this.activationTick = Game.time().now();
    Game.loop().attach(this);
}@Override
  public void update() {
    if (this.isPaused()) {
      return;
    }

    // clear particles if the effect time to life is reached
    if (this.isFinished()) {
      for (EmitterFinishedListener listener : this.finishedListeners) {
        listener.finished(this);
      }

      this.delete();
      return;
    }

    final float updateRatio = (float) this.data().getUpdateRate() / Game.loop().getTickRate();
    for (final Particle p : this.getParticles().stream().collect(Collectors.toList())) {
      if (this.particleCanBeRemoved(p)) {
        // remove dead particles
        this.particles.remove(p);
        continue;
      }

      p.update(this.getOrigin(), updateRatio);
    }

    this.aliveTime = Game.time().since(this.activationTick);
    if ((this.data().getSpawnRate() == 0
        || Game.time().since(this.lastSpawn) >= this.data().getSpawnRate())) {
      this.lastSpawn = Game.time().now();
      this.spawnParticle();
    }
}
}
```
```java
class de.gurkenlabs.litiengine.entities.behavior.IBehaviorController {
public default void attach() {
    Game.loop().attach(this);
}public default void detach() {
    Game.loop().detach(this);
}
}
```
```java
class de.gurkenlabs.litiengine.abilities.AbilityExecution {
AbilityExecution(final Ability ability) {
    this.appliedEffects = new CopyOnWriteArrayList<>();
    this.ability = ability;
    this.executionTicks = Game.time().now();
    this.impactArea = ability.calculateImpactArea();
    this.castLocation = ability.getExecutor().getCenter();
    Game.loop().attach(this);
}@Override
  public void update() {
    // if there a no effects to apply -> unregister this instance and we're done
    if (this.getAbility().getEffects().isEmpty()
        || this.getAbility().getEffects().size() == this.getAppliedEffects().size()) {
      Game.loop().detach(this);
      return;
    }

    // handle all effects from the ability that were not applied yet
    for (final Effect effect : this.getAbility().getEffects()) {
      // if the ability was not executed yet or the delay of the effect is not
      // yet reached
      if (this.getAppliedEffects().contains(effect)
          || Game.time().since(this.getExecutionTicks()) < effect.getDelay()) {
        continue;
      }

      effect.apply(this.getExecutionImpactArea());
      this.getAppliedEffects().add(effect);
    }
}
}
```
```java
class de.gurkenlabs.litiengine.GameWindow$3 {
@Override
          public void windowGainedFocus(WindowEvent e) {
            Game.loop().setTickRate(Game.config().client().getMaxFps());
}@Override
          public void windowLostFocus(WindowEvent e) {
            if (Game.config().graphics().reduceFramesWhenNotFocused()) {
              Game.loop().setTickRate(NONE_FOCUS_MAX_FPS);
            }
}
}
```
```java
class de.gurkenlabs.litiengine.environment.EntitySpawner {
protected void spawnNewEntities() {
    if (this.getSpawnMode() != SpawnMode.CUSTOMSPAWNPOINTS && this.getSpawnPoints().isEmpty()) {
      return;
    }

    switch (this.getSpawnMode()) {
      case ALLSPAWNPOINTS:
        for (int i = 0; i < this.getSpawnPoints().size(); i++) {
          final int index = i;
          Game.loop()
              .perform(
                  this.getSpawnDelay() + this.getSpawnDelay() * i,
                  () -> this.spawn(this.getSpawnPoints().get(index), this.getSpawnAmount()));
        }
        break;
      case ONERANDOMSPAWNPOINT:
        this.spawn(Game.random().choose(this.getSpawnPoints()), this.getSpawnAmount());
        break;
      case RANDOMSPAWNPOINTS:
        for (int i = 0; i < this.getSpawnAmount(); i++) {
          Game.loop()
              .perform(
                  this.getSpawnDelay() + this.getSpawnDelay() * i,
                  () -> this.spawn(Game.random().choose(this.getSpawnPoints()), 1));
        }
        break;
      case CUSTOMSPAWNPOINTS:
        List<Spawnpoint> spawnPoints =
            this.customSpawnpoints != null
                ? this.customSpawnpoints.apply(this)
                : this.getCustomSpawnpoints();

        int index = 0;
        for (Spawnpoint spawn : spawnPoints) {
          Game.loop()
              .perform(
                  this.getSpawnDelay() + this.getSpawnDelay() * index, () -> this.spawn(spawn, 1));
          index++;
        }
        break;
      default:
        break;
    }
}
}
```
```java
class de.gurkenlabs.litiengine.tweening.TweenEngine {
@Override
  public void start() {
    Game.loop().attach(this);
}@Override
  public void terminate() {
    Game.loop().detach(this);
}
}
```
```java
class de.gurkenlabs.litiengine.gui.SpeechBubble {
public void hide() {
    Game.world().environment().removeRenderable(this);
    Game.loop().detach(this);
    if (activeSpeechBubbles.get(this.getEntity()) != null
        && activeSpeechBubbles.remove(this.getEntity()).equals(this)) {
      activeSpeechBubbles.remove(this.getEntity());
    }

    for (SpeechBubbleListener listener : this.listeners) {
      listener.hidden();
    }
}private SpeechBubble(
      final IEntity entity,
      final String text,
      @Nullable SpeechBubbleAppearance appearance,
      @Nullable Font font) {
    if (appearance == null) {
      this.appearance = DEFAULT_APPEARANCE;
    } else {
      this.appearance = appearance;
    }

    final SpeechBubble active = activeSpeechBubbles.get(entity);
    if (active != null) {
      active.hide();
    }
    this.setFont(font);

    this.textBoxWidth = (float) (entity.getWidth() * 4);
    this.entity = entity;

    this.currentText = text;
    this.currentTextDisplayTime = DISPLAYTIME_MIN + text.length() * DISPLAYTIME_PER_LETTER;

    this.lastTextDisplay = Game.time().now();
    this.createBubbleImage();
    entity.getEnvironment().add(this, RenderType.UI);
    Game.loop().attach(this);
    activeSpeechBubbles.put(entity, this);
}
}
```
```java
class de.gurkenlabs.litiengine.entities.Prop {
private void updateAnimationController() {
    IEntityAnimationController<?> controller = this.createAnimationController();
    this.getControllers().addController(controller);
    if (Game.world().environment() != null && Game.world().environment().isLoaded()) {
      Game.loop().attach(controller);
    }
}
}
```
```java
class de.gurkenlabs.litiengine.graphics.FreeFlightCamera {
public FreeFlightCamera(final Point2D focus) {
    this.setFocus(focus);
    this.velocity = DEFAULT_SCROLL_PIXELS_PER_SECOND;
    this.scrollPadding = DEFAULT_SCROLL_PADDING;
    this.setClampToMap(true);

    Game.loop().attach(this);
}private void handleFreeFlightCamera() {
    if (Game.world().environment() == null || Game.world().environment().getMap() == null) {
      return;
    }

    final Point2D mouseLocation = Input.mouse().getLocation();

    final double scrollSpeed =
        this.getVelocity()
            / (double) Game.loop().getTickRate()
            * Game.config().input().getMouseSensitivity();

    double x = this.getFocus().getX();
    double y = this.getFocus().getY();

    double deltaX = 0;
    if (mouseLocation.getX() < this.getScrollPadding()) {
      deltaX -= scrollSpeed;
    } else if (Game.window().getResolution().getWidth() - mouseLocation.getX()
        < this.getScrollPadding()) {
      deltaX += scrollSpeed;
    }

    double deltaY = 0;
    if (mouseLocation.getY() < this.getScrollPadding()) {
      deltaY -= scrollSpeed;
    } else if (Game.window().getResolution().getHeight() - mouseLocation.getY()
        < this.getScrollPadding()) {
      deltaY += scrollSpeed;
    }

    x += deltaX;
    y += deltaY;

    this.setFocus(new Point2D.Double(x, y));
}
}
```
```java
class de.gurkenlabs.litiengine.environment.Environment {
private static void dispose(final Collection<? extends IEntity> entities) {
    for (final IEntity entity : entities) {
      if (entity instanceof IUpdateable) {
        Game.loop().detach((IUpdateable) entity);
      }

      entity.detachControllers();
    }
}private static void loadUpdatableOrEmitterEntity(IEntity entity) {
    if (entity instanceof Emitter) {
      final Emitter emitter = (Emitter) entity;
      if (emitter.isActivateOnInit()) {
        emitter.activate();
      }
    } else if (entity instanceof IUpdateable) {
      Game.loop().attach((IUpdateable) entity);
    }
}private void unload(final IEntity entity) {
    // 1. remove from physics engine
    if (entity instanceof ICollisionEntity) {
      Game.physics().remove((ICollisionEntity) entity);
    }

    // 2. unregister from update
    if (entity instanceof IUpdateable) {
      Game.loop().detach((IUpdateable) entity);
    }

    if (entity instanceof IMobileEntity) {
      this.removeGravity((IMobileEntity) entity);
    }

    // 3. detach all controllers
    entity.detachControllers();

    if (entity instanceof Emitter) {
      Emitter em = (Emitter) entity;
      em.deactivate();
    }

    if (this.loaded && (entity instanceof LightSource || entity instanceof StaticShadow)) {
      this.updateLighting(entity);
    }

    entity.removed(this);
}
}
```
```java
class de.gurkenlabs.litiengine.graphics.animation.Animation {
@Override
  public void update() {
    // do nothing if the animation is not playing or the current keyframe is not finished
    if (!this.isPlaying()
        || Game.time().since(this.lastFrameUpdate) < this.getCurrentKeyFrame().getDuration()) {
      return;
    }

    // if we are not looping and the last keyframe is finished, we terminate the animation
    if (!this.isLooping() && this.isLastKeyFrame()) {
      this.terminate();
      return;
    }

    // make sure, we stay inside the keyframe list
    final int newFrameIndex =
        (this.getKeyframes().indexOf(this.currentFrame) + 1) % this.getKeyframes().size();
    final KeyFrame previousFrame = this.currentFrame;
    this.currentFrame = this.getKeyframes().get(newFrameIndex);

    for (KeyFrameListener listener : this.listeners) {
      listener.currentFrameChanged(previousFrame, this.currentFrame);
    }

    this.lastFrameUpdate = Game.loop().getTicks();
}public void restart() {
    this.currentFrame = this.firstFrame;
    this.lastFrameUpdate = Game.loop().getTicks();
}
}
```
```java
class de.gurkenlabs.litiengine.physics.MovementController {
@Override
  public void attach() {
    Game.loop().attach(this);
}private void handleForces() {
    // clean up forces
    this.activeForces.forEach(
        x -> {
          if (x.hasEnded()) {
            this.activeForces.remove(x);
          }
        });

    if (this.activeForces.isEmpty()) {
      return;
    }

    // disable turn-on-move for force handling
    boolean turn = this.getEntity().turnOnMove();
    this.getEntity().setTurnOnMove(false);
    try {
      double deltaX = 0;
      double deltaY = 0;
      for (final Force force : this.activeForces) {
        if (force.cancelOnReached() && force.hasReached(this.getEntity())) {
          force.end();
          continue;
        }

        final Point2D collisionBoxCenter = this.getEntity().getCollisionBoxCenter();
        final double angle =
            GeometricUtilities.calcRotationAngleInDegrees(collisionBoxCenter, force.getLocation());
        final double strength =
            Game.loop().getDeltaTime() * 0.001f * force.getStrength() * Game.loop().getTimeScale();
        deltaX += GeometricUtilities.getDeltaX(angle, strength);
        deltaY += GeometricUtilities.getDeltaY(angle, strength);
      }

      final Point2D target =
          new Point2D.Double(this.getEntity().getX() + deltaX, this.getEntity().getY() + deltaY);
      final boolean success = Game.physics().move(this.getEntity(), target);
      if (!success) {
        for (final Force force : this.activeForces) {
          if (force.cancelOnCollision()) {
            force.end();
          }
        }
      }
    } finally {
      this.getEntity().setTurnOnMove(turn);
    }
}@Override
  public void detach() {
    Game.loop().detach(this);
}public void handleMovement() {
    if (!this.isMovementAllowed()) {
      this.velocity = 0;
      return;
    }

    // max distance an entity can travel within one tick
    final double maxPixelsPerTick = this.getEntity().getTickVelocity();
    final double deltaTime = Game.loop().getDeltaTime() * Game.loop().getTimeScale();

    final double acceleration =
        this.getEntity().getAcceleration() == 0
            ? maxPixelsPerTick
            : deltaTime / this.getEntity().getAcceleration() * maxPixelsPerTick;
    final double deceleration =
        this.getEntity().getDeceleration() == 0
            ? this.getVelocity()
            : deltaTime / this.getEntity().getDeceleration() * maxPixelsPerTick;

    double dx = this.getDx();
    double dy = this.getDy();
    this.setDx(0);
    this.setDy(0);

    final double deltaVelocity =
        Math.min(Math.sqrt(Math.pow(dx, 2) + Math.pow(dy, 2)), acceleration);
    if (deltaVelocity != 0) {
      double newVelocity = this.getVelocity() + deltaVelocity;
      this.setVelocity(newVelocity);
    } else {
      final double newVelocity = Math.max(0, this.getVelocity() - deceleration);
      this.setVelocity(newVelocity);
      dx = GeometricUtilities.getDeltaX(this.moveAngle);
      dy = GeometricUtilities.getDeltaY(this.moveAngle);
    }

    if (this.getVelocity() == 0) {
      this.moveAngle = 0;
      return;
    }

    // actually move entity
    this.moveEntity(dx, dy);
}
}
```
```java
class de.gurkenlabs.litiengine.graphics.animation.AnimationController {
public void detach() {
    Game.loop().detach(this);
}public void attach() {
    Game.loop().attach(this);
}
}
```
```java
class de.gurkenlabs.litiengine.graphics.Camera {
@Override
  public void setZoom(final float targetZoom, final int delay) {
    if (delay == 0) {

      this.zoom = targetZoom;
      this.targetZoom = 0;
      this.zoomDelay = 0;
      this.zoomTick = 0;
      this.zoomStep = 0;

      final ZoomChangedEvent event = new ZoomChangedEvent(this, targetZoom);
      for (final ZoomChangedListener listener : this.zoomListeners) {
        listener.zoomChanged(event);
      }
    } else {
      this.zoomTick = Game.time().now();
      this.targetZoom = targetZoom;
      this.zoomDelay = delay;

      final double tickduration = 1000 / (double) Game.loop().getTickRate();
      final double tickAmount = delay / tickduration;
      final float totalDelta = this.targetZoom - this.zoom;
      this.zoomStep = tickAmount > 0 ? (float) (totalDelta / tickAmount) : totalDelta;
    }
}
}
```
```java
class de.gurkenlabs.litiengine.Game {
public static synchronized void init(String... args) {
    if (initialized) {
      log().log(Level.INFO, "The game has already been initialized.");
      return;
    }

    log.init();
    handleCommandLineArguments(args);

    config().load();
    Locale.setDefault(new Locale(config().client().getCountry(), config().client().getLanguage()));

    gameLoop = new GameLoop("Main Update Loop", config().client().getMaxFps());
    loop().attach(physics());
    loop().attach(world());

    // setup default exception handling for render and update loop
    setUncaughtExceptionHandler(
        new DefaultUncaughtExceptionHandler(config().client().exitOnError()));

    screenManager = new ScreenManager();
    gameWindow = new GameWindow();

    // initialize  the game window
    window().init();
    world.setCamera(new Camera());

    for (GameListener listener : gameListeners) {
      listener.initialized(args);
    }

    if (!isInNoGUIMode()) {
      window().getRenderComponent().onRendered(g -> metrics().render(g));

      graphics()
          .addEntityRenderedListener(
              e -> DebugRenderer.renderEntityDebugInfo(e.getGraphics(), e.getEntity()));

      window().getRenderComponent().onFpsChanged(fps -> metrics().setFramesPerSecond(fps));
      window()
          .setIcons(
              Arrays.asList(
                  Resources.images().get("liti-logo-x16.png"),
                  Resources.images().get("liti-logo-x20.png"),
                  Resources.images().get("liti-logo-x32.png"),
                  Resources.images().get("liti-logo-x48.png")));

      Input.keyboard()
          .onKeyTyped(
              KeyEvent.VK_PRINTSCREEN,
              key -> {
                // don't take a screenshot if a modifier is active
                if (key.getModifiers() != 0) {
                  return;
                }

                window().getRenderComponent().takeScreenshot();
              });
    }

    Runtime.getRuntime().addShutdownHook(new Thread(Game::terminate, "Shutdown"));

    initialized = true;
}
}
```
```java
class de.gurkenlabs.litiengine.entities.Creature {
protected void updateAnimationController() {
    IEntityAnimationController<?> controller = this.createAnimationController();
    this.getControllers().addController(controller);
    if (Game.world().environment() != null && Game.world().environment().isLoaded()) {
      Game.loop().attach(controller);
    }
}@Override
  public float getTickVelocity() {
    // pixels per ms multiplied by the passed ms
    // ensure that entities don't travel too far in case of lag
    return Math.min(Game.loop().getDeltaTime(), GameLoop.TICK_DELTATIME_LAG)
        * 0.001F
        * this.getVelocity().get()
        * Game.loop().getTimeScale();
}
}
```
Depth: 2
```java
class de.gurkenlabs.litiengine.environment.GameWorld {
public void clear() {
    this.unloadEnvironment();
    this.environments.clear();
    this.setCamera(null);
    Game.physics().clear();

    this.environmentListeners.clear();
    this.environmentLoadedListeners.clear();
    this.environmentUnloadedListeners.clear();

    this.listeners.clear();
    this.loadedListeners.clear();
    this.unloadedListeners.clear();
}@Nullable
  public Environment loadEnvironment(IMap map) {
    Environment env = this.getEnvironment(map);
    this.loadEnvironment(env);
    return env;
}@Nullable
  public Environment loadEnvironment(String mapName) {
    Environment env = this.getEnvironment(mapName);
    this.loadEnvironment(env);
    return env;
}
}
```
```java
class de.gurkenlabs.litiengine.GameWindow {
GameWindow() {
    this.hostControl = new JFrame();

    this.resolutionChangedListeners = new CopyOnWriteArrayList<>();

    this.renderCanvas = new RenderComponent(Game.config().graphics().getResolution());
    this.cursor = new MouseCursor();
    if (!Game.isInNoGUIMode()) {
      this.hostControl.setBackground(Color.BLACK);
      this.hostControl.add(this.renderCanvas);

      this.initializeEventListeners();

      this.hostControl.setTitle(Game.info().getTitle());
      this.hostControl.setDefaultCloseOperation(WindowConstants.DO_NOTHING_ON_CLOSE);
      initializeWindowEventListeners(this.hostControl);
    }
}
}
```
```java
class de.gurkenlabs.litiengine.GameTime {
public long sinceEnvironmentLoad() {
    return this.since(this.environmentLoaded);
}public long since(final long tick) {
    return toMilliseconds(Game.loop().getTicks() - tick);
}public long sinceGameStart() {
    return this.toMilliseconds(Game.loop().getTicks());
}
}
```
```java
class de.gurkenlabs.litiengine.abilities.effects.Effect {
protected void cease(final EffectApplication appliance) {
    // 1. cease the effect for all affected entities
    for (final ICombatEntity entity : appliance.getAffectedEntities()) {
      this.cease(entity);
    }

    // 2. apply follow up effects
    this.getFollowUpEffects().forEach(followUp -> followUp.apply(appliance.getImpactArea()));
}protected boolean hasEnded(final EffectApplication appliance) {
    final long effectDuration = Game.time().since(appliance.getAppliedTicks());
    return effectDuration > this.getDuration();
}
}
```
```java
class de.gurkenlabs.litiengine.abilities.effects.EffectApplication {
protected EffectApplication(final List<ICombatEntity> affectedEntities, final Shape impactArea) {
    this.applied = Game.time().now();
    this.affectedEntities = affectedEntities;
    this.impactArea = impactArea;
}
}
```
```java
class de.gurkenlabs.litiengine.entities.CombatEntity {
@Override
  public boolean wasHit(int timeSpan) {
    return Game.time().since(this.lastHit) < timeSpan;
}@Override
  public void hit(final int damage, @Nullable final Ability ability) {
    if (this.isDead()) {
      return;
    }

    if (!this.isIndestructible()) {
      this.getHitPoints().modifyBaseValue(new AttributeModifier<>(Modification.SUBTRACT, damage));
    }

    final EntityHitEvent event = new EntityHitEvent(this, ability, damage, this.isDead());

    for (final CombatEntityListener listener : this.listeners) {
      listener.hit(event);
    }

    for (final CombatEntityHitListener listener : this.hitListeners) {
      listener.hit(event);
    }

    if (this.isDead()) {
      this.fireDeathEvent();
      this.setCollision(false);
    }

    this.lastHit = Game.time().now();
}
}
```
```java
class de.gurkenlabs.litiengine.graphics.ImageEffect {
protected ImageEffect(final int ttl, final String name) {
    this.ttl = ttl;
    this.name = name;
    this.aliveTick = Game.time().now();
}@Override
  public long getAliveTime() {
    return Game.time().since(this.aliveTick);
}
}
```
```java
class de.gurkenlabs.litiengine.abilities.AbilityExecution {
AbilityExecution(final Ability ability) {
    this.appliedEffects = new CopyOnWriteArrayList<>();
    this.ability = ability;
    this.executionTicks = Game.time().now();
    this.impactArea = ability.calculateImpactArea();
    this.castLocation = ability.getExecutor().getCenter();
    Game.loop().attach(this);
}@Override
  public void update() {
    // if there a no effects to apply -> unregister this instance and we're done
    if (this.getAbility().getEffects().isEmpty()
        || this.getAbility().getEffects().size() == this.getAppliedEffects().size()) {
      Game.loop().detach(this);
      return;
    }

    // handle all effects from the ability that were not applied yet
    for (final Effect effect : this.getAbility().getEffects()) {
      // if the ability was not executed yet or the delay of the effect is not
      // yet reached
      if (this.getAppliedEffects().contains(effect)
          || Game.time().since(this.getExecutionTicks()) < effect.getDelay()) {
        continue;
      }

      effect.apply(this.getExecutionImpactArea());
      this.getAppliedEffects().add(effect);
    }
}
}
```
```java
class de.gurkenlabs.litiengine.tweening.TweenEngine {
@Override
  public void update() {
    for (final Tweenable target : this.getTweens().keySet()) {
      for (final Tween tween : this.getTweens().get(target).values()) {
        if (tween.hasStopped()) {
          continue;
        }
        final long elapsed = Game.time().since(tween.getStartTime());
        if (elapsed >= tween.getDuration()) {
          tween.stop();
          continue;
        }
        final float[] currentValues = new float[tween.getTargetValues().length];
        for (int i = 0; i < tween.getTargetValues().length; i++) {
          currentValues[i] =
              tween.getStartValues()[i]
                  + tween.getEquation().compute(elapsed / (float) tween.getDuration())
                      * (tween.getTargetValues()[i] - tween.getStartValues()[i]);
        }
        tween.getTarget().setTweenValues(tween.getType(), currentValues);
      }
    }
}
}
```
```java
class de.gurkenlabs.litiengine.gui.SpeechBubble {
public static SpeechBubble create(
      final IEntity entity, final String text, SpeechBubbleAppearance appearance, Font font) {
    return new SpeechBubble(entity, text, appearance, font);
}public static SpeechBubble create(final IEntity entity, final Font font, final String text) {
    SpeechBubbleAppearance app =
        new SpeechBubbleAppearance(
            DEFAULT_APPEARANCE.getForeColor(),
            DEFAULT_APPEARANCE.getBackgroundColor1(),
            DEFAULT_APPEARANCE.getBorderColor(),
            DEFAULT_APPEARANCE.getPadding());
    return new SpeechBubble(entity, text, app, font);
}public static SpeechBubble create(final IEntity entity, final String text) {
    return new SpeechBubble(entity, text, null, GuiProperties.getDefaultFont());
}@Override
  public void update() {
    if (this.currentText == null) {
      this.hide();
      return;
    }

    this.entityCenter = Game.world().camera().getViewportLocation(this.getEntity().getCenter());

    // old text was displayed long enough
    if (this.lastTextDisplay != 0
        && Game.time().since(this.lastTextDisplay) > this.currentTextDisplayTime) {
      this.currentText = null;
      this.lastTextDisplay = 0;
      return;
    }

    // display new text
    if (this.textIndex < this.currentText.length()
        && Game.time().since(this.lastCharPoll) > LETTER_WRITE_DELAY) {
      this.textIndex++;
      this.lastCharPoll = Game.time().now();
      if (this.typeSound != null) {
        Game.audio().playSound(this.typeSound, this.getEntity());
      }
    }

    // continue displaying currently displayed text
}private SpeechBubble(
      final IEntity entity,
      final String text,
      final Sound typeSound,
      SpeechBubbleAppearance appearance,
      Font font) {
    this(entity, text, appearance, font);
    this.typeSound = typeSound;
}private SpeechBubble(
      final IEntity entity,
      final String text,
      @Nullable SpeechBubbleAppearance appearance,
      @Nullable Font font) {
    if (appearance == null) {
      this.appearance = DEFAULT_APPEARANCE;
    } else {
      this.appearance = appearance;
    }

    final SpeechBubble active = activeSpeechBubbles.get(entity);
    if (active != null) {
      active.hide();
    }
    this.setFont(font);

    this.textBoxWidth = (float) (entity.getWidth() * 4);
    this.entity = entity;

    this.currentText = text;
    this.currentTextDisplayTime = DISPLAYTIME_MIN + text.length() * DISPLAYTIME_PER_LETTER;

    this.lastTextDisplay = Game.time().now();
    this.createBubbleImage();
    entity.getEnvironment().add(this, RenderType.UI);
    Game.loop().attach(this);
    activeSpeechBubbles.put(entity, this);
}
}
```
```java
class de.gurkenlabs.litiengine.gui.TextFieldComponent {
@Override
  public void render(final Graphics2D g) {
    super.render(g);
    g.setFont(this.getFont());
    final FontMetrics fm = g.getFontMetrics();

    if (this.isSelected() && Game.time().since(this.lastToggled) > this.flickerDelay) {
      this.cursorVisible = !this.cursorVisible;
      this.lastToggled = Game.time().now();
    }
    if (this.isSelected() && this.cursorVisible) {
      final Rectangle2D cursor =
          new Rectangle2D.Double(
              this.getX() + this.getTextX() + fm.stringWidth(this.getTextToRender(g)),
              this.getY() + this.getTextY(),
              this.getFont().getSize2D() * 3 / 5,
              this.getFont().getSize2D() * 1 / 5);
      g.setColor(this.getAppearance().getForeColor());
      g.fill(cursor);
    }
}
}
```
```java
class de.gurkenlabs.litiengine.entities.Prop {
public Prop(
      final Point2D location, @Nullable final String spritesheetName, final Material material) {
    super();
    this.rotation = Rotation.NONE;
    this.spritesheetName = spritesheetName;
    this.material = material;
    this.setLocation(location);
    this.updateAnimationController();
}public void setSpritesheetName(@Nullable final String spriteName) {
    this.spritesheetName = spriteName;
    this.updateAnimationController();
}
}
```
```java
class de.gurkenlabs.litiengine.tweening.Tween {
public Tween begin() {
    this.started = Game.time().now();
    this.stopped = false;
    return this;
}
}
```
```java
class de.gurkenlabs.litiengine.graphics.emitters.particles.Particle {
public void update(final Point2D emitterOrigin, final float updateRatio) {
    if (this.aliveTick == 0) {
      this.aliveTick = Game.time().now();
    }

    this.aliveTime = Game.time().since(this.aliveTick);
    if (this.timeToLiveReached()) {
      return;
    }

    if (this.colliding) {
      return;
    }

    if (this.getDeltaWidth() != 0) {
      this.width += this.getDeltaWidth() * updateRatio;
    }

    if (this.getDeltaHeight() != 0) {
      this.height += this.getDeltaHeight() * updateRatio;
    }

    if (this.getDeltaAngle() != 0) {
      this.angle += this.getDeltaAngle() * updateRatio;
    }

    // test for ray cast collision
    final float targetX = this.x + this.getVelocityX() * updateRatio;
    final float targetY = this.y + this.getVelocityY() * updateRatio;

    if (targetX == this.x && targetY == this.y) {
      return;
    }

    if (this.checkForCollision(emitterOrigin, targetX, targetY)) {
      return;
    }

    if (this.getVelocityX() != 0) {
      this.x = targetX;
    }

    if (this.getVelocityY() != 0) {
      this.y = targetY;
    }

    if (this.getAccelerationX() != 0) {
      this.velocityX += this.getAccelerationX() * updateRatio;
    }

    if (this.getAccelerationY() != 0) {
      this.velocityY += this.getAccelerationY() * updateRatio;
    }
}
}
```
```java
class de.gurkenlabs.litiengine.graphics.animation.Animation {
@Override
  public void start() {
    this.playing = true;
    if (this.getKeyframes().isEmpty()) {
      return;
    }

    this.restart();
}@Override
  public void update() {
    // do nothing if the animation is not playing or the current keyframe is not finished
    if (!this.isPlaying()
        || Game.time().since(this.lastFrameUpdate) < this.getCurrentKeyFrame().getDuration()) {
      return;
    }

    // if we are not looping and the last keyframe is finished, we terminate the animation
    if (!this.isLooping() && this.isLastKeyFrame()) {
      this.terminate();
      return;
    }

    // make sure, we stay inside the keyframe list
    final int newFrameIndex =
        (this.getKeyframes().indexOf(this.currentFrame) + 1) % this.getKeyframes().size();
    final KeyFrame previousFrame = this.currentFrame;
    this.currentFrame = this.getKeyframes().get(newFrameIndex);

    for (KeyFrameListener listener : this.listeners) {
      listener.currentFrameChanged(previousFrame, this.currentFrame);
    }

    this.lastFrameUpdate = Game.loop().getTicks();
}
}
```
```java
class de.gurkenlabs.litiengine.graphics.animation.AnimationController {
@Override
  public void update() {
    for (final Animation animation : this.getAll()) {
      animation.update();
    }

    if (this.getCurrent() != null && this.getCurrent().isPaused()) {
      return;
    }

    final boolean playbackFinished = this.getCurrent() != null && !this.getCurrent().isPlaying();
    if (playbackFinished) {
      for (final AnimationListener listener : this.listeners) {
        listener.finished(this.getCurrent());
      }
    }

    if (this.getCurrent() == null || playbackFinished) {
      if (this.getDefault() != null) {
        this.play(this.getDefault().getName());
      } else {
        this.currentAnimation = null;
      }
    }
}
}
```
```java
class de.gurkenlabs.litiengine.graphics.RenderComponent {
private void handleFade() {
    if (this.fadeOutStart != -1) {
      final long timePassed = Game.time().since(this.fadeOutStart);
      this.currentAlpha = MathUtilities.clamp(1 - timePassed / (float) this.fadeOutTime, 0, 1);
      if (this.currentAlpha == 0f) {
        this.fadeOutStart = -1;
        this.fadeOutTime = -1;
      }

      return;
    }

    if (this.fadeInStart != -1) {
      final long timePassed = Game.time().since(this.fadeInStart);
      this.currentAlpha = MathUtilities.clamp(timePassed / (float) this.fadeInTime, 0, 1);
      if (this.currentAlpha == 1f) {
        this.fadeInStart = -1;
        this.fadeInTime = -1;
        this.currentAlpha = Float.NaN;
      }
    }
}public void fadeOut(final int ms) {
    this.fadeInStart = -1;
    this.fadeInTime = -1;
    this.fadeOutStart = Game.time().now();
    this.fadeOutTime = ms;
}public void fadeIn(final int ms) {
    this.fadeOutStart = -1;
    this.fadeOutTime = -1;
    this.fadeInStart = Game.time().now();
    this.fadeInTime = ms;
}
}
```
```java
class de.gurkenlabs.litiengine.entities.Trigger {
private boolean activate(final IEntity activator, final int tar) {
    if (!this.isLoaded()
        || this.isOneTimeTrigger && this.isActivated
        || this.getActivationType() == TriggerActivation.COLLISION
            && activator != null
            && this.collisionActivated.contains(activator)) {
      return false;
    }

    if (this.getCooldown() > 0 && Game.time().since(this.lastActivation) < this.getCooldown()) {
      return false;
    }

    List<Integer> triggerTargets = this.getTargets(tar);

    final TriggerEvent te = new TriggerEvent(this, activator, triggerTargets);

    if (!this.checkActivationPredicates(te)) {
      return false;
    }

    this.isActivated = true;
    if (activator != null) {
      this.collisionActivated.add(activator);
    }

    // if we actually have a trigger target, we send the message to the target
    for (final int target : triggerTargets) {
      final IEntity entity = this.getEnvironment().get(target);
      if (entity == null) {
        log.log(
            Level.WARNING,
            "trigger [{0}] was activated, but the trigger target [{1}] could not be found on the environment",
            new Object[] {this, target});
        continue;
      }

      entity.sendMessage(this, this.message);
    }

    // also send the trigger event to all registered consumers
    for (final TriggerActivatedListener listener : this.activatedListeners) {
      listener.activated(te);
    }

    if (this.isOneTimeTrigger) {
      this.getEnvironment().remove(this);
    }

    this.lastActivation = Game.time().now();
    return true;
}
}
```
```java
class de.gurkenlabs.litiengine.graphics.Camera {
private boolean isShakeEffectActive() {
    return this.getShakeTick() != 0
        && Game.time().since(this.getShakeTick()) < this.getShakeDuration();
}@Override
  public void update() {
    if (Game.world().camera() != null && !Game.world().camera().equals(this)) {
      return;
    }

    if (this.targetZoom > 0) {
      if (Game.time().since(this.zoomTick) >= this.zoomDelay) {
        this.zoom = this.targetZoom;
        this.targetZoom = 0;
        this.zoomDelay = 0;
        this.zoomTick = 0;
        this.zoomStep = 0;
      } else {
        this.zoom += this.zoomStep;
      }

      final ZoomChangedEvent event = new ZoomChangedEvent(this, this.getZoom());
      for (final ZoomChangedListener listener : this.zoomListeners) {
        listener.zoomChanged(event);
      }
    }

    if (this.panTime > 0) {
      if (--this.panTime <= 0) {
        this.setFocus(this.targetFocus);
        this.targetFocus = null;
      } else {
        double diff = this.panTime / (this.panTime + 1.0);
        this.focus =
            new Point2D.Double(
                this.focus.getX() * diff + this.targetFocus.getX() * (1.0 - diff),
                this.focus.getY() * diff + this.targetFocus.getY() * (1.0 - diff));
      }
    }

    if (!this.isShakeEffectActive()) {
      this.shakeOffsetX = 0;
      this.shakeOffsetY = 0;
      return;
    }

    if (Game.time().since(this.lastShake) > this.shakeDelay) {
      this.shakeOffsetX = this.getShakeIntensity() * ThreadLocalRandom.current().nextGaussian();
      this.shakeOffsetY = this.getShakeIntensity() * ThreadLocalRandom.current().nextGaussian();
      this.lastShake = Game.time().now();
    }
}@Override
  public void setZoom(final float targetZoom, final int delay) {
    if (delay == 0) {

      this.zoom = targetZoom;
      this.targetZoom = 0;
      this.zoomDelay = 0;
      this.zoomTick = 0;
      this.zoomStep = 0;

      final ZoomChangedEvent event = new ZoomChangedEvent(this, targetZoom);
      for (final ZoomChangedListener listener : this.zoomListeners) {
        listener.zoomChanged(event);
      }
    } else {
      this.zoomTick = Game.time().now();
      this.targetZoom = targetZoom;
      this.zoomDelay = delay;

      final double tickduration = 1000 / (double) Game.loop().getTickRate();
      final double tickAmount = delay / tickduration;
      final float totalDelta = this.targetZoom - this.zoom;
      this.zoomStep = tickAmount > 0 ? (float) (totalDelta / tickAmount) : totalDelta;
    }
}@Override
  public void shake(final double intensity, final int delay, final int shakeDuration) {
    this.shakeTick = Game.time().now();
    this.shakeDelay = delay;
    this.shakeIntensity = intensity;
    this.shakeDuration = shakeDuration;
}
}
```
```java
class de.gurkenlabs.litiengine.entities.Creature {
public void setSpritesheetName(String spritesheetName) {
    if (this.spritesheetName != null && this.spritesheetName.equals(spritesheetName)) {
      return;
    }

    this.spritesheetName = spritesheetName;
    this.updateAnimationController();
}public boolean isIdle() {
    return Game.time().since(this.lastMoved) > IDLE_DELAY;
}@Override
  public void setLocation(final Point2D position) {
    if (this.isDead() || position == null) {
      return;
    }

    final Point2D oldLocation = this.getLocation();
    super.setLocation(position);

    if (Game.hasStarted() && this.isLoaded()) {
      this.lastMoved = Game.time().now();
      this.fireMovedEvent(
          new EntityMovedEvent(
              this, this.getX() - oldLocation.getX(), this.getY() - oldLocation.getY()));
    }
}
}
```
```java
class de.gurkenlabs.litiengine.gui.screens.ScreenManager {
public void display(final String screenName) {
    if (this.current() != null && this.current().getName().equalsIgnoreCase(screenName)) {
      log.log(
          Level.INFO,
          "Skipping displaying of screen {0} because it is already the current screen.",
          screenName);
      return;
    }

    if (this.screens.stream()
        .noneMatch(element -> element.getName().equalsIgnoreCase(screenName))) {
      log.log(
          Level.WARNING,
          "Could not display the screen {0} because there is no screen with the specified name.",
          screenName);
      return;
    }

    Screen screen = this.get(screenName);
    if (screen == null) {
      return;
    }

    this.display(screen);
}public void add(final Screen screen) {
    screen.setWidth(Game.window().getWidth());
    screen.setHeight(Game.window().getHeight());
    this.screens.add(screen);

    if (this.current() == null) {
      this.display(screen);
    }
}public void remove(Screen screen) {
    this.screens.remove(screen);
    if (this.current() == screen) {
      if (!this.screens.isEmpty()) {
        this.display(this.screens.get(0));
      } else {
        this.display((Screen) null);
      }
    }
}public void display(@Nullable final Screen screen) {
    if (Game.hasStarted() && Game.time().since(this.lastScreenChange) < this.getChangeCooldown()) {
      log.log(
          Level.INFO,
          "Skipping displaying of screen {0} because screen changing is currently on cooldown.",
          screen != null ? screen.getName() : "");
      return;
    }

    final Screen previous = this.current();
    if (previous != null) {
      previous.suspend();
    }

    if (screen != null && !this.screens.contains(screen)) {
      this.screens.add(screen);
    }

    this.currentScreen = screen;
    if (!Game.isInNoGUIMode() && this.current() != null) {
      this.current().prepare();
    }

    this.lastScreenChange = Game.loop().getTicks();

    final ScreenChangedEvent event = new ScreenChangedEvent(this.current(), previous);
    for (final ScreenChangedListener listener : this.screenChangedListeners) {
      listener.changed(event);
    }
}
}
```
```java
class de.gurkenlabs.litiengine.abilities.Ability {
public boolean isOnCooldown() {
    return (this.getCurrentExecution() != null
        && this.getCurrentExecution().getExecutionTicks() > 0
        && Game.time().since(this.getCurrentExecution().getExecutionTicks())
            < this.getAttributes().cooldown().get());
}public boolean isActive() {
    return this.getCurrentExecution() != null
        && Game.time().since(this.getCurrentExecution().getExecutionTicks())
            < this.getAttributes().duration().get();
}@Nullable
  public AbilityExecution cast() {
    if (!this.canCast()) {
      return null;
    }
    this.currentExecution = new AbilityExecution(this);

    for (final AbilityCastListener listener : this.abilityCastListeners) {
      listener.abilityCast(this.currentExecution);
    }

    return this.getCurrentExecution();
}public float getRemainingCooldownInSeconds() {
    if (this.getCurrentExecution() == null
        || this.getExecutor() == null
        || this.getExecutor().isDead()) {
      return 0;
    }

    // calculate cooldown in seconds
    return (float)
        (!this.canCast()
            ? (this.getAttributes().cooldown().get()
                    - Game.time().since(this.getCurrentExecution().getExecutionTicks()))
                * 0.001
            : 0);
}
}
```
```java
class de.gurkenlabs.litiengine.entities.EntityHitEvent {
EntityHitEvent(
      final ICombatEntity hitEntity,
      @Nullable final Ability ability,
      final int damage,
      final boolean kill) {
    super(hitEntity);
    this.executor = ability != null ? ability.getExecutor() : null;
    this.hitEntity = hitEntity;
    this.ability = ability;
    this.damage = damage;
    this.kill = kill;
    this.time = Game.time().now();
}
}
```
```java
class de.gurkenlabs.litiengine.graphics.emitters.Emitter {
public void delete() {
    this.deactivate();
    if (Game.world().environment() != null) {
      Game.world().environment().remove(this);
    }
}public void activate() {
    if (this.activated) {
      return;
    }

    this.activated = true;
    this.activationTick = Game.time().now();
    Game.loop().attach(this);
}@Override
  public void update() {
    if (this.isPaused()) {
      return;
    }

    // clear particles if the effect time to life is reached
    if (this.isFinished()) {
      for (EmitterFinishedListener listener : this.finishedListeners) {
        listener.finished(this);
      }

      this.delete();
      return;
    }

    final float updateRatio = (float) this.data().getUpdateRate() / Game.loop().getTickRate();
    for (final Particle p : this.getParticles().stream().collect(Collectors.toList())) {
      if (this.particleCanBeRemoved(p)) {
        // remove dead particles
        this.particles.remove(p);
        continue;
      }

      p.update(this.getOrigin(), updateRatio);
    }

    this.aliveTime = Game.time().since(this.activationTick);
    if ((this.data().getSpawnRate() == 0
        || Game.time().since(this.lastSpawn) >= this.data().getSpawnRate())) {
      this.lastSpawn = Game.time().now();
      this.spawnParticle();
    }
}
}
```
```java
class de.gurkenlabs.litiengine.GameLoop {
@Override
  public int perform(int delay, Runnable action) {
    final long d = Game.time().toTicks(delay);

    TimedAction a = new TimedAction(this.getTicks() + d, action);
    this.actions.add(a);

    return a.getId();
}
}
```
```java
class de.gurkenlabs.litiengine.environment.EntitySpawner {
protected boolean shouldSpawn() {
    return this.lastSpawnWave == 0
        || Game.time().since(this.lastSpawnWave) >= this.getSpawnInterval();
}@Override
  public void update() {
    if (!this.shouldSpawn()) {
      return;
    }

    this.spawnNewEntities();
    this.lastSpawnWave = Game.time().now();
}
}
```
```java
class de.gurkenlabs.litiengine.graphics.FreeFlightCamera {
@Override
  public void update() {
    this.handleFreeFlightCamera();
}public FreeFlightCamera(double x, double y) {
    this(new Point2D.Double(x, y));
}
}
```
```java
class de.gurkenlabs.litiengine.environment.Environment {
public void unload() {
    if (!this.loaded) {
      return;
    }

    // unregister all updatable entities from the current environment
    for (final IEntity entity : this.allEntities.values()) {
      this.unload(entity);
    }

    this.loaded = false;
    this.fireEvent(l -> l.unloaded(this));
}private static void loadUpdatableOrEmitterEntity(IEntity entity) {
    if (entity instanceof Emitter) {
      final Emitter emitter = (Emitter) entity;
      if (emitter.isActivateOnInit()) {
        emitter.activate();
      }
    } else if (entity instanceof IUpdateable) {
      Game.loop().attach((IUpdateable) entity);
    }
}public void clear() {
    Game.physics().clear();

    this.combatEntities.clear();
    this.mobileEntities.clear();
    this.gravityForces.clear();
    this.layerEntities.clear();
    this.entitiesByTag.clear();
    this.allEntities.clear();

    for (RenderType renderType : RenderType.values()) {
      this.miscEntities.get(renderType).clear();
      this.renderListeners.get(renderType).clear();
      this.renderables.get(renderType).clear();
    }

    dispose(this.allEntities.values());
    dispose(this.triggers);
    this.emitters.clear();
    this.colliders.clear();
    this.props.clear();
    this.creatures.clear();
    this.staticShadows.clear();
    this.combatEntities.clear();
    this.mobileEntities.clear();
    this.lightSources.clear();
    this.spawnPoints.clear();
    this.soundSources.clear();
    this.mapAreas.clear();
    this.triggers.clear();

    this.ambientLight = null;
    this.staticShadowLayer = null;

    for (Map<Integer, IEntity> type : this.miscEntities.values()) {
      type.clear();
    }

    this.initialized = false;

    this.fireEvent(l -> l.cleared(this));
}private void load(final IEntity entity) {
    // an entity can only exist on one environment at a time, so remove it from the current one
    if (entity.getEnvironment() != null) {
      entity.getEnvironment().remove(entity);
    }

    // 1. add to physics engine
    loadPhysicsEntity(entity);

    // 2. register for update or activate
    loadUpdatableOrEmitterEntity(entity);

    // 3. if a gravity is defined, add a gravity force to the entity
    if (entity instanceof IMobileEntity && this.getGravity() != 0) {
      this.addGravityForce((IMobileEntity) entity);
    }

    // 4. attach all controllers
    entity.attachControllers();

    if (this.loaded && (entity instanceof LightSource || entity instanceof StaticShadow)) {
      this.updateLighting(entity);
    }

    entity.loaded(this);
}private void unload(final IEntity entity) {
    // 1. remove from physics engine
    if (entity instanceof ICollisionEntity) {
      Game.physics().remove((ICollisionEntity) entity);
    }

    // 2. unregister from update
    if (entity instanceof IUpdateable) {
      Game.loop().detach((IUpdateable) entity);
    }

    if (entity instanceof IMobileEntity) {
      this.removeGravity((IMobileEntity) entity);
    }

    // 3. detach all controllers
    entity.detachControllers();

    if (entity instanceof Emitter) {
      Emitter em = (Emitter) entity;
      em.deactivate();
    }

    if (this.loaded && (entity instanceof LightSource || entity instanceof StaticShadow)) {
      this.updateLighting(entity);
    }

    entity.removed(this);
}public void remove(final IEntity entity) {
    if (entity == null) {
      return;
    }

    this.allEntities.remove(entity.getMapId());
    Iterator<List<IEntity>> iter = this.layerEntities.values().iterator();
    while (iter.hasNext()) {
      List<IEntity> layer = iter.next();
      if (layer.remove(entity) && layer.isEmpty()) {
        iter.remove();
      }
    }
    if (this.miscEntities.get(entity.getRenderType()) != null) {
      this.miscEntities.get(entity.getRenderType()).values().remove(entity);
    }

    for (String tag : entity.getTags()) {
      if (this.getEntitiesByTag().containsKey(tag)) {
        this.getEntitiesByTag().get(tag).remove(entity);

        if (this.getEntitiesByTag().get(tag).isEmpty()) {
          this.getEntitiesByTag().remove(tag);
        }
      }
    }

    if (entity instanceof Emitter) {
      Emitter emitter = (Emitter) entity;
      this.removeEmitter(emitter);
    }

    if (entity instanceof MapArea) {
      this.mapAreas.remove(entity);
    }

    if (entity instanceof Prop) {
      this.props.remove(entity);
    }

    if (entity instanceof Creature) {
      this.creatures.remove(entity);
    }

    if (entity instanceof CollisionBox) {
      this.colliders.remove(entity);
      this.staticShadows.removeIf(x -> x.getOrigin() != null && x.getOrigin().equals(entity));
    }

    if (entity instanceof LightSource) {
      this.lightSources.remove(entity);
      this.updateLighting(entity);
    }

    if (entity instanceof Trigger) {
      this.triggers.remove(entity);
    }

    if (entity instanceof Spawnpoint) {
      this.spawnPoints.remove(entity);
    }
    if (entity instanceof SoundSource) {
      this.soundSources.remove(entity);
    }

    if (entity instanceof StaticShadow) {
      this.staticShadows.remove(entity);
      this.updateLighting(entity);
    }

    if (entity instanceof IMobileEntity) {
      this.mobileEntities.values().remove(entity);
    }

    if (entity instanceof ICombatEntity) {
      this.combatEntities.values().remove(entity);
    }

    this.unload(entity);

    this.fireEntityEvent(l -> l.entityRemoved(entity));
}
}
```
```java
class de.gurkenlabs.litiengine.physics.MovementController {
@Override
  public void update() {
    this.handleForces();
    this.handleMovement();
}
}
```
```java
class de.gurkenlabs.litiengine.Game {
static synchronized void terminate() {
    if (!initialized) {
      return;
    }

    hasStarted = false;
    initialized = false;

    config().save();
    gameLoop.terminate();
    tweenEngine.terminate();
    soundEngine.terminate();

    world().clear();

    for (final GameListener listener : gameListeners) {
      try {
        listener.terminated();
      } catch (Exception e) {
        log().log(Level.WARNING, "game listener threw an exception during shutdown", e);
      }
    }

    gameLoop = null;
    screenManager = null;
    gameWindow = null;
}public static synchronized void start() {
    if (!initialized) {
      throw new IllegalStateException(
          "The game cannot be started without being first initialized. Call Game.init(...) before Game.start().");
    }

    gameLoop.start();
    tweenEngine.start();
    soundEngine.start();

    for (final GameListener listener : gameListeners) {
      listener.started();
    }

    hasStarted = true;
}public static synchronized void init(String... args) {
    if (initialized) {
      log().log(Level.INFO, "The game has already been initialized.");
      return;
    }

    log.init();
    handleCommandLineArguments(args);

    config().load();
    Locale.setDefault(new Locale(config().client().getCountry(), config().client().getLanguage()));

    gameLoop = new GameLoop("Main Update Loop", config().client().getMaxFps());
    loop().attach(physics());
    loop().attach(world());

    // setup default exception handling for render and update loop
    setUncaughtExceptionHandler(
        new DefaultUncaughtExceptionHandler(config().client().exitOnError()));

    screenManager = new ScreenManager();
    gameWindow = new GameWindow();

    // initialize  the game window
    window().init();
    world.setCamera(new Camera());

    for (GameListener listener : gameListeners) {
      listener.initialized(args);
    }

    if (!isInNoGUIMode()) {
      window().getRenderComponent().onRendered(g -> metrics().render(g));

      graphics()
          .addEntityRenderedListener(
              e -> DebugRenderer.renderEntityDebugInfo(e.getGraphics(), e.getEntity()));

      window().getRenderComponent().onFpsChanged(fps -> metrics().setFramesPerSecond(fps));
      window()
          .setIcons(
              Arrays.asList(
                  Resources.images().get("liti-logo-x16.png"),
                  Resources.images().get("liti-logo-x20.png"),
                  Resources.images().get("liti-logo-x32.png"),
                  Resources.images().get("liti-logo-x48.png")));

      Input.keyboard()
          .onKeyTyped(
              KeyEvent.VK_PRINTSCREEN,
              key -> {
                // don't take a screenshot if a modifier is active
                if (key.getModifiers() != 0) {
                  return;
                }

                window().getRenderComponent().takeScreenshot();
              });
    }

    Runtime.getRuntime().addShutdownHook(new Thread(Game::terminate, "Shutdown"));

    initialized = true;
}
}
```


Response Format:
Provide the answer in **XML format** as follows:

#### If the method **cannot** return `null` at the specific call site:
```xml
<response>
  <reason><![CDATA[EXPLAIN WHY THE INVOCATION Game.loop() RESULT CANNOT BE NULL.]]></reason>
  <value>NO</value>
</response>

#### If the method can return null at the specific call site:
<response>
  <reason><![CDATA[EXPLAIN WHY THE INVOCATION Game.loop() RESULT CAN BE NULL.]]></reason>
  <value>YES</value>
</response>

#### If you are unsure or If there are any methods that directly or indirectly affect the return value and are not fully disclosed, request their declarations first, in the following format:
<response>
  <reason><![CDATA[EXPLAIN WHY THIS METHOD DECLARATION IS NECESSARY AND WHY YOU CANNOT MAKE A CONFIDENT DECISION WITHOUT IT]]></reason>
  <success>false</success>
  <methods>
    <method>methodName</method>
  </methods>
</response>

Additional Notes:
Be precise in your reasoning.
If a method’s return value depends on another method not provided, request its declaration before making a conclusion.
If the method can return null in this case but not in others, explain why it happens specifically for this call.

---ChatGPT.sendRequestToOpenAI---
Retrieving response from cache
---Response.<init>---
Creating Response:
```xml
<response>
  <reason><![CDATA[The method `Game.loop()` returns the static field `gameLoop`, which is initialized in the `Game.init(String... args)` method. In this method, a new `GameLoop` object is instantiated and assigned to `gameLoop`. Since `init()` must be called before `start()`, which is implied by the requirement of initializing the game, the `gameLoop` is guaranteed to be non-null during the lifetime of the game execution where `Game.loop()` is called. The absence of any code that could set `gameLoop` to null after its initialization ensures that `Game.loop()` cannot return null.]]></reason>
  <value>NO</value>
</response>
```
---Response.<init>---
Response created:
Disagreement: The method `Game.loop()` returns the static field `gameLoop`, which is initialized in the `Game.init(String... args)` method. In this method, a new `GameLoop` object is instantiated and assigned to `gameLoop`. Since `init()` must be called before `start()`, which is implied by the requirement of initializing the game, the `gameLoop` is guaranteed to be non-null during the lifetime of the game execution where `Game.loop()` is called. The absence of any code that could set `gameLoop` to null after its initialization ensures that `Game.loop()` cannot return null.
---AdvancedNullAwayCodeFix.resolveMethodDereferenceError---
Method is not returning nullable on call site. Injecting suppression annotation.
---AdvancedNullAwayCodeFix.constructCastToNonnullChange---
Constructing cast to nonnull change for reason: The method `Game.loop()` returns the static field `gameLoop`, which is initialized in the `Game.init(String... args)` method. In this method, a new `GameLoop` object is instantiated and assigned to `gameLoop`. Since `init()` must be called before `start()`, which is implied by the requirement of initializing the game, the `gameLoop` is guaranteed to be non-null during the lifetime of the game execution where `Game.loop()` is called. The absence of any code that could set `gameLoop` to null after its initialization ensures that `Game.loop()` cannot return null.
---ChatGPT.ask---
Asking ChatGPT:
For the reason you mentioned earlier:

"The method `Game.loop()` returns the static field `gameLoop`, which is initialized in the `Game.init(String... args)` method. In this method, a new `GameLoop` object is instantiated and assigned to `gameLoop`. Since `init()` must be called before `start()`, which is implied by the requirement of initializing the game, the `gameLoop` is guaranteed to be non-null during the lifetime of the game execution where `Game.loop()` is called. The absence of any code that could set `gameLoop` to null after its initialization ensures that `Game.loop()` cannot return null."

in the method below, the expression Game.loop() is not nullable at the point it is used.

```java
public long toTicks(final int milliseconds) {
    return this.toTicks(milliseconds, Game.loop().getTickRate());
}
```
Please Summarize the reason in max 5 words and rewrite the method so that at the line "    return this.toTicks(milliseconds, Game.loop().getTickRate());", at the occurrence of: "Game.loop()" is replaced with `NullabilityUtil.castToNonnull(Game.loop(), summary of reason)`
Replace "REASON" with the exact reason summary I provide to you (maximum 5 words), not with a generic explanation like "checked to be nonnull".
see the example below, for expression `foo.getBar()`, to wrap it with `NullabilityUtil.castToNonnull(foo.getBar(), "reason")`.

```java
public t(){
    String l = foo.getBar();
}
```

will be:
```java
public t(){
    String l = NullabilityUtil.castToNonnull(foo.getBar(), "checked to be nonnull");
}
```

### Instructions:

Do not import any additional classes.

Do not add Java comments.

Only modify relevant lines as required.

Return only the modified method wrapped in the XML format shown below.

Place the Java code inside the <code> tag using a CDATA block with ```java formatting.

Just give me the fixed code snippet in XML format in <response> tag like the example below. I will apply the fix to my codebase. Do not import any additional libraries or classes or add java comments. If you can provide the fixed code snippet, please provide it in the following format and place the code snippet in the <code> tag within ```java block.
<response>
  <success>true</success>
  <code><![CDATA[
  ```java
  Your fixed code snippet here
  ```
    ]]>
  </code>
</response>

---ChatGPT.sendRequestToOpenAI---
Sending request to OpenAI...
---ChatGPT.sendRequestToOpenAI---
Response received from OpenAI.
---Response.<init>---
Creating Response:
<response>
  <success>true</success>
  <code><![CDATA[
  ```java
public long toTicks(final int milliseconds) {
    return this.toTicks(milliseconds, NullabilityUtil.castToNonnull(Game.loop(), "initialized before use").getTickRate());
}
  ```
    ]]>
  </code>
</response>
---Response.<init>---
Response created:
public long toTicks(final int milliseconds) {
    return this.toTicks(milliseconds, NullabilityUtil.castToNonnull(Game.loop(), "initialized before use").getTickRate());
}
---ChatGPT.fixDereferenceByAddingCastToNonnull---
Fixing the error by adding castToNonnull
---AdvancedNullAwayCodeFix.lambda$resolveUninitializedField$2---
Working on triggered error: Type='DEREFERENCE_NULLABLE', message='dereferenced expression gameLoop is @Nullable'
/home/nima/Developer/nullness-benchmarks/litiengine/src/de/gurkenlabs/litiengine/Game.java:623
    gameLoop.terminate();
---AdvancedNullAwayCodeFix.fix---
Fixing error: Type='DEREFERENCE_NULLABLE', message='dereferenced expression gameLoop is @Nullable'
/home/nima/Developer/nullness-benchmarks/litiengine/src/de/gurkenlabs/litiengine/Game.java:623
    gameLoop.terminate();
---AdvancedNullAwayCodeFix.resolveDereferenceError---
Resolving dereference error: Type='DEREFERENCE_NULLABLE', message='dereferenced expression gameLoop is @Nullable'
/home/nima/Developer/nullness-benchmarks/litiengine/src/de/gurkenlabs/litiengine/Game.java:623
    gameLoop.terminate();
---AdvancedNullAwayCodeFix.resolveDereferenceError---
Checking nullability possibility at error point
---ChatGPT.checkNullabilityPossibilityAtErrorPoint---
Asking if the expression can be null at error point point
---ChatGPT.ask---
Asking ChatGPT:
In the method below, is there a possibility that the expression "gameLoop" at line "gameLoop.terminate();" is null?
static synchronized void terminate() {
    if (!initialized) {
      return;
    }

    hasStarted = false;
    initialized = false;

    config().save();
    gameLoop.terminate();
    tweenEngine.terminate();
    soundEngine.terminate();

    world().clear();

    for (final GameListener listener : gameListeners) {
      try {
        listener.terminated();
      } catch (Exception e) {
        log().log(Level.WARNING, "game listener threw an exception during shutdown", e);
      }
    }

    gameLoop = null;
    screenManager = null;
    gameWindow = null;
}
Give a single-word answer in XML format. If it is possible for the expression to be null, respond with:
```xml
<response>
    <reason><![CDATA[YOUR REASON]]></reason>
    <value>YES</value>
</response>
```
If it is not possible for the expression to be null, respond with:
```xml
<response>
    <reason><![CDATA[YOUR REASON]]></reason>
    <value>NO</value>
</response>
```
If you are unsure or need more information, respond with where you can ask for more details or what specific information you need.

If additional information is required, list each request inside a `<request>` tag. If no additional information is needed, omit the `<requests>` section.

Respond with:
```xml
<response>
    <reason><![CDATA[YOUR REASON]]></reason>
    <value>UNKNOWN</value>
    <!-- Include <requests> only if additional information is needed -->
    <requests>
        <request><![CDATA[YOUR REQUEST 1]]></request>
        <request><![CDATA[YOUR REQUEST 2]]></request>
    </requests>
</response>
```
---ChatGPT.sendRequestToOpenAI---
Retrieving response from cache
---Response.<init>---
Creating Response:
```xml
<response>
    <reason><![CDATA[The code snippet does not show any condition or assignment that ensures gameLoop is non-null before calling gameLoop.terminate(). Without additional context or guarantees from other parts of the code, it's possible that gameLoop could be null.]]></reason>
    <value>YES</value>
</response>
```
---Response.<init>---
Response created:
Agreement: The code snippet does not show any condition or assignment that ensures gameLoop is non-null before calling gameLoop.terminate(). Without additional context or guarantees from other parts of the code, it's possible that gameLoop could be null.
---AdvancedNullAwayCodeFix.investigateFieldNullability---
Investigating field nullability.
---AdvancedNullAwayCodeFix.investigateFieldNullability---
Checking if there is any method initializing field: gameLoop
---AdvancedNullAwayCodeFix.resolveFieldNullabilityError---
Trying to fix errors for making the field nullable
---AdvancedNullAwayCodeFix.fixErrorByRegions---
Fixing error by regions.
---AdvancedNullAwayCodeFix.fixErrorByRegions---
Safe regions: 3 - Unsafe regions: 4
---ChatGPT.fixDereferenceErrorBySafeRegions---
Attempting to fix dereference error by using safe regions
---ChatGPT.fixDereferenceErrorBySafeRegions---
Asking if the error can be fixed by using safe regions
---ChatGPT.ask---
Asking ChatGPT:
I want to resolve a warning reported by NullAway.
I am getting the error that in line:     gameLoop.terminate();, the dereferenced expression gameLoop is @Nullable and can produce Null Pointer Exception. In the method below:
static synchronized void terminate() {
    if (!initialized) {
      return;
    }

    hasStarted = false;
    initialized = false;

    config().save();
    gameLoop.terminate();
    tweenEngine.terminate();
    soundEngine.terminate();

    world().clear();

    for (final GameListener listener : gameListeners) {
      try {
        listener.terminated();
      } catch (Exception e) {
        log().log(Level.WARNING, "game listener threw an exception during shutdown", e);
      }
    }

    gameLoop = null;
    screenManager = null;
    gameWindow = null;
}
I am going to show you a couple of other examples in my codebase where the dereferenced expression is used in a way that cannot produce Null Pointer Exception.
Here are the examples(s):
private Game() {
    throw new UnsupportedOperationException();
}
public static synchronized void init(String... args) {
    if (initialized) {
      log().log(Level.INFO, "The game has already been initialized.");
      return;
    }

    log.init();
    handleCommandLineArguments(args);

    config().load();
    Locale.setDefault(new Locale(config().client().getCountry(), config().client().getLanguage()));

    gameLoop = new GameLoop("Main Update Loop", config().client().getMaxFps());
    loop().attach(physics());
    loop().attach(world());

    // setup default exception handling for render and update loop
    setUncaughtExceptionHandler(
        new DefaultUncaughtExceptionHandler(config().client().exitOnError()));

    screenManager = new ScreenManager();
    gameWindow = new GameWindow();

    // initialize  the game window
    window().init();
    world.setCamera(new Camera());

    for (GameListener listener : gameListeners) {
      listener.initialized(args);
    }

    if (!isInNoGUIMode()) {
      window().getRenderComponent().onRendered(g -> metrics().render(g));

      graphics()
          .addEntityRenderedListener(
              e -> DebugRenderer.renderEntityDebugInfo(e.getGraphics(), e.getEntity()));

      window().getRenderComponent().onFpsChanged(fps -> metrics().setFramesPerSecond(fps));
      window()
          .setIcons(
              Arrays.asList(
                  Resources.images().get("liti-logo-x16.png"),
                  Resources.images().get("liti-logo-x20.png"),
                  Resources.images().get("liti-logo-x32.png"),
                  Resources.images().get("liti-logo-x48.png")));

      Input.keyboard()
          .onKeyTyped(
              KeyEvent.VK_PRINTSCREEN,
              key -> {
                // don't take a screenshot if a modifier is active
                if (key.getModifiers() != 0) {
                  return;
                }

                window().getRenderComponent().takeScreenshot();
              });
    }

    Runtime.getRuntime().addShutdownHook(new Thread(Game::terminate, "Shutdown"));

    initialized = true;
}
Given the examples above, I want you to fix the error in the original method by using the same pattern as in the examples.
If you can fix the error, please provide the fixed code snippet in XML format. I just need the XML response, no other information is needed. If you can provide the fixed code snippet, please provide it in the following format and place the code snippet in the <code> tag within ```java block.
For example,
<response>
  <success>true</success>
  <code>
  <![CDATA[
  ```java
  Your fixed code snippet here, JUST THE METHOD.
  ```
    ]]>
  </code>
</response>
Or if you cannot fix the error, please provide the reason in XML format.
<response>
  <success>false</success>
</response>

---ChatGPT.sendRequestToOpenAI---
Retrieving response from cache
---Response.<init>---
Creating Response:
```xml
<response>
  <success>true</success>
  <code>
  <![CDATA[
  ```java
  static synchronized void terminate() {
      if (!initialized || gameLoop == null) {
        return;
      }
  
      hasStarted = false;
      initialized = false;
  
      config().save();
      gameLoop.terminate();
      tweenEngine.terminate();
      soundEngine.terminate();
  
      world().clear();
  
      for (final GameListener listener : gameListeners) {
        try {
          listener.terminated();
        } catch (Exception e) {
          log().log(Level.WARNING, "game listener threw an exception during shutdown", e);
        }
      }
  
      gameLoop = null;
      screenManager = null;
      gameWindow = null;
  }
  ```
  ]]>
  </code>
</response>
```
---Response.<init>---
Response created:
static synchronized void terminate() {
      if (!initialized || gameLoop == null) {
        return;
      }
  
      hasStarted = false;
      initialized = false;
  
      config().save();
      gameLoop.terminate();
      tweenEngine.terminate();
      soundEngine.terminate();
  
      world().clear();
  
      for (final GameListener listener : gameListeners) {
        try {
          listener.terminated();
        } catch (Exception e) {
          log().log(Level.WARNING, "game listener threw an exception during shutdown", e);
        }
      }
  
      gameLoop = null;
      screenManager = null;
      gameWindow = null;
  }
---ChatGPT.fixDereferenceErrorBySafeRegions---
Fixing the error by using safe regions with code:
static synchronized void terminate() {
      if (!initialized || gameLoop == null) {
        return;
      }
  
      hasStarted = false;
      initialized = false;
  
      config().save();
      gameLoop.terminate();
      tweenEngine.terminate();
      soundEngine.terminate();
  
      world().clear();
  
      for (final GameListener listener : gameListeners) {
        try {
          listener.terminated();
        } catch (Exception e) {
          log().log(Level.WARNING, "game listener threw an exception during shutdown", e);
        }
      }
  
      gameLoop = null;
      screenManager = null;
      gameWindow = null;
  }
---AdvancedNullAwayCodeFix.fixErrorByRegions---
Successfully generated a fix for the error.
---AdvancedNullAwayCodeFix.fixErrorByRegions---
Fixing error by regions.
---AdvancedNullAwayCodeFix.fixErrorByRegions---
Safe regions: 3 - Unsafe regions: 4
---ChatGPT.fixDereferenceErrorBySafeRegions---
Attempting to fix dereference error by using safe regions
---ChatGPT.fixDereferenceErrorBySafeRegions---
Asking if the error can be fixed by using safe regions
---ChatGPT.ask---
Asking ChatGPT:
I want to resolve a warning reported by NullAway.
I am getting the error that in line:     gameLoop.setUncaughtExceptionHandler(uncaughtExceptionHandler);, the dereferenced expression gameLoop is @Nullable and can produce Null Pointer Exception. In the method below:
public static void setUncaughtExceptionHandler(
      UncaughtExceptionHandler uncaughtExceptionHandler) {
    gameLoop.setUncaughtExceptionHandler(uncaughtExceptionHandler);
    Thread.setDefaultUncaughtExceptionHandler(uncaughtExceptionHandler);
}
I am going to show you a couple of other examples in my codebase where the dereferenced expression is used in a way that cannot produce Null Pointer Exception.
Here are the examples(s):
private Game() {
    throw new UnsupportedOperationException();
}
public static synchronized void init(String... args) {
    if (initialized) {
      log().log(Level.INFO, "The game has already been initialized.");
      return;
    }

    log.init();
    handleCommandLineArguments(args);

    config().load();
    Locale.setDefault(new Locale(config().client().getCountry(), config().client().getLanguage()));

    gameLoop = new GameLoop("Main Update Loop", config().client().getMaxFps());
    loop().attach(physics());
    loop().attach(world());

    // setup default exception handling for render and update loop
    setUncaughtExceptionHandler(
        new DefaultUncaughtExceptionHandler(config().client().exitOnError()));

    screenManager = new ScreenManager();
    gameWindow = new GameWindow();

    // initialize  the game window
    window().init();
    world.setCamera(new Camera());

    for (GameListener listener : gameListeners) {
      listener.initialized(args);
    }

    if (!isInNoGUIMode()) {
      window().getRenderComponent().onRendered(g -> metrics().render(g));

      graphics()
          .addEntityRenderedListener(
              e -> DebugRenderer.renderEntityDebugInfo(e.getGraphics(), e.getEntity()));

      window().getRenderComponent().onFpsChanged(fps -> metrics().setFramesPerSecond(fps));
      window()
          .setIcons(
              Arrays.asList(
                  Resources.images().get("liti-logo-x16.png"),
                  Resources.images().get("liti-logo-x20.png"),
                  Resources.images().get("liti-logo-x32.png"),
                  Resources.images().get("liti-logo-x48.png")));

      Input.keyboard()
          .onKeyTyped(
              KeyEvent.VK_PRINTSCREEN,
              key -> {
                // don't take a screenshot if a modifier is active
                if (key.getModifiers() != 0) {
                  return;
                }

                window().getRenderComponent().takeScreenshot();
              });
    }

    Runtime.getRuntime().addShutdownHook(new Thread(Game::terminate, "Shutdown"));

    initialized = true;
}
Given the examples above, I want you to fix the error in the original method by using the same pattern as in the examples.
If you can fix the error, please provide the fixed code snippet in XML format. I just need the XML response, no other information is needed. If you can provide the fixed code snippet, please provide it in the following format and place the code snippet in the <code> tag within ```java block.
For example,
<response>
  <success>true</success>
  <code>
  <![CDATA[
  ```java
  Your fixed code snippet here, JUST THE METHOD.
  ```
    ]]>
  </code>
</response>
Or if you cannot fix the error, please provide the reason in XML format.
<response>
  <success>false</success>
</response>

---ChatGPT.sendRequestToOpenAI---
Retrieving response from cache
---Response.<init>---
Creating Response:
```xml
<response>
  <success>true</success>
  <code>
  <![CDATA[
  ```java
  public static synchronized void setUncaughtExceptionHandler(
      UncaughtExceptionHandler uncaughtExceptionHandler) {
    if (gameLoop != null) {
      gameLoop.setUncaughtExceptionHandler(uncaughtExceptionHandler);
    }
    Thread.setDefaultUncaughtExceptionHandler(uncaughtExceptionHandler);
  }
  ```
  ]]>
  </code>
</response>
```
---Response.<init>---
Response created:
public static synchronized void setUncaughtExceptionHandler(
      UncaughtExceptionHandler uncaughtExceptionHandler) {
    if (gameLoop != null) {
      gameLoop.setUncaughtExceptionHandler(uncaughtExceptionHandler);
    }
    Thread.setDefaultUncaughtExceptionHandler(uncaughtExceptionHandler);
  }
---ChatGPT.fixDereferenceErrorBySafeRegions---
Fixing the error by using safe regions with code:
public static synchronized void setUncaughtExceptionHandler(
      UncaughtExceptionHandler uncaughtExceptionHandler) {
    if (gameLoop != null) {
      gameLoop.setUncaughtExceptionHandler(uncaughtExceptionHandler);
    }
    Thread.setDefaultUncaughtExceptionHandler(uncaughtExceptionHandler);
  }
---AdvancedNullAwayCodeFix.fixErrorByRegions---
Successfully generated a fix for the error.
---AdvancedNullAwayCodeFix.fixErrorByRegions---
Fixing error by regions.
---AdvancedNullAwayCodeFix.fixErrorByRegions---
Safe regions: 3 - Unsafe regions: 4
---ChatGPT.fixDereferenceErrorBySafeRegions---
Attempting to fix dereference error by using safe regions
---ChatGPT.fixDereferenceErrorBySafeRegions---
Asking if the error can be fixed by using safe regions
---ChatGPT.ask---
Asking ChatGPT:
I want to resolve a warning reported by NullAway.
I am getting the error that in line:     gameLoop.start();, the dereferenced expression gameLoop is @Nullable and can produce Null Pointer Exception. In the method below:
public static synchronized void start() {
    if (!initialized) {
      throw new IllegalStateException(
          "The game cannot be started without being first initialized. Call Game.init(...) before Game.start().");
    }

    gameLoop.start();
    tweenEngine.start();
    soundEngine.start();

    for (final GameListener listener : gameListeners) {
      listener.started();
    }

    hasStarted = true;
}
I am going to show you a couple of other examples in my codebase where the dereferenced expression is used in a way that cannot produce Null Pointer Exception.
Here are the examples(s):
private Game() {
    throw new UnsupportedOperationException();
}
public static synchronized void init(String... args) {
    if (initialized) {
      log().log(Level.INFO, "The game has already been initialized.");
      return;
    }

    log.init();
    handleCommandLineArguments(args);

    config().load();
    Locale.setDefault(new Locale(config().client().getCountry(), config().client().getLanguage()));

    gameLoop = new GameLoop("Main Update Loop", config().client().getMaxFps());
    loop().attach(physics());
    loop().attach(world());

    // setup default exception handling for render and update loop
    setUncaughtExceptionHandler(
        new DefaultUncaughtExceptionHandler(config().client().exitOnError()));

    screenManager = new ScreenManager();
    gameWindow = new GameWindow();

    // initialize  the game window
    window().init();
    world.setCamera(new Camera());

    for (GameListener listener : gameListeners) {
      listener.initialized(args);
    }

    if (!isInNoGUIMode()) {
      window().getRenderComponent().onRendered(g -> metrics().render(g));

      graphics()
          .addEntityRenderedListener(
              e -> DebugRenderer.renderEntityDebugInfo(e.getGraphics(), e.getEntity()));

      window().getRenderComponent().onFpsChanged(fps -> metrics().setFramesPerSecond(fps));
      window()
          .setIcons(
              Arrays.asList(
                  Resources.images().get("liti-logo-x16.png"),
                  Resources.images().get("liti-logo-x20.png"),
                  Resources.images().get("liti-logo-x32.png"),
                  Resources.images().get("liti-logo-x48.png")));

      Input.keyboard()
          .onKeyTyped(
              KeyEvent.VK_PRINTSCREEN,
              key -> {
                // don't take a screenshot if a modifier is active
                if (key.getModifiers() != 0) {
                  return;
                }

                window().getRenderComponent().takeScreenshot();
              });
    }

    Runtime.getRuntime().addShutdownHook(new Thread(Game::terminate, "Shutdown"));

    initialized = true;
}
Given the examples above, I want you to fix the error in the original method by using the same pattern as in the examples.
If you can fix the error, please provide the fixed code snippet in XML format. I just need the XML response, no other information is needed. If you can provide the fixed code snippet, please provide it in the following format and place the code snippet in the <code> tag within ```java block.
For example,
<response>
  <success>true</success>
  <code>
  <![CDATA[
  ```java
  Your fixed code snippet here, JUST THE METHOD.
  ```
    ]]>
  </code>
</response>
Or if you cannot fix the error, please provide the reason in XML format.
<response>
  <success>false</success>
</response>

---ChatGPT.sendRequestToOpenAI---
Retrieving response from cache
---Response.<init>---
Creating Response:
```xml
<response>
  <success>true</success>
  <code>
  <![CDATA[
  ```java
  public static synchronized void start() {
      if (!initialized) {
          throw new IllegalStateException(
              "The game cannot be started without being first initialized. Call Game.init(...) before Game.start().");
      }

      if (gameLoop == null) {
          throw new IllegalStateException(
              "Game loop is not initialized. Ensure Game.init(...) has been called successfully.");
      }
      
      gameLoop.start();
      tweenEngine.start();
      soundEngine.start();

      for (final GameListener listener : gameListeners) {
          listener.started();
      }

      hasStarted = true;
  }
  ```
  ]]>
  </code>
</response>
```
---Response.<init>---
Response created:
public static synchronized void start() {
      if (!initialized) {
          throw new IllegalStateException(
              "The game cannot be started without being first initialized. Call Game.init(...) before Game.start().");
      }

      if (gameLoop == null) {
          throw new IllegalStateException(
              "Game loop is not initialized. Ensure Game.init(...) has been called successfully.");
      }
      
      gameLoop.start();
      tweenEngine.start();
      soundEngine.start();

      for (final GameListener listener : gameListeners) {
          listener.started();
      }

      hasStarted = true;
  }
---ChatGPT.fixDereferenceErrorBySafeRegions---
Fixing the error by using safe regions with code:
public static synchronized void start() {
      if (!initialized) {
          throw new IllegalStateException(
              "The game cannot be started without being first initialized. Call Game.init(...) before Game.start().");
      }

      if (gameLoop == null) {
          throw new IllegalStateException(
              "Game loop is not initialized. Ensure Game.init(...) has been called successfully.");
      }
      
      gameLoop.start();
      tweenEngine.start();
      soundEngine.start();

      for (final GameListener listener : gameListeners) {
          listener.started();
      }

      hasStarted = true;
  }
---AdvancedNullAwayCodeFix.fixErrorByRegions---
Successfully generated a fix for the error.
---AdvancedNullAwayCodeFix.lambda$resolveUninitializedField$2---
Working on triggered error: Type='DEREFERENCE_NULLABLE', message='dereferenced expression gameLoop is @Nullable'
/home/nima/Developer/nullness-benchmarks/litiengine/src/de/gurkenlabs/litiengine/Game.java:514
    gameLoop.setUncaughtExceptionHandler(uncaughtExceptionHandler);
---AdvancedNullAwayCodeFix.fix---
Fixing error: Type='DEREFERENCE_NULLABLE', message='dereferenced expression gameLoop is @Nullable'
/home/nima/Developer/nullness-benchmarks/litiengine/src/de/gurkenlabs/litiengine/Game.java:514
    gameLoop.setUncaughtExceptionHandler(uncaughtExceptionHandler);
---AdvancedNullAwayCodeFix.resolveDereferenceError---
Resolving dereference error: Type='DEREFERENCE_NULLABLE', message='dereferenced expression gameLoop is @Nullable'
/home/nima/Developer/nullness-benchmarks/litiengine/src/de/gurkenlabs/litiengine/Game.java:514
    gameLoop.setUncaughtExceptionHandler(uncaughtExceptionHandler);
---AdvancedNullAwayCodeFix.resolveDereferenceError---
Checking nullability possibility at error point
---ChatGPT.checkNullabilityPossibilityAtErrorPoint---
Asking if the expression can be null at error point point
---ChatGPT.ask---
Asking ChatGPT:
In the method below, is there a possibility that the expression "gameLoop" at line "gameLoop.setUncaughtExceptionHandler(uncaughtExceptionHandler);" is null?
public static void setUncaughtExceptionHandler(
      UncaughtExceptionHandler uncaughtExceptionHandler) {
    gameLoop.setUncaughtExceptionHandler(uncaughtExceptionHandler);
    Thread.setDefaultUncaughtExceptionHandler(uncaughtExceptionHandler);
}
Give a single-word answer in XML format. If it is possible for the expression to be null, respond with:
```xml
<response>
    <reason><![CDATA[YOUR REASON]]></reason>
    <value>YES</value>
</response>
```
If it is not possible for the expression to be null, respond with:
```xml
<response>
    <reason><![CDATA[YOUR REASON]]></reason>
    <value>NO</value>
</response>
```
If you are unsure or need more information, respond with where you can ask for more details or what specific information you need.

If additional information is required, list each request inside a `<request>` tag. If no additional information is needed, omit the `<requests>` section.

Respond with:
```xml
<response>
    <reason><![CDATA[YOUR REASON]]></reason>
    <value>UNKNOWN</value>
    <!-- Include <requests> only if additional information is needed -->
    <requests>
        <request><![CDATA[YOUR REQUEST 1]]></request>
        <request><![CDATA[YOUR REQUEST 2]]></request>
    </requests>
</response>
```
---ChatGPT.sendRequestToOpenAI---
Retrieving response from cache
---Response.<init>---
Creating Response:
```xml
<response>
    <reason><![CDATA[Without more context on how "gameLoop" is initialized or managed, it's unclear whether it could be null.]]></reason>
    <value>UNKNOWN</value>
    <requests>
        <request><![CDATA[Is the "gameLoop" variable ever initialized in the relevant code?]]></request>
        <request><![CDATA[Can "gameLoop" be modified concurrently or reset by other methods?]]></request>
    </requests>
</response>
```
---Response.<init>---
Response created:
Unknown: Without more context on how "gameLoop" is initialized or managed, it's unclear whether it could be null.
---AdvancedNullAwayCodeFix.investigateFieldNullability---
Investigating field nullability.
---AdvancedNullAwayCodeFix.investigateFieldNullability---
Checking if there is any method initializing field: gameLoop
---AdvancedNullAwayCodeFix.resolveFieldNullabilityError---
Trying to fix errors for making the field nullable
---AdvancedNullAwayCodeFix.fixErrorByRegions---
Fixing error by regions.
---AdvancedNullAwayCodeFix.fixErrorByRegions---
Safe regions: 3 - Unsafe regions: 4
---ChatGPT.fixDereferenceErrorBySafeRegions---
Attempting to fix dereference error by using safe regions
---ChatGPT.fixDereferenceErrorBySafeRegions---
Asking if the error can be fixed by using safe regions
---ChatGPT.ask---
Asking ChatGPT:
I want to resolve a warning reported by NullAway.
I am getting the error that in line:     gameLoop.terminate();, the dereferenced expression gameLoop is @Nullable and can produce Null Pointer Exception. In the method below:
static synchronized void terminate() {
    if (!initialized) {
      return;
    }

    hasStarted = false;
    initialized = false;

    config().save();
    gameLoop.terminate();
    tweenEngine.terminate();
    soundEngine.terminate();

    world().clear();

    for (final GameListener listener : gameListeners) {
      try {
        listener.terminated();
      } catch (Exception e) {
        log().log(Level.WARNING, "game listener threw an exception during shutdown", e);
      }
    }

    gameLoop = null;
    screenManager = null;
    gameWindow = null;
}
I am going to show you a couple of other examples in my codebase where the dereferenced expression is used in a way that cannot produce Null Pointer Exception.
Here are the examples(s):
private Game() {
    throw new UnsupportedOperationException();
}
public static synchronized void init(String... args) {
    if (initialized) {
      log().log(Level.INFO, "The game has already been initialized.");
      return;
    }

    log.init();
    handleCommandLineArguments(args);

    config().load();
    Locale.setDefault(new Locale(config().client().getCountry(), config().client().getLanguage()));

    gameLoop = new GameLoop("Main Update Loop", config().client().getMaxFps());
    loop().attach(physics());
    loop().attach(world());

    // setup default exception handling for render and update loop
    setUncaughtExceptionHandler(
        new DefaultUncaughtExceptionHandler(config().client().exitOnError()));

    screenManager = new ScreenManager();
    gameWindow = new GameWindow();

    // initialize  the game window
    window().init();
    world.setCamera(new Camera());

    for (GameListener listener : gameListeners) {
      listener.initialized(args);
    }

    if (!isInNoGUIMode()) {
      window().getRenderComponent().onRendered(g -> metrics().render(g));

      graphics()
          .addEntityRenderedListener(
              e -> DebugRenderer.renderEntityDebugInfo(e.getGraphics(), e.getEntity()));

      window().getRenderComponent().onFpsChanged(fps -> metrics().setFramesPerSecond(fps));
      window()
          .setIcons(
              Arrays.asList(
                  Resources.images().get("liti-logo-x16.png"),
                  Resources.images().get("liti-logo-x20.png"),
                  Resources.images().get("liti-logo-x32.png"),
                  Resources.images().get("liti-logo-x48.png")));

      Input.keyboard()
          .onKeyTyped(
              KeyEvent.VK_PRINTSCREEN,
              key -> {
                // don't take a screenshot if a modifier is active
                if (key.getModifiers() != 0) {
                  return;
                }

                window().getRenderComponent().takeScreenshot();
              });
    }

    Runtime.getRuntime().addShutdownHook(new Thread(Game::terminate, "Shutdown"));

    initialized = true;
}
Given the examples above, I want you to fix the error in the original method by using the same pattern as in the examples.
If you can fix the error, please provide the fixed code snippet in XML format. I just need the XML response, no other information is needed. If you can provide the fixed code snippet, please provide it in the following format and place the code snippet in the <code> tag within ```java block.
For example,
<response>
  <success>true</success>
  <code>
  <![CDATA[
  ```java
  Your fixed code snippet here, JUST THE METHOD.
  ```
    ]]>
  </code>
</response>
Or if you cannot fix the error, please provide the reason in XML format.
<response>
  <success>false</success>
</response>

---ChatGPT.sendRequestToOpenAI---
Retrieving response from cache
---Response.<init>---
Creating Response:
```xml
<response>
  <success>true</success>
  <code>
  <![CDATA[
  ```java
  static synchronized void terminate() {
      if (!initialized || gameLoop == null) {
        return;
      }
  
      hasStarted = false;
      initialized = false;
  
      config().save();
      gameLoop.terminate();
      tweenEngine.terminate();
      soundEngine.terminate();
  
      world().clear();
  
      for (final GameListener listener : gameListeners) {
        try {
          listener.terminated();
        } catch (Exception e) {
          log().log(Level.WARNING, "game listener threw an exception during shutdown", e);
        }
      }
  
      gameLoop = null;
      screenManager = null;
      gameWindow = null;
  }
  ```
  ]]>
  </code>
</response>
```
---Response.<init>---
Response created:
static synchronized void terminate() {
      if (!initialized || gameLoop == null) {
        return;
      }
  
      hasStarted = false;
      initialized = false;
  
      config().save();
      gameLoop.terminate();
      tweenEngine.terminate();
      soundEngine.terminate();
  
      world().clear();
  
      for (final GameListener listener : gameListeners) {
        try {
          listener.terminated();
        } catch (Exception e) {
          log().log(Level.WARNING, "game listener threw an exception during shutdown", e);
        }
      }
  
      gameLoop = null;
      screenManager = null;
      gameWindow = null;
  }
---ChatGPT.fixDereferenceErrorBySafeRegions---
Fixing the error by using safe regions with code:
static synchronized void terminate() {
      if (!initialized || gameLoop == null) {
        return;
      }
  
      hasStarted = false;
      initialized = false;
  
      config().save();
      gameLoop.terminate();
      tweenEngine.terminate();
      soundEngine.terminate();
  
      world().clear();
  
      for (final GameListener listener : gameListeners) {
        try {
          listener.terminated();
        } catch (Exception e) {
          log().log(Level.WARNING, "game listener threw an exception during shutdown", e);
        }
      }
  
      gameLoop = null;
      screenManager = null;
      gameWindow = null;
  }
---AdvancedNullAwayCodeFix.fixErrorByRegions---
Successfully generated a fix for the error.
---AdvancedNullAwayCodeFix.fixErrorByRegions---
Fixing error by regions.
---AdvancedNullAwayCodeFix.fixErrorByRegions---
Safe regions: 3 - Unsafe regions: 4
---ChatGPT.fixDereferenceErrorBySafeRegions---
Attempting to fix dereference error by using safe regions
---ChatGPT.fixDereferenceErrorBySafeRegions---
Asking if the error can be fixed by using safe regions
---ChatGPT.ask---
Asking ChatGPT:
I want to resolve a warning reported by NullAway.
I am getting the error that in line:     gameLoop.setUncaughtExceptionHandler(uncaughtExceptionHandler);, the dereferenced expression gameLoop is @Nullable and can produce Null Pointer Exception. In the method below:
public static void setUncaughtExceptionHandler(
      UncaughtExceptionHandler uncaughtExceptionHandler) {
    gameLoop.setUncaughtExceptionHandler(uncaughtExceptionHandler);
    Thread.setDefaultUncaughtExceptionHandler(uncaughtExceptionHandler);
}
I am going to show you a couple of other examples in my codebase where the dereferenced expression is used in a way that cannot produce Null Pointer Exception.
Here are the examples(s):
private Game() {
    throw new UnsupportedOperationException();
}
public static synchronized void init(String... args) {
    if (initialized) {
      log().log(Level.INFO, "The game has already been initialized.");
      return;
    }

    log.init();
    handleCommandLineArguments(args);

    config().load();
    Locale.setDefault(new Locale(config().client().getCountry(), config().client().getLanguage()));

    gameLoop = new GameLoop("Main Update Loop", config().client().getMaxFps());
    loop().attach(physics());
    loop().attach(world());

    // setup default exception handling for render and update loop
    setUncaughtExceptionHandler(
        new DefaultUncaughtExceptionHandler(config().client().exitOnError()));

    screenManager = new ScreenManager();
    gameWindow = new GameWindow();

    // initialize  the game window
    window().init();
    world.setCamera(new Camera());

    for (GameListener listener : gameListeners) {
      listener.initialized(args);
    }

    if (!isInNoGUIMode()) {
      window().getRenderComponent().onRendered(g -> metrics().render(g));

      graphics()
          .addEntityRenderedListener(
              e -> DebugRenderer.renderEntityDebugInfo(e.getGraphics(), e.getEntity()));

      window().getRenderComponent().onFpsChanged(fps -> metrics().setFramesPerSecond(fps));
      window()
          .setIcons(
              Arrays.asList(
                  Resources.images().get("liti-logo-x16.png"),
                  Resources.images().get("liti-logo-x20.png"),
                  Resources.images().get("liti-logo-x32.png"),
                  Resources.images().get("liti-logo-x48.png")));

      Input.keyboard()
          .onKeyTyped(
              KeyEvent.VK_PRINTSCREEN,
              key -> {
                // don't take a screenshot if a modifier is active
                if (key.getModifiers() != 0) {
                  return;
                }

                window().getRenderComponent().takeScreenshot();
              });
    }

    Runtime.getRuntime().addShutdownHook(new Thread(Game::terminate, "Shutdown"));

    initialized = true;
}
Given the examples above, I want you to fix the error in the original method by using the same pattern as in the examples.
If you can fix the error, please provide the fixed code snippet in XML format. I just need the XML response, no other information is needed. If you can provide the fixed code snippet, please provide it in the following format and place the code snippet in the <code> tag within ```java block.
For example,
<response>
  <success>true</success>
  <code>
  <![CDATA[
  ```java
  Your fixed code snippet here, JUST THE METHOD.
  ```
    ]]>
  </code>
</response>
Or if you cannot fix the error, please provide the reason in XML format.
<response>
  <success>false</success>
</response>

---ChatGPT.sendRequestToOpenAI---
Retrieving response from cache
---Response.<init>---
Creating Response:
```xml
<response>
  <success>true</success>
  <code>
  <![CDATA[
  ```java
  public static synchronized void setUncaughtExceptionHandler(
      UncaughtExceptionHandler uncaughtExceptionHandler) {
    if (gameLoop != null) {
      gameLoop.setUncaughtExceptionHandler(uncaughtExceptionHandler);
    }
    Thread.setDefaultUncaughtExceptionHandler(uncaughtExceptionHandler);
  }
  ```
  ]]>
  </code>
</response>
```
---Response.<init>---
Response created:
public static synchronized void setUncaughtExceptionHandler(
      UncaughtExceptionHandler uncaughtExceptionHandler) {
    if (gameLoop != null) {
      gameLoop.setUncaughtExceptionHandler(uncaughtExceptionHandler);
    }
    Thread.setDefaultUncaughtExceptionHandler(uncaughtExceptionHandler);
  }
---ChatGPT.fixDereferenceErrorBySafeRegions---
Fixing the error by using safe regions with code:
public static synchronized void setUncaughtExceptionHandler(
      UncaughtExceptionHandler uncaughtExceptionHandler) {
    if (gameLoop != null) {
      gameLoop.setUncaughtExceptionHandler(uncaughtExceptionHandler);
    }
    Thread.setDefaultUncaughtExceptionHandler(uncaughtExceptionHandler);
  }
---AdvancedNullAwayCodeFix.fixErrorByRegions---
Successfully generated a fix for the error.
---AdvancedNullAwayCodeFix.fixErrorByRegions---
Fixing error by regions.
---AdvancedNullAwayCodeFix.fixErrorByRegions---
Safe regions: 3 - Unsafe regions: 4
---ChatGPT.fixDereferenceErrorBySafeRegions---
Attempting to fix dereference error by using safe regions
---ChatGPT.fixDereferenceErrorBySafeRegions---
Asking if the error can be fixed by using safe regions
---ChatGPT.ask---
Asking ChatGPT:
I want to resolve a warning reported by NullAway.
I am getting the error that in line:     gameLoop.start();, the dereferenced expression gameLoop is @Nullable and can produce Null Pointer Exception. In the method below:
public static synchronized void start() {
    if (!initialized) {
      throw new IllegalStateException(
          "The game cannot be started without being first initialized. Call Game.init(...) before Game.start().");
    }

    gameLoop.start();
    tweenEngine.start();
    soundEngine.start();

    for (final GameListener listener : gameListeners) {
      listener.started();
    }

    hasStarted = true;
}
I am going to show you a couple of other examples in my codebase where the dereferenced expression is used in a way that cannot produce Null Pointer Exception.
Here are the examples(s):
private Game() {
    throw new UnsupportedOperationException();
}
public static synchronized void init(String... args) {
    if (initialized) {
      log().log(Level.INFO, "The game has already been initialized.");
      return;
    }

    log.init();
    handleCommandLineArguments(args);

    config().load();
    Locale.setDefault(new Locale(config().client().getCountry(), config().client().getLanguage()));

    gameLoop = new GameLoop("Main Update Loop", config().client().getMaxFps());
    loop().attach(physics());
    loop().attach(world());

    // setup default exception handling for render and update loop
    setUncaughtExceptionHandler(
        new DefaultUncaughtExceptionHandler(config().client().exitOnError()));

    screenManager = new ScreenManager();
    gameWindow = new GameWindow();

    // initialize  the game window
    window().init();
    world.setCamera(new Camera());

    for (GameListener listener : gameListeners) {
      listener.initialized(args);
    }

    if (!isInNoGUIMode()) {
      window().getRenderComponent().onRendered(g -> metrics().render(g));

      graphics()
          .addEntityRenderedListener(
              e -> DebugRenderer.renderEntityDebugInfo(e.getGraphics(), e.getEntity()));

      window().getRenderComponent().onFpsChanged(fps -> metrics().setFramesPerSecond(fps));
      window()
          .setIcons(
              Arrays.asList(
                  Resources.images().get("liti-logo-x16.png"),
                  Resources.images().get("liti-logo-x20.png"),
                  Resources.images().get("liti-logo-x32.png"),
                  Resources.images().get("liti-logo-x48.png")));

      Input.keyboard()
          .onKeyTyped(
              KeyEvent.VK_PRINTSCREEN,
              key -> {
                // don't take a screenshot if a modifier is active
                if (key.getModifiers() != 0) {
                  return;
                }

                window().getRenderComponent().takeScreenshot();
              });
    }

    Runtime.getRuntime().addShutdownHook(new Thread(Game::terminate, "Shutdown"));

    initialized = true;
}
Given the examples above, I want you to fix the error in the original method by using the same pattern as in the examples.
If you can fix the error, please provide the fixed code snippet in XML format. I just need the XML response, no other information is needed. If you can provide the fixed code snippet, please provide it in the following format and place the code snippet in the <code> tag within ```java block.
For example,
<response>
  <success>true</success>
  <code>
  <![CDATA[
  ```java
  Your fixed code snippet here, JUST THE METHOD.
  ```
    ]]>
  </code>
</response>
Or if you cannot fix the error, please provide the reason in XML format.
<response>
  <success>false</success>
</response>

---ChatGPT.sendRequestToOpenAI---
Retrieving response from cache
---Response.<init>---
Creating Response:
```xml
<response>
  <success>true</success>
  <code>
  <![CDATA[
  ```java
  public static synchronized void start() {
      if (!initialized) {
          throw new IllegalStateException(
              "The game cannot be started without being first initialized. Call Game.init(...) before Game.start().");
      }

      if (gameLoop == null) {
          throw new IllegalStateException(
              "Game loop is not initialized. Ensure Game.init(...) has been called successfully.");
      }
      
      gameLoop.start();
      tweenEngine.start();
      soundEngine.start();

      for (final GameListener listener : gameListeners) {
          listener.started();
      }

      hasStarted = true;
  }
  ```
  ]]>
  </code>
</response>
```
---Response.<init>---
Response created:
public static synchronized void start() {
      if (!initialized) {
          throw new IllegalStateException(
              "The game cannot be started without being first initialized. Call Game.init(...) before Game.start().");
      }

      if (gameLoop == null) {
          throw new IllegalStateException(
              "Game loop is not initialized. Ensure Game.init(...) has been called successfully.");
      }
      
      gameLoop.start();
      tweenEngine.start();
      soundEngine.start();

      for (final GameListener listener : gameListeners) {
          listener.started();
      }

      hasStarted = true;
  }
---ChatGPT.fixDereferenceErrorBySafeRegions---
Fixing the error by using safe regions with code:
public static synchronized void start() {
      if (!initialized) {
          throw new IllegalStateException(
              "The game cannot be started without being first initialized. Call Game.init(...) before Game.start().");
      }

      if (gameLoop == null) {
          throw new IllegalStateException(
              "Game loop is not initialized. Ensure Game.init(...) has been called successfully.");
      }
      
      gameLoop.start();
      tweenEngine.start();
      soundEngine.start();

      for (final GameListener listener : gameListeners) {
          listener.started();
      }

      hasStarted = true;
  }
---AdvancedNullAwayCodeFix.fixErrorByRegions---
Successfully generated a fix for the error.
---AdvancedNullAwayCodeFix.lambda$resolveUninitializedField$2---
Working on triggered error: Type='DEREFERENCE_NULLABLE', message='dereferenced expression gameLoop is @Nullable'
/home/nima/Developer/nullness-benchmarks/litiengine/src/de/gurkenlabs/litiengine/Game.java:541
    gameLoop.start();
---AdvancedNullAwayCodeFix.fix---
Fixing error: Type='DEREFERENCE_NULLABLE', message='dereferenced expression gameLoop is @Nullable'
/home/nima/Developer/nullness-benchmarks/litiengine/src/de/gurkenlabs/litiengine/Game.java:541
    gameLoop.start();
---AdvancedNullAwayCodeFix.resolveDereferenceError---
Resolving dereference error: Type='DEREFERENCE_NULLABLE', message='dereferenced expression gameLoop is @Nullable'
/home/nima/Developer/nullness-benchmarks/litiengine/src/de/gurkenlabs/litiengine/Game.java:541
    gameLoop.start();
---AdvancedNullAwayCodeFix.resolveDereferenceError---
Checking nullability possibility at error point
---ChatGPT.checkNullabilityPossibilityAtErrorPoint---
Asking if the expression can be null at error point point
---ChatGPT.ask---
Asking ChatGPT:
In the method below, is there a possibility that the expression "gameLoop" at line "gameLoop.start();" is null?
public static synchronized void start() {
    if (!initialized) {
      throw new IllegalStateException(
          "The game cannot be started without being first initialized. Call Game.init(...) before Game.start().");
    }

    gameLoop.start();
    tweenEngine.start();
    soundEngine.start();

    for (final GameListener listener : gameListeners) {
      listener.started();
    }

    hasStarted = true;
}
Give a single-word answer in XML format. If it is possible for the expression to be null, respond with:
```xml
<response>
    <reason><![CDATA[YOUR REASON]]></reason>
    <value>YES</value>
</response>
```
If it is not possible for the expression to be null, respond with:
```xml
<response>
    <reason><![CDATA[YOUR REASON]]></reason>
    <value>NO</value>
</response>
```
If you are unsure or need more information, respond with where you can ask for more details or what specific information you need.

If additional information is required, list each request inside a `<request>` tag. If no additional information is needed, omit the `<requests>` section.

Respond with:
```xml
<response>
    <reason><![CDATA[YOUR REASON]]></reason>
    <value>UNKNOWN</value>
    <!-- Include <requests> only if additional information is needed -->
    <requests>
        <request><![CDATA[YOUR REQUEST 1]]></request>
        <request><![CDATA[YOUR REQUEST 2]]></request>
    </requests>
</response>
```
---ChatGPT.sendRequestToOpenAI---
Retrieving response from cache
---Response.<init>---
Creating Response:
```xml
<response>
    <reason><![CDATA[The method does not explicitly check if gameLoop is initialized or not; gameLoop could potentially be null if it is not assigned a value during initialization.]]></reason>
    <value>YES</value>
</response>
```
---Response.<init>---
Response created:
Agreement: The method does not explicitly check if gameLoop is initialized or not; gameLoop could potentially be null if it is not assigned a value during initialization.
---AdvancedNullAwayCodeFix.investigateFieldNullability---
Investigating field nullability.
---AdvancedNullAwayCodeFix.investigateFieldNullability---
Checking if there is any method initializing field: gameLoop
---AdvancedNullAwayCodeFix.resolveFieldNullabilityError---
Trying to fix errors for making the field nullable
---AdvancedNullAwayCodeFix.fixErrorByRegions---
Fixing error by regions.
---AdvancedNullAwayCodeFix.fixErrorByRegions---
Safe regions: 3 - Unsafe regions: 4
---ChatGPT.fixDereferenceErrorBySafeRegions---
Attempting to fix dereference error by using safe regions
---ChatGPT.fixDereferenceErrorBySafeRegions---
Asking if the error can be fixed by using safe regions
---ChatGPT.ask---
Asking ChatGPT:
I want to resolve a warning reported by NullAway.
I am getting the error that in line:     gameLoop.terminate();, the dereferenced expression gameLoop is @Nullable and can produce Null Pointer Exception. In the method below:
static synchronized void terminate() {
    if (!initialized) {
      return;
    }

    hasStarted = false;
    initialized = false;

    config().save();
    gameLoop.terminate();
    tweenEngine.terminate();
    soundEngine.terminate();

    world().clear();

    for (final GameListener listener : gameListeners) {
      try {
        listener.terminated();
      } catch (Exception e) {
        log().log(Level.WARNING, "game listener threw an exception during shutdown", e);
      }
    }

    gameLoop = null;
    screenManager = null;
    gameWindow = null;
}
I am going to show you a couple of other examples in my codebase where the dereferenced expression is used in a way that cannot produce Null Pointer Exception.
Here are the examples(s):
private Game() {
    throw new UnsupportedOperationException();
}
public static synchronized void init(String... args) {
    if (initialized) {
      log().log(Level.INFO, "The game has already been initialized.");
      return;
    }

    log.init();
    handleCommandLineArguments(args);

    config().load();
    Locale.setDefault(new Locale(config().client().getCountry(), config().client().getLanguage()));

    gameLoop = new GameLoop("Main Update Loop", config().client().getMaxFps());
    loop().attach(physics());
    loop().attach(world());

    // setup default exception handling for render and update loop
    setUncaughtExceptionHandler(
        new DefaultUncaughtExceptionHandler(config().client().exitOnError()));

    screenManager = new ScreenManager();
    gameWindow = new GameWindow();

    // initialize  the game window
    window().init();
    world.setCamera(new Camera());

    for (GameListener listener : gameListeners) {
      listener.initialized(args);
    }

    if (!isInNoGUIMode()) {
      window().getRenderComponent().onRendered(g -> metrics().render(g));

      graphics()
          .addEntityRenderedListener(
              e -> DebugRenderer.renderEntityDebugInfo(e.getGraphics(), e.getEntity()));

      window().getRenderComponent().onFpsChanged(fps -> metrics().setFramesPerSecond(fps));
      window()
          .setIcons(
              Arrays.asList(
                  Resources.images().get("liti-logo-x16.png"),
                  Resources.images().get("liti-logo-x20.png"),
                  Resources.images().get("liti-logo-x32.png"),
                  Resources.images().get("liti-logo-x48.png")));

      Input.keyboard()
          .onKeyTyped(
              KeyEvent.VK_PRINTSCREEN,
              key -> {
                // don't take a screenshot if a modifier is active
                if (key.getModifiers() != 0) {
                  return;
                }

                window().getRenderComponent().takeScreenshot();
              });
    }

    Runtime.getRuntime().addShutdownHook(new Thread(Game::terminate, "Shutdown"));

    initialized = true;
}
Given the examples above, I want you to fix the error in the original method by using the same pattern as in the examples.
If you can fix the error, please provide the fixed code snippet in XML format. I just need the XML response, no other information is needed. If you can provide the fixed code snippet, please provide it in the following format and place the code snippet in the <code> tag within ```java block.
For example,
<response>
  <success>true</success>
  <code>
  <![CDATA[
  ```java
  Your fixed code snippet here, JUST THE METHOD.
  ```
    ]]>
  </code>
</response>
Or if you cannot fix the error, please provide the reason in XML format.
<response>
  <success>false</success>
</response>

---ChatGPT.sendRequestToOpenAI---
Retrieving response from cache
---Response.<init>---
Creating Response:
```xml
<response>
  <success>true</success>
  <code>
  <![CDATA[
  ```java
  static synchronized void terminate() {
      if (!initialized || gameLoop == null) {
        return;
      }
  
      hasStarted = false;
      initialized = false;
  
      config().save();
      gameLoop.terminate();
      tweenEngine.terminate();
      soundEngine.terminate();
  
      world().clear();
  
      for (final GameListener listener : gameListeners) {
        try {
          listener.terminated();
        } catch (Exception e) {
          log().log(Level.WARNING, "game listener threw an exception during shutdown", e);
        }
      }
  
      gameLoop = null;
      screenManager = null;
      gameWindow = null;
  }
  ```
  ]]>
  </code>
</response>
```
---Response.<init>---
Response created:
static synchronized void terminate() {
      if (!initialized || gameLoop == null) {
        return;
      }
  
      hasStarted = false;
      initialized = false;
  
      config().save();
      gameLoop.terminate();
      tweenEngine.terminate();
      soundEngine.terminate();
  
      world().clear();
  
      for (final GameListener listener : gameListeners) {
        try {
          listener.terminated();
        } catch (Exception e) {
          log().log(Level.WARNING, "game listener threw an exception during shutdown", e);
        }
      }
  
      gameLoop = null;
      screenManager = null;
      gameWindow = null;
  }
---ChatGPT.fixDereferenceErrorBySafeRegions---
Fixing the error by using safe regions with code:
static synchronized void terminate() {
      if (!initialized || gameLoop == null) {
        return;
      }
  
      hasStarted = false;
      initialized = false;
  
      config().save();
      gameLoop.terminate();
      tweenEngine.terminate();
      soundEngine.terminate();
  
      world().clear();
  
      for (final GameListener listener : gameListeners) {
        try {
          listener.terminated();
        } catch (Exception e) {
          log().log(Level.WARNING, "game listener threw an exception during shutdown", e);
        }
      }
  
      gameLoop = null;
      screenManager = null;
      gameWindow = null;
  }
---AdvancedNullAwayCodeFix.fixErrorByRegions---
Successfully generated a fix for the error.
---AdvancedNullAwayCodeFix.fixErrorByRegions---
Fixing error by regions.
---AdvancedNullAwayCodeFix.fixErrorByRegions---
Safe regions: 3 - Unsafe regions: 4
---ChatGPT.fixDereferenceErrorBySafeRegions---
Attempting to fix dereference error by using safe regions
---ChatGPT.fixDereferenceErrorBySafeRegions---
Asking if the error can be fixed by using safe regions
---ChatGPT.ask---
Asking ChatGPT:
I want to resolve a warning reported by NullAway.
I am getting the error that in line:     gameLoop.setUncaughtExceptionHandler(uncaughtExceptionHandler);, the dereferenced expression gameLoop is @Nullable and can produce Null Pointer Exception. In the method below:
public static void setUncaughtExceptionHandler(
      UncaughtExceptionHandler uncaughtExceptionHandler) {
    gameLoop.setUncaughtExceptionHandler(uncaughtExceptionHandler);
    Thread.setDefaultUncaughtExceptionHandler(uncaughtExceptionHandler);
}
I am going to show you a couple of other examples in my codebase where the dereferenced expression is used in a way that cannot produce Null Pointer Exception.
Here are the examples(s):
private Game() {
    throw new UnsupportedOperationException();
}
public static synchronized void init(String... args) {
    if (initialized) {
      log().log(Level.INFO, "The game has already been initialized.");
      return;
    }

    log.init();
    handleCommandLineArguments(args);

    config().load();
    Locale.setDefault(new Locale(config().client().getCountry(), config().client().getLanguage()));

    gameLoop = new GameLoop("Main Update Loop", config().client().getMaxFps());
    loop().attach(physics());
    loop().attach(world());

    // setup default exception handling for render and update loop
    setUncaughtExceptionHandler(
        new DefaultUncaughtExceptionHandler(config().client().exitOnError()));

    screenManager = new ScreenManager();
    gameWindow = new GameWindow();

    // initialize  the game window
    window().init();
    world.setCamera(new Camera());

    for (GameListener listener : gameListeners) {
      listener.initialized(args);
    }

    if (!isInNoGUIMode()) {
      window().getRenderComponent().onRendered(g -> metrics().render(g));

      graphics()
          .addEntityRenderedListener(
              e -> DebugRenderer.renderEntityDebugInfo(e.getGraphics(), e.getEntity()));

      window().getRenderComponent().onFpsChanged(fps -> metrics().setFramesPerSecond(fps));
      window()
          .setIcons(
              Arrays.asList(
                  Resources.images().get("liti-logo-x16.png"),
                  Resources.images().get("liti-logo-x20.png"),
                  Resources.images().get("liti-logo-x32.png"),
                  Resources.images().get("liti-logo-x48.png")));

      Input.keyboard()
          .onKeyTyped(
              KeyEvent.VK_PRINTSCREEN,
              key -> {
                // don't take a screenshot if a modifier is active
                if (key.getModifiers() != 0) {
                  return;
                }

                window().getRenderComponent().takeScreenshot();
              });
    }

    Runtime.getRuntime().addShutdownHook(new Thread(Game::terminate, "Shutdown"));

    initialized = true;
}
Given the examples above, I want you to fix the error in the original method by using the same pattern as in the examples.
If you can fix the error, please provide the fixed code snippet in XML format. I just need the XML response, no other information is needed. If you can provide the fixed code snippet, please provide it in the following format and place the code snippet in the <code> tag within ```java block.
For example,
<response>
  <success>true</success>
  <code>
  <![CDATA[
  ```java
  Your fixed code snippet here, JUST THE METHOD.
  ```
    ]]>
  </code>
</response>
Or if you cannot fix the error, please provide the reason in XML format.
<response>
  <success>false</success>
</response>

---ChatGPT.sendRequestToOpenAI---
Retrieving response from cache
---Response.<init>---
Creating Response:
```xml
<response>
  <success>true</success>
  <code>
  <![CDATA[
  ```java
  public static synchronized void setUncaughtExceptionHandler(
      UncaughtExceptionHandler uncaughtExceptionHandler) {
    if (gameLoop != null) {
      gameLoop.setUncaughtExceptionHandler(uncaughtExceptionHandler);
    }
    Thread.setDefaultUncaughtExceptionHandler(uncaughtExceptionHandler);
  }
  ```
  ]]>
  </code>
</response>
```
---Response.<init>---
Response created:
public static synchronized void setUncaughtExceptionHandler(
      UncaughtExceptionHandler uncaughtExceptionHandler) {
    if (gameLoop != null) {
      gameLoop.setUncaughtExceptionHandler(uncaughtExceptionHandler);
    }
    Thread.setDefaultUncaughtExceptionHandler(uncaughtExceptionHandler);
  }
---ChatGPT.fixDereferenceErrorBySafeRegions---
Fixing the error by using safe regions with code:
public static synchronized void setUncaughtExceptionHandler(
      UncaughtExceptionHandler uncaughtExceptionHandler) {
    if (gameLoop != null) {
      gameLoop.setUncaughtExceptionHandler(uncaughtExceptionHandler);
    }
    Thread.setDefaultUncaughtExceptionHandler(uncaughtExceptionHandler);
  }
---AdvancedNullAwayCodeFix.fixErrorByRegions---
Successfully generated a fix for the error.
---AdvancedNullAwayCodeFix.fixErrorByRegions---
Fixing error by regions.
---AdvancedNullAwayCodeFix.fixErrorByRegions---
Safe regions: 3 - Unsafe regions: 4
---ChatGPT.fixDereferenceErrorBySafeRegions---
Attempting to fix dereference error by using safe regions
---ChatGPT.fixDereferenceErrorBySafeRegions---
Asking if the error can be fixed by using safe regions
---ChatGPT.ask---
Asking ChatGPT:
I want to resolve a warning reported by NullAway.
I am getting the error that in line:     gameLoop.start();, the dereferenced expression gameLoop is @Nullable and can produce Null Pointer Exception. In the method below:
public static synchronized void start() {
    if (!initialized) {
      throw new IllegalStateException(
          "The game cannot be started without being first initialized. Call Game.init(...) before Game.start().");
    }

    gameLoop.start();
    tweenEngine.start();
    soundEngine.start();

    for (final GameListener listener : gameListeners) {
      listener.started();
    }

    hasStarted = true;
}
I am going to show you a couple of other examples in my codebase where the dereferenced expression is used in a way that cannot produce Null Pointer Exception.
Here are the examples(s):
private Game() {
    throw new UnsupportedOperationException();
}
public static synchronized void init(String... args) {
    if (initialized) {
      log().log(Level.INFO, "The game has already been initialized.");
      return;
    }

    log.init();
    handleCommandLineArguments(args);

    config().load();
    Locale.setDefault(new Locale(config().client().getCountry(), config().client().getLanguage()));

    gameLoop = new GameLoop("Main Update Loop", config().client().getMaxFps());
    loop().attach(physics());
    loop().attach(world());

    // setup default exception handling for render and update loop
    setUncaughtExceptionHandler(
        new DefaultUncaughtExceptionHandler(config().client().exitOnError()));

    screenManager = new ScreenManager();
    gameWindow = new GameWindow();

    // initialize  the game window
    window().init();
    world.setCamera(new Camera());

    for (GameListener listener : gameListeners) {
      listener.initialized(args);
    }

    if (!isInNoGUIMode()) {
      window().getRenderComponent().onRendered(g -> metrics().render(g));

      graphics()
          .addEntityRenderedListener(
              e -> DebugRenderer.renderEntityDebugInfo(e.getGraphics(), e.getEntity()));

      window().getRenderComponent().onFpsChanged(fps -> metrics().setFramesPerSecond(fps));
      window()
          .setIcons(
              Arrays.asList(
                  Resources.images().get("liti-logo-x16.png"),
                  Resources.images().get("liti-logo-x20.png"),
                  Resources.images().get("liti-logo-x32.png"),
                  Resources.images().get("liti-logo-x48.png")));

      Input.keyboard()
          .onKeyTyped(
              KeyEvent.VK_PRINTSCREEN,
              key -> {
                // don't take a screenshot if a modifier is active
                if (key.getModifiers() != 0) {
                  return;
                }

                window().getRenderComponent().takeScreenshot();
              });
    }

    Runtime.getRuntime().addShutdownHook(new Thread(Game::terminate, "Shutdown"));

    initialized = true;
}
Given the examples above, I want you to fix the error in the original method by using the same pattern as in the examples.
If you can fix the error, please provide the fixed code snippet in XML format. I just need the XML response, no other information is needed. If you can provide the fixed code snippet, please provide it in the following format and place the code snippet in the <code> tag within ```java block.
For example,
<response>
  <success>true</success>
  <code>
  <![CDATA[
  ```java
  Your fixed code snippet here, JUST THE METHOD.
  ```
    ]]>
  </code>
</response>
Or if you cannot fix the error, please provide the reason in XML format.
<response>
  <success>false</success>
</response>

---ChatGPT.sendRequestToOpenAI---
Retrieving response from cache
---Response.<init>---
Creating Response:
```xml
<response>
  <success>true</success>
  <code>
  <![CDATA[
  ```java
  public static synchronized void start() {
      if (!initialized) {
          throw new IllegalStateException(
              "The game cannot be started without being first initialized. Call Game.init(...) before Game.start().");
      }

      if (gameLoop == null) {
          throw new IllegalStateException(
              "Game loop is not initialized. Ensure Game.init(...) has been called successfully.");
      }
      
      gameLoop.start();
      tweenEngine.start();
      soundEngine.start();

      for (final GameListener listener : gameListeners) {
          listener.started();
      }

      hasStarted = true;
  }
  ```
  ]]>
  </code>
</response>
```
---Response.<init>---
Response created:
public static synchronized void start() {
      if (!initialized) {
          throw new IllegalStateException(
              "The game cannot be started without being first initialized. Call Game.init(...) before Game.start().");
      }

      if (gameLoop == null) {
          throw new IllegalStateException(
              "Game loop is not initialized. Ensure Game.init(...) has been called successfully.");
      }
      
      gameLoop.start();
      tweenEngine.start();
      soundEngine.start();

      for (final GameListener listener : gameListeners) {
          listener.started();
      }

      hasStarted = true;
  }
---ChatGPT.fixDereferenceErrorBySafeRegions---
Fixing the error by using safe regions with code:
public static synchronized void start() {
      if (!initialized) {
          throw new IllegalStateException(
              "The game cannot be started without being first initialized. Call Game.init(...) before Game.start().");
      }

      if (gameLoop == null) {
          throw new IllegalStateException(
              "Game loop is not initialized. Ensure Game.init(...) has been called successfully.");
      }
      
      gameLoop.start();
      tweenEngine.start();
      soundEngine.start();

      for (final GameListener listener : gameListeners) {
          listener.started();
      }

      hasStarted = true;
  }
---AdvancedNullAwayCodeFix.fixErrorByRegions---
Successfully generated a fix for the error.
