====================
Type='METHOD_NO_INIT', message='initializer method does not guarantee @NonNull fields renderorder (line 59), hexsidelength (line 71), nextLayerId (line 82), nextObjectId (line 85) are initialized along all control-flow paths (remember to check for exceptions or early returns).'
/home/nima/Developer/nullness-benchmarks/litiengine/src/de/gurkenlabs/litiengine/environment/tilemap/xml/TmxMap.java:474
  @Initializer
Log:
---NullAway.lambda$resolveRemainingErrors$17---
==============================
---NullAway.lambda$resolveRemainingErrors$17---
TOP LEVEL CALL TO FIX ERROR: Type='METHOD_NO_INIT', message='initializer method does not guarantee @NonNull fields renderorder (line 59), hexsidelength (line 71), nextLayerId (line 82), nextObjectId (line 85) are initialized along all control-flow paths (remember to check for exceptions or early returns).'
/home/nima/Developer/nullness-benchmarks/litiengine/src/de/gurkenlabs/litiengine/environment/tilemap/xml/TmxMap.java:474
  @Initializer
---ChatGPT.ask---
Asking ChatGPT:
I want to resolve a warning reported by NullAway.
The error is of the type of "METHOD_NO_INIT" and the full error message is: "initializer method does not guarantee @NonNull fields renderorder (line 59), hexsidelength (line 71), nextLayerId (line 82), nextObjectId (line 85) are initialized along all control-flow paths (remember to check for exceptions or early returns).".
The line with the error is: "  @Initializer".

The error is within "the method: afterUnmarshal(javax.xml.bind.Unmarshaller,java.lang.Object)" and the code surrounding the error is:
```java
import de.gurkenlabs.litiengine.environment.tilemap.ITileLayer;
import de.gurkenlabs.litiengine.environment.tilemap.ITileset;
import de.gurkenlabs.litiengine.environment.tilemap.ITilesetEntry;
import de.gurkenlabs.litiengine.environment.tilemap.MapOrientations;
import de.gurkenlabs.litiengine.environment.tilemap.RenderOrder;
import de.gurkenlabs.litiengine.environment.tilemap.StaggerAxis;
import de.gurkenlabs.litiengine.environment.tilemap.StaggerIndex;
import de.gurkenlabs.litiengine.util.io.FileUtilities;
import java.awt.Color;
import java.awt.Dimension;
import java.awt.Rectangle;
import java.awt.geom.Rectangle2D;
import java.net.URL;
import java.util.ArrayList;
import java.util.Collections;
import java.util.List;
import java.util.Objects;
import java.util.concurrent.CopyOnWriteArrayList;
import java.util.logging.Level;
import java.util.logging.Logger;
import javax.annotation.Nullable;
import javax.xml.bind.Marshaller;
import javax.xml.bind.Unmarshaller;
import javax.xml.bind.annotation.XmlAccessType;
import javax.xml.bind.annotation.XmlAccessorType;
import javax.xml.bind.annotation.XmlAttribute;
import javax.xml.bind.annotation.XmlElement;
import javax.xml.bind.annotation.XmlElements;
import javax.xml.bind.annotation.XmlRootElement;
import javax.xml.bind.annotation.XmlTransient;
import javax.xml.bind.annotation.adapters.XmlJavaTypeAdapter;

@XmlRootElement(name = "map")
@XmlAccessorType(XmlAccessType.FIELD)
public final class TmxMap extends CustomPropertyProvider implements IMap {
  public static final String FILE_EXTENSION = "tmx";

  private static final Logger log = Logger.getLogger(TmxMap.class.getName());
  public static final int MAX_MAJOR = 1;
  public static final int MAX_MINOR = 2;

  @XmlAttribute private double version;

  @XmlAttribute private String tiledversion;

  @XmlAttribute private String orientation;

  @XmlTransient private IMapOrientation mapOrientation;

  @XmlAttribute private RenderOrder renderorder;

  @XmlAttribute private int width;

  @XmlAttribute private int height;

  @XmlAttribute private int tilewidth;

  @XmlAttribute private int tileheight;

  @XmlAttribute private int infinite;

  @XmlAttribute private Integer hexsidelength;

  @Nullable @XmlAttribute private StaggerAxis staggeraxis;

  @Nullable @XmlAttribute private StaggerIndex staggerindex;

  @Nullable
  @XmlAttribute
  @XmlJavaTypeAdapter(ColorAdapter.class)
  private Color backgroundcolor;

  @XmlAttribute(name = "nextlayerid")
  private Integer nextLayerId;

  @XmlAttribute(name = "nextobjectid")
  private Integer nextObjectId;

  @Nullable @XmlAttribute private String name;

  @XmlElement(name = "tileset", type = Tileset.class)
  private List<ITileset> tilesets;

  @XmlElements({
    @XmlElement(name = "imagelayer", type = ImageLayer.class),
    @XmlElement(name = "layer", type = TileLayer.class),
    @XmlElement(name = "objectgroup", type = MapObjectLayer.class),
    @XmlElement(name = "group", type = GroupLayer.class)
  })
  private List<ILayer> layers;

  @Nullable @XmlTransient private URL path;

  private transient List<ITileLayer> rawTileLayers = new CopyOnWriteArrayList<>();
  private transient List<IMapObjectLayer> rawMapObjectLayers = new CopyOnWriteArrayList<>();
  private transient List<IImageLayer> rawImageLayers = new CopyOnWriteArrayList<>();
  private transient List<IGroupLayer> rawGroupLayers = new CopyOnWriteArrayList<>();

  private transient List<ITileLayer> tileLayers = Collections.unmodifiableList(this.rawTileLayers);
  private transient List<IMapObjectLayer> mapObjectLayers =
      Collections.unmodifiableList(this.rawMapObjectLayers);
  private transient List<IImageLayer> imageLayers =
      Collections.unmodifiableList(this.rawImageLayers);
  private transient List<IGroupLayer> groupLayers =
      Collections.unmodifiableList(this.rawGroupLayers);

  public TmxMap() {
    // keep for serialization
  }

  public TmxMap(IMapOrientation orientation) {
    this.mapOrientation = orientation;
    this.renderorder = RenderOrder.RIGHT_DOWN;
    this.setTiledVersion(MAX_MAJOR + "." + MAX_MINOR + ".0");
  }

  @XmlTransient private int chunkOffsetX;

  @XmlTransient private int chunkOffsetY;

  @Override
  public List<IImageLayer> getImageLayers() {
    return this.imageLayers;
  }

  /**
   * Gets the next object id.
   *
   * @return the next object id
   */
  @Override
  public int getNextObjectId() {
    return this.nextObjectId;
  }

  @Override
  public int getNextLayerId() {
    return this.nextLayerId;
  }

  @Override
  public IMapOrientation getOrientation() {
    if (this.mapOrientation == null) {
      this.mapOrientation = MapOrientations.forName(this.orientation);
    }
    return this.mapOrientation;
  }

  @Nullable
  @Override
  @XmlTransient
  public URL getPath() {
    return this.path;
  }

  @Override
  public RenderOrder getRenderOrder() {
    return this.renderorder;
  }

  @Override
  public List<IMapObjectLayer> getMapObjectLayers() {
    return this.mapObjectLayers;
  }

  @Override
  public Dimension getSizeInPixels() {
    return this.getOrientation().getSize(this);
  }

  @XmlTransient
  @Override
  public Rectangle2D getBounds() {
    return new Rectangle(this.getSizeInPixels());
  }

  @Override
  public Dimension getSizeInTiles() {
    return new Dimension(this.width, this.height);
  }

  @Override
  public List<ITileLayer> getTileLayers() {
    return this.tileLayers;
  }

  @Override
  public List<ITileset> getTilesets() {
    if (this.tilesets == null) {
      this.tilesets = new CopyOnWriteArrayList<>();
    }

    return this.tilesets;
  }

  @Nullable
  @Override
  public ITilesetEntry getTilesetEntry(int gid) {
    for (ITileset tileset : this.getTilesets()) {
      if (tileset.containsTile(gid)) {
        return tileset.getTile(gid - tileset.getFirstGridId());
      }
    }
    return null;
  }

  @Override
  public Dimension getTileSize() {
    return new Dimension(this.tilewidth, this.tileheight);
  }

  @Override
  public int getTileWidth() {
    return this.tilewidth;
  }

  @Override
  public int getTileHeight() {
    return this.tileheight;
  }

  @Override
  public double getVersion() {
    return this.version;
  }

  @Override
  public String getTiledVersion() {
    return this.tiledversion;
  }

  @Override
  public List<IGroupLayer> getGroupLayers() {
    return this.groupLayers;
  }

  @Nullable
  @Override
  public String getName() {
    return this.name;
  }

  @Override
  public void setName(final String name) {
    this.name = name;
  }

  @Override
  public int getWidth() {
    return this.width;
  }

  @Override
  public int getHeight() {
    return this.height;
  }

  @Override
  public int getHexSideLength() {
    return this.hexsidelength;
  }

  @Nullable
  @Override
  public StaggerAxis getStaggerAxis() {
    return this.staggeraxis;
  }

  @Nullable
  @Override
  public StaggerIndex getStaggerIndex() {
    return this.staggerindex;
  }

  public void setPath(final URL path) {
    this.path = path;
  }

  @Override
  public void finish(@Nullable URL location) throws TmxException {
    super.finish(location);
    if (this.name == null) {
      this.name = FileUtilities.getFileName(location);
    }
    this.path = location;
    // tilesets must be post-processed before layers; otherwise external tilesets may not be loaded
    for (ITileset tileset : this.tilesets) {
      if (tileset instanceof Tileset) {
        ((Tileset) tileset).finish(location);
      }
    }
    for (ILayer layer : this.layers) {
      if (layer instanceof Layer) {
        ((Layer) layer).finish(location);
      }
    }
  }

  @Override
  public void addLayer(ILayer layer) {
    this.getRenderLayers().add(layer);
    this.layerAdded(layer);
    if (layer instanceof Layer) {
      ((Layer) layer).setMap(this);
    }
  }

  @Override
  public void addLayer(int index, ILayer layer) {
    this.getRenderLayers().add(index, layer);
    this.addRawLayer(index, layer);
    if (layer instanceof Layer) {
      ((Layer) layer).setMap(this);
    }
  }

  @Override
  public void removeLayer(ILayer layer) {
    this.layers.remove(layer);
    this.removeRawLayer(layer);
    if (layer instanceof Layer) {
      ((Layer) layer).setMap(null);
    }
  }

  @Override
  public void removeLayer(int index) {
    ILayer removed = this.layers.remove(index);
    this.removeRawLayer(removed);
    if (removed instanceof Layer) {
      ((Layer) removed).setMap(null);
    }
  }

  private void removeRawLayer(ILayer layer) {
    if (layer instanceof ITileLayer) {
      this.rawTileLayers.remove(layer);
    }
    if (layer instanceof IMapObjectLayer) {
      this.rawMapObjectLayers.remove(layer);
    }
    if (layer instanceof IImageLayer) {
      this.rawImageLayers.remove(layer);
    }
    if (layer instanceof IGroupLayer) {
      this.rawGroupLayers.remove(layer);
    }
  }

  @XmlTransient
  public void setHeight(int height) {
    this.height = height;
  }

  @XmlTransient
  public void setOrientation(IMapOrientation orientation) {
    this.mapOrientation = Objects.requireNonNull(orientation);
  }

  @XmlTransient
  public void setRenderOrder(RenderOrder renderorder) {
    this.renderorder = renderorder;
  }

  @XmlTransient
  public void setTiledVersion(String tiledversion) {
    this.tiledversion = tiledversion;
  }

  @XmlTransient
  public void setTileHeight(int tileheight) {
    this.tileheight = tileheight;
  }

  @XmlTransient
  public void setTileWidth(int tilewidth) {
    this.tilewidth = tilewidth;
  }

  @XmlTransient
  public void setHexSideLength(int hexSideLength) {
    this.hexsidelength = hexSideLength;
  }

  @XmlTransient
  public void setStaggerAxis(StaggerAxis staggerAxis) {
    this.staggeraxis = staggerAxis;
  }

  @XmlTransient
  public void setStaggerIndex(StaggerIndex staggerIndex) {
    this.staggerindex = staggerIndex;
  }

  @XmlTransient
  public void setVersion(double version) {
    this.version = version;
  }

  @XmlTransient
  public void setWidth(int width) {
    this.width = width;
  }

  @Override
  public String toString() {
    return (this.getName() == null || this.getName().isEmpty()) ? super.toString() : this.getName();
  }

  @Override
  public boolean equals(Object anObject) {
    if (this == anObject) {
      return true;
    }
    if (!(anObject instanceof TmxMap)) {
      return false;
    }
    return Objects.equals(this.name, ((TmxMap) anObject).name);
  }

  @Override
  public int hashCode() {
    return Objects.hashCode(this.name);
  }

  @Override
  public List<ILayer> getRenderLayers() {
    if (this.layers == null) {
      this.layers = new CopyOnWriteArrayList<>();
    }

    return this.layers;
  }

  public List<Tileset> getExternalTilesets() {
    List<Tileset> externalTilesets = new ArrayList<>();
    for (ITileset set : this.getTilesets()) {
      if (set instanceof Tileset && ((Tileset) set).sourceTileset != null) {
        externalTilesets.add(((Tileset) set).sourceTileset);
      }
    }

    return externalTilesets;
  }

  @Nullable
  @Override
  public Color getBackgroundColor() {
    return this.backgroundcolor;
  }

  @Override
  public boolean isInfinite() {
    return this.infinite == 1;
  }

  protected int getChunkOffsetX() {
    return this.chunkOffsetX;
  }

  protected int getChunkOffsetY() {
    return this.chunkOffsetY;
  }

  @Initializer
  @SuppressWarnings("unused")
  private void afterUnmarshal(Unmarshaller u, Object parent) throws TmxException {
    this.checkVersion();

    if (this.orientation != null) {
      this.mapOrientation = MapOrientations.forName(this.orientation);
    }

    if (this.mapOrientation == null) {
      this.mapOrientation = MapOrientations.ORTHOGONAL;
    }

    if (this.tilesets == null) {
      this.tilesets = new CopyOnWriteArrayList<>();
    }

    if (this.layers == null) {
      this.layers = new CopyOnWriteArrayList<>();
    }

    for (ILayer layer : this.layers) {
      this.layerAdded(layer);
    }

    if (this.isInfinite()) {
      this.updateDimensionsByTileLayers();
    }
```

Give me the fixed code snippet (ONLY THE METHOD REWRITE OF "afterUnmarshal(javax.xml.bind.Unmarshaller,java.lang.Object)") in XML format in <response> tag like the example below. I will apply the fix to my codebase.
Do not import any additional libraries or classes or java comments.
If you can provide the fixed code snippet, provide it in the following format and place the code snippet in the <code> tag within ```java block.
<response>
  <success>true</success>
  <code><![CDATA[
  ```java
  Your fixed code snippet here
  ```
    ]]>
  </code>
</response>

---ChatGPT.sendRequestToOpenAI---
Sending request to OpenAI...
---ChatGPT.sendRequestToOpenAI---
Response received from OpenAI.
---Response.<init>---
Creating Response:
```xml
<response>
  <success>true</success>
  <code><![CDATA[
  ```java
  @Initializer
  @SuppressWarnings("unused")
  private void afterUnmarshal(Unmarshaller u, Object parent) throws TmxException {
    this.checkVersion();

    if (this.orientation != null) {
      this.mapOrientation = MapOrientations.forName(this.orientation);
    }

    if (this.mapOrientation == null) {
      this.mapOrientation = MapOrientations.ORTHOGONAL;
    }

    if (this.tilesets == null) {
      this.tilesets = new CopyOnWriteArrayList<>();
    }

    if (this.layers == null) {
      this.layers = new CopyOnWriteArrayList<>();
    }

    for (ILayer layer : this.layers) {
      this.layerAdded(layer);
    }

    if (this.isInfinite()) {
      this.updateDimensionsByTileLayers();
    }

    // Ensure non-null fields are initialized
    if (this.renderorder == null) {
      this.renderorder = RenderOrder.RIGHT_DOWN;
    }

    if (this.hexsidelength == null) {
      this.hexsidelength = 0; // or any default value
    }

    if (this.nextLayerId == null) {
      this.nextLayerId = 0; // or any default value
    }

    if (this.nextObjectId == null) {
      this.nextObjectId = 0; // or any default value
    }
  }
  ```
    ]]>
  </code>
</response>
```
---Response.<init>---
Response created:
@Initializer
  @SuppressWarnings("unused")
  private void afterUnmarshal(Unmarshaller u, Object parent) throws TmxException {
    this.checkVersion();

    if (this.orientation != null) {
      this.mapOrientation = MapOrientations.forName(this.orientation);
    }

    if (this.mapOrientation == null) {
      this.mapOrientation = MapOrientations.ORTHOGONAL;
    }

    if (this.tilesets == null) {
      this.tilesets = new CopyOnWriteArrayList<>();
    }

    if (this.layers == null) {
      this.layers = new CopyOnWriteArrayList<>();
    }

    for (ILayer layer : this.layers) {
      this.layerAdded(layer);
    }

    if (this.isInfinite()) {
      this.updateDimensionsByTileLayers();
    }

    // Ensure non-null fields are initialized
    if (this.renderorder == null) {
      this.renderorder = RenderOrder.RIGHT_DOWN;
    }

    if (this.hexsidelength == null) {
      this.hexsidelength = 0; // or any default value
    }

    if (this.nextLayerId == null) {
      this.nextLayerId = 0; // or any default value
    }

    if (this.nextObjectId == null) {
      this.nextObjectId = 0; // or any default value
    }
  }
