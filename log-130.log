====================
Type='DEREFERENCE_NULLABLE', message='dereferenced expression this.miscEntities.get(renderType) is @Nullable'
/home/nima/Developer/nullness-benchmarks/litiengine/src/de/gurkenlabs/litiengine/environment/Environment.java:1103
    return Collections.unmodifiableCollection(this.miscEntities.get(renderType).values());
Log:
---NullAway.lambda$resolveRemainingErrors$17---
==============================
---NullAway.lambda$resolveRemainingErrors$17---
TOP LEVEL CALL TO FIX ERROR: Type='DEREFERENCE_NULLABLE', message='dereferenced expression this.miscEntities.get(renderType) is @Nullable'
/home/nima/Developer/nullness-benchmarks/litiengine/src/de/gurkenlabs/litiengine/environment/Environment.java:1103
    return Collections.unmodifiableCollection(this.miscEntities.get(renderType).values());
---ChatGPT.ask---
Asking ChatGPT:
I want to resolve a warning reported by NullAway.
The error is of the type of "DEREFERENCE_NULLABLE" and the full error message is: "dereferenced expression this.miscEntities.get(renderType) is @Nullable".
The line with the error is: "    return Collections.unmodifiableCollection(this.miscEntities.get(renderType).values());".

The error is within "the method: getEntities(de.gurkenlabs.litiengine.graphics.RenderType)" and the code surrounding the error is:
```java
package de.gurkenlabs.litiengine.environment;

import de.gurkenlabs.litiengine.Direction;
import de.gurkenlabs.litiengine.Game;
import de.gurkenlabs.litiengine.GameMetrics;
import de.gurkenlabs.litiengine.IUpdateable;
import de.gurkenlabs.litiengine.configuration.Quality;
import de.gurkenlabs.litiengine.entities.CollisionBox;
import de.gurkenlabs.litiengine.entities.Creature;
import de.gurkenlabs.litiengine.entities.EntityInfo;
import de.gurkenlabs.litiengine.entities.EntityListener;
import de.gurkenlabs.litiengine.entities.ICollisionEntity;
import de.gurkenlabs.litiengine.entities.ICombatEntity;
import de.gurkenlabs.litiengine.entities.IEntity;
import de.gurkenlabs.litiengine.entities.IMobileEntity;
import de.gurkenlabs.litiengine.entities.LightSource;
import de.gurkenlabs.litiengine.entities.MapArea;
import de.gurkenlabs.litiengine.entities.Prop;
import de.gurkenlabs.litiengine.entities.SoundSource;
import de.gurkenlabs.litiengine.entities.Spawnpoint;
import de.gurkenlabs.litiengine.entities.StaticShadow;
import de.gurkenlabs.litiengine.entities.Trigger;
import de.gurkenlabs.litiengine.environment.tilemap.ILayer;
import de.gurkenlabs.litiengine.environment.tilemap.IMap;
import de.gurkenlabs.litiengine.environment.tilemap.IMapObject;
import de.gurkenlabs.litiengine.environment.tilemap.IMapObjectLayer;
import de.gurkenlabs.litiengine.environment.tilemap.MapObjectType;
import de.gurkenlabs.litiengine.environment.tilemap.MapProperty;
import de.gurkenlabs.litiengine.environment.tilemap.MapRenderer;
import de.gurkenlabs.litiengine.environment.tilemap.MapUtilities;
import de.gurkenlabs.litiengine.environment.tilemap.xml.Blueprint;
import de.gurkenlabs.litiengine.graphics.AmbientLight;
import de.gurkenlabs.litiengine.graphics.ColorLayer;
import de.gurkenlabs.litiengine.graphics.DebugRenderer;
import de.gurkenlabs.litiengine.graphics.IRenderable;
import de.gurkenlabs.litiengine.graphics.RenderEngine;
import de.gurkenlabs.litiengine.graphics.RenderType;
import de.gurkenlabs.litiengine.graphics.StaticShadowLayer;
import de.gurkenlabs.litiengine.graphics.StaticShadowType;
import de.gurkenlabs.litiengine.graphics.emitters.Emitter;
import de.gurkenlabs.litiengine.physics.GravityForce;
import de.gurkenlabs.litiengine.physics.IMovementController;
import de.gurkenlabs.litiengine.resources.Resources;
import de.gurkenlabs.litiengine.util.TimeUtilities;
import de.gurkenlabs.litiengine.util.geom.GeometricUtilities;
import java.awt.Color;
import java.awt.Graphics2D;
import java.awt.Shape;
import java.awt.geom.AffineTransform;
import java.awt.geom.Point2D;
import java.awt.geom.Rectangle2D;
import java.lang.reflect.Modifier;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collection;
import java.util.Collections;
import java.util.EnumMap;
import java.util.Iterator;
import java.util.List;
import java.util.Map;
import java.util.Map.Entry;
import java.util.Optional;
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.CopyOnWriteArrayList;
import java.util.function.BiConsumer;
import java.util.function.Consumer;
import java.util.function.Predicate;
import java.util.logging.Level;
import java.util.logging.Logger;
import java.util.stream.Collectors;
import javax.annotation.Nullable;

public final class Environment implements IRenderable {
  private static final Map<String, IMapObjectLoader> mapObjectLoaders = new ConcurrentHashMap<>();
  private static final String GRAVITY_IDENTIFIER = "GRAVITY";
  private static final Logger log = Logger.getLogger(Environment.class.getName());

  private static int localIdSequence = 0;

  private final Map<Integer, ICombatEntity> combatEntities = new ConcurrentHashMap<>();
  private final Map<Integer, IMobileEntity> mobileEntities = new ConcurrentHashMap<>();
  private final Map<Integer, GravityForce> gravityForces = new ConcurrentHashMap<>();
  private final Map<RenderType, Map<Integer, IEntity>> miscEntities =
      Collections.synchronizedMap(new EnumMap<>(RenderType.class));
  private final Map<IMapObjectLayer, List<IEntity>> layerEntities = new ConcurrentHashMap<>();
  private final Map<String, Collection<IEntity>> entitiesByTag = new ConcurrentHashMap<>();
  private final Map<Integer, IEntity> allEntities = new ConcurrentHashMap<>();

  private final Map<RenderType, Collection<EnvironmentRenderedListener>> renderListeners =
      Collections.synchronizedMap(new EnumMap<>(RenderType.class));
  private final Collection<EnvironmentListener> listeners = ConcurrentHashMap.newKeySet();
  private final Collection<EnvironmentEntityListener> entityListeners =
      ConcurrentHashMap.newKeySet();

  private final Map<RenderType, Collection<IRenderable>> renderables =
      Collections.synchronizedMap(new EnumMap<>(RenderType.class));
  private final Collection<Emitter> emitters = ConcurrentHashMap.newKeySet();
  private final Collection<CollisionBox> colliders = ConcurrentHashMap.newKeySet();
  private final Collection<Prop> props = ConcurrentHashMap.newKeySet();
  private final Collection<Creature> creatures = ConcurrentHashMap.newKeySet();
  private final Collection<StaticShadow> staticShadows = ConcurrentHashMap.newKeySet();
  private final Collection<LightSource> lightSources = ConcurrentHashMap.newKeySet();
  private final Collection<SoundSource> soundSources = ConcurrentHashMap.newKeySet();
  private final Collection<Spawnpoint> spawnPoints = ConcurrentHashMap.newKeySet();
  private final Collection<MapArea> mapAreas = ConcurrentHashMap.newKeySet();
  private final Collection<Trigger> triggers = ConcurrentHashMap.newKeySet();

  @Nullable private AmbientLight ambientLight;
  @Nullable private StaticShadowLayer staticShadowLayer;
  private boolean loaded;
  private boolean initialized;
  @Nullable private IMap map;

  private int gravity;

  private boolean rendering;

  static {
    registerMapObjectLoader(new PropMapObjectLoader());
    registerMapObjectLoader(new CollisionBoxMapObjectLoader());
    registerMapObjectLoader(new TriggerMapObjectLoader());
    registerMapObjectLoader(new EmitterMapObjectLoader());
    registerMapObjectLoader(new LightSourceMapObjectLoader());
    registerMapObjectLoader(new SpawnpointMapObjectLoader());
    registerMapObjectLoader(new MapAreaMapObjectLoader());
    registerMapObjectLoader(new StaticShadowMapObjectLoader());
    registerMapObjectLoader(new CreatureMapObjectLoader());
    registerMapObjectLoader(new SoundSourceMapObjectLoader());
  }

  /**
   * Instantiates a new {@code Environment} for the specified map.
   *
   * @param map The map that defines this environment.
   */
  public Environment(final IMap map) {
    this();
    this.map = map;
    if (this.getMap() != null) {
      Game.physics().setBounds(this.getMap().getBounds());
      this.setGravity(this.getMap().getIntValue(MapProperty.GRAVITY));
    }
  }

  /**
   * Instantiates a new {@code Environment} for the specified map.
   *
   * @param mapPath The path to the map resource that defines this environment.
   */
  public Environment(final String mapPath) {
    this(Resources.maps().get(mapPath));
  }

  private Environment() {
    for (RenderType renderType : RenderType.values()) {
      this.miscEntities.put(renderType, new ConcurrentHashMap<>());
      this.renderListeners.put(renderType, ConcurrentHashMap.newKeySet());
      this.renderables.put(renderType, ConcurrentHashMap.newKeySet());
    }
  }

  /**
   * Registers a custom loader instance that is responsible for loading and initializing entities of
   * the defined MapObjectType. <br>
   * <br>
   * There can only be one loader for a particular type. Calling this method again for the same type
   * will overwrite the previously registered loader.
   *
   * @param mapObjectLoader The MapObjectLoader instance to be registered.
   * @see IMapObjectLoader#getMapObjectType()
   */
  public static void registerMapObjectLoader(IMapObjectLoader mapObjectLoader) {
    mapObjectLoaders.put(mapObjectLoader.getMapObjectType(), mapObjectLoader);
  }

  /**
   * Registers a custom {@code IEntity} implementation to support being loaded from an {@code IMap}
   * instance. Note that the specified class needs to be accessible in a static manner. Inner
   * classes that aren't declared statically are not supported.
   *
   * <p>This is an overload of the {@link #registerCustomEntityType(Class)} method that allows to
   * explicitly specify the {@code MapObjectType} without having to provide an {@code EntityInfo}
   * annotation containing this information.
   *
   * <p>Custom entity types need to provide at least one constructor that matches the following
   * criteria:
   *
   * <ul>
   *   <li>has 2 parameters: {@code Environment, IMapObject}
   *   <li>has 2 parameters: {@code IMapObject, Environment}
   *   <li>has 1 parameter: {@code IMapObject}
   *   <li>has 1 parameter: {@code Environment}
   *   <li>is empty constructor
   * </ul>
   *
   * @param mapObjectType The custom mapobjectType that is used by {@code IMapObjects} to determine
   *     the target entity implementation.
   * @param entityType The class type of the custom entity implementation.
   * @see IMapObject#getType()
   * @see EntityInfo#customMapObjectType()
   */
  public static void registerCustomEntityType(
      String mapObjectType, Class<? extends IEntity> entityType) {
    if (entityType.isInterface() || Modifier.isAbstract(entityType.getModifiers())) {
      log.log(
          Level.WARNING,
          "Cannot register the custom entity type [{0}]: Type must not be an interface or abstract class.",
          entityType.getName());
      return;
    }

    CustomMapObjectLoader.ConstructorInvocation invocation =
        CustomMapObjectLoader.findConstructor(entityType);
    if (invocation == null) {
      log.log(
          Level.WARNING,
          "Cannot register the custom entity type [{0}]: No matching constructor found.",
          entityType.getName());
      return;
    }

    CustomMapObjectLoader mapObjectLoader = new CustomMapObjectLoader(mapObjectType, invocation);
    registerMapObjectLoader(mapObjectLoader);
  }

  /**
   * Registers a custom {@code IEntity} implementation to support being loaded from an {@code IMap}
   * instance. Note that the specified class needs to be accessible in a static manner. Inner
   * classes that aren't declared statically are not supported.
   *
   * <p>This implementation uses the provided {@code EntityInfo.customMapObjectType()} to determine
   * for which type the specified class should be used.
   *
   * @param entityType The class type of the custom entity implementation.
   * @see Environment#registerCustomEntityType(String, Class)
   * @see IMapObject#getType()
   * @see EntityInfo#customMapObjectType()
   */
  public static void registerCustomEntityType(Class<? extends IEntity> entityType) {
    EntityInfo info = entityType.getAnnotation(EntityInfo.class);
    if (info == null || info.customMapObjectType().isEmpty()) {
      log.log(
          Level.WARNING,
          "Cannot register the custom entity type [{0}]: EntityInfo.customMapObjectType must be specified.\nAdd an EntityInfo annotation to the class and provide the required information or use the registerCustomEntityType overload and provide the type explicitly.",
          entityType.getName());
      return;
    }

    registerCustomEntityType(info.customMapObjectType(), entityType);
  }

  /**
   * Adds the specified environment rendered listener to receive events when this instance renders
   * the specified renderType.
   *
   * @param renderType The type that defines to which render process this listener should be
   *     attached.
   * @param listener The listener to add.
   */
  public void onRendered(RenderType renderType, EnvironmentRenderedListener listener) {
    this.renderListeners.get(renderType).add(listener);
  }

  /**
   * Removes the specified environment rendered listener.
   *
   * @param listener The listener to remove.
   */
  public void removeListener(EnvironmentRenderedListener listener) {
    for (Collection<EnvironmentRenderedListener> rends : this.renderListeners.values()) {
      rends.remove(listener);
    }
  }

  /**
   * Adds the specified environment listener to receive events about the basic environment
   * life-cycle.
   *
   * @param listener The listener to add.
   */
  public void addListener(EnvironmentListener listener) {
    this.listeners.add(listener);
  }

  /**
   * Removes the environment listener.
   *
   * @param listener The listener to remove.
   */
  public void removeListener(EnvironmentListener listener) {
    this.listeners.remove(listener);
  }

  /**
   * Adds the specified environment entity listener to receive events about entities on this
   * environment.
   *
   * @param listener The listener to add.
   */
  public void addEntityListener(EnvironmentEntityListener listener) {
    this.entityListeners.add(listener);
  }

  /**
   * Removes the environment entity listener listener.
   *
   * @param listener The listener to remove.
   */
  public void removeEntityListener(EnvironmentEntityListener listener) {
    this.entityListeners.remove(listener);
  }

  /**
   * Adds the specified entity to the environment container. This also loads the entity (registers
   * entity and controllers for update) if the environment has already been loaded. The entity will
   * not be bound to a layer.
   *
   * @param entity The entity to add to the environment.
   * @see #isLoaded()
   * @see IEntity#loaded(Environment)
   * @see EnvironmentEntityListener#entityAdded(IEntity)
   */
  public void add(IEntity entity) {
    if (entity == null) {
      return;
    }
    this.addEntity(entity);
    this.miscEntities.get(entity.getRenderType()).put(entity.getMapId(), entity);
    this.fireEntityEvent(l -> l.entityAdded(entity));
  }

  /**
   * Adds all the specified entities to the environment container.
   *
   * @param <T> The type of the entity.
   * @param entities The entities to be added to the environment.
   * @see #add(IEntity)
   * @see #addAll(IEntity...)
   * @see #remove(IEntity)
   * @see #removeAll(Iterable)
   */
  public <T extends IEntity> void addAll(Iterable<T> entities) {
    if (entities == null) {
      return;
    }

    for (T ent : entities) {
      this.add(ent);
    }
  }

  /**
   * Adds all the specified entities to the environment container.
   *
   * @param entities The entities to be added to the environment.
   * @see #add(IEntity)
   * @see #addAll(Iterable)
   * @see #remove(IEntity)
   * @see #removeAll(Iterable)
   */
  public void addAll(IEntity... entities) {
    this.addAll(Arrays.asList(entities));
  }

  /**
   * Forces an update on the lighting layers for the entire map.
   *
   * @see #getStaticShadowLayer()
   * @see #getAmbientLight()
   * @see ColorLayer#updateSection(Rectangle2D)
   */
  public void updateLighting() {
    if (this.getMap() != null) {
      this.updateLighting(this.getMap().getBounds());
    }
  }

  /**
   * Forces an update on the lighting layers for the specified section on the map.
   *
   * @param section The section for which to update the lighting layers.
   * @see #getStaticShadowLayer()
   * @see #getAmbientLight()
   * @see ColorLayer#updateSection(Rectangle2D)
   */
  public void updateLighting(Rectangle2D section) {
    if (this.staticShadowLayer != null) {
      this.staticShadowLayer.updateSection(section);
    }

    if (this.ambientLight != null) {
      this.ambientLight.updateSection(section);
    }
  }

  /**
   * Adds the specified instance to be rendered with the defined {@code RenderType} whenever the
   * environment's render pipeline is executed.
   *
   * <p>This method can be used for any custom rendering that is not related to an entity, a GUI
   * component or the map.
   *
   * <p>Note that you don't need to explicitly add an {@code Entity} if it implements {@code
   * IRenderable}. The render engine will inherently call an entity's render method.
   *
   * @param renderable The instance that should be rendered.
   * @param renderType The render type that determines how the instance is processed by the
   *     environment's render pipeline.
   * @see #render(Graphics2D)
   * @see RenderEngine#renderEntity(Graphics2D, IEntity)
   */
  public void add(IRenderable renderable, RenderType renderType) {
    this.renderables.get(renderType).add(renderable);
  }

  /**
   * Adds entities by the specified blueprint to this environment at the defined location.
   *
   * @param blueprint The blueprint, defining the map object to load the entities from.
   * @param x The x-coordinate of the location at which to spawn the entities.
   * @param y The y-coordinate of the location at which to spawn the entities.
   * @return A collection with all added entities.
   */
  public Collection<IEntity> build(Blueprint blueprint, double x, double y) {
    return this.build(blueprint, new Point2D.Double(x, y));
  }

  /**
   * Adds entities by the specified blueprint to this environment at the defined location.
   *
   * @param blueprint The blueprint, defining the map object to load the entities from.
   * @param location The location at which to spawn the entities.
   * @return A collection with all added entities.
   */
  public Collection<IEntity> build(Blueprint blueprint, Point2D location) {
    Collection<IMapObject> mapObjects = blueprint.build(location);
    Collection<IEntity> loadedEntities = new ArrayList<>();
    for (IMapObject obj : mapObjects) {
      loadedEntities.addAll(this.load(obj));
    }

    return loadedEntities;
  }

  /** Clears all loaded entities and renderable instances from this environment. */
  public void clear() {
    Game.physics().clear();

    this.combatEntities.clear();
    this.mobileEntities.clear();
    this.gravityForces.clear();
    this.layerEntities.clear();
    this.entitiesByTag.clear();
    this.allEntities.clear();

    for (RenderType renderType : RenderType.values()) {
      this.miscEntities.get(renderType).clear();
      this.renderListeners.get(renderType).clear();
      this.renderables.get(renderType).clear();
    }

    dispose(this.allEntities.values());
    dispose(this.triggers);
    this.emitters.clear();
    this.colliders.clear();
    this.props.clear();
    this.creatures.clear();
    this.staticShadows.clear();
    this.combatEntities.clear();
    this.mobileEntities.clear();
    this.lightSources.clear();
    this.spawnPoints.clear();
    this.soundSources.clear();
    this.mapAreas.clear();
    this.triggers.clear();

    this.ambientLight = null;
    this.staticShadowLayer = null;

    for (Map<Integer, IEntity> type : this.miscEntities.values()) {
      type.clear();
    }

    this.initialized = false;

    this.fireEvent(l -> l.cleared(this));
  }

  /**
   * Determines whether the environment contains the specified entity.
   *
   * @param entity The entity to check for.
   * @return True if the environment contains the specified entity; otherwise false.
   */
  public boolean contains(IEntity entity) {
    return this.contains(entity.getMapId());
  }

  /**
   * Determines whether the environment contains any entity with the specified map ID.
   *
   * @param mapId The map ID of the entity to check for.
   * @return True if the environment contains an entity with the specified map ID; otherwise false.
   */
  public boolean contains(int mapId) {
    return this.allEntities.containsKey(mapId);
  }

  /**
   * Attempts to find all combat entities whose hitBox intersects with the specified shape.
   *
   * @param shape The shape to check intersection for.
   * @return A collection of all combat entities that intersect the specified {@link Shape}.
   */
  public Collection<ICombatEntity> findCombatEntities(final Shape shape) {
    return this.findCombatEntities(shape, entity -> true);
  }

  /**
   * Attempts to find all combat entities whose hitBox intersects with the specified shape.
   *
   * @param shape The shape to check intersection for.
   * @param condition An additional condition that allows to specify a condition which determines if
   *     a {@link ICombatEntity} should be considered.
   * @return A collection of all combat entities that intersect the specified {@link Shape}.
   */
  public Collection<ICombatEntity> findCombatEntities(
      final Shape shape, final Predicate<ICombatEntity> condition) {
    final Collection<ICombatEntity> foundCombatEntities = new ArrayList<>();
    if (shape == null) {
      return foundCombatEntities;
    }

    // for rectangle we can just use the intersects method
    if (shape instanceof Rectangle2D) {
      final Rectangle2D rect = (Rectangle2D) shape;
      for (final ICombatEntity combatEntity :
          this.getCombatEntities().stream().filter(condition).collect(Collectors.toList())) {
        if (combatEntity.getHitBox().intersects(rect)) {
          foundCombatEntities.add(combatEntity);
        }
      }

      return foundCombatEntities;
    }

    // for other shapes, we check if the shape's bounds intersect the hitbox and
    // if so, we then check if the actual shape intersects the hitbox
    for (final ICombatEntity combatEntity :
        this.getCombatEntities().stream().filter(condition).collect(Collectors.toList())) {
      if (combatEntity.getHitBox().intersects(shape.getBounds())
          && GeometricUtilities.shapeIntersects(combatEntity.getHitBox(), shape)) {
        foundCombatEntities.add(combatEntity);
      }
    }

    return foundCombatEntities;
  }

  /**
   * Attempts to find all entities whose bounding box intersects with the specified shape.
   *
   * @param shape The shape to check intersection for.
   * @return A collection of all entities that intersect the specified {@link Shape}.
   */
  public Collection<IEntity> findEntities(final Shape shape) {
    final Collection<IEntity> foundEntities = new ArrayList<>();
    if (shape == null) {
      return foundEntities;
    }
    if (shape instanceof Rectangle2D) {
      final Rectangle2D rect = (Rectangle2D) shape;
      for (final IEntity entity : this.allEntities.values()) {
        if (entity.getBoundingBox().intersects(rect)) {
          foundEntities.add(entity);
        }
      }
      return foundEntities;
    }
    // for other shapes, we check if the shape's bounds intersect the hitbox
    // and then we then check if the actual shape intersects the hitbox
    for (final IEntity entity : this.allEntities.values()) {
      if (entity.getBoundingBox().intersects(shape.getBounds())
          && GeometricUtilities.shapeIntersects(entity.getBoundingBox(), shape)) {
        foundEntities.add(entity);
      }
    }

    return foundEntities;
  }

  /**
   * Gets the entity with the specified map ID from this environment.
   *
   * @param mapId The map ID of the entity.
   * @return The entity with the specified map ID or null if no entity could be found.
   */
  @Nullable
  public IEntity get(final int mapId) {
    return this.allEntities.get(mapId);
  }

  /**
   * Gets all entities with the specified map IDs from this environment.
   *
   * @param mapIds The map IDs to search for.
   * @return A {@code List} of entities found, in the order given by the parameters.
   */
  public List<IEntity> get(final int... mapIds) {
    final List<IEntity> foundEntities = new ArrayList<>();
    if (mapIds == null) {
      return foundEntities;
    }

    for (int id : mapIds) {
      IEntity entity = this.allEntities.get(id);
      if (entity != null) {
        foundEntities.add(entity);
      }
    }

    return foundEntities;
  }

  /**
   * Gets the strongly typed entity with the specified map ID from this environment.
   *
   * @param <T> The type of the entity.
   * @param clss The class instance defining the type of the entity.
   * @param mapId The map ID of the entity.
   * @return The strongly typed entity with the specified map ID or null if no entity could be found
   *     or if the defined type doesn't match.
   */
  @Nullable
  public <T extends IEntity> T get(Class<T> clss, int mapId) {
    IEntity ent = this.get(mapId);
    if (ent == null || !clss.isInstance(ent)) {
      return null;
    }

    return clss.cast(ent);
  }

  /**
   * Gets the entity with the specified name from this environment.
   *
   * @param name The name of the entity.
   * @return The entity with the specified name or null if no entity could be found or if the
   *     defined type doesn't match.
   */
  @Nullable
  public IEntity get(final String name) {
    if (name == null || name.isEmpty()) {
      return null;
    }

    for (final IEntity entity : this.allEntities.values()) {
      if (entity.getName() != null && entity.getName().equals(name)) {
        return entity;
      }
    }

    return null;
  }

  /**
   * Gets the strongly typed entity with the specified name from this environment.
   *
   * @param <T> The type of the entity.
   * @param clss The class instance defining the type of the entity.
   * @param name The name of the entity.
   * @return The strongly typed entity with the specified name or null if no entity could be found
   *     or if the defined type doesn't match.
   */
  @Nullable
  public <T extends IEntity> T get(Class<T> clss, String name) {
    IEntity ent = this.get(name);
    if (ent == null || !clss.isInstance(ent)) {
      return null;
    }

    return clss.cast(ent);
  }

  /**
   * Gets a distinct collection of all entities with any of the specified tags.
   *
   * @param tags The tags to search for.
   * @return All entities with any of the specified tags.
   */
  public Collection<IEntity> getByTag(String... tags) {
    Collection<IEntity> foundEntities = new ArrayList<>();
    for (String rawTag : tags) {
      String tag = rawTag.toLowerCase();
      for (IEntity ent : this.getEntitiesByTag().getOrDefault(tag, Arrays.asList())) {
        if (!foundEntities.contains(ent)) {
          foundEntities.add(ent);
        }
      }
    }

    return foundEntities;
  }

  /**
   * Gets a distinct and strongly named collection of all entities with any of the specified tags.
   *
   * @param <T> The type of the entity.
   * @param clss The class instance defining the type of the entity.
   * @param tags The tags to search for.
   * @return All entities with any of the specified tags.
   */
  public <T extends IEntity> Collection<T> getByTag(Class<? extends T> clss, String... tags) {
    Collection<T> foundEntities = new ArrayList<>();
    for (String rawTag : tags) {
      String tag = rawTag.toLowerCase();

      for (IEntity ent : this.getEntitiesByTag().getOrDefault(tag, Arrays.asList())) {
        if (!foundEntities.contains(ent) && clss.isInstance(ent)) {
          foundEntities.add(clss.cast(ent));
        }
      }
    }

    return foundEntities;
  }

  /**
   * Gets the ambient light instance of this environment.
   *
   * @return The ambient light instance of this environment.
   * @see #getStaticShadowLayer()
   */
  @Nullable
  public AmbientLight getAmbientLight() {
    return this.ambientLight;
  }

  /**
   * Gets the static shadow lighting layer of this environment.
   *
   * @return The static shadow lighting layer of this environment.
   * @see #getAmbientLight()
   */
  @Nullable
  public StaticShadowLayer getStaticShadowLayer() {
    return this.staticShadowLayer;
  }

  /**
   * Gets an immutable collection with all assigned map IDs on this environment.
   *
   * @return An immutable collection with all map IDs.
   */
  public Collection<Integer> getAllMapIDs() {
    return Collections.unmodifiableCollection(this.allEntities.keySet());
  }

  /**
   * Gets an immutable collection containing all {@link MapArea} entities on this environment.
   *
   * <p>To add or remove entities, use the corresponding methods on this environment.
   *
   * @return An immutable collection with all {@link MapArea} entities.
   * @see #add(IEntity)
   * @see #addAll(Iterable)
   * @see #remove(IEntity)
   * @see #removeAll(Iterable)
   */
  public Collection<MapArea> getAreas() {
    return Collections.unmodifiableCollection(this.mapAreas);
  }

  /**
   * Gets an immutable collection containing all {@link MapArea} entities with the specified tag.
   *
   * <p>To add or remove entities, use the corresponding methods on this environment.
   *
   * @param tag The tag that the {@link MapArea} entities have to provide to be returned.
   * @return An immutable collection with all {@link MapArea} entities with the specified tag.
   * @see #getAreas()
   * @see #add(IEntity)
   * @see #addAll(Iterable)
   * @see #remove(IEntity)
   * @see #removeAll(Iterable)
   */
  public Collection<MapArea> getAreas(String tag) {
    if (tag == null || tag.isEmpty()) {
      return this.getAreas();
    }

    return Collections.unmodifiableCollection(
        this.mapAreas.stream().filter(p -> p.hasTag(tag)).collect(Collectors.toList()));
  }

  /**
   * Gets the {@link MapArea} with the specified map ID from this environment.
   *
   * @param mapId The map ID of the entity.
   * @return The {@link MapArea} with the specified map ID or null if no entity is found.
   * @see #getArea(String)
   * @see #getAreas()
   */
  @Nullable
  public MapArea getArea(final int mapId) {
    return getById(this.mapAreas, mapId);
  }

  /**
   * Gets the {@link MapArea} with the specified name from this environment.
   *
   * @param name The name of the entity.
   * @return The {@link MapArea} with the specified name or null if no entity is found.
   * @see #getArea(int)
   * @see #getAreas()
   */
  @Nullable
  public MapArea getArea(final String name) {
    return getByName(this.mapAreas, name);
  }

  /**
   * Gets an immutable collection containing all {@link Emitter} entities on this environment.
   *
   * <p>To add or remove entities, use the corresponding methods on this environment.
   *
   * @return An immutable collection with all {@link Emitter} entities.
   * @see #add(IEntity)
   * @see #addAll(Iterable)
   * @see #remove(IEntity)
   * @see #removeAll(Iterable)
   */
  public Collection<Emitter> getEmitters() {
    return Collections.unmodifiableCollection(this.emitters);
  }

  /**
   * Gets an immutable collection containing all {@link Emitter} entities with the specified tag.
   *
   * <p>To add or remove entities, use the corresponding methods on this environment.
   *
   * @param tag The tag that the {@link Emitter} entities have to provide to be returned.
   * @return An immutable collection with all {@link Emitter} entities with the specified tag.
   * @see #getEmitters()
   * @see #add(IEntity)
   * @see #addAll(Iterable)
   * @see #remove(IEntity)
   * @see #removeAll(Iterable)
   */
  public Collection<Emitter> getEmitters(String tag) {
    if (tag == null || tag.isEmpty()) {
      return this.getEmitters();
    }

    return Collections.unmodifiableCollection(
        this.emitters.stream().filter(p -> p.hasTag(tag)).collect(Collectors.toList()));
  }

  /**
   * Gets the {@link Emitter} with the specified map ID from this environment.
   *
   * @param mapId The map ID of the entity.
   * @return The {@link Emitter} with the specified map ID or null if no entity is found.
   * @see #getEmitter(String)
   * @see #getEmitters()
   */
  @Nullable
  public Emitter getEmitter(int mapId) {
    return getById(this.emitters, mapId);
  }

  /**
   * Gets the {@link Emitter} with the specified name from this environment.
   *
   * @param name The name of the entity.
   * @return The {@link Emitter} with the specified name or null if no entity is found.
   * @see #getEmitter(int)
   * @see #getEmitters()
   */
  @Nullable
  public Emitter getEmitter(String name) {
    return getByName(this.emitters, name);
  }

  /**
   * Gets an immutable collection containing all {@link CollisionBox} entities on this environment.
   *
   * <p>To add or remove entities, use the corresponding methods on this environment.
   *
   * @return An immutable collection with all {@link CollisionBox} entities.
   * @see #add(IEntity)
   * @see #addAll(Iterable)
   * @see #remove(IEntity)
   * @see #removeAll(Iterable)
   */
  public Collection<CollisionBox> getCollisionBoxes() {
    return Collections.unmodifiableCollection(this.colliders);
  }

  /**
   * Gets an immutable collection containing all {@link CollisionBox} entities with the specified
   * tag.
   *
   * <p>To add or remove entities, use the corresponding methods on this environment.
   *
   * @param tag The tag that the {@link CollisionBox} entities have to provide to be returned.
   * @return An immutable collection with all {@link CollisionBox} entities with the specified tag.
   * @see #getCollisionBoxes()
   * @see #add(IEntity)
   * @see #addAll(Iterable)
   * @see #remove(IEntity)
   * @see #removeAll(Iterable)
   */
  public Collection<CollisionBox> getCollisionBoxes(String tag) {
    if (tag == null || tag.isEmpty()) {
      return this.getCollisionBoxes();
    }

    return Collections.unmodifiableCollection(
        this.colliders.stream().filter(p -> p.hasTag(tag)).collect(Collectors.toList()));
  }

  /**
   * Gets the {@link CollisionBox} with the specified map ID from this environment.
   *
   * @param mapId The map ID of the entity.
   * @return The {@link CollisionBox} with the specified map ID or null if no entity is found.
   * @see #getCollisionBox(String)
   * @see #getCollisionBoxes()
   */
  @Nullable
  public CollisionBox getCollisionBox(int mapId) {
    return getById(this.colliders, mapId);
  }

  /**
   * Gets the {@link CollisionBox} with the specified name from this environment.
   *
   * @param name The name of the entity.
   * @return The {@link CollisionBox} with the specified name or null if no entity is found.
   * @see #getCollisionBox(int)
   * @see #getCollisionBoxes()
   */
  @Nullable
  public CollisionBox getCollisionBox(String name) {
    return getByName(this.colliders, name);
  }

  /**
   * Gets an immutable collection containing all {@link ICombatEntity} entities on this environment.
   *
   * <p>To add or remove entities, use the corresponding methods on this environment.
   *
   * @return An immutable collection with all {@link ICombatEntity} entities.
   * @see #add(IEntity)
   * @see #addAll(Iterable)
   * @see #remove(IEntity)
   * @see #removeAll(Iterable)
   */
  public Collection<ICombatEntity> getCombatEntities() {
    return Collections.unmodifiableCollection(this.combatEntities.values());
  }

  /**
   * Gets an immutable collection containing all {@link ICombatEntity} entities with the specified
   * tag.
   *
   * <p>To add or remove entities, use the corresponding methods on this environment.
   *
   * @param tag The tag that the {@link ICombatEntity} entities have to provide to be returned.
   * @return An immutable collection with all {@link ICombatEntity} entities with the specified tag.
   * @see #getMobileEntities()
   * @see #add(IEntity)
   * @see #addAll(Iterable)
   * @see #remove(IEntity)
   * @see #removeAll(Iterable)
   */
  public Collection<ICombatEntity> getCombatEntities(String tag) {
    if (tag == null || tag.isEmpty()) {
      return this.getCombatEntities();
    }

    return Collections.unmodifiableCollection(
        this.combatEntities.values().stream()
            .filter(p -> p.hasTag(tag))
            .collect(Collectors.toList()));
  }

  /**
   * Gets the {@link ICombatEntity} with the specified map ID from this environment.
   *
   * @param mapId The map ID of the entity.
   * @return The {@link ICombatEntity} with the specified map ID or null if no entity is found.
   * @see #getCombatEntity(String)
   * @see #getCombatEntities()
   */
  @Nullable
  public ICombatEntity getCombatEntity(final int mapId) {
    return getById(this.combatEntities.values(), mapId);
  }

  /**
   * Gets the {@link ICombatEntity} with the specified name from this environment.
   *
   * @param name The name of the entity.
   * @return The {@link ICombatEntity} with the specified name or null if no entity is found.
   * @see #getCombatEntity(int)
   * @see #getCombatEntities()
   */
  @Nullable
  public ICombatEntity getCombatEntity(String name) {
    return getByName(this.combatEntities.values(), name);
  }

  /**
   * Gets an immutable collection containing all entities on this environment.
   *
   * <p>To add or remove entities, use the corresponding methods on this environment.
   *
   * @return An immutable collection with all entities.
   * @see #add(IEntity)
   * @see #addAll(Iterable)
   * @see #remove(IEntity)
   * @see #removeAll(Iterable)
   */
  public Collection<IEntity> getEntities() {
    return Collections.unmodifiableCollection(this.allEntities.values());
  }

  /**
   * Gets all entities of the specified type on this environment.
   *
   * @param <T> The type of the entity.
   * @param cls The class instance defining the type of the entity.
   * @return All entities of the specified type.
   */
  public <T> Collection<T> getEntities(Class<? extends T> cls) {
    Collection<T> foundEntities = new ArrayList<>();
    for (IEntity ent : this.allEntities.values()) {
      if (cls.isInstance(ent)) {
        foundEntities.add(cls.cast(ent));
      }
    }

    return foundEntities;
  }

  /**
   * Gets all entities of the specified type on this environment.
   *
   * @param <T> The type of the entity.
   * @param cls The class instance defining the type of the entity.
   * @param tag A tag that decides whether the defined entity should be included in the result.
   * @return All entities of the specified type.
   */
  public <T> Collection<T> getEntities(Class<? extends T> cls, String tag) {
    Collection<T> foundEntities = new ArrayList<>();
    for (IEntity ent : this.allEntities.values()) {
      if (cls.isInstance(ent) && ent.hasTag(tag)) {
        foundEntities.add(cls.cast(ent));
      }
    }

    return foundEntities;
  }

  /**
   * Gets all entities of the specified type on this environment.
   *
   * @param <T> The type of the entity.
   * @param cls The class instance defining the type of the entity.
   * @param pred A predicate that decides whether the defined entity should be included in the
   *     result.
   * @return All entities of the specified type.
   */
  public <T> Collection<T> getEntities(Class<? extends T> cls, Predicate<T> pred) {
    Collection<T> foundEntities = new ArrayList<>();
    for (IEntity ent : this.allEntities.values()) {
      if (cls.isInstance(ent)) {
        T entity = cls.cast(ent);

        if (pred.test(entity)) {
          foundEntities.add(entity);
        }
      }
    }

    return foundEntities;
  }

  /**
   * Gets the entities with the specified render type that are not bound to layers.
   *
   * <p>Entities are unbound from there originating {@code MapObjectLayer} if their {@code
   * RenderType} differs from the layer's {@code RenderType}.
   *
   * @param renderType The render type
   * @return The miscellaneous entities with the specified render type
   * @see IEntity#getRenderType()
   * @see ILayer#getRenderType()
   */
  public Collection<IEntity> getEntities(final RenderType renderType) {
    return Collections.unmodifiableCollection(this.miscEntities.get(renderType).values());
```

Give me the fixed code snippet (ONLY THE METHOD REWRITE OF "getEntities(de.gurkenlabs.litiengine.graphics.RenderType)") in XML format in <response> tag like the example below. I will apply the fix to my codebase.
Do not import any additional libraries or classes or java comments.
If you can provide the fixed code snippet, provide it in the following format and place the code snippet in the <code> tag within ```java block.
<response>
  <success>true</success>
  <code><![CDATA[
  ```java
  Your fixed code snippet here
  ```
    ]]>
  </code>
</response>

---ChatGPT.sendRequestToOpenAI---
Sending request to OpenAI...
---ChatGPT.sendRequestToOpenAI---
Response received from OpenAI.
---Response.<init>---
Creating Response:
```xml
<response>
  <success>true</success>
  <code><![CDATA[
  ```java
  public Collection<IEntity> getEntities(final RenderType renderType) {
    Map<Integer, IEntity> entities = this.miscEntities.get(renderType);
    if (entities == null) {
      return Collections.emptyList();
    }
    return Collections.unmodifiableCollection(entities.values());
  }
  ```
  ]]>
  </code>
</response>
```
---Response.<init>---
Response created:
public Collection<IEntity> getEntities(final RenderType renderType) {
    Map<Integer, IEntity> entities = this.miscEntities.get(renderType);
    if (entities == null) {
      return Collections.emptyList();
    }
    return Collections.unmodifiableCollection(entities.values());
  }
