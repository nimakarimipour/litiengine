====================
Type='DEREFERENCE_NULLABLE', message='enhanced-for expression this.collisionEntities.get(collision) is @Nullable'
/home/nima/Developer/nullness-benchmarks/litiengine/src/de/gurkenlabs/litiengine/physics/PhysicsEngine.java:545
    for (final ICollisionEntity collisionEntity : this.collisionEntities.get(collision)) {
Log:
11:47:04.566 TRACE edu.ucr.cs.riple.core.checkers.nullaway.NullAway.lambda$resolveRemainingErrors$19
==============================
11:47:04.566 TRACE edu.ucr.cs.riple.core.checkers.nullaway.NullAway.lambda$resolveRemainingErrors$19
CHATGPT.COUNT = 1
11:47:04.566 TRACE edu.ucr.cs.riple.core.checkers.nullaway.NullAway.lambda$resolveRemainingErrors$19
CHATGPT.PROMPTS SIZE = 1
11:47:04.566 TRACE edu.ucr.cs.riple.core.checkers.nullaway.NullAway.lambda$resolveRemainingErrors$19
Both set to 0 and cleared 0
11:47:04.566 TRACE edu.ucr.cs.riple.core.checkers.nullaway.NullAway.lambda$resolveRemainingErrors$19
119 : TOP LEVEL CALL TO FIX ERROR: Type='DEREFERENCE_NULLABLE', message='enhanced-for expression this.collisionEntities.get(collision) is @Nullable'
/home/nima/Developer/nullness-benchmarks/litiengine/src/de/gurkenlabs/litiengine/physics/PhysicsEngine.java:545
    for (final ICollisionEntity collisionEntity : this.collisionEntities.get(collision)) {
11:47:06.071 TRACE edu.ucr.cs.riple.core.checkers.nullaway.codefix.ChatGPT.ask
Asking ChatGPT:
I want to resolve a warning reported by NullAway.
The error is of the type of "DEREFERENCE_NULLABLE" and the full error message is: "enhanced-for expression this.collisionEntities.get(collision) is @Nullable".
The line with the error is: "    for (final ICollisionEntity collisionEntity : this.collisionEntities.get(collision)) {".

The error is within "the method: raycast(java.awt.geom.Line2D,de.gurkenlabs.litiengine.physics.Collision,de.gurkenlabs.litiengine.entities.ICollisionEntity)" and the code surrounding the error is:
```java
   */
  @Nullable
  public RaycastHit raycast(Line2D line, ICollisionEntity entity) {
    return raycast(line, Collision.ANY, entity);
  }

  /**
   * Cast a ray along a given line [from (x1,y1) to (x2,y2)] and see if it hits anything with a
   * certain {@code Collision} type that collides with the given {@code ICollisionEntity}.
   *
   * @param line The line along which the ray is cast.
   * @param collision The {@code Collision} type to check for collision.
   * @param entity The {@code ICollisionEntity} type to check for collision.
   * @return A {@code RaycastHit} determining the hit point, ray length, and corresponding {@code
   *     ICollisionEntity}.
   */
  @Nullable
  public RaycastHit raycast(Line2D line, Collision collision, @Nullable ICollisionEntity entity) {
    final Point2D rayCastSource = new Point2D.Double(line.getX1(), line.getY1());

    for (final ICollisionEntity collisionEntity : this.collisionEntities.get(collision)) {
      if (!canCollide(entity, collisionEntity)) {
        continue;
      }

      if (collisionEntity.getCollisionBox().intersectsLine(line)) {
        double closestDist = -1;
        Point2D closestPoint = null;
        for (final Point2D intersection :
            GeometricUtilities.getIntersectionPoints(line, collisionEntity.getCollisionBox())) {
          final double dist = intersection.distance(rayCastSource);
          if (closestPoint == null || dist < closestDist) {
            closestPoint = intersection;
            closestDist = dist;
          }
        }

        return new RaycastHit(closestPoint, collisionEntity, closestDist);
      }
    }

    return null;
```

Give me the fixed code snippet (ONLY THE METHOD REWRITE OF "raycast(java.awt.geom.Line2D,de.gurkenlabs.litiengine.physics.Collision,de.gurkenlabs.litiengine.entities.ICollisionEntity)") in XML format in <response> tag like the example below. I will apply the fix to my codebase.
Do not import any additional libraries or classes or java comments.
If you can provide the fixed code snippet, provide it in the following format and place the code snippet in the <code> tag within ```java block.
<response>
  <success>true</success>
  <code><![CDATA[
  ```java
  Your fixed code snippet here
  ```
    ]]>
  </code>
</response>

11:47:06.071 TRACE edu.ucr.cs.riple.core.checkers.nullaway.codefix.ChatGPT.ask
Retrieving response from cache
11:47:06.071 TRACE edu.ucr.cs.riple.core.checkers.nullaway.codefix.Response.tryCreate
Trying to create Response:
```xml
<response>
  <success>true</success>
  <code><![CDATA[
  ```java
  public RaycastHit raycast(Line2D line, Collision collision, ICollisionEntity entity) {
    final Point2D rayCastSource = new Point2D.Double(line.getX1(), line.getY1());
    Collection<ICollisionEntity> collisionEntitiesForType = this.collisionEntities.get(collision);

    if (collisionEntitiesForType == null) {
      return null;
    }

    for (final ICollisionEntity collisionEntity : collisionEntitiesForType) {
      if (!canCollide(entity, collisionEntity)) {
        continue;
      }

      if (collisionEntity.getCollisionBox().intersectsLine(line)) {
        double closestDist = -1;
        Point2D closestPoint = null;
        for (final Point2D intersection : GeometricUtilities.getIntersectionPoints(line, collisionEntity.getCollisionBox())) {
          final double dist = intersection.distance(rayCastSource);
          if (closestPoint == null || dist < closestDist) {
            closestPoint = intersection;
            closestDist = dist;
          }
        }

        return new RaycastHit(closestPoint, collisionEntity, closestDist);
      }
    }

    return null;
  }
  ```
  ]]>
  </code>
</response>
```
11:47:06.072 TRACE edu.ucr.cs.riple.core.checkers.nullaway.codefix.Response.<init>
Creating Response:
```xml
<response>
  <success>true</success>
  <code><![CDATA[
  ```java
  public RaycastHit raycast(Line2D line, Collision collision, ICollisionEntity entity) {
    final Point2D rayCastSource = new Point2D.Double(line.getX1(), line.getY1());
    Collection<ICollisionEntity> collisionEntitiesForType = this.collisionEntities.get(collision);

    if (collisionEntitiesForType == null) {
      return null;
    }

    for (final ICollisionEntity collisionEntity : collisionEntitiesForType) {
      if (!canCollide(entity, collisionEntity)) {
        continue;
      }

      if (collisionEntity.getCollisionBox().intersectsLine(line)) {
        double closestDist = -1;
        Point2D closestPoint = null;
        for (final Point2D intersection : GeometricUtilities.getIntersectionPoints(line, collisionEntity.getCollisionBox())) {
          final double dist = intersection.distance(rayCastSource);
          if (closestPoint == null || dist < closestDist) {
            closestPoint = intersection;
            closestDist = dist;
          }
        }

        return new RaycastHit(closestPoint, collisionEntity, closestDist);
      }
    }

    return null;
  }
  ```
  ]]>
  </code>
</response>
```
11:47:06.073 TRACE edu.ucr.cs.riple.core.checkers.nullaway.codefix.Response.<init>
Response created:
public RaycastHit raycast(Line2D line, Collision collision, ICollisionEntity entity) {
    final Point2D rayCastSource = new Point2D.Double(line.getX1(), line.getY1());
    Collection<ICollisionEntity> collisionEntitiesForType = this.collisionEntities.get(collision);

    if (collisionEntitiesForType == null) {
      return null;
    }

    for (final ICollisionEntity collisionEntity : collisionEntitiesForType) {
      if (!canCollide(entity, collisionEntity)) {
        continue;
      }

      if (collisionEntity.getCollisionBox().intersectsLine(line)) {
        double closestDist = -1;
        Point2D closestPoint = null;
        for (final Point2D intersection : GeometricUtilities.getIntersectionPoints(line, collisionEntity.getCollisionBox())) {
          final double dist = intersection.distance(rayCastSource);
          if (closestPoint == null || dist < closestDist) {
            closestPoint = intersection;
            closestDist = dist;
          }
        }

        return new RaycastHit(closestPoint, collisionEntity, closestDist);
      }
    }

    return null;
  }
