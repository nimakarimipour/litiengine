====================
Type='RETURN_NULLABLE', message='returning @Nullable expression from method with @NonNull return type'
/home/nima/Developer/nullness-benchmarks/litiengine/src/de/gurkenlabs/litiengine/attributes/AttributeModifier.java:132
    return null;
Log:
---NullAway.lambda$resolveRemainingErrors$17---
==============================
---NullAway.lambda$resolveRemainingErrors$17---
TOP LEVEL CALL TO FIX ERROR: Type='RETURN_NULLABLE', message='returning @Nullable expression from method with @NonNull return type'
/home/nima/Developer/nullness-benchmarks/litiengine/src/de/gurkenlabs/litiengine/attributes/AttributeModifier.java:132
    return null;
---ChatGPT.ask---
Asking ChatGPT:
I want to resolve a warning reported by NullAway.
The error is of the type of "RETURN_NULLABLE" and the full error message is: "returning @Nullable expression from method with @NonNull return type".
The line with the error is: "    return null;".

The error is within "the method: ensureType(java.lang.Double,T)" and the code surrounding the error is:
```java
package de.gurkenlabs.litiengine.attributes;

/**
 * An attribute modifier allows to modify attributes by the specified Modification and modify value.
 *
 * @param <T> the generic type
 * @see Attribute#addModifier(AttributeModifier)
 * @see Attribute#modifyBaseValue(AttributeModifier)
 */
public class AttributeModifier<T extends Number> implements Comparable<AttributeModifier<T>> {
  private final Modification modification;
  private double modifyValue;
  private boolean active;

  /**
   * Initializes a new instance of the {@code AttributeModifier} class.
   *
   * @param mod The modification type.
   * @param modifyValue The modification value to be applied by this instance.
   */
  public AttributeModifier(final Modification mod, final double modifyValue) {
    this.modification = mod;
    this.modifyValue = modifyValue;
    this.active = true;
  }

  @Override
  public int compareTo(final AttributeModifier<T> otherModifier) {
    return Integer.compare(
        this.getModification().getApplyOrder(), otherModifier.getModification().getApplyOrder());
  }

  @Override
  public boolean equals(Object obj) {
    if (obj instanceof AttributeModifier<?>) {
      AttributeModifier<?> attr = (AttributeModifier<?>) obj;
      return this.isActive() == attr.isActive()
          && this.getModification() == attr.getModification()
          && this.getModifyValue() == attr.getModifyValue();
    }

    return super.equals(obj);
  }

  @Override
  public int hashCode() {
    return super.hashCode();
  }

  /**
   * Gets the modification type applied by this modifier.
   *
   * @return The modification type applied by this modifier.
   */
  public Modification getModification() {
    return this.modification;
  }

  /**
   * Gets the value that is used to modify an attribute.
   *
   * @return The value that is used to modify an attribute.
   */
  public double getModifyValue() {
    return this.modifyValue;
  }

  public boolean isActive() {
    return active;
  }

  public T modify(final T modvalue) {
    if (!this.isActive()) {
      return modvalue;
    }

    switch (this.getModification()) {
      case ADD:
        return this.ensureType(
            Double.valueOf(modvalue.doubleValue() + this.getModifyValue()), modvalue);
      case SUBTRACT:
        return this.ensureType(
            Double.valueOf(modvalue.doubleValue() - this.getModifyValue()), modvalue);
      case MULTIPLY:
        return this.ensureType(
            Double.valueOf(modvalue.doubleValue() * this.getModifyValue()), modvalue);
      case DIVIDE:
        return this.ensureType(
            Double.valueOf(modvalue.doubleValue() / this.getModifyValue()), modvalue);
      case ADDPERCENT:
        return this.ensureType(
            Double.valueOf(
                modvalue.doubleValue() + modvalue.doubleValue() / 100 * this.getModifyValue()),
            modvalue);
      case SUBTRACTPERCENT:
        return this.ensureType(
            Double.valueOf(
                modvalue.doubleValue() - modvalue.doubleValue() / 100 * this.getModifyValue()),
            modvalue);
      case SET:
        return this.ensureType(Double.valueOf(this.getModifyValue()), modvalue);
      case UNKNOWN:
      default:
        return modvalue;
    }
  }

  public void setModifyValue(double value) {
    this.modifyValue = value;
  }

  public void setActive(boolean active) {
    this.active = active;
  }

  @SuppressWarnings("unchecked")
  private T ensureType(final Double modValue, final T originalValue) {
    if (originalValue instanceof Double) {
      return (T) modValue;
    } else if (originalValue instanceof Float) {
      return (T) Float.valueOf(modValue.floatValue());
    } else if (originalValue instanceof Long) {
      return (T) Long.valueOf(modValue.longValue());
    } else if (originalValue instanceof Byte) {
      return (T) Byte.valueOf(modValue.byteValue());
    } else if (originalValue instanceof Short) {
      return (T) Short.valueOf(modValue.shortValue());
    } else if (originalValue instanceof Integer) {
      return (T) Integer.valueOf(modValue.intValue());
    }

    return null;
```

Give me the fixed code snippet (ONLY THE METHOD REWRITE OF "ensureType(java.lang.Double,T)") in XML format in <response> tag like the example below. I will apply the fix to my codebase.
Do not import any additional libraries or classes or java comments.
If you can provide the fixed code snippet, provide it in the following format and place the code snippet in the <code> tag within ```java block.
<response>
  <success>true</success>
  <code><![CDATA[
  ```java
  Your fixed code snippet here
  ```
    ]]>
  </code>
</response>

---ChatGPT.sendRequestToOpenAI---
Sending request to OpenAI...
---ChatGPT.sendRequestToOpenAI---
Response received from OpenAI.
---Response.<init>---
Creating Response:
```xml
<response>
  <success>true</success>
  <code><![CDATA[
  ```java
  @SuppressWarnings("unchecked")
  private T ensureType(final Double modValue, final T originalValue) {
    if (originalValue instanceof Double) {
      return (T) modValue;
    } else if (originalValue instanceof Float) {
      return (T) Float.valueOf(modValue.floatValue());
    } else if (originalValue instanceof Long) {
      return (T) Long.valueOf(modValue.longValue());
    } else if (originalValue instanceof Byte) {
      return (T) Byte.valueOf(modValue.byteValue());
    } else if (originalValue instanceof Short) {
      return (T) Short.valueOf(modValue.shortValue());
    } else if (originalValue instanceof Integer) {
      return (T) Integer.valueOf(modValue.intValue());
    }

    throw new IllegalArgumentException("Unsupported type: " + originalValue.getClass());
  }
  ```
    ]]>
  </code>
</response>
```
---Response.<init>---
Response created:
@SuppressWarnings("unchecked")
  private T ensureType(final Double modValue, final T originalValue) {
    if (originalValue instanceof Double) {
      return (T) modValue;
    } else if (originalValue instanceof Float) {
      return (T) Float.valueOf(modValue.floatValue());
    } else if (originalValue instanceof Long) {
      return (T) Long.valueOf(modValue.longValue());
    } else if (originalValue instanceof Byte) {
      return (T) Byte.valueOf(modValue.byteValue());
    } else if (originalValue instanceof Short) {
      return (T) Short.valueOf(modValue.shortValue());
    } else if (originalValue instanceof Integer) {
      return (T) Integer.valueOf(modValue.intValue());
    }

    throw new IllegalArgumentException("Unsupported type: " + originalValue.getClass());
  }
